<!DOCTYPE html><html><head><title>Help for package MGDrivE2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MGDrivE2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_interventions'><p>This set of functions modifies mosquito life history parameters in the presence of</p>
adult interventions - indoor residual spraying (IRS) and insecticide treated nets (ITN)
This is based on the work of Le Menach et al (2007) and Griffin et al (2010).
We vary three parameters in the presence of interventions:
Egg laying rate (beta),
Adult mortality (muF),
Mosquito biting rate (av0)</a></li>
<li><a href='#base_aquatic_geno'><p>Base Aquatic Function for Genotype Summary</p></a></li>
<li><a href='#base_aquatic_stage'><p>Base Aquatic Function for Erlang-Stage Summary</p></a></li>
<li><a href='#base_erlang'><p>Base Summary of Erlang Stages for Aquatic Life Stages</p></a></li>
<li><a href='#base_erlang_F'><p>Base Summary of Erlang Stages for Adult Females</p></a></li>
<li><a href='#base_gen'><p>Base Summary for Eggs, Larvae, Pupae, Susceptible Females, and Infectious Females</p></a></li>
<li><a href='#base_gen_FE'><p>Base Summary for Latent Females</p></a></li>
<li><a href='#base_MQ'><p>Base Summary Function</p></a></li>
<li><a href='#base_MUH'><p>Base Summary for Males, Unmated Females, and Humans</p></a></li>
<li><a href='#base_sum_F'><p>Base Summary of Infection (SEI) Stages for Adult Females</p></a></li>
<li><a href='#base_summarize_humans'><p>Base Function for Human Summary</p></a></li>
<li><a href='#batch_migration'><p>Sample Batch Migration Events</p></a></li>
<li><a href='#batch_migration_stage'><p>Internal function to sample and set up data structure for batch migration</p></a></li>
<li><a href='#calc_move_rate'><p>Calculate Outbound Movement Rate</p></a></li>
<li><a href='#convert_prevalence_to_eir'><p>Generally, pathogen prevalence is a more accesible metric for users, but</p>
the Imperial equilibrium function requires an annual EIR.
This function converts a given pathogen prevalence to an EIR</a></li>
<li><a href='#equilibrium_Imperial_decoupled'><p>This function calculates the human and mosquito equilibrium values for the decoupled Imperial model.</p>
Currently this only works in one node.</a></li>
<li><a href='#equilibrium_Imperial_decoupled_human'><p>This function calculates the human equilibrium values for the decoupled Imperial model.</p>
Requires the age structure of the population
Currently this only works in one node.</a></li>
<li><a href='#equilibrium_lifeycle'><p>Calculate Equilibrium for Lifecycle Model (Logistic or Lotka-Volterra)</p></a></li>
<li><a href='#equilibrium_SEI_decoupled_human'><p>This function calculates the equilibrium values for the decoupled SIS human states.</p>
Currently this only works in one node.</a></li>
<li><a href='#equilibrium_SEI_decoupled_mosy'><p>Calculate Equilibrium for Decoupled Mosquito SEI model. Human states will be handled separately.</p></a></li>
<li><a href='#equilibrium_SEI_Imperial'><p>Calculate Equilibrium for Mosquito SEI - Human Imperial Model</p></a></li>
<li><a href='#equilibrium_SEI_SEIR'><p>Calculate Equilibrium for Mosquito SEI - Human SEIR Model</p></a></li>
<li><a href='#equilibrium_SEI_SIS'><p>Calculate Equilibrium for Mosquito SEI - Human SIS Model</p></a></li>
<li><a href='#get_shape'><p>Calculate Erlang shape parameter</p></a></li>
<li><a href='#human_Imperial_ODE'><p>ODE describing the age-structured Imperial model</p>
used in decoupled sampling, which will pass in values of I_V and
return the human states for usein the mosquito portion of the model</a></li>
<li><a href='#imperial_model_param_list_create'><p>Model Parameter List Creation</p></a></li>
<li><a href='#make_Q_Imperial'><p>Rate Matrix (Q) for Adult Mosquito SEI Dynamics</p></a></li>
<li><a href='#make_Q_SEI'><p>Rate Matrix (Q) for Adult Mosquito SEI Dynamics</p></a></li>
<li><a href='#movement_prob2rate'><p>Convert Stochastic Matrix to Rate Matrix</p></a></li>
<li><a href='#mu_ts'><p>Mosquito Death Rates, Comoros Islands</p></a></li>
<li><a href='#sim_trajectory_base_CSV'><p>Simulate Trajectory From one  SPN Model</p></a></li>
<li><a href='#sim_trajectory_base_CSV_decoupled'><p>Simulate Trajectory From one  SPN Model</p></a></li>
<li><a href='#sim_trajectory_base_R'><p>Simulate Trajectory From one SPN Model</p></a></li>
<li><a href='#sim_trajectory_base_R_decoupled_Imperial'><p>Simulate Trajectory From one SPN Model using Imperial Malaria model</p></a></li>
<li><a href='#sim_trajectory_base_R_decoupled_SIS'><p>Simulate Trajectory From one SPN Model using Human SIS model</p></a></li>
<li><a href='#sim_trajectory_CSV'><p>Simulate Trajectory From a SPN Model</p></a></li>
<li><a href='#sim_trajectory_CSV_decoupled'><p>Simulate Trajectory From a SPN Model</p></a></li>
<li><a href='#sim_trajectory_R'><p>Simulate Trajectory From a SPN Model</p></a></li>
<li><a href='#sim_trajectory_R_decoupled'><p>Simulate Trajectory From a SPN Model</p></a></li>
<li><a href='#solve_muAqua'><p>Solve for Constant Aquatic Mortality</p></a></li>
<li><a href='#split_aggregate_CSV'><p>Split CSV output by Patch and Aggregate by Mate or Dwell-Stage</p></a></li>
<li><a href='#split_aggregate_CSV_decoupled'><p>Split CSV output for decoupled sampling with Imperial malaria model</p></a></li>
<li><a href='#spn_hazards'><p>Make Hazards (Lambda) For a MGDrivE2: Node and Network Simulations</p></a></li>
<li><a href='#spn_hazards_decoupled'><p>Make Hazards (Lambda) For a MGDrivE2: Node and Network Simulations</p></a></li>
<li><a href='#spn_P_epi_decoupled_node'><p>Make Places (P) For a Node (SEI Mosquitoes). Note in the v2 epi module, we only</p>
use the SPN framework for the mosquito component of the model. The human compoenent
will be handled separately in the sampler, and will be formulated as an ODE.
This function makes the set of places (P) for a SPN. It is used alone if our model
is a single-node metapopulation for mosquito SEI and dynamics; This is used by both
SIS and Imperial transmission models.</a></li>
<li><a href='#spn_P_epiSEIR_network'><p>Make Places (P) For a Network (SEI Mosquitoes - SEIR Humans)</p></a></li>
<li><a href='#spn_P_epiSEIR_node'><p>Make Places (P) For a Node (SEI Mosquitoes - SEIR Humans)</p></a></li>
<li><a href='#spn_P_epiSIS_network'><p>Make Places (P) For a Network (SEI Mosquitoes - SIS Humans)</p></a></li>
<li><a href='#spn_P_epiSIS_node'><p>Make Places (P) For a Node (SEI Mosquitoes - SIS Humans)</p></a></li>
<li><a href='#spn_P_lifecycle_network'><p>Make Places (P) For a Network (Mosquitoes only)</p></a></li>
<li><a href='#spn_P_lifecycle_node'><p>Make Places (P) For a Node (Mosquitoes only)</p></a></li>
<li><a href='#spn_Post'><p>Make Post Matrix For a Petri Net</p></a></li>
<li><a href='#spn_Pre'><p>Make Pre Matrix For a Petri Net</p></a></li>
<li><a href='#spn_S'><p>Make stoichiometry Matrix For a Petri Net</p></a></li>
<li><a href='#spn_T_epi_decoupled_node'><p>Make Transitions (T) For a Node (SEI Mosquitoes)</p></a></li>
<li><a href='#spn_T_epiSEIR_network'><p>Make Transitions (T) For a Network (SEI Mosquitoes - SEIR Humans)</p></a></li>
<li><a href='#spn_T_epiSEIR_node'><p>Make Transitions (T) For a Node (SEI Mosquitoes - SEIR Humans)</p></a></li>
<li><a href='#spn_T_epiSIS_network'><p>Make Transitions (T) For a Network (SEI Mosquitoes - SIS Humans)</p></a></li>
<li><a href='#spn_T_epiSIS_node'><p>Make Transitions (T) For a Node (SEI Mosquitoes - SIS Humans)</p></a></li>
<li><a href='#spn_T_lifecycle_network'><p>Make Transitions (T) For a Network (Mosquitoes only)</p></a></li>
<li><a href='#spn_T_lifecycle_node'><p>Make Transitions (T) For a Node (Mosquitoes only)</p></a></li>
<li><a href='#step_CLE'><p>Make Chemical Langevin (CLE) Sampler for a SPN model</p></a></li>
<li><a href='#step_DM'><p>Make Gillespie's Direct Method (DM) Sampler for a SPN model</p></a></li>
<li><a href='#step_ODE'><p>Make Mean-field Approximation (ODE) Numerical Integrator for a SPN Model</p></a></li>
<li><a href='#step_ODE_decoupled'><p>Make Mean-field Approximation (ODE) Numerical Integrator for a SPN Model for Decoupled Epi Dynamics</p></a></li>
<li><a href='#step_PTS'><p>Make Poisson Time-Step (PTS) Sampler for a SPN Model</p></a></li>
<li><a href='#step_PTS_decoupled'><p>Make Poisson Time-Step (PTS) Sampler for a SPN Model</p></a></li>
<li><a href='#summarize_eggs_geno'><p>Summarize Eggs by Genotype</p></a></li>
<li><a href='#summarize_eggs_stage'><p>Summarize Eggs by Erlang-Stage</p></a></li>
<li><a href='#summarize_females'><p>Summarize Adult Females (One Node or Metapopulation Network, Lifecycle Model)</p></a></li>
<li><a href='#summarize_females_epi'><p>Summarize Adult Females (One Node or Metapopulation Network, SEI Mosquitoes)</p></a></li>
<li><a href='#summarize_humans_epiImperial'><p>Summarize Humans for Imperial Model</p></a></li>
<li><a href='#summarize_humans_epiSEIR'><p>Summarize Humans (One Node or Metapopulation Network, SEI Mosquitoes - SEIR Humans)</p></a></li>
<li><a href='#summarize_humans_epiSIS'><p>Summarize Humans (One Node or Metapopulation Network, SEI Mosquitoes - SIS Humans)</p></a></li>
<li><a href='#summarize_larvae_geno'><p>Summarize Larvae by Genotype</p></a></li>
<li><a href='#summarize_larvae_stage'><p>Summarize Larval by Erlang-Stage</p></a></li>
<li><a href='#summarize_males'><p>Summarize Adult Males (One Node or Metapopulation Network)</p></a></li>
<li><a href='#summarize_pupae_geno'><p>Summarize Pupal by Genotype</p></a></li>
<li><a href='#summarize_pupae_stage'><p>Summarize Pupal by Erlang-Stage</p></a></li>
<li><a href='#summarize_stats_CSV'><p>Summary Statistics for MGDrivE2</p></a></li>
<li><a href='#summarize_stats_CSV_decoupled'><p>Summary Statistics for MGDrivE2 - Decoupled samples</p></a></li>
<li><a href='#track_hinf'><p>Make tracking matrix for human infection events</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mosquito Gene Drive Explorer 2</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Agastya Mondal &lt;amondal13@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marshalllab.github.io/MGDrivE/docs_v2/index.html">https://marshalllab.github.io/MGDrivE/docs_v2/index.html</a>,
<a href="https://www.marshalllab.com/">https://www.marshalllab.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MarshallLab/MGDrivE/issues">https://github.com/MarshallLab/MGDrivE/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A simulation modeling framework which significantly extends capabilities from the
    'MGDrivE' simulation package via a new mathematical and computational framework based on stochastic Petri nets.
    For more information about 'MGDrivE', see our publication: Sánchez et al. (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13318">doi:10.1111/2041-210X.13318</a>&gt;
    Some of the notable capabilities of 'MGDrivE2' include: incorporation of human populations,
    epidemiological dynamics, time-varying parameters, and a continuous-time simulation
    framework with various sampling algorithms for both deterministic and stochastic interpretations.
    'MGDrivE2' relies on the genetic inheritance structures provided in package 'MGDrivE', so we
    suggest installing that package initially.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, deSolve, statmod</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MGDrivE, knitr, rmarkdown, markdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-03 19:55:27 UTC; agastyamondal</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean L. Wu [aut],
  Jared B. Bennett [aut],
  Héctor Manuel Sánchez Castellanos [ctb],
  Tomás M. León [ctb],
  Andrew J. Dolgert [ctb],
  John M. Marshall [aut],
  Agastya Mondal [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-04 07:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_interventions'>This set of functions modifies mosquito life history parameters in the presence of
adult interventions - indoor residual spraying (IRS) and insecticide treated nets (ITN)
This is based on the work of Le Menach et al (2007) and Griffin et al (2010).
We vary three parameters in the presence of interventions:
Egg laying rate (beta),
Adult mortality (muF),
Mosquito biting rate (av0)</h2><span id='topic+add_interventions'></span>

<h3>Description</h3>

<p>This set of functions modifies mosquito life history parameters in the presence of
adult interventions - indoor residual spraying (IRS) and insecticide treated nets (ITN)
This is based on the work of Le Menach et al (2007) and Griffin et al (2010).
We vary three parameters in the presence of interventions:
Egg laying rate (beta),
Adult mortality (muF),
Mosquito biting rate (av0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_interventions(params, IRS_cov, LLIN_cov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_interventions_+3A_params">params</code></td>
<td>
<p>a named list of parameters</p>
</td></tr>
<tr><td><code id="add_interventions_+3A_irs_cov">IRS_cov</code></td>
<td>
<p>proportion of humans in the node receiving IRS</p>
</td></tr>
<tr><td><code id="add_interventions_+3A_llin_cov">LLIN_cov</code></td>
<td>
<p>proportion of humans in the node receiving LLIN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the equilibrium number of females in each SEI stage
</p>

<hr>
<h2 id='base_aquatic_geno'>Base Aquatic Function for Genotype Summary</h2><span id='topic+base_aquatic_geno'></span>

<h3>Description</h3>

<p>This function takes a given aquatic (egg, larval, pupal) stage and sums over
the Erlang-distributed stages, returning summary trajectories by genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_aquatic_geno(out, spn_P, elp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_aquatic_geno_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="base_aquatic_geno_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
<tr><td><code id="base_aquatic_geno_+3A_elp">elp</code></td>
<td>
<p>stage to summarize, one of: &quot;egg&quot;, &quot;larvae&quot;, &quot;pupae&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the base function for <code><a href="#topic+summarize_eggs_geno">summarize_eggs_geno</a></code>,
<code><a href="#topic+summarize_larvae_geno">summarize_larvae_geno</a></code>, and <code><a href="#topic+summarize_pupae_geno">summarize_pupae_geno</a></code>.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='base_aquatic_stage'>Base Aquatic Function for Erlang-Stage Summary</h2><span id='topic+base_aquatic_stage'></span>

<h3>Description</h3>

<p>This function takes a given aquatic (egg, larval, pupal) stage and sums over
the genotypes, returning summary trajectories by Erlang-distributed stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_aquatic_stage(out, spn_P, elp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_aquatic_stage_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="base_aquatic_stage_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
<tr><td><code id="base_aquatic_stage_+3A_elp">elp</code></td>
<td>
<p>stage to summarize, one of: &quot;egg&quot;, &quot;larvae&quot;, &quot;pupae&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the base function for <code><a href="#topic+summarize_eggs_stage">summarize_eggs_stage</a></code>,
<code><a href="#topic+summarize_larvae_stage">summarize_larvae_stage</a></code>, and <code><a href="#topic+summarize_pupae_stage">summarize_pupae_stage</a></code>.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>Erlang-stage</code>, and <code>value</code>.
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='base_erlang'>Base Summary of Erlang Stages for Aquatic Life Stages</h2><span id='topic+base_erlang'></span>

<h3>Description</h3>

<p>This function takes the given aquatic stage and summarizes them by Erlang-distributed
dwell times, writing output to provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_erlang(fileVec, outList, genos, nGenos, nErlang, times, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_erlang_+3A_filevec">fileVec</code></td>
<td>
<p>Vector of files for analysis</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_genos">genos</code></td>
<td>
<p>Genotypes to summarize by</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_nerlang">nErlang</code></td>
<td>
<p>Number of Erlang stages</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_erlang_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_erlang_F'>Base Summary of Erlang Stages for Adult Females</h2><span id='topic+base_erlang_F'></span>

<h3>Description</h3>

<p>This function takes ALL of the adult female stages and summarized them by
Erlang-distributed latent infection, writing output to provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_erlang_F(fileList, outList, nGenos, nErlang, times, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_erlang_F_+3A_filelist">fileList</code></td>
<td>
<p>Length 3 list holding 'FS','FE', and 'FI' files for analysis</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_nerlang">nErlang</code></td>
<td>
<p>Number of Erlang stages</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_erlang_F_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_gen'>Base Summary for Eggs, Larvae, Pupae, Susceptible Females, and Infectious Females</h2><span id='topic+base_gen'></span>

<h3>Description</h3>

<p>This function takes a given stage and summarizes them by genotype, writing
output to provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_gen(fileVec, outList, genos, nGenos, nIDX1, times, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_gen_+3A_filevec">fileVec</code></td>
<td>
<p>Vector of files for analysis</p>
</td></tr>
<tr><td><code id="base_gen_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_gen_+3A_genos">genos</code></td>
<td>
<p>Genotypes to summarize by</p>
</td></tr>
<tr><td><code id="base_gen_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_gen_+3A_nidx1">nIDX1</code></td>
<td>
<p>First index to expand over, nE/nL/nP for aquatic stages, 1 for the rest</p>
</td></tr>
<tr><td><code id="base_gen_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_gen_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_gen_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_gen_FE'>Base Summary for Latent Females</h2><span id='topic+base_gen_FE'></span>

<h3>Description</h3>

<p>This function takes 'E' stage females and summarizes them by genotype, writing
output to provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_gen_FE(fileVec, outList, genos, nGenos, nIDX1, times, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_gen_FE_+3A_filevec">fileVec</code></td>
<td>
<p>Vector of files for analysis</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_genos">genos</code></td>
<td>
<p>Genotypes to summarize by</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_nidx1">nIDX1</code></td>
<td>
<p>First index to expand over, nE/nL/nP for aquatic stages, 1 for the rest</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_gen_FE_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_MQ'>Base Summary Function</h2><span id='topic+base_MQ'></span>

<h3>Description</h3>

<p>This function does the actual calculations for <code><a href="#topic+summarize_stats_CSV">summarize_stats_CSV</a></code>.
It calculates mean and quantiles, writing output to the appropriate folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_MQ(
  fList,
  oDir,
  sName,
  nodeNames,
  nNodes,
  genos,
  nGenos,
  times,
  nTimes,
  num_repss,
  mean,
  quantiles,
  oDepth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_MQ_+3A_flist">fList</code></td>
<td>
<p>File list, all files for this stage, organized by repetition</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_odir">oDir</code></td>
<td>
<p>Output directory</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_sname">sName</code></td>
<td>
<p>Stage signifier</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_nodenames">nodeNames</code></td>
<td>
<p>Properly formatted vector of node names for printing</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the simulation</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_genos">genos</code></td>
<td>
<p>Vector of genotypes for the header</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_num_repss">num_repss</code></td>
<td>
<p>Number of repetitions from the simulation</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_mean">mean</code></td>
<td>
<p>Boolean, calculate mean or not</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles to calculate, or NULL</p>
</td></tr>
<tr><td><code id="base_MQ_+3A_odepth">oDepth</code></td>
<td>
<p>Max(1, number of quantiles)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_MUH'>Base Summary for Males, Unmated Females, and Humans</h2><span id='topic+base_MUH'></span>

<h3>Description</h3>

<p>This function takes a given stage (males, unmated females, or humans) and
summarizes them by genotype (infection status for humans), writing output to
provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_MUH(fileVec, outList, genos, nGenos, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_MUH_+3A_filevec">fileVec</code></td>
<td>
<p>Vector of files for analysis</p>
</td></tr>
<tr><td><code id="base_MUH_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_MUH_+3A_genos">genos</code></td>
<td>
<p>Genotypes to summarize by</p>
</td></tr>
<tr><td><code id="base_MUH_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_MUH_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_MUH_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_sum_F'>Base Summary of Infection (SEI) Stages for Adult Females</h2><span id='topic+base_sum_F'></span>

<h3>Description</h3>

<p>This function takes ALL of the adult female stages and summarized them by
Erlang-distributed latent infection, writing output to provided folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_sum_F(fileList, outList, genos, nGenos, nErlang, times, nTimes, nNodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_sum_F_+3A_filelist">fileList</code></td>
<td>
<p>Length 3 list holding 'FS','FE', and 'FI' files for analysis</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_outlist">outList</code></td>
<td>
<p>List of files, organized by repetition, to write output</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_genos">genos</code></td>
<td>
<p>Genotypes to summarize by</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_ngenos">nGenos</code></td>
<td>
<p>Number of genotypes</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_nerlang">nErlang</code></td>
<td>
<p>Number of Erlang stages</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_times">times</code></td>
<td>
<p>Vector of sampling times</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_ntimes">nTimes</code></td>
<td>
<p>Number of sampled times</p>
</td></tr>
<tr><td><code id="base_sum_F_+3A_nnodes">nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a base function used in <code><a href="#topic+split_aggregate_CSV">split_aggregate_CSV</a></code>.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='base_summarize_humans'>Base Function for Human Summary</h2><span id='topic+base_summarize_humans'></span>

<h3>Description</h3>

<p>This function takes a given infection ('S','E','I','R') status and returns a
summary trajectory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_summarize_humans(out, infState)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_summarize_humans_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="base_summarize_humans_+3A_infstate">infState</code></td>
<td>
<p>type of humans to summarize: 'S','E','I','R'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the base function for <code><a href="#topic+summarize_humans_epiSIS">summarize_humans_epiSIS</a></code>,
<code><a href="#topic+summarize_humans_epiSEIR">summarize_humans_epiSEIR</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>inf</code>, <code>genotype</code>, and <code>value</code>.
</p>


<h3>Value</h3>

<p>a 4 to 6 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='batch_migration'>Sample Batch Migration Events</h2><span id='topic+batch_migration'></span>

<h3>Description</h3>

<p>Sample batch migration events for simulation given rates of occurance and probability of destination for each patch.
Batch migration can be simulated for the aquatic life stages (eggs, larvae, pupae), adult females, and/or adult males.
To simulate batch migration, each life stage needs all 3 of its arguments specified. If any arguments are left
unspecified (<code>NULL</code>), batch migration for that life stage will not be sampled.
The output of this function should be passed to <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
as the argument <code>batch</code>.
Calls the internal function <code><a href="#topic+batch_migration_stage">batch_migration_stage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_migration(
  SPN_P,
  tmax,
  ELPrates = NULL,
  ELPmove = NULL,
  ELPprob = NULL,
  Frates = NULL,
  Fmove = NULL,
  Fprob = NULL,
  Mrates = NULL,
  Mmove = NULL,
  Mprob = NULL,
  stage = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_migration_+3A_spn_p">SPN_P</code></td>
<td>
<p>places of the SPN</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_tmax">tmax</code></td>
<td>
<p>maximum time of the simulation</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_elprates">ELPrates</code></td>
<td>
<p>rate at which aquatic stage batch migration occurs for each node (nodes without mosquitoes should be set to <code>NaN</code> or <code>NA</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_elpmove">ELPmove</code></td>
<td>
<p>movement matrix for destinations of aquatic stage batch migration events (diagonal will be set to zero and off-diagonal elements normalized)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_elpprob">ELPprob</code></td>
<td>
<p>probability for each individual to be chosen for aquatic stage batch migration events (must be same length as <code>ELPrates</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_frates">Frates</code></td>
<td>
<p>rate at which adult female batch migration occurs for each node (nodes without mosquitoes should be set to <code>NaN</code> or <code>NA</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_fmove">Fmove</code></td>
<td>
<p>movement matrix for destinations of adult female batch migration events (diagonal will be set to zero and off-diagonal elements normalized)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_fprob">Fprob</code></td>
<td>
<p>probability for each individual to be chosen for adult female batch migration events (must be same length as <code>Frates</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_mrates">Mrates</code></td>
<td>
<p>rate at which adult male batch migration occurs for each node (nodes without mosquitoes should be set to <code>NaN</code> or <code>NA</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_mmove">Mmove</code></td>
<td>
<p>movement matrix for destinations of adult male batch migration events (diagonal will be set to zero and off-diagonal elements normalized)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_mprob">Mprob</code></td>
<td>
<p>probability for each individual to be chosen for adult male batch migration events (must be same length as <code>Mrates</code>)</p>
</td></tr>
<tr><td><code id="batch_migration_+3A_stage">stage</code></td>
<td>
<p>either <code>NULL</code> or &quot;E&quot;, &quot;L&quot;, or &quot;P&quot;. If not <code>NULL</code> and migration for aquatic stages is specified by <code>ELPrates</code>, only the aquatic stage specified here will move</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of lists describing all batch migration events, segmented by life stage.
</p>

<hr>
<h2 id='batch_migration_stage'>Internal function to sample and set up data structure for batch migration</h2><span id='topic+batch_migration_stage'></span>

<h3>Description</h3>

<p>Internal function to sample and set up data structure for batch migration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_migration_stage(SPN_P, rates, move, prob, stage, tmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_migration_stage_+3A_spn_p">SPN_P</code></td>
<td>
<p>a set of Petri net places</p>
</td></tr>
<tr><td><code id="batch_migration_stage_+3A_rates">rates</code></td>
<td>
<p>a vector of rates for each node</p>
</td></tr>
<tr><td><code id="batch_migration_stage_+3A_move">move</code></td>
<td>
<p>a movement matrix (where do the batches go?)</p>
</td></tr>
<tr><td><code id="batch_migration_stage_+3A_prob">prob</code></td>
<td>
<p>the probability vector for each individual moving in each batch</p>
</td></tr>
<tr><td><code id="batch_migration_stage_+3A_stage">stage</code></td>
<td>
<p>the life stage (one of 'ELP', 'F', 'M')</p>
</td></tr>
<tr><td><code id="batch_migration_stage_+3A_tmax">tmax</code></td>
<td>
<p>maximum simulation time</p>
</td></tr>
</table>

<hr>
<h2 id='calc_move_rate'>Calculate Outbound Movement Rate</h2><span id='topic+calc_move_rate'></span>

<h3>Description</h3>

<p>Given <code>P</code>, the cumulative probability of moving before dying, and <code>mu</code>,
the daily mortality rate, calculate the movement rate <code>gamma</code> to get <code>P</code>.
The equation comes from integrating the competing risks and solving for <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_move_rate(mu, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_move_rate_+3A_mu">mu</code></td>
<td>
<p>daily mortality rate</p>
</td></tr>
<tr><td><code id="calc_move_rate_+3A_p">P</code></td>
<td>
<p>cumulative probability to move before dying</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric probability of movement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # parameters, see vignette MGDrivE2: One Node Lifecycle Dynamics
  theta &lt;- list(qE = 1/4, nE = 2, qL = 1/3, nL = 3, qP = 1/6, nP = 2,
                muE = 0.05, muL = 0.15, muP = 0.05, muF = 0.09, muM = 0.09,
                beta = 16, nu = 1/(4/24) )

  # lets say a 70% chance to move over the entire lifespan
  rMoveRate &lt;- calc_move_rate(mu = theta$muF, P = 0.70)

</code></pre>

<hr>
<h2 id='convert_prevalence_to_eir'>Generally, pathogen prevalence is a more accesible metric for users, but
the Imperial equilibrium function requires an annual EIR.
This function converts a given pathogen prevalence to an EIR</h2><span id='topic+convert_prevalence_to_eir'></span>

<h3>Description</h3>

<p>Generally, pathogen prevalence is a more accesible metric for users, but
the Imperial equilibrium function requires an annual EIR.
This function converts a given pathogen prevalence to an EIR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_prevalence_to_eir(prevalence, age_vector, ft, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_prevalence_to_eir_+3A_prevalence">prevalence</code></td>
<td>
<p>desired prevalence value</p>
</td></tr>
<tr><td><code id="convert_prevalence_to_eir_+3A_age_vector">age_vector</code></td>
<td>
<p>age distribution of the population</p>
</td></tr>
<tr><td><code id="convert_prevalence_to_eir_+3A_ft">ft</code></td>
<td>
<p>proportion treated</p>
</td></tr>
<tr><td><code id="convert_prevalence_to_eir_+3A_params">params</code></td>
<td>
<p>entomological and epidemiological parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the equilibrium number of humans in each SIS stage
</p>

<hr>
<h2 id='equilibrium_Imperial_decoupled'>This function calculates the human and mosquito equilibrium values for the decoupled Imperial model.
Currently this only works in one node.</h2><span id='topic+equilibrium_Imperial_decoupled'></span>

<h3>Description</h3>

<p>This function calculates the human and mosquito equilibrium values for the decoupled Imperial model.
Currently this only works in one node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_Imperial_decoupled(age_vector, ft, eir, theta, cube, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_age_vector">age_vector</code></td>
<td>
<p>age structure of population (see vignette for example)</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_ft">ft</code></td>
<td>
<p>proportion of population seeking treatment</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_eir">eir</code></td>
<td>
<p>desired annual EIR</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_+3A_spn_p">spn_P</code></td>
<td>
<p>places of the stochastic petri net</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the equilibrium number of humans in each Imperial stage by age, and immunity. mosquito equilibrium values, and full theta vector
</p>

<hr>
<h2 id='equilibrium_Imperial_decoupled_human'>This function calculates the human equilibrium values for the decoupled Imperial model.
Requires the age structure of the population
Currently this only works in one node.</h2><span id='topic+equilibrium_Imperial_decoupled_human'></span>

<h3>Description</h3>

<p>This function calculates the human equilibrium values for the decoupled Imperial model.
Requires the age structure of the population
Currently this only works in one node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_Imperial_decoupled_human(age_vector, ft, EIR, model_param_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_Imperial_decoupled_human_+3A_age_vector">age_vector</code></td>
<td>
<p>age structure of population (see vignette for example)</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_human_+3A_ft">ft</code></td>
<td>
<p>proportion of population seeking treatment</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_human_+3A_eir">EIR</code></td>
<td>
<p>desired annual EIR</p>
</td></tr>
<tr><td><code id="equilibrium_Imperial_decoupled_human_+3A_model_param_list">model_param_list</code></td>
<td>
<p>parameters for the</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the equilibrium number of humans in each Imperial stage by age, and immunity
</p>

<hr>
<h2 id='equilibrium_lifeycle'>Calculate Equilibrium for Lifecycle Model (Logistic or Lotka-Volterra)</h2><span id='topic+equilibrium_lifeycle'></span>

<h3>Description</h3>

<p>This function calculates deterministic equilibria for the mosquito lifecycle
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_lifeycle(
  params,
  NF,
  phi = 0.5,
  log_dd = TRUE,
  spn_P,
  pop_ratio_Aq = NULL,
  pop_ratio_F = NULL,
  pop_ratio_M = NULL,
  cube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_lifeycle_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_nf">NF</code></td>
<td>
<p>vector of female mosquitoes at equilibrium, for every population in the environment</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_phi">phi</code></td>
<td>
<p>sex ratio of mosquitoes at emergence</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_log_dd">log_dd</code></td>
<td>
<p>Boolean: TRUE implies logistic density dependence, FALSE implies Lotka-Volterra model</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_pop_ratio_aq">pop_ratio_Aq</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_pop_ratio_f">pop_ratio_F</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_pop_ratio_m">pop_ratio_M</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_lifeycle_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equilibrium can be calculated using one of two models: classic logistic dynamics
or following the Lotka-Volterra competition model. This is determined by the
parameter <code>log_dd</code>, and it changes elements of the return list: <code>K</code> is
returned for logistic dynamics, or <code>gamma</code> is returned for Lotka-Volterra
dynamics.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The initial population genotype ratios are set by supplying the <code>pop_ratio_Aq</code>,
<code>pop_ratio_F</code>, and <code>pop_ratio_M</code> values. The default value is NULL,
and the function will use the wild-type alleles provided in the <code>cube</code>
object. However, one can supply
several different objects to set the initial genotype ratios. All genotypes provided
must exist in the <code>cube</code> (this is checked by the function). If a single, named vector
is provided, then all patches will be initialized with the same ratios. If a
matrix is provided, with the number of columns (and column names) giving the
initial genotypes, and a row for each patch, each patch can be set to a different
initial ratio. The three parameters do not need to match each other.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This is used to set the initial population
distribution and during the simulation to maintain equilibrium. <code>params</code>
must include the following named parameters:
</p>

<ul>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li>
<li> <p><code>muE</code>: egg mortality
</p>
</li>
<li> <p><code>muL</code>: density-independent larvae mortality
</p>
</li>
<li> <p><code>muP</code>: pupae mortality
</p>
</li>
<li> <p><code>muF</code>: adult female mortality
</p>
</li>
<li> <p><code>muM</code>: adult male mortality
</p>
</li>
<li> <p><code>beta</code>: egg-laying rate, daily
</p>
</li>
<li> <p><code>nu</code>: mating rate of unmated females
</p>
</li></ul>

<p>The return list contains all of the <code>params</code> parameters, along with the
density-dependent parameter, either <code>K</code> or <code>gamma</code>. These are the
parameters necessary later in the simulations. This was done for compatibility
with <code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>, which requires several extra parameters
not required further in the simulations.
</p>
<p>For equilibrium with epidemiological parameters, see <code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>.
For equilibrium with latent humans (SEIR dynamics), see <code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>.
</p>


<h3>Value</h3>

<p>a list with 3 elements: <code>init</code> a matrix of equilibrium values for every life-cycle stage,
<code>params</code> a list of parameters for the simulation, <code>M0</code> a vector of initial conditions
</p>

<hr>
<h2 id='equilibrium_SEI_decoupled_human'>This function calculates the equilibrium values for the decoupled SIS human states.
Currently this only works in one node.</h2><span id='topic+equilibrium_SEI_decoupled_human'></span>

<h3>Description</h3>

<p>This function calculates the equilibrium values for the decoupled SIS human states.
Currently this only works in one node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_SEI_decoupled_human(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_SEI_decoupled_human_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the equilibrium number of humans in each SIS stage
</p>

<hr>
<h2 id='equilibrium_SEI_decoupled_mosy'>Calculate Equilibrium for Decoupled Mosquito SEI model. Human states will be handled separately.</h2><span id='topic+equilibrium_SEI_decoupled_mosy'></span>

<h3>Description</h3>

<p>Given prevalence of disease in humans (modeled as an SIS: Susceptible-Infected-Susceptible
process with birth and death) and entomological parameters of transmission, this
function calculates the quasi-stationary distribution of adult female mosquitoes
across SEI (Susceptible-Exposed-Infectious) stages, allowing for Erlang distributed E stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_SEI_decoupled_mosy(
  params,
  node_list = "b",
  NF = NULL,
  phi = 0.5,
  NH = NULL,
  log_dd = TRUE,
  spn_P,
  pop_ratio_Aq = NULL,
  pop_ratio_F = NULL,
  pop_ratio_M = NULL,
  pop_ratio_H = 1,
  cube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_nf">NF</code></td>
<td>
<p>vector of female mosquitoes at equilibrium, for mosquito-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_phi">phi</code></td>
<td>
<p>sex ratio of mosquitoes at emergence</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_nh">NH</code></td>
<td>
<p>vector of humans at equilibrium, for human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_log_dd">log_dd</code></td>
<td>
<p>Boolean: TRUE implies logistic density dependence, FALSE implies Lotka-Volterra model</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_pop_ratio_aq">pop_ratio_Aq</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_pop_ratio_f">pop_ratio_F</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_pop_ratio_m">pop_ratio_M</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_pop_ratio_h">pop_ratio_H</code></td>
<td>
<p>Prevalence in human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_decoupled_mosy_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function handles 3 types of nodes: Human only, mosquito only, and nodes
with both. These nodes are set using the <code>node_list</code> parameter.
Mosquito-only node equilibrium calls <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>, which
follows one of two models: classic logistic dynamics or the Lotka-Volterra
competition model. This is determined by the parameter <code>log_dd</code>, and it
changes elements of the return list: <code>K</code> is returned for logistic dynamics,
or <code>gamma</code> is returned for Lotka-Volterra dynamics. This
is parameterized with the <code>NF</code> parameter to define the adult female numbers.
This parameter only needs to be supplied if there are mosquito-only nodes.
</p>
<p>Human-only nodes don't require any equilibrium calculations. These nodes use
the <code>NH</code> and <code>pop_ratio_H</code> to set adult human populations and
infection rates in nodes. These two parameters only need to be supplied
if there are human-only nodes.
</p>
<p>For human and mosquito nodes, this function calls <code><a href="#topic+make_Q_SEI">make_Q_SEI</a></code> to construct the
infinitesimal generator matrix which is used to solve for the quasi-stationary
(stochastic) or equilibrium (deterministic) distribution of mosquitoes over stages.
Parameters are provided by <code>params</code>.
</p>
<p>For information on the method used to solve this distribution, see section
&quot;3.1.3 Nonsingularity of the Subintensity Matrix&quot; of:
</p>

<ul>
<li><p> Bladt, Mogens, and Bo Friis Nielsen. Matrix-exponential distributions in
applied probability. Vol. 81. New York: Springer, 2017.
</p>
</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The initial population genotype ratios are set by supplying the <code>pop_ratio_Aq</code>,
<code>pop_ratio_F</code>, and <code>pop_ratio_M</code> values. The default value is NULL,
and the function will use the wild-type alleles provided in the <code>cube</code>
object. However, one can supply
several different objects to set the initial genotype ratios. All genotypes provided
must exist in the <code>cube</code> (this is checked by the function). If a single, named vector
is provided, then all patches will be initialized with the same ratios. If a
matrix is provided, with the number of columns (and column names) giving the
initial genotypes, and a row for each patch, each patch can be set to a different
initial ratio. The three parameters do not need to match each other.
</p>
<p>The <code>params</code> argument supplies all of the ecological and epidemiological
parameters necessary to calculate equilibrium values. This is used to set the
initial population distribution and during the simulation to maintain equilibrium.
This <code>params</code> must include the following named parameters, noted as being
the same as lifecycle parameters, or new for the epidemiological equilibrium
</p>

<ul>
<li> <p><strong>(Lifecycle parameters)</strong>
</p>

<ul>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li>
<li> <p><code>muE</code>: egg mortality
</p>
</li>
<li> <p><code>muL</code>: density-independent larvae mortality
</p>
</li>
<li> <p><code>muP</code>: pupae mortality
</p>
</li>
<li> <p><code>muF</code>: adult female mortality
</p>
</li>
<li> <p><code>muM</code>: adult male mortality
</p>
</li>
<li> <p><code>beta</code>: egg-laying rate, daily
</p>
</li>
<li> <p><code>nu</code>: mating rate of unmated females
</p>
</li></ul>

</li>
<li> <p><strong>(Epidemiological parameters)</strong>
</p>

<ul>
<li> <p><code>NH</code>: number of humans, can be a vector
</p>
</li>
<li> <p><code>X</code>: prevalence in humans, can be a vector
</p>
</li>
<li> <p><code>NFX</code>: number of female mosquitoes, only required if any prevalence (X) is zero
</p>
</li>
<li> <p><code>b</code>: mosquito to human transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>c</code>: human to mosquito transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>r</code>: rate of recovery in humans (1/duration of infectiousness)
</p>
</li>
<li> <p><code>muH</code>: death rate of humans (1/avg lifespan)
</p>
</li>
<li> <p><code>f</code>: rate of blood feeding
</p>
</li>
<li> <p><code>Q</code>: human blood index
</p>
</li>
<li> <p><code>qEIP</code>: related to scale parameter of Gamma distributed EIP (1/qEIP is mean length of EIP)
</p>
</li>
<li> <p><code>nEIP</code>: shape parameter of Gamma distributed EIP
</p>
</li></ul>

</li></ul>

<p>The return list contains all of the parameters necessary later in the simulations.
</p>
<p>For equilibrium without epidemiological parameters, see <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>.
For equilibrium with latent humans (SEIR dynamics), see <code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a vector of the equilibrium number of females in each SEI stage
</p>

<hr>
<h2 id='equilibrium_SEI_Imperial'>Calculate Equilibrium for Mosquito SEI - Human Imperial Model</h2><span id='topic+equilibrium_SEI_Imperial'></span>

<h3>Description</h3>

<p>In decoupled sampling, human states are handled separately from mosquito states.
The function <code>equilibrium_Imperial_decoupled_human</code> calculates the distribution of humans
at equilibrium required for the Imperial model of malaria transmission. Here we use parameters from
that model to calculate the equilibrium states of Susceptible-Exposed-Infectious (SEI) female mosquitoes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_SEI_Imperial(
  params,
  node_list = "b",
  NF = NULL,
  phi = 0.5,
  NH = NULL,
  log_dd = TRUE,
  spn_P,
  pop_ratio_Aq = NULL,
  pop_ratio_F = NULL,
  pop_ratio_M = NULL,
  pop_ratio_H = 1,
  cube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_node_list">node_list</code></td>
<td>
<p>list of geospatial nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_nf">NF</code></td>
<td>
<p>number of female mosquitoes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_phi">phi</code></td>
<td>
<p>sex ratio of mosquitoes at emergence</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_nh">NH</code></td>
<td>
<p>vector of humans at equilibrium</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_log_dd">log_dd</code></td>
<td>
<p>Boolean: TRUE implies logistic density dependence, FALSE implies Lotka-Volterra model</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_pop_ratio_aq">pop_ratio_Aq</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_pop_ratio_f">pop_ratio_F</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_pop_ratio_m">pop_ratio_M</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_pop_ratio_h">pop_ratio_H</code></td>
<td>
<p>Prevalence in human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_Imperial_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imperial model sampling is currently only supported for one-node dynamics: a single node with mosquitoes
parameterized by the distribution of human states.
These nodes are set using the <code>node_list</code> parameter.
Mosquito-only node equilibrium calls <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>, which
follows one of two models: classic logistic dynamics or the Lotka-Volterra
competition model. This is determined by the parameter <code>log_dd</code>, and it
changes elements of the return list: <code>K</code> is returned for logistic dynamics,
or <code>gamma</code> is returned for Lotka-Volterra dynamics. This
is parameterized with the <code>NF</code> parameter to define the adult female numbers.
This parameter only needs to be supplied if there are mosquito-only nodes.
</p>
<p>For human and mosquito nodes, this function calculates the number of SEI mosquitoes in each state.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The initial population genotype ratios are set by supplying the <code>pop_ratio_Aq</code>,
<code>pop_ratio_F</code>, and <code>pop_ratio_M</code> values. The default value is NULL,
and the function will use the wild-type alleles provided in the <code>cube</code>
object. However, one can supply
several different objects to set the initial genotype ratios. All genotypes provided
must exist in the <code>cube</code> (this is checked by the function). If a single, named vector
is provided, then all patches will be initialized with the same ratios. If a
matrix is provided, with the number of columns (and column names) giving the
initial genotypes, and a row for each patch, each patch can be set to a different
initial ratio. The three parameters do not need to match each other.
</p>
<p>The <code>params</code> argument supplies all of the ecological and epidemiological
parameters necessary to calculate equilibrium values. This is used to set the
initial population distribution and during the simulation to maintain equilibrium.
This <code>params</code> must include the following named parameters, noted as being
the same as lifecycle parameters, or new for the epidemiological equilibrium
</p>

<ul>
<li> <p><strong>(Lifecycle parameters)</strong>
</p>

<ul>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li>
<li> <p><code>muE</code>: egg mortality
</p>
</li>
<li> <p><code>muL</code>: density-independent larvae mortality
</p>
</li>
<li> <p><code>muP</code>: pupae mortality
</p>
</li>
<li> <p><code>muF</code>: adult female mortality, supplied from Imperial equilibrium function
</p>
</li>
<li> <p><code>muM</code>: adult male mortality, supplied from Imperial equilibrium function
</p>
</li>
<li> <p><code>beta</code>: egg-laying rate, daily
</p>
</li>
<li> <p><code>nu</code>: mating rate of unmated females
</p>
</li></ul>

</li>
<li> <p><strong>(Epidemiological parameters)</strong>
</p>

<ul>
<li> <p><code>NH</code>: number of humans, can be a vector
</p>
</li>
<li> <p><code>FOIv</code>: force of infection on mosquitoes, supplied from Imperial equilibrium function
</p>
</li>
<li> <p><code>Iv_eq</code>: per-capita proportion of infectious mosquitoes
The return list contains all of the parameters necessary later in the simulations.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>a vector of the equilibrium number of females in each SEI stage
</p>

<hr>
<h2 id='equilibrium_SEI_SEIR'>Calculate Equilibrium for Mosquito SEI - Human SEIR Model</h2><span id='topic+equilibrium_SEI_SEIR'></span>

<h3>Description</h3>

<p>Given prevalence of disease in humans (modeled as an SEIR: Susceptible-Latent-Infected-Recovered
process with birth and death) and entomological parameters of transmission, this
function calculates the quasi-stationary distribution of adult female mosquitoes
across SEI (Susceptible-Exposed-Infectious) stages, allowing for Erlang distributed E stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_SEI_SEIR(
  params,
  node_list = "b",
  NF = NULL,
  phi = 0.5,
  NH = NULL,
  log_dd = TRUE,
  spn_P,
  pop_ratio_Aq = NULL,
  pop_ratio_F = NULL,
  pop_ratio_M = NULL,
  pop_ratio_H = c(1, 0, 0, 0),
  cube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_nf">NF</code></td>
<td>
<p>vector of female mosquitoes at equilibrium, for mosquito-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_phi">phi</code></td>
<td>
<p>sex ratio of mosquitoes at emergence</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_nh">NH</code></td>
<td>
<p>vector of humans at equilibrium, for human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_log_dd">log_dd</code></td>
<td>
<p>Boolean: TRUE implies logistic density dependence, FALSE implies Lotka-Volterra model</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_pop_ratio_aq">pop_ratio_Aq</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_pop_ratio_f">pop_ratio_F</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_pop_ratio_m">pop_ratio_M</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_pop_ratio_h">pop_ratio_H</code></td>
<td>
<p>Prevalence in human-only nodes, default is all susceptible</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SEIR_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function handles 3 types of nodes: Human only, mosquito only, and nodes
with both. These nodes are set using the <code>node_list</code> parameter.
Mosquito-only node equilibrium calls <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>, which
follows one of two models: classic logistic dynamics or the Lotka-Volterra
competition model. This is determined by the parameter <code>log_dd</code>, and it
changes elements of the return list: <code>K</code> is returned for logistic dynamics,
or <code>gamma</code> is returned for Lotka-Volterra dynamics. This
is parameterized with the <code>NF</code> parameter to define the adult female numbers.
This parameter only needs to be supplied if there are mosquito-only nodes.
</p>
<p>Human-only nodes don't require any equilibrium calculations. These nodes use
the <code>NH</code> and <code>pop_ratio_H</code> to set adult human populations and
infection rates in nodes. These two parameters only need to be supplied
if there are human-only nodes. <code>pop_ratio_H</code> needs to be a matrix with the
number of rows equal to the number of human-only patches, and 4 columns. The
columns are assumed to be fractions of the population in &quot;S&quot;, &quot;E&quot;, &quot;I&quot;, or &quot;R&quot;
states, and every row must sum to 1.
</p>
<p>For human and mosquito nodes, this function calls <code><a href="#topic+make_Q_SEI">make_Q_SEI</a></code> to construct the
infinitesimal generator matrix which is used to solve for the quasi-stationary
(stochastic) or equilibrium (deterministic) distribution of mosquitoes over stages.
Parameters are provided by <code>params</code>.
</p>
<p>For information on the method used to solve this distribution, see section
&quot;3.1.3 Nonsingularity of the Subintensity Matrix&quot; of:
</p>

<ul>
<li><p> Bladt, Mogens, and Bo Friis Nielsen. Matrix-exponential distributions in
applied probability. Vol. 81. New York: Springer, 2017.
</p>
</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The initial population genotype ratios are set by supplying the <code>pop_ratio_Aq</code>,
<code>pop_ratio_F</code>, and <code>pop_ratio_M</code> values. The default value is NULL,
and the function will use the wild-type alleles provided in the <code>cube</code>
object. However, one can supply
several different objects to set the initial genotype ratios. All genotypes provided
must exist in the <code>cube</code> (this is checked by the function). If a single, named vector
is provided, then all patches will be initialized with the same ratios. If a
matrix is provided, with the number of columns (and column names) giving the
initial genotypes, and a row for each patch, each patch can be set to a different
initial ratio. The three parameters do not need to match each other.
</p>
<p>The <code>params</code> argument supplies all of the ecological and epidemiological
parameters necessary to calculate equilibrium values. This is used to set the
initial population distribution and during the simulation to maintain equilibrium.
This <code>params</code> must include the following named parameters, noted as being
the same as lifecycle parameters, or new for the epidemiological equilibrium
</p>

<ul>
<li> <p><strong>(Lifecycle parameters)</strong>
</p>

<ul>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li>
<li> <p><code>muE</code>: egg mortality
</p>
</li>
<li> <p><code>muL</code>: density-independent larvae mortality
</p>
</li>
<li> <p><code>muP</code>: pupae mortality
</p>
</li>
<li> <p><code>muF</code>: adult female mortality
</p>
</li>
<li> <p><code>muM</code>: adult male mortality
</p>
</li>
<li> <p><code>beta</code>: egg-laying rate, daily
</p>
</li>
<li> <p><code>nu</code>: mating rate of unmated females
</p>
</li></ul>

</li>
<li> <p><strong>(Epidemiological parameters)</strong>
</p>

<ul>
<li> <p><code>NH</code>: number of humans, can be a vector
</p>
</li>
<li> <p><code>X</code>: SEIR prevalence in humans, can be a vector of length 4 for 1 node, or a matrix for many nodes
</p>
</li>
<li> <p><code>NFX</code>: number of female mosquitoes, only required if any prevalence (X) is zero
</p>
</li>
<li> <p><code>b</code>: mosquito to human transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>c</code>: human to mosquito transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>r</code>: rate of recovery in humans (1/duration of infectiousness)
</p>
</li>
<li> <p><code>muH</code>: death rate of humans (1/avg lifespan)
</p>
</li>
<li> <p><code>f</code>: rate of blood feeding
</p>
</li>
<li> <p><code>Q</code>: human blood index
</p>
</li>
<li> <p><code>qEIP</code>: related to scale parameter of Gamma distributed EIP (1/qEIP is mean length of EIP)
</p>
</li>
<li> <p><code>nEIP</code>: shape parameter of Gamma distributed EIP
</p>
</li>
<li> <p><code>delta</code>: inverse duration of the latent stage (E)
</p>
</li></ul>

</li></ul>

<p>The return list contains all of the parameters necessary later in the simulations.
</p>
<p>For equilibrium without epidemiological parameters, see <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>.
For equilibrium without latent humans (SIS dynamics), see <code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>.
</p>


<h3>Value</h3>

<p>a vector of the equilibrium number of females in each SEI stage
</p>

<hr>
<h2 id='equilibrium_SEI_SIS'>Calculate Equilibrium for Mosquito SEI - Human SIS Model</h2><span id='topic+equilibrium_SEI_SIS'></span>

<h3>Description</h3>

<p>Given prevalence of disease in humans (modeled as an SIS: Susceptible-Infected-Susceptible
process with birth and death) and entomological parameters of transmission, this
function calculates the quasi-stationary distribution of adult female mosquitoes
across SEI (Susceptible-Exposed-Infectious) stages, allowing for Erlang distributed E stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrium_SEI_SIS(
  params,
  node_list = "b",
  NF = NULL,
  phi = 0.5,
  NH = NULL,
  log_dd = TRUE,
  spn_P,
  pop_ratio_Aq = NULL,
  pop_ratio_F = NULL,
  pop_ratio_M = NULL,
  pop_ratio_H = 1,
  cube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrium_SEI_SIS_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_nf">NF</code></td>
<td>
<p>vector of female mosquitoes at equilibrium, for mosquito-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_phi">phi</code></td>
<td>
<p>sex ratio of mosquitoes at emergence</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_nh">NH</code></td>
<td>
<p>vector of humans at equilibrium, for human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_log_dd">log_dd</code></td>
<td>
<p>Boolean: TRUE implies logistic density dependence, FALSE implies Lotka-Volterra model</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_pop_ratio_aq">pop_ratio_Aq</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_pop_ratio_f">pop_ratio_F</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_pop_ratio_m">pop_ratio_M</code></td>
<td>
<p>May be empty; if not, a named vector or matrix. (see details)</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_pop_ratio_h">pop_ratio_H</code></td>
<td>
<p>Prevalence in human-only nodes</p>
</td></tr>
<tr><td><code id="equilibrium_SEI_SIS_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function handles 3 types of nodes: Human only, mosquito only, and nodes
with both. These nodes are set using the <code>node_list</code> parameter.
Mosquito-only node equilibrium calls <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>, which
follows one of two models: classic logistic dynamics or the Lotka-Volterra
competition model. This is determined by the parameter <code>log_dd</code>, and it
changes elements of the return list: <code>K</code> is returned for logistic dynamics,
or <code>gamma</code> is returned for Lotka-Volterra dynamics. This
is parameterized with the <code>NF</code> parameter to define the adult female numbers.
This parameter only needs to be supplied if there are mosquito-only nodes.
</p>
<p>Human-only nodes don't require any equilibrium calculations. These nodes use
the <code>NH</code> and <code>pop_ratio_H</code> to set adult human populations and
infection rates in nodes. These two parameters only need to be supplied
if there are human-only nodes.
</p>
<p>For human and mosquito nodes, this function calls <code><a href="#topic+make_Q_SEI">make_Q_SEI</a></code> to construct the
infinitesimal generator matrix which is used to solve for the quasi-stationary
(stochastic) or equilibrium (deterministic) distribution of mosquitoes over stages.
Parameters are provided by <code>params</code>.
</p>
<p>For information on the method used to solve this distribution, see section
&quot;3.1.3 Nonsingularity of the Subintensity Matrix&quot; of:
</p>

<ul>
<li><p> Bladt, Mogens, and Bo Friis Nielsen. Matrix-exponential distributions in
applied probability. Vol. 81. New York: Springer, 2017.
</p>
</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The initial population genotype ratios are set by supplying the <code>pop_ratio_Aq</code>,
<code>pop_ratio_F</code>, and <code>pop_ratio_M</code> values. The default value is NULL,
and the function will use the wild-type alleles provided in the <code>cube</code>
object. However, one can supply
several different objects to set the initial genotype ratios. All genotypes provided
must exist in the <code>cube</code> (this is checked by the function). If a single, named vector
is provided, then all patches will be initialized with the same ratios. If a
matrix is provided, with the number of columns (and column names) giving the
initial genotypes, and a row for each patch, each patch can be set to a different
initial ratio. The three parameters do not need to match each other.
</p>
<p>The <code>params</code> argument supplies all of the ecological and epidemiological
parameters necessary to calculate equilibrium values. This is used to set the
initial population distribution and during the simulation to maintain equilibrium.
This <code>params</code> must include the following named parameters, noted as being
the same as lifecycle parameters, or new for the epidemiological equilibrium
</p>

<ul>
<li> <p><strong>(Lifecycle parameters)</strong>
</p>

<ul>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li>
<li> <p><code>muE</code>: egg mortality
</p>
</li>
<li> <p><code>muL</code>: density-independent larvae mortality
</p>
</li>
<li> <p><code>muP</code>: pupae mortality
</p>
</li>
<li> <p><code>muF</code>: adult female mortality
</p>
</li>
<li> <p><code>muM</code>: adult male mortality
</p>
</li>
<li> <p><code>beta</code>: egg-laying rate, daily
</p>
</li>
<li> <p><code>nu</code>: mating rate of unmated females
</p>
</li></ul>

</li>
<li> <p><strong>(Epidemiological parameters)</strong>
</p>

<ul>
<li> <p><code>NH</code>: number of humans, can be a vector
</p>
</li>
<li> <p><code>X</code>: prevalence in humans, can be a vector
</p>
</li>
<li> <p><code>NFX</code>: number of female mosquitoes, only required if any prevalence (X) is zero
</p>
</li>
<li> <p><code>b</code>: mosquito to human transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>c</code>: human to mosquito transmission efficiency, can be a vector
</p>
</li>
<li> <p><code>r</code>: rate of recovery in humans (1/duration of infectiousness)
</p>
</li>
<li> <p><code>muH</code>: death rate of humans (1/avg lifespan)
</p>
</li>
<li> <p><code>f</code>: rate of blood feeding
</p>
</li>
<li> <p><code>Q</code>: human blood index
</p>
</li>
<li> <p><code>qEIP</code>: related to scale parameter of Gamma distributed EIP (1/qEIP is mean length of EIP)
</p>
</li>
<li> <p><code>nEIP</code>: shape parameter of Gamma distributed EIP
</p>
</li></ul>

</li></ul>

<p>The return list contains all of the parameters necessary later in the simulations.
</p>
<p>For equilibrium without epidemiological parameters, see <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>.
For equilibrium with latent humans (SEIR dynamics), see <code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a vector of the equilibrium number of females in each SEI stage
</p>

<hr>
<h2 id='get_shape'>Calculate Erlang shape parameter</h2><span id='topic+get_shape'></span>

<h3>Description</h3>

<p>Calculate Erlang shape parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shape(cv, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_shape_+3A_cv">cv</code></td>
<td>
<p>coefficient of variation (CV) between mean and standard deviation of dwell times,
smaller values of CV correspond to distributions less dispersed around their mean and larger
value to more dispersed distributions.</p>
</td></tr>
<tr><td><code id="get_shape_+3A_q">q</code></td>
<td>
<p>inverse of mean dwell time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer value representing the coefficient of variation in Erlang-distributed life stages.
</p>

<hr>
<h2 id='human_Imperial_ODE'>ODE describing the age-structured Imperial model
used in decoupled sampling, which will pass in values of I_V and
return the human states for usein the mosquito portion of the model</h2><span id='topic+human_Imperial_ODE'></span>

<h3>Description</h3>

<p>ODE describing the age-structured Imperial model
used in decoupled sampling, which will pass in values of I_V and
return the human states for usein the mosquito portion of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>human_Imperial_ODE(t, state, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="human_Imperial_ODE_+3A_t">t</code></td>
<td>
<p>starting time of simulation</p>
</td></tr>
<tr><td><code id="human_Imperial_ODE_+3A_state">state</code></td>
<td>
<p>distributon of disease states</p>
</td></tr>
<tr><td><code id="human_Imperial_ODE_+3A_parameters">parameters</code></td>
<td>
<p>parameter set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of disease states after integration
</p>

<hr>
<h2 id='imperial_model_param_list_create'>Model Parameter List Creation</h2><span id='topic+imperial_model_param_list_create'></span>

<h3>Description</h3>

<p><code>model_param_list_create</code> creates list of model parameters to be used
within <code>equilibrium_init_create</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imperial_model_param_list_create(
  eta = 1/(21 * 365),
  rho = 0.85,
  a0 = 2920,
  sigma2 = 1.67,
  max_age = 100 * 365,
  rA = 1/195,
  rT = 0.2,
  rD = 0.2,
  rU = 1/110.299,
  rP = 1/15,
  dE = 12,
  delayGam = 12.5,
  cD = 0.0676909,
  cT = 0.322 * cD,
  cU = 0.006203,
  gamma1 = 1.82425,
  d1 = 0.160527,
  dID = 3650,
  ID0 = 1.577533,
  kD = 0.476614,
  uD = 9.44512,
  aD = 8001.99,
  fD0 = 0.007055,
  gammaD = 4.8183,
  alphaA = 0.75735,
  alphaU = 0.185624,
  b0 = 0.590076,
  b1 = 0.5,
  dB = 3650,
  IB0 = 43.8787,
  kB = 2.15506,
  uB = 7.19919,
  theta0 = 0.0749886,
  theta1 = 0.0001191,
  iv0 = 1.09629,
  kv = 2.00048,
  av = 2493.41,
  gammaV = 2.91282,
  fvS = 0.141195,
  pctMort = 0.215,
  phi0 = 0.791666,
  phi1 = 0.000737,
  dCA = 10950,
  IC0 = 18.02366,
  kC = 2.36949,
  uCA = 6.06349,
  PM = 0.774368,
  dCM = 67.6952,
  dVM = 76.8365,
  dVA = 30 * 365,
  PVM = 0.195768,
  uVA = 11.4321,
  tau1 = 0.69,
  tau2 = 2.31,
  muF = 0.132,
  nEIP = 3,
  qEIP = 1/10,
  Q0 = 0.92,
  DY = 365,
  thetaB = 0.89,
  thetaI = 0.97,
  r_llin = 0.56,
  s_llin = 0.03,
  r_irs = 0.6,
  s_irs = 0,
  qE = 1/3,
  nE = 2,
  qL = 1/7,
  nL = 3,
  qP = 1/1,
  nP = 2,
  muE = 0.05,
  muL = 0.15,
  muP = 0.05,
  muM = 0.132,
  eps = 58.9,
  nu = 1/(4/24),
  NH = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imperial_model_param_list_create_+3A_eta">eta</code></td>
<td>
<p>Death rate for expoential population distribtuion, i.e. 1/Mean Population Age. Default = 0.0001305</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_rho">rho</code></td>
<td>
<p>Age-dependent biting parameter. Default = 0.85</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_a0">a0</code></td>
<td>
<p>Age-dependent biting parameter. Default = 2920</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_sigma2">sigma2</code></td>
<td>
<p>Variance of the log heterogeneity in biting rates. Default = 1.67</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_max_age">max_age</code></td>
<td>
<p>Maximum age in days. Default = 100*365</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ra">rA</code></td>
<td>
<p>Rate of leaving asymptomatic infection. Default = 0.00512821</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_rt">rT</code></td>
<td>
<p>Rate of leaving treatment. Default = 0.2</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_rd">rD</code></td>
<td>
<p>Rate of leaving clinical disease. Default = 0.2</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ru">rU</code></td>
<td>
<p>Rate of recovering from subpatent infection. Default = 0.00906627</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_rp">rP</code></td>
<td>
<p>Rate of leaving prophylaxis. Default = 0.06666667</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_de">dE</code></td>
<td>
<p>Latent period of human infection. Default = 12</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_delaygam">delayGam</code></td>
<td>
<p>Lag from parasites to infectious gametocytes. Default = 12.5</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_cd">cD</code></td>
<td>
<p>Untreated disease contribution to infectiousness. Default = 0.0676909</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ct">cT</code></td>
<td>
<p>Treated disease contribution to infectiousness. Default =   0.322 * cD</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_cu">cU</code></td>
<td>
<p>Subpatent disease contribution to infectiousness. Default = 0.006203</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_gamma1">gamma1</code></td>
<td>
<p>Parameter for infectiousness of state A. Default = 1.82425</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_d1">d1</code></td>
<td>
<p>Minimum probability due to maximum immunity. Default = 0.160527</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_did">dID</code></td>
<td>
<p>Inverse of decay rate. Default = 3650</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_id0">ID0</code></td>
<td>
<p>Scale parameter. Default = 1.577533</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_kd">kD</code></td>
<td>
<p>Shape parameter. Default = 0.476614</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ud">uD</code></td>
<td>
<p>Duration in which immunity is not boosted. Default = 9.44512</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ad">aD</code></td>
<td>
<p>Scale parameter relating age to immunity. Default = 8001.99</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_fd0">fD0</code></td>
<td>
<p>Time-scale at which immunity changes with age. Default = 0.007055</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_gammad">gammaD</code></td>
<td>
<p>Shape parameter relating age to immunity. Default = 4.8183</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_alphaa">alphaA</code></td>
<td>
<p>PCR detection probability parameters state A. Default = 0.757</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_alphau">alphaU</code></td>
<td>
<p>PCR detection probability parameters state U. Default = 0.186</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_b0">b0</code></td>
<td>
<p>Maximum probability due to no immunity. Default = 0.590076</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_b1">b1</code></td>
<td>
<p>Maximum relative reduction due to immunity. Default = 0.5</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_db">dB</code></td>
<td>
<p>Inverse of decay rate. Default = 3650</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ib0">IB0</code></td>
<td>
<p>Scale parameter. Default = 43.8787</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_kb">kB</code></td>
<td>
<p>Shape parameter. Default = 2.15506</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ub">uB</code></td>
<td>
<p>Duration in which immunity is not boosted. Default = 7.19919</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_theta0">theta0</code></td>
<td>
<p>Maximum probability of severe infection due to no immunity. Default = 0.0749886</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_theta1">theta1</code></td>
<td>
<p>Maximum reduction due to to immunity. Default = 0.0001191</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_iv0">iv0</code></td>
<td>
<p>Scale parameter. Default = 1.09629</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_kv">kv</code></td>
<td>
<p>Shape parameter. Default = 2.00048</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_av">av</code></td>
<td>
<p>Age-dependent modifier. Default = 2493.41</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_gammav">gammaV</code></td>
<td>
<p>Age-dependent modifier. Default = 2.91282</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_fvs">fvS</code></td>
<td>
<p>Age-dependent modifier. Default = 0.141195</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_pctmort">pctMort</code></td>
<td>
<p>Percentage of severe cases that die. Default = 0.215</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_phi0">phi0</code></td>
<td>
<p>Maximum probability due to no immunity. Default = 0.791666</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_phi1">phi1</code></td>
<td>
<p>Maximum relative reduction due to immunity. Default = 0.000737</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_dca">dCA</code></td>
<td>
<p>Inverse of decay rate. Default = 10950</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ic0">IC0</code></td>
<td>
<p>Scale parameter. Default = 18.02366</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_kc">kC</code></td>
<td>
<p>Shape parameter. Default = 2.36949</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_uca">uCA</code></td>
<td>
<p>Duration in which immunity is not boosted. Default = 6.06349</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_pm">PM</code></td>
<td>
<p>New-born immunity relative to mother’s. Default = 0.774368</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_dcm">dCM</code></td>
<td>
<p>Inverse of decay rate of maternal immunity. Default = 67.6952</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_dvm">dVM</code></td>
<td>
<p>Inverse of decay rate. Default = 76.8365</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_dva">dVA</code></td>
<td>
<p>Inverse of decay rate. Default = 30 * 365</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_pvm">PVM</code></td>
<td>
<p>New-born immunity to severe disease relative to mothers. Default = 0.195768</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_uva">uVA</code></td>
<td>
<p>Duration in which immunity to severe disease is not boosted. Default = 11.4321</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_tau1">tau1</code></td>
<td>
<p>Duration of host seeking, assumed to be constant between species. Default = 0.69</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_tau2">tau2</code></td>
<td>
<p>Duration of mosquito resting after feed. Default = 2.31</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_muf">muF</code></td>
<td>
<p>Daily mortality of adult mosquitos. Default = 0.132</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_neip">nEIP</code></td>
<td>
<p>Number of Erlang-distributed EIP compartments. Default = 6</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_qeip">qEIP</code></td>
<td>
<p>Inverse of the mean duration of the EIP. Default = 1/10 (days)</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_q0">Q0</code></td>
<td>
<p>Anthrophagy probability. Default = 0.92</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_dy">DY</code></td>
<td>
<p>number of days in a year. Default = 365</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_thetab">thetaB</code></td>
<td>
<p>proportion of bites on a person in bed. Default = 0.89</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_thetai">thetaI</code></td>
<td>
<p>proportion of bites on a person outdoors. Default = 0.97</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_r_llin">r_llin</code></td>
<td>
<p>probability of repeating a feeding attempt due to LLINs. Default = 0.56</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_s_llin">s_llin</code></td>
<td>
<p>probability of feeding and surviving in presence of LLINs. Default = 0.03</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_r_irs">r_irs</code></td>
<td>
<p>probability of repeating a feeding attempt due to IRS. Default = 0.60</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_s_irs">s_irs</code></td>
<td>
<p>probability of feeding and surviving in presence of IRS. Default = 0</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_qe">qE</code></td>
<td>
<p>mosquito egg lifecycle parameter. Default = 1/3</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ne">nE</code></td>
<td>
<p>mosquito egg lifecycle parameter. Default = 2</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_ql">qL</code></td>
<td>
<p>mosquito larval lifecycle parameter. Default = 1/7</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_nl">nL</code></td>
<td>
<p>mosquito larval lifecycle parameter. Default = 3</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_qp">qP</code></td>
<td>
<p>mosquito pupae lifecycle parameter. Default = 1/1</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_np">nP</code></td>
<td>
<p>mosquito pupae lifecycle parameter. Default = 2</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_mue">muE</code></td>
<td>
<p>death rate of egg stage. Default = 0.05</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_mul">muL</code></td>
<td>
<p>death rate of larval stage. Default = 0.15</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_mup">muP</code></td>
<td>
<p>death rate of pupae stage. Default = 0.05</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_mum">muM</code></td>
<td>
<p>death rate of male adult stage. Default = 0.132</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_eps">eps</code></td>
<td>
<p>eggs laid per day. Default = 58.9</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_nu">nu</code></td>
<td>
<p>mosquito lifecycle parameter. Default = 1/(4/24</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_nh">NH</code></td>
<td>
<p>number of humans. Default = 1000</p>
</td></tr>
<tr><td><code id="imperial_model_param_list_create_+3A_...">...</code></td>
<td>
<p>Any other parameters needed for non-standard model. If they share the same name
as any of the defined parameters <code>model_param_list_create</code> will stop. You can either write
any extra parameters you like individually, e.g. model_param_list_create(extra1 = 1, extra2 = 2)
and these parameteres will appear appended to the returned list, or you can pass explicitly
the ellipsis argument as a list created before, e.g. model_param_list_create(...=list(extra1 = 1, extra2 = 2))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of all baseline parameters required by the Imperial malaria model.
</p>
<p>This function creates all of the necessary parameters for the Imperial model. Parameters furnished by MGDrivE will be
removed from this function. Adapted from: https://github.com/mrc-ide/deterministic-malaria-model/blob/master/R/model_parameters.R
</p>
<p>A newer version of the model also includes parameters for severe disease. See: https://github.com/mrc-ide/malariasimulation for details.
</p>

<hr>
<h2 id='make_Q_Imperial'>Rate Matrix (Q) for Adult Mosquito SEI Dynamics</h2><span id='topic+make_Q_Imperial'></span>

<h3>Description</h3>

<p>Construct the infinitesimal generator matrix for (individual) adult female
infection dynamics. Adult females follow SEI (Susceptible-Exposed-Infectious)
style dynamics with a Gamma distributed EIP, with a mean duration 1/q and
variance 1/nq^2 (following shape-scale parameterization, EIP ~ Gamma(n,1/nq)).
This function only constructs the rate matrix for either a single mosquito or
cohort that all emerged at the same time (the rate matrix for a population
with emergence is infinite in dimension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q_Imperial(q, n, mu, FOIv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Q_Imperial_+3A_q">q</code></td>
<td>
<p>related to scale parameter of Gamma distributed EIP (1/q is mean length of EIP)</p>
</td></tr>
<tr><td><code id="make_Q_Imperial_+3A_n">n</code></td>
<td>
<p>shape parameter of Gamma distributed EIP</p>
</td></tr>
<tr><td><code id="make_Q_Imperial_+3A_mu">mu</code></td>
<td>
<p>mosquito mortality rate</p>
</td></tr>
<tr><td><code id="make_Q_Imperial_+3A_foiv">FOIv</code></td>
<td>
<p>equilibrium force of infection on mosquitos</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rate matrix for a single (emergence) cohort of SEI mosquito
</p>

<hr>
<h2 id='make_Q_SEI'>Rate Matrix (Q) for Adult Mosquito SEI Dynamics</h2><span id='topic+make_Q_SEI'></span>

<h3>Description</h3>

<p>Construct the infinitesimal generator matrix for (individual) adult female
infection dynamics. Adult females follow SEI (Susceptible-Exposed-Infectious)
style dynamics with a Gamma distributed EIP, with a mean duration 1/q and
variance 1/nq^2 (following shape-scale parameterization, EIP ~ Gamma(n,1/nq)).
This function only constructs the rate matrix for either a single mosquito or
cohort that all emerged at the same time (the rate matrix for a population
with emergence is infinite in dimension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q_SEI(q, n, mu, c, a, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Q_SEI_+3A_q">q</code></td>
<td>
<p>related to scale parameter of Gamma distributed EIP (1/q is mean length of EIP)</p>
</td></tr>
<tr><td><code id="make_Q_SEI_+3A_n">n</code></td>
<td>
<p>shape parameter of Gamma distributed EIP</p>
</td></tr>
<tr><td><code id="make_Q_SEI_+3A_mu">mu</code></td>
<td>
<p>mosquito mortality rate</p>
</td></tr>
<tr><td><code id="make_Q_SEI_+3A_c">c</code></td>
<td>
<p>human to mosquito transmission efficiency</p>
</td></tr>
<tr><td><code id="make_Q_SEI_+3A_a">a</code></td>
<td>
<p>human biting rate</p>
</td></tr>
<tr><td><code id="make_Q_SEI_+3A_x">x</code></td>
<td>
<p>prevalence of disease in humans</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rate matrix for a single (emergence) cohort of SEI mosquito
</p>

<hr>
<h2 id='movement_prob2rate'>Convert Stochastic Matrix to Rate Matrix</h2><span id='topic+movement_prob2rate'></span>

<h3>Description</h3>

<p>Given a stochastic matrix, return the rate matrix (infinitesimal generator)
that would generate it when exponentiated over the interval of unit time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movement_prob2rate(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movement_prob2rate_+3A_tau">tau</code></td>
<td>
<p>a row normalized stochastic matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: if the matrix provided has diagonal-only rows (i.e., the location is
independent), the rate matrix will return 0 in that row, as there is no movement
rate that can generate that scenario.
</p>


<h3>Value</h3>

<p>a list with two elements: <code>gamma</code> negative diagonal of the rate
matrix, <code>mat</code> matrix of row normalized off-diagonal elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate random matrix for example
  #  This represents a 3-node landscape, with random movement between nodes
  moveMat &lt;- matrix(data = runif(n = 9), nrow = 3, ncol = 3)
  moveMat &lt;- moveMat/rowSums(moveMat)

  moveRate &lt;- movement_prob2rate(tau = moveMat)

</code></pre>

<hr>
<h2 id='mu_ts'>Mosquito Death Rates, Comoros Islands</h2><span id='topic+mu_ts'></span>

<h3>Description</h3>

<p>This is a matrix containing estimated mosquito death rates from the Comoros
Islands, between Mozambique and Madagascar. It provides hourly death rates over
the course of one year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mu_ts)
</code></pre>


<h3>Format</h3>

<p>matrix with 3 named columns and 8760 rows:
</p>

<dl>
<dt>Grande_Comore</dt><dd><p>Hourly death rates for main island</p>
</dd>
<dt>Moheli</dt><dd><p>Hourly death rates for second island</p>
</dd>
<dt>Anjouan</dt><dd><p>Hourly death rates for smallest island</p>
</dd>
</dl>


<hr>
<h2 id='sim_trajectory_base_CSV'>Simulate Trajectory From one  SPN Model</h2><span id='topic+sim_trajectory_base_CSV'></span>

<h3>Description</h3>

<p>This is an internal function to <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>. It does the
actual sampling once all of the functions have been checked and setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_base_CSV(
  x0,
  times,
  stepFun,
  folders,
  stage,
  events0 = NULL,
  batch = NULL,
  Sout = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_base_CSV_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_times">times</code></td>
<td>
<p>sequence of sampling times</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_stepfun">stepFun</code></td>
<td>
<p>a sampling function</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_folders">folders</code></td>
<td>
<p>vector of folders to write output</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_stage">stage</code></td>
<td>
<p>vector of life-stages to print</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_events0">events0</code></td>
<td>
<p>a <code>data.frame</code> of events (uses the same format as required
in package <code>deSolve</code> for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return, prints .csv files into provided folders
</p>

<hr>
<h2 id='sim_trajectory_base_CSV_decoupled'>Simulate Trajectory From one  SPN Model</h2><span id='topic+sim_trajectory_base_CSV_decoupled'></span>

<h3>Description</h3>

<p>This is an internal function to <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>. It does the
actual sampling once all of the functions have been checked and setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_base_CSV_decoupled(
  x0,
  h0,
  SPN_P,
  theta,
  times,
  stepFun,
  events0 = NULL,
  batch = NULL,
  Sout = NULL,
  verbose = TRUE,
  human_ode = "Imperial",
  cube = NULL,
  folders = folders
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_h0">h0</code></td>
<td>
<p>initial human state distribution</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_spn_p">SPN_P</code></td>
<td>
<p>stochastic petri net, places</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_times">times</code></td>
<td>
<p>sequence of sampling times</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_stepfun">stepFun</code></td>
<td>
<p>a sampling function</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_events0">events0</code></td>
<td>
<p>a <code>data.frame</code> of events (uses the same format as required
in package <code>deSolve</code> for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_human_ode">human_ode</code></td>
<td>
<p>ode function used for human states</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_CSV_decoupled_+3A_folders">folders</code></td>
<td>
<p>vector of folders to write output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return, prints .csv files into provided folders
</p>

<hr>
<h2 id='sim_trajectory_base_R'>Simulate Trajectory From one SPN Model</h2><span id='topic+sim_trajectory_base_R'></span>

<h3>Description</h3>

<p>This is an internal function to <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>. It does the
actual sampling once all of the functions have been checked and setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_base_R(
  x0,
  times,
  num_reps,
  stepFun,
  events = NULL,
  batch = NULL,
  Sout = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_base_R_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_times">times</code></td>
<td>
<p>sequence of sampling times</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_num_reps">num_reps</code></td>
<td>
<p>number of repetitions to run</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_stepfun">stepFun</code></td>
<td>
<p>a sampling function</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events (uses the same format as required in package <code>deSolve</code> for consistency, see <code><a href="deSolve.html#topic+events">events</a></code> for more information)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of sampled values
</p>

<hr>
<h2 id='sim_trajectory_base_R_decoupled_Imperial'>Simulate Trajectory From one SPN Model using Imperial Malaria model</h2><span id='topic+sim_trajectory_base_R_decoupled_Imperial'></span>

<h3>Description</h3>

<p>This is an internal function to <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>. It does the
actual sampling once all of the functions have been checked and setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_base_R_decoupled_Imperial(
  x0,
  h0,
  SPN_P,
  theta,
  times,
  num_reps,
  stepFun,
  events = NULL,
  batch = NULL,
  Sout = NULL,
  verbose = TRUE,
  cube = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_h0">h0</code></td>
<td>
<p>initial human state distribution</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_spn_p">SPN_P</code></td>
<td>
<p>stochastic petri net, places</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_times">times</code></td>
<td>
<p>sequence of sampling times</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_num_reps">num_reps</code></td>
<td>
<p>number of repetitions to run</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_stepfun">stepFun</code></td>
<td>
<p>a sampling function</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events (uses the same format as required in package <code>deSolve</code> for consistency, see <code><a href="deSolve.html#topic+events">events</a></code> for more information)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_Imperial_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of sampled values
</p>

<hr>
<h2 id='sim_trajectory_base_R_decoupled_SIS'>Simulate Trajectory From one SPN Model using Human SIS model</h2><span id='topic+sim_trajectory_base_R_decoupled_SIS'></span>

<h3>Description</h3>

<p>This is an internal function to <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>. It does the
actual sampling once all of the functions have been checked and setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_base_R_decoupled_SIS(
  x0,
  h0,
  SPN_P,
  theta,
  times,
  num_reps,
  stepFun,
  events = NULL,
  batch = NULL,
  Sout = NULL,
  verbose = TRUE,
  cube = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_h0">h0</code></td>
<td>
<p>initial human state distribution</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_spn_p">SPN_P</code></td>
<td>
<p>stochastic petri net, places</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_times">times</code></td>
<td>
<p>sequence of sampling times</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_num_reps">num_reps</code></td>
<td>
<p>number of repetitions to run</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_stepfun">stepFun</code></td>
<td>
<p>a sampling function</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events (uses the same format as required in package <code>deSolve</code> for consistency, see <code><a href="deSolve.html#topic+events">events</a></code> for more information)</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_base_R_decoupled_SIS_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of sampled values
</p>

<hr>
<h2 id='sim_trajectory_CSV'>Simulate Trajectory From a SPN Model</h2><span id='topic+sim_trajectory_CSV'></span>

<h3>Description</h3>

<p>This function provides a unified interface to the various simulation algorithms
for SPN, returning output sampled at a lattice of time points to the user, and
handling various exogenous events that may occur during the simulation
(such as release of adult mosquitoes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_CSV(
  x0,
  tmax,
  dt = 1,
  dt_stoch = 0.1,
  folders = "./",
  stage = c("M", "F"),
  S,
  hazards,
  Sout = NULL,
  sampler = "tau",
  method = "lsoda",
  events = NULL,
  batch = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_CSV_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state, M0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_tmax">tmax</code></td>
<td>
<p>the final time to end simulation</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_dt">dt</code></td>
<td>
<p>the time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_dt_stoch">dt_stoch</code></td>
<td>
<p>time-step used for approximation of hazards</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_folders">folders</code></td>
<td>
<p>vector of folders to write output</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_stage">stage</code></td>
<td>
<p>life-stages to print. Any combination of: &quot;E&quot;, &quot;L&quot;, &quot;P&quot;,&quot; M&quot;, &quot;U&quot;, &quot;F&quot;, &quot;H&quot;</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_hazards">hazards</code></td>
<td>
<p>list of hazard functions</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_sampler">sampler</code></td>
<td>
<p>determines sampling algorithm, one of; &quot;ode&quot;, &quot;tau&quot;, &quot;cle&quot;, or &quot;dm&quot;</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_method">method</code></td>
<td>
<p>if <code>sampler</code> is &quot;ode&quot;, the solver to use, from <code>deSolve</code></p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_+3A_...">...</code></td>
<td>
<p>further named arguments passed to the step function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dt_stoch</code> is used by the Poisson Time-Step (<code><a href="#topic+step_PTS">step_PTS</a></code>) and
Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods to approximate the hazards.
A smaller <code>dt_stoch</code> provides a better approximation, but will take longer
to run.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>hazards</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>Several samplers are provided. The default is a Poisson Time-Step
(<code><a href="#topic+step_PTS">step_PTS</a></code>) method. Other options are Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>) and a Chemical Langevin sampler (<code><a href="#topic+step_CLE">step_CLE</a></code>).
Additionally, for convenience, an ODE &quot;sampler&quot; (<code><a href="#topic+step_ODE">step_ODE</a></code>) is
provided for compatibility with other samplers. This function uses methods from
<code>deSolve</code>.
</p>
<p>If using the <code>ode</code> sampler, several <code>methods</code> are provided in the <code>deSolve</code>
package, see <code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider
using the &quot;rk4&quot; method to avoid excessive integration times.
</p>
<p>Additionally, <code>events</code> objects must follow the format required by
<code>deSolve</code>. This was done for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information.
</p>
<p>This function writes all output to .csv files. Each simulation is written to
a <code>folder</code> element - the number of repetitions is the number of folders
provided. What life-stages get recorded is specified by the <code>stage</code> parameter.
All life-stages can be stored, or any subset thereof. Females are split by
infection status, i.e. by &quot;S&quot;, &quot;E&quot;, or &quot;I&quot;.
</p>
<p>This function tracks state variables specified by argument <code>stage</code> by default; an optional argument <code>Sout</code>
can be provided to track number of event firings each time step (for discrete stochastic simulations),
or cumulative intensity (for continuous stochastic simulations), or the rate function of
particular events for ODE simulation. The matrix must have number of columns equal to
number of events in the system (the number of hazard functions), and a row for each tracking
variable. If <code>Sout</code> is provided, it outputs an additional csv, &quot;Tracking.csv&quot;.
The function <code><a href="#topic+track_hinf">track_hinf</a></code> is provided, which builds a matrix to track
human infection events.
</p>
<p>To return simulations to R for further processing, see <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>.
</p>


<h3>Value</h3>

<p>NULL - prints output to .csv files
</p>

<hr>
<h2 id='sim_trajectory_CSV_decoupled'>Simulate Trajectory From a SPN Model</h2><span id='topic+sim_trajectory_CSV_decoupled'></span>

<h3>Description</h3>

<p>This function provides a unified interface to the various simulation algorithms
for SPN, returning output sampled at a lattice of time points to the user, and
handling various exogenous events that may occur during the simulation
(such as release of adult mosquitoes). This function is used in decoupled sampling, where
the mosquito and human states are separated. This is used primarily when using the
Imperial model of malaria transmission.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_CSV_decoupled(
  x0,
  h0,
  inf_labels,
  tmax,
  dt = 1,
  dt_stoch = 0.1,
  folders = "./",
  S,
  hazards,
  SPN_P,
  theta,
  Sout = NULL,
  sampler = "tau",
  method = "lsoda",
  events = NULL,
  batch = NULL,
  verbose = TRUE,
  human_ode = "Imperial",
  cube = cube,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state, M0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_h0">h0</code></td>
<td>
<p>the initial human state distribution</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_inf_labels">inf_labels</code></td>
<td>
<p>labels corresponding to female mosquito infection hazard</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_tmax">tmax</code></td>
<td>
<p>the final time to end simulation</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_dt">dt</code></td>
<td>
<p>the time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_dt_stoch">dt_stoch</code></td>
<td>
<p>time-step used for approximation of hazards</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_folders">folders</code></td>
<td>
<p>vector of folders to write output</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_hazards">hazards</code></td>
<td>
<p>list of hazard functions</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_spn_p">SPN_P</code></td>
<td>
<p>stochastic petri net places</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_sampler">sampler</code></td>
<td>
<p>determines sampling algorithm, one of; &quot;ode&quot;, &quot;tau&quot;, &quot;cle&quot;, or &quot;dm&quot;</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_method">method</code></td>
<td>
<p>if <code>sampler</code> is &quot;ode&quot;, the solver to use, from <code>deSolve</code></p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_human_ode">human_ode</code></td>
<td>
<p>human ode function</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
<tr><td><code id="sim_trajectory_CSV_decoupled_+3A_...">...</code></td>
<td>
<p>further named arguments passed to the step function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dt_stoch</code> is used by the Poisson Time-Step (<code><a href="#topic+step_PTS">step_PTS</a></code>) and
Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods to approximate the hazards.
A smaller <code>dt_stoch</code> provides a better approximation, but will take longer
to run.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>hazards</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>Several samplers are provided. The default is a Poisson Time-Step
(<code><a href="#topic+step_PTS">step_PTS</a></code>) method. Other options are Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>) and a Chemical Langevin sampler (<code><a href="#topic+step_CLE">step_CLE</a></code>).
Additionally, for convenience, an ODE &quot;sampler&quot; (<code><a href="#topic+step_ODE">step_ODE</a></code>) is
provided for compatibility with other samplers. This function uses methods from
<code>deSolve</code>.
</p>
<p>If using the <code>ode</code> sampler, several <code>methods</code> are provided in the <code>deSolve</code>
package, see <code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider
using the &quot;rk4&quot; method to avoid excessive integration times.
</p>
<p>Additionally, <code>events</code> objects must follow the format required by
<code>deSolve</code>. This was done for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information.
</p>
<p>This function writes all output to .csv files. Each simulation is written to
a <code>folder</code> element - the number of repetitions is the number of folders
provided. For now, only adult mosquito states, human states, clinical incidence, and pathogen prevalence are
written to CSVs.
</p>
<p>This function tracks state variables specified by argument <code>stage</code> by default; an optional argument <code>Sout</code>
can be provided to track number of event firings each time step (for discrete stochastic simulations),
or cumulative intensity (for continuous stochastic simulations), or the rate function of
particular events for ODE simulation. The matrix must have number of columns equal to
number of events in the system (the number of hazard functions), and a row for each tracking
variable. If <code>Sout</code> is provided, it outputs an additional csv, &quot;Tracking.csv&quot;.
The function <code><a href="#topic+track_hinf">track_hinf</a></code> is provided, which builds a matrix to track
human infection events.
</p>
<p>To return simulations to R for further processing, see <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>.
</p>


<h3>Value</h3>

<p>NULL - prints output to .csv files
</p>

<hr>
<h2 id='sim_trajectory_R'>Simulate Trajectory From a SPN Model</h2><span id='topic+sim_trajectory_R'></span>

<h3>Description</h3>

<p>This function provides a unified interface to the various simulation algorithms
for SPN, returning output sampled at a lattice of time points to the user, and
handling various exogenous events that may occur during the simulation
(such as release of adult mosquitoes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_R(
  x0,
  tmax,
  dt = 1,
  dt_stoch = 0.1,
  num_reps = 1,
  S,
  hazards,
  Sout = NULL,
  sampler = "tau",
  method = "lsoda",
  events = NULL,
  batch = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_R_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state, M0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_tmax">tmax</code></td>
<td>
<p>the final time to end simulation (all simulations start at 0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_dt">dt</code></td>
<td>
<p>the time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_dt_stoch">dt_stoch</code></td>
<td>
<p>time-step used for approximation of hazards</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_num_reps">num_reps</code></td>
<td>
<p>number of repetitions to run, default is 1.</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_hazards">hazards</code></td>
<td>
<p>list of hazard functions</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_sampler">sampler</code></td>
<td>
<p>determines sampling algorithm, one of; &quot;ode&quot;, &quot;tau&quot;, &quot;cle&quot;, or &quot;dm&quot;</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_method">method</code></td>
<td>
<p>if <code>sampler</code> is &quot;ode&quot;, the solver to use, from <code>deSolve</code></p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_+3A_...">...</code></td>
<td>
<p>further named arguments passed to the step function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dt_stoch</code> is used by the Poisson Time-Step (<code><a href="#topic+step_PTS">step_PTS</a></code>) and
Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods to approximate the hazards.
A smaller <code>dt_stoch</code> provides a better approximation, but will take longer
to run.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>hazards</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>Several samplers are provided. The default is a Poisson Time-Step
(<code><a href="#topic+step_PTS">step_PTS</a></code>) method. Other options are Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>) and a Chemical Langevin sampler (<code><a href="#topic+step_CLE">step_CLE</a></code>).
Additionally, for convenience, an ODE &quot;sampler&quot; (<code><a href="#topic+step_ODE">step_ODE</a></code>) is
provided for compatibility with other samplers. This function uses methods from
<code>deSolve</code>.
</p>
<p>If using the <code>ode</code> sampler, several <code>methods</code> are provided in the <code>deSolve</code>
package, see <code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider
using the &quot;rk4&quot; method to avoid excessive integration times.
</p>
<p>Additionally, <code>events</code> objects must follow the format required by
<code>deSolve</code>. This was done for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information.
</p>
<p>This function tracks state variables by default; an optional argument <code>Sout</code>
can be provided to track number of event firings each time step (for discrete stochastic simulations),
or cumulative intensity (for continuous stochastic simulations), or the rate function of
particular events for ODE simulation. The matrix must have number of columns equal to
number of events in the system (the number of hazard functions), and a row for each tracking
variable. The function <code><a href="#topic+track_hinf">track_hinf</a></code> is provided, which builds a matrix to track
human infection events.
</p>
<p>To save output as .csv files, see <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>.
</p>


<h3>Value</h3>

<p>a list with 2 elements: &quot;state&quot; is the array of returned state values, and &quot;events&quot; will
return events tracked with <code>Sout</code> if provided, otherwise is <code>NULL</code>
</p>

<hr>
<h2 id='sim_trajectory_R_decoupled'>Simulate Trajectory From a SPN Model</h2><span id='topic+sim_trajectory_R_decoupled'></span>

<h3>Description</h3>

<p>This function provides a unified interface to the various simulation algorithms
for SPN, returning output sampled at a lattice of time points to the user, and
handling various exogenous events that may occur during the simulation
(such as release of adult mosquitoes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_R_decoupled(
  x0,
  h0,
  tmax,
  inf_labels,
  dt = 1,
  dt_stoch = 0.1,
  num_reps = 1,
  S,
  hazards,
  SPN_P,
  theta,
  Sout = NULL,
  sampler = "tau",
  method = "lsoda",
  events = NULL,
  batch = NULL,
  verbose = TRUE,
  human_ode = "Imperial",
  cube = cube,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_x0">x0</code></td>
<td>
<p>the initial marking of the SPN (initial state, M0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_h0">h0</code></td>
<td>
<p>the initial human state distribution</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_tmax">tmax</code></td>
<td>
<p>the final time to end simulation (all simulations start at 0)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_inf_labels">inf_labels</code></td>
<td>
<p>labels corresponding to female mosquito infection hazard</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_dt">dt</code></td>
<td>
<p>the time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_dt_stoch">dt_stoch</code></td>
<td>
<p>time-step used for approximation of hazards</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_num_reps">num_reps</code></td>
<td>
<p>number of repetitions to run, default is 1.</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_hazards">hazards</code></td>
<td>
<p>list of hazard functions</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_spn_p">SPN_P</code></td>
<td>
<p>stochastic petri net places</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_theta">theta</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track event firings</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_sampler">sampler</code></td>
<td>
<p>determines sampling algorithm, one of; &quot;ode&quot;, &quot;tau&quot;, &quot;cle&quot;, or &quot;dm&quot;</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_method">method</code></td>
<td>
<p>if <code>sampler</code> is &quot;ode&quot;, the solver to use, from <code>deSolve</code></p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_events">events</code></td>
<td>
<p>a <code>data.frame</code> of events, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_batch">batch</code></td>
<td>
<p>a <code>list</code> of batch migration events, created from <code><a href="#topic+batch_migration">batch_migration</a></code>, may be set to <code>NULL</code> if not used</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>print a progress bar?</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_human_ode">human_ode</code></td>
<td>
<p>human ode function</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_cube">cube</code></td>
<td>
<p>inheritance cube</p>
</td></tr>
<tr><td><code id="sim_trajectory_R_decoupled_+3A_...">...</code></td>
<td>
<p>further named arguments passed to the step function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dt_stoch</code> is used by the Poisson Time-Step (<code><a href="#topic+step_PTS">step_PTS</a></code>) and
Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods to approximate the hazards.
A smaller <code>dt_stoch</code> provides a better approximation, but will take longer
to run.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>hazards</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>Several samplers are provided. The default is a Poisson Time-Step
(<code><a href="#topic+step_PTS">step_PTS</a></code>) method. Other options are Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>) and a Chemical Langevin sampler (<code><a href="#topic+step_CLE">step_CLE</a></code>).
Additionally, for convenience, an ODE &quot;sampler&quot; (<code><a href="#topic+step_ODE">step_ODE</a></code>) is
provided for compatibility with other samplers. This function uses methods from
<code>deSolve</code>.
</p>
<p>If using the <code>ode</code> sampler, several <code>methods</code> are provided in the <code>deSolve</code>
package, see <code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider
using the &quot;rk4&quot; method to avoid excessive integration times.
</p>
<p>Additionally, <code>events</code> objects must follow the format required by
<code>deSolve</code>. This was done for consistency, see <code><a href="deSolve.html#topic+events">events</a></code>
for more information.
</p>
<p>This function tracks state variables by default; an optional argument <code>Sout</code>
can be provided to track number of event firings each time step (for discrete stochastic simulations),
or cumulative intensity (for continuous stochastic simulations), or the rate function of
particular events for ODE simulation. The matrix must have number of columns equal to
number of events in the system (the number of hazard functions), and a row for each tracking
variable. The function <code><a href="#topic+track_hinf">track_hinf</a></code> is provided, which builds a matrix to track
human infection events.
</p>
<p>To save output as .csv files, see <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>.
</p>


<h3>Value</h3>

<p>a list with 2 elements: &quot;state&quot; is the array of returned state values, and &quot;events&quot; will
return events tracked with <code>Sout</code> if provided, otherwise is <code>NULL</code>
</p>

<hr>
<h2 id='solve_muAqua'>Solve for Constant Aquatic Mortality</h2><span id='topic+solve_muAqua'></span>

<h3>Description</h3>

<p>In <code>MGDrivE</code>, the model was typically solved at equilibrium assuming the
density-independent mortality was constant over aquatic stages (eggs, larvae, pupae),
given a daily growth rate, <code class="reqn">r_{M}</code>. Given that growth rate, it solved for
that mortality <code class="reqn">\mu_{Aqua}</code> by relating it with <code class="reqn">R_{M}</code>, the per-generation
growth rate of the population, calculable from <code class="reqn">r_{M}</code> and the mean
duration of life stages. This function uses <code><a href="stats.html#topic+uniroot">uniroot</a></code> to
solve for <code class="reqn">mu_{Aqua}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_muAqua(params, rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_muAqua_+3A_params">params</code></td>
<td>
<p>a named list of parameters</p>
</td></tr>
<tr><td><code id="solve_muAqua_+3A_rm">rm</code></td>
<td>
<p>the daily growth rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs the following parameters in <code>params</code>:
</p>

<ul>
<li> <p><code>muF</code>: adult female mortality
</p>
</li>
<li> <p><code>beta</code>: rate of egg laying
</p>
</li>
<li> <p><code>phi</code>: sex ratio at emergence
</p>
</li>
<li> <p><code>qE</code>: inverse of mean duration of egg stage
</p>
</li>
<li> <p><code>nE</code>: shape parameter of Erlang-distributed egg stage
</p>
</li>
<li> <p><code>qL</code>: inverse of mean duration of larval stage
</p>
</li>
<li> <p><code>nL</code>: shape parameter of Erlang-distributed larval stage
</p>
</li>
<li> <p><code>qP</code>: inverse of mean duration of pupal stage
</p>
</li>
<li> <p><code>nP</code>: shape parameter of Erlang-distributed pupal stage
</p>
</li></ul>



<h3>Value</h3>

<p>location of the root, as provided from uniroot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- list(qE = 1/4, nE = 2, qL = 1/5, nL = 3, qP = 1/6, nP = 2, muF = 1/12,
             beta = 32, phi = 0.5);
muAqatic &lt;- solve_muAqua(params = theta, rm = 1.096)

</code></pre>

<hr>
<h2 id='split_aggregate_CSV'>Split CSV output by Patch and Aggregate by Mate or Dwell-Stage</h2><span id='topic+split_aggregate_CSV'></span>

<h3>Description</h3>

<p>This function reads in the output files from <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
and splits them into smaller files. The files are output by patch, with the
appropriate patch numbers for mosquitoes or humans, and specific stages are
aggregated by a given metric. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_aggregate_CSV(
  read_dir,
  write_dir = read_dir,
  stage = c("E", "L", "P", "M", "U", "FS", "FE", "FI", "H"),
  spn_P,
  tmax,
  dt,
  erlang = FALSE,
  sum_fem = FALSE,
  rem_file = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_aggregate_CSV_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory where output was written to</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_write_dir">write_dir</code></td>
<td>
<p>Directory to write output to. Default is read_dir</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_stage">stage</code></td>
<td>
<p>Life stage to print, see details</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_spn_p">spn_P</code></td>
<td>
<p>Places object, see details</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_tmax">tmax</code></td>
<td>
<p>The final time to end simulation</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_dt">dt</code></td>
<td>
<p>The time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_erlang">erlang</code></td>
<td>
<p>Boolean, default is FALSE, to return summaries by genotype</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_sum_fem">sum_fem</code></td>
<td>
<p>if <code>TRUE</code>, in addition to FS, FE, FI output by node and repetition, output an
additional file F which sums over infection states (S,E,I). Does nothing if the
simulation did not include epi dynamics.</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_rem_file">rem_file</code></td>
<td>
<p>Remove original output? Default is FALSE</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the <code>read_dir</code>, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> read_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M.csv
</p>
</li>
<li><p> FS.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M.csv
</p>
</li>
<li><p> FS.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>This function expects the <code>write_dir</code> to be empty, and it sets up the
same file structure as the <code>read_dir</code>. For a 2-node simulation, the output
will be organized similar to: <br />
</p>

<ul>
<li><p> write_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p><code>stage</code> defines which life-stages the function will analyze. These stages
must be any combination of: &quot;E&quot;, &quot;L&quot;, &quot;P&quot;, &quot;M&quot;, &quot;U&quot;, &quot;FS&quot;, &quot;FE&quot;, &quot;FI&quot;, &quot;H&quot;.
These must come from the set of stages provided to <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
via the <code>stage</code> argument. It can be less than what was printed by the simulation,
but any extra stages provided, but not printed, will throw a warning and then
be ignored.
</p>
<p><code>erlang</code> defines how aquatic (eggs, larvae, and pupae) stages and adult females
(only mated females) are aggregated. By default, <code>erlang</code> is FALSE, and
all of these stages are summarized by genotype only, combining any Erlang-distributed
dwell stages (for eggs, larvae, and pupae) or latent infection (for adult females)
stages. If <code>erlang</code> is TRUE, summaries are returned by dwell stage or infection
status, combining any genotype information. <br />
Female summaries always combine over mate-genotype, so only female genotypes
are returned.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p><code>tmax</code>, <code>dt</code> define the last sampling
time, and each sampling time in-between.
</p>
<p>For more details about using this function to process CSV output see:
<code>vignette("data-analysis", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>Writes output to files in write_dir
</p>

<hr>
<h2 id='split_aggregate_CSV_decoupled'>Split CSV output for decoupled sampling with Imperial malaria model</h2><span id='topic+split_aggregate_CSV_decoupled'></span>

<h3>Description</h3>

<p>This function reads in the output files from <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
and splits them into smaller files. The files are output by patch, with the
appropriate patch numbers for mosquitoes or humans, and specific stages are
aggregated by a given metric. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_aggregate_CSV_decoupled(
  read_dir,
  write_dir = read_dir,
  spn_P,
  tmax,
  dt,
  human_states,
  sum_fem = FALSE,
  rem_file = FALSE,
  verbose = TRUE,
  erlang = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory where output was written to</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_write_dir">write_dir</code></td>
<td>
<p>Directory to write output to. Default is read_dir</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_spn_p">spn_P</code></td>
<td>
<p>Places object, see details</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_tmax">tmax</code></td>
<td>
<p>The final time to end simulation</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_dt">dt</code></td>
<td>
<p>The time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_human_states">human_states</code></td>
<td>
<p>human state distribution</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_sum_fem">sum_fem</code></td>
<td>
<p>if <code>TRUE</code>, in addition to FS, FE, FI output by node and repetition, output an
additional file F which sums over infection states (S,E,I). Does nothing if the
simulation did not include epi dynamics.</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_rem_file">rem_file</code></td>
<td>
<p>Remove original output? Default is FALSE</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
<tr><td><code id="split_aggregate_CSV_decoupled_+3A_erlang">erlang</code></td>
<td>
<p>erlang distributed states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the <code>read_dir</code>, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> read_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M.csv
</p>
</li>
<li><p> FS.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M.csv
</p>
</li>
<li><p> FS.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>This function expects the <code>write_dir</code> to be empty, and it sets up the
same file structure as the <code>read_dir</code>. For a 2-node simulation, the output
will be organized similar to: <br />
</p>

<ul>
<li><p> write_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p><code>tmax</code>, <code>dt</code> define the last sampling
time, and each sampling time in-between.
</p>
<p>For more details about using this function to process CSV output see:
<code>vignette("data-analysis", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>Writes output to files in write_dir
</p>

<hr>
<h2 id='spn_hazards'>Make Hazards (Lambda) For a MGDrivE2: Node and Network Simulations</h2><span id='topic+spn_hazards'></span>

<h3>Description</h3>

<p>Using the structural (topological) SPN model as well as parameters in the
<code>cube</code> and <code>params</code> objects, generate a list (of length |v|) of
hazards, each implemented as a function closure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_hazards(
  spn_P,
  spn_T,
  cube,
  params,
  type = "life",
  log_dd = TRUE,
  exact = TRUE,
  tol = 1e-12,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_hazards_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_spn_t">spn_T</code></td>
<td>
<p>the set of transitions (T) (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_type">type</code></td>
<td>
<p>string indicating type of hazards, one of; &quot;life&quot;, &quot;SIS&quot;, or &quot;SEIR&quot;</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_log_dd">log_dd</code></td>
<td>
<p>if <code>TRUE</code>, use logistic (carrying capacity) density dependent hazards, if <code>FALSE</code> use Lotka-Volterra density dependent hazards for larval mortality</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_exact">exact</code></td>
<td>
<p>boolean, make exact (integer input) hazards? Default is TRUE</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_tol">tol</code></td>
<td>
<p>if <code>exact=FALSE</code>, the value of hazard below which it is clipped to 0</p>
</td></tr>
<tr><td><code id="spn_hazards_+3A_verbose">verbose</code></td>
<td>
<p>display a progress bar when making hazards?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If these hazards will be used in a continuous approximation algorithm, such as
an ODE method (<code><a href="#topic+step_ODE">step_ODE</a></code>) or Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>), it is recommended to use <code>exact=FALSE</code>. If the
hazards will be used in an integer state space method, such as tau-leaping
(<code><a href="#topic+step_PTS">step_PTS</a></code>) or Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods,
it is recommended to use <code>exact=TRUE</code>.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The set of transitions (<code>spn_T</code>) is generated from one of the following:
<code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>, <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>,
<code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>, <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>,
<code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>, <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>.
</p>
<p>The <code>params</code> objected is generated from either <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
or <code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>; it is the &quot;params&quot; object in the return
list. The equilibrium function used must match the <code>type</code> parameter.
</p>
<p>The <code>type</code> parameter indicates what type of simulation is being run. It
is one of: &quot;life&quot;, &quot;SIS&quot;, or &quot;SEIR&quot;. This must match the <code>params</code> object
supplied.
</p>
<p>Use of this function is demonstrated in many vignettes, <code>browseVignettes(package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>list of length 2: <code>hazards</code> is a list of named closures for every
state transition in the model, <code>flag</code> is a boolean indicating exact or approximate
</p>

<hr>
<h2 id='spn_hazards_decoupled'>Make Hazards (Lambda) For a MGDrivE2: Node and Network Simulations</h2><span id='topic+spn_hazards_decoupled'></span>

<h3>Description</h3>

<p>Using the structural (topological) SPN model as well as parameters in the
<code>cube</code> and <code>params</code> objects, generate a list (of length |v|) of
hazards, each implemented as a function closure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_hazards_decoupled(
  spn_P,
  spn_T,
  cube,
  params,
  type = "SIS",
  log_dd = TRUE,
  exact = TRUE,
  tol = 1e-12,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_hazards_decoupled_+3A_spn_p">spn_P</code></td>
<td>
<p>the set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_spn_t">spn_T</code></td>
<td>
<p>the set of transitions (T) (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_type">type</code></td>
<td>
<p>string indicating type of hazards, one of; &quot;life&quot;, &quot;SIS&quot;, &quot;Imperial&quot; or &quot;SEIR&quot;</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_log_dd">log_dd</code></td>
<td>
<p>if <code>TRUE</code>, use logistic (carrying capacity) density dependent hazards, if <code>FALSE</code> use Lotka-Volterra density dependent hazards for larval mortality</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_exact">exact</code></td>
<td>
<p>boolean, make exact (integer input) hazards? Default is TRUE</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_tol">tol</code></td>
<td>
<p>if <code>exact=FALSE</code>, the value of hazard below which it is clipped to 0</p>
</td></tr>
<tr><td><code id="spn_hazards_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>display a progress bar when making hazards?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If these hazards will be used in a continuous approximation algorithm, such as
an ODE method (<code><a href="#topic+step_ODE">step_ODE</a></code>) or Gillespie's Direct Method
(<code><a href="#topic+step_DM">step_DM</a></code>), it is recommended to use <code>exact=FALSE</code>. If the
hazards will be used in an integer state space method, such as tau-leaping
(<code><a href="#topic+step_PTS">step_PTS</a></code>) or Chemical Langevin (<code><a href="#topic+step_CLE">step_CLE</a></code>) methods,
it is recommended to use <code>exact=TRUE</code>.
</p>
<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The set of transitions (<code>spn_T</code>) is generated from one of the following:
<code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>, <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>,
<code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>, <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>,
<code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>, <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>.
</p>
<p>The <code>params</code> objected is generated from either <code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
or <code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>; it is the &quot;params&quot; object in the return
list. The equilibrium function used must match the <code>type</code> parameter.
</p>
<p>The <code>type</code> parameter indicates what type of simulation is being run. It
is one of: &quot;life&quot;, &quot;SIS&quot;, or &quot;SEIR&quot;. This must match the <code>params</code> object
supplied.
</p>
<p>Use of this function is demonstrated in many vignettes, <code>browseVignettes(package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>list of length 2: <code>hazards</code> is a list of named closures for every
state transition in the model, <code>flag</code> is a boolean indicating exact or approximate
</p>

<hr>
<h2 id='spn_P_epi_decoupled_node'>Make Places (P) For a Node (SEI Mosquitoes). Note in the v2 epi module, we only
use the SPN framework for the mosquito component of the model. The human compoenent
will be handled separately in the sampler, and will be formulated as an ODE.
This function makes the set of places (P) for a SPN. It is used alone if our model
is a single-node metapopulation for mosquito SEI and dynamics; This is used by both
SIS and Imperial transmission models.</h2><span id='topic+spn_P_epi_decoupled_node'></span>

<h3>Description</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_epi_decoupled_node(params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_epi_decoupled_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_epi_decoupled_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of using this function, see:
<code>vignette("epi-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the places
by life stage, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_epiSEIR_network'>Make Places (P) For a Network (SEI Mosquitoes - SEIR Humans)</h2><span id='topic+spn_P_epiSEIR_network'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN model of a metapopulation
network for simulation of coupled SEI-SEIR dynamics. It is the network version
of <code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_epiSEIR_network(node_list, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_epiSEIR_network_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="spn_P_epiSEIR_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_epiSEIR_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("seir-dynamics", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the places
by life stage and node, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_epiSEIR_node'>Make Places (P) For a Node (SEI Mosquitoes - SEIR Humans)</h2><span id='topic+spn_P_epiSEIR_node'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN. It is used alone if our
model is a single-node metapopulation for mosquito SEI and human SEIR dynamics;
otherwise it is used as part of other functions to make SPN models with larger
state spaces (metapopulation models, <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_epiSEIR_node(params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_epiSEIR_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_epiSEIR_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("seir-dynamics", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the
places by life stage, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_epiSIS_network'>Make Places (P) For a Network (SEI Mosquitoes - SIS Humans)</h2><span id='topic+spn_P_epiSIS_network'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN model of a metapopulation
network for simulation of coupled SEI-SIS dynamics. It is the network version
of <code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_epiSIS_network(node_list, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_epiSIS_network_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node_id with only mosquitoes, h = a node_id with only humans, b = a node_id with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="spn_P_epiSIS_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_epiSIS_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("epi-network", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the
places by life stage and node_id, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_epiSIS_node'>Make Places (P) For a Node (SEI Mosquitoes - SIS Humans)</h2><span id='topic+spn_P_epiSIS_node'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN. It is used alone if our model
is a single-node metapopulation for mosquito SEI and human SIS dynamics;
otherwise it is used as part of other functions to make SPN models with
larger state spaces (metapopulation models, see <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_epiSIS_node(params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_epiSIS_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_epiSIS_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("epi-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the places
by life stage, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_lifecycle_network'>Make Places (P) For a Network (Mosquitoes only)</h2><span id='topic+spn_P_lifecycle_network'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN model of a metapopulation
network. It is the network version of <code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_lifecycle_network(num_nodes, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_lifecycle_network_+3A_num_nodes">num_nodes</code></td>
<td>
<p>number of nodes in the network</p>
</td></tr>
<tr><td><code id="spn_P_lifecycle_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_lifecycle_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, and <code>nP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-network", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the
places by life stage and node_id, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_P_lifecycle_node'>Make Places (P) For a Node (Mosquitoes only)</h2><span id='topic+spn_P_lifecycle_node'></span>

<h3>Description</h3>

<p>This function makes the set of places (P) for a SPN. It is used alone if our model
is a single-node metapopulation for mosquito dynamics only; otherwise it is used
as part of other functions to make SPN models with larger state spaces
(metapopulation models, see <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_P_lifecycle_node(params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_P_lifecycle_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_P_lifecycle_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, and <code>nP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>ix</code> contains labeled indices of the places
by life stage, <code>u</code> is the character vector of places (P)
</p>

<hr>
<h2 id='spn_Post'>Make Post Matrix For a Petri Net</h2><span id='topic+spn_Post'></span>

<h3>Description</h3>

<p>Generate the Post (|v| by |u|) matrix for the SPN. This gives the edges from
T to P (output arcs) in the bipartite network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_Post(spn_P, spn_T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_Post_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="spn_Post_+3A_spn_t">spn_T</code></td>
<td>
<p>set of transitions (T) (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The set of transitions (<code>spn_T</code>) is generated from one of the following:
<code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>, <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>,
<code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>, <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>,
<code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>, <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>.
</p>


<h3>Value</h3>

<p>a matrix of type <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>
</p>

<hr>
<h2 id='spn_Pre'>Make Pre Matrix For a Petri Net</h2><span id='topic+spn_Pre'></span>

<h3>Description</h3>

<p>Generate the Pre (|v| by |u|) matrix for the SPN. This gives the edges from P
to T (input arcs) in the bipartite network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_Pre(spn_P, spn_T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_Pre_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="spn_Pre_+3A_spn_t">spn_T</code></td>
<td>
<p>set of transitions (T) (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The set of transitions (<code>spn_T</code>) is generated from one of the following:
<code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>, <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>,
<code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>, <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>,
<code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>, <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>.
</p>


<h3>Value</h3>

<p>a matrix of type <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>
</p>

<hr>
<h2 id='spn_S'>Make stoichiometry Matrix For a Petri Net</h2><span id='topic+spn_S'></span>

<h3>Description</h3>

<p>Generate the stoichiometry (|u| by |v|) matrix for the SPN.
Each column gives the net effect of that transition firing upon the state
space of the model. Internally, this creates a Pre (<code><a href="#topic+spn_Pre">spn_Pre</a></code>) and
Post (<code><a href="#topic+spn_Post">spn_Post</a></code>) matrix, and then calculates the final stoichiometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_S(spn_P, spn_T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_S_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places (P) (see details)</p>
</td></tr>
<tr><td><code id="spn_S_+3A_spn_t">spn_T</code></td>
<td>
<p>set of transitions (T) (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The set of transitions (<code>spn_T</code>) is generated from one of the following:
<code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>, <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>,
<code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>, <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>,
<code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>, <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>.
</p>


<h3>Value</h3>

<p>stoichiometry matrix representing the net effect of a transition in the SPN state model.
</p>

<hr>
<h2 id='spn_T_epi_decoupled_node'>Make Transitions (T) For a Node (SEI Mosquitoes)</h2><span id='topic+spn_T_epi_decoupled_node'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN. It is used alone if
our model is a single-node metapopulation of mosquito; otherwise
it is used as part of other functions to make SPN models with larger state
spaces (metapopulation models, see <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_epi_decoupled_node(spn_P, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_epi_decoupled_node_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code>spn_P_epiSIS_node_decoupled</code> function</p>
</td></tr>
<tr><td><code id="spn_T_epi_decoupled_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_epi_decoupled_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code>spn_P_epiSIS_node_decoupled</code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
This is used by both decoupled SIS and Imperial transmission model sampling.
For examples of using this function, see:
<code>vignette("epi-node-decoupled", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_epiSEIR_network'>Make Transitions (T) For a Network (SEI Mosquitoes - SEIR Humans)</h2><span id='topic+spn_T_epiSEIR_network'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN model of a
metapopulation network for simulation of coupled SEI-SEIR dynamics. It is the
network version of <code><a href="#topic+spn_T_epiSEIR_node">spn_T_epiSEIR_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_epiSEIR_network(node_list, spn_P, params, cube, h_move, m_move)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_epiSEIR_network_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_network_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code></p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_network_+3A_h_move">h_move</code></td>
<td>
<p>binary adjacency matrix indicating if movement of humans between nodes is possible or not</p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_network_+3A_m_move">m_move</code></td>
<td>
<p>binary adjacency matrix indicating if movement of mosquitoes between nodes is possible or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For larger networks, this function may take some time to return, please be patient;
the Petri Net modeling formalism trades additional computation time at model
initialization for faster sampling of trajectories within a simulation.
</p>
<p>Please note, the movement matrices (<code>h_move</code> and <code>m_move</code>) are NOT
stochastic matrices, just binary matrices that say if i,j can exchange population.
Diagonal elements must be <code>FALSE</code>, and both matrices are checked for validity; the
function will stop with errors if the adjacency matrix specifies illegal movement
rules (e.g.; mosquito movement from a &quot;h&quot; node to a &quot;b&quot; node)
</p>
<p>For examples of using this function, see:
<code>vignette("seir-dynamics", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_epiSEIR_node'>Make Transitions (T) For a Node (SEI Mosquitoes - SEIR Humans)</h2><span id='topic+spn_T_epiSEIR_node'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN. It is used alone
if our model is a single-node metapopulation of mosquito and human dynamics;
otherwise it is used as part of other functions to make SPN models with larger
state spaces (metapopulation models, see <code><a href="#topic+spn_T_epiSEIR_network">spn_T_epiSEIR_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_epiSEIR_node(spn_P, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_epiSEIR_node_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code></p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_epiSEIR_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SEIR">equilibrium_SEI_SEIR</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For examples of using this function, see:
<code>vignette("seir-dynamics", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_epiSIS_network'>Make Transitions (T) For a Network (SEI Mosquitoes - SIS Humans)</h2><span id='topic+spn_T_epiSIS_network'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN model of a
metapopulation network for simulation of coupled SEI-SIS dynamics. It is the
network version of <code><a href="#topic+spn_T_epiSIS_node">spn_T_epiSIS_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_epiSIS_network(node_list, spn_P, params, cube, h_move, m_move)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_epiSIS_network_+3A_node_list">node_list</code></td>
<td>
<p>a character vector specifying what type of nodes to create;
(m = a node with only mosquitoes, h = a node with only humans, b = a node with both humans and mosquitoes)</p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_network_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code></p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_network_+3A_h_move">h_move</code></td>
<td>
<p>binary adjacency matrix indicating if movement of humans between nodes is possible or not</p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_network_+3A_m_move">m_move</code></td>
<td>
<p>binary adjacency matrix indicating if movement of mosquitoes between nodes is possible or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For larger networks, this function may take some time to return, please be patient;
the Petri Net modeling formalism trades additional computation time at model
initialization for faster sampling of trajectories within a simulation.
</p>
<p>Please note, the movement matrices (<code>h_move</code> and <code>m_move</code>) are NOT
stochastic matrices, just binary matrices that say if i,j can exchange population.
Diagonal elements must be <code>FALSE</code>, and both matrices are checked for validity; the
function will stop with errors if the adjacency matrix specifies illegal movement
rules (e.g.; mosquito movement from a &quot;h&quot; node to a &quot;b&quot; node)
</p>
<p>For examples of using this function, see:
<code>vignette("epi-network", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_epiSIS_node'>Make Transitions (T) For a Node (SEI Mosquitoes - SIS Humans)</h2><span id='topic+spn_T_epiSIS_node'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN. It is used alone if
our model is a single-node metapopulation of mosquito and human dynamics; otherwise
it is used as part of other functions to make SPN models with larger state
spaces (metapopulation models, see <code><a href="#topic+spn_T_epiSIS_network">spn_T_epiSIS_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_epiSIS_node(spn_P, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_epiSIS_node_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code></p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_epiSIS_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, <code>nP</code>, and <code>nEIP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_SEI_SIS">equilibrium_SEI_SIS</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For examples of using this function, see:
<code>vignette("epi-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_lifecycle_network'>Make Transitions (T) For a Network (Mosquitoes only)</h2><span id='topic+spn_T_lifecycle_network'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN model of a
metapopulation network. It is the network version of <code><a href="#topic+spn_T_lifecycle_node">spn_T_lifecycle_node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_lifecycle_network(spn_P, params, cube, n = NULL, m_move = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_lifecycle_network_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code></p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_network_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_network_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_network_+3A_n">n</code></td>
<td>
<p>an integer giving the number of nodes</p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_network_+3A_m_move">m_move</code></td>
<td>
<p>binary adjacency matrix indicating if movement of mosquitoes between nodes is possible or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, and <code>nP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For larger networks, this function may take some time to return, please be patient;
the Petri Net modeling formalism trades additional computation time at model
initialization for faster sampling of trajectories within a simulation.
</p>
<p>Please note, the movement matrix (<code>m_move</code>) is NOT a
stochastic matrices, just a binary matrix that say if i,j can exchange population.
Diagonal elements must be <code>FALSE</code>.
</p>
<p>At least one of the arguments <code>n</code> and <code>m_move</code> must be provided. If both are provided
<code>n</code> is ignored.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-network", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='spn_T_lifecycle_node'>Make Transitions (T) For a Node (Mosquitoes only)</h2><span id='topic+spn_T_lifecycle_node'></span>

<h3>Description</h3>

<p>This function makes the set of transitions (T) for a SPN. It is used alone if
our model is a single-node metapopulation for mosquito dynamics only; otherwise
it is used as part of other functions to make SPN models with larger state
spaces (metapopulation models, see <code><a href="#topic+spn_T_lifecycle_network">spn_T_lifecycle_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spn_T_lifecycle_node(spn_P, params, cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spn_T_lifecycle_node_+3A_spn_p">spn_P</code></td>
<td>
<p>set of places produced by <code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code></p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_node_+3A_params">params</code></td>
<td>
<p>a named list of parameters (see details)</p>
</td></tr>
<tr><td><code id="spn_T_lifecycle_node_+3A_cube">cube</code></td>
<td>
<p>an inheritance cube from the <code>MGDrivE</code> package (e.g. <code><a href="MGDrivE.html#topic+cubeMendelian">cubeMendelian</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the places produced from <code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>
and builds all possible transitions between subsets of those places.
</p>
<p>The <code>params</code> argument supplies all of the ecological parameters necessary
to calculate equilibrium values. This function requires the <code>nE</code>,
<code>nL</code>, and <code>nP</code> parameters to be specified. For more details, see
<code><a href="#topic+equilibrium_lifeycle">equilibrium_lifeycle</a></code>
</p>
<p>While this function produces all structural information related to transitions,
hazards are produced by a separate function, <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a list with two elements: <code>T</code> contains transitions packets as lists,
<code>v</code> is the character vector of transitions (T)
</p>

<hr>
<h2 id='step_CLE'>Make Chemical Langevin (CLE) Sampler for a SPN model</h2><span id='topic+step_CLE'></span>

<h3>Description</h3>

<p>Make a function closure to implement a chemical Langevin (continuous-state)
approximation for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_CLE(S, Sout, haz, dt = 0.01, maxhaz = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_CLE_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_CLE_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings. In the continuous stochastic model this will
be the approximate cumulative intensity of each event.</p>
</td></tr>
<tr><td><code id="step_CLE_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_CLE_+3A_dt">dt</code></td>
<td>
<p>time-step for Euler-Maruyama method used to solve the SDE system</p>
</td></tr>
<tr><td><code id="step_CLE_+3A_maxhaz">maxhaz</code></td>
<td>
<p>maximum allowable hazard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chemical Langevin approximation is a numerical simulation of a Fokker-Planck
approximation to the Master equations (Kolmogorov Forwards Equations) governing
the stochastic model; the CLE approximation is a second-order approximation
that will get the correct mean and variance but higher order moments will be
incorrect.
</p>
<p>The design of <code>step_CLE</code> is from: Wilkinson, D. J. (2011). Stochastic
modeling for systems biology. CRC press
</p>
<p>Elements of the <code>N</code> list come from two places: The stoichiometry matrix
(<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code> and the hazards (<code>h</code>) come
from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_PTS">step_PTS</a></code>, <code><a href="#topic+step_DM">step_DM</a></code>, <code><a href="#topic+step_ODE">step_ODE</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='step_DM'>Make Gillespie's Direct Method (DM) Sampler for a SPN model</h2><span id='topic+step_DM'></span>

<h3>Description</h3>

<p>Make a function closure to implement Gillespie's Direct Method sampler for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_DM(S, Sout, haz, maxhaz = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_DM_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_DM_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings</p>
</td></tr>
<tr><td><code id="step_DM_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_DM_+3A_maxhaz">maxhaz</code></td>
<td>
<p>maximum allowable hazard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The direct method is an exact sampling algorithm; it simulates each event individually.
Because of this it may be extremely slow for non-trivial population sizes, and
thus should be used to debug and test rather than for serious Monte Carlo simulation.
</p>
<p>The design of <code>step_DM</code> is from: Wilkinson, D. J. (2011). Stochastic
modeling for systems biology. CRC press
</p>
<p>Elements of the <code>N</code> list come from two places: The stoichiometry matrix
(<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code> and the hazards (<code>h</code>) come
from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_CLE">step_CLE</a></code>, <code><a href="#topic+step_PTS">step_PTS</a></code>, <code><a href="#topic+step_ODE">step_ODE</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='step_ODE'>Make Mean-field Approximation (ODE) Numerical Integrator for a SPN Model</h2><span id='topic+step_ODE'></span>

<h3>Description</h3>

<p>Make a function closure to implement a first order mean-field ODE approximation
for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ODE(S, Sout, haz, method = "lsoda")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ODE_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_ODE_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings. In the deterministic case it will return
the rate of that event at the end of the time step</p>
</td></tr>
<tr><td><code id="step_ODE_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_ODE_+3A_method">method</code></td>
<td>
<p>a character giving the type of numerical integrator used, the default is &quot;lsoda&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is equivalent to considering the ODEs describing the time
evolution of the mean trajectory (first moment) and setting all higher order
moments which appear on the right hand side to zero.
</p>
<p>The solvers used within can be found in the <code>deSolve</code> package, see
<code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider using the &quot;rk4&quot;
method to avoid excessive integration times.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>haz</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_CLE">step_CLE</a></code>, <code><a href="#topic+step_PTS">step_PTS</a></code>, <code><a href="#topic+step_DM">step_DM</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='step_ODE_decoupled'>Make Mean-field Approximation (ODE) Numerical Integrator for a SPN Model for Decoupled Epi Dynamics</h2><span id='topic+step_ODE_decoupled'></span>

<h3>Description</h3>

<p>Make a function closure to implement a first order mean-field ODE approximation
for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ODE_decoupled(S, Sout, haz, method = "lsoda", human_ode = "SIS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ODE_decoupled_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_ODE_decoupled_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings. In the deterministic case it will return
the rate of that event at the end of the time step</p>
</td></tr>
<tr><td><code id="step_ODE_decoupled_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_ODE_decoupled_+3A_method">method</code></td>
<td>
<p>a character giving the type of numerical integrator used, the default is &quot;lsoda&quot;</p>
</td></tr>
<tr><td><code id="step_ODE_decoupled_+3A_human_ode">human_ode</code></td>
<td>
<p>ODE function used for human states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is equivalent to considering the ODEs describing the time
evolution of the mean trajectory (first moment) and setting all higher order
moments which appear on the right hand side to zero.
</p>
<p>The solvers used within can be found in the <code>deSolve</code> package, see
<code><a href="deSolve.html#topic+ode">ode</a></code>. For inhomogeneous systems, consider using the &quot;rk4&quot;
method to avoid excessive integration times.
</p>
<p>The stoichiometry matrix (<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code>.
</p>
<p>The list of hazards (<code>haz</code>) come from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_CLE">step_CLE</a></code>, <code><a href="#topic+step_PTS">step_PTS</a></code>, <code><a href="#topic+step_DM">step_DM</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='step_PTS'>Make Poisson Time-Step (PTS) Sampler for a SPN Model</h2><span id='topic+step_PTS'></span>

<h3>Description</h3>

<p>Make a function closure to implement a Poisson time-step (tau-leaping with fixed tau)
sampler for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_PTS(S, Sout, haz, dt = 0.01, maxhaz = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_PTS_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_PTS_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings</p>
</td></tr>
<tr><td><code id="step_PTS_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_PTS_+3A_dt">dt</code></td>
<td>
<p>time-step for tau-leap method</p>
</td></tr>
<tr><td><code id="step_PTS_+3A_maxhaz">maxhaz</code></td>
<td>
<p>maximum allowable hazard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This sampling algorithm is based on representing a SPN as a set of competing
Poisson processes; it thus uses an integer valued state space but approximates
the number of events over <code>dt</code>.
</p>
<p>The design of <code>step_PTS</code> is from: Wilkinson, D. J. (2011). Stochastic
modeling for systems biology. CRC press
</p>
<p>Elements of the <code>N</code> list come from two places: The stoichiometry matrix
(<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code> and the hazards (<code>h</code>) come
from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_CLE">step_CLE</a></code>, <code><a href="#topic+step_DM">step_DM</a></code>, <code><a href="#topic+step_ODE">step_ODE</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='step_PTS_decoupled'>Make Poisson Time-Step (PTS) Sampler for a SPN Model</h2><span id='topic+step_PTS_decoupled'></span>

<h3>Description</h3>

<p>Make a function closure to implement a Poisson time-step (tau-leaping with fixed tau)
sampler for a SPN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_PTS_decoupled(S, Sout, haz, dt = 0.01, maxhaz = 1e+06, human_ode = "SIS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_PTS_decoupled_+3A_s">S</code></td>
<td>
<p>a stoichiometry <code><a href="Matrix.html#topic+Matrix-class">Matrix-class</a></code> object</p>
</td></tr>
<tr><td><code id="step_PTS_decoupled_+3A_sout">Sout</code></td>
<td>
<p>an optional matrix to track of event firings</p>
</td></tr>
<tr><td><code id="step_PTS_decoupled_+3A_haz">haz</code></td>
<td>
<p>a list of hazard functions</p>
</td></tr>
<tr><td><code id="step_PTS_decoupled_+3A_dt">dt</code></td>
<td>
<p>time-step for tau-leap method</p>
</td></tr>
<tr><td><code id="step_PTS_decoupled_+3A_maxhaz">maxhaz</code></td>
<td>
<p>maximum allowable hazard</p>
</td></tr>
<tr><td><code id="step_PTS_decoupled_+3A_human_ode">human_ode</code></td>
<td>
<p>ode used for human states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This sampling algorithm is based on representing a SPN as a set of competing
Poisson processes; it thus uses an integer valued state space but approximates
the number of events over <code>dt</code>.
</p>
<p>The design of <code>step_PTS</code> is from: Wilkinson, D. J. (2011). Stochastic
modeling for systems biology. CRC press
</p>
<p>Elements of the <code>N</code> list come from two places: The stoichiometry matrix
(<code>S</code>) is generated in <code><a href="#topic+spn_S">spn_S</a></code> and the hazards (<code>h</code>) come
from <code><a href="#topic+spn_hazards">spn_hazards</a></code>.
</p>
<p>For other samplers, see: <code><a href="#topic+step_CLE">step_CLE</a></code>, <code><a href="#topic+step_DM">step_DM</a></code>, <code><a href="#topic+step_ODE">step_ODE</a></code>
</p>


<h3>Value</h3>

<p>function closure for use in <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code> or <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code>
</p>

<hr>
<h2 id='summarize_eggs_geno'>Summarize Eggs by Genotype</h2><span id='topic+summarize_eggs_geno'></span>

<h3>Description</h3>

<p>This function summarizes egg stage by genotype. It calls
<code><a href="#topic+base_aquatic_geno">base_aquatic_geno</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_eggs_geno(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_eggs_geno_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_eggs_geno_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_eggs_stage'>Summarize Eggs by Erlang-Stage</h2><span id='topic+summarize_eggs_stage'></span>

<h3>Description</h3>

<p>This function summarizes egg stage by Erlang-stages. It calls
<code><a href="#topic+base_aquatic_stage">base_aquatic_stage</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_eggs_stage(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_eggs_stage_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_eggs_stage_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>Erlang-stage</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_females'>Summarize Adult Females (One Node or Metapopulation Network, Lifecycle Model)</h2><span id='topic+summarize_females'></span>

<h3>Description</h3>

<p>For <code>MGDrivE2</code> simulations of mosquito lifecycle dynamics in a single node
or metapopulation network, this function sums over the male mate genotype to
get population trajectories of adult female mosquitoes by their genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_females(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_females_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_females_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code> or <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, this or any vignette which visualizes output:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_females_epi'>Summarize Adult Females (One Node or Metapopulation Network, SEI Mosquitoes)</h2><span id='topic+summarize_females_epi'></span>

<h3>Description</h3>

<p>For <code>MGDrivE2</code> simulations of mosquito epidemiological dynamics in a single
node or metapopulation network, this function sums over the male mate genotype
as well as EIP bins to get population trajectories of adult female mosquitoes
by their genotype and (S,E,I) status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_females_epi(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_females_epi_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_females_epi_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>inf</code>, <code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, this or any vignette which simulates epi dynamics:
<code>vignette("epi-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 4 to 6 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_humans_epiImperial'>Summarize Humans for Imperial Model</h2><span id='topic+summarize_humans_epiImperial'></span>

<h3>Description</h3>

<p>The Imperial model outputs six human states for each age compartment.
This function accepts the output matrix and the desired index of an age compartment
and returns the trajectory of all human states in that given age compartment (default 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_humans_epiImperial(out, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_humans_epiImperial_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_humans_epiImperial_+3A_index">index</code></td>
<td>
<p>the desired age compartment for which to pull trajectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_humans_epiSEIR'>Summarize Humans (One Node or Metapopulation Network, SEI Mosquitoes - SEIR Humans)</h2><span id='topic+summarize_humans_epiSEIR'></span>

<h3>Description</h3>

<p>For <code>MGDrivE2</code> simulations of mosquito epidemiological dynamics in a
node or network, this function summarizes human infection status, S, E, I, and R.
It uses <code><a href="#topic+base_summarize_humans">base_summarize_humans</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_humans_epiSEIR(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_humans_epiSEIR_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>inf</code>, <code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("seir-dynamics", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 4 to 6 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_humans_epiSIS'>Summarize Humans (One Node or Metapopulation Network, SEI Mosquitoes - SIS Humans)</h2><span id='topic+summarize_humans_epiSIS'></span>

<h3>Description</h3>

<p>For <code>MGDrivE2</code> simulations of mosquito epidemiological dynamics in a
node or network, this function summarizes human infection status, S and I. It
uses <code><a href="#topic+base_summarize_humans">base_summarize_humans</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_humans_epiSIS(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_humans_epiSIS_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>inf</code>, <code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("epi-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 4 to 6 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_larvae_geno'>Summarize Larvae by Genotype</h2><span id='topic+summarize_larvae_geno'></span>

<h3>Description</h3>

<p>This function summarizes larval stage by genotype. It calls
<code><a href="#topic+base_aquatic_geno">base_aquatic_geno</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_larvae_geno(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_larvae_geno_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_larvae_geno_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_larvae_stage'>Summarize Larval by Erlang-Stage</h2><span id='topic+summarize_larvae_stage'></span>

<h3>Description</h3>

<p>This function summarizes larval stage by Erlang-stages. It calls
<code><a href="#topic+base_aquatic_stage">base_aquatic_stage</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_larvae_stage(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_larvae_stage_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_larvae_stage_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>Erlang-stage</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_males'>Summarize Adult Males (One Node or Metapopulation Network)</h2><span id='topic+summarize_males'></span>

<h3>Description</h3>

<p>For <code>MGDrivE2</code> simulations of mosquito lifecycle dynamics or human infection
dynamics, in a node or metapopulation network, this function summarizes
population trajectories of adult male mosquitoes by their genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_males(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_males_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, this or any vignette which visualizes output:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_pupae_geno'>Summarize Pupal by Genotype</h2><span id='topic+summarize_pupae_geno'></span>

<h3>Description</h3>

<p>This function summarizes pupal stage by genotype. It calls
<code><a href="#topic+base_aquatic_geno">base_aquatic_geno</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_pupae_geno(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_pupae_geno_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_pupae_geno_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>genotype</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_pupae_stage'>Summarize Pupal by Erlang-Stage</h2><span id='topic+summarize_pupae_stage'></span>

<h3>Description</h3>

<p>This function summarizes pupal stage by Erlang-stages. It calls
<code><a href="#topic+base_aquatic_stage">base_aquatic_stage</a></code> to do all of the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_pupae_stage(out, spn_P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_pupae_stage_+3A_out">out</code></td>
<td>
<p>the output of <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code></p>
</td></tr>
<tr><td><code id="summarize_pupae_stage_+3A_spn_p">spn_P</code></td>
<td>
<p>the places of the SPN, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p>The return object depends on the data provided. If the simulation was only 1 node,
then no <code>node</code> designation is returned. If only one repetition was performed,
no <code>rep</code> designation is returned. Columns always returned include: <code>time</code>,
<code>Erlang-stage</code>, and <code>value</code>.
</p>
<p>For examples of using this function, see:
<code>vignette("lifecycle-node", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>a 3 to 5 column dataframe for plotting with ggplot2
</p>

<hr>
<h2 id='summarize_stats_CSV'>Summary Statistics for MGDrivE2</h2><span id='topic+summarize_stats_CSV'></span>

<h3>Description</h3>

<p>This function reads in all repetitions for each patch and calculates either
the mean, quantiles, or both. User chooses the quantiles, up to 4 decimal places,
and enters them as a vector. Quantiles are calculated empirically. (order does not matter)  <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_stats_CSV(
  read_dir,
  write_dir = read_dir,
  mean = TRUE,
  quantiles = NULL,
  spn_P,
  tmax,
  dt,
  rem_file = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_stats_CSV_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to find repetition folders in</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_write_dir">write_dir</code></td>
<td>
<p>Directory to write output</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_mean">mean</code></td>
<td>
<p>Boolean, calculate mean or not. Default is TRUE</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles to calculate. Default is NULL</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_spn_p">spn_P</code></td>
<td>
<p>Places object, see details</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_tmax">tmax</code></td>
<td>
<p>The final time to end simulation</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_dt">dt</code></td>
<td>
<p>The time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_rem_file">rem_file</code></td>
<td>
<p>Remove original output? Default is FALSE</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the read_dir, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> read_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p><code>t0</code>, <code>tt</code>, <code>dt</code> define the first sampling time, the last sampling
time, and each sampling time in-between.
</p>
<p>Output files are *.csv and contain the mean or quantile in the file name, e.g.
stage<em>Mean</em>(patchNum).csv and stage<em>Quantile</em>(quantNum)_(patchNum).csv.
</p>
<p>For more details about using this function to process CSV output see:
<code>vignette("data-analysis", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>Writes output to files in write_dir
</p>

<hr>
<h2 id='summarize_stats_CSV_decoupled'>Summary Statistics for MGDrivE2 - Decoupled samples</h2><span id='topic+summarize_stats_CSV_decoupled'></span>

<h3>Description</h3>

<p>This function reads in all repetitions for each patch and calculates either
the mean, quantiles, or both. User chooses the quantiles, up to 4 decimal places,
and enters them as a vector. Quantiles are calculated empirically. (order does not matter)  <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_stats_CSV_decoupled(
  read_dir,
  write_dir = read_dir,
  mean = TRUE,
  quantiles = NULL,
  spn_P,
  tmax,
  dt,
  human_states,
  rem_file = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to find repetition folders in</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_write_dir">write_dir</code></td>
<td>
<p>Directory to write output</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_mean">mean</code></td>
<td>
<p>Boolean, calculate mean or not. Default is TRUE</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles to calculate. Default is NULL</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_spn_p">spn_P</code></td>
<td>
<p>Places object, see details</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_tmax">tmax</code></td>
<td>
<p>The final time to end simulation</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_dt">dt</code></td>
<td>
<p>The time-step at which to return output (<strong>not</strong> the time-step of the sampling algorithm)</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_human_states">human_states</code></td>
<td>
<p>human state distribution</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_rem_file">rem_file</code></td>
<td>
<p>Remove original output? Default is FALSE</p>
</td></tr>
<tr><td><code id="summarize_stats_CSV_decoupled_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the read_dir, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> read_dir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> M_0001.csv
</p>
</li>
<li><p> M_0002.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> FS_0001.csv
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>The places (<code>spn_P</code>) object is generated from one of the following:
<code><a href="#topic+spn_P_lifecycle_node">spn_P_lifecycle_node</a></code>, <code><a href="#topic+spn_P_lifecycle_network">spn_P_lifecycle_network</a></code>,
<code><a href="#topic+spn_P_epiSIS_node">spn_P_epiSIS_node</a></code>, <code><a href="#topic+spn_P_epiSIS_network">spn_P_epiSIS_network</a></code>,
<code><a href="#topic+spn_P_epiSEIR_node">spn_P_epiSEIR_node</a></code>, or <code><a href="#topic+spn_P_epiSEIR_network">spn_P_epiSEIR_network</a></code>.
</p>
<p><code>t0</code>, <code>tt</code>, <code>dt</code> define the first sampling time, the last sampling
time, and each sampling time in-between.
</p>
<p>Output files are *.csv and contain the mean or quantile in the file name, e.g.
stage<em>Mean</em>(patchNum).csv and stage<em>Quantile</em>(quantNum)_(patchNum).csv.
</p>
<p>For more details about using this function to process CSV output see:
<code>vignette("data-analysis", package = "MGDrivE2")</code>
</p>


<h3>Value</h3>

<p>Writes output to files in write_dir
</p>

<hr>
<h2 id='track_hinf'>Make tracking matrix for human infection events</h2><span id='topic+track_hinf'></span>

<h3>Description</h3>

<p>Create a matrix object for tracking incidence in human population
to be passed to either <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code> or <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_hinf(spn_T, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_hinf_+3A_spn_t">spn_T</code></td>
<td>
<p>set of transitions</p>
</td></tr>
<tr><td><code id="track_hinf_+3A_s">S</code></td>
<td>
<p>stoichiometry matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned matrix can be passed to the <code>Sout</code> argument of <code><a href="#topic+sim_trajectory_CSV">sim_trajectory_CSV</a></code> or <code><a href="#topic+sim_trajectory_R">sim_trajectory_R</a></code>.
</p>


<h3>Value</h3>

<p>a <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
