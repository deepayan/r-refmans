<!DOCTYPE html><html><head><title>Help for package SemiCompRisks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SemiCompRisks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesID_AFT'>
<p>The function to implement Bayesian parametric and semi-parametric analyses for semi-competing risks data in the context of accelerated failure time (AFT) models.</p></a></li>
<li><a href='#BayesID_HReg'>
<p>The function to implement Bayesian parametric and semi-parametric analyses for semi-competing risks data in the context of hazard regression (HReg) models.</p></a></li>
<li><a href='#BayesSurv_AFT'>
<p>The function to implement Bayesian parametric and semi-parametric analyses for univariate survival data in the context of accelerated failure time (AFT) models.</p></a></li>
<li><a href='#BayesSurv_HReg'>
<p>The function to implement Bayesian parametric and semi-parametric regression analyses for univariate time-to-event data in the context of hazard regression (HReg) models.</p></a></li>
<li><a href='#BMT'>
<p>Data on 137 Bone Marrow Transplant Patients</p></a></li>
<li><a href='#CIBMTR'>
<p>Center for International Blood and Bone Marrow Transplant Research (CIBMTR) data</p></a></li>
<li><a href='#CIBMTR_Params'>
<p>Estimates for model parameters from semi-competing risks analysis of the CIBMTR data using Weibull illness-death model.</p></a></li>
<li><a href='#FreqID_HReg'>
<p>The function to fit parametric Weibull models for the frequentist anlaysis of semi-competing risks data.</p></a></li>
<li><a href='#FreqSurv_HReg'>
<p>The function to fit parametric Weibull models for the frequentist analysis of univariate survival data.</p></a></li>
<li><a href='#initiate.startValues_AFT'>
<p>The function that initiates starting values for a single chain.</p></a></li>
<li><a href='#initiate.startValues_HReg'>
<p>The function that initiates starting values for a single chain.</p></a></li>
<li><a href='#methods'>
<p>Methods for objects of classes, <code>Bayes_HReg</code>/<code>Bayes_AFT</code>/<code>Freq_HReg</code>.</p></a></li>
<li><a href='#old.functions'>
<p>Old functions</p></a></li>
<li><a href='#PPD'>
<p>Function to predict the joint probability involving two event times in Bayesian illness-death models</p></a></li>
<li><a href='#scrData'>
<p>A simulated clustered semi-competing risks data set</p></a></li>
<li><a href='#SemiCompRisks-package'>
<p>Algorithms for fitting parametric and semi-parametric models to semi-competing risks data / univariate survival data.</p></a></li>
<li><a href='#simID'>
<p>The function that simulates independent/cluster-correlated semi-competing risks data under semi-Markov Weibull/Weibull-MVN models.</p></a></li>
<li><a href='#simSurv'>
<p>The function that simulates independent/cluster-correlated right-censored survival data under Weibull/Weibull-Normal model.</p></a></li>
<li><a href='#survData'>
<p>A simulated clustered univariate survival data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Models for Parametric and Semi-Parametric Analyses
of Semi-Competing Risks Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-2-2</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyu Ha Lee, Catherine Lee, Danilo Alvares, and Sebastien Haneuse</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyu Ha Lee &lt;klee15239@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Hierarchical multistate models are considered to perform the analysis of independent/clustered semi-competing risks data. The package allows to choose the specification for model components from a range of options giving users substantial flexibility, including: accelerated failure time or proportional hazards regression models; parametric or non-parametric specifications for baseline survival functions and cluster-specific random effects distribution; a Markov or semi-Markov specification for terminal event following non-terminal event. While estimation is mainly performed within the Bayesian paradigm, the package also provides the maximum likelihood estimation approach for several parametric models. The package also includes functions for univariate survival analysis as complementary analysis tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, survival, Formula, R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-03 13:19:41 UTC; kyuhalee</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-03 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesID_AFT'>
The function to implement Bayesian parametric and semi-parametric analyses for semi-competing risks data in the context of accelerated failure time (AFT) models.
</h2><span id='topic+BayesID_AFT'></span>

<h3>Description</h3>

<p>Independent semi-competing risks data can be analyzed using AFT models that have a hierarchical structure. The proposed models can accomodate left-truncated and/or interval-censored data. An efficient computational algorithm that gives users the flexibility to adopt either a fully parametric (log-Normal) or a semi-parametric (Dirichlet process mixture) model specification is developed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesID_AFT(Formula, data, model = "LN", hyperParams, startValues,
mcmcParams, na.action = "na.fail", subset=NULL, path=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesID_AFT_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcomes on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, left truncation time | interval- (or right-) censored time for non-terminal event | interval-(or right-) censored time for terminal event <code class="reqn">\sim</code> covariates for <code class="reqn">h_1</code> | covariates for <code class="reqn">h_2</code> | covariates for <code class="reqn">h_3</code>: i.e., <code class="reqn">L</code> | <code class="reqn">y_{1L}</code>+<code class="reqn">y_{1U}</code> | <code class="reqn">y_{2L}</code>+<code class="reqn">y_{2U}</code> ~ <code class="reqn">x_1</code> | <code class="reqn">x_2</code> | <code class="reqn">x_3</code>. 
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_model">model</code></td>
<td>

<p>The specification of baseline survival distribution: &quot;LN&quot; or &quot;DPM&quot;.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_hyperparams">hyperParams</code></td>
<td>

<p>a list containing lists or vectors for hyperparameter values in hierarchical models. Components include,
<code>theta</code> (a numeric vector for hyperparameter in the prior of subject-specific frailty variance component),
<code>LN</code> (a list containing numeric vectors for log-Normal hyperparameters: <code>LN.ab1</code>, <code>LN.ab2</code>, <code>LN.ab3</code>),
<code>DPM</code> (a list containing numeric vectors for DPM hyperparameters: <code>DPM.mu1</code>, <code>DPM.mu2</code>, <code>DPM.mu3</code>, <code>DPM.sigSq1</code>, <code>DPM.sigSq2</code>, <code>DPM.sigSq3</code>, <code>DPM.ab1</code>, <code>DPM.ab2</code>, <code>DPM.ab3</code>, <code>Tau.ab1</code>, <code>Tau.ab2</code>, <code>Tau.ab3</code>).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_startvalues">startValues</code></td>
<td>

<p>a list containing vectors of starting values for model parameters. It can be specified as the object returned by the function <code><a href="#topic+initiate.startValues_AFT">initiate.startValues_AFT</a></code>.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_mcmcparams">mcmcParams</code></td>
<td>

<p>a list containing variables required for MCMC sampling. Components include,
<code>run</code> (a list containing numeric values for setting for the overall run:
<code>numReps</code>, total number of scans; <code>thin</code>, extent of thinning; <code>burninPerc</code>, the proportion of burn-in).
<code>storage</code> (a list containing numeric values for storing posterior samples for subject- and cluster-specific random effects:
<code>nGam_save</code>, the number of <code class="reqn">\gamma</code> to be stored; <code>nY1_save</code>, the number of <code class="reqn">y1</code> to be stored; <code>nY2_save</code>, the number of <code class="reqn">y2</code> to be stored; <code>nY1.NA_save</code>, the number of <code class="reqn">y1.NA</code> to be stored).
<code>tuning</code> (a list containing numeric values relevant to tuning parameters for specific updates in Metropolis-Hastings (MH) algorithm:
<code>betag.prop.var</code>, the variance of proposal density for <code class="reqn">\beta_g</code>; <code>mug.prop.var</code>, the variance of proposal density for <code class="reqn">\mu_{g}</code>; <code>zetag.prop.var</code>, the variance of proposal density for <code class="reqn">1/\sigma_g^2</code>;
<code>gamma.prop.var</code>, the variance of proposal density for <code class="reqn">\gamma</code>).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_AFT_+3A_path">path</code></td>
<td>

<p>the name of directory where the results are saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We view the semi-competing risks data as arising from an underlying illness-death model system in which individuals may undergo one or more of three transitions: 1) from some initial condition to non-terminal event, 2) from some initial condition to terminal event, 3) from non-terminal event to terminal event. Let <code class="reqn">T_{i1}</code>, <code class="reqn">T_{i2}</code> denote time to non-terminal and terminal event from subject <code class="reqn">i=1,...,n</code>.  We propose to directly model the times of the events via the following AFT model specification:
</p>
<p style="text-align: center;"><code class="reqn">\log(T_{i1}) = x_{i1}^\top\beta_1 + \gamma_i + \epsilon_{i1},  T_{i1} &gt; 0,</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(T_{i2}) = x_{i2}^\top\beta_2 + \gamma_i + \epsilon_{i2},  T_{i2} &gt; 0,</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(T_{i2} - T_{i1}) = x_{i3}^\top\beta_3 + \gamma_i + \epsilon_{i3},  T_{i2} &gt;  T_{i1},</code>
</p>

<p>where <code class="reqn">x_{ig}</code> is a vector of transition-specific covariates, <code class="reqn">\beta_g</code> is a corresponding vector of transition-specific regression parameters and <code class="reqn">\epsilon_{ig}</code> is a transition-specific random variable whose distribution determines that of the corresponding transition time, <code class="reqn">g \in \{1,2,3\}</code>. <code class="reqn">\gamma_i</code> is a study participant-specific random effect that induces positive dependence between the two event times, thereby performing a role analogous to that performed by frailties in models for the hazard function.
Let <code class="reqn">L_{i}</code> denote the time at study entry (i.e. the left-truncation time). Furthermore, suppose that study participant <code class="reqn">i</code> was observed at follow-up times <code class="reqn">\{c_{i1},\ldots, c_{im_i}\}</code> and let <code class="reqn">c_i^*</code> denote the time to the end of study or to administrative right-censoring. Considering interval-censoring for both events, the times to non-terminal and terminal event for the <code class="reqn">i^{th}</code> study participant satisfy <code class="reqn">c_{ij}\leq T_{i1}&lt; c_{ij+1}</code> for some <code class="reqn">j</code> and <code class="reqn">c_{ik}\leq T_{i2}&lt; c_{ik+1}</code> for some <code class="reqn">k</code>, respectively. Then the observed outcomes for the <code class="reqn">i^{th}</code> study participant can be succinctly denoted by <code class="reqn">\{c_{ij}, c_{ij+1}, c_{ik}, c_{ik+1}, L_{i}\}</code>.
</p>
<p>For the Bayesian semi-parametric analysis, we proceed by adopting independent DPM of normal distributions for each <code class="reqn">\epsilon_{ig}</code>. More precisely, <code class="reqn">\epsilon_{ig}</code> is taken to be an independent draw from a mixture of <code class="reqn">M_g</code> normal distributions with means and variances (<code class="reqn">\mu_{gr}</code>, <code class="reqn">\sigma_{gr}^2</code>), for <code class="reqn">r \in \{1,\ldots,M_g\}</code>. Since the class-specific <code class="reqn">(\mu_{gr}, \sigma_{gr}^2)</code> are not known, they are taken to be draws from some common distribution, <code class="reqn">G_{g0}</code>, often referred to as the centering distribution. Furthermore, since the &lsquo;true&rsquo; class membership for any given study participant is not known, we let <code class="reqn">p_{gr}</code> denote the probability of belonging to the <code class="reqn">r^{th}</code> class for transition <code class="reqn">g</code> and <code class="reqn">p_g</code> = <code class="reqn">(p_{g1}, \ldots, p_{gM_g})</code> the collection of such probabilities. Note, <code class="reqn">p_g</code> is defined at the level of the population (i.e. is not study participant-specific) and its components add up to 1.0. In the absence of prior knowledge regarding the distribution of class memberships for the <code class="reqn">n</code> individuals across the <code class="reqn">M_g</code> classes, <code class="reqn">p_g</code> is assumed to follow a conjugate symmetric Dirichlet<code class="reqn">(\tau_g/M_g,\ldots,\tau_g/M_g)</code> distribution, where <code class="reqn">\tau_g</code> is referred to as the precision parameter. The finite mixture distribution can then be succinctly represented as:
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{ig} | r_{i} \sim Normal(\mu_{r_{i}}, \sigma_{r_{i}}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">(\mu_{gr}, \sigma_{gr}^2) \sim G_{g0}, ~~for~ r=1,\ldots,M_g,</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{i}| p_g \sim Discrete(r_{i} | p_{g1},\ldots,p_{gM_g}),</code>
</p>

<p style="text-align: center;"><code class="reqn">p_g \sim Dirichlet(\tau_g/M_g, \ldots, \tau_g/M_g).</code>
</p>

<p>Letting <code class="reqn">M_g</code> approach infinity, this specification is referred to as a DPM of normal distributions. In our proposed framework, we specify a Gamma(<code class="reqn">a_{\tau_g}</code>, <code class="reqn">b_{\tau_g}</code>) hyperprior for <code class="reqn">\tau_g</code>. For regression parameters, we adopt non-informative flat priors on the real line. For <code class="reqn">\gamma</code>=<code class="reqn">\{\gamma_1, \ldots, \gamma_n\}</code>, we assume that each <code class="reqn">\gamma_i</code> is an independent random draw from a Normal(0, <code class="reqn">\theta</code>) distribution. In the absence of prior knowledge on the variance component <code class="reqn">\theta</code>, we adopt a conjugate inverse-Gamma hyperprior, IG(<code class="reqn">a_\theta</code>, <code class="reqn">b_\theta</code>). Finally, We take the <code class="reqn">G_{g0}</code> as a normal distribution centered at <code class="reqn">\mu_{g0}</code> with a variance <code class="reqn">\sigma_{g0}^2</code> for <code class="reqn">\mu_{gr}</code> and an IG(<code class="reqn">a_{\sigma_g}</code>, <code class="reqn">b_{\sigma_g}</code>) for <code class="reqn">\sigma_{gr}^2</code>.
</p>
<p>For the Bayesian parametric analysis, we build on the log-Normal formulation and take the <code class="reqn">\epsilon_{ig}</code> to follow independent Normal(<code class="reqn">\mu_g</code>, <code class="reqn">\sigma_g^2</code>) distributions, <code class="reqn">g</code>=1,2,3. For location parameters <code class="reqn">\{\mu_1, \mu_2, \mu_3\}</code>, we adopt non-informative flat priors on the real line. For <code class="reqn">\{\sigma_1^2, \sigma_2^2, \sigma_3^2\}</code>, we adopt independent inverse Gamma distributions, denoted IG(<code class="reqn">a_{\sigma g}</code>, <code class="reqn">b_{\sigma g}</code>). For <code class="reqn">\beta_g</code>, <code class="reqn">\gamma</code>, and <code class="reqn">\theta</code>, we adopt the same priors as those adopted for the DPM model.
</p>


<h3>Value</h3>

<p><code>BayesID_AFT</code> returns an object of class <code>Bayes_AFT</code>. <br />
</p>


<h3>Note</h3>

<p>The posterior samples of <code class="reqn">\gamma</code> are saved separately in <code>working directory/path</code>.
For a dataset with large <code class="reqn">n</code>, <code>nGam_save</code> should be carefully specified considering the system memory and the storage capacity.
</p>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Rondeau, V., and Haneuse, S. (2017),
Accelerated failure time models for semicompeting risks data in the presence of complex censoring, <em>Biometrics</em>, 73, 4, 1401-1412. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initiate.startValues_AFT">initiate.startValues_AFT</a></code>, <code><a href="#topic+print.Bayes_AFT">print.Bayes_AFT</a></code>, <code><a href="#topic+summary.Bayes_AFT">summary.Bayes_AFT</a></code>, <code><a href="#topic+predict.Bayes_AFT">predict.Bayes_AFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# loading a data set
data(scrData)
scrData$y1L &lt;- scrData$y1U &lt;- scrData[,1]
scrData$y1U[which(scrData[,2] == 0)] &lt;- Inf
scrData$y2L &lt;- scrData$y2U &lt;- scrData[,3]
scrData$y2U[which(scrData[,4] == 0)] &lt;- Inf
scrData$LT &lt;- rep(0, dim(scrData)[1])

form &lt;- Formula(LT | y1L + y1U | y2L + y2U  ~ x1 + x2 + x3 | x1 + x2 | x1 + x2)

#####################
## Hyperparameters ##
#####################

## Subject-specific random effects variance component
##
theta.ab &lt;- c(0.5, 0.05)

## log-Normal model
##
LN.ab1 &lt;- c(0.3, 0.3)
LN.ab2 &lt;- c(0.3, 0.3)
LN.ab3 &lt;- c(0.3, 0.3)

## DPM model
##
DPM.mu1 &lt;- log(12)
DPM.mu2 &lt;- log(12)
DPM.mu3 &lt;- log(12)

DPM.sigSq1 &lt;- 100
DPM.sigSq2 &lt;- 100
DPM.sigSq3 &lt;- 100

DPM.ab1 &lt;-  c(2, 1)
DPM.ab2 &lt;-  c(2, 1)
DPM.ab3 &lt;-  c(2, 1)

Tau.ab1 &lt;- c(1.5, 0.0125)
Tau.ab2 &lt;- c(1.5, 0.0125)
Tau.ab3 &lt;- c(1.5, 0.0125)

##
hyperParams &lt;- list(theta=theta.ab,
LN=list(LN.ab1=LN.ab1, LN.ab2=LN.ab2, LN.ab3=LN.ab3),
DPM=list(DPM.mu1=DPM.mu1, DPM.mu2=DPM.mu2, DPM.mu3=DPM.mu3, DPM.sigSq1=DPM.sigSq1,
DPM.sigSq2=DPM.sigSq2, DPM.sigSq3=DPM.sigSq3, DPM.ab1=DPM.ab1, DPM.ab2=DPM.ab2,
DPM.ab3=DPM.ab3, Tau.ab1=Tau.ab1, Tau.ab2=Tau.ab2, Tau.ab3=Tau.ab3))

###################
## MCMC SETTINGS ##
###################

## Setting for the overall run
##
numReps    &lt;- 300
thin       &lt;- 3
burninPerc &lt;- 0.5

## Setting for storage
##
nGam_save &lt;- 10
nY1_save &lt;- 10
nY2_save &lt;- 10
nY1.NA_save &lt;- 10

## Tuning parameters for specific updates
##
##  - those common to all models
betag.prop.var	&lt;- c(0.01,0.01,0.01)
mug.prop.var	&lt;- c(0.1,0.1,0.1)
zetag.prop.var	&lt;- c(0.1,0.1,0.1)
gamma.prop.var	&lt;- 0.01

##
mcmcParams	&lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
storage=list(nGam_save=nGam_save, nY1_save=nY1_save, nY2_save=nY2_save, nY1.NA_save=nY1.NA_save),
tuning=list(betag.prop.var=betag.prop.var, mug.prop.var=mug.prop.var,
zetag.prop.var=zetag.prop.var, gamma.prop.var=gamma.prop.var))

#################################################################
## Analysis of Independent Semi-competing risks data ############
#################################################################

###############
## logNormal ##
###############

##
myModel &lt;- "LN"
myPath  &lt;- "Output/01-Results-LN/"

startValues      &lt;- initiate.startValues_AFT(form, scrData, model=myModel, nChain=2)

##
fit_LN &lt;- BayesID_AFT(form, scrData, model=myModel, hyperParams,
startValues, mcmcParams, path=myPath)

fit_LN
summ.fit_LN &lt;- summary(fit_LN); names(summ.fit_LN)
summ.fit_LN
pred_LN &lt;- predict(fit_LN, time = seq(0, 35, 1), tseq=seq(from=0, to=30, by=5))
plot(pred_LN, plot.est="Haz")
plot(pred_LN, plot.est="Surv")

#########
## DPM ##
#########

##
myModel &lt;- "DPM"
myPath  &lt;- "Output/02-Results-DPM/"

startValues      &lt;- initiate.startValues_AFT(form, scrData, model=myModel, nChain=2)

##
fit_DPM &lt;- BayesID_AFT(form, scrData, model=myModel, hyperParams,
startValues, mcmcParams, path=myPath)

fit_DPM
summ.fit_DPM &lt;- summary(fit_DPM); names(summ.fit_DPM)
summ.fit_DPM
pred_DPM &lt;- predict(fit_DPM, time = seq(0, 35, 1), tseq=seq(from=0, to=30, by=5))
plot(pred_DPM, plot.est="Haz")
plot(pred_DPM, plot.est="Surv")

## End(Not run)

</code></pre>

<hr>
<h2 id='BayesID_HReg'>
The function to implement Bayesian parametric and semi-parametric analyses for semi-competing risks data in the context of hazard regression (HReg) models.
</h2><span id='topic+BayesID_HReg'></span>

<h3>Description</h3>

<p>Independent/cluster-correlated semi-competing risks data can be analyzed using HReg models that have a hierarchical structure. The priors for baseline hazard functions can be specified by either parametric (Weibull) model or non-parametric mixture of piecewise exponential models (PEM). The option to choose between parametric multivariate normal (MVN) and non-parametric Dirichlet process mixture of multivariate normals (DPM) is available for the prior of cluster-specific random effects distribution. The conditional hazard function for time to the terminal event given time to non-terminal event can be modeled based on either Markov (it does not depend on the timing of the non-terminal event) or semi-Markov assumption (it does depend on the timing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesID_HReg(Formula, data, id=NULL, model=c("semi-Markov", "Weibull"),
hyperParams, startValues, mcmcParams, na.action = "na.fail", subset=NULL, path=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesID_HReg_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcome on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, time to non-terminal event + corresponding censoring indicator | time to terminal event + corresponding censoring indicator <code class="reqn">\sim</code> covariates for <code class="reqn">h_1</code> | covariates for <code class="reqn">h_2</code> | covariates for <code class="reqn">h_3</code>: i.e., <code class="reqn">y_1</code>+<code class="reqn">\delta_1</code> | <code class="reqn">y_2</code>+<code class="reqn">\delta_2</code> ~ <code class="reqn">x_1</code> | <code class="reqn">x_2</code> | <code class="reqn">x_3</code>. 
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_id">id</code></td>
<td>

<p>a vector of cluster information for <code>n</code> subjects. The cluster membership must be consecutive positive integers, <code class="reqn">1:J</code>.  
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_model">model</code></td>
<td>

<p>a character vector that specifies the type of components in a model. 
The first element is for the assumption on <code class="reqn">h_3</code>: &quot;semi-Markov&quot; or &quot;Markov&quot;. 
The second element is for the specification of baseline hazard functions: &quot;Weibull&quot; or &quot;PEM&quot;. 
The third element needs to be set only for clustered semi-competing risks data and is for the specification of cluster-specific random effects distribution: &quot;MVN&quot; or &quot;DPM&quot;.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_hyperparams">hyperParams</code></td>
<td>

<p>a list containing lists or vectors for hyperparameter values in hierarchical models. Components include, 
<code>theta</code> (a numeric vector for hyperparameter in the prior of subject-specific frailty variance component), 
<code>WB</code> (a list containing numeric vectors for Weibull hyperparameters: <code>WB.ab1</code>, <code>WB.ab2</code>, <code>WB.ab3</code>, <code>WB.cd1</code>, <code>WB.cd2</code>, <code>WB.cd3</code>), 
<code>PEM</code> (a list containing numeric vectors for PEM hyperparameters: <code>PEM.ab1</code>, <code>PEM.ab2</code>, <code>PEM.ab3</code>, <code>PEM.alpha1</code>, <code>PEM.alpha2</code>, <code>PEM.alpha3</code>).
Models for clustered data require additional components,
<code>MVN</code> (a list containing numeric vectors for MVN hyperparameters: <code>Psi_v</code>, <code>rho_v</code>), 
<code>DPM</code> (a list containing numeric vectors for DPM hyperparameters: <code>Psi0</code>, <code>rho0</code>, <code>aTau</code>, <code>bTau</code>).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_startvalues">startValues</code></td>
<td>

<p>a list containing vectors of starting values for model parameters. It can be specified as the object returned by the function <code><a href="#topic+initiate.startValues_HReg">initiate.startValues_HReg</a></code>.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_mcmcparams">mcmcParams</code></td>
<td>

<p>a list containing variables required for MCMC sampling. Components include,
<code>run</code> (a list containing numeric values for setting for the overall run: 
<code>numReps</code>, total number of scans; <code>thin</code>, extent of thinning; <code>burninPerc</code>, the proportion of burn-in).
<code>storage</code> (a list containing numeric values for storing posterior samples for subject- and cluster-specific random effects: 
<code>nGam_save</code>, the number of <code class="reqn">\gamma</code> to be stored; 
<code>storeV</code>, a vector of three logical values to determine whether all the posterior samples of <code class="reqn">V_1</code>, <code class="reqn">V_2</code>, <code class="reqn">V_3</code> are to be stored).
<code>tuning</code> (a list containing numeric values relevant to tuning parameters for specific updates in Metropolis-Hastings-Green (MHG) algorithm: 
<code>mhProp_theta_var</code>, the variance of proposal density for <code class="reqn">\theta</code>; <code>mhProp_Vg_var</code>, the variance of proposal density for <code class="reqn">V_g</code> in DPM models; 
<code>mhProp_alphag_var</code>, the variance of proposal density for <code class="reqn">\alpha_g</code> in Weibull models; 
<code>Cg</code>, a vector of three proportions that determine the sum of probabilities of choosing the birth and the death moves in PEM models. 
The sum of the three elements should not exceed 0.6;
<code>delPertg</code>, the perturbation parameters in the birth update in PEM models. The values must be between 0 and 0.5;
If <code>rj.scheme</code>=1, the birth update will draw the proposal time split from <code class="reqn">1:s_{max}</code>.
If <code>rj.scheme</code>=2, the birth update will draw the proposal time split from uniquely ordered failure times in the data. Only required for PEM models;
<code>Kg_max</code>, the maximum number of splits allowed at each iteration in MHG algorithm for PEM models;
<code>time_lambda1</code>, <code>time_lambda2</code>, <code>time_lambda3</code> - time points at which the log-hazard functions are calculated for <code><a href="#topic+predict.Bayes_HReg">predict.Bayes_HReg</a></code>, Only required for PEM models).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesID_HReg_+3A_path">path</code></td>
<td>

<p>the name of directory where the results are saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We view the semi-competing risks data as arising from an underlying illness-death model system in which individuals may undergo one or more of three transitions: 1) from some initial condition to non-terminal event, 2) from some initial condition to terminal event, 3) from non-terminal event to terminal event. Let <code class="reqn">t_{ji1}</code>, <code class="reqn">t_{ji2}</code> denote time to non-terminal and terminal event from subject <code class="reqn">i=1,...,n_j</code> in cluster <code class="reqn">j=1,...,J</code>. The system of transitions is modeled via the specification of three hazard functions:
</p>
<p style="text-align: center;"><code class="reqn">h_1(t_{ji1} | \gamma_{ji}, x_{ji1}, V_{j1}) = \gamma_{ji} h_{01}(t_{ji1})\exp(x_{ji1}^{\top}\beta_1 +V_{j1}), t_{ji1}&gt;0,</code>
</p>

<p style="text-align: center;"><code class="reqn">h_2(t_{ji2} | \gamma_{ji}, x_{ji2}, V_{j2}) = \gamma_{ji} h_{02}(t_{ji2})\exp(x_{ji2}^{\top}\beta_2 +V_{j2}), t_{ji2}&gt;0,</code>
</p>

<p style="text-align: center;"><code class="reqn">h_3(t_{ji2} | t_{ji1}, \gamma_{ji}, x_{ji3}, V_{j3}) = \gamma_{ji} h_{03}(t_{ji2})\exp(x_{ji3}^{\top}\beta_3 +V_{j3}), 0&lt;t_{ji1}&lt;t_{ji2},</code>
</p>

<p>where <code class="reqn">\gamma_{ji}</code> is a subject-specific frailty and <code class="reqn">V_j</code>=(<code class="reqn">V_{j1}</code>, <code class="reqn">V_{j2}</code>, <code class="reqn">V_{j3}</code>) is a vector of cluster-specific random effects (each specific to one of the three possible transitions), taken to be independent of <code class="reqn">x_{ji1}</code>, <code class="reqn">x_{ji2}</code>, and <code class="reqn">x_{ji3}</code>.
For <code class="reqn">g \in \{1,2,3\}</code>, <code class="reqn">h_{0g}</code> is an unspecified baseline hazard function and <code class="reqn">\beta_g</code> is a vector of <code class="reqn">p_g</code> log-hazard ratio regression parameters.
The <code class="reqn">h_{03}</code> is assumed to be Markov with respect to <code class="reqn">t_1</code>. We refer to the model specified by three conditional hazard functions as the Markov model.
An alternative specification is to model the risk of terminal event following non-terminal event as a function of the sojourn time. Specifically, retaining <code class="reqn">h_1</code> and <code class="reqn">h_2</code> as above,
we consider modeling <code class="reqn">h_3</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">h_3(t_{ji2} | t_{ji1}, \gamma_{ji}, x_{ji3}, V_{j3}) = \gamma_{ji} h_{03}(t_{ji2}-t_{ji1})\exp(x_{ji3}^{\top}\beta_3 +V_{j3}), 0&lt;t_{ji1}&lt;t_{ji2}.</code>
</p>

<p>We refer to this alternative model as the semi-Markov model. <br />
For parametric MVN prior specification for a vector of cluster-specific random effects, we assume <code class="reqn">V_j</code> arise as i.i.d. draws from a mean 0 MVN distribution with variance-covariance matrix <code class="reqn">\Sigma_V</code>. The diagonal elements of the <code class="reqn">3\times 3</code> matrix <code class="reqn">\Sigma_V</code> characterize variation across clusters in risk for non-terminal, terminal and terminal following non-terminal event, respectively, which is not explained by covariates included in the linear predictors. Specifically, the priors can be written as follows:
</p>
<p style="text-align: center;"><code class="reqn">V_j \sim MVN(0, \Sigma_V),</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_V \sim inverse-Wishart(\Psi_v, \rho_v).</code>
</p>

<p>For DPM prior specification for <code class="reqn">V_j</code>, we consider non-parametric Dirichlet process mixture of MVN distributions: the <code class="reqn">V_j</code>'s are draws from a finite mixture of M multivariate Normal distributions, each with their own mean vector and variance-covariance matrix, (<code class="reqn">\mu_m</code>, <code class="reqn">\Sigma_m</code>) for <code class="reqn">m=1,...,M</code>. Let <code class="reqn">m_j\in\{1,...,M\}</code> denote the specific component to which the <code class="reqn">j</code>th cluster belongs. Since the class-specific (<code class="reqn">\mu_m</code>, <code class="reqn">\Sigma_m</code>) are unknown they are taken to be draws from some distribution, <code class="reqn">G_0</code>, often referred to as the centering distribution. Furthermore, since the true class memberships are not known, we denote the probability that the <code class="reqn">j</code>th cluster belongs to any given class by the vector <code class="reqn">p=(p_1,..., p_M)</code> whose components add up to 1.0. In the absence of prior knowledge regarding the distribution of class memberships for the <code class="reqn">J</code> clusters across the <code class="reqn">M</code> classes, a natural prior for <code class="reqn">p</code> is the conjugate symmetric <code class="reqn">Dirichlet(\tau/M,...,\tau/M)</code> distribution; the hyperparameter, <code class="reqn">\tau</code>, is often referred to as a the precision parameter. The prior can be represented as follows (<code class="reqn">M</code> goes to infinity):
</p>
<p style="text-align: center;"><code class="reqn">V_j | m_j \sim MVN(\mu_{m_j}, \Sigma_{m_j}),</code>
</p>

<p style="text-align: center;"><code class="reqn">(\mu_m, \Sigma_m) \sim G_{0},~~ for ~m=1,...,M,</code>
</p>

<p style="text-align: center;"><code class="reqn">m_j | p \sim Discrete(m_j| p_1,...,p_M),</code>
</p>

<p style="text-align: center;"><code class="reqn">p \sim Dirichlet(\tau/M,...,\tau/M),</code>
</p>

<p>where <code class="reqn">G_0</code> is taken to be a multivariate Normal/inverse-Wishart (NIW) distribution for which the probability density function is the following product:
</p>
<p style="text-align: center;"><code class="reqn">f_{NIW}(\mu, \Sigma | \Psi_0, \rho_0) = f_{MVN}(\mu | 0, \Sigma) \times f_{inv-Wishart}(\Sigma | \Psi_0, \rho_0).</code>
</p>

<p>We consider <code class="reqn">Gamma(a_{\tau}, b_{\tau})</code> as the prior for concentration parameter <code class="reqn">\tau</code>.
</p>
<p>For non-parametric PEM prior specification for baseline hazard functions, let <code class="reqn">s_{g,\max}</code> denote the largest observed event time for each transition <code class="reqn">g \in \{1,2,3\}</code>.
Then, consider the finite partition of the relevant time axis into <code class="reqn">K_{g} + 1</code> disjoint intervals: <code class="reqn">0&lt;s_{g,1}&lt;s_{g,2}&lt;...&lt;s_{g, K_g+1} = s_{g, \max}</code>. For notational convenience, let <code class="reqn">I_{g,k}=(s_{g, k-1}, s_{g, k}]</code> denote the <code class="reqn">k^{th}</code> partition. For given a partition, <code class="reqn">s_g = (s_{g,1}, \dots, s_{g, K_g + 1})</code>, we assume the log-baseline hazard functions is piecewise constant:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{0g}(t)=\log h_{0g}(t) = \sum_{k=1}^{K_g + 1} \lambda_{g,k} I(t\in I_{g,k}),</code>
</p>

<p>where <code class="reqn">I(\cdot)</code> is the indicator function and <code class="reqn">s_{g,0} \equiv 0</code>. Note, this specification is general in that the partitions of the time axes differ across the three hazard functions. our prior choices are, for <code class="reqn">g\in\{1,2,3\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_g | K_g, \mu_{\lambda_g}, \sigma_{\lambda_g}^2 \sim MVN_{K_g+1}(\mu_{\lambda_g}1, \sigma_{\lambda_g}^2\Sigma_{\lambda_g}),</code>
</p>

<p style="text-align: center;"><code class="reqn">K_g \sim Poisson(\alpha_g),</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(s_g | K_g) \propto \frac{(2K_g+1)! \prod_{k=1}^{K_g+1}(s_{g,k}-s_{g,k-1})}{(s_{g,K_g+1})^{(2K_g+1)}},</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(\mu_{\lambda_g}) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{\lambda_g}^{-2} \sim Gamma(a_g, b_g).</code>
</p>

<p>Note that <code class="reqn">K_g</code> and <code class="reqn">s_g</code> are treated as random and the priors for <code class="reqn">K_g</code> and <code class="reqn">s_g</code> jointly form a time-homogeneous Poisson process prior for the partition. The number of time splits and their positions are therefore updated within our computational scheme using reversible jump MCMC.
</p>
<p>For parametric Weibull prior specification for baseline hazard functions, <code class="reqn">h_{0g}(t) = \alpha_g \kappa_g t^{\alpha_g-1}</code>. In our Bayesian framework, our prior choices are, for <code class="reqn">g\in\{1,2,3\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\alpha_g) \sim Gamma(a_g, b_g),</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(\kappa_g) \sim Gamma(c_g, d_g).</code>
</p>

<p>Our prior choice for remaining model parameters in all of four models (Weibull-MVN, Weibull-DPM, PEM-MVN, PEM-DPM) is given as follows:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\beta_g) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_{ji}|\theta \sim Gamma(\theta^{-1}, \theta^{-1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta^{-1} \sim Gamma(\psi, \omega).</code>
</p>
  
<p>We provide a detailed description of the hierarchical models for cluster-correlated semi-competing risks data. The models for independent semi-competing risks data can be obtained by removing cluster-specific random effects, <code class="reqn">V_j</code>, and its corresponding prior	specification from the description given above.
</p>


<h3>Value</h3>

<p><code>BayesID_HReg</code> returns an object of class <code>Bayes_HReg</code>. <br />
</p>


<h3>Note</h3>

<p>The posterior samples of <code class="reqn">\gamma</code> and <code class="reqn">V_g</code> are saved separately in <code>working directory/path</code>. 
For a dataset with large <code class="reqn">n</code>, <code>nGam_save</code> should be carefully specified considering the system memory and the storage capacity.
</p>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Lee, K. H., Dominici, F., Schrag, D., and Haneuse, S. (2016),
Hierarchical models for semicompeting risks data with application to quality of end-of-life care for pancreatic cancer, <em>Journal of the American Statistical Association</em>, 111, 515, 1075-1095. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initiate.startValues_HReg">initiate.startValues_HReg</a></code>, <code><a href="#topic+print.Bayes_HReg">print.Bayes_HReg</a></code>, <code><a href="#topic+summary.Bayes_HReg">summary.Bayes_HReg</a></code>, <code><a href="#topic+predict.Bayes_HReg">predict.Bayes_HReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:    
# loading a data set
data(scrData)
id=scrData$cluster

form &lt;- Formula(time1 + event1 | time2 + event2 ~ x1 + x2 + x3 | x1 + x2 | x1 + x2)

#####################
## Hyperparameters ##
#####################

## Subject-specific frailty variance component
##  - prior parameters for 1/theta
##
theta.ab &lt;- c(0.7, 0.7)

## Weibull baseline hazard function: alphas, kappas
##
WB.ab1 &lt;- c(0.5, 0.01) # prior parameters for alpha1
WB.ab2 &lt;- c(0.5, 0.01) # prior parameters for alpha2
WB.ab3 &lt;- c(0.5, 0.01) # prior parameters for alpha3
##
WB.cd1 &lt;- c(0.5, 0.05) # prior parameters for kappa1
WB.cd2 &lt;- c(0.5, 0.05) # prior parameters for kappa2
WB.cd3 &lt;- c(0.5, 0.05) # prior parameters for kappa3

## PEM baseline hazard function
##
PEM.ab1 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_1^2
PEM.ab2 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_2^2
PEM.ab3 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_3^2
##
PEM.alpha1 &lt;- 10 # prior parameters for K1
PEM.alpha2 &lt;- 10 # prior parameters for K2
PEM.alpha3 &lt;- 10 # prior parameters for K3

## MVN cluster-specific random effects
##
Psi_v &lt;- diag(1, 3)
rho_v &lt;- 100

## DPM cluster-specific random effects
##
Psi0  &lt;- diag(1, 3)
rho0  &lt;- 10
aTau  &lt;- 1.5
bTau  &lt;- 0.0125

##
hyperParams &lt;- list(theta=theta.ab,
                WB=list(WB.ab1=WB.ab1, WB.ab2=WB.ab2, WB.ab3=WB.ab3,
                       WB.cd1=WB.cd1, WB.cd2=WB.cd2, WB.cd3=WB.cd3),
                   PEM=list(PEM.ab1=PEM.ab1, PEM.ab2=PEM.ab2, PEM.ab3=PEM.ab3,
                       PEM.alpha1=PEM.alpha1, PEM.alpha2=PEM.alpha2, PEM.alpha3=PEM.alpha3),
                   MVN=list(Psi_v=Psi_v, rho_v=rho_v),
                   DPM=list(Psi0=Psi0, rho0=rho0, aTau=aTau, bTau=bTau))
                    
###################
## MCMC SETTINGS ##
###################

## Setting for the overall run
##
numReps    &lt;- 2000
thin       &lt;- 10
burninPerc &lt;- 0.5

## Settings for storage
##
nGam_save &lt;- 0
storeV    &lt;- rep(TRUE, 3)

## Tuning parameters for specific updates
##
##  - those common to all models
mhProp_theta_var  &lt;- 0.05
mhProp_Vg_var     &lt;- c(0.05, 0.05, 0.05)
##
## - those specific to the Weibull specification of the baseline hazard functions
mhProp_alphag_var &lt;- c(0.01, 0.01, 0.01)
##
## - those specific to the PEM specification of the baseline hazard functions
Cg        &lt;- c(0.2, 0.2, 0.2)
delPertg  &lt;- c(0.5, 0.5, 0.5)
rj.scheme &lt;- 1
Kg_max    &lt;- c(50, 50, 50)
sg_max    &lt;- c(max(scrData$time1[scrData$event1 == 1]),
               max(scrData$time2[scrData$event1 == 0 &amp; scrData$event2 == 1]),
               max(scrData$time2[scrData$event1 == 1 &amp; scrData$event2 == 1]))

time_lambda1 &lt;- seq(1, sg_max[1], 1)
time_lambda2 &lt;- seq(1, sg_max[2], 1)
time_lambda3 &lt;- seq(1, sg_max[3], 1)               

##
mcmc.WB  &lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
                storage=list(nGam_save=nGam_save, storeV=storeV),
                tuning=list(mhProp_theta_var=mhProp_theta_var,
                mhProp_Vg_var=mhProp_Vg_var, mhProp_alphag_var=mhProp_alphag_var))

##
mcmc.PEM &lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
                storage=list(nGam_save=nGam_save, storeV=storeV),
                tuning=list(mhProp_theta_var=mhProp_theta_var,
                mhProp_Vg_var=mhProp_Vg_var, Cg=Cg, delPertg=delPertg,
                rj.scheme=rj.scheme, Kg_max=Kg_max,
                time_lambda1=time_lambda1, time_lambda2=time_lambda2,
                time_lambda3=time_lambda3))
    
#####################
## Starting Values ##
#####################

##
Sigma_V &lt;- diag(0.1, 3)
Sigma_V[1,2] &lt;- Sigma_V[2,1] &lt;- -0.05
Sigma_V[1,3] &lt;- Sigma_V[3,1] &lt;- -0.06
Sigma_V[2,3] &lt;- Sigma_V[3,2] &lt;- 0.07

#################################################################
## Analysis of Independent Semi-Competing Risks Data ############
#################################################################

#############
## WEIBULL ##
#############

##
myModel &lt;- c("semi-Markov", "Weibull")
myPath  &lt;- "Output/01-Results-WB/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, nChain=2)

##
fit_WB &lt;- BayesID_HReg(form, scrData, id=NULL, model=myModel,
                hyperParams, startValues, mcmc.WB, path=myPath)
				
fit_WB
summ.fit_WB &lt;- summary(fit_WB); names(summ.fit_WB)
summ.fit_WB
pred_WB &lt;- predict(fit_WB, tseq=seq(from=0, to=30, by=5))
plot(pred_WB, plot.est="Haz")
plot(pred_WB, plot.est="Surv")

#########
## PEM ##
#########

##						
myModel &lt;- c("semi-Markov", "PEM")
myPath  &lt;- "Output/02-Results-PEM/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, nChain=2)

##
fit_PEM &lt;- BayesID_HReg(form, scrData, id=NULL, model=myModel,
                 hyperParams, startValues, mcmc.PEM, path=myPath)
				
fit_PEM
summ.fit_PEM &lt;- summary(fit_PEM); names(summ.fit_PEM)
summ.fit_PEM
pred_PEM &lt;- predict(fit_PEM)
plot(pred_PEM, plot.est="Haz")
plot(pred_PEM, plot.est="Surv")
					
#################################################################
## Analysis of Correlated Semi-Competing Risks Data #############
#################################################################

#################
## WEIBULL-MVN ##
#################

##
myModel &lt;- c("semi-Markov", "Weibull", "MVN")
myPath  &lt;- "Output/03-Results-WB_MVN/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, id, nChain=2)

##
fit_WB_MVN &lt;- BayesID_HReg(form, scrData, id, model=myModel,
                    hyperParams, startValues, mcmc.WB, path=myPath)
                    
fit_WB_MVN
summ.fit_WB_MVN &lt;- summary(fit_WB_MVN); names(summ.fit_WB_MVN)
summ.fit_WB_MVN
pred_WB_MVN &lt;- predict(fit_WB_MVN, tseq=seq(from=0, to=30, by=5))
plot(pred_WB_MVN, plot.est="Haz")
plot(pred_WB_MVN, plot.est="Surv")


#################
## WEIBULL-DPM ##
#################

##
myModel &lt;- c("semi-Markov", "Weibull", "DPM")
myPath  &lt;- "Output/04-Results-WB_DPM/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, id, nChain=2)

##
fit_WB_DPM &lt;- BayesID_HReg(form, scrData, id, model=myModel,
                    hyperParams, startValues, mcmc.WB, path=myPath)

fit_WB_DPM
summ.fit_WB_DPM &lt;- summary(fit_WB_DPM); names(summ.fit_WB_DPM)
summ.fit_WB_DPM
pred_WB_DPM &lt;- predict(fit_WB_MVN, tseq=seq(from=0, to=30, by=5))
plot(pred_WB_DPM, plot.est="Haz")
plot(pred_WB_DPM, plot.est="Surv")

#############
## PEM-MVN ##
#############

##
myModel &lt;- c("semi-Markov", "PEM", "MVN")
myPath  &lt;- "Output/05-Results-PEM_MVN/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, id, nChain=2)

##
fit_PEM_MVN &lt;- BayesID_HReg(form, scrData, id, model=myModel,
                    hyperParams, startValues, mcmc.PEM, path=myPath)
                    
fit_PEM_MVN
summ.fit_PEM_MVN &lt;- summary(fit_PEM_MVN); names(summ.fit_PEM_MVN)
summ.fit_PEM_MVN
pred_PEM_MVN &lt;- predict(fit_PEM_MVN)
plot(pred_PEM_MVN, plot.est="Haz")
plot(pred_PEM_MVN, plot.est="Surv")

#############
## PEM-DPM ##
#############

##
myModel &lt;- c("semi-Markov", "PEM", "DPM")
myPath  &lt;- "Output/06-Results-PEM_DPM/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, id, nChain=2)
                    
##
fit_PEM_DPM &lt;- BayesID_HReg(form, scrData, id, model=myModel,
                    hyperParams, startValues, mcmc.PEM, path=myPath)
                    
fit_PEM_DPM
summ.fit_PEM_DPM &lt;- summary(fit_PEM_DPM); names(summ.fit_PEM_DPM)
summ.fit_PEM_DPM
pred_PEM_DPM &lt;- predict(fit_PEM_DPM)
plot(pred_PEM_DPM, plot.est="Haz")
plot(pred_PEM_DPM, plot.est="Surv")
                    

## End(Not run)
</code></pre>

<hr>
<h2 id='BayesSurv_AFT'>
The function to implement Bayesian parametric and semi-parametric analyses for univariate survival data in the context of accelerated failure time (AFT) models.
</h2><span id='topic+BayesSurv_AFT'></span>

<h3>Description</h3>

<p>Independent univariate survival data can be analyzed using AFT models that have a hierarchical structure. The proposed models can accomodate left-truncated and/or interval-censored data. An efficient computational algorithm that gives users the flexibility to adopt either a fully parametric (log-Normal) or a semi-parametric (Dirichlet process mixture) model specification is developed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesSurv_AFT(Formula, data, model = "LN", hyperParams, startValues,
                mcmcParams, na.action = "na.fail", subset=NULL, path=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesSurv_AFT_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcomes on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, left truncation time | interval- (or right-) censored time to event <code class="reqn">\sim</code> covariates : i.e., <code class="reqn">L</code> | <code class="reqn">y_{L}</code>+<code class="reqn">y_{U}</code> ~ <code class="reqn">x</code>. 
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_model">model</code></td>
<td>

<p>The specification of baseline survival distribution: &quot;LN&quot; or &quot;DPM&quot;.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_hyperparams">hyperParams</code></td>
<td>

<p>a list containing lists or vectors for hyperparameter values in hierarchical models. Components include,
<code>LN</code> (a list containing numeric vectors for log-Normal hyperparameters: <code>LN.ab</code>),
<code>DPM</code> (a list containing numeric vectors for DPM hyperparameters: <code>DPM.mu</code>, <code>DPM.sigSq</code>, <code>DPM.ab</code>, <code>Tau.ab</code>).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_startvalues">startValues</code></td>
<td>

<p>a list containing vectors of starting values for model parameters. It can be specified as the object returned by the function <code><a href="#topic+initiate.startValues_AFT">initiate.startValues_AFT</a></code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_mcmcparams">mcmcParams</code></td>
<td>

<p>a list containing variables required for MCMC sampling. Components include,
<code>run</code> (a list containing numeric values for setting for the overall run:
<code>numReps</code>, total number of scans; <code>thin</code>, extent of thinning; <code>burninPerc</code>, the proportion of burn-in).
<code>tuning</code> (a list containing numeric values relevant to tuning parameters for specific updates in Metropolis-Hastings (MH) algorithm:
<code>beta.prop.var</code>, the variance of proposal density for <code class="reqn">\beta</code>; <code>mu.prop.var</code>, the variance of proposal density for <code class="reqn">\mu</code>; <code>zeta.prop.var</code>, the variance of proposal density for <code class="reqn">1/\sigma^2</code>).
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_AFT_+3A_path">path</code></td>
<td>

<p>the name of directory where the results are saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>BayesSurv_AFT</code> implements Bayesian semi-parametric (DPM) and parametric (log-Normal) models to univariate time-to-event data in the presence of left-truncation and/or interval-censoring. Consider a univariate AFT model that relates the covariate <code class="reqn">x_i</code> to survival time <code class="reqn">T_i</code> for the <code class="reqn">i^{\textrm{th}}</code> subject:
</p>
<p style="text-align: center;"><code class="reqn">\log(T_i) =  x_i^{\top}\beta + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i</code> is a random variable whose distribution determines that of <code class="reqn">T_i</code> and <code class="reqn">\beta</code> is a vector of regression parameters. Considering the interval censoring, the time to the event for the <code class="reqn">i^{\textrm{th}}</code> subject satisfies <code class="reqn">c_{ij}\leq T_i &lt;c_{ij+1}</code>. Let <code class="reqn">L_i</code> denote the left-truncation time.
For the Bayesian parametric analysis, we take  <code class="reqn">\epsilon_i</code> to follow the Normal(<code class="reqn">\mu</code>, <code class="reqn">\sigma^2</code>) distribution for <code class="reqn">\epsilon_i</code>. The following prior distributions are adopted for the model parameters:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\beta, \mu) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma^2 \sim \textrm{Inverse-Gamma}(a_{\sigma}, b_{\sigma}).</code>
</p>

<p>For the Bayesian semi-parametric analysis, we assume that <code class="reqn">\epsilon_i</code> is taken as draws from the DPM of normal distributions:
</p>
<p style="text-align: center;"><code class="reqn">\epsilon\sim DPM(G_0, \tau).</code>
</p>

<p>We refer readers to <code><a href="#topic+print.Bayes_AFT">print.Bayes_AFT</a></code> for a detailed illustration of DPM specification. We adopt a non-informative flat prior on the real line for the regression parameters <code class="reqn">\beta</code> and a Gamma(<code class="reqn">a_{\tau}</code>, <code class="reqn">b_{\tau}</code>) hyperprior for the precision parameter <code class="reqn">\tau</code>.
</p>


<h3>Value</h3>

<p><code>BayesSurv_AFT</code> returns an object of class <code>Bayes_AFT</code>. <br />
</p>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Rondeau, V., and Haneuse, S. (2017),
Accelerated failure time models for semicompeting risks data in the presence of complex censoring, <em>Biometrics</em>, 73, 4, 1401-1412. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initiate.startValues_AFT">initiate.startValues_AFT</a></code>, <code><a href="#topic+print.Bayes_AFT">print.Bayes_AFT</a></code>, <code><a href="#topic+summary.Bayes_AFT">summary.Bayes_AFT</a></code>, <code><a href="#topic+predict.Bayes_AFT">predict.Bayes_AFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# loading a data set
data(survData)
survData$yL &lt;- survData$yU &lt;- survData[,1]
survData$yU[which(survData[,2] == 0)] &lt;- Inf
survData$LT &lt;- rep(0, dim(survData)[1])

form &lt;- Formula(LT | yL + yU ~ cov1 + cov2)

#####################
## Hyperparameters ##
#####################

## log-Normal model
##
LN.ab &lt;- c(0.3, 0.3)

## DPM model
##
DPM.mu &lt;- log(12)
DPM.sigSq &lt;- 100
DPM.ab &lt;-  c(2, 1)
Tau.ab &lt;- c(1.5, 0.0125)

##
hyperParams &lt;- list(LN=list(LN.ab=LN.ab),
DPM=list(DPM.mu=DPM.mu, DPM.sigSq=DPM.sigSq, DPM.ab=DPM.ab, Tau.ab=Tau.ab))

###################
## MCMC SETTINGS ##
###################

## Setting for the overall run
##
numReps    &lt;- 100
thin       &lt;- 1
burninPerc &lt;- 0.5

## Tuning parameters for specific updates
##
##  - those common to all models
beta.prop.var	&lt;- 0.01
mu.prop.var	&lt;- 0.1
zeta.prop.var	&lt;- 0.1

##
mcmcParams	&lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
tuning=list(beta.prop.var=beta.prop.var, mu.prop.var=mu.prop.var,
zeta.prop.var=zeta.prop.var))

################################################################
## Analysis of Independent univariate survival data ############
################################################################

###############
## logNormal ##
###############

##
myModel &lt;- "LN"
myPath  &lt;- "Output/01-Results-LN/"

startValues      &lt;- initiate.startValues_AFT(form, survData, model=myModel, nChain=2)

##
fit_LN &lt;- BayesSurv_AFT(form, survData, model=myModel, hyperParams,
startValues, mcmcParams, path=myPath)

fit_LN
summ.fit_LN &lt;- summary(fit_LN); names(summ.fit_LN)
summ.fit_LN
pred_LN &lt;- predict(fit_LN, time = seq(0, 35, 1), tseq=seq(from=0, to=30, by=5))
plot(pred_LN, plot.est="Haz")
plot(pred_LN, plot.est="Surv")

#########
## DPM ##
#########

##
myModel &lt;- "DPM"
myPath  &lt;- "Output/02-Results-DPM/"

startValues      &lt;- initiate.startValues_AFT(form, survData, model=myModel, nChain=2)

##
fit_DPM &lt;- BayesSurv_AFT(form, survData, model=myModel, hyperParams,
startValues, mcmcParams, path=myPath)

fit_DPM
summ.fit_DPM &lt;- summary(fit_DPM); names(summ.fit_DPM)
summ.fit_DPM
pred_DPM &lt;- predict(fit_DPM, time = seq(0, 35, 1), tseq=seq(from=0, to=30, by=5))
plot(pred_DPM, plot.est="Haz")
plot(pred_DPM, plot.est="Surv")

## End(Not run)

</code></pre>

<hr>
<h2 id='BayesSurv_HReg'>
The function to implement Bayesian parametric and semi-parametric regression analyses for univariate time-to-event data in the context of hazard regression (HReg) models.
</h2><span id='topic+BayesSurv_HReg'></span>

<h3>Description</h3>

<p>Independent/cluster-correlated univariate right-censored survival data can be analyzed using hierarchical models. The prior for the baseline hazard function can be specified by either parametric (Weibull) model or non-parametric mixture of piecewise exponential models (PEM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesSurv_HReg(Formula, data, id=NULL, model="Weibull", hyperParams,
        startValues, mcmcParams, na.action = "na.fail", subset=NULL, path=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesSurv_HReg_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcome on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, time to event + censoring indicator <code class="reqn">\sim</code> covariates: i.e., <code class="reqn">y</code>+<code class="reqn">\delta</code> ~ <code class="reqn">x</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_id">id</code></td>
<td>

<p>a vector of cluster information for <code>n</code> subjects. The cluster membership must be consecutive positive integers, <code class="reqn">1:J</code>.  
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_model">model</code></td>
<td>

<p>a character vector that specifies the type of components in a model. 
The first element is for the specification of baseline hazard functions: &quot;Weibull&quot; or &quot;PEM&quot;. 
The second element needs to be set only for clustered data and is for the specification of cluster-specific random effects distribution: &quot;Normal&quot; or &quot;DPM&quot;.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_hyperparams">hyperParams</code></td>
<td>

<p>a list containing lists or vectors for hyperparameter values in hierarchical models. Components include, 
<code>WB</code> (a list containing a numeric vector for Weibull hyperparameters: <code>WB.ab</code>, <code>WB.cd</code>), 
<code>PEM</code> (a list containing numeric vectors for PEM hyperparameters: <code>PEM.ab</code>, <code>PEM.alpha</code>).
Models for clustered data require additional components,
<code>Normal</code> (a list containing a numeric vector for hyperparameters in a Normal prior: <code>Normal.ab</code>), 
<code>DPM</code> (a list containing numeric vectors for DPM hyperparameters: <code>DPM.ab</code>, <code>aTau</code>, <code>bTau</code>).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_startvalues">startValues</code></td>
<td>

<p>a list containing vectors of starting values for model parameters. It can be specified as the object returned by the function <code><a href="#topic+initiate.startValues_HReg">initiate.startValues_HReg</a></code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_mcmcparams">mcmcParams</code></td>
<td>

<p>a list containing variables required for MCMC sampling. Components include,
<code>run</code> (a list containing numeric values for setting for the overall run: 
<code>numReps</code>, total number of scans; <code>thin</code>, extent of thinning; <code>burninPerc</code>, the proportion of burn-in).
<code>storage</code> (a list containing numeric values for storing posterior samples for cluster-specific random effects: 
<code>storeV</code>, a logical value to determine whether all the posterior samples of <code class="reqn">V</code> are to be stored.)
<code>tuning</code> (a list containing numeric values relevant to tuning parameters for specific updates in Metropolis-Hastings-Green (MHG) algorithm: 
<code>mhProp_V_var</code>, the variance of proposal density for <code class="reqn">V</code> in DPM models; 
<code>mhProp_alpha_var</code>, the variance of proposal density for <code class="reqn">\alpha</code> in Weibull models; 
<code>C</code>, a numeric value for the proportion that determines the sum of probabilities of choosing the birth and the death moves in PEM models. 
The value should not exceed 0.8;
<code>delPert</code>, the perturbation parameter in the birth update in PEM models. The values must be between 0 and 0.5;
If <code>rj.scheme</code>=1, the birth update will draw the proposal time split from <code class="reqn">1:s_{max}</code>.
If <code>rj.scheme</code>=2, the birth update will draw the proposal time split from uniquely ordered failure times in the data. Only required for PEM models;
<code>K_max</code>, the maximum number of splits allowed at each iteration in MHG algorithm for PEM models;
<code>time_lambda</code> - time points at which the log-hazard function is calculated for <code><a href="#topic+predict.Bayes_HReg">predict.Bayes_HReg</a></code>, Only required for PEM models).
See Details and Examples below.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="BayesSurv_HReg_+3A_path">path</code></td>
<td>

<p>the name of directory where the results are saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>BayesSurv_HReg</code> implements Bayesian semi-parametric (piecewise exponential mixture) and parametric (Weibull) models to univariate time-to-event data. Let <code class="reqn">t_{ji}</code> denote time to event of interest from subject <code class="reqn">i=1,...,n_j</code> in cluster <code class="reqn">j=1,...,J</code>. The covariates <code class="reqn">x_{ji}</code> are incorporated via Cox proportional hazards model:
</p>
<p style="text-align: center;"><code class="reqn">h(t_{ji} | x_{ji}) = h_{0}(t_{ji})\exp(x_{ji}^{\top}\beta + V_{j}), t_{ji}&gt;0,</code>
</p>

<p>where <code class="reqn">h_0</code> is an unspecified baseline hazard function and <code class="reqn">\beta</code> is a vector of <code class="reqn">p</code> log-hazard ratio regression parameters. <code class="reqn">V_j</code>'s are cluster-specific random effects.
For parametric Normal prior specification for a vector of cluster-specific random effects, we assume <code class="reqn">V</code> arise as i.i.d. draws from a mean 0 Normal distribution with variance <code class="reqn">\sigma^2</code>. Specifically, the priors can be written as follows:
</p>
<p style="text-align: center;"><code class="reqn">V_j \sim Normal(0, \sigma^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta=1/\sigma^2 \sim Gamma(a_{N}, b_{N}).</code>
</p>

<p>For DPM prior specification for <code class="reqn">V_j</code>, we consider non-parametric Dirichlet process mixture of Normal distributions: the <code class="reqn">V_j</code>'s' are draws from a finite mixture of M Normal distributions, each with their own mean and variance, (<code class="reqn">\mu_m</code>, <code class="reqn">\sigma_m^2</code>) for <code class="reqn">m=1,...,M</code>. Let <code class="reqn">m_j\in\{1,...,M\}</code> denote the specific component to which the <code class="reqn">j</code>th cluster belongs. Since the class-specific (<code class="reqn">\mu_m</code>, <code class="reqn">\sigma_m^2</code>) are not known they are taken to be draws from some distribution, <code class="reqn">G_0</code>, often referred to as the centering distribution. Furthermore, since the true class memberships are unknown, we denote the probability that the <code class="reqn">j</code>th cluster belongs to any given class by the vector <code class="reqn">p=(p_1,..., p_M)</code> whose components add up to 1.0. In the absence of prior knowledge regarding the distribution of class memberships for the <code class="reqn">J</code> clusters across the <code class="reqn">M</code> classes, a natural prior for <code class="reqn">p</code> is the conjugate symmetric <code class="reqn">Dirichlet(\tau/M,...,\tau/M)</code> distribution; the hyperparameter, <code class="reqn">\tau</code>, is often referred to as a the precision parameter. The prior can be represented as follows (<code class="reqn">M</code> goes to infinity):
</p>
<p style="text-align: center;"><code class="reqn">V_j | m_j \sim Normal(\mu_{m_j}, \sigma_{m_j}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">(\mu_m, \sigma_m^2) \sim G_{0},~~ for ~m=1,...,M,</code>
</p>

<p style="text-align: center;"><code class="reqn">m_j | p \sim Discrete(m_j| p_1,...,p_M),</code>
</p>

<p style="text-align: center;"><code class="reqn">p \sim Dirichlet(\tau/M,...,\tau/M),</code>
</p>

<p>where <code class="reqn">G_0</code> is taken to be a multivariate Normal/inverse-Gamma (NIG) distribution for which the probability density function is the following product:
</p>
<p style="text-align: center;"><code class="reqn">f_{NIG}(\mu, \sigma^2 | \mu_0, \zeta_0, a_0, b_0) = f_{Normal}(\mu | 0, 1/\zeta_0^2) \times f_{Gamma}(\zeta=1/\sigma^2 | a_0, b_0).</code>
</p>

<p>In addition, we use <code class="reqn">Gamma(a_{\tau}, b_{\tau})</code> as the hyperprior for <code class="reqn">\tau</code>.
</p>
<p>For non-parametric prior specification (PEM) for baseline hazard function, let <code class="reqn">s_{\max}</code> denote the largest observed event time. Then, consider the finite partition of the relevant time axis into <code class="reqn">K + 1</code> disjoint intervals: <code class="reqn">0&lt;s_1&lt;s_2&lt;...&lt;s_{K+1} = s_{\max}</code>. For notational convenience, let <code class="reqn">I_k=(s_{k-1}, s_k]</code> denote the <code class="reqn">k^{th}</code> partition. For given a partition, <code class="reqn">s = (s_1, \dots, s_{K + 1})</code>, we assume the log-baseline hazard functions is piecewise constant:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{0}(t)=\log h_{0}(t) = \sum_{k=1}^{K + 1} \lambda_{k} I(t\in I_{k}),</code>
</p>

<p>where <code class="reqn">I(\cdot)</code> is the indicator function and <code class="reqn">s_0 \equiv 0</code>. In our proposed Bayesian framework, our prior choices are:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\beta) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda | K, \mu_{\lambda}, \sigma_{\lambda}^2 \sim MVN_{K+1}(\mu_{\lambda}1, \sigma_{\lambda}^2\Sigma_{\lambda}),</code>
</p>

<p style="text-align: center;"><code class="reqn">K \sim Poisson(\alpha),</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(s | K) \propto \frac{(2K+1)! \prod_{k=1}^{K+1}(s_k-s_{k-1})}{(s_{K+1})^{(2K+1)}},</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(\mu_{\lambda}) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{\lambda}^{-2} \sim Gamma(a, b).</code>
</p>

<p>Note that <code class="reqn">K</code> and <code class="reqn">s</code> are treated as random and the priors for <code class="reqn">K</code> and <code class="reqn">s</code> jointly form a time-homogeneous Poisson process prior for the partition. The number of time splits and their positions are therefore updated within our computational scheme using reversible jump MCMC.
</p>
<p>For parametric Weibull prior specification for baseline hazard function, <code class="reqn">h_{0}(t) = \alpha \kappa t^{\alpha-1}</code>.
In our Bayesian framework, our prior choices are:	
</p>
<p style="text-align: center;"><code class="reqn">\pi(\beta) \propto 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(\alpha) \sim Gamma(a, b),</code>
</p>

<p style="text-align: center;"><code class="reqn">\pi(\kappa) \sim Gamma(c, d).</code>
</p>

<p>We provide a detailed description of the hierarchical models for cluster-correlated univariate survival data. The models for independent data can be obtained by removing cluster-specific random effects, <code class="reqn">V_j</code>, and its corresponding prior specification from the description given above. 	
</p>


<h3>Value</h3>

<p><code>BayesSurv_HReg</code> returns an object of class <code>Bayes_HReg</code>. <br /> 
</p>


<h3>Note</h3>

<p>The posterior samples of <code class="reqn">V_g</code> are saved separately in <code>working directory/path</code>.
</p>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse <br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Lee, K. H., Dominici, F., Schrag, D., and Haneuse, S. (2016),
Hierarchical models for semicompeting risks data with application to quality of end-of-life care for pancreatic cancer, <em>Journal of the American Statistical Association</em>, 111, 515, 1075-1095. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initiate.startValues_HReg">initiate.startValues_HReg</a></code>, <code><a href="#topic+print.Bayes_HReg">print.Bayes_HReg</a></code>, <code><a href="#topic+summary.Bayes_HReg">summary.Bayes_HReg</a></code>, <code><a href="#topic+predict.Bayes_HReg">predict.Bayes_HReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
## Not run: 		
# loading a data set	
data(survData)
id=survData$cluster

form &lt;- Formula(time + event ~ cov1 + cov2)

#####################
## Hyperparameters ##
#####################

## Weibull baseline hazard function: alpha1, kappa1
##
WB.ab &lt;- c(0.5, 0.01) # prior parameters for alpha
##
WB.cd &lt;- c(0.5, 0.05) # prior parameters for kappa

## PEM baseline hazard function: 
##
PEM.ab &lt;- c(0.7, 0.7) # prior parameters for 1/sigma^2
##
PEM.alpha &lt;- 10 # prior parameters for K

## Normal cluster-specific random effects
##
Normal.ab 	&lt;- c(0.5, 0.01) 		# prior for zeta

## DPM cluster-specific random effects
##
DPM.ab &lt;- c(0.5, 0.01)
aTau  &lt;- 1.5
bTau  &lt;- 0.0125

##
hyperParams &lt;- list(WB=list(WB.ab=WB.ab, WB.cd=WB.cd),
                    PEM=list(PEM.ab=PEM.ab, PEM.alpha=PEM.alpha),
                    Normal=list(Normal.ab=Normal.ab),
                    DPM=list(DPM.ab=DPM.ab, aTau=aTau, bTau=bTau))
                    
###################
## MCMC SETTINGS ##
###################

## Setting for the overall run
##
numReps    &lt;- 2000
thin       &lt;- 10
burninPerc &lt;- 0.5

## Settings for storage
##
storeV    &lt;- TRUE

## Tuning parameters for specific updates
##
##  - those common to all models
mhProp_V_var     &lt;- 0.05
##
## - those specific to the Weibull specification of the baseline hazard functions
mhProp_alpha_var &lt;- 0.01
##
## - those specific to the PEM specification of the baseline hazard functions
C        &lt;- 0.2
delPert  &lt;- 0.5
rj.scheme &lt;- 1
K_max    &lt;- 50
s_max    &lt;- max(survData$time[survData$event == 1])
time_lambda &lt;- seq(1, s_max, 1)

##
mcmc.WB  &lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
                    storage=list(storeV=storeV),
                    tuning=list(mhProp_alpha_var=mhProp_alpha_var, mhProp_V_var=mhProp_V_var))
##
mcmc.PEM &lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
                    storage=list(storeV=storeV),
                    tuning=list(mhProp_V_var=mhProp_V_var, C=C, delPert=delPert,
                    rj.scheme=rj.scheme, K_max=K_max, time_lambda=time_lambda))

################################################################
## Analysis of Independent Univariate Survival Data ############
################################################################

#############
## WEIBULL ##
#############

##
myModel &lt;- "Weibull"
myPath  &lt;- "Output/01-Results-WB/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, nChain=2)

##
fit_WB &lt;- BayesSurv_HReg(form, survData, id=NULL, model=myModel, 
                  hyperParams, startValues, mcmc.WB, path=myPath)
                  
fit_WB
summ.fit_WB &lt;- summary(fit_WB); names(summ.fit_WB)
summ.fit_WB
pred_WB &lt;- predict(fit_WB, tseq=seq(from=0, to=30, by=5))
plot(pred_WB, plot.est="Haz")
plot(pred_WB, plot.est="Surv")

#########
## PEM ##
#########
                
##
myModel &lt;- "PEM"
myPath  &lt;- "Output/02-Results-PEM/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, nChain=2)

##
fit_PEM &lt;- BayesSurv_HReg(form, survData, id=NULL, model=myModel,
                   hyperParams, startValues, mcmc.PEM, path=myPath)
                   
fit_PEM
summ.fit_PEM &lt;- summary(fit_PEM); names(summ.fit_PEM)
summ.fit_PEM
pred_PEM &lt;- predict(fit_PEM)
plot(pred_PEM, plot.est="Haz")
plot(pred_PEM, plot.est="Surv")

###############################################################
## Analysis of Correlated Univariate Survival Data ############
###############################################################

####################
## WEIBULL-NORMAL ##
####################

##
myModel &lt;- c("Weibull", "Normal")
myPath  &lt;- "Output/03-Results-WB_Normal/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, id, nChain=2)

##
fit_WB_N &lt;- BayesSurv_HReg(form, survData, id, model=myModel,
                        hyperParams, startValues, mcmc.WB, path=myPath)
                        
fit_WB_N
summ.fit_WB_N &lt;- summary(fit_WB_N); names(summ.fit_WB_N)
summ.fit_WB_N
pred_WB_N &lt;- predict(fit_WB_N, tseq=seq(from=0, to=30, by=5))
plot(pred_WB_N, plot.est="Haz")
plot(pred_WB_N, plot.est="Surv")

#################
## WEIBULL-DPM ##
#################

##
myModel &lt;- c("Weibull", "DPM")
myPath  &lt;- "Output/04-Results-WB_DPM/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, id, nChain=2)

##
fit_WB_DPM &lt;- BayesSurv_HReg(form, survData, id, model=myModel,
                        hyperParams, startValues, mcmc.WB, path=myPath)

fit_WB_DPM
summ.fit_WB_DPM &lt;- summary(fit_WB_DPM); names(summ.fit_WB_DPM)
summ.fit_WB_DPM
pred_WB_DPM &lt;- predict(fit_WB_DPM, tseq=seq(from=0, to=30, by=5))
plot(pred_WB_DPM, plot.est="Haz")
plot(pred_WB_DPM, plot.est="Surv")

################
## PEM-NORMAL ##
################

##
myModel &lt;- c("PEM", "Normal")
myPath  &lt;- "Output/05-Results-PEM_Normal/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, id, nChain=2)

##
fit_PEM_N &lt;- BayesSurv_HReg(form, survData, id, model=myModel,
                            hyperParams, startValues, mcmc.PEM, path=myPath)

fit_PEM_N
summ.fit_PEM_N &lt;- summary(fit_PEM_N); names(summ.fit_PEM_N)
summ.fit_PEM_N
pred_PEM_N &lt;- predict(fit_PEM_N)
plot(pred_PEM_N, plot.est="Haz")
plot(pred_PEM_N, plot.est="Surv")

#############
## PEM-DPM ##
#############

##
myModel &lt;- c("PEM", "DPM")
myPath  &lt;- "Output/06-Results-PEM_DPM/"

startValues      &lt;- initiate.startValues_HReg(form, survData, model=myModel, id, nChain=2)

##
fit_PEM_DPM &lt;- BayesSurv_HReg(form, survData, id, model=myModel,
                        hyperParams, startValues, mcmc.PEM, path=myPath)
                        
fit_PEM_DPM
summ.fit_PEM_DPM &lt;- summary(fit_PEM_DPM); names(summ.fit_PEM_DPM)
summ.fit_PEM_DPM
pred_PEM_DPM &lt;- predict(fit_PEM_DPM)
plot(pred_PEM_DPM, plot.est="Haz")
plot(pred_PEM_DPM, plot.est="Surv")

## End(Not run)
</code></pre>

<hr>
<h2 id='BMT'>
Data on 137 Bone Marrow Transplant Patients
</h2><span id='topic+BMT'></span>

<h3>Description</h3>

<p>Data on 137 Bone Marrow Transplant Patients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BMT)</code></pre>


<h3>Format</h3>

<p>a data frame with 137 observations on the following 22 variables.
</p>

<dl>
<dt><code>g</code></dt><dd><p>disease group; 1-ALL, 2-AML low-risk, 3-high-risk</p>
</dd>
<dt><code>T1</code></dt><dd><p>time (in days) to death or on study time</p>
</dd>
<dt><code>T2</code></dt><dd><p>disease-Free survival time (time to relapse, death or end of study)</p>
</dd>
<dt><code>delta1</code></dt><dd><p>death indicator; 1-Dead, 0-Alive</p>
</dd>
<dt><code>delta2</code></dt><dd><p>relapse indicator; 1-Relapsed, 0-Disease-Free</p>
</dd>
<dt><code>delta3</code></dt><dd><p>disease-Free survival indicator; 1-Dead or relapsed, 0-Alive disease-free</p>
</dd>
<dt><code>TA</code></dt><dd><p>time (in days) to acute graft-versus-host disease</p>
</dd>
<dt><code>deltaA</code></dt><dd><p>acute graft-versus-host disease indicator; 1-Developed acute graft-versus-host disease, 0-Never developed acute graft-versus-host disease</p>
</dd>
<dt><code>TC</code></dt><dd><p>time (in days) to chronic graft-versus-host disease</p>
</dd>
<dt><code>deltaC</code></dt><dd><p>chronic graft-versus-host disease indicator; 1-Developed chronic graft-versus-host disease, 0-Never developed chronic graft-versus-host disease</p>
</dd>
<dt><code>TP</code></dt><dd><p>time (in days) to return of platelets to normal levels</p>
</dd>
<dt><code>deltaP</code></dt><dd><p>platelet recovery indicator; 1-Platelets returned to normal levels, 0-Platelets never returned to normal levels</p>
</dd>
<dt><code>Z1</code></dt><dd><p>patient age in years</p>
</dd>
<dt><code>Z2</code></dt><dd><p>donor age in years</p>
</dd>
<dt><code>Z3</code></dt><dd><p>patient sex: 1-Male, 2-Female</p>
</dd>
<dt><code>Z4</code></dt><dd><p>donor sex: 1-Male, 2-Female</p>
</dd>
<dt><code>Z5</code></dt><dd><p>patient CMV status: 1-CMV positive, 0-CMV negative</p>
</dd>
<dt><code>Z6</code></dt><dd><p>donor CMV status: 1-CMV positive, 0-CMV negative</p>
</dd>
<dt><code>Z7</code></dt><dd><p>waiting time to transplant in days</p>
</dd>
<dt><code>Z8</code></dt><dd><p>FAB: 1-FAB Grade 4 or 5 and AML, 0-Otherwise</p>
</dd>
<dt><code>Z9</code></dt><dd><p>hospital: 1-The Ohio State University, 2-Alfred, 3-St. Vincent, 4-Hahnemann</p>
</dd>
<dt><code>Z10</code></dt><dd><p>MTX used as a graft-versus-host-prophylactic; 1-Yes, 0-No</p>
</dd>
</dl>



<h3>Source</h3>

<p>1. R package &quot;<code>KMsurv</code>&quot;. <br />
2. Klein, J. P. and Moeschberger M. L. (2005). 
Survival Analysis: Techniques for Censored and Truncated Data.
</p>


<h3>References</h3>

<p>Klein, J. P. and Moeschberger M. L. (2005). 
Survival Analysis: Techniques for Censored and Truncated Data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BMT)
</code></pre>

<hr>
<h2 id='CIBMTR'>
Center for International Blood and Bone Marrow Transplant Research (CIBMTR) data
</h2><span id='topic+CIBMTR'></span>

<h3>Description</h3>

<p>We provide a dataset with five covariates from a study of acute graft-versus-host (GVHD) disease with 9651 patients who underwent first allogeneic hematopoietic cell transplant. We also provide an algorithm to simulate semi-competing risks outcome data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CIBMTR")</code></pre>


<h3>Format</h3>

<p>A data frame with 9651 observations on the following 5 variables.
</p>

<dl>
<dt><code>sexP</code></dt><dd><p>patient sex: <code>M</code>-Male, <code>F</code>-Female</p>
</dd>
<dt><code>ageP</code></dt><dd><p>patient age: <code>LessThan10</code>, <code>10to19</code>, <code>20to29</code>, <code>30to39</code>, <code>40to49</code>, <code>50to59</code>, <code>60plus</code></p>
</dd>
<dt><code>dType</code></dt><dd><p>disease type: <code>AML</code>-Acute Myeloid Leukemia, <code>ALL</code>-Acute Lymphoblastic Leukemia, <code>CML</code>-Chronic Myeloid Leukemia, <code>MDS</code>-Myelodysplastic Syndrome</p>
</dd>
<dt><code>dStatus</code></dt><dd><p>disease stage: <code>Early</code>-early, <code>Int</code>-intermediate, <code>Adv</code>-advanced</p>
</dd>
<dt><code>donorGrp</code></dt><dd><p>human leukocyte antigen compatibility: <code>HLA_Id_Sib</code>-identical sibling, <code>8_8</code>-8/8, <code>7_8</code>-7/8</p>
</dd>
</dl>



<h3>Details</h3>

<p>See Examples below for an algorithm to simulate semi-competing risks outcome data. 
</p>


<h3>Source</h3>

<p>Center for International Blood and Bone Marrow Transplant Research
</p>


<h3>References</h3>

<p>Lee, C., Lee, S.J., Haneuse, S. (2017+). Time-to-event analysis when the event is defined on a finite time interval. <em>under review</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CIBMTR_Params">CIBMTR_Params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CIBMTR_Params)
data(CIBMTR)

## CREATING DUMMY VARIABLES ##

# Sex (M: reference)
CIBMTR$sexP &lt;- as.numeric(CIBMTR$sexP)-1

# Age (LessThan10: reference)
CIBMTR$ageP20to29 &lt;- as.numeric(CIBMTR$ageP=="20to29")
CIBMTR$ageP30to39 &lt;- as.numeric(CIBMTR$ageP=="30to39")
CIBMTR$ageP40to49 &lt;- as.numeric(CIBMTR$ageP=="40to49")
CIBMTR$ageP50to59 &lt;- as.numeric(CIBMTR$ageP=="50to59")
CIBMTR$ageP60plus &lt;- as.numeric(CIBMTR$ageP=="60plus")

# Disease type (AML: reference)
CIBMTR$dTypeALL &lt;- as.numeric(CIBMTR$dType=="ALL")
CIBMTR$dTypeCML &lt;- as.numeric(CIBMTR$dType=="CML")
CIBMTR$dTypeMDS &lt;- as.numeric(CIBMTR$dType=="MDS")

# Disease status (Early: reference)
CIBMTR$dStatusInt &lt;- as.numeric(CIBMTR$dStatus=="Int")
CIBMTR$dStatusAdv &lt;- as.numeric(CIBMTR$dStatus=="Adv")

# HLA compatibility (HLA_Id_Sib: reference)
CIBMTR$donorGrp8_8 &lt;- as.numeric(CIBMTR$donorGrp=="8_8")
CIBMTR$donorGrp7_8 &lt;- as.numeric(CIBMTR$donorGrp=="7_8")

# Covariate matrix
x &lt;- CIBMTR[,c("sexP","ageP20to29","ageP30to39","ageP40to49","ageP50to59","ageP60plus",
"dTypeALL","dTypeCML","dTypeMDS","dStatusInt","dStatusAdv","donorGrp8_8","donorGrp7_8")]

# Set the parameter values
beta1 &lt;- CIBMTR_Params$beta1.true
beta2 &lt;- CIBMTR_Params$beta2.true
beta3 &lt;- CIBMTR_Params$beta3.true
alpha1 &lt;- CIBMTR_Params$alpha1.true
alpha2 &lt;- CIBMTR_Params$alpha2.true
alpha3 &lt;- CIBMTR_Params$alpha3.true
kappa1 &lt;- CIBMTR_Params$kappa1.true
kappa2 &lt;- CIBMTR_Params$kappa2.true
kappa3 &lt;- CIBMTR_Params$kappa3.true
theta &lt;- CIBMTR_Params$theta.true

set.seed(1405)
simCIBMTR &lt;- simID(id=NULL, x, x, x, beta1, beta2, beta3, alpha1, alpha2, alpha3,
          kappa1, kappa2, kappa3, theta, SigmaV.true=NULL, cens=c(365,365))
          
names(simCIBMTR) &lt;- c("time1", "event1", "time2", "event2")
CIBMTR &lt;- cbind(simCIBMTR, CIBMTR) 
head(CIBMTR)
</code></pre>

<hr>
<h2 id='CIBMTR_Params'>
Estimates for model parameters from semi-competing risks analysis of the CIBMTR data using Weibull illness-death model.
</h2><span id='topic+CIBMTR_Params'></span>

<h3>Description</h3>

<p>Estimates for model parameters from semi-competing risks analysis of the CIBMTR data using Weibull illness-death model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CIBMTR_Params")</code></pre>


<h3>Format</h3>

<p>The format is a list of 10 components corresponding to parameters for Weibull illness-death model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CIBMTR">CIBMTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CIBMTR_Params)
</code></pre>

<hr>
<h2 id='FreqID_HReg'>
The function to fit parametric Weibull models for the frequentist anlaysis of semi-competing risks data.
</h2><span id='topic+FreqID_HReg'></span>

<h3>Description</h3>

<p>Independent semi-competing risks data can be analyzed using hierarchical models. Markov or semi-Markov assumption can be adopted for the conditional hazard function for time to the terminal event given time to non-terminal event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FreqID_HReg(Formula, data, model="semi-Markov", frailty = TRUE, na.action = "na.fail",
subset=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FreqID_HReg_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcome on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, time to non-terminal event + corresponding censoring indicator | time to terminal event + corresponding censoring indicator <code class="reqn">\sim</code> covariates for <code class="reqn">h_1</code> | covariates for <code class="reqn">h_2</code> | covariates for <code class="reqn">h_3</code>: i.e., <code class="reqn">y_1</code>+<code class="reqn">\delta_1</code> | <code class="reqn">y_2</code>+<code class="reqn">\delta_2</code> ~ <code class="reqn">x_1</code> | <code class="reqn">x_2</code> | <code class="reqn">x_3</code>. 
</p>
</td></tr>
<tr><td><code id="FreqID_HReg_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="FreqID_HReg_+3A_model">model</code></td>
<td>

<p>a character value that specifies the type of a model based on the assumption on <code class="reqn">h_3</code>: &quot;semi-Markov&quot; or &quot;Markov&quot;. 
</p>
</td></tr>
<tr><td><code id="FreqID_HReg_+3A_frailty">frailty</code></td>
<td>

<p>a logical value to determine whether to include the subject-specific shared frailty term, <code class="reqn">\gamma</code>, into the model.
</p>
</td></tr>
<tr><td><code id="FreqID_HReg_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="FreqID_HReg_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code> for a detailed description of the models.
</p>


<h3>Value</h3>

<p><code>FreqID_HReg</code> returns an object of class <code>Freq_HReg</code>. <br />
</p>


<h3>Author(s)</h3>

<p>Sebastien Haneuse and Kyu Ha Lee<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Freq_HReg">print.Freq_HReg</a></code>, <code><a href="#topic+summary.Freq_HReg">summary.Freq_HReg</a></code>, <code><a href="#topic+predict.Freq_HReg">predict.Freq_HReg</a></code>, <code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# loading a data set
data(scrData)

form &lt;- Formula(time1 + event1 | time2 + event2 ~ x1 + x2 + x3 | x1 + x2 | x1 + x2)

fit_WB	&lt;- FreqID_HReg(form, data=scrData, model="semi-Markov")

fit_WB
summ.fit_WB &lt;- summary(fit_WB); names(summ.fit_WB)
summ.fit_WB
pred_WB &lt;- predict(fit_WB, tseq=seq(from=0, to=30, by=5))
plot(pred_WB, plot.est="Haz")
plot(pred_WB, plot.est="Surv")

## End(Not run)
</code></pre>

<hr>
<h2 id='FreqSurv_HReg'>
The function to fit parametric Weibull models for the frequentist analysis of univariate survival data.
</h2><span id='topic+FreqSurv_HReg'></span>

<h3>Description</h3>

<p>Independent univariate right-censored survival data can be analyzed using hierarchical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FreqSurv_HReg(Formula, data, na.action = "na.fail", subset=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FreqSurv_HReg_+3A_formula">Formula</code></td>
<td>

<p>a <code>Formula</code> object, with the outcome on the left of a <code class="reqn">\sim</code>, and covariates on the right. It is of the form, time to event + censoring indicator <code class="reqn">\sim</code> covariates: i.e., <code class="reqn">y</code>+<code class="reqn">\delta</code> ~ <code class="reqn">x</code>.
</p>
</td></tr>
<tr><td><code id="FreqSurv_HReg_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in <code>Formula</code>.
</p>
</td></tr>
<tr><td><code id="FreqSurv_HReg_+3A_na.action">na.action</code></td>
<td>

<p>how NAs are treated. See <code>model.frame</code>.
</p>
</td></tr>
<tr><td><code id="FreqSurv_HReg_+3A_subset">subset</code></td>
<td>

<p>a specification of the rows to be used: defaults to all rows. See <code>model.frame</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+BayesSurv_HReg">BayesSurv_HReg</a></code> for a detailed description of the models.
</p>


<h3>Value</h3>

<p><code>FreqSurv_HReg</code> returns an object of class <code>Freq_HReg</code>. <br /> 
</p>


<h3>Author(s)</h3>

<p>Sebastien Haneuse and Kyu Ha Lee<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Freq_HReg">print.Freq_HReg</a></code>, <code><a href="#topic+summary.Freq_HReg">summary.Freq_HReg</a></code>, <code><a href="#topic+predict.Freq_HReg">predict.Freq_HReg</a></code>, <code><a href="#topic+BayesSurv_HReg">BayesSurv_HReg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 	
# loading a data set	
data(survData)

form &lt;- Formula(time + event ~ cov1 + cov2)

fit_WB &lt;- FreqSurv_HReg(form, data=survData)
fit_WB
summ.fit_WB &lt;- summary(fit_WB); names(summ.fit_WB)
summ.fit_WB
pred_WB &lt;- predict(fit_WB, tseq=seq(from=0, to=30, by=5))
plot(pred_WB, plot.est="Haz")
plot(pred_WB, plot.est="Surv")

## End(Not run)
</code></pre>

<hr>
<h2 id='initiate.startValues_AFT'>
The function that initiates starting values for a single chain.
</h2><span id='topic+initiate.startValues_AFT'></span>

<h3>Description</h3>

<p>The function initiates starting values for a single chain for accelrated failture time (AFT) models. Users are allowed to set some non-null values to starting values for a set of parameters. The function will automatically generate starting values for any parameters whose values are not specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    initiate.startValues_AFT(Formula, data, model, nChain=1,
                            beta1=NULL, beta2=NULL, beta3=NULL, beta=NULL,
                            gamma=NULL, theta=NULL,
                            y1=NULL, y2=NULL, y=NULL,
                            LN.mu=NULL, LN.sigSq=NULL,
                            DPM.class1=NULL, DPM.class2=NULL, DPM.class3=NULL,
                            DPM.class=NULL, DPM.mu1=NULL, DPM.mu2=NULL,
                            DPM.mu3=NULL, DPM.mu=NULL, DPM.zeta1=NULL,
                            DPM.zeta2=NULL, DPM.zeta3=NULL, DPM.zeta=NULL,
                            DPM.tau=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initiate.startValues_AFT_+3A_formula">Formula</code></td>
<td>

<p>For <code>BayesID_AFT</code>, it is a data.frame containing semi-competing risks outcomes from <code>n</code> subjects. See <code>BayesID_AFT</code>.
For <code>BayesSurv_AFT</code>, it is a data.frame containing univariate time-to-event outcomes from <code>n</code> subjects. See <code>BayesSurv_AFT</code>.
For <code>BayesID_AFT</code>, it is a list containing three formula objects that correspond to the transition <code class="reqn">g</code>=1,2,3.
For <code>BayesSurv_AFT</code>, it is a formula object that corresponds to <code class="reqn">log(t)</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the formula(s) in <code>lin.pred</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_model">model</code></td>
<td>

<p>a character vector that specifies the type of components in a model. Check <code><a href="#topic+BayesID_AFT">BayesID_AFT</a></code> and <code><a href="#topic+BayesSurv_AFT">BayesSurv_AFT</a></code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_nchain">nChain</code></td>
<td>

<p>The number of chains.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_beta1">beta1</code></td>
<td>

<p>starting values of <code class="reqn">\beta_1</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_beta2">beta2</code></td>
<td>

<p>starting values of <code class="reqn">\beta_2</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_beta3">beta3</code></td>
<td>

<p>starting values of <code class="reqn">\beta_3</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_beta">beta</code></td>
<td>

<p>starting values of <code class="reqn">\beta</code> for <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_gamma">gamma</code></td>
<td>

<p>starting values of <code class="reqn">\gamma</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_theta">theta</code></td>
<td>

<p>starting values of <code class="reqn">\theta</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_y1">y1</code></td>
<td>

<p>starting values of <code class="reqn">log(t_1)</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_y2">y2</code></td>
<td>

<p>starting values of <code class="reqn">log(t_2)</code> for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_y">y</code></td>
<td>

<p>starting values of <code class="reqn">log(t)</code> for <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_ln.mu">LN.mu</code></td>
<td>

<p>starting values of <code class="reqn">\beta_0</code> in logNormal models for <code>BayesID_AFT</code> and <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_ln.sigsq">LN.sigSq</code></td>
<td>

<p>starting values of <code class="reqn">\sigma^2</code> in logNormal models for <code>BayesID_AFT</code> and <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.class1">DPM.class1</code></td>
<td>

<p>starting values of the class membership for transition 1 in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.class2">DPM.class2</code></td>
<td>

<p>starting values of the class membership for transition 2 in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.class3">DPM.class3</code></td>
<td>

<p>starting values of the class membership for transition 3 in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.class">DPM.class</code></td>
<td>

<p>starting values of the class membership in DPM models for <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.mu1">DPM.mu1</code></td>
<td>

<p>starting values of <code class="reqn">\mu_1</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.mu2">DPM.mu2</code></td>
<td>

<p>starting values of <code class="reqn">\mu_2</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.mu3">DPM.mu3</code></td>
<td>

<p>starting values of <code class="reqn">\mu_3</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.mu">DPM.mu</code></td>
<td>

<p>starting values of <code class="reqn">\mu</code> in DPM models for <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.zeta1">DPM.zeta1</code></td>
<td>

<p>starting values of <code class="reqn">\zeta_{1}</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.zeta2">DPM.zeta2</code></td>
<td>

<p>starting values of <code class="reqn">\zeta_{2}</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.zeta3">DPM.zeta3</code></td>
<td>

<p>starting values of <code class="reqn">\zeta_{3}</code> in DPM models for <code>BayesID_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.zeta">DPM.zeta</code></td>
<td>

<p>starting values of <code class="reqn">\zeta</code> in DPM models for <code>BayesSurv_AFT</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_AFT_+3A_dpm.tau">DPM.tau</code></td>
<td>

<p>starting values of <code class="reqn">\tau</code> in DPM models for <code>BayesID_AFT</code> and <code>BayesSurv_AFT</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>initiate.startValues_AFT</code> returns a list containing starting values for a sigle chain that can be used for <code>BayesID_AFT</code> and <code>BayesSurv_AFT</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastien Haneuse and Kyu Ha Lee<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Rondeau, V., and Haneuse, S. (2017),
Accelerated failure time models for semicompeting risks data in the presence of complex censoring, <em>Biometrics</em>, 73, 4, 1401-1412. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesID_AFT">BayesID_AFT</a></code>, <code><a href="#topic+BayesSurv_AFT">BayesSurv_AFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in \code{\link{BayesID_AFT}} and \code{\link{BayesSurv_AFT}}.
</code></pre>

<hr>
<h2 id='initiate.startValues_HReg'>
The function that initiates starting values for a single chain.
</h2><span id='topic+initiate.startValues_HReg'></span>

<h3>Description</h3>

<p>The function initiates starting values for a single chain for hazard regression (HReg) models. Users are allowed to set some non-null values to starting values for a set of parameters. The function will automatically generate starting values for any parameters whose values are not specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initiate.startValues_HReg(Formula, data, model, id = NULL, nChain=1,
                   beta1 = NULL, beta2 = NULL, beta3 = NULL, beta = NULL,
                   gamma.ji = NULL, theta = NULL,
                   V.j1 = NULL, V.j2 = NULL, V.j3 = NULL, V.j = NULL,
                   WB.alpha = NULL, WB.kappa = NULL, 
                   PEM.lambda1=NULL, PEM.lambda2=NULL, PEM.lambda3=NULL, PEM.lambda=NULL,
                   PEM.s1=NULL, PEM.s2=NULL, PEM.s3=NULL, PEM.s=NULL,
                   PEM.mu_lam=NULL, PEM.sigSq_lam=NULL,
                   MVN.SigmaV = NULL, Normal.zeta = NULL, 
                   DPM.class = NULL, DPM.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initiate.startValues_HReg_+3A_formula">Formula</code></td>
<td>

<p>For <code>BayesID_HReg</code>, it is a data.frame containing semi-competing risks outcomes from <code>n</code> subjects.
For <code>BayesSurv_HReg</code>, it is a data.frame containing univariate time-to-event outcomes from <code>n</code> subjects. For <code>BayesID_HReg</code>, it is a list containing three formula objects that correspond to <code class="reqn">h_g()</code>, <code class="reqn">g</code>=1,2,3.
For <code>BayesSurv_HReg</code>, it is a formula object that corresponds to <code class="reqn">h()</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the formula(s) in <code>lin.pred</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_model">model</code></td>
<td>

<p>a character vector that specifies the type of components in a model. Check <code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code> and <code><a href="#topic+BayesSurv_HReg">BayesSurv_HReg</a></code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_id">id</code></td>
<td>

<p>a vector of cluster information for <code>n</code> subjects. The cluster membership must be set to consecutive positive integers, <code class="reqn">1:J</code>.  
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_nchain">nChain</code></td>
<td>

<p>The number of chains.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_beta1">beta1</code></td>
<td>

<p>starting values of <code class="reqn">\beta_1</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_beta2">beta2</code></td>
<td>

<p>starting values of <code class="reqn">\beta_2</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_beta3">beta3</code></td>
<td>

<p>starting values of <code class="reqn">\beta_3</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_beta">beta</code></td>
<td>

<p>starting values of <code class="reqn">\beta</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_gamma.ji">gamma.ji</code></td>
<td>

<p>starting values of <code class="reqn">\gamma</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_theta">theta</code></td>
<td>

<p>starting values of <code class="reqn">\theta</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_v.j1">V.j1</code></td>
<td>

<p>starting values of <code class="reqn">V_{j1}</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_v.j2">V.j2</code></td>
<td>

<p>starting values of <code class="reqn">V_{j2}</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_v.j3">V.j3</code></td>
<td>

<p>starting values of <code class="reqn">V_{j3}</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_v.j">V.j</code></td>
<td>

<p>starting values of <code class="reqn">V_{j}</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_wb.alpha">WB.alpha</code></td>
<td>

<p>starting values of the Weibull parameters, <code class="reqn">\alpha_g</code> for <code>BayesID_HReg</code>.
starting values of the Weibull parameter, <code class="reqn">\alpha</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_wb.kappa">WB.kappa</code></td>
<td>

<p>starting values of the Weibull parameters, <code class="reqn">\kappa_g</code> for <code>BayesID_HReg</code>.
starting values of the Weibull parameter, <code class="reqn">\kappa</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.lambda1">PEM.lambda1</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">\lambda_1</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.lambda2">PEM.lambda2</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">\lambda_2</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.lambda3">PEM.lambda3</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">\lambda_3</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.lambda">PEM.lambda</code></td>
<td>

<p>starting values of <code class="reqn">\lambda</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.s1">PEM.s1</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">s_1</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.s2">PEM.s2</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">s_2</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.s3">PEM.s3</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">s_3</code> for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.s">PEM.s</code></td>
<td>

<p>starting values of <code class="reqn">s</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.mu_lam">PEM.mu_lam</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">\mu_{\lambda,g}</code> for <code>BayesID_HReg</code>.
starting values of the PEM parameter, <code class="reqn">\mu_{\lambda}</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_pem.sigsq_lam">PEM.sigSq_lam</code></td>
<td>

<p>starting values of the PEM parameters, <code class="reqn">\sigma_{\lambda,g}^2</code> for <code>BayesID_HReg</code>.
starting values of the PEM parameter, <code class="reqn">\sigma_{\lambda}^2</code> for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_mvn.sigmav">MVN.SigmaV</code></td>
<td>

<p>starting values of <code class="reqn">\Sigma_V</code> in DPM models for <code>BayesID_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_normal.zeta">Normal.zeta</code></td>
<td>

<p>starting values of <code class="reqn">\zeta</code> in DPM models for <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_dpm.class">DPM.class</code></td>
<td>

<p>starting values of the class membership in DPM models for <code>BayesID_HReg</code> and <code>BayesSurv_HReg</code>.
</p>
</td></tr>
<tr><td><code id="initiate.startValues_HReg_+3A_dpm.tau">DPM.tau</code></td>
<td>

<p>starting values of <code class="reqn">\tau</code> in DPM models for <code>BayesID_HReg</code> and <code>BayesSurv_HReg</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>initiate.startValues_HReg</code> returns a list containing starting values for a sigle chain that can be used for <code>BayesID_HReg</code> and <code>BayesSurv_HReg</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastien Haneuse and Kyu Ha Lee<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Lee, K. H., Dominici, F., Schrag, D., and Haneuse, S. (2016),
Hierarchical models for semicompeting risks data with application to quality of end-of-life care for pancreatic cancer, <em>Journal of the American Statistical Association</em>, 111, 515, 1075-1095. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code>, <code><a href="#topic+BayesSurv_HReg">BayesSurv_HReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in \code{\link{BayesID_HReg}} and \code{\link{BayesSurv_HReg}}.
</code></pre>

<hr>
<h2 id='methods'>
Methods for objects of classes, <code>Bayes_HReg</code>/<code>Bayes_AFT</code>/<code>Freq_HReg</code>.
</h2><span id='topic+print.Bayes_HReg'></span><span id='topic+print.Bayes_AFT'></span><span id='topic+print.summ.Bayes_HReg'></span><span id='topic+print.summ.Bayes_AFT'></span><span id='topic+print.Freq_HReg'></span><span id='topic+print.summ.Freq_HReg'></span><span id='topic+summary.Bayes_HReg'></span><span id='topic+summary.Bayes_AFT'></span><span id='topic+summary.Freq_HReg'></span><span id='topic+coef.Bayes_HReg'></span><span id='topic+coef.Bayes_AFT'></span><span id='topic+coef.Freq_HReg'></span><span id='topic+predict.Bayes_HReg'></span><span id='topic+plot.pred.Bayes_HReg'></span><span id='topic+predict.Bayes_AFT'></span><span id='topic+plot.pred.Bayes_AFT'></span><span id='topic+predict.Freq_HReg'></span><span id='topic+plot.pred.Freq_HReg'></span><span id='topic+vcov.Freq_HReg'></span>

<h3>Description</h3>

<p>The <code>Bayes_HReg</code> class represents results from Bayesian analysis of semi-competing risks or univariate time-to-event data in the context of hazard regression models.<br />
The <code>Bayes_AFT</code> class represents results from Bayesian analysis of semi-competing risks or univariate time-to-event data in the context of AFT models.<br />
The <code>Freq_HReg</code> class represents results from Frequentist analysis of semi-competing risks or univariate time-to-event data in the context of hazard regression models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bayes_HReg'
print(x, digits=3, alpha=0.05, ...)
## S3 method for class 'Bayes_AFT'
print(x, digits=3, alpha=0.05, ...)
## S3 method for class 'summ.Bayes_HReg'
print(x, digits=3, ...)
## S3 method for class 'summ.Bayes_AFT'
print(x, digits=3, ...)
## S3 method for class 'Freq_HReg'
print(x, digits=3, alpha=0.05, ...)
## S3 method for class 'summ.Freq_HReg'
print(x, digits=3, ...)
## S3 method for class 'Bayes_HReg'
summary(object, digits=3, alpha=0.05, ...)
## S3 method for class 'Bayes_AFT'
summary(object, digits=3, alpha=0.05, ...)
## S3 method for class 'Freq_HReg'
summary(object, digits=3, alpha=0.05, ...)
## S3 method for class 'Bayes_HReg'
coef(object, alpha=0.05, ...)
## S3 method for class 'Bayes_AFT'
coef(object, alpha=0.05, ...)
## S3 method for class 'Freq_HReg'
coef(object, alpha=0.05, ...)
## S3 method for class 'Bayes_HReg'
predict(object, xnew=NULL, x1new=NULL, x2new=NULL,
x3new=NULL, tseq=c(0, 5, 10), alpha=0.05, ...)
## S3 method for class 'pred.Bayes_HReg'
plot(x, plot.est="Haz", xlab=NULL, ylab=NULL, ...)
## S3 method for class 'Bayes_AFT'
predict(object, xnew=NULL, x1new=NULL, x2new=NULL,
x3new=NULL, time, tseq=c(0, 5, 10), alpha=0.05, ...)
## S3 method for class 'pred.Bayes_AFT'
plot(x, plot.est="Haz", xlab=NULL, ylab=NULL, ...)
## S3 method for class 'Freq_HReg'
predict(object, xnew=NULL, x1new=NULL, x2new=NULL,
x3new=NULL, tseq=c(0, 5, 10), alpha=0.05, ...)
## S3 method for class 'pred.Freq_HReg'
plot(x, plot.est="Haz", xlab=NULL, ylab=NULL, ...)
## S3 method for class 'Freq_HReg'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods_+3A_x">x</code></td>
<td>

<p>an object of class <code>Bayes_HReg</code> or <code>Bayes_AFT</code> or <code>Freq_HReg</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_digits">digits</code></td>
<td>

<p>a numeric value indicating the number of digits to display.
</p>
</td></tr>
<tr><td><code id="methods_+3A_object">object</code></td>
<td>

<p>an object of class <code>Bayes_HReg</code> or <code>Bayes_AFT</code> or<code>Freq_HReg</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_time">time</code></td>
<td>

<p>the points at which the baseline survival/hazard functions are evaluated.
</p>
</td></tr>
<tr><td><code id="methods_+3A_tseq">tseq</code></td>
<td>

<p>the points at which tick-marks are to be drawn. 
Required only if the object <code>x</code> is returned by parametric Weibull-HReg/log-Normal-AFT/DPM-AFT models.
</p>
</td></tr>
<tr><td><code id="methods_+3A_plot.est">plot.est</code></td>
<td>

<p>used only if <code>plot</code> is <code>TRUE</code>. 
If <code>Surv</code> (the default) then estimated survival functions are produced.
If <code>Haz</code> then estimated hazard functions are produced.
</p>
</td></tr>
<tr><td><code id="methods_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis.
</p>
</td></tr>
<tr><td><code id="methods_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis.
</p>
</td></tr>
<tr><td><code id="methods_+3A_xnew">xnew</code></td>
<td>

<p>a vector of covariate values with which to predict for which to predict for <code class="reqn">h</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_x1new">x1new</code></td>
<td>

<p>a vector of covariate values with which to predict for which to predict for <code class="reqn">h_1</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_x2new">x2new</code></td>
<td>

<p>a vector of covariate values with which to predict for which to predict for <code class="reqn">h_2</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_x3new">x3new</code></td>
<td>

<p>a vector of covariate values with which to predict for which to predict for <code class="reqn">h_3</code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_alpha">alpha</code></td>
<td>

<p>confidence/credibility level of the interval.
</p>
</td></tr>
<tr><td><code id="methods_+3A_...">...</code></td>
<td>

<p>additional arguments.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code>, <code><a href="#topic+BayesID_AFT">BayesID_AFT</a></code>, <code><a href="#topic+BayesSurv_HReg">BayesSurv_HReg</a></code>, <code><a href="#topic+BayesSurv_AFT">BayesSurv_AFT</a></code>, <code><a href="#topic+FreqID_HReg">FreqID_HReg</a></code>, <code><a href="#topic+FreqSurv_HReg">FreqSurv_HReg</a></code>.
</p>

<hr>
<h2 id='old.functions'>
Old functions
</h2><span id='topic+BayesID'></span><span id='topic+BayesSurv'></span><span id='topic+FreqID'></span><span id='topic+FreqSurv'></span><span id='topic+initiate.startValues'></span>

<h3>Description</h3>

<p>Since version 2.5, the functions BayesID(), BayesSurv(), FreqID(), FreqSurv(), initiate.startValues() have been renamed as BayesID_HReg(), BayesSurv_HReg(), FreqID_HReg(), FreqSurv_HReg(), initiate.startValues_HReg(), respectively. If one of the old functions is called, a warning message will be displayed with the corresponding new function name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesID(...)
BayesSurv(...)
FreqID(...)
FreqSurv(...)
initiate.startValues(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="old.functions_+3A_...">...</code></td>
<td>

<p>arguments used for the old functions.
</p>
</td></tr>
</table>

<hr>
<h2 id='PPD'>
Function to predict the joint probability involving two event times in Bayesian illness-death models
</h2><span id='topic+PPD'></span>

<h3>Description</h3>

<p><code>PPD</code> is a function to predict the joint probability involving two event times in Bayesian illness-death models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPD(fit, x1, x2, x3, t1, t2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPD_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>Bayes_HReg</code>. Currently, the function is available for PEM illness-death models.
</p>
</td></tr>
<tr><td><code id="PPD_+3A_x1">x1</code></td>
<td>

<p>a vector of covariates for <code class="reqn">h_1</code> with which to predict.
</p>
</td></tr>
<tr><td><code id="PPD_+3A_x2">x2</code></td>
<td>

<p>a vector of covariates for <code class="reqn">h_2</code> with which to predict.
</p>
</td></tr>
<tr><td><code id="PPD_+3A_x3">x3</code></td>
<td>

<p>a vector of covariates for <code class="reqn">h_3</code> with which to predict.
</p>
</td></tr>
<tr><td><code id="PPD_+3A_t1">t1</code></td>
<td>

<p>time to non-terminal event for which the joint probability is calculated.
</p>
</td></tr>
<tr><td><code id="PPD_+3A_t2">t2</code></td>
<td>

<p>time to terminal event for which the joint probability is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the posterior predictive density, given (<code class="reqn">x_1</code>, <code class="reqn">x_2</code>, <code class="reqn">x_3</code>), one can predict any joint probability involving the two event times such as <code class="reqn">P(T_1&lt;t_1, T_2&lt;t_2| x_1, x_2, x_3)</code> for <code class="reqn">0&lt;t_1\le t_2</code> and <code class="reqn">P(T_1=\infty, T_2&lt;t_2| x_1, x_2, x_3)</code> for <code class="reqn">t_2&gt;0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>F_u</code></td>
<td>
<p>Predicted <code class="reqn">P(T_1\le t_1, T_2\le t_2| x_1, x_2, x_3)</code> in the upper wedge of the support of <code class="reqn">(T_1, T_2)</code>.</p>
</td></tr>
<tr><td><code>F_l</code></td>
<td>
<p>Predicted <code class="reqn">P(T_1=\infty, T_2\le t_2| x_1, x_2, x_3)</code> in the lower wedge of the support of <code class="reqn">(t1, t2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse<br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesID_HReg">BayesID_HReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:    
# loading a data set
data(scrData)
id=scrData$cluster

form &lt;- Formula(time1 + event1 | time2 + event2 ~ x1 + x2 | x1 + x2 | x1 + x2)

#####################
## Hyperparameters ##
#####################

## Subject-specific frailty variance component
##  - prior parameters for 1/theta
##
theta.ab &lt;- c(0.7, 0.7)

## PEM baseline hazard function
##
PEM.ab1 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_1^2
PEM.ab2 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_2^2
PEM.ab3 &lt;- c(0.7, 0.7) # prior parameters for 1/sigma_3^2
##
PEM.alpha1 &lt;- 10 # prior parameters for K1
PEM.alpha2 &lt;- 10 # prior parameters for K2
PEM.alpha3 &lt;- 10 # prior parameters for K3

##
hyperParams &lt;- list(theta=theta.ab,
                   PEM=list(PEM.ab1=PEM.ab1, PEM.ab2=PEM.ab2, PEM.ab3=PEM.ab3,
                    PEM.alpha1=PEM.alpha1, PEM.alpha2=PEM.alpha2,
                    PEM.alpha3=PEM.alpha3))
                    
###################
## MCMC SETTINGS ##
###################

## Setting for the overall run
##
numReps    &lt;- 2000
thin       &lt;- 10
burninPerc &lt;- 0.5

## Settings for storage
##
nGam_save &lt;- 0

## Tuning parameters for specific updates
##
##  - those common to all models
mhProp_theta_var  &lt;- 0.05
##
## - those specific to the Weibull specification of the baseline hazard functions
mhProp_alphag_var &lt;- c(0.01, 0.01, 0.01)
##
## - those specific to the PEM specification of the baseline hazard functions
Cg        &lt;- c(0.2, 0.2, 0.2)
delPertg  &lt;- c(0.5, 0.5, 0.5)
rj.scheme &lt;- 1
Kg_max    &lt;- c(50, 50, 50)
sg_max    &lt;- c(max(scrData$time1[scrData$event1 == 1]),
               max(scrData$time2[scrData$event1 == 0 &amp; scrData$event2 == 1]),
               max(scrData$time2[scrData$event1 == 1 &amp; scrData$event2 == 1]))

time_lambda1 &lt;- seq(1, sg_max[1], 1)
time_lambda2 &lt;- seq(1, sg_max[2], 1)
time_lambda3 &lt;- seq(1, sg_max[3], 1)               

##
mcmc.PEM &lt;- list(run=list(numReps=numReps, thin=thin, burninPerc=burninPerc),
                storage=list(nGam_save=nGam_save),
                tuning=list(mhProp_theta_var=mhProp_theta_var,
                Cg=Cg, delPertg=delPertg,
                rj.scheme=rj.scheme, Kg_max=Kg_max,
                time_lambda1=time_lambda1, time_lambda2=time_lambda2,
                time_lambda3=time_lambda3))
    
##						
myModel &lt;- c("semi-Markov", "PEM")
myPath  &lt;- "Output/02-Results-PEM/"

startValues      &lt;- initiate.startValues_HReg(form, scrData, model=myModel, nChain=2)

##
fit_PEM &lt;- BayesID_HReg(form, scrData, id=NULL, model=myModel,
                 hyperParams, startValues, mcmc.PEM, path=myPath)
				
PPD(fit_PEM, x1=c(1,1), x2=c(1,1), x3=c(1,1), t1=3, t2=6)
		

## End(Not run)
</code></pre>

<hr>
<h2 id='scrData'>
A simulated clustered semi-competing risks data set
</h2><span id='topic+scrData'></span>

<h3>Description</h3>

<p>Simulated semi-competing risks data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scrData)</code></pre>


<h3>Format</h3>

<p>a data frame with 2000 observations on the following 14 variables.
</p>

<dl>
<dt><code>time1</code></dt><dd><p>the time to non-terminal event</p>
</dd>
<dt><code>event1</code></dt><dd><p>the censoring indicators for the non-terminal event time; 1=event observed, 0=censored/truncated</p>
</dd>
<dt><code>time2</code></dt><dd><p>the time to terminal event</p>
</dd>
<dt><code>event2</code></dt><dd><p>the censoring indicators for the terminal event time; 1=event observed, 0=censored</p>
</dd>
<dt><code>cluster</code></dt><dd><p>cluster numbers</p>
</dd>
<dt><code>x1</code></dt><dd><p>a vector of continuous covarate</p>
</dd>
<dt><code>x2</code></dt><dd><p>a vector of continuous covarate</p>
</dd>
<dt><code>x3</code></dt><dd><p>a vector of continuous covarate</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(scrData)
</code></pre>

<hr>
<h2 id='SemiCompRisks-package'>
Algorithms for fitting parametric and semi-parametric models to semi-competing risks data / univariate survival data.
</h2><span id='topic+SemiCompRisks-package'></span><span id='topic+SemiCompRisks'></span>

<h3>Description</h3>

<p>The package provides functions to perform the analysis of semi-competing risks or univariate survival data with either hazard regression (HReg) models or accelerated failure time (AFT) models. The framework is flexible in the sense that:<br />
1) it can handle cluster-correlated or independent data; <br />
2) the option to choose between parametric (Weibull) and semi-parametric (mixture of piecewise exponential) specification for baseline hazard function(s) is available;  <br />
3) for clustered data, the option to choose between parametric (multivariate Normal for semicompeting risks data, Normal for univariate survival data) and semi-parametric (Dirichlet process mixture) specification for random effects distribution is available;  <br />
4) for semi-competing risks data, the option to choose between Makov and semi-Makov model is available.  <br />
</p>


<h3>Details</h3>

<p>The package includes following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>BayesID_HReg</code> </td><td style="text-align: left;"> Bayesian analysis of semi-competing risks data using HReg models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BayesID_AFT</code> </td><td style="text-align: left;"> Bayesian analysis of semi-competing risks data using AFT models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BayesSurv_HReg</code> </td><td style="text-align: left;"> Bayesian analysis of univariate survival data using HReg models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BayesSurv_AFT</code> </td><td style="text-align: left;"> Bayesian analysis of univariate survival data using AFT models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>FreqID_HReg</code> </td><td style="text-align: left;"> Frequentist analysis of semi-competing risks data using HReg models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>FreqSurv_HReg</code> </td><td style="text-align: left;"> Frequentist analysis of univariate survival data using HReg models</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>initiate.startValues_HReg</code> </td><td style="text-align: left;"> Initiating starting values for Bayesian estimations with HReg models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>initiate.startValues_AFT</code> </td><td style="text-align: left;"> Initiating starting values for Bayesian estimations with AFT models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>simID</code> </td><td style="text-align: left;"> Simulating semi-competing risks data under Weibull/Weibull-MVN model </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>simSurv</code> </td><td style="text-align: left;"> Simulating survival data under Weibull/Weibull-Normal model </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SemiCompRisks</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-2-2</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kyu Ha Lee, Catherine Lee, Danilo Alvares, and Sebastien Haneuse <br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lee, K. H., Haneuse, S., Schrag, D., and Dominici, F. (2015), 
Bayesian semiparametric analysis of semicompeting risks data: 
investigating hospital readmission after a pancreatic cancer diagnosis, <em>Journal of the Royal Statistical Society: Series C</em>, 64, 2, 253-273.<br /> <br />
Lee, K. H., Dominici, F., Schrag, D., and Haneuse, S. (2016),
Hierarchical models for semicompeting risks data with application to quality of end-of-life care for pancreatic cancer, <em>Journal of the American Statistical Association</em>, 111, 515, 1075-1095. <br /> <br />
Lee, K. H., Rondeau, V., and Haneuse, S. (2017),
Accelerated failure time models for semicompeting risks data in the presence of complex censoring, <em>Biometrics</em>, 73, 4, 1401-1412. <br /> <br />
Alvares, D., Haneuse, S., Lee, C., Lee, K. H. (2019),
SemiCompRisks: An R package for the analysis of independent and cluster-correlated semi-competing risks data, <em>The R Journal</em>, 11, 1, 376-400. <br />
</p>

<hr>
<h2 id='simID'>
The function that simulates independent/cluster-correlated semi-competing risks data under semi-Markov Weibull/Weibull-MVN models.
</h2><span id='topic+simID'></span>

<h3>Description</h3>

<p>The function to simulate independent/cluster-correlated semi-competing risks data under semi-Markov Weibull/Weibull-MVN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simID(id=NULL, x1, x2, x3, beta1.true, beta2.true, beta3.true,
			alpha1.true, alpha2.true, alpha3.true, 
			kappa1.true, kappa2.true, kappa3.true, 
			theta.true, SigmaV.true=NULL, cens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simID_+3A_id">id</code></td>
<td>

<p>a vector of cluster information for <code>n</code> subjects. The cluster membership must be set to consecutive positive integers, <code class="reqn">1:J</code>. 
Required only when generating clustered data.
</p>
</td></tr>
<tr><td><code id="simID_+3A_x1">x1</code></td>
<td>

<p>covariate matrix, <code>n</code> observations by <code>p1</code> variables.
</p>
</td></tr>
<tr><td><code id="simID_+3A_x2">x2</code></td>
<td>

<p>covariate matrix, <code>n</code> observations by <code>p2</code> variables.
</p>
</td></tr>
<tr><td><code id="simID_+3A_x3">x3</code></td>
<td>

<p>covariate matrix, <code>n</code> observations by <code>p3</code> variables.
</p>
</td></tr>
<tr><td><code id="simID_+3A_beta1.true">beta1.true</code></td>
<td>

<p>true value for <code class="reqn">\beta_1</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_beta2.true">beta2.true</code></td>
<td>

<p>true value for <code class="reqn">\beta_2</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_beta3.true">beta3.true</code></td>
<td>

<p>true value for <code class="reqn">\beta_3</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_alpha1.true">alpha1.true</code></td>
<td>

<p>true value for <code class="reqn">\alpha_1</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_alpha2.true">alpha2.true</code></td>
<td>

<p>true value for <code class="reqn">\alpha_2</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_alpha3.true">alpha3.true</code></td>
<td>

<p>true value for <code class="reqn">\alpha_3</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_kappa1.true">kappa1.true</code></td>
<td>

<p>true value for <code class="reqn">\kappa_1</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_kappa2.true">kappa2.true</code></td>
<td>

<p>true value for <code class="reqn">\kappa_2</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_kappa3.true">kappa3.true</code></td>
<td>

<p>true value for <code class="reqn">\kappa_3</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_theta.true">theta.true</code></td>
<td>

<p>true value for <code class="reqn">\theta</code>.
</p>
</td></tr>
<tr><td><code id="simID_+3A_sigmav.true">SigmaV.true</code></td>
<td>

<p>true value for <code class="reqn">\Sigma_V</code>. Required only when generating clustered data.
</p>
</td></tr>
<tr><td><code id="simID_+3A_cens">cens</code></td>
<td>

<p>a vector with two numeric elements. The right censoring times are generated from Uniform(<code class="reqn">cens[1]</code>, <code class="reqn">cens[2]</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simIDcor</code> returns a data.frame containing semi-competing risks outcomes from <code>n</code> subjects. 
It is of dimension <code class="reqn">n\times 4</code>: the columns correspond to <code class="reqn">y_1</code>, <code class="reqn">\delta_1</code>, <code class="reqn">y_2</code>, <code class="reqn">\delta_2</code>. <br />
</p>
<table>
<tr><td><code>y1</code></td>
<td>
<p>a vector of <code>n</code> times to the non-terminal event</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>a vector of <code>n</code> times to the terminal event</p>
</td></tr>
<tr><td><code>delta1</code></td>
<td>
<p>a vector of <code>n</code> censoring indicators for the non-terminal event time (1=event occurred, 0=censored)</p>
</td></tr>
<tr><td><code>delta2</code></td>
<td>
<p>a vector of <code>n</code> censoring indicators for the terminal event time (1=event occurred, 0=censored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse <br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	library(MASS)
	set.seed(123456)
	
	J = 110
	nj = 50
	n = J * nj

	id &lt;- rep(1:J, each = nj)

	kappa1.true &lt;- 0.05
	kappa2.true &lt;- 0.01
	kappa3.true &lt;- 0.01
	alpha1.true &lt;- 0.8
	alpha2.true &lt;- 1.1
	alpha3.true &lt;- 0.9
	beta1.true &lt;- c(0.5, 0.8, -0.5)
	beta2.true &lt;- c(0.5, 0.8, -0.5)
	beta3.true &lt;- c(1, 1, -1)
	SigmaV.true &lt;- matrix(0.25,3,3)
	theta.true &lt;- 0.5
	cens &lt;- c(90, 90)

	cov1 &lt;- matrix(rnorm((length(beta1.true)-1)*n, 0, 1), n, length(beta1.true)-1)
	cov2 &lt;- sample(c(0, 1), n, replace = TRUE)
	x1 &lt;- as.data.frame(cbind(cov1, cov2))
	x2 &lt;- as.data.frame(cbind(cov1, cov2))
	x3 &lt;- as.data.frame(cbind(cov1, cov2))
	
	simData &lt;- simID(id, x1, x2, x3, beta1.true, beta2.true, beta3.true, 
				alpha1.true, alpha2.true, alpha3.true, 
				kappa1.true, kappa2.true, kappa3.true, 
				theta.true, SigmaV.true, cens)	
   				    				
</code></pre>

<hr>
<h2 id='simSurv'>
The function that simulates independent/cluster-correlated right-censored survival data under Weibull/Weibull-Normal model.
</h2><span id='topic+simSurv'></span>

<h3>Description</h3>

<p>The function to simulate independent/cluster-correlated right-censored survival data under Weibull/Weibull-Normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSurv(id=NULL, x, beta.true, alpha.true, kappa.true, sigmaV.true=NULL, cens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSurv_+3A_id">id</code></td>
<td>

<p>a vector of cluster information for <code>n</code> subjects. The cluster membership must be set to consecutive positive integers, <code class="reqn">1:J</code>. 
Required only when generating clustered data.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_x">x</code></td>
<td>

<p>covariate matrix, <code>n</code> observations by <code>p</code> variables.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_beta.true">beta.true</code></td>
<td>

<p>true value for <code class="reqn">\beta</code>.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_alpha.true">alpha.true</code></td>
<td>

<p>true value for <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_kappa.true">kappa.true</code></td>
<td>

<p>true value for <code class="reqn">\kappa</code>.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_sigmav.true">sigmaV.true</code></td>
<td>

<p>true value for <code class="reqn">\sigma_V</code>. 
Required only when generating clustered data.
</p>
</td></tr>
<tr><td><code id="simSurv_+3A_cens">cens</code></td>
<td>

<p>a vector with two numeric elements. The right censoring times are generated from Uniform(<code class="reqn">cens[1]</code>, <code class="reqn">cens[2]</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simSurv</code> returns a data.frame containing univariate time-to-event outcomes from <code>n</code> subjects. 
It is of dimension <code class="reqn">n\times 2</code>: the columns correspond to <code class="reqn">y</code>, <code class="reqn">\delta</code>.<br />
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>a vector of <code>n</code> times to the event</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>a vector of <code>n</code> censoring indicators for the event time (1=event occurred, 0=censored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyu Ha Lee and Sebastien Haneuse <br />
Maintainer: Kyu Ha Lee &lt;klee15239@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	set.seed(123456)
	
	J = 110
	nj = 50
	n = J * nj

	id &lt;- rep(1:J, each = nj)

	x	= matrix(0, n, 2)	
	x[,1]	= rnorm(n, 0, 2)	
	x[,2]	= sample(c(0, 1), n, replace = TRUE)

	beta.true = c(0.5, 0.5)
	
	alpha.true = 1.5		
	kappa.true = 0.02
	sigmaV.true = 0.1

	cens &lt;- c(30, 40)		

	simData &lt;- simSurv(id, x, beta.true, alpha.true, kappa.true, 
				sigmaV.true, cens) 		 
</code></pre>

<hr>
<h2 id='survData'>
A simulated clustered univariate survival data.
</h2><span id='topic+survData'></span>

<h3>Description</h3>

<p>Simulated univariate survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survData)</code></pre>


<h3>Format</h3>

<p>a data frame with 2000 observations on the following 4 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>the time to event</p>
</dd>
<dt><code>event</code></dt><dd><p>the censoring indicators for the event time; 1=event observed, 0=censored</p>
</dd>
<dt><code>cluster</code></dt><dd><p>cluster numbers</p>
</dd>    
<dt><code>cov1</code></dt><dd><p>the first column of covariate matrix x</p>
</dd>
<dt><code>cov2</code></dt><dd><p>the second column of covariate matrix x</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(scrData)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
