<!DOCTYPE html><html><head><title>Help for package mlr3db</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3db}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlr3db-package'><p>mlr3db: Data Base Backend for 'mlr3'</p></a></li>
<li><a href='#as_duckdb_backend'><p>Convert to DuckDB Backend</p></a></li>
<li><a href='#as_sqlite_backend'><p>Convert to SQLite Backend</p></a></li>
<li><a href='#DataBackendDplyr'><p>DataBackend for dplyr/dbplyr</p></a></li>
<li><a href='#DataBackendDuckDB'><p>DataBackend for DuckDB</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Data Base Backend for 'mlr3'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends the 'mlr3' package with a backend to
    transparently work with databases such as 'SQLite', 'DuckDB', 'MySQL',
    'MariaDB', or 'PostgreSQL'. The package provides two additional backends:
    'DataBackendDplyr' relies on the abstraction of package 'dbplyr' to
    interact with most DBMS. 'DataBackendDuckDB' operates on 'DuckDB' data bases
    and also on Apache Parquet files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https:///mlr3db.mlr-org.com">https:///mlr3db.mlr-org.com</a>, <a href="https://github.com/mlr-org/mlr3db">https://github.com/mlr-org/mlr3db</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3db/issues">https://github.com/mlr-org/mlr3db/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3 (&ge; 0.13.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6 (&ge; 2.4.0), backports, checkmate, data.table, mlr3misc (&ge;
0.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, RSQLite, dbplyr, dplyr, duckdb (&ge; 0.4.0), future,
future.apply, future.callr, lgr, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-04 09:27:31 UTC; michel</td>
</tr>
<tr>
<td>Author:</td>
<td>Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michel Lang &lt;michellang@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-04 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlr3db-package'>mlr3db: Data Base Backend for 'mlr3'</h2><span id='topic+mlr3db'></span><span id='topic+mlr3db-package'></span>

<h3>Description</h3>

<p>Extends the 'mlr3' package with a backend to transparently work with databases such as 'SQLite', 'DuckDB', 'MySQL', 'MariaDB', or 'PostgreSQL'. The package provides two additional backends: 'DataBackendDplyr' relies on the abstraction of package 'dbplyr' to interact with most DBMS. 'DataBackendDuckDB' operates on 'DuckDB' data bases and also on Apache Parquet files.
</p>


<h3>Options</h3>


<ul>
<li> <p><code>mlr3db.sqlite_dir</code>: Default directory to store SQLite databases constructed
with <code><a href="#topic+as_sqlite_backend">as_sqlite_backend()</a></code>..
</p>
</li>
<li> <p><code>mlr3db.sqlite_dir</code>: Default directory to store DuckDB databases constructed
with <code><a href="#topic+as_duckdb_backend">as_duckdb_backend()</a></code>..
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https:///mlr3db.mlr-org.com">https:///mlr3db.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3db">https://github.com/mlr-org/mlr3db</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3db/issues">https://github.com/mlr-org/mlr3db/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_duckdb_backend'>Convert to DuckDB Backend</h2><span id='topic+as_duckdb_backend'></span>

<h3>Description</h3>

<p>Converts to a <a href="#topic+DataBackendDuckDB">DataBackendDuckDB</a> using the <a href="https://CRAN.R-project.org/package=duckdb"><span class="pkg">duckdb</span></a> database, depending on the input type:
</p>

<ul>
<li> <p><code>data.frame</code>: Creates a new <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a> first using <code><a href="mlr3.html#topic+as_data_backend">as_data_backend()</a></code>, then proceeds
with the conversion from <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a> to <a href="#topic+DataBackendDuckDB">DataBackendDuckDB</a>.
</p>
</li>
<li> <p><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>: Creates a new DuckDB data base in the specified path.
The filename is determined by the hash of the <a href="mlr3.html#topic+DataBackend">DataBackend</a>.
If the file already exists, a connection to the existing database is established and the existing
files are reused.
</p>
</li></ul>

<p>The created backend automatically reconnects to the database if the connection was lost, e.g. because
the object was serialized to the filesystem and restored in a different R session.
The only requirement is that the path does not change and that the path is accessible
on all workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_duckdb_backend(data, path = getOption("mlr3db.duckdb_dir", ":temp:"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_duckdb_backend_+3A_data">data</code></td>
<td>
<p>(<code>data.frame()</code> | <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>)<br />
See description.</p>
</td></tr>
<tr><td><code id="as_duckdb_backend_+3A_path">path</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Path for the DuckDB databases.
Either a valid path to a directory which will be created if it not exists, or one of the special strings:
</p>

<ul>
<li> <p><code>":temp:"</code> (default): Temporary directory of the R session is used, see <code><a href="base.html#topic+tempdir">tempdir()</a></code>.
Note that this directory will be removed during the shutdown of the R session.
Also note that this usually does not work for parallelization on remote workers.
Set to a custom path instead or use special string <code>":user:"</code> instead.
</p>
</li>
<li> <p><code>":user:"</code>: User cache directory as returned by <code><a href="tools.html#topic+R_user_dir">R_user_dir()</a></code> is used.
</p>
</li></ul>

<p>The default for this argument can be configured via option <code>"mlr3db.sqlite_dir"</code> or <code>"mlr3db.duckdb_dir"</code>,
respectively. The database files will use the hash of the <a href="mlr3.html#topic+DataBackend">DataBackend</a> as filename with
file extension <code>".duckdb"</code> or <code>".sqlite"</code>.
If the database already exists on the file system, the converters will just established a new read-only
connection.</p>
</td></tr>
<tr><td><code id="as_duckdb_backend_+3A_...">...</code></td>
<td>
<p>(<code>any</code>)<br />
Additional arguments, passed to <a href="#topic+DataBackendDuckDB">DataBackendDuckDB</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+DataBackendDuckDB">DataBackendDuckDB</a> or <a href="mlr3.html#topic+Task">Task</a>.
</p>

<hr>
<h2 id='as_sqlite_backend'>Convert to SQLite Backend</h2><span id='topic+as_sqlite_backend'></span>

<h3>Description</h3>

<p>Converts to a <a href="#topic+DataBackendDplyr">DataBackendDplyr</a> using a <a href="https://CRAN.R-project.org/package=RSQLite"><span class="pkg">RSQLite</span></a> database, depending on the input type:
</p>

<ul>
<li> <p><code>data.frame</code>: Creates a new <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a> first using <code><a href="mlr3.html#topic+as_data_backend">as_data_backend()</a></code>, then proceeds
with the conversion from <a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a> to <a href="#topic+DataBackendDplyr">DataBackendDplyr</a>.
</p>
</li>
<li> <p><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>: Creates a new SQLite data base in the specified path.
The filename is determined by the hash of the <a href="mlr3.html#topic+DataBackend">DataBackend</a>.
If the file already exists, a connection to the existing database is established and the existing
files are reused.
</p>
</li></ul>

<p>The created backend automatically reconnects to the database if the connection was lost, e.g. because
the object was serialized to the filesystem and restored in a different R session.
The only requirement is that the path does not change and that the path is accessible
on all workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sqlite_backend(data, path = getOption("mlr3db.sqlite_dir", ":temp:"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sqlite_backend_+3A_data">data</code></td>
<td>
<p>(<code>data.frame()</code> | <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a><br />
See description.</p>
</td></tr>
<tr><td><code id="as_sqlite_backend_+3A_path">path</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Path for the DuckDB databases.
Either a valid path to a directory which will be created if it not exists, or one of the special strings:
</p>

<ul>
<li> <p><code>":temp:"</code> (default): Temporary directory of the R session is used, see <code><a href="base.html#topic+tempdir">tempdir()</a></code>.
Note that this directory will be removed during the shutdown of the R session.
Also note that this usually does not work for parallelization on remote workers.
Set to a custom path instead or use special string <code>":user:"</code> instead.
</p>
</li>
<li> <p><code>":user:"</code>: User cache directory as returned by <code><a href="tools.html#topic+R_user_dir">R_user_dir()</a></code> is used.
</p>
</li></ul>

<p>The default for this argument can be configured via option <code>"mlr3db.sqlite_dir"</code> or <code>"mlr3db.duckdb_dir"</code>,
respectively. The database files will use the hash of the <a href="mlr3.html#topic+DataBackend">DataBackend</a> as filename with
file extension <code>".duckdb"</code> or <code>".sqlite"</code>.
If the database already exists on the file system, the converters will just established a new read-only
connection.</p>
</td></tr>
<tr><td><code id="as_sqlite_backend_+3A_...">...</code></td>
<td>
<p>(<code>any</code>)<br />
Additional arguments, passed to <a href="#topic+DataBackendDplyr">DataBackendDplyr</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+DataBackendDplyr">DataBackendDplyr</a> or <a href="mlr3.html#topic+Task">Task</a>.
</p>

<hr>
<h2 id='DataBackendDplyr'>DataBackend for dplyr/dbplyr</h2><span id='topic+DataBackendDplyr'></span>

<h3>Description</h3>

<p>A <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> using <code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code> from packages <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a>/<a href="https://CRAN.R-project.org/package=dbplyr"><span class="pkg">dbplyr</span></a>.
This includes <code><a href="tibble.html#topic+tibble">tibbles</a></code> and abstract database connections interfaced by <a href="https://CRAN.R-project.org/package=dbplyr"><span class="pkg">dbplyr</span></a>.
The latter allows <a href="mlr3.html#topic+Task">mlr3::Task</a>s to interface an out-of-memory database.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a></code> -&gt; <code>DataBackendDplyr</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>levels</code></dt><dd><p>(named <code>list()</code>)<br />
List (named with column names) of factor levels as <code>character()</code>.
Used to auto-convert character columns to factor variables.</p>
</dd>
<dt><code>connector</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Function which is called to re-connect in case the connection became invalid.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rownames</code></dt><dd><p>(<code>integer()</code>)<br />
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.</p>
</dd>
<dt><code>colnames</code></dt><dd><p>(<code>character()</code>)<br />
Returns vector of all column names, including the primary key column.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows (observations).</p>
</dd>
<dt><code>ncol</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of columns (variables), including the primary key column.</p>
</dd>
<dt><code>valid</code></dt><dd><p>(<code>logical(1)</code>)<br />
Returns <code>NA</code> if the data does not inherits from <code>"tbl_sql"</code> (i.e., it is not a real SQL data base).
Returns the result of <code><a href="DBI.html#topic+dbIsValid">DBI::dbIsValid()</a></code> otherwise.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendDplyr-new"><code>DataBackendDplyr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDplyr-data"><code>DataBackendDplyr$data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDplyr-head"><code>DataBackendDplyr$head()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDplyr-distinct"><code>DataBackendDplyr$distinct()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDplyr-missings"><code>DataBackendDplyr$missings()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-format'><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-print'><code>mlr3::DataBackend$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataBackendDplyr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a backend for a <code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDplyr$new(
  data,
  primary_key,
  strings_as_factors = TRUE,
  connector = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>(<code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code>)<br />
The data object.
</p>
<p>Instead of calling the constructor yourself, you can call <code><a href="mlr3.html#topic+as_data_backend">mlr3::as_data_backend()</a></code>
on a <code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code>.
Note that only objects of class <code>"tbl_lazy"</code> will be converted to a <a href="#topic+DataBackendDplyr">DataBackendDplyr</a>
(this includes all connectors from <a href="https://CRAN.R-project.org/package=dbplyr"><span class="pkg">dbplyr</span></a>).
Local <code>"tbl"</code> objects such as <code><a href="tibble.html#topic+tibble">tibbles</a></code> will converted to a
<a href="mlr3.html#topic+DataBackendDataTable">DataBackendDataTable</a>.</p>
</dd>
<dt><code>primary_key</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the primary key column.</p>
</dd>
<dt><code>strings_as_factors</code></dt><dd><p>(<code>logical(1)</code> || <code>character()</code>)<br />
Either a character vector of column names to convert to factors, or a single logical flag:
if <code>FALSE</code>, no column will be converted, if <code>TRUE</code> all string columns (except the primary key).
For conversion, the backend is queried for distinct values of the respective columns
on construction and their levels are stored in <code style="white-space: pre;">&#8288;$levels&#8288;</code>.</p>
</dd>
<dt><code>connector</code></dt><dd><p>(function()<code style="white-space: pre;">&#8288;)\cr If not &#8288;</code>NULL', a function which re-connects to the database in case the connection has become invalid.
Database connections can become invalid due to timeouts or if the backend is serialized
to the file system and then de-serialized again.
This round trip is often performed for parallelization, e.g. to send the objects to remote workers.
<code><a href="DBI.html#topic+dbIsValid">DBI::dbIsValid()</a></code> is called to validate the connection.
The function must return just the connection, not a <code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code> object!
Note that this this function is serialized together with the backend, including
possible sensitive information such as login credentials.
These can be retrieved from the stored <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>/<a href="mlr3.html#topic+Task">mlr3::Task</a>.
To protect your credentials, it is recommended to use the <a href="https://CRAN.R-project.org/package=secret"><span class="pkg">secret</span></a> package.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendDplyr-data"></a>



<h4>Method <code>data()</code></h4>

<p>Returns a slice of the data.
Calls <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> and <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> on the table and converts it to a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>
<p>The rows must be addressed as vector of primary key values, columns must be referred to via column names.
Queries for rows with no matching row id and queries for columns with no matching
column name are silently ignored.
Rows are guaranteed to be returned in the same order as <code>rows</code>, columns may be returned in an arbitrary order.
Duplicated row ids result in duplicated rows, duplicated column names lead to an exception.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDplyr$data(rows, cols, data_format = "data.table")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character(1)</code>)<br />
Desired data format, e.g. <code>"data.table"</code> or <code>"Matrix"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendDplyr-head"></a>



<h4>Method <code>head()</code></h4>

<p>Retrieve the first <code>n</code> rows.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDplyr$head(n = 6L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of the first <code>n</code> rows.
</p>


<hr>
<a id="method-DataBackendDplyr-distinct"></a>



<h4>Method <code>distinct()</code></h4>

<p>Returns a named list of vectors of distinct values for each column
specified. If <code>na_rm</code> is <code>TRUE</code>, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDplyr$distinct(rows, cols, na_rm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p><code>logical(1)</code><br />
Whether to remove NAs or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Named <code>list()</code> of distinct values.
</p>


<hr>
<a id="method-DataBackendDplyr-missings"></a>



<h4>Method <code>missings()</code></h4>

<p>Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDplyr$missings(rows, cols)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Total of missing values per column (named <code>numeric()</code>).
</p>




<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces(c("tibble", "RSQLite", "dbplyr"), quietly = TRUE)) {
  # Backend using a in-memory tibble
  data = tibble::as_tibble(iris)
  data$Sepal.Length[1:30] = NA
  data$row_id = 1:150
  b = DataBackendDplyr$new(data, primary_key = "row_id")

  # Object supports all accessors of DataBackend
  print(b)
  b$nrow
  b$ncol
  b$colnames
  b$data(rows = 100:101, cols = "Species")
  b$distinct(b$rownames, "Species")

  # Classification task using this backend
  task = mlr3::TaskClassif$new(id = "iris_tibble", backend = b, target = "Species")
  print(task)
  head(task)

  # Create a temporary SQLite database
  con = DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  dplyr::copy_to(con, data)
  tbl = dplyr::tbl(con, "data")

  # Define a backend on a subset of the database: do not use column "Sepal.Width"
  tbl = dplyr::select_at(tbl, setdiff(colnames(tbl), "Sepal.Width"))
  tbl = dplyr::filter(tbl, row_id %in% 1:120) # Use only first 120 rows
  b = DataBackendDplyr$new(tbl, primary_key = "row_id")
  print(b)

  # Query disinct values
  b$distinct(b$rownames, "Species")

  # Query number of missing values
  b$missings(b$rownames, b$colnames)

  # Note that SQLite does not support factors, column Species has been converted to character
  lapply(b$head(), class)

  # Cleanup
  rm(tbl)
  DBI::dbDisconnect(con)
}
</code></pre>

<hr>
<h2 id='DataBackendDuckDB'>DataBackend for DuckDB</h2><span id='topic+DataBackendDuckDB'></span>

<h3>Description</h3>

<p>A <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> for <a href="https://CRAN.R-project.org/package=duckdb"><span class="pkg">duckdb</span></a>.
Can be easily constructed with <code><a href="#topic+as_duckdb_backend">as_duckdb_backend()</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a></code> -&gt; <code>DataBackendDuckDB</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>levels</code></dt><dd><p>(named <code>list()</code>)<br />
List (named with column names) of factor levels as <code>character()</code>.
Used to auto-convert character columns to factor variables.</p>
</dd>
<dt><code>connector</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Function which is called to re-connect in case the connection became invalid.</p>
</dd>
<dt><code>table</code></dt><dd><p>(<code>character(1)</code>)<br />
Data base table or view to operate on.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>table_info</code></dt><dd><p>(<code>data.frame()</code>)<br />
Data frame as returned by pragma <code>table_info()</code>.</p>
</dd>
<dt><code>rownames</code></dt><dd><p>(<code>integer()</code>)<br />
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.</p>
</dd>
<dt><code>colnames</code></dt><dd><p>(<code>character()</code>)<br />
Returns vector of all column names, including the primary key column.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows (observations).</p>
</dd>
<dt><code>ncol</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of columns (variables), including the primary key column.</p>
</dd>
<dt><code>valid</code></dt><dd><p>(<code>logical(1)</code>)<br />
Returns <code>NA</code> if the data does not inherits from <code>"tbl_sql"</code> (i.e., it is not a real SQL data base).
Returns the result of <code><a href="DBI.html#topic+dbIsValid">DBI::dbIsValid()</a></code> otherwise.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendDuckDB-new"><code>DataBackendDuckDB$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDuckDB-data"><code>DataBackendDuckDB$data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDuckDB-head"><code>DataBackendDuckDB$head()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDuckDB-distinct"><code>DataBackendDuckDB$distinct()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendDuckDB-missings"><code>DataBackendDuckDB$missings()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-format'><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-print'><code>mlr3::DataBackend$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataBackendDuckDB-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a backend for a <code><a href="duckdb.html#topic+duckdb">duckdb::duckdb()</a></code> database.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDuckDB$new(
  data,
  table,
  primary_key,
  strings_as_factors = TRUE,
  connector = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>(connection)<br />
A connection created with <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code>.
If constructed manually (and not via the helper function <code><a href="#topic+as_duckdb_backend">as_duckdb_backend()</a></code>,
make sure that there exists an (unique) index for the key column.</p>
</dd>
<dt><code>table</code></dt><dd><p>(<code>character(1)</code>)<br />
Table or view to operate on.</p>
</dd>
<dt><code>primary_key</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the primary key column.</p>
</dd>
<dt><code>strings_as_factors</code></dt><dd><p>(<code>logical(1)</code> || <code>character()</code>)<br />
Either a character vector of column names to convert to factors, or a single logical flag:
if <code>FALSE</code>, no column will be converted, if <code>TRUE</code> all string columns (except the primary key).
For conversion, the backend is queried for distinct values of the respective columns
on construction and their levels are stored in <code style="white-space: pre;">&#8288;$levels&#8288;</code>.</p>
</dd>
<dt><code>connector</code></dt><dd><p>(function()<code style="white-space: pre;">&#8288;)\cr If not &#8288;</code>NULL', a function which re-connects to the database in case the connection has become invalid.
Database connections can become invalid due to timeouts or if the backend is serialized
to the file system and then de-serialized again.
This round trip is often performed for parallelization, e.g. to send the objects to remote workers.
<code><a href="DBI.html#topic+dbIsValid">DBI::dbIsValid()</a></code> is called to validate the connection.
The function must return just the connection, not a <code><a href="dplyr.html#topic+tbl">dplyr::tbl()</a></code> object!
Note that this this function is serialized together with the backend, including
possible sensitive information such as login credentials.
These can be retrieved from the stored <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>/<a href="mlr3.html#topic+Task">mlr3::Task</a>.
To protect your credentials, it is recommended to use the <a href="https://CRAN.R-project.org/package=secret"><span class="pkg">secret</span></a> package.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendDuckDB-data"></a>



<h4>Method <code>data()</code></h4>

<p>Returns a slice of the data.
</p>
<p>The rows must be addressed as vector of primary key values, columns must be referred to via column names.
Queries for rows with no matching row id and queries for columns with no matching
column name are silently ignored.
Rows are guaranteed to be returned in the same order as <code>rows</code>, columns may be returned in an arbitrary order.
Duplicated row ids result in duplicated rows, duplicated column names lead to an exception.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDuckDB$data(rows, cols, data_format = "data.table")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>data_format</code></dt><dd><p>(<code>character(1)</code>)<br />
Desired data format, e.g. <code>"data.table"</code> or <code>"Matrix"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataBackendDuckDB-head"></a>



<h4>Method <code>head()</code></h4>

<p>Retrieve the first <code>n</code> rows.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDuckDB$head(n = 6L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of the first <code>n</code> rows.
</p>


<hr>
<a id="method-DataBackendDuckDB-distinct"></a>



<h4>Method <code>distinct()</code></h4>

<p>Returns a named list of vectors of distinct values for each column
specified. If <code>na_rm</code> is <code>TRUE</code>, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDuckDB$distinct(rows, cols, na_rm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p><code>logical(1)</code><br />
Whether to remove NAs or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Named <code>list()</code> of distinct values.
</p>


<hr>
<a id="method-DataBackendDuckDB-missings"></a>



<h4>Method <code>missings()</code></h4>

<p>Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendDuckDB$missings(rows, cols)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p><code>integer()</code><br />
Row indices.</p>
</dd>
<dt><code>cols</code></dt><dd><p><code>character()</code><br />
Column names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Total of missing values per column (named <code>numeric()</code>).
</p>




<h3>See Also</h3>

<p><a href="https://duckdb.org/">https://duckdb.org/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
