<!DOCTYPE html><html><head><title>Help for package ebnm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ebnm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.ebnm'><p>Extract posterior means from a fitted EBNM model</p></a></li>
<li><a href='#confint.ebnm'><p>Obtain confidence intervals using a fitted EBNM model</p></a></li>
<li><a href='#ebnm'><p>Solve the EBNM problem</p></a></li>
<li><a href='#ebnm_add_sampler'><p>Add sampler to an ebnm_object</p></a></li>
<li><a href='#ebnm_ash'><p>Solve the EBNM problem using an ash family of distributions</p></a></li>
<li><a href='#ebnm_deconvolver'><p>Solve the EBNM problem using the &quot;deconvolveR&quot; family of distributions</p></a></li>
<li><a href='#ebnm_flat'><p>Solve the EBNM problem using a flat prior</p></a></li>
<li><a href='#ebnm_generalized_binary'><p>Solve the EBNM problem using generalized binary priors</p></a></li>
<li><a href='#ebnm_group'><p>Solve the EBNM problem for grouped data</p></a></li>
<li><a href='#ebnm_horseshoe'><p>Solve the EBNM problem using horseshoe priors</p></a></li>
<li><a href='#ebnm_normal'><p>Solve the EBNM problem using normal priors</p></a></li>
<li><a href='#ebnm_normal_scale_mixture'><p>Solve the EBNM problem using scale mixtures of normals</p></a></li>
<li><a href='#ebnm_npmle'><p>Solve the EBNM problem using the family of all distributions</p></a></li>
<li><a href='#ebnm_point_exponential'><p>Solve the EBNM problem using point-exponential priors</p></a></li>
<li><a href='#ebnm_point_laplace'><p>Solve the EBNM problem using point-Laplace priors</p></a></li>
<li><a href='#ebnm_point_mass'><p>Solve the EBNM problem using a point mass prior</p></a></li>
<li><a href='#ebnm_point_normal'><p>Solve the EBNM problem using point-normal priors</p></a></li>
<li><a href='#ebnm_scale_normalmix'><p>Set scale parameter for scale mixtures of normals</p></a></li>
<li><a href='#ebnm_scale_npmle'><p>Set scale parameter for NPMLE and deconvolveR prior family</p></a></li>
<li><a href='#ebnm_scale_unimix'><p>Set scale parameter for nonparametric unimodal prior families</p></a></li>
<li><a href='#ebnm_unimodal'><p>Solve the EBNM problem using unimodal distributions</p></a></li>
<li><a href='#ebnm_unimodal_nonnegative'><p>Solve the EBNM problem using unimodal nonnegative distributions</p></a></li>
<li><a href='#ebnm_unimodal_nonpositive'><p>Solve the EBNM problem using unimodal nonpositive distributions</p></a></li>
<li><a href='#ebnm_unimodal_symmetric'><p>Solve the EBNM problem using symmetric unimodal distributions</p></a></li>
<li><a href='#fitted.ebnm'><p>Extract posterior estimates from a fitted EBNM model</p></a></li>
<li><a href='#gammamix'><p>Constructor for gammamix class</p></a></li>
<li><a href='#horseshoe'><p>Constructor for horseshoe class</p></a></li>
<li><a href='#laplacemix'><p>Constructor for laplacemix class</p></a></li>
<li><a href='#logLik.ebnm'><p>Extract the log likelihood from a fitted EBNM model</p></a></li>
<li><a href='#nobs.ebnm'><p>Get the number of observations used to fit an EBNM model</p></a></li>
<li><a href='#plot.ebnm'><p>Plot an ebnm object</p></a></li>
<li><a href='#predict.ebnm'><p>Use the estimated prior from a fitted EBNM model to solve the EBNM problem for</p>
new data</a></li>
<li><a href='#print.ebnm'><p>Print an ebnm object</p></a></li>
<li><a href='#print.summary.ebnm'><p>Print a summary.ebnm object</p></a></li>
<li><a href='#quantile.ebnm'><p>Obtain posterior quantiles using a fitted EBNM model</p></a></li>
<li><a href='#residuals.ebnm'><p>Calculate residuals for a fitted EBNM model</p></a></li>
<li><a href='#simulate.ebnm'><p>Sample from the posterior of a fitted EBNM model</p></a></li>
<li><a href='#summary.ebnm'><p>Summarize an ebnm object</p></a></li>
<li><a href='#vcov.ebnm'><p>Extract posterior variances from a fitted EBNM model</p></a></li>
<li><a href='#wOBA'><p>2022 MLB wOBA Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Solve the Empirical Bayes Normal Means Problem</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stephenslab/ebnm">https://github.com/stephenslab/ebnm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenslab/ebnm/issues">https://github.com/stephenslab/ebnm/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides simple, fast, and stable functions to fit the normal
    means model using empirical Bayes. For available models and details, see 
    function ebnm(). A detailed introduction to the package is provided
    by Willwerscheid and Stephens (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2110.00152">doi:10.48550/arXiv.2110.00152</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ashr, mixsqp, truncnorm, trust, horseshoe, deconvolveR,
magrittr, rlang, dplyr, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, numDeriv, REBayes, knitr, rmarkdown, cowplot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 17:28:03 UTC; pcarbo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Willwerscheid [aut],
  Matthew Stephens [aut],
  Peter Carbonetto [aut, cre],
  Andrew Goldstein [ctb],
  Yusha Liu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Carbonetto &lt;peter.carbonetto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-12 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.ebnm'>Extract posterior means from a fitted EBNM model</h2><span id='topic+coef.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+coef">coef</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="coef.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='confint.ebnm'>Obtain confidence intervals using a fitted EBNM model</h2><span id='topic+confint.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+confint">confint</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
Estimates the highest posterior density (HPD) intervals by sampling from
the posterior. By default, <code><a href="#topic+ebnm">ebnm</a></code> does not return a posterior
sampler; one can be added to the <code>ebnm</code> object using function
<code><a href="#topic+ebnm_add_sampler">ebnm_add_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
confint(object, parm, level = 0.95, nsim = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="confint.ebnm_+3A_parm">parm</code></td>
<td>
<p>A vector of numeric indices specifying which means <code class="reqn">\theta_i</code>
are to be given confidence intervals. If missing, all observations are
considered.</p>
</td></tr>
<tr><td><code id="confint.ebnm_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.ebnm_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to use to estimate confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.ebnm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the posterior sampler
function. Since <code>ebnm_horseshoe</code> returns an MCMC sampler, it takes
parameter <code>burn</code>, the number of burn-in samples to discard.  At
present, no other samplers take any additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns giving lower and upper confidence limits for
each mean <code class="reqn">\theta_i</code>. These will be labelled as &quot;CI.lower&quot; and
&quot;CI.upper&quot;.
</p>

<hr>
<h2 id='ebnm'>Solve the EBNM problem</h2><span id='topic+ebnm'></span><span id='topic+ebnm_output_default'></span><span id='topic+ebnm_output_all'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using a specified
family of priors. For an article-length introduction to the package, see
Willwerscheid and Stephens (2021), cited in <strong>References</strong> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm(
  x,
  s = 1,
  prior_family = c("point_normal", "point_laplace", "point_exponential", "normal",
    "horseshoe", "normal_scale_mixture", "unimodal", "unimodal_symmetric",
    "unimodal_nonnegative", "unimodal_nonpositive", "generalized_binary", "npmle",
    "deconvolver", "flat", "point_mass", "ash"),
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL,
  ...
)

ebnm_output_default()

ebnm_output_all()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and
missing standard errors are not allowed. Two prior families have
additional restrictions: when horseshoe priors are used, errors
must be homoskedastic; and since function
<code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in package <code>deconvolveR</code> takes
<code class="reqn">z</code>-scores, the &quot;deconvolver&quot; family requires that all standard errors
be equal to 1.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_prior_family">prior_family</code></td>
<td>
<p>A character string that specifies the prior family
<code class="reqn">G</code>. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data. This
parameter is ignored by the NPMLE, the <code>deconvolveR</code> family,
and the improper uniform (or &quot;flat&quot;) prior. For generalized binary priors,
which are bimodal, the mode parameter specifies the mode of the truncated
normal component (the location of the point mass is fixed at zero).</p>
</td></tr>
<tr><td><code id="ebnm_+3A_scale">scale</code></td>
<td>
<p>A scalar or vector specifying the scale parameter(s) of the
prior or <code>"estimate"</code> if the scale parameters are to be estimated
from the data. This parameter is ignored by the flat prior and the family
of point mass priors.
</p>
<p>The interpretation of <code>scale</code> depends on the prior
family. For normal and point-normal families, it is a scalar
specifying the standard deviation of the normal component. For
point-Laplace and point-exponential families, it is a scalar specifying
the scale parameter of the Laplace or exponential component. For the horseshoe
family, it corresponds to <code class="reqn">s\tau</code> in the usual parametrization of
the <code><a href="#topic+horseshoe">horseshoe</a></code> distribution. For the family of generalized
binary priors, it specifies the ratio of the (untruncated) standard
deviation of the normal component to its mode.
This ratio must be fixed in advance (i.e., argument <code>"estimate"</code> is
unavailable for generalized binary priors). For the NPMLE and <code>deconvolveR</code>
prior family, <code>scale</code> is a scalar specifying the distance between
successive means in the grid of point masses or normal distributions
used to estimate <code class="reqn">g</code>.
For all other prior families, which are implemented using the function
<code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>, it is a vector specifying
the parameter <code>mixsd</code> to be passed to <code>ash</code> or <code>"estimate"</code>
if <code>mixsd</code> is to be chosen by <code>ebnm</code>. (Note that <code>ebnm</code> chooses
<code>mixsd</code> differently from <code>ash</code>: see functions
<code><a href="#topic+ebnm_scale_normalmix">ebnm_scale_normalmix</a></code>, <code><a href="#topic+ebnm_scale_unimix">ebnm_scale_unimix</a></code>, and
<code><a href="#topic+ebnm_scale_npmle">ebnm_scale_npmle</a></code> for details. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.)</p>
</td></tr>
<tr><td><code id="ebnm_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. For
non-parametric priors, this has the side effect of fixing the <code>mode</code>
and <code>scale</code> parameters. If <code>g_init</code> is supplied, it should be
an object of class <code><a href="ashr.html#topic+normalmix">normalmix</a></code> for normal, point-normal,
scale mixture of normals, and <code>deconvolveR</code> prior families, as well as
for the NPMLE; class <code><a href="#topic+laplacemix">laplacemix</a></code> for
point-Laplace families; class <code><a href="#topic+gammamix">gammamix</a></code> for point-exponential
families; class <code><a href="#topic+horseshoe">horseshoe</a></code> for horseshoe families; class
<code><a href="ashr.html#topic+unimix">unimix</a></code> for <code>unimodal_</code> families; or class
<code><a href="ashr.html#topic+tnormalmix">tnormalmix</a></code> for generalized binary priors. An object of
class <code>ebnm</code> can also be supplied as argument, provided that field
<code>fitted_g</code> contains a prior of the correct class (see
<strong>Examples</strong> below).</p>
</td></tr>
<tr><td><code id="ebnm_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_optmethod">optmethod</code></td>
<td>
<p>A string specifying which optimization function is to be
used. Since all non-parametric families rely upon external packages, this
parameter is only available for parametric families (point-normal,
point-Laplace, point-exponential, and normal). Options include <code>"nlm"</code>,
<code>"lbfgsb"</code> (which calls
<code>optim</code> with <code>method = "L-BFGS-B"</code>), and <code>"trust"</code> (which
calls into package <code>trust</code>). Other options are <code>"nohess_nlm"</code>,
<code>"nograd_nlm"</code>, and <code>"nograd_lbfgsb"</code>, which use numerical
approximations rather than exact expressions for the Hessian and (for
the latter two) the gradient. The default option is <code>"nohess_nlm"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to the optimization
function. <code><a href="stats.html#topic+optimize">optimize</a></code> is used for normal and horseshoe
prior families, while <code><a href="stats.html#topic+nlm">nlm</a></code> is used for parametric
families unless parameter <code>optmethod</code> specifies otherwise.
<code><a href="stats.html#topic+nlm">nlm</a></code> is also used for the <code>deconvolveR</code> prior family.
For ash families (including scale mixtures of normals, the NPMLE, and
all <code>unimodal_</code> families), function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code> in
package <code>mixsqp</code> is the default. For generalized binary priors,
function <code><a href="stats.html#topic+optim">optim</a></code> is used with <code>method = "L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_+3A_...">...</code></td>
<td>
<p>Additional parameters. When a <code>unimodal_</code> prior family is used,
these parameters are passed to function <code><a href="ashr.html#topic+ash">ash</a></code> in package
<code>ashr</code>. Although it
does not call into <code>ashr</code>, the scale mixture of normals family accepts
parameter <code>gridmult</code> for purposes of comparison. When <code>gridmult</code>
is set, an <code>ashr</code>-style grid will be used instead of the default
<code>ebnm</code> grid. When the &quot;deconvolver&quot; family is used, additional
parameters are passed to function <code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in
package <code>deconvolveR</code>. Families of generalized binary priors take several
additional parameters; see <code><a href="#topic+ebnm_generalized_binary">ebnm_generalized_binary</a></code>. In all
other cases, additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vectors of data <code>x</code> and standard errors <code>s</code>, <code>ebnm</code>
solves the &quot;empirical Bayes normal means&quot; (EBNM) problem for various
choices of prior family.
The model is </p>
<p style="text-align: center;"><code class="reqn">x_j | \theta_j, s_j \sim N(\theta_j, s_j^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j \sim g \in G,</code>
</p>
<p> where <code class="reqn">g</code>, which is referred to as the
&quot;prior distribution&quot; for <code class="reqn">\theta</code>, is to be estimated from among
some specified family of prior distributions <code class="reqn">G</code>. Several options
for <code class="reqn">G</code> are implemented, some parametric and others non-parametric;
see below for examples.
</p>
<p>Solving the EBNM problem involves
two steps. First, <code class="reqn">g \in  G</code> is estimated via maximum marginal likelihood:
</p>
<p style="text-align: center;"><code class="reqn">\hat{g} := \arg\max_{g \in G} L(g),</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">L(g) := \prod_j \int p(x_j | \theta_j, s_j)  g(d\theta_j).</code>
</p>

<p>Second, posterior distributions
<code class="reqn">p(\theta_j | x_j, s_j, \hat{g})</code> and/or summaries
such as posterior means and posterior second moments are computed.
</p>
<p>Implemented prior families include:
</p>

<dl>
<dt><code>point_normal</code></dt><dd><p>The family of mixtures where one
component is a point mass at <code class="reqn">\mu</code> and the other is a normal
distribution centered at <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>point_laplace</code></dt><dd><p>The family of mixtures where one
component is a point mass at <code class="reqn">\mu</code> and the other is a
double-exponential distribution centered at <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>point_exponential</code></dt><dd><p>The family of mixtures where one
component is a point mass at <code class="reqn">\mu</code> and the other is a
(nonnegative) exponential distribution with mode <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>normal</code></dt><dd><p>The family of normal distributions.</p>
</dd>
<dt><code>horseshoe</code></dt><dd><p>The family of <a href="#topic+horseshoe">horseshoe</a> distributions.</p>
</dd>
<dt><code>normal_scale_mixture</code></dt><dd><p>The family of scale mixtures of
normals.</p>
</dd>
<dt><code>unimodal</code></dt><dd><p>The family of all unimodal distributions.</p>
</dd>
<dt><code>unimodal_symmetric</code></dt><dd><p>The family of symmetric unimodal
distributions.</p>
</dd>
<dt><code>unimodal_nonnegative</code></dt><dd><p>The family of unimodal
distributions with support constrained to be greater than the mode.</p>
</dd>
<dt><code>unimodal_nonpositive</code></dt><dd><p>The family of unimodal
distributions with support constrained to be less than the mode.</p>
</dd>
<dt><code>generalized_binary</code></dt><dd><p>The family of mixtures where one
component is a point mass at zero and the other is a truncated
normal distribution with lower bound zero and nonzero mode. See
Liu et al. (2023), cited in <strong>References</strong> below.</p>
</dd>
<dt><code>npmle</code></dt><dd><p>The family of all distributions.</p>
</dd>
<dt><code>deconvolver</code></dt><dd><p>A non-parametric exponential family with
a natural spline basis. Like <code>npmle</code>, there is no unimodal
assumption, but whereas <code>npmle</code> produces spiky estimates for
<code class="reqn">g</code>, <code>deconvolver</code> estimates are much more regular. See
<code><a href="deconvolveR.html#topic+deconvolveR-package">deconvolveR-package</a></code> for details and
references.</p>
</dd>
<dt><code>flat</code></dt><dd><p>The &quot;non-informative&quot; improper uniform prior, which
yields posteriors </p>
<p style="text-align: center;"><code class="reqn">\theta_j | x_j, s_j \sim N(x_j, s_j^2).</code>
</p>
</dd>
<dt><code>point_mass</code></dt><dd><p>The family of point masses <code class="reqn">\delta_\mu</code>.
Posteriors are point masses at <code class="reqn">\mu</code>.</p>
</dd>
<dt><code>ash</code></dt><dd><p>Calls into function <code><a href="ashr.html#topic+ash">ash</a></code> in
package <code>ashr</code>. Can be used to make direct comparisons of
<code>ebnm</code> and <code>ashr</code> implementations of prior families such as
scale mixtures of normals and the NPMLE.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code> (an object of
class <code><a href="ashr.html#topic+normalmix">normalmix</a></code>, <code><a href="#topic+laplacemix">laplacemix</a></code>,
<code><a href="#topic+gammamix">gammamix</a></code>, <code><a href="ashr.html#topic+unimix">unimix</a></code>,
<code><a href="ashr.html#topic+tnormalmix">tnormalmix</a></code>, or <code><a href="#topic+horseshoe">horseshoe</a></code>).</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. For all prior families other
than the horseshoe, the sampler takes a single parameter
<code>nsamp</code>, the number of posterior samples to return per
observation. Since <code>ebnm_horseshoe</code> returns an MCMC sampler,
it additionally takes parameter <code>burn</code>, the number of burn-in
samples to discard.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ebnm_output_default()</code>: Lists the default return values.
</p>
</li>
<li> <p><code>ebnm_output_all()</code>: Lists all valid return values.
</p>
</li></ul>


<h3>References</h3>

<p>Jason Willwerscheid and Matthew Stephens (2021).
<code>ebnm</code>: an <code>R</code> Package for solving the empirical Bayes
normal means problem using a variety of prior families. arXiv:2110.00152.
</p>
<p>Yusha Liu, Peter Carbonetto, Jason Willwerscheid, Scott A Oakes, Kay F Macleod,
and Matthew Stephens (2023). Dissecting tumor transcriptional heterogeneity
from single-cell RNA-seq data by generalized binary covariance decomposition.
bioRxiv 2023.08.15.553436.
</p>


<h3>See Also</h3>

<p>A plotting method is available for <code>ebnm</code> objects: see
<code><a href="#topic+plot.ebnm">plot.ebnm</a></code>.
</p>
<p>For other methods, see <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>, <code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+predict.ebnm">predict.ebnm</a></code>,
<code><a href="#topic+print.ebnm">print.ebnm</a></code>, <code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>,
<code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>, <code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>,
<code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>
<p>Calling into functions <code><a href="#topic+ebnm_point_normal">ebnm_point_normal</a></code>,
<code><a href="#topic+ebnm_point_laplace">ebnm_point_laplace</a></code>,
<code><a href="#topic+ebnm_point_exponential">ebnm_point_exponential</a></code>, <code><a href="#topic+ebnm_normal">ebnm_normal</a></code>,
<code><a href="#topic+ebnm_horseshoe">ebnm_horseshoe</a></code>,
<code><a href="#topic+ebnm_normal_scale_mixture">ebnm_normal_scale_mixture</a></code>, <code><a href="#topic+ebnm_unimodal">ebnm_unimodal</a></code>,
<code><a href="#topic+ebnm_unimodal_symmetric">ebnm_unimodal_symmetric</a></code>,
<code><a href="#topic+ebnm_unimodal_nonnegative">ebnm_unimodal_nonnegative</a></code>,
<code><a href="#topic+ebnm_unimodal_nonpositive">ebnm_unimodal_nonpositive</a></code>,
<code><a href="#topic+ebnm_generalized_binary">ebnm_generalized_binary</a></code>, <code><a href="#topic+ebnm_npmle">ebnm_npmle</a></code>,
<code><a href="#topic+ebnm_deconvolver">ebnm_deconvolver</a></code>, <code><a href="#topic+ebnm_flat">ebnm_flat</a></code>,
<code><a href="#topic+ebnm_point_mass">ebnm_point_mass</a></code>, and <code><a href="#topic+ebnm_ash">ebnm_ash</a></code>
is equivalent to calling into <code>ebnm</code> with <code>prior_family</code> set
accordingly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(rep(0, 100), rexp(100))
s &lt;- 1
x &lt;- theta + rnorm(200, 0, s)

# The following are equivalent:
pn.res &lt;- ebnm(x, s, prior_family = "point_normal")
pn.res &lt;- ebnm_point_normal(x, s)

# Inspect results:
logLik(pn.res)
plot(pn.res)

# Fix the scale parameter:
pl.res &lt;- ebnm_point_laplace(x, s, scale = 1)

# Estimate the mode:
normal.res &lt;- ebnm_normal(x, s, mode = "estimate")
plot(normal.res) # posterior means shrink to a value different from zero

# Use an initial g (this fixes mode and scale for ash priors):
normalmix.res &lt;- ebnm_normal_scale_mixture(x, s, g_init = pn.res)

# Fix g and get different output (including a posterior sampler):
pn.res &lt;- ebnm_point_normal(x, s, g_init = pn.res, fix_g = TRUE,
                            output = ebnm_output_all())

# Sample from the posterior:
pn.samp &lt;- simulate(pn.res, nsim = 100)

# Quantiles and HPD confidence intervals can be obtained via sampling:
set.seed(1)
pn.quantiles &lt;- quantile(pn.res, probs = c(0.1, 0.9))
pn.quantiles[1:5, ]
confint(pn.res, level = 0.8, parm = 1:5)

# Examples of usage of control parameter:
#  point_normal uses nlm:
pn.res &lt;- ebnm_point_normal(x, s, control = list(print.level = 1))
#  unimodal uses mixsqp:
unimodal.res &lt;- ebnm_unimodal(x, s, control = list(verbose = TRUE))

</code></pre>

<hr>
<h2 id='ebnm_add_sampler'>Add sampler to an ebnm_object</h2><span id='topic+ebnm_add_sampler'></span>

<h3>Description</h3>

<p>Adds a posterior sampler to a fitted <code><a href="#topic+ebnm">ebnm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_add_sampler(ebnm_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_add_sampler_+3A_ebnm_res">ebnm_res</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ebnm</code> object with an additional field
<code>posterior_sampler</code>.
</p>

<hr>
<h2 id='ebnm_ash'>Solve the EBNM problem using an ash family of distributions</h2><span id='topic+ebnm_ash'></span>

<h3>Description</h3>

<p>A wrapper to function <code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>.
Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "ash"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_ash(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_ash_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_mode">mode</code></td>
<td>
<p>Passed to <code><a href="ashr.html#topic+ash">ash</a></code> as parameter <code>mode</code>.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_scale">scale</code></td>
<td>
<p>Passed to <code><a href="ashr.html#topic+ash">ash</a></code> as parameter <code>mixsd</code>.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_g_init">g_init</code></td>
<td>
<p>Passed to <code><a href="ashr.html#topic+ash">ash</a></code> as parameter <code>g</code>.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_fix_g">fix_g</code></td>
<td>
<p>Passed to <code><a href="ashr.html#topic+ash">ash</a></code> as parameter <code>fixg</code>.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_control">control</code></td>
<td>
<p>Passed to <code><a href="ashr.html#topic+ash">ash</a></code> as parameter <code>control</code>.</p>
</td></tr>
<tr><td><code id="ebnm_ash_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="ashr.html#topic+ash">ash</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_deconvolver'>Solve the EBNM problem using the &quot;deconvolveR&quot; family of distributions</h2><span id='topic+ebnm_deconvolver'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using a non-parametric
exponential family with a natural spline basis.
Like <code><a href="#topic+ebnm_npmle">ebnm_npmle</a></code>, there is no unimodal assumption, but whereas
<code>ebnm_npmle</code> produces spiky estimates for <code class="reqn">g</code>,
<code>ebnm_deconvolver</code> estimates are much more regular. See
<code><a href="deconvolveR.html#topic+deconvolveR-package">deconvolveR-package</a></code> for details and
references. Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "deconvolver"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_deconvolver(
  x,
  s = 1,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_deconvolver_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_s">s</code></td>
<td>
<p>Standard errors, which must be uniformly equal to 1 (i.e.,
<code>s = 1</code>) since the deconvolveR method takes <code class="reqn">z</code>-scores as input.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_scale">scale</code></td>
<td>
<p>A deconvolveR prior is a finite mixture of point masses
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 \delta_{\mu_1} + \ldots + \pi_K \delta_{\mu_K},</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the point masses are
evenly spaced over <code class="reqn">(\mu_1, \mu_K)</code>.The distance between successive
point masses can be specified by the user via parameter
<code>scale</code>, in which case the argument should be a scalar specifying the
distance <code class="reqn">d = \mu_2 - \mu_1 = \cdots = \mu_K - \mu_{K - 1}</code>;
alternatively, if <code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid
via function <code><a href="#topic+ebnm_scale_npmle">ebnm_scale_npmle</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>scale</code> parameter. When supplied,
<code>g_init</code> should be an object of class <code><a href="ashr.html#topic+normalmix">normalmix</a></code>
or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="stats.html#topic+nlm">nlm</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_deconvolver_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to function
<code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in package <code>deconvolveR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_flat'>Solve the EBNM problem using a flat prior</h2><span id='topic+ebnm_flat'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using a
&quot;non-informative&quot; improper uniform prior, which yields posteriors
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | x_j, s_j \sim N(x_j, s_j^2).</code>
</p>
<p> Identical to function
<code><a href="#topic+ebnm">ebnm</a></code> with argument <code>prior_family = "flat"</code>. For details
about the model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_flat(
  x,
  s = 1,
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_flat_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_flat_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_flat_+3A_g_init">g_init</code></td>
<td>
<p>Not used by <code>ebnm_flat</code>, but included for consistency
with other <code>ebnm</code> functions.</p>
</td></tr>
<tr><td><code id="ebnm_flat_+3A_fix_g">fix_g</code></td>
<td>
<p>Not used by <code>ebnm_flat</code>, but included for consistency
with other <code>ebnm</code> functions.</p>
</td></tr>
<tr><td><code id="ebnm_flat_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_generalized_binary'>Solve the EBNM problem using generalized binary priors</h2><span id='topic+ebnm_generalized_binary'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
nonnegative distributions consisting of mixtures where one component is a
point mass at zero and the other is a truncated normal distribution with
lower bound zero and nonzero mode. Typically, the mode is positive, with
the ratio of the mode to the standard deviation taken to be large, so that
posterior estimates are strongly shrunk towards one of two values (zero or
the mode of the normal component).
Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "generalized_binary"</code>.
For details, see Liu et al. (2023), cited in <strong>References</strong> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_generalized_binary(
  x,
  s = 1,
  mode = "estimate",
  scale = 0.1,
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_generalized_binary_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the truncated normal component,
or <code>"estimate"</code> if the mode is to be estimated from the data (the
location of the point mass is fixed at zero).</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_scale">scale</code></td>
<td>
<p>A scalar specifying the ratio of the (untruncated) standard
deviation of the normal component to its mode. This ratio must be
fixed in advance (i.e., it is not possible to set <code>scale = "estimate"</code>
when using generalized binary priors).</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+tnormalmix">tnormalmix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>tnormalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to function
<code><a href="stats.html#topic+optim">optim</a></code>, where <code>method</code> has been set to
<code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_generalized_binary_+3A_...">...</code></td>
<td>
<p>The following additional arguments act as control parameters for
the outer EM loops in the fitting algorithm. Each loop iteratively updates
parameters <code class="reqn">w</code> (the
mixture proportion corresponding to the truncated normal component) and
<code class="reqn">\mu</code> (the mode of the truncated normal component):
</p>

<dl>
<dt><code>wlist</code></dt><dd><p>A vector defining intervals of <code class="reqn">w</code> for which
optimal solutions will separately be found. For example, if
<code>wlist = c(0, 0.5, 1)</code>, then two optimal priors will be found:
one such that <code class="reqn">w</code> is constrained to be less than 0.5 and one
such that it is constrained to be greater than 0.5.</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>A scalar specifying the maximum number of
iterations to perform in each outer EM loop.</p>
</dd>
<dt><code>tol</code></dt><dd><p>A scalar specifying the convergence tolerance
parameter for each outer EM loop.</p>
</dd>
<dt><code>mu_init</code></dt><dd><p>A scalar specifying the initial value of <code class="reqn">\mu</code>
to be used in each outer EM loop.</p>
</dd>
<dt><code>mu_range</code></dt><dd><p>A vector of length two specifying lower and
upper bounds for possible values of <code class="reqn">\mu</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>References</h3>

<p>Yusha Liu, Peter Carbonetto, Jason Willwerscheid, Scott A Oakes, Kay F Macleod,
and Matthew Stephens (2023). Dissecting tumor transcriptional heterogeneity
from single-cell RNA-seq data by generalized binary covariance decomposition.
bioRxiv 2023.08.15.553436.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_group'>Solve the EBNM problem for grouped data</h2><span id='topic+ebnm_group'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem for observations
belonging to distinct groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_group(
  x,
  s = 1,
  group,
  prior_family = "point_normal",
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_group_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and
missing standard errors are not allowed. Two prior families have
additional restrictions: when horseshoe priors are used, errors
must be homoskedastic; and since function
<code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in package <code>deconvolveR</code> takes
<code class="reqn">z</code>-scores, the &quot;deconvolver&quot; family requires that all standard errors
be equal to 1.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_group">group</code></td>
<td>
<p>A vector of character strings that gives the group to which each
observation belongs. It must have the same length as argument <code>x</code>. For
an example of usage, see Examples below.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_prior_family">prior_family</code></td>
<td>
<p>A named vector that specifies the prior family <code class="reqn">G</code>
for each group. If the same prior family is to be used for all groups, then
a character string may be used instead.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_mode">mode</code></td>
<td>
<p>A named list that specifies, for each group, the mode of the
respective prior <code class="reqn">g</code>, or <code>"estimate"</code> if the mode is to be
estimated from the data. If the mode is the same across groups, then a
scalar may be used instead. If all modes are to be estimated, then
<code>mode = "estimate"</code> may be used.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_scale">scale</code></td>
<td>
<p>A named list that specifies, for each group, the scale
parameter(s) of the respective prior, or <code>"estimate"</code> if the scale
parameters are to be estimated from the data. If the scale parameter is the
same across groups, then a scalar may be used instead. If all scales are to
be estimated, then <code>scale = "estimate"</code> may be used.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_g_init">g_init</code></td>
<td>
<p>The prior distributions <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. If
<code>g_init</code> is supplied, it should be a named list that specifies, for
each group, a prior of the appropriate class (<code><a href="ashr.html#topic+normalmix">normalmix</a></code>
for normal, point-normal,
scale mixture of normals, and <code>deconvolveR</code> prior families, as well as
for the NPMLE; class <code><a href="#topic+laplacemix">laplacemix</a></code> for
point-Laplace families; class <code><a href="#topic+gammamix">gammamix</a></code> for point-exponential
families; class <code><a href="#topic+horseshoe">horseshoe</a></code> for horseshoe families; and class
<code><a href="ashr.html#topic+unimix">unimix</a></code> for <code>unimodal_</code> families).</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_group_+3A_...">...</code></td>
<td>
<p>Additional parameters. When a <code>unimodal_</code> prior family is used,
these parameters are passed to function <code><a href="ashr.html#topic+ash">ash</a></code> in package
<code>ashr</code>. Although it
does not call into <code>ashr</code>, the scale mixture of normals family accepts
parameter <code>gridmult</code> for purposes of comparison. When <code>gridmult</code>
is set, an <code>ashr</code>-style grid will be used instead of the default
<code>ebnm</code> grid. When the &quot;deconvolver&quot; family is used, additional
parameters are passed to function <code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in
package <code>deconvolveR</code>. Families of generalized binary priors take several
additional parameters; see <code><a href="#topic+ebnm_generalized_binary">ebnm_generalized_binary</a></code>. In all
other cases, additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EBNM model for grouped data, with observations <code class="reqn">x_j</code> belonging to
groups <code class="reqn">k = 1, ..., K</code>, is
</p>
<p style="text-align: center;"><code class="reqn">x_j | \theta_j, s_j \sim N(\theta_j, s_j^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j \sim g_{k(j)} \in G_{k(j)}.</code>
</p>

<p>Solving the EBNM problem for grouped data is equivalent to solving a
separate EBNM problem for each group <code class="reqn">k = 1, ..., K</code>, with the optimal
log likelihood equal to the sum of the optimal log likelihoods for each
separate problem.
</p>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code> (an object of
class <code><a href="ashr.html#topic+normalmix">normalmix</a></code>, <code><a href="#topic+laplacemix">laplacemix</a></code>,
<code><a href="#topic+gammamix">gammamix</a></code>, <code><a href="ashr.html#topic+unimix">unimix</a></code>,
<code><a href="ashr.html#topic+tnormalmix">tnormalmix</a></code>, or <code><a href="#topic+horseshoe">horseshoe</a></code>).</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. For all prior families other
than the horseshoe, the sampler takes a single parameter
<code>nsamp</code>, the number of posterior samples to return per
observation. Since <code>ebnm_horseshoe</code> returns an MCMC sampler,
it additionally takes parameter <code>burn</code>, the number of burn-in
samples to discard.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ebnm">ebnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group &lt;- c(rep("small_sd", 100), rep("large_sd", 100))
theta &lt;- c(rnorm(100, sd = 1), rnorm(100, sd = 10))
s &lt;- 1
x &lt;- theta + rnorm(200, 0, s)

ebnm.group.res &lt;- ebnm_group(x, s, group)

# Use different prior families for each group:
ebnm.group.res &lt;- ebnm_group(
  x, s, group,
  prior_family = list(small_sd = "normal", large_sd = "normal_scale_mixture")
)

# Different modes and scales can be set similarly:
ebnm.group.res &lt;- ebnm_group(
  x, s, group,
  mode = list(small_sd = 0, large_sd = "estimate"),
  scale = list(small_sd = 1, large_sd = "estimate")
)

</code></pre>

<hr>
<h2 id='ebnm_horseshoe'>Solve the EBNM problem using horseshoe priors</h2><span id='topic+ebnm_horseshoe'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
<a href="#topic+horseshoe">horseshoe</a> distributions. Identical to function <code><a href="#topic+ebnm">ebnm</a></code>
with argument <code>prior_family = "horseshoe"</code>. For details about the
model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_horseshoe(
  x,
  s = 1,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_horseshoe_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_s">s</code></td>
<td>
<p>A <em>scalar</em> specifying the standard error of the observations
(observations must be homoskedastic).</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_scale">scale</code></td>
<td>
<p>A scalar corresponding to <code class="reqn">s\tau</code> in the usual
parametrization of the <code><a href="#topic+horseshoe">horseshoe</a></code> distribution, or
<code>"estimate"</code> if this parameter is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="#topic+horseshoe">horseshoe</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>horseshoe</code>.</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_horseshoe_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to function
<code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The function takes parameters
<code>nsamp</code>, the number of posterior samples to return per
observation, and <code>burn</code>, the number of burn-in samples to
discard (an MCMC sampler is used).</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_normal'>Solve the EBNM problem using normal priors</h2><span id='topic+ebnm_normal'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
normal distributions. Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with
argument <code>prior_family = "normal"</code>. For details about the model, see
<code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_normal(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_normal_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_scale">scale</code></td>
<td>
<p>A scalar specifying the standard deviation of the normal prior
or <code>"estimate"</code> if the standard deviation is to be estimated from
the data.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+normalmix">normalmix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_optmethod">optmethod</code></td>
<td>
<p>A string specifying which optimization function is to be
used. Options include <code>"nlm"</code>, <code>"lbfgsb"</code> (which calls
<code>optim</code> with <code>method = "L-BFGS-B"</code>), and <code>"trust"</code> (which
calls into package <code>trust</code>). Other options are <code>"nohess_nlm"</code>,
<code>"nograd_nlm"</code>, and <code>"nograd_lbfgsb"</code>, which use numerical
approximations rather than exact expressions for the Hessian and (for
the latter two) the gradient. The default option is <code>"nohess_nlm"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_normal_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to the
optimization function specified by parameter <code>optmethod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_normal_scale_mixture'>Solve the EBNM problem using scale mixtures of normals</h2><span id='topic+ebnm_normal_scale_mixture'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
scale mixtures of normals. Identical to function <code><a href="#topic+ebnm">ebnm</a></code>
with argument <code>prior_family = "normal_scale_mixture"</code>. For details
about the model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_normal_scale_mixture(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of scale mixtures of normals is
approximated via a finite mixture of normal distributions
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 N(\mu, \sigma_1^2) + \ldots + \pi_K N(\mu, \sigma_K^2),</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the grid of standard
deviations <code class="reqn">(\sigma_1, \ldots, \sigma_K)</code> is fixed in advance. By
making the grid sufficiently dense, one can obtain an arbitrarily good
approximation. The grid can be specified by the user via parameter
<code>scale</code>, in which case the argument should be the vector of
standard deviations <code class="reqn">(\sigma_1, \ldots, \sigma_K)</code>; alternatively,
if <code>scale = "estimate"</code>, then
<code>ebnm</code> sets the grid via function <code><a href="#topic+ebnm_scale_normalmix">ebnm_scale_normalmix</a></code>.
Note that <code>ebnm</code> sets the grid differently from
function <code><a href="ashr.html#topic+ash">ash</a></code>. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>mode</code> and <code>scale</code> parameters. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+normalmix">normalmix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_normal_scale_mixture_+3A_...">...</code></td>
<td>
<p>When parameter <code>gridmult</code> is set, an
<code><a href="ashr.html#topic+ash">ash</a></code>-style grid will be used instead of the default
<code>ebnm</code> grid (see parameter <code>scale</code> above). Other additional
parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_npmle'>Solve the EBNM problem using the family of all distributions</h2><span id='topic+ebnm_npmle'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family
of all distributions. Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "npmle"</code>. For details about the model, see
<code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_npmle(
  x,
  s = 1,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_npmle_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of all distributions is
approximated via a finite mixture of point masses
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 \delta_{\mu_1} + \ldots + \pi_K \delta_{\mu_K},</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the point masses are
evenly spaced over <code class="reqn">(\mu_1, \mu_K)</code>. By taking a sufficiently dense
grid of point masses, one can obtain an arbitrarily good
approximation. The distance between successive point masses can be
specified by the user via parameter
<code>scale</code>, in which case the argument should be a scalar specifying the
distance <code class="reqn">d = \mu_2 - \mu_1 = \cdots = \mu_K - \mu_{K - 1}</code>;
alternatively, if <code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid
via function <code><a href="#topic+ebnm_scale_npmle">ebnm_scale_npmle</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>scale</code> parameter. When supplied,
<code>g_init</code> should be an object of class <code><a href="ashr.html#topic+normalmix">normalmix</a></code>
or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_optmethod">optmethod</code></td>
<td>
<p>Not used by <code>ebnm_npmle</code>.</p>
</td></tr>
<tr><td><code id="ebnm_npmle_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_point_exponential'>Solve the EBNM problem using point-exponential priors</h2><span id='topic+ebnm_point_exponential'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
point-exponential priors (the family of mixtures where one component is a
point mass at <code class="reqn">\mu</code> and the other is a (nonnegative) exponential
distribution with mode <code class="reqn">\mu</code>). Identical to function <code><a href="#topic+ebnm">ebnm</a></code>
with argument <code>prior_family = "point_exponential"</code>. For details about
the model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_point_exponential(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_point_exponential_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_scale">scale</code></td>
<td>
<p>A scalar specifying the scale parameter of the exponential
component or <code>"estimate"</code> if the scale is to be estimated
from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="#topic+gammamix">gammamix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>gammamix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_optmethod">optmethod</code></td>
<td>
<p>A string specifying which optimization function is to be
used. Options include <code>"nlm"</code>, <code>"lbfgsb"</code> (which calls
<code>optim</code> with <code>method = "L-BFGS-B"</code>), and <code>"trust"</code> (which
calls into package <code>trust</code>). Other options are <code>"nohess_nlm"</code>,
<code>"nograd_nlm"</code>, and <code>"nograd_lbfgsb"</code>, which use numerical
approximations rather than exact expressions for the Hessian and (for
the latter two) the gradient. The default option is <code>"nohess_nlm"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_exponential_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to the
optimization function specified by parameter <code>optmethod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_point_laplace'>Solve the EBNM problem using point-Laplace priors</h2><span id='topic+ebnm_point_laplace'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
point-Laplace priors (the family of mixtures where one component is a point
mass at <code class="reqn">\mu</code> and the other is a double-exponential distribution
centered at <code class="reqn">\mu</code>). Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "point_laplace"</code>. For details about the model, see
<code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_point_laplace(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_point_laplace_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_scale">scale</code></td>
<td>
<p>A scalar specifying the scale parameter of the Laplace
component or <code>"estimate"</code> if the scale is to be estimated
from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="#topic+laplacemix">laplacemix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>laplacemix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_optmethod">optmethod</code></td>
<td>
<p>A string specifying which optimization function is to be
used. Options include <code>"nlm"</code>, <code>"lbfgsb"</code> (which calls
<code>optim</code> with <code>method = "L-BFGS-B"</code>), and <code>"trust"</code> (which
calls into package <code>trust</code>). Other options are <code>"nohess_nlm"</code>,
<code>"nograd_nlm"</code>, and <code>"nograd_lbfgsb"</code>, which use numerical
approximations rather than exact expressions for the Hessian and (for
the latter two) the gradient. The default option is <code>"nohess_nlm"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_laplace_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to the
optimization function specified by parameter <code>optmethod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_point_mass'>Solve the EBNM problem using a point mass prior</h2><span id='topic+ebnm_point_mass'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
point masses <code class="reqn">\delta_\mu</code>. Posteriors are simply point masses at <code class="reqn">\mu</code>.
Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "point_mass"</code>. For details about the model, see
<code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_point_mass(
  x,
  s = 1,
  mode = 0,
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_point_mass_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_mass_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_mass_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the location of the point mass or
<code>"estimate"</code> if the location is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_mass_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+normalmix">normalmix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_mass_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_point_mass_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_point_normal'>Solve the EBNM problem using point-normal priors</h2><span id='topic+ebnm_point_normal'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
point-normal priors (the family of mixtures where one component is a point
mass at <code class="reqn">\mu</code> and the other is a normal distribution centered at
<code class="reqn">\mu</code>). Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "point_normal"</code>. For details about the model, see
<code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_point_normal(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  optmethod = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_point_normal_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_scale">scale</code></td>
<td>
<p>A scalar specifying the standard deviation of the normal
component or <code>"estimate"</code> if the standard deviation is to be estimated
from the data.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+normalmix">normalmix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>normalmix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_optmethod">optmethod</code></td>
<td>
<p>A string specifying which optimization function is to be
used. Options include <code>"nlm"</code>, <code>"lbfgsb"</code> (which calls
<code>optim</code> with <code>method = "L-BFGS-B"</code>), and <code>"trust"</code> (which
calls into package <code>trust</code>). Other options are <code>"nohess_nlm"</code>,
<code>"nograd_nlm"</code>, and <code>"nograd_lbfgsb"</code>, which use numerical
approximations rather than exact expressions for the Hessian and (for
the latter two) the gradient. The default option is <code>"nohess_nlm"</code>.</p>
</td></tr>
<tr><td><code id="ebnm_point_normal_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to the
optimization function specified by parameter <code>optmethod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_scale_normalmix'>Set scale parameter for scale mixtures of normals</h2><span id='topic+ebnm_scale_normalmix'></span>

<h3>Description</h3>

<p>The default method for setting the <code>scale</code> parameter for function
<code><a href="#topic+ebnm_normal_scale_mixture">ebnm_normal_scale_mixture</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_scale_normalmix(
  x,
  s,
  mode = 0,
  min_K = 3,
  max_K = 300,
  KLdiv_target = 1/length(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_scale_normalmix_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_normalmix_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_normalmix_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code>.</p>
</td></tr>
<tr><td><code id="ebnm_scale_normalmix_+3A_min_k">min_K</code></td>
<td>
<p>The minimum number of components <code class="reqn">K</code> to include in the
finite mixture of normal distributions used to approximate the
nonparametric family of scale mixtures of normals.</p>
</td></tr>
<tr><td><code id="ebnm_scale_normalmix_+3A_max_k">max_K</code></td>
<td>
<p>The maximum number of components <code class="reqn">K</code> to include in the
approximating mixture of normal distributions.</p>
</td></tr>
<tr><td><code id="ebnm_scale_normalmix_+3A_kldiv_target">KLdiv_target</code></td>
<td>
<p>The desired bound <code class="reqn">\kappa</code> on the KL-divergence from
the solution obtained using the approximating mixture to the exact
solution. More precisely, the scale parameter is set such that given
the exact MLE
</p>
<p style="text-align: center;"><code class="reqn">\hat{g} := \mathrm{argmax}_{g \in G} L(g),</code>
</p>

<p>where <code class="reqn">G</code> is the full nonparametric family, and given the MLE for the
approximating family <code class="reqn">\tilde{G}</code>
</p>
<p style="text-align: center;"><code class="reqn">\tilde{g} := \mathrm{argmax}_{g \in \tilde{G}} L(g),</code>
</p>

<p>we have that
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{KL}(\hat{g} \ast N(0, s^2) \mid \tilde{g} \ast N(0, s^2)) \le \kappa,</code>
</p>

<p>where <code class="reqn">\ast \ N(0, s^2)</code> denotes convolution with the normal error
distribution (the derivation of the bound assumes homoskedastic
observations). For details, see <strong>References</strong> below.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jason Willwerscheid (2021).
<em>Empirical Bayes Matrix Factorization: Methods and Applications</em>.
University of Chicago, PhD dissertation.
</p>

<hr>
<h2 id='ebnm_scale_npmle'>Set scale parameter for NPMLE and deconvolveR prior family</h2><span id='topic+ebnm_scale_npmle'></span>

<h3>Description</h3>

<p>The default method for setting the <code>scale</code> parameter for functions
<code><a href="#topic+ebnm_npmle">ebnm_npmle</a></code> and <code><a href="#topic+ebnm_deconvolver">ebnm_deconvolver</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_scale_npmle(
  x,
  s,
  min_K = 3,
  max_K = 300,
  KLdiv_target = 1/length(x),
  pointmass = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_scale_npmle_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_npmle_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_npmle_+3A_min_k">min_K</code></td>
<td>
<p>The minimum number of components <code class="reqn">K</code> to include in the
mixture of point masses used to approximate the nonparametric family of
all distributions.</p>
</td></tr>
<tr><td><code id="ebnm_scale_npmle_+3A_max_k">max_K</code></td>
<td>
<p>The maximum number of components <code class="reqn">K</code> to include in the
approximating mixture of point masses.</p>
</td></tr>
<tr><td><code id="ebnm_scale_npmle_+3A_kldiv_target">KLdiv_target</code></td>
<td>
<p>The desired bound <code class="reqn">\kappa</code> on the KL-divergence from
the solution obtained using the approximating mixture to the exact
solution. More precisely, the scale parameter is set such that given
the exact MLE
</p>
<p style="text-align: center;"><code class="reqn">\hat{g} := \mathrm{argmax}_{g \in G} L(g),</code>
</p>

<p>where <code class="reqn">G</code> is the full nonparametric family, and given the MLE for the
approximating family <code class="reqn">\tilde{G}</code>
</p>
<p style="text-align: center;"><code class="reqn">\tilde{g} := \mathrm{argmax}_{g \in \tilde{G}} L(g),</code>
</p>

<p>we have that
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{KL}(\hat{g} \ast N(0, s^2) \mid \tilde{g} \ast N(0, s^2)) \le \kappa,</code>
</p>

<p>where <code class="reqn">\ast \ N(0, s^2)</code> denotes convolution with the normal error
distribution (the derivation of the bound assumes homoskedastic
observations). For details, see <strong>References</strong> below.</p>
</td></tr>
<tr><td><code id="ebnm_scale_npmle_+3A_pointmass">pointmass</code></td>
<td>
<p>When the range of the data is so large that <code>max_K</code>
point masses cannot provide a good approximation to the family of all
distributions, then <code>ebnm</code> will instead use a mixture of normal
distributions, with the standard deviation of each component equal to
<code>scale</code><code class="reqn">/ 2</code>. Setting <code>pointmass = FALSE</code> gives the
default <code>scale</code> for this mixture of normal distributions.
</p>
<p>To be exact, <code>ebnm</code> uses a mixture of normal distributions rather than
a mixture of point masses when
</p>
<p style="text-align: center;"><code class="reqn">\frac{\max(x) - \min(x)}{\min(s)} &gt; 3 \ \mathrm{max}_K;</code>
</p>
<p> for a
rationale, see <strong>References</strong> below. Note however that <code>ebnm</code>
only uses a mixture of normal distributions when <code>scale = "estimate"</code>;
if parameter <code>scale</code> is set manually, then a mixture of point masses
will be used in all cases. To use a mixture of normal distributions with
the scale set manually, an object created by the constructor function
<code><a href="ashr.html#topic+normalmix">normalmix</a></code> must be provided as argument to parameter
<code>g_init</code> in function <code><a href="#topic+ebnm_npmle">ebnm_npmle</a></code> or function
<code><a href="#topic+ebnm_deconvolver">ebnm_deconvolver</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jason Willwerscheid (2021).
<em>Empirical Bayes Matrix Factorization: Methods and Applications</em>.
University of Chicago, PhD dissertation.
</p>

<hr>
<h2 id='ebnm_scale_unimix'>Set scale parameter for nonparametric unimodal prior families</h2><span id='topic+ebnm_scale_unimix'></span>

<h3>Description</h3>

<p>The default method for setting the <code>scale</code> parameter for functions
<code><a href="#topic+ebnm_unimodal">ebnm_unimodal</a></code>, <code><a href="#topic+ebnm_unimodal_symmetric">ebnm_unimodal_symmetric</a></code>,
<code><a href="#topic+ebnm_unimodal_nonnegative">ebnm_unimodal_nonnegative</a></code>, and
<code><a href="#topic+ebnm_unimodal_nonpositive">ebnm_unimodal_nonpositive</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_scale_unimix(
  x,
  s,
  mode = 0,
  min_K = 3,
  max_K = 300,
  KLdiv_target = 1/length(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_scale_unimix_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_unimix_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_scale_unimix_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code>.</p>
</td></tr>
<tr><td><code id="ebnm_scale_unimix_+3A_min_k">min_K</code></td>
<td>
<p>The minimum number of components <code class="reqn">K</code> to include in the
finite mixture of uniform distributions used to approximate the
nonparametric family of unimodal distributions.</p>
</td></tr>
<tr><td><code id="ebnm_scale_unimix_+3A_max_k">max_K</code></td>
<td>
<p>The maximum number of components <code class="reqn">K</code> to include in the
approximating mixture of uniform distributions.</p>
</td></tr>
<tr><td><code id="ebnm_scale_unimix_+3A_kldiv_target">KLdiv_target</code></td>
<td>
<p>The desired bound <code class="reqn">\kappa</code> on the KL-divergence from
the solution obtained using the approximating mixture to the exact
solution. More precisely, the scale parameter is set such that given
the exact MLE
</p>
<p style="text-align: center;"><code class="reqn">\hat{g} := \mathrm{argmax}_{g \in G} L(g),</code>
</p>

<p>where <code class="reqn">G</code> is the full nonparametric family, and given the MLE for the
approximating family <code class="reqn">\tilde{G}</code>
</p>
<p style="text-align: center;"><code class="reqn">\tilde{g} := \mathrm{argmax}_{g \in \tilde{G}} L(g),</code>
</p>

<p>we have that
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{KL}(\hat{g} \ast N(0, s^2) \mid \tilde{g} \ast N(0, s^2)) \le \kappa,</code>
</p>

<p>where <code class="reqn">\ast \ N(0, s^2)</code> denotes convolution with the normal error
distribution (the derivation of the bound assumes homoskedastic
observations). For details, see <strong>References</strong> below.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jason Willwerscheid (2021).
<em>Empirical Bayes Matrix Factorization: Methods and Applications</em>.
University of Chicago, PhD dissertation.
</p>

<hr>
<h2 id='ebnm_unimodal'>Solve the EBNM problem using unimodal distributions</h2><span id='topic+ebnm_unimodal'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
all unimodal distributions. Identical to function <code><a href="#topic+ebnm">ebnm</a></code>
with argument <code>prior_family = "unimodal"</code>. For details
about the model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_unimodal(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_unimodal_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of unimodal distributions is
approximated via a finite mixture of uniform distributions
</p>
<p style="text-align: center;"><code class="reqn">\pi_1^l \mathrm{Unif}(\mu - a_1, \mu) + \pi_1^u \mathrm{Unif}(\mu, \mu + a_1)
+ \ldots + \pi_K^l \mathrm{Unif}(\mu - a_K, \mu) + \pi_K^u \mathrm{Unif}(\mu, \mu + a_K),</code>
</p>

<p>where parameters <code class="reqn">\pi_k^l</code> and <code class="reqn">\pi_k^u</code> are estimated and the grid
of lengths <code class="reqn">(a_1, \ldots, a_K)</code> is fixed in advance. By
making the grid sufficiently dense, one can obtain an arbitrarily good
approximation. The grid can be specified by the user via parameter
<code>scale</code>, in which case the argument should be the vector of
lengths <code class="reqn">(a_1, \ldots, a_K)</code>; alternatively, if
<code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid via function
<code><a href="#topic+ebnm_scale_unimix">ebnm_scale_unimix</a></code>.
Note that <code>ebnm</code> sets the grid differently from
function <code><a href="ashr.html#topic+ash">ash</a></code>. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>mode</code> and <code>scale</code> parameters. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+unimix">unimix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>unimix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to function
<code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_unimodal_nonnegative'>Solve the EBNM problem using unimodal nonnegative distributions</h2><span id='topic+ebnm_unimodal_nonnegative'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
unimodal distributions with support constrained to be greater than the
mode. Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "unimodal_nonnegative"</code>. For details about the model,
see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_unimodal_nonnegative(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of nonnegative unimodal distributions is
approximated via a finite mixture of uniform distributions
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 \mathrm{Unif}(\mu, \mu + a_1)
+ \ldots + \pi_K \mathrm{Unif}(\mu, \mu + a_K),</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the grid
of lengths <code class="reqn">(a_1, \ldots, a_K)</code> is fixed in advance. By
making the grid sufficiently dense, one can obtain an arbitrarily good
approximation. The grid can be specified by the user via parameter
<code>scale</code>, in which case the argument should be the vector of
lengths <code class="reqn">(a_1, \ldots, a_K)</code>; alternatively, if
<code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid via function
<code><a href="#topic+ebnm_scale_unimix">ebnm_scale_unimix</a></code>.
Note that <code>ebnm</code> sets the grid differently from
function <code><a href="ashr.html#topic+ash">ash</a></code>. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>mode</code> and <code>scale</code> parameters. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+unimix">unimix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>unimix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonnegative_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to function
<code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_unimodal_nonpositive'>Solve the EBNM problem using unimodal nonpositive distributions</h2><span id='topic+ebnm_unimodal_nonpositive'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
unimodal distributions with support constrained to be less than the
mode. Identical to function <code><a href="#topic+ebnm">ebnm</a></code> with argument
<code>prior_family = "unimodal_nonpositive"</code>. For details about the model,
see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_unimodal_nonpositive(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of nonnpositive unimodal distributions is
approximated via a finite mixture of uniform distributions
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 \mathrm{Unif}(\mu - a_1, \mu)
+ \ldots + \pi_K \mathrm{Unif}(\mu - a_K, \mu),</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the grid
of lengths <code class="reqn">(a_1, \ldots, a_K)</code> is fixed in advance. By
making the grid sufficiently dense, one can obtain an arbitrarily good
approximation. The grid can be specified by the user via parameter
<code>scale</code>, in which case the argument should be the vector of
lengths <code class="reqn">(a_1, \ldots, a_K)</code>; alternatively, if
<code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid via function
<code><a href="#topic+ebnm_scale_unimix">ebnm_scale_unimix</a></code>.
Note that <code>ebnm</code> sets the grid differently from
function <code><a href="ashr.html#topic+ash">ash</a></code>. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>mode</code> and <code>scale</code> parameters. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+unimix">unimix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>unimix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_nonpositive_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to function
<code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='ebnm_unimodal_symmetric'>Solve the EBNM problem using symmetric unimodal distributions</h2><span id='topic+ebnm_unimodal_symmetric'></span>

<h3>Description</h3>

<p>Solves the empirical Bayes normal means (EBNM) problem using the family of
symmetric unimodal distributions. Identical to function <code><a href="#topic+ebnm">ebnm</a></code>
with argument <code>prior_family = "unimodal_symmetric"</code>. For details
about the model, see <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebnm_unimodal_symmetric(
  x,
  s = 1,
  mode = 0,
  scale = "estimate",
  g_init = NULL,
  fix_g = FALSE,
  output = ebnm_output_default(),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_x">x</code></td>
<td>
<p>A vector of observations. Missing observations (<code>NA</code>s) are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and missing standard errors are
not allowed.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_mode">mode</code></td>
<td>
<p>A scalar specifying the mode of the prior <code class="reqn">g</code> or
<code>"estimate"</code> if the mode is to be estimated from the data.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_scale">scale</code></td>
<td>
<p>The nonparametric family of symmetric unimodal distributions is
approximated via a finite mixture of uniform distributions
</p>
<p style="text-align: center;"><code class="reqn">\pi_1 \mathrm{Unif}(\mu - a_1, \mu + a_1)
+ \ldots + \pi_K \mathrm{Unif}(\mu - a_K, \mu + a_K),</code>
</p>

<p>where parameters <code class="reqn">\pi_k</code> are estimated and the grid
of (half-)lengths <code class="reqn">(a_1, \ldots, a_K)</code> is fixed in advance. By
making the grid sufficiently dense, one can obtain an arbitrarily good
approximation. The grid can be specified by the user via parameter
<code>scale</code>, in which case the argument should be the vector
<code class="reqn">(a_1, \ldots, a_K)</code>; alternatively, if
<code>scale = "estimate"</code>, then <code>ebnm</code> sets the grid via function
<code><a href="#topic+ebnm_scale_unimix">ebnm_scale_unimix</a></code>.
Note that <code>ebnm</code> sets the grid differently from
function <code><a href="ashr.html#topic+ash">ash</a></code>. To use the <code>ash</code> grid, set
<code>scale = "estimate"</code> and pass in <code>gridmult</code> as an additional
parameter. See <code><a href="ashr.html#topic+ash">ash</a></code> for defaults and details.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_g_init">g_init</code></td>
<td>
<p>The prior distribution <code class="reqn">g</code>. Usually this is left
unspecified (<code>NULL</code>) and estimated from the data. However, it can be
used in conjuction with <code>fix_g = TRUE</code> to fix the prior (useful, for
example, to do computations with the &quot;true&quot; <code class="reqn">g</code> in simulations). If
<code>g_init</code> is specified but <code>fix_g = FALSE</code>, <code>g_init</code>
specifies the initial value of <code class="reqn">g</code> used during optimization. This has
the side effect of fixing the <code>mode</code> and <code>scale</code> parameters. When
supplied, <code>g_init</code> should be an object of class
<code><a href="ashr.html#topic+unimix">unimix</a></code> or an <code>ebnm</code> object in which the fitted
prior is an object of class <code>unimix</code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_fix_g">fix_g</code></td>
<td>
<p>If <code>TRUE</code>, fix the prior <code class="reqn">g</code> at <code>g_init</code> instead
of estimating it.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_output">output</code></td>
<td>
<p>A character vector indicating which values are to be returned.
Function <code>ebnm_output_default()</code> provides the default return values, while
<code>ebnm_output_all()</code> lists all possible return values. See <strong>Value</strong>
below.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to optimization
function <code><a href="mixsqp.html#topic+mixsqp">mixsqp</a></code>.</p>
</td></tr>
<tr><td><code id="ebnm_unimodal_symmetric_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to function
<code><a href="ashr.html#topic+ash">ash</a></code> in package <code>ashr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ebnm</code> object. Depending on the argument to <code>output</code>, the
object is a list containing elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the observations <code>x</code>
and standard errors <code>s</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>A data frame of summary results (posterior
means, standard deviations, second moments, and local false sign
rates).</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The fitted prior <code class="reqn">\hat{g}</code>.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood attained,
<code class="reqn">L(\hat{g})</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>A function that can be used to
produce samples from the posterior. The sampler takes a single
parameter <code>nsamp</code>, the number of posterior samples to return per
observation.</p>
</dd>
</dl>

<p>S3 methods <code>coef</code>, <code>confint</code>, <code>fitted</code>, <code>logLik</code>,
<code>nobs</code>, <code>plot</code>, <code>predict</code>, <code>print</code>, <code>quantile</code>,
<code>residuals</code>, <code>simulate</code>, <code>summary</code>, and <code>vcov</code>
have been implemented for <code>ebnm</code> objects. For details, see the
respective help pages, linked below under <strong>See Also</strong>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ebnm">ebnm</a></code> for examples of usage and model details.
</p>
<p>Available S3 methods include <code><a href="#topic+coef.ebnm">coef.ebnm</a></code>,
<code><a href="#topic+confint.ebnm">confint.ebnm</a></code>,
<code><a href="#topic+fitted.ebnm">fitted.ebnm</a></code>, <code><a href="#topic+logLik.ebnm">logLik.ebnm</a></code>,
<code><a href="#topic+nobs.ebnm">nobs.ebnm</a></code>, <code><a href="#topic+plot.ebnm">plot.ebnm</a></code>,
<code><a href="#topic+predict.ebnm">predict.ebnm</a></code>, <code><a href="#topic+print.ebnm">print.ebnm</a></code>,
<code><a href="#topic+print.summary.ebnm">print.summary.ebnm</a></code>, <code><a href="#topic+quantile.ebnm">quantile.ebnm</a></code>,
<code><a href="#topic+residuals.ebnm">residuals.ebnm</a></code>, <code><a href="#topic+simulate.ebnm">simulate.ebnm</a></code>,
<code><a href="#topic+summary.ebnm">summary.ebnm</a></code>, and <code><a href="#topic+vcov.ebnm">vcov.ebnm</a></code>.
</p>

<hr>
<h2 id='fitted.ebnm'>Extract posterior estimates from a fitted EBNM model</h2><span id='topic+fitted.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+fitted">fitted</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
Returns a data frame that includes posterior means, standard deviations,
and local false sign rates (when available).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="fitted.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='gammamix'>Constructor for gammamix class</h2><span id='topic+gammamix'></span>

<h3>Description</h3>

<p>Creates a finite mixture of gamma distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammamix(pi, shape, scale, shift = rep(0, length(pi)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammamix_+3A_pi">pi</code></td>
<td>
<p>A vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_shape">shape</code></td>
<td>
<p>A vector of shape parameters.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_scale">scale</code></td>
<td>
<p>A vector of scale parameters.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_shift">shift</code></td>
<td>
<p>A vector of shift parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gammamix</code> (a list with elements
<code>pi</code>, <code>shape</code>, <code>scale</code>, and <code>shift</code>, described above).
</p>

<hr>
<h2 id='horseshoe'>Constructor for horseshoe class</h2><span id='topic+horseshoe'></span>

<h3>Description</h3>

<p>Creates a horseshoe prior (see Carvalho, Polson, and Scott (2010)). The
horseshoe is usually parametrized as
<code class="reqn">\theta_i \sim N(0, s^2 \tau^2 \lambda_i^2)</code>,
<code class="reqn">\lambda_i \sim \mathrm{Cauchy}^+(0, 1)</code>,
with <code class="reqn">s^2</code> the variance of the error distribution. We use a single
parameter <code>scale</code>, which corresponds to <code class="reqn">s\tau</code> and thus does
not depend on the error distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horseshoe(scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horseshoe_+3A_scale">scale</code></td>
<td>
<p>The scale parameter (must be a scalar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>horseshoe</code> (a list with a single element
<code>scale</code>, described above).
</p>

<hr>
<h2 id='laplacemix'>Constructor for laplacemix class</h2><span id='topic+laplacemix'></span>

<h3>Description</h3>

<p>Creates a finite mixture of Laplace distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacemix(pi, mean, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacemix_+3A_pi">pi</code></td>
<td>
<p>A vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="laplacemix_+3A_mean">mean</code></td>
<td>
<p>A vector of means.</p>
</td></tr>
<tr><td><code id="laplacemix_+3A_scale">scale</code></td>
<td>
<p>A vector of scale parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>laplacemix</code> (a list with elements
<code>pi</code>, <code>mean</code>, and <code>scale</code>, described above).
</p>

<hr>
<h2 id='logLik.ebnm'>Extract the log likelihood from a fitted EBNM model</h2><span id='topic+logLik.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+logLik">logLik</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="logLik.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>logLik</code>, which includes attributes <code>df</code>,
the degrees of freedom &mdash; i.e., number of parameters in the model &mdash;, and
<code>nobs</code>, the number of observations in the data.
</p>

<hr>
<h2 id='nobs.ebnm'>Get the number of observations used to fit an EBNM model</h2><span id='topic+nobs.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+nobs">nobs</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="nobs.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations used to fit the <code>ebnm</code> object.
</p>

<hr>
<h2 id='plot.ebnm'>Plot an ebnm object</h2><span id='topic+plot.ebnm'></span>

<h3>Description</h3>

<p>Given one or more fitted <code><a href="#topic+ebnm">ebnm</a></code> object(s), produces a plot of
posterior means vs. observations. If desired, a plot of cumulative
distribution functions of fitted prior(s) can also be produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
plot(
  x,
  ...,
  incl_pm = TRUE,
  incl_cdf = FALSE,
  subset = NULL,
  remove_abline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ebnm_+3A_x">x</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="plot.ebnm_+3A_...">...</code></td>
<td>
<p>Additional <code>ebnm</code> objects to be included on the same plots.</p>
</td></tr>
<tr><td><code id="plot.ebnm_+3A_incl_pm">incl_pm</code></td>
<td>
<p>Plot posterior means vs. observations?</p>
</td></tr>
<tr><td><code id="plot.ebnm_+3A_incl_cdf">incl_cdf</code></td>
<td>
<p>Plot the cumulative distribution functions?</p>
</td></tr>
<tr><td><code id="plot.ebnm_+3A_subset">subset</code></td>
<td>
<p>The subset of observations to include on the plot of posterior
means vs. observations. Can be a numeric vector corresponding to indices
of observations to plot, or a character vector if observations are named.
If <code>subset = NULL</code> then all observations will be plotted.</p>
</td></tr>
<tr><td><code id="plot.ebnm_+3A_remove_abline">remove_abline</code></td>
<td>
<p>To better illustrate shrinkage effects, the plot of
posterior means vs. observations includes the line <code class="reqn">y = x</code> by default.
If <code>remove_abline = TRUE</code>, then this line will not be drawn.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(rep(0, 100), rexp(100))
theta[1:50] &lt;- 0
s &lt;- 1
x &lt;- theta + rnorm(200, 0, s)
pn.res &lt;- ebnm_point_normal(x, s)
plot(pn.res)

pe.res &lt;- ebnm_point_exponential(x, s)
plot(pn.res, pe.res)

# Customize plot:
library(ggplot2)
plot(pn.res, pe.res, remove_abline = TRUE) +
  theme_bw() +
  labs(x = "Simulated data")

</code></pre>

<hr>
<h2 id='predict.ebnm'>Use the estimated prior from a fitted EBNM model to solve the EBNM problem for
new data</h2><span id='topic+predict.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+predict">predict</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
predict(object, newdata, s = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="predict.ebnm_+3A_newdata">newdata</code></td>
<td>
<p>A vector of new observations. Missing observations
(<code>NA</code>s) are not allowed.</p>
</td></tr>
<tr><td><code id="predict.ebnm_+3A_s">s</code></td>
<td>
<p>A vector of standard errors (or a scalar if all are equal).
Standard errors may not be exactly zero, and
missing standard errors are not allowed. Two prior families have
additional restrictions: when horseshoe priors are used, errors
must be homoskedastic; and since function
<code><a href="deconvolveR.html#topic+deconv">deconv</a></code> in package <code>deconvolveR</code> takes
<code class="reqn">z</code>-scores, the &quot;deconvolver&quot; family requires that all standard errors
be equal to 1.</p>
</td></tr>
<tr><td><code id="predict.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that includes posterior means, posterior standard
deviations, and local false sign rates for the observations in <code>newdata</code>.
</p>

<hr>
<h2 id='print.ebnm'>Print an ebnm object</h2><span id='topic+print.ebnm'></span>

<h3>Description</h3>

<p>The <code>print</code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ebnm_+3A_x">x</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="print.ebnm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to use.</p>
</td></tr>
<tr><td><code id="print.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.ebnm'>Print a summary.ebnm object</h2><span id='topic+print.summary.ebnm'></span>

<h3>Description</h3>

<p>The <code>print</code> method for class <code><a href="#topic+summary.ebnm">summary.ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ebnm'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ebnm_+3A_x">x</code></td>
<td>
<p>The <code>summary.ebnm</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.ebnm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to use.</p>
</td></tr>
<tr><td><code id="print.summary.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='quantile.ebnm'>Obtain posterior quantiles using a fitted EBNM model</h2><span id='topic+quantile.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+quantile">quantile</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
Quantiles for posterior distributions <code class="reqn">\theta_i \mid x_i, s_i, g</code> are
estimated via sampling. By default, <code><a href="#topic+ebnm">ebnm</a></code> does not return a
posterior sampler; one can be added to the <code>ebnm</code> object using
function <code><a href="#topic+ebnm_add_sampler">ebnm_add_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
quantile(
  x,
  probs = seq(0, 1, 0.25),
  names = TRUE,
  type = 7,
  digits = 7,
  nsim = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ebnm_+3A_x">x</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in
<code class="reqn">[0,1]</code>.  (Values up to &lsquo;<span class="samp">&#8288;2e-14&#8288;</span>&rsquo; outside that
range are accepted and moved to the nearby endpoint.)</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code><a href="base.html#topic+names">names</a></code>
attribute.  Set to <code>FALSE</code> for speedup with many <code>probs</code>.</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_type">type</code></td>
<td>
<p>An integer between 1 and 9 selecting one of the nine quantile
algorithms detailed in <code><a href="stats.html#topic+quantile">quantile</a></code> to be used.</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_digits">digits</code></td>
<td>
<p>used only when <code>names</code> is true: the precision to use
when formatting the percentages.  In <span class="rlang"><b>R</b></span> versions up to 4.0.x, this had
been set to <code>max(2, getOption("digits"))</code>, internally.</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to use to estimate quantiles.</p>
</td></tr>
<tr><td><code id="quantile.ebnm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the posterior sampler
function. Since <code>ebnm_horseshoe</code> returns an MCMC sampler, it takes
parameter <code>burn</code>, the number of burn-in samples to discard.  At
present, no other samplers take any additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns giving quantiles for each posterior
<code class="reqn">\theta_i \mid x_i, s_i, g</code>.
</p>

<hr>
<h2 id='residuals.ebnm'>Calculate residuals for a fitted EBNM model</h2><span id='topic+residuals.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+residuals">residuals</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
Calculates &quot;residuals&quot; <code class="reqn">x_i - \hat{\theta_i}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="residuals.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='simulate.ebnm'>Sample from the posterior of a fitted EBNM model</h2><span id='topic+simulate.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+simulate">simulate</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
Extracts the posterior sampler from an object of class <code><a href="#topic+ebnm">ebnm</a></code>
and returns a specified number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="simulate.ebnm_+3A_nsim">nsim</code></td>
<td>
<p>The number of posterior samples to return per observation.</p>
</td></tr>
<tr><td><code id="simulate.ebnm_+3A_seed">seed</code></td>
<td>
<p>Either <code>NULL</code> or an integer that will be used in a call to
<code>set.seed</code> before simulating. If set, the value is saved as the
<code>"seed"</code> attribute of the returned value. The default, <code>NULL</code>,
will not change the random generator state.</p>
</td></tr>
<tr><td><code id="simulate.ebnm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the posterior sampler
function. Since <code>ebnm_horseshoe</code> returns an MCMC sampler, it takes
parameter <code>burn</code>, the number of burn-in samples to discard.  At
present, no other samplers take any additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of posterior samples, with rows corresponding to
distinct samples and columns corresponding to observations.
</p>

<hr>
<h2 id='summary.ebnm'>Summarize an ebnm object</h2><span id='topic+summary.ebnm'></span>

<h3>Description</h3>

<p>The <code>summary</code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="summary.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.ebnm</code> object.
</p>

<hr>
<h2 id='vcov.ebnm'>Extract posterior variances from a fitted EBNM model</h2><span id='topic+vcov.ebnm'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+vcov">vcov</a></code> method for class <code><a href="#topic+ebnm">ebnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebnm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.ebnm_+3A_object">object</code></td>
<td>
<p>The fitted <code>ebnm</code> object.</p>
</td></tr>
<tr><td><code id="vcov.ebnm_+3A_...">...</code></td>
<td>
<p>Not used. Included for consistency as an S3 method.</p>
</td></tr>
</table>

<hr>
<h2 id='wOBA'>2022 MLB wOBA Data</h2><span id='topic+wOBA'></span>

<h3>Description</h3>

<p>Weighted on-base average (wOBA) for hitters from the
2022 Major League Baseball (MLB) season. Standard errors are
calculated by modeling hitting outcomes as multinomially
distributed and plugging in empirical proportions as the &ldquo;true&rdquo;
outcome probabilities. To handle small sample sizes, standard
errors are lower bounded by the errors that would be obtained using
league-wide proportions rather than the plug-in estimates.
</p>


<h3>Format</h3>

<p><code>wOBA</code> is a data frame with 688 rows and 6 columns:
</p>

<dl>
<dt>FanGraphsID</dt><dd><p>The hitter's FanGraphs identifier.</p>
</dd>
<dt>Name</dt><dd><p>The hitter's name.</p>
</dd>
<dt>Team</dt><dd><p>The hitter's MLB team (given as a three-letter code) or
<code>NA</code> if the hitter played for multiple teams.</p>
</dd>
<dt>PA</dt><dd><p>The hitter's number of plate appearances over the 2022 season.</p>
</dd>
<dt>x</dt><dd><p>The hitter's wOBA over the 2022 season.</p>
</dd>
<dt>s</dt><dd><p>The standard error for the hitter's wOBA.</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://fangraphs.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wOBA)
summary(wOBA)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
