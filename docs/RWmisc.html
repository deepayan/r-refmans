<!DOCTYPE html><html><head><title>Help for package RWmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RWmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dms2dd'><p>Convert from degrees, minutes, and seconds to decimal degrees</p></a></li>
<li><a href='#gadm.extract'><p>Extract layers by country from GADM GeoPackage file</p></a></li>
<li><a href='#overlap.weight'><p>Weight Raster Cells by Overlapping Polygons</p></a></li>
<li><a href='#point.poly.dist'><p>Point-Polygon Distances</p></a></li>
<li><a href='#projectUTM'><p>Project to UTM</p></a></li>
<li><a href='#RWmisc-package'><p>RWmisc: Miscellaneous Spatial Functions</p></a></li>
<li><a href='#theme_rw'><p>Blank Theme</p></a></li>
<li><a href='#UTM.functions'><p>UTM Convenience Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Spatial Functions</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-14</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains convenience functions for working with spatial data across
    multiple UTM zones, raster-vector operations common in the analysis of 
    conflict data, and converting degrees, minutes, and seconds latitude and
    longitude coordinates to decimal degrees.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, sp, raster, units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, geosphere, lwgeom, microbenchmark, knitr, rmarkdown,
testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jayrobwilliams/RWmisc">https://github.com/jayrobwilliams/RWmisc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jayrobwilliams/RWmisc/issues">https://github.com/jayrobwilliams/RWmisc/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-14 18:59:36 UTC; rob</td>
</tr>
<tr>
<td>Author:</td>
<td>Rob Williams <a href="https://orcid.org/0000-0001-9259-3883"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Williams &lt;jayrobwilliams@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-14 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dms2dd'>Convert from degrees, minutes, and seconds to decimal degrees</h2><span id='topic+dms2dd'></span>

<h3>Description</h3>

<p>Convert latitudes and longitudes from degrees, minutes, and seconds to
decimal degrees for conversion to spatial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dms2dd(lon, lat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dms2dd_+3A_lon">lon</code></td>
<td>
<p>a character vector of longitude coordinates in degrees, minutes,
and seconds; see <code>details</code></p>
</td></tr>
<tr><td><code id="dms2dd_+3A_lat">lat</code></td>
<td>
<p>a character vector of latitude coordinates in degrees, minutes,
and seconds; see <code>details</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lon</code> and <code>lat</code> are expected to be in the format
<code style="white-space: pre;">&#8288;"degrees° minutes' seconds" (direction)"&#8288;</code> where <code>direction</code> is optional. If
<code>direction</code> is not present, <code>dms2dd</code> will use negative signs (<code>-</code>) to
determine positioning of coordinates.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n * 2</code> matrix where <em>n</em> is the length of <code>lon</code> and <code>lat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll &lt;- data.frame(lon = c("-122° 19' 55\"",
                         "71° 3' 32\" W"),
                 lat = c("47° 36' 22\"",
                         "42° 21' 36\" N"),
                 stringsAsFactors = FALSE)
dms2dd(ll[, 'lon'], ll[, 'lat'])
</code></pre>

<hr>
<h2 id='gadm.extract'>Extract layers by country from GADM GeoPackage file</h2><span id='topic+gadm.extract'></span>

<h3>Description</h3>

<p>Extract one or more levels of administrative unit geometries from the GADM
database in GeoPackage format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadm.extract(input, output, countries = NULL, level = 0:5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadm.extract_+3A_input">input</code></td>
<td>
<p>GeoPackage file to read from</p>
</td></tr>
<tr><td><code id="gadm.extract_+3A_output">output</code></td>
<td>
<p>name of file to save output to</p>
</td></tr>
<tr><td><code id="gadm.extract_+3A_countries">countries</code></td>
<td>
<p>country or countries to limit results to, if <code>NULL</code> returns
all countries</p>
</td></tr>
<tr><td><code id="gadm.extract_+3A_level">level</code></td>
<td>
<p>level(s) of administrative units 0:5 to extract; note not all
levels are defined for all countries</p>
</td></tr>
<tr><td><code id="gadm.extract_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="sf.html#topic+st_write">sf::st_write()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to extract subsets of the
<a href="https://gadm.org/">Database of Global Administrative Areas (GADM)</a>. It uses
the version of the database in GeoPackage format that provides one layer for
each level of administrative division, available at
<a href="https://gadm.org/download_world.html">https://gadm.org/download_world.html</a>.
The current version of this file is <code>gadm36_levels.gpkg</code>. It is intended
for programmatic and reproducible subsetting of the database without
requiring the user to individually download specific country data files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## extract
gadm.extract("gadm36_levels.gpkg", "Nordics.gpkg",
             c("Denmark", "Finland", "Iceland", "Norway", "Sweden"),
             level = 0:2)

## add layers 3 and 4, use delete_layer = TRUE to rewrite existing layers
gadm.extract("gadm36_levels.gpkg", "Nordics.gpkg",
             c("Denmark", "Finland", "Iceland", "Norway", "Sweden"),
             level = 0:4, delete_layer = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='overlap.weight'>Weight Raster Cells by Overlapping Polygons</h2><span id='topic+overlap.weight'></span>

<h3>Description</h3>

<p>Weight raster cells by overlapping polygons to avoid over-counting when aggregating by polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.weight(raster, polygons, count = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap.weight_+3A_raster">raster</code></td>
<td>
<p>a RasterLayer object.</p>
</td></tr>
<tr><td><code id="overlap.weight_+3A_polygons">polygons</code></td>
<td>
<p>a SpatialPolygons, SpatialPolygonsDataFrame, or simple feature
collection with at least two features. The function will still work with only
one polygon, but values will be unchanged, and the result will be equivalent
to <code>mask(raster, polygons)</code>.</p>
</td></tr>
<tr><td><code id="overlap.weight_+3A_count">count</code></td>
<td>
<p>a logical indicating whether to return a raster with the count of
polygons intersecting each cell, or a raster with original values weighted by
1/number of intersecting polygons.</p>
</td></tr>
<tr><td><code id="overlap.weight_+3A_warn">warn</code></td>
<td>
<p>include warnings? Most common is that the returned raster will be
an intersection of the raster and the polygons. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a raster and a set of polygons as arguments.
It counts the number of polygons that intersect each raster cell. It can
return either a raster with the count of the number of intersecting polygons
as cell values or the original raster with cell values weighted by 1 / the
number of intersecting polygons (the default behavior). Cells that do not
intersect any polygons will receive a value of <code>NA</code>. If the extent of the
polygons is less than the extent of the raster, then the function will warn
that it is cropping the raster to the polygons' extent.
</p>


<h3>Value</h3>

<p>a RasterLayer object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(raster)
polys_t &lt;- st_sfc(list(st_polygon(list(rbind(c(2,2), c(2,6),
                                             c(6,6), c(6,2),
                                             c(2, 2)))),
                       st_polygon(list(rbind(c(8,8), c(4,8),
                                             c(4,4), c(8,4),
                                             c(8,8))))),
                  crs = st_crs('OGC:CRS84'))
raster_t &lt;- raster(nrows = 10, ncols = 10, xmn = 0,
                   xmx = 10, ymn = 0, ymx = 10,
                   vals = 1:100,
                   crs = CRS(st_crs(polys_t)$proj4string))
overlap.weight(raster_t, polys_t)
</code></pre>

<hr>
<h2 id='point.poly.dist'>Point-Polygon Distances</h2><span id='topic+point.poly.dist'></span>

<h3>Description</h3>

<p>Calculate the maximum or minimum possible distance from a point to the edge
of a given polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point.poly.dist(point, poly, max = TRUE, by_element = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point.poly.dist_+3A_point">point</code></td>
<td>
<p>A simplefeatures object of class point.</p>
</td></tr>
<tr><td><code id="point.poly.dist_+3A_poly">poly</code></td>
<td>
<p>A simplefeatures object of class polygon or multipolygon.</p>
</td></tr>
<tr><td><code id="point.poly.dist_+3A_max">max</code></td>
<td>
<p>Logical; return maximum or minimum distance? default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="point.poly.dist_+3A_by_element">by_element</code></td>
<td>
<p>Logical; return total maximum or minimum, or for each input
point? default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum or minimum distance between a point and a polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
polys &lt;- st_sfc(st_polygon(list(rbind(c(0,0), c(0,1), c(1,1), c(1,0), c(0,0)))),
crs = st_crs('OGC:CRS84'))
points &lt;- st_sfc(st_multipoint(rbind(c(.25, .5), c(.75, .5), c(.5, .5))),
                 crs = st_crs('OGC:CRS84'))
point.poly.dist(points, polys)
</code></pre>

<hr>
<h2 id='projectUTM'>Project to UTM</h2><span id='topic+projectUTM'></span><span id='topic+projectUTM.sf'></span><span id='topic+projectUTM.sfc'></span><span id='topic+projectUTM.SpatialPointsDataFrame'></span><span id='topic+projectUTM.SpatialPoints'></span><span id='topic+projectUTM.SpatialPolygonsDataFrame'></span><span id='topic+projectUTM.SpatialPolygons'></span>

<h3>Description</h3>

<p>Project an object in latitude/longitude to UTM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectUTM(x)

## S3 method for class 'sf'
projectUTM(x)

## S3 method for class 'sfc'
projectUTM(x)

## S3 method for class 'SpatialPointsDataFrame'
projectUTM(x)

## S3 method for class 'SpatialPoints'
projectUTM(x)

## S3 method for class 'SpatialPolygonsDataFrame'
projectUTM(x)

## S3 method for class 'SpatialPolygons'
projectUTM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectUTM_+3A_x">x</code></td>
<td>
<p>An <code>sf</code> or <code>sp</code> object in latitude-longitude CRS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> or <code>sp</code> object projected to UTM CRS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package="sf"))
st_crs(projectUTM(nc))
</code></pre>

<hr>
<h2 id='RWmisc-package'>RWmisc: Miscellaneous Spatial Functions</h2><span id='topic+RWmisc'></span><span id='topic+RWmisc-package'></span>

<h3>Description</h3>

<p>Contains convenience functions for working with spatial data across
multiple UTM zones, raster-vector operations common in the analysis of 
conflict data, and converting degrees, minutes, and seconds latitude and
longitude coordinates to decimal degrees.
</p>


<h3>Details</h3>

<p>Convenience functions for working with spatial data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rob Williams <a href="mailto:jayrobwilliams@gmail.com">jayrobwilliams@gmail.com</a> (<a href="https://orcid.org/0000-0001-9259-3883">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jayrobwilliams/RWmisc">https://github.com/jayrobwilliams/RWmisc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jayrobwilliams/RWmisc/issues">https://github.com/jayrobwilliams/RWmisc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='theme_rw'>Blank Theme</h2><span id='topic+theme_rw'></span>

<h3>Description</h3>

<p>A ggplot theme with no grid elements or gray background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_rw()
</code></pre>


<h3>Value</h3>

<p>A ggplot <a href="ggplot2.html#topic+theme">theme</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot2::ggplot(mtcars, ggplot2::aes(x = hp, y = mpg)) +
ggplot2::geom_point() +
theme_rw()
</code></pre>

<hr>
<h2 id='UTM.functions'>UTM Convenience Functions</h2><span id='topic+UTM.functions'></span><span id='topic+long2UTM'></span><span id='topic+UTMzones'></span><span id='topic+chooseUTM'></span>

<h3>Description</h3>

<p>Functions for converting latitude-longitude data to UTM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2UTM(long)

UTMzones(long)

chooseUTM(long)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UTM.functions_+3A_long">long</code></td>
<td>
<p>A vector of longitude values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UTM vector of zone numbers.
</p>
<p>UTM vector of zone numbers.
</p>
<p>UTM zone number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long2UTM(c(-90, 0, 90))
UTMzones(c(-90, 90, 90))
chooseUTM(c(-90, -80, -70))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
