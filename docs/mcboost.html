<!DOCTYPE html><html><head><title>Help for package mcboost</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcboost}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcboost-package'><p>mcboost: Multi-Calibration Boosting</p></a></li>
<li><a href='#AuditorFitter'><p>AuditorFitter Abstract Base Class</p></a></li>
<li><a href='#CVLearnerAuditorFitter'><p>Cross-validated AuditorFitter from a Learner</p></a></li>
<li><a href='#LearnerAuditorFitter'><p>Create an AuditorFitter from a Learner</p></a></li>
<li><a href='#MCBoost'><p>Multi-Calibration Boosting</p></a></li>
<li><a href='#mlr_pipeops_mcboost'><p>Multi-Calibrate a Learner's Prediction</p></a></li>
<li><a href='#mlr3_init_predictor'><p>Create an initial predictor function from a trained mlr3 learner</p></a></li>
<li><a href='#one_hot'><p>One-hot encode a factor variable</p></a></li>
<li><a href='#ppl_mcboost'><p>Multi-calibration pipeline</p></a></li>
<li><a href='#SubgroupAuditorFitter'><p>Static AuditorFitter based on Subgroups</p></a></li>
<li><a href='#SubpopAuditorFitter'><p>Static AuditorFitter based on Subpopulations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Calibration Boosting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements 'Multi-Calibration Boosting' (2018) <a href="https://proceedings.mlr.press/v80/hebert-johnson18a.html">https://proceedings.mlr.press/v80/hebert-johnson18a.html</a> and
    'Multi-Accuracy Boosting' (2019) &lt;<a href="https://doi.org/10.48550%2FarXiv.1805.12317">doi:10.48550/arXiv.1805.12317</a>&gt; for the multi-calibration of a machine learning model's prediction.
    'MCBoost' updates predictions for sub-groups in an iterative fashion in order to mitigate biases like poor calibration or large accuracy differences across subgroups.
    Multi-Calibration works best in scenarios where the underlying data &amp; labels are unbiased, but resulting models are.
    This is often the case, e.g. when an algorithm fits a majority population while ignoring or under-fitting minority populations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlr-org/mcboost">https://github.com/mlr-org/mcboost</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mcboost/issues">https://github.com/mlr-org/mcboost/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, checkmate (&ge; 2.0.0), data.table (&ge; 1.13.6), mlr3
(&ge; 0.10), mlr3misc (&ge; 0.8.0), mlr3pipelines (&ge; 0.3.0), R6
(&ge; 2.4.1), rmarkdown, rpart, glmnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl, lgr, formattable, tidyverse, PracTools, mlr3learners,
mlr3oml, neuralnet, paradox, knitr, ranger, xgboost, covr,
testthat (&ge; 3.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AuditorFitters.R' 'MCBoost.R' 'PipelineMCBoost.R'
'PipeOpLearnerPred.R' 'PipeOpMCBoost.R' 'Predictor.R'
'ProbRange.R' 'helpers.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-10 19:32:07 UTC; sebi</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Pfisterer <a href="https://orcid.org/0000-0001-8867-762X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Susanne Dandl <a href="https://orcid.org/0000-0003-4324-4163"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christoph Kern <a href="https://orcid.org/0000-0001-7363-4299"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Carolin Becker [ctb],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sebastian Fischer [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Fischer &lt;sebf.fischer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-12 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcboost-package'>mcboost: Multi-Calibration Boosting</h2><span id='topic+mcboost'></span><span id='topic+mcboost-package'></span>

<h3>Description</h3>

<p>Implements 'Multi-Calibration Boosting' (2018) <a href="https://proceedings.mlr.press/v80/hebert-johnson18a.html">https://proceedings.mlr.press/v80/hebert-johnson18a.html</a> and 'Multi-Accuracy Boosting' (2019) <a href="https://doi.org/10.48550/arXiv.1805.12317">doi:10.48550/arXiv.1805.12317</a> for the multi-calibration of a machine learning model's prediction. 'MCBoost' updates predictions for sub-groups in an iterative fashion in order to mitigate biases like poor calibration or large accuracy differences across subgroups. Multi-Calibration works best in scenarios where the underlying data &amp; labels are unbiased, but resulting models are. This is often the case, e.g. when an algorithm fits a majority population while ignoring or under-fitting minority populations.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sebastian Fischer <a href="mailto:sebf.fischer@gmail.com">sebf.fischer@gmail.com</a> [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Florian Pfisterer <a href="mailto:pfistererf@googlemail.com">pfistererf@googlemail.com</a> (<a href="https://orcid.org/0000-0001-8867-762X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Susanne Dandl <a href="mailto:susanne.dandl@stat.uni-muenchen.de">susanne.dandl@stat.uni-muenchen.de</a> (<a href="https://orcid.org/0000-0003-4324-4163">ORCID</a>) [contributor]
</p>
</li>
<li><p> Christoph Kern <a href="mailto:c.kern@uni-mannheim.de">c.kern@uni-mannheim.de</a> (<a href="https://orcid.org/0000-0001-7363-4299">ORCID</a>) [contributor]
</p>
</li>
<li><p> Carolin Becker [contributor]
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Kim et al., 2019: Multiaccuracy: Black-Box Post-Processing for Fairness in Classification.
Hebert-Johnson et al., 2018: Multicalibration: Calibration for the (Computationally-Identifiable) Masses.
Pfisterer F, Kern C, Dandl S, Sun M, Kim M, Bischl B (2021).
&ldquo;mcboost: Multi-Calibration Boosting for R.&rdquo;
<em>Journal of Open Source Software</em>, <b>6</b>(64), 3453.
<a href="https://doi.org/10.21105/joss.03453">doi:10.21105/joss.03453</a>, <a href="https://joss.theoj.org/papers/10.21105/joss.03453">https://joss.theoj.org/papers/10.21105/joss.03453</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlr-org/mcboost">https://github.com/mlr-org/mcboost</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mcboost/issues">https://github.com/mlr-org/mcboost/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AuditorFitter'>AuditorFitter Abstract Base Class</h2><span id='topic+AuditorFitter'></span>

<h3>Description</h3>

<p>Defines an <code>AuditorFitter</code> abstract base class.
</p>


<h3>Value</h3>

<p><code>list</code> with items<br />
</p>

<ul>
<li> <p><code>corr</code>: pseudo-correlation between residuals and learner prediction.
</p>
</li>
<li> <p><code>l</code>: the trained learner.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AuditorFitter-new"><code>AuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AuditorFitter-fit_to_resid"><code>AuditorFitter$fit_to_resid()</code></a>
</p>
</li>
<li> <p><a href="#method-AuditorFitter-fit"><code>AuditorFitter$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-AuditorFitter-clone"><code>AuditorFitter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code><a href="#topic+AuditorFitter">AuditorFitter</a></code>.
This is an abstract base class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AuditorFitter$new()</pre></div>


<hr>
<a id="method-AuditorFitter-fit_to_resid"></a>



<h4>Method <code>fit_to_resid()</code></h4>

<p>Fit to residuals.
</p>


<h5>Usage</h5>

<div class="r"><pre>AuditorFitter$fit_to_resid(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuditorFitter-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit (mostly used internally, use <code>fit_to_resid</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>AuditorFitter$fit(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CVLearnerAuditorFitter'>Cross-validated AuditorFitter from a Learner</h2><span id='topic+CVLearnerAuditorFitter'></span><span id='topic+CVTreeAuditorFitter'></span><span id='topic+CVRidgeAuditorFitter'></span>

<h3>Description</h3>

<p>CVLearnerAuditorFitter returns the cross-validated predictions
instead of the in-sample predictions.
</p>
<p>Available data is cut into complementary subsets (folds).
For each subset out-of-sample predictions are received by training a model
on all other subsets and predicting afterwards on the left-out subset.
</p>


<h3>Value</h3>

<p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code><br />
</p>
<p><code>list</code> with items<br />
</p>

<ul>
<li> <p><code>corr</code>: pseudo-correlation between residuals and learner prediction.
</p>
</li>
<li> <p><code>l</code>: the trained learner.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>CVTreeAuditorFitter</code>: Cross-Validated auditor based on rpart
</p>
</li>
<li> <p><code>CVRidgeAuditorFitter</code>: Cross-Validated auditor based on glmnet
</p>
</li></ul>


<h3>Super class</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code>CVLearnerAuditorFitter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>learner</code></dt><dd><p><code>CVLearnerPredictor</code><br />
Learner used for fitting residuals.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CVLearnerAuditorFitter-new"><code>CVLearnerAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CVLearnerAuditorFitter-fit"><code>CVLearnerAuditorFitter$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-CVLearnerAuditorFitter-clone"><code>CVLearnerAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CVLearnerAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define a <code>CVAuditorFitter</code> from a learner.
Available instantiations:<br /> <code><a href="#topic+CVTreeAuditorFitter">CVTreeAuditorFitter</a></code> (rpart) and
<code><a href="#topic+CVRidgeAuditorFitter">CVRidgeAuditorFitter</a></code> (glmnet).
See <code><a href="mlr3pipelines.html#topic+mlr_pipeops_learner_cv">mlr3pipelines::PipeOpLearnerCV</a></code> for more information on
cross-validated learners.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVLearnerAuditorFitter$new(learner, folds = 3L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner</code></dt><dd><p><code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code><br />
Regression Learner to use.</p>
</dd>
<dt><code>folds</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Number of folds to use for PipeOpLearnerCV. Defaults to 3.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CVLearnerAuditorFitter-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the cross-validated learner and compute correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>CVLearnerAuditorFitter$fit(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CVLearnerAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVLearnerAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code><a href="#topic+CVLearnerAuditorFitter">mcboost::CVLearnerAuditorFitter</a></code> -&gt; <code>CVTreeAuditorFitter</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CVTreeAuditorFitter-new"><code>CVTreeAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CVTreeAuditorFitter-clone"><code>CVTreeAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="CVLearnerAuditorFitter" data-id="fit"><a href='../../mcboost/html/CVLearnerAuditorFitter.html#method-CVLearnerAuditorFitter-fit'><code>mcboost::CVLearnerAuditorFitter$fit()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CVTreeAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define a cross-validated AuditorFitter from a rpart learner
See <code><a href="mlr3pipelines.html#topic+mlr_pipeops_learner_cv">mlr3pipelines::PipeOpLearnerCV</a></code> for more information on
cross-validated learners.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVTreeAuditorFitter$new()</pre></div>


<hr>
<a id="method-CVTreeAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVTreeAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code><a href="#topic+CVLearnerAuditorFitter">mcboost::CVLearnerAuditorFitter</a></code> -&gt; <code>CVRidgeAuditorFitter</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CVRidgeAuditorFitter-new"><code>CVRidgeAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CVRidgeAuditorFitter-clone"><code>CVRidgeAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="CVLearnerAuditorFitter" data-id="fit"><a href='../../mcboost/html/CVLearnerAuditorFitter.html#method-CVLearnerAuditorFitter-fit'><code>mcboost::CVLearnerAuditorFitter$fit()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CVRidgeAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define a cross-validated AuditorFitter from a glmnet learner.
See <code><a href="mlr3pipelines.html#topic+mlr_pipeops_learner_cv">mlr3pipelines::PipeOpLearnerCV</a></code> for more information on
cross-validated learners.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVRidgeAuditorFitter$new()</pre></div>


<hr>
<a id="method-CVRidgeAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CVRidgeAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other AuditorFitter: 
<code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>
<p>Other AuditorFitter: 
<code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>
<p>Other AuditorFitter: 
<code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>

<hr>
<h2 id='LearnerAuditorFitter'>Create an AuditorFitter from a Learner</h2><span id='topic+LearnerAuditorFitter'></span><span id='topic+TreeAuditorFitter'></span><span id='topic+RidgeAuditorFitter'></span>

<h3>Description</h3>

<p>Instantiates an AuditorFitter that trains a <code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code>
on the data.
</p>


<h3>Value</h3>

<p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code><br />
</p>
<p><code>list</code> with items<br />
</p>

<ul>
<li> <p><code>corr</code>: pseudo-correlation between residuals and learner prediction.
</p>
</li>
<li> <p><code>l</code>: the trained learner.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>TreeAuditorFitter</code>: Learner auditor based on rpart
</p>
</li>
<li> <p><code>RidgeAuditorFitter</code>: Learner auditor based on glmnet
</p>
</li></ul>


<h3>Super class</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code>LearnerAuditorFitter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>learner</code></dt><dd><p><code>LearnerPredictor</code><br />
Learner used for fitting residuals.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LearnerAuditorFitter-new"><code>LearnerAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LearnerAuditorFitter-fit"><code>LearnerAuditorFitter$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-LearnerAuditorFitter-clone"><code>LearnerAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LearnerAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define an <code>AuditorFitter</code> from a Learner.
Available instantiations:<br /> <code><a href="#topic+TreeAuditorFitter">TreeAuditorFitter</a></code> (rpart) and
<code><a href="#topic+RidgeAuditorFitter">RidgeAuditorFitter</a></code> (glmnet).
</p>


<h5>Usage</h5>

<div class="r"><pre>LearnerAuditorFitter$new(learner)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner</code></dt><dd><p><code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code><br />
Regression learner to use.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LearnerAuditorFitter-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the learner and compute correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>LearnerAuditorFitter$fit(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LearnerAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LearnerAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code><a href="#topic+LearnerAuditorFitter">mcboost::LearnerAuditorFitter</a></code> -&gt; <code>TreeAuditorFitter</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TreeAuditorFitter-new"><code>TreeAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TreeAuditorFitter-clone"><code>TreeAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="LearnerAuditorFitter" data-id="fit"><a href='../../mcboost/html/LearnerAuditorFitter.html#method-LearnerAuditorFitter-fit'><code>mcboost::LearnerAuditorFitter$fit()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TreeAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define a AuditorFitter from a rpart learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeAuditorFitter$new()</pre></div>


<hr>
<a id="method-TreeAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code><a href="#topic+LearnerAuditorFitter">mcboost::LearnerAuditorFitter</a></code> -&gt; <code>RidgeAuditorFitter</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RidgeAuditorFitter-new"><code>RidgeAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RidgeAuditorFitter-clone"><code>RidgeAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="LearnerAuditorFitter" data-id="fit"><a href='../../mcboost/html/LearnerAuditorFitter.html#method-LearnerAuditorFitter-fit'><code>mcboost::LearnerAuditorFitter$fit()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RidgeAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Define a AuditorFitter from a glmnet learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>RidgeAuditorFitter$new()</pre></div>


<hr>
<a id="method-RidgeAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RidgeAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other AuditorFitter: 
<code><a href="#topic+CVLearnerAuditorFitter">CVLearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>
<p>Other AuditorFitter: 
<code><a href="#topic+CVLearnerAuditorFitter">CVLearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>
<p>Other AuditorFitter: 
<code><a href="#topic+CVLearnerAuditorFitter">CVLearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>

<hr>
<h2 id='MCBoost'>Multi-Calibration Boosting</h2><span id='topic+MCBoost'></span>

<h3>Description</h3>

<p>Implements Multi-Calibration Boosting by Hebert-Johnson et al. (2018) and
Multi-Accuracy Boosting by Kim et al. (2019) for the multi-calibration of a
machine learning model's prediction.
Multi-Calibration works best in scenarios where the underlying data &amp; labels are unbiased
but a bias is introduced within the algorithm's fitting procedure. This is often the case,
e.g. when an algorithm fits a majority population while ignoring or under-fitting minority
populations.<br />
Expects initial models that fit binary outcomes or continuous outcomes with
predictions that are in (or scaled to) the 0-1 range.
The method defaults to <code style="white-space: pre;">&#8288;Multi-Accuracy Boosting&#8288;</code> as described in Kim et al. (2019).
In order to obtain behaviour as described in Hebert-Johnson et al. (2018) set
<code>multiplicative=FALSE</code> and <code>num_buckets</code> to 10.
</p>

<p>For additional details, please refer to the relevant publications:
</p>
<ul>
<li><p>Hebert-Johnson et al., 2018. Multicalibration: Calibration for the (Computationally-Identifiable) Masses.
Proceedings of the 35th International Conference on Machine Learning, PMLR 80:1939-1948.
https://proceedings.mlr.press/v80/hebert-johnson18a.html.
</p>
</li>
<li><p>Kim et al., 2019. Multiaccuracy: Black-Box Post-Processing for Fairness in Classification.
Proceedings of the 2019 AAAI/ACM Conference on AI, Ethics, and Society (AIES '19).
Association for Computing Machinery, New York, NY, USA, 247–254.
https://dl.acm.org/doi/10.1145/3306618.3314287
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>max_iter</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
The maximum number of iterations of the multi-calibration/multi-accuracy method.</p>
</dd>
<dt><code>alpha</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> <br />
Accuracy parameter that determines the stopping condition.</p>
</dd>
<dt><code>eta</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> <br />
Parameter for multiplicative weight update (step size).</p>
</dd>
<dt><code>num_buckets</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
The number of buckets to split into in addition to using the whole sample.</p>
</dd>
<dt><code>bucket_strategy</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
Currently only supports &quot;simple&quot;, even split along probabilities.
Only relevant for <code>num_buckets</code> &gt; 1.</p>
</dd>
<dt><code>rebucket</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should buckets be re-calculated at each iteration?</p>
</dd>
<dt><code>eval_fulldata</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should auditor be evaluated on the full data?</p>
</dd>
<dt><code>partition</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
True/False flag for whether to split up predictions by their &quot;partition&quot;
(e.g., predictions less than 0.5 and predictions greater than 0.5).</p>
</dd>
<dt><code>multiplicative</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Specifies the strategy for updating the weights (multiplicative weight vs additive).</p>
</dd>
<dt><code>iter_sampling</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
Specifies the strategy to sample the validation data for each iteration.</p>
</dd>
<dt><code>auditor_fitter</code></dt><dd><p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code> <br />
Specifies the type of model used to fit the residuals.</p>
</dd>
<dt><code>predictor</code></dt><dd><p><code><a href="base.html#topic+function">function</a></code> <br />
Initial predictor function.</p>
</dd>
<dt><code>iter_models</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Cumulative list of fitted models.</p>
</dd>
<dt><code>iter_partitions</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Cumulative list of data partitions for models.</p>
</dd>
<dt><code>iter_corr</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Auditor correlation in each iteration.</p>
</dd>
<dt><code>auditor_effects</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Auditor effect in each iteration.</p>
</dd>
<dt><code>bucket_strategies</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
Possible bucket_strategies.</p>
</dd>
<dt><code>weight_degree</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
Weighting degree for low-degree multi-calibration.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MCBoost-new"><code>MCBoost$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MCBoost-multicalibrate"><code>MCBoost$multicalibrate()</code></a>
</p>
</li>
<li> <p><a href="#method-MCBoost-predict_probs"><code>MCBoost$predict_probs()</code></a>
</p>
</li>
<li> <p><a href="#method-MCBoost-auditor_effect"><code>MCBoost$auditor_effect()</code></a>
</p>
</li>
<li> <p><a href="#method-MCBoost-print"><code>MCBoost$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MCBoost-clone"><code>MCBoost$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MCBoost-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a multi-calibration instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$new(
  max_iter = 5,
  alpha = 1e-04,
  eta = 1,
  num_buckets = 2,
  partition = ifelse(num_buckets &gt; 1, TRUE, FALSE),
  bucket_strategy = "simple",
  rebucket = FALSE,
  eval_fulldata = FALSE,
  multiplicative = TRUE,
  auditor_fitter = NULL,
  subpops = NULL,
  default_model_class = ConstantPredictor,
  init_predictor = NULL,
  iter_sampling = "none",
  weight_degree = 1L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_iter</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
The maximum number of iterations of the multi-calibration/multi-accuracy method.
Default <code>5L</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> <br />
Accuracy parameter that determines the stopping condition. Default <code>1e-4</code>.</p>
</dd>
<dt><code>eta</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> <br />
Parameter for multiplicative weight update (step size). Default <code>1.0</code>.</p>
</dd>
<dt><code>num_buckets</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
The number of buckets to split into in addition to using the whole sample. Default <code>2L</code>.</p>
</dd>
<dt><code>partition</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
True/False flag for whether to split up predictions by their &quot;partition&quot;
(e.g., predictions less than 0.5 and predictions greater than 0.5).
Defaults to <code>TRUE</code> (multi-accuracy boosting).</p>
</dd>
<dt><code>bucket_strategy</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
Currently only supports &quot;simple&quot;, even split along probabilities.
Only taken into account for <code>num_buckets</code> &gt; 1.</p>
</dd>
<dt><code>rebucket</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should buckets be re-done at each iteration? Default <code>FALSE</code>.</p>
</dd>
<dt><code>eval_fulldata</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should the auditor be evaluated on the full data or on the respective bucket for determining
the stopping criterion? Default <code>FALSE</code>, auditor is only evaluated on the bucket.
This setting keeps the implementation closer to the Algorithm proposed in the corresponding
multi-accuracy paper (Kim et al., 2019) where auditor effects are computed across the full
sample (i.e. eval_fulldata = TRUE).</p>
</dd>
<dt><code>multiplicative</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Specifies the strategy for updating the weights (multiplicative weight vs additive).
Defaults to <code>TRUE</code> (multi-accuracy boosting). Set to <code>FALSE</code> for multi-calibration.</p>
</dd>
<dt><code>auditor_fitter</code></dt><dd><p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code>|<code><a href="base.html#topic+character">character</a></code>|<code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code> <br />
Specifies the type of model used to fit the
residuals. The default is <code><a href="#topic+RidgeAuditorFitter">RidgeAuditorFitter</a></code>.
Can be a <code>character</code>, the name of a <code><a href="#topic+AuditorFitter">AuditorFitter</a></code>, a <code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code> that is then
auto-converted into a <code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code> or a custom <code><a href="#topic+AuditorFitter">AuditorFitter</a></code>.</p>
</dd>
<dt><code>subpops</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Specifies a collection of characteristic attributes
and the values they take to define subpopulations
e.g. list(age = c('20-29','30-39','40+'), nJobs = c(0,1,2,'3+'), ,..).</p>
</dd>
<dt><code>default_model_class</code></dt><dd><p><code>Predictor</code> <br />
The class of the model that should be used as the init predictor model if
<code>init_predictor</code> is not specified. Defaults to <code>ConstantPredictor</code> which
predicts a constant value.</p>
</dd>
<dt><code>init_predictor</code></dt><dd><p><code><a href="base.html#topic+function">function</a></code>|<code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code> <br />
The initial predictor function to use (i.e., if the user has a pretrained model).
If a <code>mlr3</code> <code>Learner</code> is passed, it will be autoconverted using <code>mlr3_init_predictor</code>.
This requires the <code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code> to be trained.</p>
</dd>
<dt><code>iter_sampling</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
How to sample the validation data for each iteration?
Can be <code>bootstrap</code>, <code>split</code> or <code>none</code>.<br />
&quot;split&quot; splits the data into <code>max_iter</code> parts and validates on each sample in each iteration.<br />
&quot;bootstrap&quot; uses a new bootstrap sample in each iteration.<br />
&quot;none&quot; uses the same dataset in each iteration.</p>
</dd>
<dt><code>weight_degree</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
Weighting degree for low-degree multi-calibration. Initialized to 1, which applies constant weighting with 1.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MCBoost-multicalibrate"></a>



<h4>Method <code>multicalibrate()</code></h4>

<p>Run multi-calibration.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$multicalibrate(data, labels, predictor_args = NULL, audit = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>labels</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
One-hot encoded labels (of same length as data).</p>
</dd>
<dt><code>predictor_args</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Arguments passed on to <code>init_predictor</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>audit</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Perform auditing? Initialized to <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Params passed on to other methods.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code>
</p>


<hr>
<a id="method-MCBoost-predict_probs"></a>



<h4>Method <code>predict_probs()</code></h4>

<p>Predict a dataset with multi-calibrated predictions
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$predict_probs(x, t = Inf, predictor_args = NULL, audit = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code> <br />
Prediction data.</p>
</dd>
<dt><code>t</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
Number of multi-calibration steps to predict. Default: <code>Inf</code> (all).</p>
</dd>
<dt><code>predictor_args</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Arguments passed on to <code>init_predictor</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>audit</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should audit weights be stored? Default <code>FALSE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Params passed on to the residual prediction model's predict method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Numeric vector of multi-calibrated predictions.
</p>


<hr>
<a id="method-MCBoost-auditor_effect"></a>



<h4>Method <code>auditor_effect()</code></h4>

<p>Compute the auditor effect for each instance which are the cumulative
absolute predictions of the auditor. It indicates &quot;how much&quot;
each observation was affected by multi-calibration on average across iterations.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$auditor_effect(
  x,
  aggregate = TRUE,
  t = Inf,
  predictor_args = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code> <br />
Prediction data.</p>
</dd>
<dt><code>aggregate</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> <br />
Should the auditor effect be aggregated across iterations? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>t</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> <br />
Number of multi-calibration steps to predict. Defaults to <code>Inf</code> (all).</p>
</dd>
<dt><code>predictor_args</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Arguments passed on to <code>init_predictor</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p><code><a href="base.html#topic+any">any</a></code> <br />
Params passed on to the residual prediction model's predict method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="base.html#topic+numeric">numeric</a></code> <br />
Numeric vector of auditor effects for each row in <code>x</code>.
</p>


<hr>
<a id="method-MCBoost-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints information about multi-calibration.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code><br />
Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MCBoost-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCBoost$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># See vignette for more examples.
# Instantiate the object
## Not run: 
mc = MCBoost$new()
# Run multi-calibration on training dataset.
mc$multicalibrate(iris[1:100, 1:4], factor(sample(c("A", "B"), 100, TRUE)))
# Predict on test set
mc$predict_probs(iris[101:150, 1:4])
# Get auditor effect
mc$auditor_effect(iris[101:150, 1:4])

## End(Not run)
</code></pre>

<hr>
<h2 id='mlr_pipeops_mcboost'>Multi-Calibrate a Learner's Prediction</h2><span id='topic+mlr_pipeops_mcboost'></span><span id='topic+PipeOpLearnerPred'></span><span id='topic+PipeOpMCBoost'></span>

<h3>Description</h3>

<p><code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code> that trains a <code><a href="mlr3.html#topic+Learner">Learner</a></code> and passes its predictions forward during training and prediction.
</p>
<p>Post-process a learner prediction using multi-calibration.
For more details, please refer to <a href="https://arxiv.org/pdf/1805.12317.pdf">https://arxiv.org/pdf/1805.12317.pdf</a> (Kim et al. 2018)
or the help for <code><a href="#topic+MCBoost">MCBoost</a></code>.
If no <code>init_predictor</code> is provided, the preceding learner's predictions
corresponding to the <code>prediction</code> slot are used as an initial predictor for <code>MCBoost</code>.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> inheriting from <code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code>.
</p>
<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> inheriting from <code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpLearnerPred$new(learner, id = NULL, param_vals = list())

* `learner` :: [`Learner`][mlr3::Learner] \cr
  [`Learner`][mlr3::Learner] to  prediction, or a string identifying a
  [`Learner`][mlr3::Learner] in the [`mlr3::mlr_learners`] [`Dictionary`][mlr3misc::Dictionary].
* `id` :: `character(1)`
  Identifier of the resulting object, internally defaulting to the `id` of the [`Learner`][mlr3::Learner] being wrapped.
* `param_vals` :: named `list`\cr
  List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default `list()`.


[mlr3::Learner]: R:mlr3::Learner
[mlr3::Learner]: R:mlr3::Learner
[mlr3::Learner]: R:mlr3::Learner
[`mlr3::mlr_learners`]: R:%60mlr3::mlr_learners%60
[mlr3misc::Dictionary]: R:mlr3misc::Dictionary
[mlr3::Learner]: R:mlr3::Learner
</pre></div>
<div class="sourceCode"><pre>PipeOpMCBoost$new(id = "mcboost", param_vals = list())
</pre></div>

<ul>
<li> <p><code>id</code> :: <code>character(1)</code>
Identifier of the resulting  object, default <code>"threshold"</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br />
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction.
See <code>MCBoost</code> for a comprehensive description of all hyperparameters.
</p>
</li></ul>



<h3>Input and Output Channels</h3>

<p><code><a href="#topic+PipeOpLearnerPred">PipeOpLearnerPred</a></code> has one input channel named <code>"input"</code>, taking a <code><a href="mlr3.html#topic+Task">Task</a></code> specific to the <code><a href="mlr3.html#topic+Learner">Learner</a></code>
type given to <code>learner</code> during construction; both during training and prediction.
</p>
<p><code><a href="#topic+PipeOpLearnerPred">PipeOpLearnerPred</a></code> has one output channel named <code>"output"</code>, producing a <code><a href="mlr3.html#topic+Task">Task</a></code> specific to the <code><a href="mlr3.html#topic+Learner">Learner</a></code>
type given to <code>learner</code> during construction; both during training and prediction.
</p>
<p>During training, the input and output are <code>"data"</code> and <code>"prediction"</code>, two <code><a href="mlr3.html#topic+TaskClassif">TaskClassif</a></code>.
A <code><a href="mlr3.html#topic+PredictionClassif">PredictionClassif</a></code> is required as input and returned as output during prediction.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">&#8288;$state&#8288;</code> is a <code>MCBoost</code> Object as obtained from <code>MCBoost$new()</code>.
</p>


<h3>Parameters</h3>

<p>The <code style="white-space: pre;">&#8288;$state&#8288;</code> is set to the <code style="white-space: pre;">&#8288;$state&#8288;</code> slot of the <code><a href="mlr3.html#topic+Learner">Learner</a></code> object, together with the <code style="white-space: pre;">&#8288;$state&#8288;</code> elements inherited from
<code><a href="mlr3pipelines.html#topic+PipeOpTaskPreproc">mlr3pipelines::PipeOpTaskPreproc</a></code>. It is a named <code>list</code> with the inherited members, as well as:
</p>

<ul>
<li> <p><code>model</code> :: <code>any</code><br />
Model created by the <code><a href="mlr3.html#topic+Learner">Learner</a></code>'s <code style="white-space: pre;">&#8288;$.train()&#8288;</code> function.
</p>
</li>
<li> <p><code>train_log</code> :: <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns <code>class</code> (<code>character</code>), <code>msg</code> (<code>character</code>)<br />
Errors logged during training.
</p>
</li>
<li> <p><code>train_time</code> :: <code>numeric(1)</code><br />
Training time, in seconds.
</p>
</li>
<li> <p><code>predict_log</code> :: <code>NULL</code> | <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns <code>class</code> (<code>character</code>), <code>msg</code> (<code>character</code>)<br />
Errors logged during prediction.
</p>
</li>
<li> <p><code>predict_time</code> :: <code>NULL</code> | <code>numeric(1)</code>
Prediction time, in seconds.
</p>
</li></ul>


<ul>
<li> <p><code>max_iter</code> :: <code>integer</code><br />
A integer specifying the number of multi-calibration rounds. Defaults to 5.
</p>
</li></ul>



<h3>Fields</h3>

<p>Fields inherited from <code><a href="mlr3pipelines.html#topic+PipeOp">PipeOp</a></code>, as well as:
</p>

<ul>
<li> <p><code>learner</code> :: <code><a href="mlr3.html#topic+Learner">Learner</a></code><br />
<code><a href="mlr3.html#topic+Learner">Learner</a></code> that is being wrapped. Read-only.
</p>
</li>
<li> <p><code>learner_model</code> :: <code><a href="mlr3.html#topic+Learner">Learner</a></code><br />
<code><a href="mlr3.html#topic+Learner">Learner</a></code> that is being wrapped. This learner contains the model if the <code>PipeOp</code> is trained. Read-only.
</p>
</li></ul>

<p>Only fields inherited from <code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code>.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3pipelines.html#topic+PipeOpTaskPreproc">mlr3pipelines::PipeOpTaskPreproc</a></code>/<code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code>.
</p>
<p>Only methods inherited from <code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code> -&gt; <code><a href="mlr3pipelines.html#topic+PipeOpTaskPreproc">mlr3pipelines::PipeOpTaskPreproc</a></code> -&gt; <code>PipeOpLearnerPred</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>learner</code></dt><dd><p>The wrapped learner.</p>
</dd>
<dt><code>learner_model</code></dt><dd><p>The wrapped learner's model(s).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PipeOpLearnerPred-new"><code>PipeOpLearnerPred$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PipeOpLearnerPred-clone"><code>PipeOpLearnerPred$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PipeOpLearnerPred-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a Learner Predictor PipeOp. Can be used to wrap trained or untrainted
mlr3 learners.
</p>


<h5>Usage</h5>

<div class="r"><pre>PipeOpLearnerPred$new(learner, id = NULL, param_vals = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner</code></dt><dd><p><code><a href="mlr3.html#topic+Learner">Learner</a></code><br />
The learner that should be wrapped.</p>
</dd>
<dt><code>id</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
The <code>PipeOp</code>'s id. Defaults to &quot;mcboost&quot;.</p>
</dd>
<dt><code>param_vals</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
List of hyperparameters for the <code>PipeOp</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PipeOpLearnerPred-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PipeOpLearnerPred$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="mlr3pipelines.html#topic+PipeOp">mlr3pipelines::PipeOp</a></code> -&gt; <code>PipeOpMCBoost</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>predict_type</code></dt><dd><p>Predict type of the PipeOp.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PipeOpMCBoost-new"><code>PipeOpMCBoost$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PipeOpMCBoost-clone"><code>PipeOpMCBoost$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PipeOpMCBoost-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a Multi-Calibration PipeOp.
</p>


<h5>Usage</h5>

<div class="r"><pre>PipeOpMCBoost$new(id = "mcboost", param_vals = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> <br />
The <code>PipeOp</code>'s id. Defaults to &quot;mcboost&quot;.</p>
</dd>
<dt><code>param_vals</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
List of hyperparameters for the <code>PipeOp</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PipeOpMCBoost-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PipeOpMCBoost$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>https://mlr3book.mlr-org.com/list-pipeops.html
</p>
<p>https://mlr3book.mlr-org.com/list-pipeops.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gr = gunion(list(
  "data" = po("nop"),
  "prediction" = po("learner_cv", lrn("classif.rpart"))
)) %&gt;&gt;%
  PipeOpMCBoost$new()
tsk = tsk("sonar")
tid = sample(1:208, 108)
gr$train(tsk$clone()$filter(tid))
gr$predict(tsk$clone()$filter(setdiff(1:208, tid)))

## End(Not run)
</code></pre>

<hr>
<h2 id='mlr3_init_predictor'>Create an initial predictor function from a trained mlr3 learner</h2><span id='topic+mlr3_init_predictor'></span>

<h3>Description</h3>

<p>Create an initial predictor function from a trained mlr3 learner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr3_init_predictor(learner)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlr3_init_predictor_+3A_learner">learner</code></td>
<td>
<p><code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code>
A trained learner used for initialization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+function">function</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 library("mlr3")
 l = lrn("classif.featureless")$train(tsk("sonar"))
 mlr3_init_predictor(l)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='one_hot'>One-hot encode a factor variable</h2><span id='topic+one_hot'></span>

<h3>Description</h3>

<p>One-hot encode a factor variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot(labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_hot_+3A_labels">labels</code></td>
<td>
<p><code><a href="base.html#topic+factor">factor</a></code><br />
Factor to encode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+integer">integer</a></code><br />
Integer vector of encoded labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 one_hot(factor(c("a", "b", "a")))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='ppl_mcboost'>Multi-calibration pipeline</h2><span id='topic+ppl_mcboost'></span>

<h3>Description</h3>

<p>Wraps MCBoost in a Pipeline to be used with <code>mlr3pipelines</code>.
For now this assumes training on the same dataset that is later used
for multi-calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppl_mcboost(learner = lrn("classif.featureless"), param_vals = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppl_mcboost_+3A_learner">learner</code></td>
<td>
<p>(mlr3)<code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code><br />
Initial learner. Internally wrapped into a <code>PipeOpLearnerCV</code>
with <code>resampling.method = "insample"</code> as a default.
All parameters can be adjusted through the resulting Graph's <code>param_set</code>.
Defaults to <code>lrn("classif.featureless")</code>.
Note: An initial predictor can also be supplied via the <code>init_predictor</code> parameter.</p>
</td></tr>
<tr><td><code id="ppl_mcboost_+3A_param_vals">param_vals</code></td>
<td>
<p><code>list</code> <br />
List of parameter values passed on to <code>MCBoost$new</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(mlr3pipelines) <code><a href="mlr3pipelines.html#topic+Graph">Graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  library("mlr3pipelines")
  gr = ppl_mcboost()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='SubgroupAuditorFitter'>Static AuditorFitter based on Subgroups</h2><span id='topic+SubgroupAuditorFitter'></span>

<h3>Description</h3>

<p>Used to assess multi-calibration based on a list of
binary <code>subgroup_masks</code> passed during initialization.
</p>


<h3>Value</h3>

<p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code><br />
</p>
<p><code>list</code> with items<br />
</p>

<ul>
<li> <p><code>corr</code>: pseudo-correlation between residuals and learner prediction.
</p>
</li>
<li> <p><code>l</code>: the trained learner.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code>SubgroupAuditorFitter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>subgroup_masks</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
List of subgroup masks.
Initialize a SubgroupAuditorFitter</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SubgroupAuditorFitter-new"><code>SubgroupAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SubgroupAuditorFitter-fit"><code>SubgroupAuditorFitter$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-SubgroupAuditorFitter-clone"><code>SubgroupAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SubgroupAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes a <code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code> that
assesses multi-calibration within each group defined
by the &lsquo;subpops&rsquo;.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubgroupAuditorFitter$new(subgroup_masks)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subgroup_masks</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
List of subgroup masks. Subgroup masks are list(s) of integer masks,
each with the same length as data to be fitted on.
They allow defining subgroups of the data.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubgroupAuditorFitter-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the learner and compute correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>SubgroupAuditorFitter$fit(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubgroupAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubgroupAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other AuditorFitter: 
<code><a href="#topic+CVLearnerAuditorFitter">CVLearnerAuditorFitter</a></code>,
<code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code>,
<code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library("data.table")
 data = data.table(
   "AGE_0_10" =  c(1, 1, 0, 0, 0),
   "AGE_11_20" = c(0, 0, 1, 0, 0),
   "AGE_21_31" = c(0, 0, 0, 1, 1),
   "X1" = runif(5),
   "X2" = runif(5)
 )
 label = c(1,0,0,1,1)
 masks = list(
   "M1" = c(1L, 0L, 1L, 1L, 0L),
   "M2" = c(1L, 0L, 0L, 0L, 1L)
 )
 sg = SubgroupAuditorFitter$new(masks)
</code></pre>

<hr>
<h2 id='SubpopAuditorFitter'>Static AuditorFitter based on Subpopulations</h2><span id='topic+SubpopAuditorFitter'></span>

<h3>Description</h3>

<p>Used to assess multi-calibration based on a list of
binary valued columns: <code>subpops</code> passed during initialization.
</p>


<h3>Value</h3>

<p><code><a href="#topic+AuditorFitter">AuditorFitter</a></code><br />
</p>
<p><code>list</code> with items<br />
</p>

<ul>
<li> <p><code>corr</code>: pseudo-correlation between residuals and learner prediction.
</p>
</li>
<li> <p><code>l</code>: the trained learner.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+AuditorFitter">mcboost::AuditorFitter</a></code> -&gt; <code>SubpopAuditorFitter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>subpops</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
List of subpopulation indicators.
Initialize a SubpopAuditorFitter</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SubpopAuditorFitter-new"><code>SubpopAuditorFitter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SubpopAuditorFitter-fit"><code>SubpopAuditorFitter$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-SubpopAuditorFitter-clone"><code>SubpopAuditorFitter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mcboost" data-topic="AuditorFitter" data-id="fit_to_resid"><a href='../../mcboost/html/AuditorFitter.html#method-AuditorFitter-fit_to_resid'><code>mcboost::AuditorFitter$fit_to_resid()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SubpopAuditorFitter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes a <code><a href="#topic+SubpopAuditorFitter">SubpopAuditorFitter</a></code> that
assesses multi-calibration within each group defined
by the <code style="white-space: pre;">&#8288;subpops'. Names in &#8288;</code>subpops' must correspond to
columns in the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubpopAuditorFitter$new(subpops)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subpops</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> <br />
Specifies a collection of characteristic attributes
and the values they take to define subpopulations
e.g. list(age = c('20-29','30-39','40+'), nJobs = c(0,1,2,'3+'), ,..).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubpopAuditorFitter-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the learner and compute correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>SubpopAuditorFitter$fit(data, resid, mask)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code><br />
Features.</p>
</dd>
<dt><code>resid</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code><br />
Residuals (of same length as data).</p>
</dd>
<dt><code>mask</code></dt><dd><p><code><a href="base.html#topic+integer">integer</a></code><br />
Mask applied to the data. Only used for <code>SubgroupAuditorFitter</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubpopAuditorFitter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubpopAuditorFitter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other AuditorFitter: 
<code><a href="#topic+CVLearnerAuditorFitter">CVLearnerAuditorFitter</a></code>,
<code><a href="#topic+LearnerAuditorFitter">LearnerAuditorFitter</a></code>,
<code><a href="#topic+SubgroupAuditorFitter">SubgroupAuditorFitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("data.table")
  data = data.table(
    "AGE_NA" = c(0, 0, 0, 0, 0),
    "AGE_0_10" =  c(1, 1, 0, 0, 0),
    "AGE_11_20" = c(0, 0, 1, 0, 0),
    "AGE_21_31" = c(0, 0, 0, 1, 1),
    "X1" = runif(5),
    "X2" = runif(5)
  )
  label = c(1,0,0,1,1)
  pops = list("AGE_NA", "AGE_0_10", "AGE_11_20", "AGE_21_31", function(x) {x[["X1" &gt; 0.5]]})
  sf = SubpopAuditorFitter$new(subpops = pops)
  sf$fit(data, label - 0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
