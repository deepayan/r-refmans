<!DOCTYPE html><html><head><title>Help for package gamlss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamlss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.binom'><p>Lists used by GAMLSS</p></a></li>
<li><a href='#acfResid'>
<p>ACF plot of the residuals</p></a></li>
<li><a href='#additive.fit'><p>Implementing Backfitting in GAMLSS</p></a></li>
<li><a href='#bfp'><p> Functions to fit fractional polynomials in GAMLSS</p></a></li>
<li><a href='#bp'><p>Bucket plot</p></a></li>
<li><a href='#calibration'><p>Calibrating centile curves</p></a></li>
<li><a href='#centiles'><p>Plots the centile curves for a GAMLSS object</p></a></li>
<li><a href='#centiles.com'>
<p>Comparing centiles from different GAMLSS models</p></a></li>
<li><a href='#centiles.pred'><p>Creating  predictive centiles values</p></a></li>
<li><a href='#centiles.split'><p>Plots centile curves split by x for a GAMLSS object</p></a></li>
<li><a href='#coef.gamlss'><p>Extract Model Coefficients in a GAMLSS fitted model</p></a></li>
<li><a href='#cs'><p>Specify a Smoothing Cubic Spline Fit in a GAMLSS Formula</p></a></li>
<li><a href='#deviance.gamlss'><p> Global Deviance of a GAMLSS model</p></a></li>
<li><a href='#devianceIncr'><p>The global deviance increment</p></a></li>
<li><a href='#dtop'><p>Detrended transformed Owen's plot</p></a></li>
<li><a href='#edf'>
<p>Effective degrees of freedom from  gamlss model</p></a></li>
<li><a href='#find.hyper'><p>A function to select values of hyper-parameters in a GAMLSS model</p></a></li>
<li><a href='#fitDist'>
<p>Fitting Different Parametric <code>gamlss.family</code> Distributions.</p></a></li>
<li><a href='#fitted.gamlss'><p>Extract Fitted Values For A GAMLSS Model</p></a></li>
<li><a href='#fittedPlot'><p>Plots The Fitted Values of a GAMLSS Model</p></a></li>
<li><a href='#formula.gamlss'><p>Extract the Model Formula in a GAMLSS fitted model</p></a></li>
<li><a href='#gamlss'><p>Generalized Additive Models for Location Scale and Shape</p></a></li>
<li><a href='#gamlss-package'><p>Generalized Additive Models for Location Scale and Shape</p></a></li>
<li><a href='#gamlss.control'><p>Auxiliary for Controlling GAMLSS Fitting</p></a></li>
<li><a href='#gamlss.cs'><p>Support for Function cs() and scs()</p></a></li>
<li><a href='#gamlss.fp'><p> Support for Function fp()</p></a></li>
<li><a href='#gamlss.lo'><p>Support for Function lo()</p></a></li>
<li><a href='#gamlss.ps'><p>Support for Functions  for smoothers</p></a></li>
<li><a href='#gamlss.random'><p>Support for Functions random() and re()</p></a></li>
<li><a href='#gamlss.scope'><p>Generate a Scope Argument for Stepwise GAMLSS</p></a></li>
<li><a href='#gamlssML'><p>Maximum Likelihood estimation of a simple GAMLSS model</p></a></li>
<li><a href='#gamlssVGD'><p>A  Set of Functions for selecting Models using Validation or Test Data Sets and Cross Validation</p></a></li>
<li><a href='#gen.likelihood'>
<p>A function to generate the likelihood function from a GAMLSS object</p></a></li>
<li><a href='#getPEF'><p>Getting the partial effect function from a continuous term in a GAMLSS model</p></a></li>
<li><a href='#getQuantile'><p>Getting the partial quantile function for a term</p></a></li>
<li><a href='#getSmo'>
<p>Extracting Smoother information from a GAMLSS fitted object</p></a></li>
<li><a href='#glim.control'><p> Auxiliary for Controlling the inner algorithm in a GAMLSS Fitting</p></a></li>
<li><a href='#histDist'><p>This function plots the histogram and a fitted (GAMLSS family) distribution to a variable</p></a></li>
<li><a href='#histSmo'>
<p>Density estimation using the Poisson trick</p></a></li>
<li><a href='#IC'><p>Gives the GAIC for a GAMLSS Object</p></a></li>
<li><a href='#lms'><p>A function to fit LMS curves for centile estimation</p></a></li>
<li><a href='#lo'><p> Specify a loess fit in a GAMLSS formula</p></a></li>
<li><a href='#loglogSurv'>
<p>Survival function plots for checking the tail behaviour of the data</p></a></li>
<li><a href='#lpred'><p>Extract Linear Predictor Values and Standard Errors For A GAMLSS Model</p></a></li>
<li><a href='#LR.test'><p>Likelihood Ratio test for nested GAMLSS models</p></a></li>
<li><a href='#model.frame.gamlss'><p>Extract a model.frame, a model matrix or terms from a GAMLSS object for a given distributional parameter</p></a></li>
<li><a href='#numeric.deriv'><p>An internal GAMLSS function for numerical derivatives</p></a></li>
<li><a href='#par.plot'><p>A function to plot parallel plot for repeated measurement data</p></a></li>
<li><a href='#pcat'>
<p>Reduction for the Levels of a Factor.</p></a></li>
<li><a href='#pdf.plot'><p>Plots Probability Distribution Functions for GAMLSS Family</p></a></li>
<li><a href='#plot.gamlss'><p>Plot Residual Diagnostics for an GAMLSS Object</p></a></li>
<li><a href='#plot.histSmo'>
<p>A Plotting Function for density estimator object histSmo</p></a></li>
<li><a href='#plot2way'>
<p>Function to plot two interaction in a GAMLSS model</p></a></li>
<li><a href='#polyS'><p>Auxiliary support for the GAMLSS</p></a></li>
<li><a href='#predict.gamlss'><p>Extract Predictor Values and Standard Errors For New Data In a GAMLSS Model</p></a></li>
<li><a href='#print.gamlss'><p> Prints a GAMLSS fitted model</p></a></li>
<li><a href='#prodist.gamlss'><p>Extracting Fitted or Predicted Probability Distributions from gamlss Models</p></a></li>
<li><a href='#prof.dev'><p>Plotting the Profile Deviance for one of the Parameters in a GAMLSS model</p></a></li>
<li><a href='#prof.term'><p>Plotting the Profile: deviance or information criterion for one of the terms (or hyper-parameters) in a GAMLSS model</p></a></li>
<li><a href='#ps'><p>P-Splines Fits in a GAMLSS Formula</p></a></li>
<li><a href='#Q.stats'><p>A function to calculate the Q-statistics</p></a></li>
<li><a href='#quantSheets'>
<p>Quantile Sheets</p></a></li>
<li><a href='#random'><p>Specify a random intercept model in a GAMLSS formula</p></a></li>
<li><a href='#refit'><p>Refit a GAMLSS model</p></a></li>
<li><a href='#residuals.gamlss'><p>Extract Residuals from GAMLSS model</p></a></li>
<li><a href='#ri'><p>Specify ridge  or lasso  Regression within a  GAMLSS Formula</p></a></li>
<li><a href='#rqres.plot'><p>Creating and Plotting Randomized Quantile Residuals</p></a></li>
<li><a href='#Rsq'><p>Generalised  (Pseudo) R-squared for GAMLSS models</p></a></li>
<li><a href='#rvcov'>
<p>Robust Variance-Covariance matrix of the parameters from a fitted GAMLSS model</p></a></li>
<li><a href='#stepGAIC'><p>Choose a model by GAIC in a Stepwise Algorithm</p></a></li>
<li><a href='#summary.gamlss'><p>Summarizes a GAMLSS fitted model</p></a></li>
<li><a href='#term.plot'><p>Plot regression terms for a specified parameter of a fitted GAMLSS object</p></a></li>
<li><a href='#update.gamlss'><p> Update and Re-fit a GAMLSS Model</p></a></li>
<li><a href='#VC.test'><p>Vuong and Clarke tests</p></a></li>
<li><a href='#wp'><p> Worm plot</p></a></li>
<li><a href='#z.scores'><p>Z-scores for lms objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Additive Models for Location Scale and Shape</td>
</tr>
<tr>
<td>Version:</td>
<td>5.4-22</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting the Generalized Additive Models for Location Scale and Shape introduced by Rigby and Stasinopoulos (2005), &lt;<a href="https://doi.org/10.1111%2Fj.1467-9876.2005.00510.x">doi:10.1111/j.1467-9876.2005.00510.x</a>&gt;. The models use a distributional regression approach where all the parameters of the conditional distribution of the response variable are modelled using explanatory variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.gamlss.com/">https://www.gamlss.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gamlss-dev/gamlss/issues">https://github.com/gamlss-dev/gamlss/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), graphics, stats, splines, utils, grDevices,
gamlss.data (&ge; 5.0-0), gamlss.dist (&ge; 4.3.1), nlme, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, survival, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>distributions3 (&ge; 0.2.1)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 07:57:24 UTC; dimitriosstasinopoulos</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikis Stasinopoulos
    <a href="https://orcid.org/0000-0003-2407-5704"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Robert Rigby <a href="https://orcid.org/0000-0003-3853-1707"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vlasios Voudouris [ctb],
  Calliope Akantziliotou [ctb],
  Marco Enea [ctb],
  Daniil Kiose <a href="https://orcid.org/0000-0002-3596-5748"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.binom'>Lists used by GAMLSS</h2><span id='topic+.binom'></span><span id='topic+.counts'></span><span id='topic+.gamlss.bi.list'></span><span id='topic+.gamlss.multin.list'></span><span id='topic+.gamlss.sm.list'></span><span id='topic+.real0to1'></span><span id='topic+.realAll'></span><span id='topic+.realline'></span><span id='topic+.realplus'></span>

<h3>Description</h3>

<p>Those lists are used in GAMLSS fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
".binom"

".counts"

".gamlss.bi.list" 

".gamlss.multin.list"

".gamlss.sm.lis"

".real0to1"

".realAll" 

".realline"

".realplus" 
</code></pre>


<h3>Format</h3>

<p>List used by the <code>gamlss()</code> function.
</p>

<dl>
<dt><code>.binom</code></dt><dd><p>a character vector showing all the binomial type (finite count) distributions</p>
</dd>
<dt><code>.counts</code></dt><dd><p>a character vector showing all the infinity count distributions</p>
</dd>
<dt><code>.gamlss.bi.list</code></dt><dd><p>a character vector showing all the binomial type (finite count) distributions</p>
</dd>
<dt><code>.gamlss.multin.list</code></dt><dd><p>a character vector showing all the multinomial distributions</p>
</dd>
<dt><code>.gamlss.sm.list</code></dt><dd><p>a character vector showing all the available smooth functions</p>
</dd>
<dt><code>.real0to1</code></dt><dd><p>a character vector showing all real line distributions with range 0 to 1 </p>
</dd>
<dt><code>.realAll</code></dt><dd><p>a character vector showing all real line distributions from <code class="reqn">-\infty</code> to <code class="reqn">+\infty</code> and from <code class="reqn">0</code> to <code class="reqn">+\infty</code></p>
</dd>
<dt><code>.realline</code></dt><dd><p>a character vector showing all all real line distributions from <code class="reqn">-\infty</code> to <code class="reqn">+\infty</code></p>
</dd>
<dt><code>.realplus</code></dt><dd><p>a character vector showing all all real line distributions from <code class="reqn">0</code> to <code class="reqn">+\infty</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Those list are internal to help the <code>gamlss()</code> function. 
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.binom
.counts
.gamlss.bi.list
.gamlss.multin.list
.gamlss.sm.list
.real0to1
.realline
.realplus
</code></pre>

<hr>
<h2 id='acfResid'>
ACF plot of the residuals
</h2><span id='topic+acfResid'></span>

<h3>Description</h3>

<p>This plot display the ACF and PACF of the residuals of a gamlss or other fitted model (provided that they have been standardised appropriately.  Is is appropriate for time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfResid(obj = NULL, resid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfResid_+3A_obj">obj</code></td>
<td>
<p>A gamlss model or other fitted model where the resid() function applies exist
</p>
</td></tr>
<tr><td><code id="acfResid_+3A_resid">resid</code></td>
<td>

<p>if <code>obj</code> does not exist the argument here will be used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ACF and PACF for the residuals <code>r</code>, squared residuals <code>r^2</code>,  <code>r^3</code> and <code>r^4</code> are plotted
</p>


<h3>Value</h3>

<p>The relevant plots are displayed
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos. Bob Rigby. Vlasios Voudouris and Majid Djennad
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(co2)
m1&lt;- gamlss(co2~pb(as.numeric(time(co2)))+factor(cycle(co2)))
acfResid(m1)
</code></pre>

<hr>
<h2 id='additive.fit'>Implementing Backfitting in GAMLSS</h2><span id='topic+additive.fit'></span>

<h3>Description</h3>

<p>This function is not to be used on its own. It is used for backfitting in the GAMLSS fitting algorithms and it is based on 
the equivalent function written by Trevor Hastie in the gam() S-plus implementation, (Chambers and Hastie, 1991). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive.fit(x, y, w, s, who, smooth.frame, maxit = 30, tol = 0.001, 
             trace = FALSE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="additive.fit_+3A_x">x</code></td>
<td>
<p>the linear part of the explanatory variables</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_w">w</code></td>
<td>
<p>the weights</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_s">s</code></td>
<td>
<p>the matrix containing the smoothers </p>
</td></tr>
<tr><td><code id="additive.fit_+3A_who">who</code></td>
<td>
<p>the current smoothers</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_smooth.frame">smooth.frame</code></td>
<td>
<p>the data frame used for the smoothers</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations in the backfitting</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_tol">tol</code></td>
<td>
<p>the tolerance level for the backfitting </p>
</td></tr>
<tr><td><code id="additive.fit_+3A_trace">trace</code></td>
<td>
<p>whether to trace the backfitting algorithm</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_se">se</code></td>
<td>
<p>whether standard errors are required</p>
</td></tr>
<tr><td><code id="additive.fit_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be used on its own 
</p>


<h3>Value</h3>

<p>Returns a list with the linear fit plus the smothers 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>

<hr>
<h2 id='bfp'> Functions to fit fractional polynomials in GAMLSS</h2><span id='topic+bfp'></span><span id='topic+fp'></span><span id='topic+pp'></span>

<h3>Description</h3>

<p>The function <code>bfp</code> generate a power polynomial basis matrix which  (for given powers) can be used to fit power polynomials in one x-variable.
The function <code>fp</code> takes a vector and returns it with several attributes. 
The vector is used in the construction of the model matrix.  The function <code>fp()</code> is not used for fitting the fractional polynomial curves
but assigns the attributes to the vector to aid gamlss in the fitting process.
The function doing the fitting is <code><a href="#topic+gamlss.fp">gamlss.fp</a>()</code> which is used at the backfitting function 
<code><a href="#topic+additive.fit">additive.fit</a></code> (but never used on its own).
The (experimental) function <code>pp</code> can be use to fit power polynomials as in <code class="reqn">a+b_1 
x^{p_1}+b_2 x^{p_2}</code>., where p1 and p2 
have arbitrary values rather restricted as in the  <code>fp</code> function.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfp(x, powers = c(1, 2), shift = NULL, scale = NULL)
fp(x, npoly = 2, shift = NULL, scale = NULL)
pp(x, start = list(), shift = NULL, scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfp_+3A_x">x</code></td>
<td>
<p>the explanatory variable to be used in functions <code>bfp()</code> or <code>fp()</code>. Note that this is different from the argument <code>x</code> use in <code>gamlss.fp</code> (a function used in the backfitting but not by straight by the user) </p>
</td></tr>
<tr><td><code id="bfp_+3A_powers">powers</code></td>
<td>
<p>a vector containing as elements  the powers in which the x has to be raised </p>
</td></tr>
<tr><td><code id="bfp_+3A_shift">shift</code></td>
<td>
<p>a number for shifting the x-variable. The default values is  zero, if x is positive, or the minimum of the positive difference in x  minus the minimum of x</p>
</td></tr>
<tr><td><code id="bfp_+3A_scale">scale</code></td>
<td>
<p>a positive number for scaling the x-variable. The default values is 
<code class="reqn">10^(sign(log10(range)))*trunc(abs(log10(range)))</code></p>
</td></tr>
<tr><td><code id="bfp_+3A_npoly">npoly</code></td>
<td>
<p>a positive indicating how many fractional polynomials should be considered in the fit. Can take the values 1, 2 or 3 with 2 as default</p>
</td></tr>
<tr><td><code id="bfp_+3A_start">start</code></td>
<td>
<p>a list containing the starting values for the non-linear maximization to find the powers. 
The results from fitting the equivalent fractional polynomials can be used here  </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The above functions are an implementation of the 
fractional polynomials introduced by  Royston and Altman (1994). 
The three functions involved in the fitting are loosely based on 
the fractional polynomials implementation in S-plus written by 
Gareth Amber in 1999, (unfortunately the URL link for his work no longer exist).  The function <code>bfp</code> generates the right design 
matrix for the fitting a power polynomial of the type <code class="reqn">a+b_1 
x^{p_1}+b_2 x^{p_2}+\ldots+b_k x^p_k </code>. For given powers 
<code class="reqn">p_1,p_2,\ldots,p_k</code> given as the argument <code>powers</code> 
in <code>bfp()</code> the function can be used to fit power polynomials 
in the same way as the functions <code>poly()</code> or <code>bs()</code> (of 
package <code>splines</code>) are used to fit orthogonal or piecewise 
polynomials respectively.    
The function <code>fp()</code>, which is working as a smoother in <code>gamlss</code>, is used to fit the best fractional polynomials within a set of power values. 
Its argument <code>npoly</code> 
determines whether one, two or three fractional polynomials should used in the fitting. 
For a fixed number <code>npoly</code> the algorithm looks for the best fitting fractional polynomials
in the list <code>c(-2, -1, -0.5, 0, 0.5, 1, 2, 3) </code>. Note that <code>npolu=3</code> is rather slow since it fits all possible combinations 3-way combinations 
at each backfitting interaction. 
The function <code>gamlss.fp()</code> is an internal function of GAMLSS allowing the 
fractional polynomials to be fitted in the backfitting cycle of <code>gamlss</code>, and should be not used on its own.  
</p>


<h3>Value</h3>

<p>The function <code>bfp</code> returns a matrix to be used as part of the design matrix in the fitting. 
</p>
<p>The function <code>fp</code> returns a vector with values zero to be included in the design matrix but with attributes useful in the fitting 
of the fractional polynomials algorithm in <code>gamlss.fp</code>.  
</p>


<h3>Warning </h3>

<p>Since the model constant is included in both the design matrix X and in the backfitting part of fractional polynomials, its values is wrongly 
given in the <code>summary</code>. Its true values is the model constant minus the constant from the fractional polynomial fitting ??? What happens if more that one fractional polynomials are fitted? </p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Royston,  P. and Altman, D. G., (1994). Regression using fractional polynomials of continuous covariates: parsimonious parametric modelling 
(with discussion), <em>Appl. Statist.</em>, <b>43</b>, 429-467.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
#fits polynomials with power 1 and .5 
mod1&lt;-gamlss(y~bfp(x,c(1,0.5)),data=abdom)
# fit the best of one fractional polynomial
m1&lt;-gamlss(y~fp(x,1),data=abdom)
# fit the best of two fractional polynomials
m2&lt;-gamlss(y~fp(x,2),data=abdom)
# fit the best of three fractional polynomials
m3&lt;-gamlss(y~fp(x,3),data=abdom)
# get the coefficient for the second model 
m2$mu.coefSmo
# now power polynomials using the best 2 fp c()
 m4 &lt;- gamlss(y ~ pp(x, c(1,3)), data = abdom)
# This is not good idea in this case because
# if you look at the fitted values you see what it went wrong
plot(y~x,data=abdom)
lines(fitted(m2,"mu")~abdom$x,col="red")
lines(fitted(m4,"mu")~abdom$x,col="blue")
</code></pre>

<hr>
<h2 id='bp'>Bucket plot</h2><span id='topic+bp'></span>

<h3>Description</h3>

<p>A bucket plot is a graphical way to check the skewness and kurtosis of a continuous variable or the residuals of a fitted GAMLSS model. It plots the transformed moment skewness and  transformed moment kurtosis of the variable (or residuals) together with a cloud of points obtained using a non-parametric bootstrap from the original variable (or residuals). It also provides a graphical way of performing the  Jarque-Bera test (JarqueandBera,1980). 
</p>
<p>There are two different bucket plots specified by the <code>type</code> argument:
</p>
<p>i) the <code>moment</code> bucket   and 
ii) the <code>centile</code> bucket which itself can be  <code>central</code> or <code>tail</code> one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bp(obj = NULL, weights = NULL, 
      type = c("moment", "centile.central", "centile.tail"), 
      xvar = NULL, bootstrap = TRUE, no.bootstrap = 99, 
      col.bootstrap = c("lightblue", "pink", "khaki", 
      "thistle", "tan", "sienna1","steelblue", "coral", "gold", 
      "cyan"), 
      pch.bootstrap = rep(21, 10), asCharacter = TRUE, 
      col.point = rep("black", 10), pch.point = 1:10, 
      lwd.point = 2, text.to.show = NULL, cex.text = 1.5, 
      col.text = "black", show.legend = FALSE, n.inter = 4, 
      xcut.points = NULL, overlap = 0, show.given = TRUE, 
      cex = 1, pch = 21, data = NULL, 
      bar.bg = c(num = "lightblue", fac = "pink"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bp_+3A_obj">obj</code></td>
<td>
<p>A <code>gamlss</code> fitted object.</p>
</td></tr>
<tr><td><code id="bp_+3A_weights">weights</code></td>
<td>
<p>prior weights.</p>
</td></tr>
<tr><td><code id="bp_+3A_type">type</code></td>
<td>
<p>type of bucket plot whether &quot;moment&quot;, &quot;centile.central&quot;, or &quot;centile.tail&quot;.</p>
</td></tr>
<tr><td><code id="bp_+3A_xvar">xvar</code></td>
<td>
<p>the x-variable if need to split the bucket plot.</p>
</td></tr>
<tr><td><code id="bp_+3A_bootstrap">bootstrap</code></td>
<td>
<p>whether to bootstrap the skewness and kurtosis points</p>
</td></tr>
<tr><td><code id="bp_+3A_no.bootstrap">no.bootstrap</code></td>
<td>
<p>the number of the  bootstrap samples in the plot</p>
</td></tr>
<tr><td><code id="bp_+3A_col.bootstrap">col.bootstrap</code></td>
<td>
<p>the colour of the  bootstrap samples in the plot</p>
</td></tr>
<tr><td><code id="bp_+3A_pch.bootstrap">pch.bootstrap</code></td>
<td>
<p>the character plotting symbol.</p>
</td></tr>
<tr><td><code id="bp_+3A_ascharacter">asCharacter</code></td>
<td>
<p>whether to plot the skewness and kurtosis as character or just  points.</p>
</td></tr>
<tr><td><code id="bp_+3A_col.point">col.point</code></td>
<td>
<p>the colout of the point is plotted as point</p>
</td></tr>
<tr><td><code id="bp_+3A_pch.point">pch.point</code></td>
<td>
<p>the character symbol for the point</p>
</td></tr>
<tr><td><code id="bp_+3A_lwd.point">lwd.point</code></td>
<td>
<p>the width of the symbol</p>
</td></tr>
<tr><td><code id="bp_+3A_text.to.show">text.to.show</code></td>
<td>
<p>whether to show character for the model</p>
</td></tr>
<tr><td><code id="bp_+3A_cex.text">cex.text</code></td>
<td>
<p>the <code>cex</code> of the text</p>
</td></tr>
<tr><td><code id="bp_+3A_col.text">col.text</code></td>
<td>
<p>the <code>colour</code> of the text</p>
</td></tr>
<tr><td><code id="bp_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show the legend</p>
</td></tr>
<tr><td><code id="bp_+3A_n.inter">n.inter</code></td>
<td>
<p>number of intervals</p>
</td></tr>
<tr><td><code id="bp_+3A_xcut.points">xcut.points</code></td>
<td>
<p>cut points for the <code>xvar</code> if need</p>
</td></tr>
<tr><td><code id="bp_+3A_overlap">overlap</code></td>
<td>
<p>whether the interval id <code>xvar</code> is set should overlap</p>
</td></tr>
<tr><td><code id="bp_+3A_show.given">show.given</code></td>
<td>
<p>showing the top part of the plot</p>
</td></tr>
<tr><td><code id="bp_+3A_cex">cex</code></td>
<td>
<p>the <code>cex</code></p>
</td></tr>
<tr><td><code id="bp_+3A_pch">pch</code></td>
<td>
<p>the point character <code>pch</code></p>
</td></tr>
<tr><td><code id="bp_+3A_data">data</code></td>
<td>
<p>if data has to be set</p>
</td></tr>
<tr><td><code id="bp_+3A_bar.bg">bar.bg</code></td>
<td>
<p>the backgroud color of the bars in the top of the figure</p>
</td></tr>
<tr><td><code id="bp_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying the transformed moment skewness and  transformed moment kurtosis of the sample or residual of a model.
</p>


<h3>Note</h3>

<p>The  bucket plot provides an additional residual diagnostic tool that can be used for fitted model checking, alongside other diagnostic tools, for example   worm plots, and Q (and Z) statistics.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Fernanda De Bastiani</p>


<h3>References</h3>

<p>De Bastiani, F.,   Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., and Lucas A. (2022) Bucket Plot: A Visual Tool for Skewness and Kurtosis Comparisons. send for publication.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>
An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC. <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>(see also  <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a>, <a href="#topic+Q.stats">Q.stats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- gamlss(R~pb(Fl)+pb(A), data=rent, family=GA)
bp(m1)
</code></pre>

<hr>
<h2 id='calibration'>Calibrating centile curves</h2><span id='topic+calibration'></span>

<h3>Description</h3>

<p>This function can used when the fitted model centiles do not coincide with the sample centiles.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration(object, xvar, cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6),
            legend = FALSE, fan = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_+3A_object">object</code></td>
<td>
<p>a gamlss fitted object</p>
</td></tr>
<tr><td><code id="calibration_+3A_xvar">xvar</code></td>
<td>
<p>The explanatory variable</p>
</td></tr>
<tr><td><code id="calibration_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves have to be evaluated</p>
</td></tr>
<tr><td><code id="calibration_+3A_legend">legend</code></td>
<td>
<p>whether legend is required</p>
</td></tr>
<tr><td><code id="calibration_+3A_fan">fan</code></td>
<td>
<p>whether to use the fan  version of centiles</p>
</td></tr>
<tr><td><code id="calibration_+3A_...">...</code></td>
<td>
<p>other argument pass on to <code>centiles()</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  function finds the sample quantiles of the residuals of the fitted model (the z-scores) and use them as sample quantile in the argument <code>cent</code> of the <code>centiles()</code> function. This procedure is appropriate if the fitted model centiles do not coincide with the sample centiles and when this failure is the same in all values of the explanatory variable <code>xvar</code>.
</p>


<h3>Value</h3>

<p>A centile plot is produced and the sample centiles below each centile curve are printed (or saved)
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Vlasios Voudouris</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centiles">centiles</a></code>, <code><a href="#topic+centiles.fan">centiles.fan</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
m1&lt;-gamlss(y~pb(x), sigma.fo=~pb(x), family=LO, data=abdom)
calibration(m1, xvar=abdom$x, fan=TRUE)
</code></pre>

<hr>
<h2 id='centiles'>Plots the centile curves for a GAMLSS object </h2><span id='topic+centiles'></span><span id='topic+centiles.fan'></span>

<h3>Description</h3>

<p>This function <code>centiles()</code> plots centiles curves for distributions belonging to the GAMLSS family of distributions.  
The function also tabulates the sample percentages below each centile curve (for comparison with the model percentages given by the argument <code>cent</code>.)
The function <code>centiles.fan()</code> plots a fan-chart of the centile curves.
A restriction of the functions is that it applies to models with one explanatory variable only.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centiles(obj, xvar, cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6), 
         legend = TRUE, ylab = "y", xlab = "x", main = NULL, 
         main.gsub = "@", xleg = min(xvar), yleg = max(obj$y), 
         xlim = range(xvar), ylim = range(obj$y), save = FALSE, 
         plot = TRUE, points = TRUE,  pch =  15, cex = 0.5, col =  gray(0.7), 
         col.centiles = 1:length(cent) + 2, lty.centiles = 1, lwd.centiles = 1, ...)
centiles.fan(obj, xvar, cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6), 
         ylab = "y", xlab = "x", main = NULL, main.gsub = "@", 
         xleg = min(xvar), yleg = max(obj$y), xlim = range(xvar), 
         ylim = range(obj$y), points = FALSE,  median = TRUE, pch =  15, 
         cex = 0.5, col =  gray(0.7),
         colors = c("cm", "gray", "rainbow", "heat", "terrain", "topo"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centiles_+3A_obj">obj</code></td>
<td>
<p>a fitted gamlss object from fitting a gamlss distribution</p>
</td></tr>
<tr><td><code id="centiles_+3A_xvar">xvar</code></td>
<td>
<p>the unique explanatory variable</p>
</td></tr>
<tr><td><code id="centiles_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves have to be evaluated</p>
</td></tr>
<tr><td><code id="centiles_+3A_legend">legend</code></td>
<td>
<p>whether a legend is required in the plot or not, the default is <code>legent=TRUE</code>  </p>
</td></tr>
<tr><td><code id="centiles_+3A_ylab">ylab</code></td>
<td>
<p>the y-variable label</p>
</td></tr>
<tr><td><code id="centiles_+3A_xlab">xlab</code></td>
<td>
<p>the x-variable label</p>
</td></tr>
<tr><td><code id="centiles_+3A_main">main</code></td>
<td>
<p>the main title here as character. 
If NULL the default title &quot;centile curves using  NO&quot; (or the relevant distributions name) is shown</p>
</td></tr>
<tr><td><code id="centiles_+3A_main.gsub">main.gsub</code></td>
<td>
<p>if the <code>main.gsub</code> (with default &quot;@&quot;) appears in the <code>main</code> 
title then it is substituted with the default title.</p>
</td></tr>
<tr><td><code id="centiles_+3A_xleg">xleg</code></td>
<td>
<p>position of the legend in the x-axis</p>
</td></tr>
<tr><td><code id="centiles_+3A_yleg">yleg</code></td>
<td>
<p>position of the legend in the y-axis</p>
</td></tr>
<tr><td><code id="centiles_+3A_xlim">xlim</code></td>
<td>
<p>the limits of the x-axis</p>
</td></tr>
<tr><td><code id="centiles_+3A_ylim">ylim</code></td>
<td>
<p>the limits of the y-axis</p>
</td></tr>
<tr><td><code id="centiles_+3A_save">save</code></td>
<td>
<p>whether to save the sample percentages or not with default equal to <code>FALSE</code>. 
In this case the sample percentages are printed but are not saved </p>
</td></tr>
<tr><td><code id="centiles_+3A_plot">plot</code></td>
<td>
<p>whether to plot the centiles. This option is useful for <code>centile.split</code> </p>
</td></tr> 
<tr><td><code id="centiles_+3A_pch">pch</code></td>
<td>
<p>the character to be used as the default in plotting points see <code>par</code></p>
</td></tr>
<tr><td><code id="centiles_+3A_cex">cex</code></td>
<td>
<p>size of  character see <code>par</code></p>
</td></tr>
<tr><td><code id="centiles_+3A_col">col</code></td>
<td>
<p>plotting colour see <code>par</code></p>
</td></tr>
<tr><td><code id="centiles_+3A_col.centiles">col.centiles</code></td>
<td>
<p>Plotting colours  for the centile curves</p>
</td></tr>
<tr><td><code id="centiles_+3A_lty.centiles">lty.centiles</code></td>
<td>
<p>line type for the centile curves</p>
</td></tr>
<tr><td><code id="centiles_+3A_lwd.centiles">lwd.centiles</code></td>
<td>
<p>The line width for the centile curves</p>
</td></tr>
<tr><td><code id="centiles_+3A_colors">colors</code></td>
<td>
<p>the different colour schemes to be used for the fan-chart. The following are available 
<code>c("cm","gray", "rainbow", "heat", "terrain", "topo")</code>,  </p>
</td></tr>
<tr><td><code id="centiles_+3A_points">points</code></td>
<td>
<p>whether the data points should be plotted, default is <code>TRUE</code> for <code>centiles()</code> and
<code>FALSE</code> for <code>centiles.fan()</code></p>
</td></tr>
<tr><td><code id="centiles_+3A_median">median</code></td>
<td>
<p>whether the median should be plotted (only in <code>centiles.fan()</code>)</p>
</td></tr>
<tr><td><code id="centiles_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>          
</table>


<h3>Details</h3>

<p>Centiles are calculated using the fitted values in <code>obj</code> and <code>xvar</code> must
correspond exactly to the predictor in <code>obj</code> to plot correctly.
</p>
<p><code>col.centiles</code>, <code>lty.centiles</code> and <code>lwd.centiles</code> may be vector arguments
and are recycled to the length <code>cent</code> if necessary.
</p>


<h3>Value</h3>

<p>A centile plot is produced and the sample centiles below each centile curve are printed (or saved)
</p>


<h3>Warning </h3>

<p>This function is appropriate only when one continuous explanatory variable is fitted in the model</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby with contribution from Steve Ellison</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles.split">centiles.split</a></code> , <code><a href="#topic+centiles.com">centiles.com</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
h&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom) 
# default plot
centiles(h,xvar=abdom$x)
# control of colours and lines
centiles(h, xvar=abdom$x,  col.cent=c(2,3,4,5,1,5,4,3,2,1), 
              lwd.cent=c(1,1,1,1,2,1,1,1,1))
#Control line types
centiles(h, xvar=abdom$x,  col.cent=1, cent=c(.5,2.5,50,97.5,99.5), 
              lty.centiles=c(3,2,1,2,3),lwd.cent=c(1,1,2,1,1))
# control of the main title
centiles(h, xvar=abdom$x,  main="Abdominal data \n @")
# the fan-chart
centiles.fan(h,xvar=abdom$x, colors="rainbow")
rm(h)
</code></pre>

<hr>
<h2 id='centiles.com'>
Comparing centiles from different GAMLSS models</h2><span id='topic+centiles.com'></span>

<h3>Description</h3>

<p>This function compares centiles curves for more than one GAMLSS objects.It is based on the <code>centiles</code> function.
The function also tabulates the sample percentages below each centile curve (for comparison with the model percentages 
given by the argument <code>cent</code>.) A restriction of the function is that it applies to models with one 
explanatory variable only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centiles.com(obj, ..., xvar, cent = c(0.4, 10, 50, 90, 99.6), 
             legend = TRUE, ylab = "y", xlab = "x", xleg = min(xvar), 
             yleg = max(obj$y), xlim = range(xvar), ylim = NULL, 
             no.data = FALSE, color = TRUE, main = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centiles.com_+3A_obj">obj</code></td>
<td>
<p>a fitted gamlss object from fitting a gamlss continuous distribution</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_...">...</code></td>
<td>
<p>optionally more fitted GAMLSS model objects</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_xvar">xvar</code></td>
<td>
<p>the unique explanatory variable </p>
</td></tr>
<tr><td><code id="centiles.com_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves have to be evaluated</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_legend">legend</code></td>
<td>
<p>whether a legend is required in the plot or not, the default is <code>legent=TRUE</code></p>
</td></tr>
<tr><td><code id="centiles.com_+3A_ylab">ylab</code></td>
<td>
<p>the y-variable label</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_xlab">xlab</code></td>
<td>
<p>the x-variable label</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_xleg">xleg</code></td>
<td>
<p>position of the legend in the x-axis</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_yleg">yleg</code></td>
<td>
<p>position of the legend in the y-axis</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_xlim">xlim</code></td>
<td>
<p>the limits of the x-axis</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_ylim">ylim</code></td>
<td>
<p>the limits of the y-axis</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_no.data">no.data</code></td>
<td>
<p>whether the data should plotted, default <code>no.data=FALSE</code> or not <code>no.data=TRUE</code> </p>
</td></tr>
<tr><td><code id="centiles.com_+3A_color">color</code></td>
<td>
<p>whether the fitted centiles are shown in colour, <code>color=TRUE</code> (the default) or not          
<code>color=FALSE</code></p>
</td></tr>
<tr><td><code id="centiles.com_+3A_main">main</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="centiles.com_+3A_plot">plot</code></td>
<td>
<p>whether to plot the centiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Centile plots are produced for the different fitted models and the sample centiles below each centile curve are printed</p>


<h3>Warning </h3>

<p>This function is appropriate only when one continuous explanatory variable is fitted in the model</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M.(2005). Generalized additive models for location, scale and shape, (with discussion),<em>Appl. Statist.</em>, 
<b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles">centiles</a></code> , <code><a href="#topic+centiles.split">centiles.split</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
h1&lt;-gamlss(y~cs(x,df=3), sigma.formula=~cs(x,1),family=BCT, data=abdom)
h2&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom )
centiles.com(h1,h2,xvar=abdom$x)
rm(h1,h2)
</code></pre>

<hr>
<h2 id='centiles.pred'>Creating  predictive centiles values</h2><span id='topic+centiles.pred'></span>

<h3>Description</h3>

<p>This function creates predictive centiles curves for new x-values given a GAMLSS fitted model.
The function has three options: i) for given new x-values and given percentage centiles calculates a matrix containing 
the centiles values for y,
ii) for given new x-values and standard normalized centile values calculates a matrix containing the centiles values for y,
iii) for given new x-values and new y-values calculates the z-scores.  
A restriction of the function is that it applies to models with only one explanatory variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centiles.pred(obj, type = c("centiles", "z-scores", "standard-centiles"), 
             xname = NULL, xvalues = NULL, power = NULL, yval = NULL, 
             cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6), 
             dev = c(-4, -3, -2, -1, 0, 1, 2, 3, 4), calibration = FALSE,
             plot = FALSE, legend = TRUE,  ylim = NULL,xlim = NULL,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centiles.pred_+3A_obj">obj</code></td>
<td>
<p>a fitted gamlss object from fitting a gamlss continuous distribution </p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_type">type</code></td>
<td>
<p>the default, &quot;centiles&quot;, gets the centiles values given in the option <code>cent</code>. 
<code>type="standard-centiles"</code> gets the standard centiles  given in the <code>dev</code>. 
<code>type="z-scores"</code> gets the z-scores for given y and x new values</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_xname">xname</code></td>
<td>
<p> the name of the unique explanatory variable (it has to be the same as in the original fitted model)</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_xvalues">xvalues</code></td>
<td>
<p>the new values for the explanatory variable where the prediction will take place</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_power">power</code></td>
<td>
<p>if power transformation is needed (but read the note below)</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_yval">yval</code></td>
<td>
<p>the response values for a given x required for the calculation of &quot;z-scores&quot;</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves have to be evaluated</p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_dev">dev</code></td>
<td>
<p> a vector with elements the standard normalized values for which the centile curves have to be evaluated in the option <code>type="standard-centiles"</code></p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_calibration">calibration</code></td>
<td>
<p>whether to calibrate the &quot;centiles&quot;, the default is <code>calibrate=FALSE</code></p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_plot">plot</code></td>
<td>
<p>whether to plot the &quot;centiles&quot; or the &quot;standard-centiles&quot;, the default is <code>plot=FALSE</code></p>
</td></tr>
<tr><td><code id="centiles.pred_+3A_legend">legend</code></td>
<td>
<p>whether a legend is required in the plot or not, the default is <code>legent=TRUE</code>  </p>
</td></tr> 
<tr><td><code id="centiles.pred_+3A_ylim">ylim</code></td>
<td>
<p>If different <code>ylim</code> is required from the default</p>
</td></tr> 
<tr><td><code id="centiles.pred_+3A_xlim">xlim</code></td>
<td>
<p>If different <code>xlim</code> is required from the default </p>
</td></tr> 
<tr><td><code id="centiles.pred_+3A_...">...</code></td>
<td>
<p> for extra arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector (for option <code>type="z-scores"</code>) or a  matrix for options
<code>type="centiles"</code> or <code>type="standard-centiles"</code>
containing the appropriate values
</p>


<h3>Warning </h3>

<p>See example below of how to use the function when power transformation is used for the x-variables</p>


<h3>Note</h3>

<p>The power option should be only used if the model  </p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, based on ideas of Elaine Borghie 
from the World Health Organization</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles">centiles</a></code>, <code><a href="#topic+centiles.split">centiles.split</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## bring the data and fit the model
data(abdom)
a&lt;-gamlss(y~pb(x),sigma.fo=~pb(x), data=abdom, family=BCT)
## plot the centiles
centiles(a,xvar=abdom$x)
##-----------------------------------------------------------------------------
## the first use of the function centiles.pred()
## to calculate the centiles at new x values
##-----------------------------------------------------------------------------
newx&lt;-seq(12,40,2)
mat &lt;- centiles.pred(a, xname="x", xvalues=newx )
mat
## now plot the centile curves  
 mat &lt;- centiles.pred(a, xname="x",xvalues=newx, plot=TRUE )
##-----------------------------------------------------------------------------
## the second use of the function centiles.pred()
## to calculate (nornalised) standard-centiles for new x
## values using the fitted model
##-----------------------------------------------------------------------------
newx &lt;- seq(12,40,2)
mat &lt;- centiles.pred(a, xname="x",xvalues=newx, type="standard-centiles" )
mat
## now plot the standard centiles  
mat &lt;- centiles.pred(a, xname="x",xvalues=newx, type="standard-centiles",
       plot = TRUE )
##-----------------------------------------------------------------------------
## the third use of the function centiles.pred()
##  if we have new x and y values what are their z-scores?
##-----------------------------------------------------------------------------
# create new y and x values and plot them in the previous plot
newx &lt;- c(20,21.2,23,20.9,24.2,24.1,25)
newy &lt;- c(130,121,123,125,140,145,150)
for(i in 1:7) points(newx[i],newy[i],col="blue")
## now calculate their z-scores
znewx &lt;- centiles.pred(a, xname="x",xvalues=newx,yval=newy, type="z-scores" )
znewx
## Not run: 
##-----------------------------------------------------------------------------
## What we do if the x variables is transformed?
##----------------------------------------------------------------------------
##  case 1 : transformed x-variable within the formula
##----------------------------------------------------------------------------
## fit model
aa &lt;- gamlss(y~pb(x^0.5),sigma.fo=~pb(x^0.5), data=abdom, family=BCT)
## centiles is working in this case
centiles(aa, xvar=abdom$x, legend = FALSE)
## get predict for values of x at 12, 14, ..., 40
mat &lt;- centiles.pred(aa, xname="x", xvalues=seq(12,40,2), plot=TRUE )
mat
# plot all prediction points
xx &lt;- rep(mat[,1],9)
yy &lt;- unlist(mat[,2:10])
points(xx,yy,col="red")
##----------------------------------------------------------------------------
##  case 2 : the x-variable is previously transformed 
##----------------------------------------------------------------------------
nx &lt;- abdom$x^0.5
aa &lt;- gamlss(y~pb(nx),sigma.fo=~pb(nx), data=abdom, family=BCT)
centiles(aa, xvar=abdom$x)
# equivalent to fitting
newd&lt;-data.frame( abdom, nx=abdom$x^0.5)
aa1 &lt;- gamlss(y~pb(nx),sigma.fo=~pb(nx), family=BCT, data=newd)
centiles(aa1, xvar=abdom$x)
# getting the centiles at x equal to 12, 14, ...40
mat &lt;-  centiles.pred(aa, xname="nx", xvalues=seq(12,40,2), power=0.5, 
         data=newd, plot=TRUE)
# plot all prediction points         
xxx &lt;- rep(mat[,1],9)
yyy &lt;- unlist(mat[,2:10])
points(xxx,yyy,col="red")
# the idea is that if the transformed x-variable is used in the fit
# the power argument has to used in centiles.pred()

## End(Not run)
</code></pre>

<hr>
<h2 id='centiles.split'>Plots centile curves split by x for a GAMLSS object</h2><span id='topic+centiles.split'></span>

<h3>Description</h3>

<p>This function plots centiles curves for separate ranges of the unique explanatory variable x. 
It is similar to the <code><a href="#topic+centiles">centiles</a></code> function but the range of x is split at a user defined values <code>xcut.point</code> into r separate ranges.
The functions also tabulates the sample percentages below each centile curve for each of the r ranges of x 
(for comparison with the model percentage given by cent)
The model should have only one explanatory variable.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centiles.split(obj, xvar, xcut.points = NULL, n.inter = 4, 
               cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6), 
               legend = FALSE, main = NULL, main.gsub = "@", 
               ylab = "y", xlab = "x", ylim = NULL, overlap = 0, 
               save = TRUE, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centiles.split_+3A_obj">obj</code></td>
<td>
<p>a fitted gamlss object from fitting a gamlss continuous distribution</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_xvar">xvar</code></td>
<td>
<p>the unique explanatory variable</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_xcut.points">xcut.points</code></td>
<td>
<p>the x-axis cut off points e.g. <code>c(20,30)</code>. If <code>xcut.points=NULL</code> then the <code>n.inter</code> argument is activated </p>
</td></tr>
<tr><td><code id="centiles.split_+3A_n.inter">n.inter</code></td>
<td>
<p>if <code>xcut.points=NULL</code> this argument gives the number of intervals in which the x-variable will be split, with default 4 </p>
</td></tr>
<tr><td><code id="centiles.split_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves are to be evaluated</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_legend">legend</code></td>
<td>
<p>whether a legend is required in the plots or not, the default is <code>legent=FALSE</code>  </p>
</td></tr>
<tr><td><code id="centiles.split_+3A_main">main</code></td>
<td>
<p>the main title as character. 
If NULL the default title (shown the intervals) is shown</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_main.gsub">main.gsub</code></td>
<td>
<p>if the <code>main.gsub</code> (with default &quot;@&quot;) appears in the <code>main</code> 
title then it is substituted with the default title.</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_ylab">ylab</code></td>
<td>
<p>the y-variable label</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_xlab">xlab</code></td>
<td>
<p>the x-variable label</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_ylim">ylim</code></td>
<td>
<p>the range of the y-variable axis</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_overlap">overlap</code></td>
<td>
<p>how much overlapping in the <code>xvar</code> intervals. Default value is <code>overlap=0</code> for non overlapping intervals</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_save">save</code></td>
<td>
<p>whether to save the sample percentages or not with default equal to <code>TRUE</code>. 
In this case the functions produce a matrix giving the sample percentages for each interval </p>
</td></tr>
<tr><td><code id="centiles.split_+3A_plot">plot</code></td>
<td>
<p>whether to plot the centles. This option is useful if the sample statistics only are to be used</p>
</td></tr>
<tr><td><code id="centiles.split_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Centile plots are produced and the sample centiles below each centile curve for each of the r ranges of x can be saved into a matrix.  
</p>


<h3>Warning </h3>

<p>This function is appropriate when only one continuous explanatory variable is fitted in the model</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby with contributions from Elaine Borghie</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>  <code><a href="#topic+centiles">centiles</a></code>,   <code><a href="#topic+centiles.com">centiles.com</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
h&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom) 
mout &lt;- centiles.split(h,xvar=abdom$x)
mout
rm(h,mout)
</code></pre>

<hr>
<h2 id='coef.gamlss'>Extract Model Coefficients in a GAMLSS fitted model</h2><span id='topic+coef.gamlss'></span><span id='topic+coefAll'></span>

<h3>Description</h3>

<p><code>coef.gamlss</code> is the GAMLSS specific method for the generic function <code>coef</code> which extracts model coefficients
from objects returned by modelling functions.  &lsquo;coefficients&rsquo; is an
alias for <code>coef</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
coef(object, what = c("mu", "sigma", "nu", "tau"), 
                      parameter = NULL, ... )
                      
coefAll(obj, deviance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gamlss_+3A_object">object</code>, <code id="coef.gamlss_+3A_obj">obj</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="coef.gamlss_+3A_what">what</code></td>
<td>
<p>which parameter coefficient is required, default <code>what="mu"</code> </p>
</td></tr>
<tr><td><code id="coef.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code> (more obvious name)</p>
</td></tr>
<tr><td><code id="coef.gamlss_+3A_deviance">deviance</code></td>
<td>
<p>whether to print also the deviance.</p>
</td></tr>
<tr><td><code id="coef.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the GAMLSS model object.
</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=NBI, data=aids) # 
coef(h)
coefAll(h)
rm(h)
</code></pre>

<hr>
<h2 id='cs'>Specify a Smoothing Cubic Spline Fit in a GAMLSS Formula</h2><span id='topic+cs'></span><span id='topic+scs'></span><span id='topic+cs.control'></span>

<h3>Description</h3>

<p>The functions <code>cs()</code> and <code>scs()</code> are using the cubic smoothing splines function <code>smooth.spline()</code> to do smoothing.  They take a vector and return it with several attributes. 
The vector is used in the construction of the model matrix. The functions do not do the smoothing, but assigns the attributes to the vector to aid gamlss in the smoothing.
The function doing the smoothing is <code><a href="#topic+gamlss.cs">gamlss.cs</a>()</code>.
This function use the <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code> which is then used by the backfitting function  <code>additive.fit()</code> which is based on the original GAM implementation described in Chambers and Hastie (1992).
The function <code>gamlss.scs()</code>  differs from the function <code>cs()</code> in that allows cross validation of the smoothing parameters unlike the <code>cs()</code> which fixes the effective degrees of freedom, <code>df</code>.  Note that the recommended smoothing function is now the function <code>pb()</code> which allows the estimation of the smoothing parameters using a local maximum likelihood. The function <code>pb()</code> is based on the penalised beta splines (P-splines) of Eilers and Marx (1996).
</p>
<p>The (experimental) function <code>vc</code> is now defunct. For fitting varying coefficient models, Hastie and Tibshirani (1993) use the function <code>pvc()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs(x, df = 3, spar = NULL, c.spar = NULL, control = cs.control(...), ...)
scs(x, df = NULL, spar = NULL, control = cs.control(...), ...)
cs.control(cv = FALSE, all.knots = TRUE, nknots = NULL, keep.data = TRUE,
               df.offset = 0, penalty = 1.4, control.spar = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs_+3A_x">x</code></td>
<td>
<p>the univariate predictor, (or expression, that evaluates to a numeric vector). 
For the function <code>vc</code> the x argument is the vector which has its (linear) coefficient change with <code>r</code></p>
</td></tr>
<tr><td><code id="cs_+3A_df">df</code></td>
<td>
<p>the desired equivalent number of degrees of freedom (trace of the smoother matrix minus two for the constant and linear fit). The real smoothing parameter (spar below) is found such that df=tr(S)-2, 
where S is the implicit smoother matrix. Values for df should be greater than 0, with 0 implying a linear fit.</p>
</td></tr>
<tr><td><code id="cs_+3A_spar">spar</code></td>
<td>
<p> smoothing parameter, typically (but not necessarily) in (0,1].   
The coefficient lambda of the integral of the squared second derivative in the fit (penalised log likelihood)
criterion is a monotone function of &lsquo;spar&rsquo;, see the details in <code>smooth.spline</code>.</p>
</td></tr>
<tr><td><code id="cs_+3A_c.spar">c.spar</code></td>
<td>
<p>This is an option to be used when the degrees of freedom of the fitted gamlss object are different from the ones given as input in the option <code>df</code>.  The default values used are the ones given  the  option <code>control.spar</code>    in the R function <code>smooth.spine()</code> and they are <code>c.spar=c(-1.5, 2)</code>. For  very large data sets e.g. 10000 observations, the upper limit may have to increase for example to  <code>c.spar=c(-1.5, 2.5)</code>. Use this option if you have received the warning 'The output df are different from the input, change the control.spar'. <code>c.spar</code> can take both vectors or lists of length 2, for example <code>c.spar=c(-1.5, 2.5)</code> or <code>c.spar=list(-1.5, 2.5)</code> would have the same effect.</p>
</td></tr>
<tr><td><code id="cs_+3A_control">control</code></td>
<td>
<p>control for the function <code>smooth.spline()</code>, see below</p>
</td></tr>
<tr><td><code id="cs_+3A_cv">cv</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code></p>
</td></tr>
<tr><td><code id="cs_+3A_all.knots">all.knots</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code></p>
</td></tr>
<tr><td><code id="cs_+3A_nknots">nknots</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code></p>
</td></tr>
<tr><td><code id="cs_+3A_keep.data">keep.data</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code></p>
</td></tr>
<tr><td><code id="cs_+3A_df.offset">df.offset</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code></p>
</td></tr>
<tr><td><code id="cs_+3A_penalty">penalty</code></td>
<td>
<p>see the  <span class="rlang"><b>R</b></span> function <code>smooth.spline()</code>, here the default value is 1.4</p>
</td></tr>
<tr><td><code id="cs_+3A_control.spar">control.spar</code></td>
<td>
<p>see above <code>c.spar</code> or the equivalent argument in the function <code>smooth.spline</code></p>
</td></tr>
<tr><td><code id="cs_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>cs</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> which in turn uses the function 
<code>additive.fit()</code> for backfitting which in turn uses <code>gamlss.cs()</code>
</p>
<p>Note that  <code>cs()</code> and  <code>scs()</code> functions behave differently at their default values that is if df and lambda are not specified.
<code>cs(x)</code> by default will use 3 extra degrees of freedom for smoothing for <code>x</code>.
<code>scs(x)</code> by default will estimate lambda (and the degrees of freedom) automatically using generalised cross validation (GCV).
Note that if GCV is used the convergence of the gamlss model  can be less stable compared to a model where the degrees of freedom are fixed. This will be true for small data sets.         
</p>


<h3>Value</h3>

<p>the vector x is returned, endowed with a number of attributes. The vector itself is used in the construction of the model matrix, 
while the attributes are needed for the backfitting algorithms <code>additive.fit()</code>. 
Since smoothing splines includes linear fits, the linear part will be efficiently computed with the other parametric linear parts of the model. 
</p>


<h3>Warning</h3>

<p>For a user who wishes to compare the <code>gamlss()</code> results with the equivalent <code>gam()</code> 
results in S-plus: make sure when using S-plus that the convergence criteria epsilon and bf.epsilon in <code>control.gam()</code> are decreased sufficiently
to ensure proper convergence in S-plus. 
Also note that the degrees of freedom are defined on top of the linear term in <code>gamlss</code>, but on top of the constant term in S-plus, 
(so use an extra degrees of freedom in S-plus in order to obtain comparable results to those in <code>galmss</code>).
</p>
<p>Change the upper limit of spar if you received the warning 'The output df are different from the input, change the control.spar'.
</p>
<p>For large data sets do not use expressions, e.g. <code>cs(x^0.5)</code> inside the <code>gamlss</code> function command but evaluate the expression, 
e.g. nx=<code class="reqn">x^0.5</code>, first and then use <code>cs(nx)</code>.  
</p>


<h3>Note</h3>

<p>The degrees of freedom df are defined differently from that of the gam() function in S-plus. Here df are the additional degrees of freedom 
excluding the constant and the linear part of x. For example <code>df=4</code> in <code>gamlss()</code> is equivalent to <code>df=5</code> in <code>gam()</code> in S-plus </p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby (see also the documentation of the function<code>smooth.spline()</code> for the  original authors of the cubic spline function.)</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in S</em>, Wadsworth &amp; Brooks/Cole.
</p>
<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>, <b>11</b>, 89-121.
</p>
<p>Hastie, T. J. and Tibshirani, R. J. (1993), Varying coefficient models (with discussion),J. R. Statist. Soc. B., <b>55</b>,
757-796.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+gamlss.cs">gamlss.cs</a></code>, <code><a href="#topic+pb">pb</a></code>, <code><a href="#topic+pvc">pvc</a></code>   </p>


<h3>Examples</h3>

<pre><code class='language-R'># cubic splines example
data(aids)
# fitting a smoothing cubic spline with 7 degrees of freedom
# plus the a quarterly  effect  
aids1&lt;-gamlss(y~cs(x,df=7)+qrt,data=aids,family=PO) # 
aids2&lt;-gamlss(y~scs(x,df=5)+qrt,data=aids,family=PO) # 
aids3&lt;-gamlss(y~scs(x)+qrt,data=aids,family=PO) # using GCV 
with(aids, plot(x,y))
lines(aids$x,fitted(aids1), col="red")
lines(aids$x,fitted(aids3), col="green")
rm(aids1, aids2, aids3)
</code></pre>

<hr>
<h2 id='deviance.gamlss'> Global Deviance of a GAMLSS model </h2><span id='topic+deviance.gamlss'></span>

<h3>Description</h3>

<p>Returns the global, -2*log(likelihood), or the penalized, -2*log(likelihood)+ penalties, deviance of a fitted GAMLSS model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
deviance(object,  what = c("G", "P"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="deviance.gamlss_+3A_what">what</code></td>
<td>
<p>put &quot;G&quot; for Global or &quot;P&quot; for Penalized deviance</p>
</td></tr>
<tr><td><code id="deviance.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>deviance</code> is a generic function which can be used to extract deviances
for fitted models.  <code>deviance.gamlss</code> is the method for a GAMLSS object. 
</p>


<h3>Value</h3>

<p>The value of the global or the penalized deviance extracted from a GAMLSS object. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>, <code><a href="#topic+coef.gamlss">coef.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
deviance(h)
rm(h)
</code></pre>

<hr>
<h2 id='devianceIncr'>The global deviance increment</h2><span id='topic+devianceIncr'></span>

<h3>Description</h3>

<p> The  global deviance increment is the contribution of each individual observation to the global deviance.   
The function <code>devianceIncr()</code> can be used to extract the global deviance increment for a fitted gamlss model  or for a new (test/validation) data set. Large values for global deviance increment indicate a bad fit and for new data a bad prediction. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devianceIncr(obj, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devianceIncr_+3A_obj">obj</code></td>
<td>
<p>a gamlss object</p>
</td></tr>
<tr><td><code id="devianceIncr_+3A_newdata">newdata</code></td>
<td>
<p>test data set to check the global deviance increment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the global deviance increments for each observation.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), Appl. Statist., 54, part 3, 1-38.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deviance">deviance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-----------------------------------------------------------------
# Count data set
# fit Poisson model
h1 &lt;- gamlss(Claims~L_Population+L_Accidents+L_KI+L_Popdensity, 
             data=LGAclaims, family=PO)
p1&lt;-devianceIncr(h1)
# fit negative binomial model
h2 &lt;- gamlss(Claims~L_Population+L_Accidents+L_KI+L_Popdensity, 
             data=LGAclaims, family=NBI)
p2&lt;-devianceIncr(h2)
# comparing using boxplots
boxplot(cbind(p1,p2))
# comparing using emphirical cdf
plot(ecdf(p1))
lines(ecdf(p2), col=2)
# comparing agaist the y-values
plot(p1~LGAclaims$Claims, pch=20, col="gray")
points(p2~LGAclaims$Claims, pch="-", col="orange")
#----------------------------------------------------------------
# Continuous data sets
## Not run: 
m1 &lt;- gamlss(head~pb(age), data=db[1:6000,])
p1&lt;-devianceIncr(m1)
m2 &lt;- gamlss(head~pb(age), sigma.fo=~pb(age), nu.fo=~pb(age), 
      tau.fo=~pb(age), data=db[1:6000,], family=BCT)
p2&lt;-devianceIncr(m2)
# comparing using summaries
summary(p1); summary(p2)
# comparing using boxplots
boxplot(cbind(p1,p2))
# comparing using histograms
hist(p1, col=rgb(1,0,0,0.5), xlim=c(0,50), breaks=seq(0,50,2))
hist(p2, col=rgb(0,0,1,0.5), add=T)
# comparing using emphirical cdf
plot(ecdf(p1))
lines(ecdf(p2), col=2)

## End(Not run)
#----------------------------------------------------------------
</code></pre>

<hr>
<h2 id='dtop'>Detrended transformed Owen's plot</h2><span id='topic+dtop'></span>

<h3>Description</h3>

<p>Provides single or multiple detrended transformed  Owen's plot, Owen (1995), for a GAMLSS 
fitted objects or any other fitted object which has the method resid(). This is a diagnostic tool for checking whether the normalised 
quantile residuals are coming from a normal distribution or not. 
This could be true if the horizontal line is within the confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtop(object = NULL, xvar = NULL, resid = NULL,
      type = c("Owen", "JW"), 
      conf.level = c("95", "99"), n.inter = 4, 
      xcut.points = NULL, overlap = 0, 
      show.given = TRUE, cex = 1, pch = 21, 
      line = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtop_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted object or any other fitted object which has the method resid().</p>
</td></tr>
<tr><td><code id="dtop_+3A_xvar">xvar</code></td>
<td>
<p>the explanatory variable against which the detrended Owen's plots will be plotted</p>
</td></tr>
<tr><td><code id="dtop_+3A_resid">resid</code></td>
<td>
<p>if the object is not specified the residual vector can be given here</p>
</td></tr>
<tr><td><code id="dtop_+3A_type">type</code></td>
<td>
<p>whether to use Owen (1995) or Jager and Wellner (2004) approximate formula</p>
</td></tr>
<tr><td><code id="dtop_+3A_conf.level">conf.level</code></td>
<td>
<p>95 (default) or 99 percent confidence interval for the plots</p>
</td></tr>
<tr><td><code id="dtop_+3A_n.inter">n.inter</code></td>
<td>
<p>he number of intervals in which the explanatory variable xvar will be cut</p>
</td></tr>
<tr><td><code id="dtop_+3A_xcut.points">xcut.points</code></td>
<td>
<p>the x-axis cut off points e.g. c(20,30). If xcut.points=NULL then the n.inter argument is activated</p>
</td></tr>
<tr><td><code id="dtop_+3A_overlap">overlap</code></td>
<td>
<p>how much overlapping in the xvar intervals. Default value is overlap=0 for non overlapping intervals</p>
</td></tr>
<tr><td><code id="dtop_+3A_show.given">show.given</code></td>
<td>
<p>whether to show the x-variable intervals in the top of the graph, default is show.given=TRUE</p>
</td></tr>
<tr><td><code id="dtop_+3A_cex">cex</code></td>
<td>
<p>the cex plotting parameter with default cex=1</p>
</td></tr>
<tr><td><code id="dtop_+3A_pch">pch</code></td>
<td>
<p>the pch plotting parameter with default pch=21</p>
</td></tr>
<tr><td><code id="dtop_+3A_line">line</code></td>
<td>
<p>whether the detrended empirical cdf should be plotted or not</p>
</td></tr>
<tr><td><code id="dtop_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the xvar argument is not specified then a single detrended Owen's plot is used, see Owen (1995). In this case the plot is a detrended nonparametric likelihood confidence band for a distribution function. That is, if the horizontal lines lies within the confidence band then the normalised residuals could have come from a Normal distribution and consequently the assumed response variable distribution is reasonable. If the xvar is specified then we have as many plots as n.iter. In this case the x-variable is cut into n.iter intervals with an equal number observations and detrended Owen's plots for each interval are plotted. This is a way of highlighting failures of the model within different ranges of the explanatory variable.</p>


<h3>Value</h3>

<p>A plot is returned.</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Vlassios Voudouris</p>


<h3>References</h3>

<p>Jager, L. and Wellner, J. A (2004) A new goodness of fit test: the reversed Berk-Jones statistic, University of Washington, Department of Statistics, Technical report 443.    
</p>
<p>Owen A. B. (1995) Nonparametric Confidence Bands for a Distribution Function. Journal of the American Statistical Association Vol. 90, No 430, pp. 516-521.
</p>
<p>Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), Appl. Statist., 54, part 3, 1-38.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wp">wp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
a&lt;-gamlss(y~pb(x),sigma.fo=~pb(x,1),family=LO,data=abdom)
dtop(a)
dtop(a, xvar=abdom$x)
rm(a)
</code></pre>

<hr>
<h2 id='edf'>
Effective degrees of freedom from  gamlss model
</h2><span id='topic+edf'></span><span id='topic+edfAll'></span>

<h3>Description</h3>

<p>The functions <code>edf()</code> and <code>edfAll()</code> can be used to obtained the effective degrees of freedom for 
different additive terms for the distribution parameters in a gamlss model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edf(obj, what = c("mu", "sigma", "nu", "tau"),
    parameter= NULL, print = TRUE, ...)
edfAll(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edf_+3A_obj">obj</code></td>
<td>
<p>A gamlss fitted model</p>
</td></tr>
<tr><td><code id="edf_+3A_what">what</code></td>
<td>
<p>which of the four parameters <code>mu</code>, <code>sigma</code>, <code>nu</code> or <code>tau</code>.</p>
</td></tr>
<tr><td><code id="edf_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="edf_+3A_print">print</code></td>
<td>
<p>whether to print the label</p>
</td></tr>
<tr><td><code id="edf_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>edfAll()</code> re turns a list of edf for  all the fitted parameters.
The function <code>edf()</code> a vector of edf.    
</p>


<h3>Note</h3>

<p>The edf given are the ones fitted in the backfitting so the usually contained (depending on the additive term)
the contatnt and the linear part.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gamlss.data)
data(usair)
m1&lt;- gamlss(y~pb(x1)+pb(x2)+pb(x6), data=usair)
edfAll(m1)
edf(m1)
</code></pre>

<hr>
<h2 id='find.hyper'>A function to select values of hyper-parameters in a GAMLSS model </h2><span id='topic+find.hyper'></span>

<h3>Description</h3>

<p>This function selects the values of hyper parameters and/or non-linear parameters in a GAMLSS model. It uses the <span class="rlang"><b>R</b></span> function <code>optim</code> 
which then minimises the generalised Akaike information criterion (GAIC) with a user defined penalty. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.hyper(model = NULL, parameters = NULL, other = NULL, k = 2,
        steps = c(0.1), lower = -Inf, upper = Inf, method = "L-BFGS-B",
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.hyper_+3A_model">model</code></td>
<td>
<p>this is a GAMLSS model in <code>quote()</code>. e.g. <br />
<code>quate(gamlss(y~cs(x,df=p[1]),sigma.fo=~cs(x,df=p[2]),data=abdom))</code> 
where p[1] and p[2] denote the parameters to be estimated</p>
</td></tr>
<tr><td><code id="find.hyper_+3A_parameters">parameters</code></td>
<td>
<p>the starting values in the search of the optimum hyper-parameters and/or non-linear parameters e.g. <code>parameters=c(3,3)</code>  </p>
</td></tr>
<tr><td><code id="find.hyper_+3A_other">other</code></td>
<td>
<p>this is used to optimise other non-parameters, for example a transformation of the explanatory variable of the kind <code class="reqn">x^{p[3]}</code>,
<code>others=quote(nx&lt;-x^p[3])</code> where <code>nx</code> is now in the model formula </p>
</td></tr>
<tr><td><code id="find.hyper_+3A_k">k</code></td>
<td>
<p>specifies the penalty in the GAIC, (the default is 2) e.g. <code>k=3</code></p>
</td></tr>
<tr><td><code id="find.hyper_+3A_steps">steps</code></td>
<td>
<p>the steps taken in the optimisation procedure [see the <code>ndeps</code> option in <code>optim()</code>], by default is set to 0.1 for all hyper parameters and non-linear parameters</p>
</td></tr>
<tr><td><code id="find.hyper_+3A_lower">lower</code></td>
<td>
<p>the lower permissible level of the parameters  i.e. <code>lower=c(1,1)</code> this does not apply if a method other than the default method &quot;L-BFGS-B&quot; is used </p>
</td></tr>
<tr><td><code id="find.hyper_+3A_upper">upper</code></td>
<td>
<p>the upper permissible level of the parameters  i.e. <code>upper=c(30,10)</code>, this is not apply if a method other than the default method &quot;L-BFGS-B&quot; is used </p>
</td></tr>
<tr><td><code id="find.hyper_+3A_method">method</code></td>
<td>
<p>the method used in <code>optim()</code> to numerically minimise the GAIC over the hyper-parameters and/or non-linear parameters.  By default this is &quot;L-BFGS-B&quot; to allow box-restriction on the parameters </p>
</td></tr>
<tr><td><code id="find.hyper_+3A_...">...</code></td>
<td>
<p>for extra arguments to be passed to the <code>R</code> function <code>optim()</code> used in the optimisation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This historically was an experimental function which worked well for the search of the optimum degrees of freedom and non-linear parameters  (e.g. power parameter <code class="reqn">\lambda</code> used to transform <code>x</code> to <code class="reqn">x^\lambda</code>). 
With the introduction of the P-Spline smoothing function <code>pb()</code> the function <code>find.hyper()</code> became almost redundant.  <code>find.hyper()</code> takes lot longer than <code>pb()</code> to find automatically the hyper parameters while both method produce similar results. See below the examples for a small demonstration. 
</p>


<h3>Value</h3>

<p>The function turns the same output as the function <code>optim()</code>
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>the optimum hyper-parameter values</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the minimised value of the GAIC</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>A two-element integer vector giving the number of calls to &lsquo;fn&rsquo; and &lsquo;gr&rsquo; respectively </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code. &lsquo;0&rsquo; indicates successful convergence. see the function <code>optim()</code> for other errors</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving any additional information returned by the optimiser, or &lsquo;NULL&rsquo;</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>It may be slow to find the optimum</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos </p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+plot.gamlss">plot.gamlss</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(abdom)
# Example estimating the smoothing parameters for mu and 
# the transformation parameters for x
# declare the model
mod1&lt;-quote(gamlss(y~cs(nx,df=p[1]),family=BCT,data=abdom,
                        control=gamlss.control(trace=FALSE)))
# since we want also to find the transformation for x 
# we use the "other"" option
op &lt;- find.hyper(model=mod1, other=quote(nx&lt;-x^p[2]), parameters=c(3,0.5), 
            lower=c(1,0.001), steps=c(0.1,0.001))
op
# the optimum parameters found are 
# p = (p[1],p[2]) = (3.113218 0.001000) = (df for mu, lambda)
# so it needs df = 3 on top of the constant and linear 
# in  the cubic spline model for mu since p[1] is approximately  3
#  and log transformation for x since p[2] is approximately  0 
# here is an example with no data declaration in define the model
# we have to attach the data
attach(abdom)
mod2 &lt;- quote(gamlss(y~cs(nx,df=p[1]),family=BCT,
                control=gamlss.control(trace=FALSE)))
op2&lt;-find.hyper(model=mod2, other=quote(nx&lt;-x^p[2]), parameters=c(3,0.5), 
                lower=c(1,0.001), steps=c(0.1,0.001))
op2
detach(abdom)
#--------------------------------------------------------------
# showing different ways of estimating the smoothing parameter
# get the df using local ML (PQL) 
m0 &lt;- gamlss(y~pb(x), data=abdom)
# get the df using local GAIC 
m1&lt;-gamlss(y~pb(x, method="GAIC", k=2), data=abdom)
# fiiting cubic splines with fixed df's at 3
m2&lt;-gamlss(y~cs(x, df=3), data=abdom)
# fitting cubic splines using find hyper (global GAIC)
mod1 &lt;- quote(gamlss(y~cs(x, df=p[1]),family=BCT,data=abdom,control=gamlss.control(trace=FALSE)))
op &lt;- find.hyper(model=mod1, parameters=c(3), lower=c(1,0.001), steps=c(0.1,0.001))
# now fit final model
m3 &lt;- gamlss(y~cs(x, df=op$par), data=abdom)
# effetive degrees of fredom for the 4 models
edf(m0);edf(m1); m2$mu.df; m3$mu.df
# deviances for the four models
deviance(m0); deviance(m1); deviance(m2); deviance(m3)
# their GAIC
GAIC(m0,m1,m2,m3)
# plotting  the models
plot(y~x, data=abdom, type="n")
lines(fitted(m3)~abdom$x, col="red")
lines(fitted(m1)~abdom$x, col="green")
lines(fitted(m0)~abdom$x, col="blue")
# almost identical

## End(Not run) 
</code></pre>

<hr>
<h2 id='fitDist'>
Fitting Different Parametric <code>gamlss.family</code> Distributions.
</h2><span id='topic+fitDist'></span><span id='topic+fitDistPred'></span><span id='topic+chooseDist'></span><span id='topic+chooseDistPred'></span><span id='topic+getOrder'></span>

<h3>Description</h3>

<p>The function <code>fitDist()</code> is using the function <code>gamlssML()</code> to fit all relevant parametric <code>gamlss.family</code> distributions, specified by the argument <code>type</code>), to a single data vector (with no explanatory variables).  The final marginal distribution  is the one selected by the generalised Akaike information criterion with penalty <code>k</code>. The default is  <code>k=2</code> i.e AIC.
</p>
<p>The function <code>fitDistPred()</code> is using the function <code>gamlssMLpred()</code> to fit all relevant (marginal) parametric <code>gamlss.family</code> distributions to a single data vector (similar to <code>fitDist()</code>)  but the final model is selected by the minimum prediction global deviance. The user has to specify the training  and validation/test samples.
</p>
<p>The function <code>chooseDist()</code> is using the function <code>update.gamlss()</code> to fit all relevant parametric (conditional)  <code>gamlss.family</code> distributions to a given fitted <code>gamlss</code> model.  The output of the function is a matrix with  rows the different distributions (from the argument <code>type</code>) and columns the different GAIC's (). The default argument for <code>k</code> are 2, for AIC, 3.84, for Chi square, and log(n) for BIC.  No final model is given by the function  like for example  in <code>fitDist()</code>.   The function <code>getOrder()</code> can be used to rank the columns of the resulting table (matrix).
The final model can be refitted using <code>update()</code>, see the examples.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDist(y, k = 2, 
    type = c("realAll", "realline", "realplus", "real0to1", "counts", "binom"), 
    try.gamlss = FALSE, extra = NULL, data = NULL,trace = FALSE, ...)

fitDistPred(y, 
    type = c("realAll", "realline", "realplus", "real0to1", "counts", "binom"), 
    try.gamlss = FALSE, extra = NULL, data = NULL, rand = NULL,
    newdata = NULL, trace = FALSE, ...)    
      
chooseDist(object, k = c(2, 3.84, round(log(length(object$y)), 2)), type = 
    c("realAll", "realline", "realplus", "real0to1", "counts", "binom","extra"), 
    extra = NULL, trace = FALSE, 
    parallel = c("no", "multicore", "snow"), ncpus = 1L, cl = NULL, ...)

chooseDistPred(object, type = c("realAll", "realline", "realplus", 
     "real0to1", "counts", "binom", "extra"), extra = NULL, 
     trace = FALSE, parallel = c("no", "multicore", "snow"), 
     ncpus = 1L, cl = NULL, newdata = NULL, rand = NULL, ...)
      
getOrder(obj, column = 1)      
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDist_+3A_y">y</code></td>
<td>
<p>the data vector</p>
</td></tr>
<tr><td><code id="fitDist_+3A_object">object</code>, <code id="fitDist_+3A_obj">obj</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="fitDist_+3A_k">k</code></td>
<td>
<p>the penalty for the GAIC with default values <code>k=2</code> the standard AIC.  In the case of the function <code>chooseDist()</code> <code>k</code> can be a vector i.e. <code>k= c(2, 4, 6)</code> so more than one GAIC are saved.</p>
</td></tr>
<tr><td><code id="fitDist_+3A_type">type</code></td>
<td>
<p>the type of distribution to be tried see details</p>
</td></tr>
<tr><td><code id="fitDist_+3A_try.gamlss">try.gamlss</code></td>
<td>
<p>this applies to functions <code>fitDist()</code> and <code>fitDistPred()</code>.  It allows if  <code>gamlssML()</code> fail to fit the model to try <code>gamlss</code> instead. This will slow up things for big data.</p>
</td></tr>
<tr><td><code id="fitDist_+3A_extra">extra</code></td>
<td>
<p>whether extra distributions should be tried, which are not in the <code>type</code> list. Note that the function <code>chooseDist()</code> allows the fitting of only the &lsquo;extra&rsquo; distributions. This can be achieved if <code>extra</code> is set i.e. <code>extra=c("GA", "IG", "GG")</code> and type is set to extra i.e. <code>type="extra"</code>. </p>
</td></tr>
<tr><td><code id="fitDist_+3A_data">data</code></td>
<td>
<p>the data frame where <code>y</code> can be found, only for functions <code>fitDist()</code> and <code>fitDistPred()</code> </p>
</td></tr>
<tr><td><code id="fitDist_+3A_rand">rand</code></td>
<td>
<p>For <code>fitDistPred()</code> a factor with values 1 (for fitting) and 2 (for predicting).</p>
</td></tr>
<tr><td><code id="fitDist_+3A_newdata">newdata</code></td>
<td>
<p>The prediction data  set (validation or test).</p>
</td></tr>
<tr><td><code id="fitDist_+3A_trace">trace</code></td>
<td>
<p>whether to print during fitting. Note that when <code>parallel</code>  is 'multocore' or &quot;snow&quot; <code>"trace"</code> is not  produce any output.</p>
</td></tr>
<tr><td><code id="fitDist_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="fitDist_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically     one would chose this to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="fitDist_+3A_cl">cl</code></td>
<td>
<p>This is useful for snow clusters, i.e. <code>parallel = "snow"</code>, when the clusters are created in advance. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr> 
<tr><td><code id="fitDist_+3A_column">column</code></td>
<td>
<p>which column of the output matrix to be ordered according to best GAIC</p>
</td></tr>
<tr><td><code id="fitDist_+3A_...">...</code></td>
<td>
<p>for extra arguments to be passed to gamlssML() to gamlss()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following are the different <code>type</code> argument:
</p>

<ul>
<li><p>realAll: All the <code>gamlss.family</code> continuous distributions defined on the real line, i.e. <code>realline</code> and the real positive line i.e. <code>realplus</code>.
</p>
</li>
<li><p>realline: The <code>gamlss.family</code> continuous distributions : &quot;NO&quot;, &quot;GU&quot;, &quot;RG&quot; ,&quot;LO&quot;, &quot;NET&quot;, &quot;TF&quot;, &quot;TF2&quot;, &quot;PE&quot;,&quot;PE2&quot;, &quot;SN1&quot;, &quot;SN2&quot;, &quot;exGAUS&quot;, &quot;SHASH&quot;, &quot;SHASHo&quot;,&quot;SHASHo2&quot;, &quot;EGB2&quot;, &quot;JSU&quot;, &quot;JSUo&quot;, &quot;SEP1&quot;, &quot;SEP2&quot;, &quot;SEP3&quot;, &quot;SEP4&quot;,  &quot;ST1&quot;, &quot;ST2&quot;, &quot;ST3&quot;, &quot;ST4&quot;, &quot;ST5&quot;, &quot;SST&quot;, &quot;GT&quot;.
</p>
</li>
<li><p>realplus: The <code>gamlss.family</code> continuous distributions in the positive real line: &quot;EXP&quot;, &quot;GA&quot;,&quot;IG&quot;,&quot;LOGNO&quot;, &quot;LOGNO2&quot;,&quot;WEI&quot;, &quot;WEI2&quot;, &quot;WEI3&quot;, &quot;IGAMMA&quot;,&quot;PARETO2&quot;, &quot;PARETO2o&quot;, &quot;GP&quot;, &quot;BCCG&quot;, &quot;BCCGo&quot;, &quot;exGAUS&quot;, &quot;GG&quot;, &quot;GIG&quot;, &quot;LNO&quot;,&quot;BCTo&quot;, &quot;BCT&quot;, &quot;BCPEo&quot;, &quot;BCPE&quot;, &quot;GB2&quot;.
</p>
</li>
<li><p>real0to1: The <code>gamlss.family</code> continuous distributions from 0 to 1: &quot;BE&quot;, &quot;BEo&quot;, &quot;BEINF0&quot;, &quot;BEINF1&quot;, &quot;BEOI&quot;, &quot;BEZI&quot;, &quot;BEINF&quot;, &quot;GB1&quot;.
</p>
</li>
<li><p>counts: The <code>gamlss.family</code> distributions for counts: &quot;PO&quot;, &quot;GEOM&quot;, &quot;GEOMo&quot;,&quot;LG&quot;, &quot;YULE&quot;, &quot;ZIPF&quot;, &quot;WARING&quot;, &quot;GPO&quot;, &quot;DPO&quot;, &quot;BNB&quot;, &quot;NBF&quot;,&quot;NBI&quot;, &quot;NBII&quot;, &quot;PIG&quot;, &quot;ZIP&quot;,&quot;ZIP2&quot;, &quot;ZAP&quot;, &quot;ZALG&quot;, &quot;DEL&quot;, &quot;ZAZIPF&quot;, &quot;SI&quot;, &quot;SICHEL&quot;,&quot;ZANBI&quot;,  &quot;ZAPIG&quot;, &quot;ZINBI&quot;,  &quot;ZIPIG&quot;, &quot;ZINBF&quot;, &quot;ZABNB&quot;, &quot;ZASICHEL&quot;, &quot;ZINBF&quot;,  &quot;ZIBNB&quot;, 
&quot;ZISICHEL&quot;.
</p>
</li>
<li><p>binom: The <code>gamlss.family</code> distributions for binomial type data :&quot;BI&quot;, &quot;BB&quot;, &quot;DB&quot;, &quot;ZIBI&quot;, &quot;ZIBB&quot;, &quot;ZABI&quot;, &quot;ZABB&quot;.
</p>
<p>The function <code>fitDist()</code> uses the function <code>gamlssML()</code> to fit the different models, the function  <code>fitDistPred()</code> uses  <code>gamlssMLpred()</code> and the function <code>chooseDist()</code> used <code>update.gamlss()</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>For the functions <code>fitDist()</code> and <code>fitDistPred()</code> a <code>gamlssML</code> object is return (the one which minimised the GAIC or VDEV respectively) with two extra components: 
</p>
<table>
<tr><td><code>fits</code></td>
<td>
<p>an ordered list according to the GAIC of the fitted distribution</p>
</td></tr>
<tr><td><code>failed</code></td>
<td>
<p>the distributions where the <code>gamlssML)()</code> (or <code>gamlss()</code>) fits have failed</p>
</td></tr>
</table>
<p>For the function <code>chooseDist()</code> a matrix is returned,   with rows the different distributions and columns the different GAIC's  set by <code>k</code>.   
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby, Vlasis Voudouris  and Majid Djennad.
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+gamlssML">gamlssML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rt(100, df=1)
m1&lt;-fitDist(y, type="realline")
m1$fits
m1$failed
# an example of using  extra
## Not run: 
#---------------------------------------  
# Example of using the argument extra  
library(gamlss.tr)
data(tensile)
gen.trun(par=1,family="GA", type="right")
gen.trun(par=1,"LOGNO", type="right")
gen.trun(par=c(0,1),"TF", type="both")
ma&lt;-fitDist(str, type="real0to1", trace=T,
       extra=c("GAtr", "LOGNOtr", "TFtr"), 
     data=tensile) 
ma$fits
ma$failed
#-------------------------------------
# selecting model using the prediction global deviance
# Using fitDistPred
# creating training data
y &lt;- rt(1000, df=2)
m1 &lt;- fitDist(y, type="realline")
m1$fits
m1$fails
# create validation data
yn &lt;- rt(1000, df=2)
# choose distribution which fits the new data best
p1 &lt;- fitDistPred(y, type="realline", newdata=yn)
p1$fits
p1$failed
#---------------------------------------
# using the function chooseDist()
# fitting normal distribution model
m1 &lt;- gamlss(y~pb(x), sigma.fo=~pb(x), family=NO, data=abdom)
# choose a distribution on the real line 
# and save GAIC(k=c(2,4,6.4),  i.e. AIC, Chi-square and BIC.   
t1 &lt;- chooseDist(m1, type="realline", parallel="snow", ncpus=4)
# the GAIC's
t1
# the distributions which failed are with NA's 
# ordering according to  BIC
getOrder(t1,3)
fm&lt;-update(m1, family=names(getOrder(t1,3)[1]))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.gamlss'>Extract Fitted Values For A GAMLSS Model </h2><span id='topic+fitted.gamlss'></span><span id='topic+fv'></span>

<h3>Description</h3>

<p><code>fitted.gamlss</code> is the GAMLSS specific method for the generic function 
<code>fitted</code> which extracts fitted values for a specified parameter from  a GAMLSS objects.  <code>fitted.values</code> is an
alias for it. The function <code>fv()</code> is similar to <code>fitted.gamlls()</code> but allows the argument <code>what</code> not to be character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
fitted(object, what = c("mu", "sigma", "nu", "tau"),
                parameter= NULL, ...)
fv(obj, what = c("mu", "sigma", "nu", "tau"), parameter= NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="fitted.gamlss_+3A_obj">obj</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="fitted.gamlss_+3A_what">what</code></td>
<td>
<p>which parameter fitted values  are required, default <code>what="mu"</code> </p>
</td></tr>
<tr><td><code id="fitted.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="fitted.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values extracted from the GAMLSS object for the given parameter.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.gamlss">print.gamlss</a></code>, <code><a href="#topic+summary.gamlss">summary.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code>,  <code><a href="#topic+coef.gamlss">coef.gamlss</a></code>,  
<code><a href="#topic+residuals.gamlss">residuals.gamlss</a></code>, <code><a href="#topic+update.gamlss">update.gamlss</a></code>,  <code><a href="#topic+plot.gamlss">plot.gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>, 
<code><a href="#topic+formula.gamlss">formula.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
fitted(h)
rm(h)
</code></pre>

<hr>
<h2 id='fittedPlot'>Plots The Fitted Values of a GAMLSS Model</h2><span id='topic+fittedPlot'></span>

<h3>Description</h3>

<p>This function, applicable only to a models with a single explanatory variable, plots the fitted values for all the parameters
of a GAMLSS model against the (one) explanatory variable. It is also useful for comparing the fits for more than one model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fittedPlot(object, ..., x = NULL, color = TRUE, line.type = FALSE, xlab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fittedPlot_+3A_object">object</code></td>
<td>
<p>a fitted GAMLSS model object(with only one explanatory variable)</p>
</td></tr>
<tr><td><code id="fittedPlot_+3A_...">...</code></td>
<td>
<p>optionally more fitted GAMLSS model objects </p>
</td></tr>
<tr><td><code id="fittedPlot_+3A_x">x</code></td>
<td>
<p>The unique explanatory variable </p>
</td></tr>
<tr><td><code id="fittedPlot_+3A_color">color</code></td>
<td>
<p>whether the fitted lines plots are shown in colour, <code>color=TRUE</code> (the default) or not <code>color=FALSE</code></p>
</td></tr>
<tr><td><code id="fittedPlot_+3A_line.type">line.type</code></td>
<td>
<p>whether the line type should be different or not. The default is  <code>color=FALSE</code></p>
</td></tr>
<tr><td><code id="fittedPlot_+3A_xlab">xlab</code></td>
<td>
<p>the x-label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the fitted values against the explanatory variable 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Calliope Akantziliotou </p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles">centiles</a></code>, <code><a href="#topic+centiles.split">centiles.split</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
h1&lt;-gamlss(y~pb(x), sigma.formula=~x, family=BCT, data=abdom)
h2&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom)
fittedPlot(h1,h2,x=abdom$x)
rm(h1,h2)
</code></pre>

<hr>
<h2 id='formula.gamlss'>Extract the Model Formula in a GAMLSS fitted model</h2><span id='topic+formula.gamlss'></span>

<h3>Description</h3>

<p><code>formula.gamlss</code> is the GAMLSS specific method for the generic function <code>formula</code> which extracts the model formula
from objects returned by modelling functions.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
formula(x, what = c("mu", "sigma", "nu", "tau"), 
                parameter= NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.gamlss_+3A_x">x</code></td>
<td>
<p>a GAMLSS fitted model </p>
</td></tr>
<tr><td><code id="formula.gamlss_+3A_what">what</code></td>
<td>
<p>which parameter coefficient is required, default <code>what="mu"</code> </p>
</td></tr>
<tr><td><code id="formula.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="formula.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a model formula 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
formula(h,"mu")
rm(h)
</code></pre>

<hr>
<h2 id='gamlss'>Generalized Additive Models for Location Scale and Shape</h2><span id='topic+gamlss'></span><span id='topic+is.gamlss'></span><span id='topic+gamlssNews'></span>

<h3>Description</h3>

<p>Returns an object of class &quot;gamlss&quot;, which is a generalized additive model for location scale and shape (GAMLSS).
The function <code>gamlss()</code> is very similar to the <code>gam()</code> function in S-plus (now also in R in package <code>gam</code>), but
can fit more distributions (not only the ones belonging to the  exponential family) and can model all the parameters of the
distribution as functions of the explanatory variables (e.g. using linear, non-linear, smoothing, <code>loess</code> and random effects terms).
</p>
<p>This implementation of <code>gamlss()</code> allows modelling of up to four
parameters in a distribution family, which are conventionally called <code>mu</code>, <code>sigma</code>, <code>nu</code> and <code>tau</code>.
</p>
<p>The function <code>gamlssNews()</code> shows what is new in the current implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss(formula = formula(data), sigma.formula = ~1, 
        nu.formula = ~1, tau.formula = ~1, family = NO(), 
        data, weights = NULL, 
        contrasts = NULL, method = RS(),  start.from = NULL,  
        mu.start = NULL,  sigma.start = NULL, 
        nu.start = NULL, tau.start = NULL, 
        mu.fix = FALSE, sigma.fix = FALSE, nu.fix = FALSE, 
        tau.fix = FALSE, control = gamlss.control(...), 
        i.control = glim.control(...), ...)
is.gamlss(x)
gamlssNews()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of an ~ operator, and the terms, separated by <code class="reqn">+</code> operators, on the right.
Nonparametric smoothing terms are indicated by <code>pb()</code> for penalised beta splines, <code>cs</code> for smoothing splines, <code>lo</code> for <code>loess</code> smooth terms and <code>random</code> or <code>ra</code>
for random terms, e.g. <code>y~cs(x,df=5)+x1+x2*x3</code>.  Additional smoothers can be added by creating the appropriate interface.
Interactions with nonparametric smooth terms are not fully supported, but will not produce errors;
they will simply produce the usual parametric interaction 
</p>
</td></tr>
<tr><td><code id="gamlss_+3A_sigma.formula">sigma.formula</code></td>
<td>
<p>a formula object for fitting a model to the sigma parameter, as in the formula above,
e.g.  <code>sigma.formula=~cs(x,df=5)</code>. It can be abbreviated to <code>sigma.fo=~cs(x,df=5)</code>. </p>
</td></tr>
<tr><td><code id="gamlss_+3A_nu.formula">nu.formula</code></td>
<td>
<p>a formula object for fitting a model to the nu parameter, e.g. <code>nu.fo=~x</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_tau.formula">tau.formula</code></td>
<td>
<p>a formula object for fitting a model to the tau parameter, e.g. <code>tau.fo=~cs(x,df=2)</code></p>
</td></tr>
<tr><td><code id="gamlss_+3A_family">family</code></td>
<td>
<p>a <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code> object, which is used to define the distribution and the link functions of the various parameters. 
The distribution families supported by <code>gamlss()</code> can be found in <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>.
Functions such as BI() (binomial) produce a family object. Also can be given without the parentheses i.e. <code>BI</code>.
Family functions can take arguments, as in <code>BI(mu.link=probit)</code></p>
</td></tr> 
<tr><td><code id="gamlss_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables occurring in the formula, e.g. <code>data=aids</code>. If this is missing, the variables should be on the search list.</p>
</td></tr>





<tr><td><code id="gamlss_+3A_weights">weights</code></td>
<td>
<p>a vector of weights. Note that this is not the same as in the glm() or gam() function. 
Here weights can be used to weight out observations (like in <code>subset</code>) or for a weighted likelihood analysis where 
the contribution of the observations to the likelihood differs according to <code>weights</code>. 
The length of <code>weights</code> must be the same as the number of observations in the data. 
By default, the weight is set to one. To set  weights to vector <code>w</code> use <code>weights=w</code></p>
</td></tr>
<tr><td><code id="gamlss_+3A_contrasts">contrasts</code></td>
<td>
<p>list of contrasts to be used for some or all of the factors appearing as variables in the model formula. 
The names of the list should be the names of the corresponding variables. 
The elements should either be contrast-type matrices (matrices with as many rows as levels of the factor and with columns 
linearly independent of each other and of a column of ones), or else they should be functions that compute such contrast matrices.</p>
</td></tr>
<tr><td><code id="gamlss_+3A_method">method</code></td>
<td>
<p>the current algorithms for GAMLSS are RS(), CG() and mixed(). i.e. <code>method=RS()</code> will use the Rigby and Stasinopoulos algorithm, 
<code>method=CG()</code> will use the Cole and Green algorithm and 
<code>mixed(2,10)</code> will use the RS algorithm twice before switching to the Cole and Green algorithm for up to 10 extra iterations</p>
</td></tr>
<tr><td><code id="gamlss_+3A_start.from">start.from</code></td>
<td>
<p>a fitted GAMLSS model which the fitted values will be used as staring values for the current model</p>
</td></tr>
<tr><td><code id="gamlss_+3A_mu.start">mu.start</code></td>
<td>
<p> vector or scalar of initial values for the location parameter mu e.g.  <code>mu.start=4</code>  </p>
</td></tr>
<tr><td><code id="gamlss_+3A_sigma.start">sigma.start</code></td>
<td>
<p> vector or scalar of initial values for the scale parameter sigma e.g. <code>sigma.start=1</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_nu.start">nu.start</code></td>
<td>
<p> vector or scalar of initial values for the parameter nu e.g. <code>nu.start=3</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_tau.start">tau.start</code></td>
<td>
<p> vector or scalar of initial values for the location parameter tau e.g. <code>tau.start=2</code></p>
</td></tr>
<tr><td><code id="gamlss_+3A_mu.fix">mu.fix</code></td>
<td>
<p> whether the mu parameter should be kept fixed in the fitting processes e.g. <code>mu.fix=FALSE</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_sigma.fix">sigma.fix</code></td>
<td>
<p>whether the sigma parameter should be kept fixed in the fitting processes e.g. <code>sigma.fix=FALSE</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_nu.fix">nu.fix</code></td>
<td>
<p> whether the nu parameter should be kept fixed in the fitting processes e.g. <code>nu.fix=FALSE</code> </p>
</td></tr>
<tr><td><code id="gamlss_+3A_tau.fix">tau.fix</code></td>
<td>
<p>whether the tau parameter should be kept fixed in the fitting processes e.g. <code>tau.fix=FALSE</code></p>
</td></tr>
<tr><td><code id="gamlss_+3A_control">control</code></td>
<td>
<p>this sets the control parameters of the outer iterations algorithm. The default setting is the <code><a href="#topic+gamlss.control">gamlss.control</a></code> function </p>
</td></tr>
<tr><td><code id="gamlss_+3A_i.control">i.control</code></td>
<td>
<p>this sets the control parameters of the inner iterations of the RS algorithm. The default setting is the <code><a href="#topic+glim.control">glim.control</a></code> function  </p>
</td></tr>
<tr><td><code id="gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
<tr><td><code id="gamlss_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generalized Additive Model for Location, Scale and Shape
is a general class of statistical models for a univariate
response variable. The model assumes independent observations of the response variable
y given the parameters, the explanatory variables and the values
of the random effects. The distribution for the response variable
in the GAMLSS can be selected from a very general family of
distributions including highly skew and/or kurtotic continuous and
discrete distributions, see <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>. The systematic part of the model is
expanded to allow modelling not only of the mean (or location) parameter,
but also of the other parameters of the distribution of y, as
linear parametric and/or additive nonparametric  (smooth)
functions of explanatory variables and/or random effects terms.
Maximum (penalized) likelihood estimation is used to fit the
(non)parametric models. A Newton-Raphson/Fisher scoring algorithm
is used to maximize the (penalized) likelihood. The additive terms
in the model are fitted using a backfitting algorithm.
</p>
<p><code>is.gamlss</code> is a short version is <code>is(object,"gamlss")</code>
</p>


<h3>Value</h3>

<p>Returns a gamlss object with components
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>the distribution family of the gamlss object (see <a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a>)</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>the name of the fitted parameters i.e. <b><code>mu</code></b>, <b><code>sigma</code></b>, <b><code>nu</code></b>, <b><code>tau</code></b> </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the gamlss function</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the gamlss fit control settings</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the vector of weights</p>
</td></tr>
<tr><td><code>G.deviance</code></td>
<td>
<p>the global deviance</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of observations in the fit</p>
</td></tr>
<tr><td><code>rqres</code></td>
<td>
<p>a function to calculate the normalized (randomized) quantile residuals of the object</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of external iterations in the fitting process</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the type of the distribution or the response variable (continuous or discrete)</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>which algorithm is used for the fit, RS(), CG() or mixed()</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>whether the model fitting has have converged</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the normalized (randomized) quantile residuals of the model</p>
</td></tr>
<tr><td><code>mu.fv</code></td>
<td>
<p>the fitted values of the mu model, also  sigma.fv, nu.fv, tau.fv for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.lp</code></td>
<td>
<p>the linear predictor of the mu model, also  sigma.lp, nu.lp, tau.lp for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.wv</code></td>
<td>
<p>the working variable of the mu model, also  <code>sigma.wv</code>, <code>nu.wv</code>, <code>tau.wv</code> for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.wt</code></td>
<td>
<p>the working weights of the mu model, also  sigma.wt, nu.wt, tau.wt for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.link</code></td>
<td>
<p>the link function for the mu model, also  sigma.link, nu.link, tau.link for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.terms</code></td>
<td>
<p>the terms for the mu model, also  sigma.terms, nu.terms, tau.terms for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.x</code></td>
<td>
<p>the design matrix for the mu, also  sigma.x, nu.x, tau.x for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.qr</code></td>
<td>
<p>the QR decomposition of the mu model, also sigma.qr, nu.qr, tau.qr for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.coefficients</code></td>
<td>
<p>the linear coefficients of the mu model, also  sigma.coefficients, nu.coefficients, tau.coefficients for the other parameters if present </p>
</td></tr>
<tr><td><code>mu.formula</code></td>
<td>
<p>the formula for the mu model, also  sigma.formula, nu.formula, tau.formula for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.df</code></td>
<td>
<p>the mu degrees of freedom also  sigma.df, nu.df, tau.df for the other parameters if present</p>
</td></tr>
<tr><td><code>mu.nl.df</code></td>
<td>
<p>the non linear degrees of freedom, also sigma.nl.df, nu.nl.df, tau.nl.df for the other parameters if present</p>
</td></tr> 
<tr><td><code>df.fit</code></td>
<td>
<p>the total degrees of freedom use by the model</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom left after the model is fitted</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the Akaike information criterion </p>
</td></tr>
<tr><td><code>sbc</code></td>
<td>
<p>the Bayesian information criterion </p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Respect the parameter hierarchy when you are fitting a model. For example a good model for <code>mu</code> should be fitted before a model for <code>sigma</code> is fitted</p>


<h3>Note</h3>

<p>The following generic functions can be used with a GAMLSS object: <code>print</code>, <code>summary</code>,  <code>fitted</code>,  <code>coef</code>,  
<code>residuals</code>, <code>update</code>,  <code>plot</code>, <code>deviance</code>, <code>formula</code>   </p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby, Calliope Akantziliotou and Vlasios Voudouris</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>, <code><a href="#topic+pdf.plot">pdf.plot</a></code>, <code><a href="#topic+find.hyper">find.hyper</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(abdom)
mod&lt;-gamlss(y~pb(x),sigma.fo=~pb(x),family=BCT, data=abdom, method=mixed(1,20))
plot(mod)
rm(mod)
</code></pre>

<hr>
<h2 id='gamlss-package'>Generalized Additive Models for Location Scale and Shape</h2><span id='topic+gamlss-package'></span>

<h3>Description</h3>

<p>Functions for fitting the Generalized Additive Models for Location Scale and Shape introduced by Rigby and Stasinopoulos (2005), &lt;doi:10.1111/j.1467-9876.2005.00510.x&gt;. The models use a distributional regression approach where all the parameters of the conditional distribution of the response variable are modelled using explanatory variables.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> gamlss</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Generalized Additive Models for Location Scale and Shape</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 5.4-22</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Mikis", "Stasinopoulos", role = c("aut", "cre", "cph"), 
             email = "d.stasinopoulos@gre.ac.uk", comment = c(ORCID = "0000-0003-2407-5704")),
           person("Robert", "Rigby", role = "aut", email = "r.rigby@gre.ac.uk", comment = c(ORCID = "0000-0003-3853-1707")),
           person("Vlasios", "Voudouris", role = "ctb"),
           person("Calliope", "Akantziliotou", role = "ctb"),
           person("Marco", "Enea", role = "ctb"),
           person("Daniil", "Kiose", role = "ctb", comment = c(ORCID = "0000-0002-3596-5748")),
           person("Achim", "Zeileis", role = "ctb", email = "Achim.Zeileis@R-project.org", comment = c(ORCID = "0000-0003-0918-3766"))
           )</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Functions for fitting the Generalized Additive Models for Location Scale and Shape introduced by Rigby and Stasinopoulos (2005), &lt;doi:10.1111/j.1467-9876.2005.00510.x&gt;. The models use a distributional regression approach where all the parameters of the conditional distribution of the response variable are modelled using explanatory variables.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.gamlss.com/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/gamlss-dev/gamlss/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.3.0), graphics, stats, splines, utils, grDevices,
gamlss.data (&gt;= 5.0-0), gamlss.dist (&gt;= 4.3.1), nlme, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS, survival, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> distributions3 (&gt;= 0.2.1)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Mikis Stasinopoulos [aut, cre, cph]
    (&lt;https://orcid.org/0000-0003-2407-5704&gt;),
  Robert Rigby [aut] (&lt;https://orcid.org/0000-0003-3853-1707&gt;),
  Vlasios Voudouris [ctb],
  Calliope Akantziliotou [ctb],
  Marco Enea [ctb],
  Daniil Kiose [ctb] (&lt;https://orcid.org/0000-0002-3596-5748&gt;),
  Achim Zeileis [ctb] (&lt;https://orcid.org/0000-0003-0918-3766&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
.binom                  Lists used by GAMLSS
IC                      Gives the GAIC for a GAMLSS Object
LR.test                 Likelihood Ratio test for nested GAMLSS models
Q.stats                 A function to calculate the Q-statistics
Rsq                     Generalised (Pseudo) R-squared for GAMLSS
                        models
VC.test                 Vuong and Clarke tests
acfResid                ACF plot of the residuals
additive.fit            Implementing Backfitting in GAMLSS
bfp                     Functions to fit fractional polynomials in
                        GAMLSS
bp                      Bucket plot
calibration             Calibrating centile curves
centiles                Plots the centile curves for a GAMLSS object
centiles.com            Comparing centiles from different GAMLSS models
centiles.pred           Creating predictive centiles values
centiles.split          Plots centile curves split by x for a GAMLSS
                        object
coef.gamlss             Extract Model Coefficients in a GAMLSS fitted
                        model
cs                      Specify a Smoothing Cubic Spline Fit in a
                        GAMLSS Formula
deviance.gamlss         Global Deviance of a GAMLSS model
devianceIncr            The global deviance increment
dtop                    Detrended transformed Owen's plot
edf                     Effective degrees of freedom from gamlss model
find.hyper              A function to select values of hyper-parameters
                        in a GAMLSS model
fitDist                 Fitting Different Parametric 'gamlss.family'
                        Distributions.
fitted.gamlss           Extract Fitted Values For A GAMLSS Model
fittedPlot              Plots The Fitted Values of a GAMLSS Model
formula.gamlss          Extract the Model Formula in a GAMLSS fitted
                        model
gamlss                  Generalized Additive Models for Location Scale
                        and Shape
gamlss-package          Generalized Additive Models for Location Scale
                        and Shape
gamlss.control          Auxiliary for Controlling GAMLSS Fitting
gamlss.cs               Support for Function cs() and scs()
gamlss.fp               Support for Function fp()
gamlss.lo               Support for Function lo()
gamlss.ps               Support for Functions for smoothers
gamlss.random           Support for Functions random() and re()
gamlss.scope            Generate a Scope Argument for Stepwise GAMLSS
gamlssML                Maximum Likelihood estimation of a simple
                        GAMLSS model
gamlssVGD               A Set of Functions for selecting Models using
                        Validation or Test Data Sets and Cross
                        Validation
gen.likelihood          A function to generate the likelihood function
                        from a GAMLSS object
getPEF                  Getting the partial effect function from a
                        continuous term in a GAMLSS model
getQuantile             Getting the partial quantile function for a
                        term
getSmo                  Extracting Smoother information from a GAMLSS
                        fitted object
glim.control            Auxiliary for Controlling the inner algorithm
                        in a GAMLSS Fitting
histDist                This function plots the histogram and a fitted
                        (GAMLSS family) distribution to a variable
histSmo                 Density estimation using the Poisson trick
lms                     A function to fit LMS curves for centile
                        estimation
lo                      Specify a loess fit in a GAMLSS formula
loglogSurv              Survival function plots for checking the tail
                        behaviour of the data
lpred                   Extract Linear Predictor Values and Standard
                        Errors For A GAMLSS Model
model.frame.gamlss      Extract a model.frame, a model matrix or terms
                        from a GAMLSS object for a given distributional
                        parameter
numeric.deriv           An internal GAMLSS function for numerical
                        derivatives
par.plot                A function to plot parallel plot for repeated
                        measurement data
pcat                    Reduction for the Levels of a Factor.
pdf.plot                Plots Probability Distribution Functions for
                        GAMLSS Family
plot.gamlss             Plot Residual Diagnostics for an GAMLSS Object
plot.histSmo            A Plotting Function for density estimator
                        object histSmo
plot2way                Function to plot two interaction in a GAMLSS
                        model
polyS                   Auxiliary support for the GAMLSS
predict.gamlss          Extract Predictor Values and Standard Errors
                        For New Data In a GAMLSS Model
print.gamlss            Prints a GAMLSS fitted model
prodist.gamlss          Extracting Fitted or Predicted Probability
                        Distributions from gamlss Models
prof.dev                Plotting the Profile Deviance for one of the
                        Parameters in a GAMLSS model
prof.term               Plotting the Profile: deviance or information
                        criterion for one of the terms (or
                        hyper-parameters) in a GAMLSS model
ps                      P-Splines Fits in a GAMLSS Formula
quantSheets             Quantile Sheets
random                  Specify a random intercept model in a GAMLSS
                        formula
refit                   Refit a GAMLSS model
residuals.gamlss        Extract Residuals from GAMLSS model
ri                      Specify ridge or lasso Regression within a
                        GAMLSS Formula
rqres.plot              Creating and Plotting Randomized Quantile
                        Residuals
rvcov                   Robust Variance-Covariance matrix of the
                        parameters from a fitted GAMLSS model
stepGAIC                Choose a model by GAIC in a Stepwise Algorithm
summary.gamlss          Summarizes a GAMLSS fitted model
term.plot               Plot regression terms for a specified parameter
                        of a fitted GAMLSS object
update.gamlss           Update and Re-fit a GAMLSS Model
wp                      Worm plot
z.scores                Z-scores for lms objects
</pre>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos [aut, cre, cph]
    (&lt;https://orcid.org/0000-0003-2407-5704&gt;),
  Robert Rigby [aut] (&lt;https://orcid.org/0000-0003-3853-1707&gt;),
  Vlasios Voudouris [ctb],
  Calliope Akantziliotou [ctb],
  Marco Enea [ctb],
  Daniil Kiose [ctb] (&lt;https://orcid.org/0000-0002-3596-5748&gt;),
  Achim Zeileis [ctb] (&lt;https://orcid.org/0000-0003-0918-3766&gt;)
</p>
<p>Maintainer: Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;
</p>


<h3>References</h3>

<p>Nelder, J. A. and Wedderburn, R. W. M. (1972). Generalized
linear models. <em>J. R. Statist. Soc.</em> A., <b>135</b> 370-384.
</p>
<p>Hastie, T. J. and Tibshirani, R. J. (1990). <em>Generalized Additive
Models</em>. Chapman and Hall, London.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.dist.html#topic+gamlss.dist">gamlss.dist</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
mod&lt;-gamlss(y~pb(x),sigma.fo=~pb(x),family=BCT, data=abdom, method=mixed(1,20))
plot(mod)
rm(mod)
</code></pre>

<hr>
<h2 id='gamlss.control'>Auxiliary for Controlling GAMLSS Fitting
</h2><span id='topic+gamlss.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code>gamlss</code> fitting. Typically
only used when calling <code>gamlss</code> function with the option <code>control</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.control(c.crit = 0.001, n.cyc = 20, mu.step = 1, sigma.step = 1, nu.step = 1, 
               tau.step = 1, gd.tol = Inf, iter = 0, trace = TRUE, autostep = TRUE, 
               save = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.control_+3A_c.crit">c.crit</code></td>
<td>
<p>the convergence criterion for the algorithm</p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_n.cyc">n.cyc</code></td>
<td>
<p>the number of cycles of the algorithm</p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_mu.step">mu.step</code></td>
<td>
<p>the step length for the parameter <code>mu</code></p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_sigma.step">sigma.step</code></td>
<td>
<p>the step length for the parameter <code>sigma</code> </p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_nu.step">nu.step</code></td>
<td>
<p>the step length for the parameter <code>nu</code> </p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_tau.step">tau.step</code></td>
<td>
<p>the step length for the parameter <code>tau</code> </p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_gd.tol">gd.tol</code></td>
<td>
<p>global deviance tolerance level (set more recently to Inf to allow the algorithm to conversed even if the global deviance change dramatically during the iterations)</p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_iter">iter</code></td>
<td>
<p>starting value for the number of iterations, typically set to 0 unless the function <code><a href="#topic+refit">refit</a></code> is used</p>
</td></tr> 
<tr><td><code id="gamlss.control_+3A_trace">trace</code></td>
<td>
<p>whether to print at each iteration (TRUE) or not (FALSE) </p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_autostep">autostep</code></td>
<td>
<p>whether the steps should be halved automatically if the new global deviance is greater that the old one, 
the default is <code>autostep=TRUE</code>  </p>
</td></tr>
<tr><td><code id="gamlss.control_+3A_save">save</code></td>
<td>
<p><code>save=TRUE</code>, (the default), saves all the information on exit. 
<code>save=FALSE</code> saves only limited information as the global deviance and AIC. 
For example fitted values, design matrices and additive terms are not saved.
The latest is useful when gamlss() is called several times within a procedure. </p>
</td></tr>                  
<tr><td><code id="gamlss.control_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The step length for each of the parameters <code>mu</code>, <code>sigma</code>, <code>nu</code> or <code>tau</code> is very useful to aid convergence 
if the parameter has a fully parametric model.
However using a step length  is not theoretically justified if the model for the parameter includes one or more smoothing terms, 
(even thought it may give a very approximate result). 
</p>
<p>The <code>c.crit</code> can be increased to speed up the convergence especially for a large set of data which takes longer to fit.   
When &lsquo;trace&rsquo; is TRUE, calls to the function <code>cat</code> produce the output for each outer iteration.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby 
</p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
con&lt;-gamlss.control(mu.step=0.1)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids, control=con) # 
rm(h,con)
</code></pre>

<hr>
<h2 id='gamlss.cs'>Support for Function cs() and scs()</h2><span id='topic+gamlss.cs'></span>

<h3>Description</h3>

<p> This is support for the functions cs(), and scs().
It is not intended to be called directly by users. The function <code>gamlss.cs</code> is using  the R function <code>smooth.spline</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.cs(x, y, w, df = NULL, spar = NULL, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.cs_+3A_x">x</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="gamlss.cs_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="gamlss.cs_+3A_w">w</code></td>
<td>
<p> prior weights</p>
</td></tr>
<tr><td><code id="gamlss.cs_+3A_df">df</code></td>
<td>
<p> effective degrees of freedom </p>
</td></tr>
<tr><td><code id="gamlss.cs_+3A_spar">spar</code></td>
<td>
<p>spar the smoothing parameter</p>
</td></tr>
<tr><td><code id="gamlss.cs_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction </p>
</td></tr> 
<tr><td><code id="gamlss.cs_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a class &quot;smooth.spline&quot; object with 
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals of the fit</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The smoothing values </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance for the fitted smoother</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the final value for spar</p>
</td></tr>
<tr><td><code>nl.df</code></td>
<td>
<p>the smoothing degrees of freedom excluding the constant and linear terms, i.e. (df-2)</p>
</td></tr>
<tr><td><code>coefSmo</code></td>
<td>
<p>this is a list containing among others the knots and the coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+cs">cs</a></code> </p>

<hr>
<h2 id='gamlss.fp'> Support for Function fp() </h2><span id='topic+gamlss.pp'></span><span id='topic+gamlss.fp'></span>

<h3>Description</h3>

<p>Those are support for the functions <code>fp()</code> and <code>pp</code>.
It is not intended to be called directly by users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.fp(x, y, w, npoly = 2, xeval = NULL)
gamlss.pp(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.fp_+3A_x">x</code></td>
<td>
<p>the <code>x</code> for function <code>gamlss.fp</code> is referred to the design matrix of the specific parameter model (not to be used by the user)</p>
</td></tr>
<tr><td><code id="gamlss.fp_+3A_y">y</code></td>
<td>
<p>the <code>y</code> for function <code>gamlss.fp</code> is referred to the working variable of the specific parameter model (not to be used by the user)</p>
</td></tr>
<tr><td><code id="gamlss.fp_+3A_w">w</code></td>
<td>
<p>the <code>w</code> for function <code>gamlss.fp</code> is referred to the iterative weight variable of the specific parameter model (not to be used by the user) </p>
</td></tr>
<tr><td><code id="gamlss.fp_+3A_npoly">npoly</code></td>
<td>
<p>a positive indicating how many fractional polynomials should be considered in the fit. Can take the values 1, 2 or 3 with 2 as default </p>
</td></tr>
<tr><td><code id="gamlss.fp_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction </p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a list with
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
</td></tr>
<tr><td><code>nl.df</code></td>
<td>
<p>the trace of the smoothing matrix</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the value of the smoothing parameter</p>
</td></tr>
<tr><td><code>coefSmo</code></td>
<td>
<p>the coefficients from the smoothing fit</p>
</td></tr>
<tr><td><code>varcoeff</code></td>
<td>
<p>the variance of the coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+fp">fp</a></code> </p>

<hr>
<h2 id='gamlss.lo'>Support for Function lo()</h2><span id='topic+gamlss.lo'></span>

<h3>Description</h3>

<p>This is support for the <code>loess</code> function <code>lo()</code>.
It is not intended to be called directly by users. The function <code>gamlss.lo</code> is calling  the <span class="rlang"><b>R</b></span> function <code>loess</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.lo(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.lo_+3A_x">x</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="gamlss.lo_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="gamlss.lo_+3A_w">w</code></td>
<td>
<p> prior weights</p>
</td></tr>
<tr><td><code id="gamlss.lo_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction </p>
</td></tr> 
<tr><td><code id="gamlss.lo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object
</p>
<table>
<tr><td><code>fitted</code></td>
<td>
<p>the smooth values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance of the smoother</p>
</td></tr>
<tr><td><code>nl.df</code></td>
<td>
<p>the non-linear degrees of freedom</p>
</td></tr>
<tr><td><code>coefSmo</code></td>
<td>
<p>with value NULL</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the value of span</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos based on Brian Ripley implementation of <code>loess</code> function in <span class="rlang"><b>R</b></span></p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+lo">lo</a></code> </p>

<hr>
<h2 id='gamlss.ps'>Support for Functions  for smoothers</h2><span id='topic+gamlss.ps'></span><span id='topic+gamlss.pb'></span><span id='topic+gamlss.pbo'></span><span id='topic+gamlss.cy'></span><span id='topic+gamlss.pvc'></span><span id='topic+gamlss.ri'></span><span id='topic+gamlss.pbm'></span><span id='topic+gamlss.pbz'></span><span id='topic+gamlss.pbc'></span><span id='topic+gamlss.pbp'></span>

<h3>Description</h3>

<p>Those functions  are support for the functions  <code>pb()</code>, <code>pbo()</code>,  <code>ps()</code>,  <code>ridge()</code>,  <code>ri()</code>,  <code>cy()</code>,  <code>pvc()</code>,  and <code>pbm()</code>.
The functions are not intended to be called directly by users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.pb(x, y, w, xeval = NULL, ...)
gamlss.pbo(x, y, w, xeval = NULL, ...)
gamlss.ps(x, y, w, xeval = NULL, ...)
gamlss.ri(x, y, w, xeval = NULL, ...)
gamlss.cy(x, y, w, xeval = NULL, ...)
gamlss.pvc(x, y, w, xeval = NULL, ...)
gamlss.pbm(x, y, w, xeval = NULL, ...)
gamlss.pbz(x, y, w, xeval = NULL, ...)
gamlss.pbc(x, y, w, xeval = NULL, ...)
gamlss.pbp(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.ps_+3A_x">x</code></td>
<td>
<p> the <code>x</code> for function <code>gamlss.fp</code> is referred to the design matrix of the specific parameter model (not to be used by the user)</p>
</td></tr>
<tr><td><code id="gamlss.ps_+3A_y">y</code></td>
<td>
<p>the <code>y</code> for function <code>gamlss.fp</code> is referred to the working variable of the specific parameter model (not to be used by the user)</p>
</td></tr>
<tr><td><code id="gamlss.ps_+3A_w">w</code></td>
<td>
<p> the <code>w</code> for function <code>gamlss.fp</code> is referred to the iterative weight variable of the specific parameter model (not to be used by the user) </p>
</td></tr>
<tr><td><code id="gamlss.ps_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction</p>
</td></tr>
<tr><td><code id="gamlss.ps_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>All function return fitted smoothers.  
</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby</p>


<h3>References</h3>

 
<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>, <b>11</b>, 89-121.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+pb">pb</a></code>,  <code><a href="#topic+ps">ps</a></code>, <code><a href="#topic+ri">ri</a></code>,<code><a href="survival.html#topic+ridge">ridge</a></code>,<code><a href="#topic+cy">cy</a></code>,<code><a href="#topic+pvc">pvc</a></code>,<code><a href="#topic+pbm">pbm</a></code> </p>

<hr>
<h2 id='gamlss.random'>Support for Functions random() and re()</h2><span id='topic+gamlss.random'></span><span id='topic+gamlss.re'></span>

<h3>Description</h3>

<p>This is support for the functions <code>random()</code> and <code>re()</code> respectively.
It is not intended to be called directly by users.
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.random(x, y, w, xeval = NULL, ...)
gamlss.re(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.random_+3A_x">x</code></td>
<td>
<p>the explanatory design matrix </p>
</td></tr>
<tr><td><code id="gamlss.random_+3A_y">y</code></td>
<td>
<p>the response variable </p>
</td></tr>
<tr><td><code id="gamlss.random_+3A_w">w</code></td>
<td>
<p>iterative weights </p>
</td></tr>
<tr><td><code id="gamlss.random_+3A_xeval">xeval</code></td>
<td>
<p>it used internaly for prediction</p>
</td></tr>
<tr><td><code id="gamlss.random_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>the fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance of the fitted values</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the final lambda, the smoothing parameter</p>
</td></tr>
<tr><td><code>coefSmo</code></td>
<td>
<p>with value NULL</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, based on Trevor Hastie function <code>gam.random</code></p>


<h3>References</h3>

<p> Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+random">random</a></code></p>

<hr>
<h2 id='gamlss.scope'>Generate a Scope Argument for Stepwise GAMLSS</h2><span id='topic+gamlss.scope'></span>

<h3>Description</h3>

<p>Generates a scope argument for a stepwise GAMLSS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.scope(frame, response = 1, smoother = "cs", arg = NULL, form = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss.scope_+3A_frame">frame</code></td>
<td>
<p>a data or model frame</p>
</td></tr>
<tr><td><code id="gamlss.scope_+3A_response">response</code></td>
<td>
<p> which variable is the response; the default is the first</p>
</td></tr>
<tr><td><code id="gamlss.scope_+3A_smoother">smoother</code></td>
<td>
<p>what smoother to use; default is <code>cs</code></p>
</td></tr>
<tr><td><code id="gamlss.scope_+3A_arg">arg</code></td>
<td>
<p>any additional arguments required by the smoother</p>
</td></tr>
<tr><td><code id="gamlss.scope_+3A_form">form</code></td>
<td>
<p>should a formula be returned (default), or else a character version of the formula </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each formula describes an ordered regimen of terms, each of which is eligible on their own for 
inclusion in the gam model. 
One of the terms is selected from each formula by step.gam. 
If a 1 is selected, that term is omitted. 
</p>


<h3>Value</h3>

<p>a list of formulas is returned, one for each column in frame (excluding the response). 
For a numeric variable, say x1, the formula is
</p>
<p>~ 1 + x1 + cs(x1)
</p>
<p>If x1 is a factor, the last smooth term is omitted.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos: a modified function from Statistical Models in S</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+stepGAIC">stepGAIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(usair)
gs1&lt;-gamlss.scope(model.frame(y~x1+x2+x3+x4+x5+x6, data=usair))
gs2&lt;-gamlss.scope(model.frame(usair))
gs1
gs2
gs3&lt;-gamlss.scope(model.frame(usair), smooth="fp", arg="3")
gs3 
</code></pre>

<hr>
<h2 id='gamlssML'>Maximum Likelihood estimation of a simple GAMLSS model </h2><span id='topic+gamlssML'></span><span id='topic+gamlssMLpred'></span>

<h3>Description</h3>

<p>The function <code>gamlssML()</code> fits  a <code>gamlss.family</code> distribution to single  data set  using a non linear maximisation algorithm in <code>R</code>.
This is relevant only when explanatory variables do not exist.
</p>
<p>The function <code>gamlssMLpred()</code> is similar to <code>gamlssML()</code> but it saves the <em>predictive</em> global deviance for the <code>newdata</code>.  The new data in <code>gamlssMLpred()</code> can be given with the arguments <code>newdata</code> or defining the factor  <code>rand</code>.  <code>rand</code> should be a binary factor <code>rand</code> splitting the original  data set into a training set (value 1)  and  a validation/test set (values 2), see
also <code><a href="#topic+gamlssVGD">gamlssVGD</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlssML(formula, family = NO, weights = NULL, mu.start = NULL, 
 sigma.start = NULL, nu.start = NULL, tau.start = NULL, 
 mu.fix = FALSE, sigma.fix = FALSE, nu.fix = FALSE, 
 tau.fix = FALSE, data, start.from = NULL, ...)

gamlssMLpred(response = NULL, data = NULL, family = NO, 
 rand = NULL, newdata = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlssML_+3A_formula">formula</code>, <code id="gamlssML_+3A_response">response</code></td>
<td>

<p>a vector of data requiring the fit of a <code>gamlss.family</code> distribution or (only for the function <code>gamlssML</code>) a formula,  for example, <code>y~1</code>, with no explanatory variables because they are ignored).  
</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_family">family</code></td>
<td>
 <p><code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code> object, which is used to define the distribution and the link functions of the various parameters. 
The distribution families supported by <code>gamlssML()</code> can be found in <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code></p>
</td></tr>
<tr><td><code id="gamlssML_+3A_weights">weights</code></td>
<td>
<p> a vector of weights. 
Here weights can be used to weight out observations (like in <code>subset</code>) or for a weighted likelihood analysis where  the contribution of the observations to the likelihood differs according to <code>weights</code>. The length of <code>weights</code> must be the same as the number of observations in the data. By default, the weight is set to one. To set  weights to vector say <code>w</code> use <code>weights=w</code>
</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_mu.start">mu.start</code></td>
<td>
<p> a scalar of initial values for the location parameter <code>mu</code> e.g.  <code>mu.start=4</code></p>
</td></tr>
<tr><td><code id="gamlssML_+3A_sigma.start">sigma.start</code></td>
<td>
<p>a scalar of initial values for the scale parameter <code>sigma</code> e.g. <code>sigma.start=1</code></p>
</td></tr>
<tr><td><code id="gamlssML_+3A_nu.start">nu.start</code></td>
<td>
<p>scalar of initial values for the parameter <code>nu</code> e.g. <code>nu.start=3</code> </p>
</td></tr>
<tr><td><code id="gamlssML_+3A_tau.start">tau.start</code></td>
<td>
<p>scalar of initial values for the parameter <code>tau</code> e.g. <code>tau.start=3</code> </p>
</td></tr>
<tr><td><code id="gamlssML_+3A_mu.fix">mu.fix</code></td>
<td>
<p>whether the mu parameter should be kept fixed in the fitting processes e.g. <code>mu.fix=FALSE</code> </p>
</td></tr>
<tr><td><code id="gamlssML_+3A_sigma.fix">sigma.fix</code></td>
<td>
<p>whether the sigma parameter should be kept fixed in the fitting processes e.g. <code>sigma.fix=FALSE</code></p>
</td></tr>
<tr><td><code id="gamlssML_+3A_nu.fix">nu.fix</code></td>
<td>
<p>whether the nu parameter should be kept fixed in the fitting processes e.g. <code>nu.fix=FALSE</code> </p>
</td></tr>
<tr><td><code id="gamlssML_+3A_tau.fix">tau.fix</code></td>
<td>
<p>whether the tau parameter should be kept fixed in the fitting processes e.g. <code>tau.fix=FALSE</code></p>
</td></tr>
<tr><td><code id="gamlssML_+3A_data">data</code></td>
<td>
<p>a data frame containing the variable <code>y</code>, e.g. <code>data=aids</code>. If this is missing, the variable should be on the search list.</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_start.from">start.from</code></td>
<td>
<p>a gamlss object to start from the fitting or vector of length as many parameters in the distribution</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_rand">rand</code></td>
<td>
<p>For <code>gamlssMLpred()</code> a factor with values 1 (for fitting) and 2 (for predicting).</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_newdata">newdata</code></td>
<td>
<p>The prediction data  set (validation or test).</p>
</td></tr>
<tr><td><code id="gamlssML_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The  function <code>gamlssML()</code> fits a <code>gamlss.family</code> distribution to a single data set is using a non linear maximisation.
in fact it uses the internal function <code>MLE()</code> which is a copy of the <code>mle()</code> function of package <code>stat4</code>.
The function <code>gamlssML()</code> could be for large data faster than the equivalent <code>gamlss()</code> function which is designed for regression type of models. 
</p>
<p>The  function <code>gamlssMLpred()</code> uses the  function  <code>gamlssML()</code>   to fit the model but then uses <code>predict.gamlssML()</code> to predict for new data and saves the the prediction i) deviance increments, ii) global deviance iii) residuals.   
</p>


<h3>Value</h3>

<p>Returns a <code>gamlssML</code> object which behaves like a <code>gamlss</code> fitted objected</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby, Vlasis Voudouris and Majid Djennad 
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>, <code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------- negative binomial 1000 observations
y&lt;- rNBI(1000)
  system.time(m1&lt;-gamlss(y~1, family=NBI))
  system.time(m1a&lt;-gamlss(y~1, family=NBI, trace=FALSE))
system.time(m11&lt;-gamlssML(y, family=NBI))
AIC(m1,m1a,m11, k=0)
# neg. binomial   n=10000
 y&lt;- rNBI(10000)
 system.time(m1&lt;-gamlss(y~1, family=NBI))
 system.time(m1a&lt;-gamlss(y~1, family=NBI, trace=FALSE))
system.time(m11&lt;-gamlssML(y, family=NBI))
AIC(m1,m1a,m11, k=0)
# binomial type data 
data(aep)
m1 &lt;- gamlssML(aep$y, family=BB) # ok
m2 &lt;- gamlssML(y, data=aep, family=BB) # ok
m3 &lt;- gamlssML(y~1, data=aep, family=BB) # ok 
m4 &lt;- gamlssML(aep$y~1, family=BB) # ok
AIC(m1,m2,m3,m4)
## Not run: 
#-----------------------------------------------------------
# neg. binomial   n=10000
y&lt;- rNBI(10000)
rand &lt;- sample(2, length(y), replace=TRUE, prob=c(0.6,0.4))
table(rand)
   Y &lt;- subset(y, rand==1)
YVal &lt;- subset(y, rand==2) 
length(Y)
length(YVal) 
da1 &lt;- data.frame(y=y)
dim(da1)
da2 &lt;- data.frame(y=Y)
dim(da2)
danew &lt;- data.frame(y=YVal)
# using gamlssVGD to fit the models
g1 &lt;- gamlssVGD(y~1, rand=rand, family=NBI, data=da1)
g2 &lt;- gamlssVGD(y~1, family=NBI, data=da2, newdata=dan)
AIC(g1,g2)
VGD(g1,g2)
# using gamlssMLpred to fit the models
p1 &lt;- gamlssMLpred(y, rand=rand, family=NBI)
p2 &lt;- gamlssMLpred(Y, family=NBI, newdata=YVal)
# AIC and VGD should produce identical results
AIC(p1,p2,g1,g2)
VGD(p1,p2, g1,g2)
# the fitted residuals
wp(p1, ylim.all=1)
# the prediction residuals 
wp(resid=p1$residVal, ylim.all=.5)
#-------------------------------------------------------------
# chossing between distributions
p2&lt;-gamlssMLpred(y, rand=rand, family=PO)
p3&lt;-gamlssMLpred(y, rand=rand, family=PIG)
p4&lt;-gamlssMLpred(y, rand=rand, family=BNB)
AIC(p1, p2, p3, p4)
VGD(p1, p2, p3, p4)
#--------------------------------------------------

## End(Not run)
 </code></pre>

<hr>
<h2 id='gamlssVGD'>A  Set of Functions for selecting Models using Validation or Test Data Sets and Cross Validation 
</h2><span id='topic+gamlssVGD'></span><span id='topic+VGD'></span><span id='topic+getTGD'></span><span id='topic+TGD'></span><span id='topic+gamlssCV'></span><span id='topic+CV'></span><span id='topic+drop1TGD'></span><span id='topic+add1TGD'></span><span id='topic+stepTGD'></span><span id='topic+stepTGDAll.A'></span>

<h3>Description</h3>

<p>This is a set of function useful for selecting appropriate models. 
</p>
<p>The functions <code>gamlssVGD</code>, <code>VGD</code>, <code>getTGD</code>, <code>TGD</code> can be used when a subset of the data is used for validation or testing. 
</p>
<p>The function <code>stepVGD()</code> is a stepwise procedure for selecting an appropriate model for any of the parameters of the model minimising the test global deviance. The function   <code>stepVGDAll.A()</code> can select a model using strategy A for all the parameters. 
</p>
<p>The functions <code>gamlssCV</code>, <code>CV</code> can be used for a k-fold cross validation.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlssVGD(formula = NULL, sigma.formula = ~1, nu.formula = ~1, 
          tau.formula = ~1, data = NULL, family = NO, 
          control = gamlss.control(trace = FALSE), 
          rand = NULL, newdata = NULL, ...)
          
VGD(object, ...)          

getTGD(object, newdata = NULL, ...)

TGD(object, ...)  

gamlssCV(formula = NULL, sigma.formula = ~1, nu.formula = ~1, 
         tau.formula = ~1, data = NULL, family = NO, 
         control = gamlss.control(trace = FALSE), 
         K.fold = 10, set.seed = 123, rand = NULL, 
         parallel = c("no", "multicore", "snow"), 
         ncpus = 1L, cl = NULL, ...)

CV(object, ...)

drop1TGD(object, scope, newdata, parameter = c("mu", "sigma", "nu", "tau"), 
         sorted = FALSE, trace = FALSE, 
         parallel = c("no", "multicore", "snow"), 
         ncpus = 1L, cl = NULL, ...)
         
add1TGD(object, scope, newdata, parameter = c("mu", "sigma", "nu", "tau"), 
        sorted = FALSE, trace = FALSE, 
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)

stepTGD(object, scope, newdata, 
        direction = c("both", "backward", "forward"),
        trace = TRUE, keep = NULL, steps = 1000, 
        parameter = c("mu", "sigma", "nu", "tau"), 
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)
        
stepTGDAll.A(object, scope = NULL, newdata = NULL, 
        steps = 1000, sigma.scope = NULL, nu.scope = NULL, 
        tau.scope = NULL, mu.try = TRUE, sigma.try = TRUE, 
        nu.try = TRUE, tau.try = TRUE,
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)        

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlssVGD_+3A_formula">formula</code></td>
<td>
<p>A <code>gamlss</code> <code>mu</code> formula.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_sigma.formula">sigma.formula</code></td>
<td>
<p>Formula for <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_nu.formula">nu.formula</code></td>
<td>
<p>Formula for <code>nu</code>.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_tau.formula">tau.formula</code></td>
<td>
<p>Formula for <code>tau</code>.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_data">data</code></td>
<td>
<p>The data frame required for the fit.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_family">family</code></td>
<td>
<p>The <code>gamlss.family</code> distribution.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_control">control</code></td>
<td>
<p>The control for fitting the gamlss model.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_rand">rand</code></td>
<td>
<p>For <code>gamlssVGD</code> a variable with values 1 (for fitting) and 2 (for predicting). For <code>gamlssCV</code> a variable with k values indicating the cross validation sets.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_newdata">newdata</code></td>
<td>
<p>The new data set (validation or test) for prediction.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_object">object</code></td>
<td>
<p>A relevant R object.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_scope">scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection similar to <code>stepGAIC()</code> where you can see examples</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_sigma.scope">sigma.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>sigma</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_nu.scope">nu.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>nu</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_tau.scope">tau.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>tau</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_mu.try">mu.try</code></td>
<td>
<p>whether should try fitting models for <code>mu</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_sigma.try">sigma.try</code></td>
<td>
<p>whether should try fitting models for <code>sigma</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_nu.try">nu.try</code></td>
<td>
<p>whether should try fitting models for <code>nu</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_tau.try">tau.try</code></td>
<td>
<p>whether should try fitting models for <code>tau</code></p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_parameter">parameter</code></td>
<td>
<p>which distribution parameter is required, default <code>what="mu"</code></p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_sorted">sorted</code></td>
<td>
<p>should the results be sorted on the value of TGD</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_trace">trace</code></td>
<td>
<p>f <code>TRUE</code> additional information may be given on the fits as they are tried.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_direction">direction</code></td>
<td>
<p>The mode of stepwise search, can be one of <code>both</code>, <code>backward</code>, or <code>forward</code>, with a default of <code>both</code>. If the scope argument is missing the default for direction is backward</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_keep">keep</code></td>
<td>
<p>see <code>stepGAIC()</code> for explanation</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_steps">steps</code></td>
<td>
<p>the maximum number of steps to be considered. The default is 1000.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_k.fold">K.fold</code></td>
<td>
<p>the number of subsets of the data used</p>
</td></tr> 
<tr><td><code id="gamlssVGD_+3A_set.seed">set.seed</code></td>
<td>
<p>the seed to be used in creating <code>rand</code></p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically one would chose this to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel = "snow"</code>. If not supplied, a cluster on the local machine is created for the duration of the call.
</p>
</td></tr>
<tr><td><code id="gamlssVGD_+3A_...">...</code></td>
<td>
<p>further arguments to be pass in the gamlss fit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gamlssVGD()</code> fits a gamlss model to the training data set determined by the arguments <code>rand</code> or <code>newdata</code>. The results is a <code>gamlssVGD</code> objects which contains the gamlss fit to the training data plus three extra components: i) <code>VGD</code> the global deviance applied to the validation data sets. ii) <code>predictError</code> which is <code>VGD</code>
divided with the number of observations in the validation data set and iii) <code>residVal</code> the residuals for the  validation data set. 
</p>
<p>The function <code>VGD()</code> extract the validated global deviance from one or more fitted  <code>gamlssVGD</code> objects and can be used foe model comparison. 
</p>
<p>The function <code>getTGD()</code> operates different from the function <code>gamlssVGD()</code>. It assumes that the users already have fitted models using <code>gamlss()</code> and now he/she wants to evaluate the global deviance at a new (validation or test) data set. 
</p>
<p>The function <code>TGD()</code>  extract the validated/test global deviance  from one or more fitted  <code>gamlssTGD</code> objects and can be use to compare models.
</p>
<p>The <code>gamlssCV()</code> performs a k-fold cross validation on a gamlss models. 
</p>
<p>The function <code>CV()</code> extract the cross validated  global deviance from one or more fitted  <code>gamlssCV</code> objects and can be use to compare models.
</p>
<p>The functions <code>add1TGD()</code>, <code>drop1TGD()</code> and <code>stepTGD</code> behave similar to  <code>add1()</code>, <code>drop1()</code> and <code>stepGAIC()</code> functions respectively  but they used  validation or test deviance as the selection criterion rather than the GAIC.
</p>


<h3>Value</h3>

<p>A fitted models of a set of global deviances.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S</em>. Fourth edition.  Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepGAIC">stepGAIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
# generate the random split of the data
rand &lt;- sample(2, 610, replace=TRUE, prob=c(0.6,0.4))
# the proportions in the sample
table(rand)/610
olddata&lt;-abdom[rand==1,] # training data
newdata&lt;-abdom[rand==2,] # validation data
#------------------------------------------------------------------------------
#  gamlssVGD
#-------------------------------------------------------------------------------
# Using rand
v1 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=NO, 
              rand=rand)
v2 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=LO, 
              rand=rand)
v3 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=TF, 
              rand=rand)
VGD(v1,v2,v3)
#-------------------------------------------------------------------------------
## Not run: 
#-------------------------------------------------------------------------------
# using two data set
v11 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                  family=NO, newdata=newdata)
v12 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                 family=LO, newdata=newdata)
v13 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                 family=TF, newdata=newdata)
VGD(v11,v12,v13)
#-------------------------------------------------------------------------------
# function getTGD
#-------------------------------------------------------------------------------
# fit gamlss models first
g1 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=NO)
g2 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=LO)
g3 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=TF)
# and then use 
gg1 &lt;-getTGD(g1, newdata=newdata)
gg2 &lt;-getTGD(g2, newdata=newdata)
gg3 &lt;-getTGD(g3, newdata=newdata)

TGD(gg1,gg2,gg3)
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# function gamlssCV
#-------------------------------------------------------------------------------
set.seed(123)
rand1 &lt;- sample (10 , 610, replace=TRUE)
g1 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=NO, 
               rand=rand1)
g2 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=LO, 
               rand=rand1)
g3 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=TF, 
               rand=rand1)
CV(g1,g2,g3)
CV(g1)
# using parallel 
set.seed(123)
rand1 &lt;- sample (10 , 610, replace=TRUE)
nC &lt;- detectCores()

system.time(g21 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=NO, rand=rand1,parallel = "no", ncpus = nC ))

system.time(g22 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=LO, rand=rand1,parallel = "multicore", ncpus = nC ))

system.time(g23 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=TF, rand=rand1,parallel = "snow", ncpus = nC ))


CV(g21,g22,g23)
#-------------------------------------------------------------------------------
# functions add1TGD() drop1TGD() and stepTGD()
#-------------------------------------------------------------------------------
# the data
data(rent)
rand &lt;- sample(2, dim(rent)[1], replace=TRUE, prob=c(0.6,0.4))
# the proportions in the sample
table(rand)/dim(rent)[1]
oldrent&lt;-rent[rand==1,] # training set
newrent&lt;-rent[rand==2,] # validation set

# null model
v0 &lt;- gamlss(R~1, data=oldrent, family=GA)
# complete model
v1 &lt;- gamlss(R~pb(Fl)+pb(A)+H+loc, sigma.fo=~pb(Fl)+pb(A)+H+loc, 
             data=oldrent, family=GA)

# drop1TGDP
system.time(v3&lt;- drop1TGD(v1, newdata=newrent,  parallel="no"))
system.time(v4&lt;- drop1TGD(v1, newdata=newrent,  parallel="multicore", 
                          ncpus=nC) )
system.time(v5&lt;- drop1TGD(v1, newdata=newrent,  parallel="snow", ncpus=nC))
cbind(v3,v4,v5)

# add1TGDP
system.time(d3&lt;- add1TGD(v0,scope=~pb(Fl)+pb(A)+H+loc, newdata=newrent,  
                       parallel="no"))
system.time(d4&lt;- add1TGD(v0,scope=~pb(Fl)+pb(A)+H+loc, newdata=newrent,  
                        parallel="multicore", ncpus=nC) )
system.time(d5&lt;- add1TGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,  
                        parallel="snow", ncpus=nC))

# stepTGD
system.time(d6&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent))
system.time(d7&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,
                         parallel="multicore", ncpus=nC))
system.time(d8&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,
                         parallel="snow", ncpus=nC))

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.likelihood'>
A function to generate the likelihood function from a GAMLSS object
</h2><span id='topic+gen.likelihood'></span>

<h3>Description</h3>

<p>This function generate a function with argument the parameters of the GAMLSS model which can evaluate the log-likelihood function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.likelihood(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.likelihood_+3A_object">object</code></td>
<td>
<p>A gamlss fitted model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to help the function vcov() to get he right Hessian matrix after a model has fitted. Note that at the momment smoothing terms are consideted as fixed. 
</p>


<h3>Value</h3>

<p>A function of the log-likelihood
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Vlasios Voudouris</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
m1 &lt;- gamlss(y~x+qrt, data=aids, family=NBI)
logL&lt;-gen.likelihood(m1)
logL()
logLik(m1)
</code></pre>

<hr>
<h2 id='getPEF'>Getting the partial effect function from a continuous term in a GAMLSS model</h2><span id='topic+getPEF'></span>

<h3>Description</h3>

<p>This function can be used to calculate the partial effect and the elasticity of a continuous explanatory variable <code>x</code>.
</p>
<p>By &lsquo;partial effect&rsquo; function we mean how <code>x</code> is influence the parameter of interest given that the rest of explanatory terms for this parameter are on (specified) fixed values.  
</p>
<p>The function takes a GAMLSS object and for the range of the continuous variable <code>x</code>, 
(by fixing the rest of the explanatory terms at specified values), 
calculates the effect that <code>x</code> has on the specific distribution parameter (or its predictor).
The resulting function shows the effect that <code>x</code> has on the distribution parameter. 
The partial effect function which is calculated on a finite grit is then approximated using the <code>splinefun()</code> in R and its is saved.
</p>
<p>The saved function can be used to calculate the elasticity of <code>x</code>. The elasticity is the first derivative of the partial effect function  and shows the chance of the parameter of interest for a small change in in <code>x</code>, by fixing the rest of the explanatory variables at specified values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPEF(obj = NULL, term = NULL, data = NULL, n.points = 100, 
          parameter = c("mu", "sigma", "nu", "tau"), 
          type = c("response", "link"), how = c("median", "last"), 
          fixed.at = list(), plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPEF_+3A_obj">obj</code></td>
<td>
<p>A <code>gamlss</code> object</p>
</td></tr>
<tr><td><code id="getPEF_+3A_term">term</code></td>
<td>
<p>the continuous explanatory variable</p>
</td></tr>
<tr><td><code id="getPEF_+3A_data">data</code></td>
<td>
<p>the data.frame (not needed if is declared on <code>obj</code>)</p>
</td></tr>
<tr><td><code id="getPEF_+3A_n.points">n.points</code></td>
<td>
<p>the number of points in which the influence function for <code>x</code> need to be evaluated</p>
</td></tr>
<tr><td><code id="getPEF_+3A_parameter">parameter</code></td>
<td>
<p>which distribution parameter</p>
</td></tr>
<tr><td><code id="getPEF_+3A_type">type</code></td>
<td>
<p>whether against the parameter, <code>"response"</code>, or the predictor <code>"link"</code></p>
</td></tr>
<tr><td><code id="getPEF_+3A_how">how</code></td>
<td>
<p>whether for continuous variables should use the median  or the last observation in the data</p>
</td></tr>
<tr><td><code id="getPEF_+3A_fixed.at">fixed.at</code></td>
<td>
<p>a list indicating  at which values the rest of the explanatory terms should be fixed</p>
</td></tr>
<tr><td><code id="getPEF_+3A_plot">plot</code></td>
<td>
<p>whether to the plot the influence function and its first derivatives</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function is created which can be used to evaluate the partial effect function at different values of <code>x</code>.  </p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Vlasios Voudouris, Daniil Kiose</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. and Stasinopoulos, D. M (2013) Automatic smoothing parameter selection in GAMLSS with an application to centile estimation, <em>Statistical methods in medical research</em>.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- gamlss(R~pb(Fl)+pb(A), data=rent, family=GA)
# getting the Partial Efect function
pef &lt;- getPEF(obj=m1,term="A", plot=TRUE)
# the value at 1980
pef(1980)
# the first derivative at 1980
pef(1980, deriv=1)
# the second derivative at 1980
pef(1980, deriv=2)
# plotting the first derivative
curve(pef(x, deriv=1), 1900,2000)
</code></pre>

<hr>
<h2 id='getQuantile'>Getting the partial quantile function for a term</h2><span id='topic+getQuantile'></span>

<h3>Description</h3>

<p>This function can be used to calculate the partial effect that an explanatory variable has on a specific quantile.
</p>
<p>By &lsquo;partial effect&rsquo; function we mean how the term influence the quantile given that the rest of explanatory terms are constant.  
</p>
<p>The function takes a GAMLSS object and for the range of a specified explanatory
(by fixing the rest of the terms at specified values), 
calculates the effect that this term has on the a quantile of the distribution.
That is, it shows the effect that the particular term  has on the quantile. 
The &lsquo;partial&rsquo; quantile is calculated on a finite grid of values and then the function is approximated (using the <code>splinefun()</code>)  and  saved.
</p>
<p>The saved function can be used to calculate the first derivative. This first derivatives   shows the chance of the quantile function  for a small change in the explanatory variable, by fixing the rest of the explanatory variables at a constant values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantile(obj = NULL, term = NULL, quantile = 0.9, data = NULL,
    n.points = 100, how = c("median", "last"), 
    fixed.at = list(), plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQuantile_+3A_obj">obj</code></td>
<td>
<p>A <code>gamlss</code> object</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_term">term</code></td>
<td>

<p>an explanatory variable (at the moment works with with continuous)
</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_quantile">quantile</code></td>
<td>
<p>the required quantile of the distribution</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_data">data</code></td>
<td>
<p>the data.frame (not needed if is declared on <code>obj</code>)</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_n.points">n.points</code></td>
<td>
<p>the number of points in which the quantile function needs evaluation</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_how">how</code></td>
<td>
<p>whether for extra continuous explanatory variables should fixed at the median or the last observation in the data</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_fixed.at">fixed.at</code></td>
<td>
<p>a list indicating at which values the rest of the explanatory terms should be fixed</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_plot">plot</code></td>
<td>
<p>whether to the plot the partial quantile function and its first derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>getQuantile()</code> relies on the <code>predictAll()</code> function to evaluate the distribution parameters at a grid (default 100 points) of the specified term (given that the  the rest of the terms are fixed). Then the inverse cdf is used to calculate the partial quantile. The function then is approximated using   <code>splinefun()</code>)  and saved. 
</p>


<h3>Value</h3>

<p>A function is created which can be used to evaluate the partial effect of the explanatory variable  on a specified quantile. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+getPEF">getPEF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gamlss)
data(rent)
m1 &lt;- gamlss(R~pb(Fl)+pb(A)+B+loc, data=rent, family=GA)
FF&lt;-getQuantile(m1, quantile=0.9, term="A", plot=TRUE)
FF(1960)
FF(1060, deriv=1)
FF(1060, deriv=2)
## Not run: 
# plotting partial quantile
# .05, 0.25, 0.5, 0.75, 0.95
# at the default values
# Fl = median(Fl), B=0, and loc=2
plot(R~A, data=rent,  col="lightgray", pch=20)
for (i in c(.05, 0.25, 0.5, 0.75, 0.95))
{
  Qua &lt;- getQuantile(m1, quantile=i,term="A")
  curve(Qua, 1900, 1985,  lwd=1, lty=1, add=T)
}
# plotting at values Fl=60, B=1, and loc=1.
for (i in c(.05, 0.25, 0.5, 0.75, 0.95))
{
  Qua &lt;- getQuantile(m1, quantile=i,term="A", 
            fixed.at=list(Fl=60, B=1, loc=1))
  curve(Qua, 1900, 1985,  lwd=1, lty=2, col="red", add=T)
}
# plotting at Fl=60, B=1 and loc=1.
for (i in c(.05, 0.25, 0.5, 0.75, 0.95))
{
  Qua &lt;- getQuantile(m1, quantile=i,term="A", 
           fixed.at=list(Fl=120, B=0, loc=3))
  curve(Qua, 1900, 1985,  lwd=1, lty=3, col="blue", add=T)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='getSmo'>
Extracting Smoother information from a GAMLSS fitted object
</h2><span id='topic+getSmo'></span>

<h3>Description</h3>

<p>The function <code>getSmo()</code> extracts information from a fitted smoothing additive term.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSmo(object, what = c("mu", "sigma", "nu", "tau"), 
       parameter= NULL, which = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSmo_+3A_object">object</code></td>
<td>

<p>a GAMLSS fitted model
</p>
</td></tr>
<tr><td><code id="getSmo_+3A_what">what</code></td>
<td>

<p>which distribution parameter is required, default what=&quot;mu&quot;
</p>
</td></tr>
<tr><td><code id="getSmo_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="getSmo_+3A_which">which</code></td>
<td>

<p>which smoothing term i.e. 1, 2 etc. Note that 0 means all.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitates the extraction of information from a fitted additive terms. For example <code>getSmo(m1,"sigma",2)</code> is equivalent of <code>m1$sigma.coefSmo[[2]]</code>. To get the actual fitted values type <code>m1$sigma.s[[2]]</code>
</p>


<h3>Value</h3>

<p>A list containing information about a fitted smoother or a fitted objects 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(usair)
t1&lt;-gamlss(y~x1+pb(x5)+pb(x6), data=usair, family=GA)
# get the value for lambda for the second fitted term in mu
getSmo(t1, parameter="mu", 2)$lambda
  </code></pre>

<hr>
<h2 id='glim.control'> Auxiliary for Controlling the inner algorithm in a GAMLSS Fitting </h2><span id='topic+glim.control'></span>

<h3>Description</h3>

<p>Auxiliary function used for the inner iteration of <code>gamlss</code> algorithm. Typically
only used when calling <code>gamlss</code> function through the option <code>i.control</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glim.control(cc = 0.001, cyc = 50,  glm.trace = FALSE, 
             bf.cyc = 30, bf.tol = 0.001, bf.trace = FALSE, 
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glim.control_+3A_cc">cc</code></td>
<td>
<p>the convergence criterion for the algorithm</p>
</td></tr>
<tr><td><code id="glim.control_+3A_cyc">cyc</code></td>
<td>
<p>the number of cycles of the algorithm</p>
</td></tr>
<tr><td><code id="glim.control_+3A_glm.trace">glm.trace</code></td>
<td>
<p>whether to print at each iteration (TRUE) or not (FALSE) </p>
</td></tr>
<tr><td><code id="glim.control_+3A_bf.cyc">bf.cyc</code></td>
<td>
<p>the number of cycles of the backfitting algorithm</p>
</td></tr>
<tr><td><code id="glim.control_+3A_bf.tol">bf.tol</code></td>
<td>
<p>the convergence criterion (tolerance level) for the backfitting algorithm </p>
</td></tr>
<tr><td><code id="glim.control_+3A_bf.trace">bf.trace</code></td>
<td>
<p>whether to print at each iteration (TRUE) or not (FALSE, the default)</p>
</td></tr>
<tr><td><code id="glim.control_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the arguments as components</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby</p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
con&lt;-glim.control(glm.trace=TRUE)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids, i.control=con) # 
rm(h,con)

</code></pre>

<hr>
<h2 id='histDist'>This function plots the histogram and a fitted (GAMLSS family) distribution to a variable</h2><span id='topic+histDist'></span>

<h3>Description</h3>

<p>This function fits constants to the parameters of a GAMLSS family distribution and them plot the histogram and 
the fitted distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histDist(y, family = NO, freq = NULL, density = FALSE, 
        nbins = 10, xlim = NULL, ylim = NULL, main = NULL, 
        xlab = NULL, ylab = NULL, data = NULL, 
        col.hist = "gray", border.hist = "blue", 
        fg.hist = rainbow(12)[9], line.wd = 2, 
        line.ty = c(1, 2), line.col = c(2, 3), 
        col.main = "blue4", col.lab = "blue4", 
        col.axis = "blue", ...)
        </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histDist_+3A_y">y</code></td>
<td>
<p>a vector for the response variable</p>
</td></tr>
<tr><td><code id="histDist_+3A_family">family</code></td>
<td>
<p>a <code>gamlss.family</code> distribution</p>
</td></tr>
<tr><td><code id="histDist_+3A_freq">freq</code></td>
<td>
<p>the frequencies of the data in <code>y</code> if exist. <code>freq</code> is used as <code>weights</code> in the <code>gamlss</code> fit</p>
</td></tr>
<tr><td><code id="histDist_+3A_density">density</code></td>
<td>
<p>default value is FALSE. Change to TRUE if you would like a non-parametric density plot together with the parametric 
fitted distribution plot (for continuous variable only)</p>
</td></tr>
<tr><td><code id="histDist_+3A_nbins">nbins</code></td>
<td>
<p>The suggested number of bins (argument passed to <code>truehist()</code> of package MASS).  Either a positive integer, or a character string naming a rule: &quot;Scott&quot; or &quot;Freedman-Diaconis&quot; or &quot;FD&quot;. (Case is ignored.) </p>
</td></tr>
<tr><td><code id="histDist_+3A_xlim">xlim</code></td>
<td>
<p>the minimum and the maximum x-axis value (if the default values are out of range)</p>
</td></tr>
<tr><td><code id="histDist_+3A_ylim">ylim</code></td>
<td>
<p>the minimum and the maximum y-axis value (if the default values are out of range)</p>
</td></tr>
<tr><td><code id="histDist_+3A_main">main</code></td>
<td>
<p>the main title for the plot</p>
</td></tr>
<tr><td><code id="histDist_+3A_xlab">xlab</code></td>
<td>
<p>the label in the x-axis</p>
</td></tr>
<tr><td><code id="histDist_+3A_ylab">ylab</code></td>
<td>
<p>the label in the y-axis</p>
</td></tr>
<tr><td><code id="histDist_+3A_data">data</code></td>
<td>
<p>the data.frame</p>
</td></tr>
<tr><td><code id="histDist_+3A_col.hist">col.hist</code></td>
<td>
<p>the colour of the histogram or barplot</p>
</td></tr>
<tr><td><code id="histDist_+3A_border.hist">border.hist</code></td>
<td>
<p>the colour of the border of the histogram or barplot</p>
</td></tr>
<tr><td><code id="histDist_+3A_fg.hist">fg.hist</code></td>
<td>
<p>the colour of  axis in the histogram or barplot</p>
</td></tr>
<tr><td><code id="histDist_+3A_line.wd">line.wd</code></td>
<td>
<p>the line width of the fitted distribution</p>
</td></tr>
<tr><td><code id="histDist_+3A_line.ty">line.ty</code></td>
<td>
<p>the line type of the fitted distribution</p>
</td></tr>
<tr><td><code id="histDist_+3A_line.col">line.col</code></td>
<td>
<p>the line color of the fitted distribution</p>
</td></tr>
<tr><td><code id="histDist_+3A_col.main">col.main</code></td>
<td>
<p>the colour for the main title</p>
</td></tr>
<tr><td><code id="histDist_+3A_col.lab">col.lab</code></td>
<td>
<p>the colour of the labels</p>
</td></tr>
<tr><td><code id="histDist_+3A_col.axis">col.axis</code></td>
<td>
<p>the color of the axis</p>
</td></tr>
<tr><td><code id="histDist_+3A_...">...</code></td>
<td>
<p>for extra arguments to be passed to the <code>gamlss</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first fits constants for each parameters of a GAMLSS distribution family using the <code>gamlss</code> function  
and them plots the fitted distribution together with the appropriate plot according to whether 
the <code>y</code> variable is of a continuous or discrete type. Histogram is plotted for continuous and barplot for discrete variables. 
The function <code>truehist()</code> of 
Venables and Ripley's MASS package is used for the histogram plotting.  
</p>


<h3>Value</h3>

<p>returns a plot
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
histDist(y,family="NO", data=abdom)
# use the ylim 
histDist(y,family="NO", ylim=c(0,0.005), data=abdom)
# bad fit use PE
histDist(y,family="PE",ymax=0.005, data=abdom, line.col="blue")
# discere data counts 
#  Hand at al. p150  Leptinotarsa decemlineata
y &lt;- c(0,1,2,3,4,6,7,8,10,11)
freq &lt;- c(33,12,5,6,5,2,2,2,1,2) 
histDist(y, "NBI", freq=freq)
# the same as 
histDist(rep(y,freq), "NBI")
</code></pre>

<hr>
<h2 id='histSmo'>
Density estimation using the Poisson trick
</h2><span id='topic+histSmo'></span><span id='topic+histSmoC'></span><span id='topic+histSmoO'></span><span id='topic+histSmoP'></span>

<h3>Description</h3>

<p>This set of functions use the old Poisson trick of discretising the data and then fitting a Poisson error model to the resulting frequencies (Lindsey, 1997). Here the model fitted is a smooth cubic spline curve. The result is a density estimator for the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histSmo(y, lambda = NULL, df = NULL, order = 3, lower = NULL,  
       upper = NULL, type = c("freq", "prob"), 
       plot = FALSE, breaks = NULL,  
       discrete = FALSE, ...)
histSmoC(y, df = 10, lower = NULL, upper = NULL, type = c("freq", "prob"), 
       plot = FALSE, breaks = NULL,  
       discrete = FALSE, ...)
histSmoO(y, lambda = 1, order = 3, lower = NULL, upper = NULL, 
      type = c("freq", "prob"), 
      plot = FALSE, breaks = NULL,  
      discrete = FALSE, ...)
histSmoP(y, lambda = NULL, df = NULL, order = 3, lower = NULL, 
      upper = NULL, type = c("freq", "prob"), 
      plot = FALSE, breaks = NULL,  discrete = FALSE, 
      ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histSmo_+3A_y">y</code></td>
<td>
<p>the variable of interest</p>
</td></tr>
<tr><td><code id="histSmo_+3A_lambda">lambda</code></td>
<td>
<p>the smoothing parameter</p>
</td></tr>
<tr><td><code id="histSmo_+3A_df">df</code></td>
<td>
<p>the degrees of freedom</p>
</td></tr>
<tr><td><code id="histSmo_+3A_order">order</code></td>
<td>
<p>the order of the P-spline</p>
</td></tr>
<tr><td><code id="histSmo_+3A_lower">lower</code></td>
<td>
<p>the lower limit of the y-variable</p>
</td></tr>
<tr><td><code id="histSmo_+3A_upper">upper</code></td>
<td>
<p>the upper limit of the y-variable</p>
</td></tr>
<tr><td><code id="histSmo_+3A_type">type</code></td>
<td>
<p>the type of histogram</p>
</td></tr>
<tr><td><code id="histSmo_+3A_plot">plot</code></td>
<td>
<p>whether to plot the resulting density estimator</p>
</td></tr>
<tr><td><code id="histSmo_+3A_breaks">breaks</code></td>
<td>
<p>the number of break points to be used in the histogram and consequently the number of observations in the Poisson fit</p>
</td></tr> 
<tr><td><code id="histSmo_+3A_discrete">discrete</code></td>
<td>
<p>whether to treat the fitting density as a discrete distribution or not</p>
</td></tr>
<tr><td><code id="histSmo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Here are the methods used here:
</p>
<p>i) The function <code>histSmoO()</code> uses Penalised discrete splines (Eilers,  2003). This function is appropriate when the smoothing parameter is fixed. 
</p>
<p>ii) The function <code>histSmoC()</code> uses smooth cubic splines and fits a Poison error model to the frequencies using the <code>cs()</code> additive function of GAMLSS. This function is appropriate if the effective degrees of freedom are fixed in the model.
</p>
<p>iii) The function <code>histSmoP()</code> uses Penalised cubic splines (Eilers and Marx 1996). It is fitting a Poisson model to the frequencies using the <code>pb()</code> additive function of GAMLSS. This function is appropriate if automatic selection of the smoothing parameter is required.
</p>
<p>iv) The function <code>histSmo()</code> combines all the above functions in the sense that if lambda is fixed it uses  <code>histSmoO()</code>, if the degrees  of freedom are fixed it uses <code>histSmoC()</code> and if none of these is specified it uses <code>histSmoP()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>histSmo</code> S3 object. The object has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the middle points of the discretise data</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>how many observation are on the discretise intervals</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>the density value for each discrete interval</p>
</td></tr>
<tr><td><code>hist</code></td>
<td>
<p>the <code>hist</code> object used to discretise the data</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>The resulting cumulative distribution function useful for calculating probabilities from the estimate density</p>
</td></tr>
<tr><td><code>nvcdf</code></td>
<td>
<p>The inverse cumulative distribution function</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted Poisson model only for <code>histSmoP()</code> and <code>histSmoC()</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Paul Eilers, Bob Rigby and Vlasios Voudouris
</p>


<h3>References</h3>

<p>Eilers, P. (2003). A perfect smoother. <em>Analytical Chemistry</em>, 75: 3631-3636.
</p>
<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>, <b>11</b>, 89-121.
</p>
<p>Lindsey, J.K. (1997) <em>Applying Generalized Linear Models</em>. New York: Springer-Verlag. 
ISBN 0-387-98218-3 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pb">pb</a></code>, <code><a href="#topic+cs">cs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating data from Pareto 2 distribution
set.seed(153)
Y &lt;- rPARETO2(1000) 
## Not run: 
# getting the density 
histSmo(Y, lower=0, plot=TRUE)
# more  breaks a bit slower
histSmo(Y, breaks=200, lower=0, plot=TRUE)
# quick fit using lambda
histSmoO(Y, lambda=1, breaks=200, lower=0, plot=TRUE)
# or 
histSmo(Y, lambda=1, breaks=200, lower=0, plot=TRUE)
# quick fit using df
histSmoC(Y, df=15, breaks=200, lower=0,plot=TRUE)
# or 
histSmo(Y, df=15, breaks=200, lower=0)
# saving results
m1&lt;- histSmo(Y, lower=0, plot=T)
plot(m1)
plot(m1, "cdf")
plot(m1, "invcdf")
# using with a histogram
library(MASS)
truehist(Y)
lines(m1, col="red")
#---------------------------
# now gererate from SHASH distribution
YY &lt;- rSHASH(1000)
m1&lt;- histSmo(YY)
# calculate Pr(YY&gt;10)
1-m1$cdf(10)
# calculate Pr(-10&lt;YY&lt;10)
1-(1-m1$cdf(10))-m1$cdf(-10)
#---------------------------
#   from discrete distribution
YYY &lt;- rNBI(1000, mu=5, sigma=4)
histSmo(YYY, discrete=TRUE, plot=T)
#
YYY &lt;- rPO(1000, mu=5)
histSmo(YYY, discrete=TRUE, plot=T)
#
YYY &lt;- rNBI(1000, mu=5, sigma=.1)
histSmo(YYY, discrete=TRUE, plot=T)
# genarating from beta distribution
YYY &lt;- rBE(1000, mu=.1, sigma=.3)
histSmo(YYY, lower=0, upper=1, plot=T)
# from trucated data
Y &lt;- with(stylo, rep(word,freq))
histSmo(Y, lower=1, discrete=TRUE, plot=T)
histSmo(Y, lower=1, discrete=TRUE, plot=T, type="prob")
## End(Not run)
</code></pre>

<hr>
<h2 id='IC'>Gives the GAIC for a GAMLSS Object</h2><span id='topic+IC'></span><span id='topic+AIC.gamlss'></span><span id='topic+GAIC'></span><span id='topic+extractAIC.gamlss'></span><span id='topic+GAIC.table'></span><span id='topic+GAIC.scaled'></span>

<h3>Description</h3>

<p>The function <code>GAIC()</code> calculates the Generalised Akaike information criterion (GAIC) for a given penalty <code>k</code> for a fitted GAMLSS object. 
</p>
<p>The function <code>AIC.gamlss()</code> is the method associated with a GAMLSS object of the generic function <code>AIC()</code>. Note that <code>GAIC()</code> is a synonymous of the function <code>AIC.gamlss</code>.
</p>
<p>The function <code>IC()</code> is an old version of   <code>GAIC()</code>.
</p>
<p>The function <code>GAIC.table()</code> produces a table with different models as rows and different penalties, <code>k</code>, as columns.
</p>
<p>The function <code>GAIC.scaled()</code> produces, [for a given set of different fitted models or for a table produced by <code>chooseDist()</code>], the  scaled  Akaike values (see Burnham  and  Anderson (2002) section 2.9 for a similar concept the GAIC weights. The scaled Akaike  should not be interpreted as posterior probabilities of models given the data but for model selection purpose they produce a scaled ranking of the model using their relative importance i.e. from the worst to the best model.   
</p>
<p>The function <code>extractAIC</code> is a the method associated a GAMLSS object of the generic function <code>extractAIC</code> and it is 
mainly used in the <code>stepAIC</code> function. 
</p>
<p>The function <code>Rsq</code> compute a generalisation of the R-squared for not normal models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(object, k = 2)
## S3 method for class 'gamlss'
AIC(object, ..., k = 2, c = FALSE)
GAIC(object, ..., k = 2, c = FALSE )
GAIC.table(object, ..., k = c(2, 3.84, round(log(length(object$y)), 2)),
           text.to.show=NULL)
GAIC.scaled(object,..., k = 2, c = FALSE, plot = TRUE,   
              text.cex = 0.7, which = 1, diff.dev = 1000,
              text.to.show = NULL, col = NULL, horiz = FALSE) 
## S3 method for class 'gamlss'
extractAIC(fit, scale, k = 2, c = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_+3A_object">object</code></td>
<td>
<p>an gamlss fitted model(s) [or for <code>GAIC.scaled()</code> a table 
produced by <code>chooseDist()</code>].</p>
</td></tr>
<tr><td><code id="IC_+3A_fit">fit</code></td>
<td>
<p>an gamlss fitted model</p>
</td></tr>
<tr><td><code id="IC_+3A_...">...</code></td>
<td>
<p>allows several GAMLSS object to be compared using a GAIC</p>
</td></tr>
<tr><td><code id="IC_+3A_k">k</code></td>
<td>
<p>the penalty with default <code>k=2.5</code></p>
</td></tr>
<tr><td><code id="IC_+3A_c">c</code></td>
<td>
<p>whether the corrected AIC, i.e. AICc, should be used, note that it applies only when  <code>k=2</code></p>
</td></tr>
<tr><td><code id="IC_+3A_scale">scale</code></td>
<td>
<p>this argument is not used in gamlss</p>
</td></tr>
<tr><td><code id="IC_+3A_plot">plot</code></td>
<td>
<p>whether to plot the ranking in <code>GAIC.scaled()</code>.</p>
</td></tr>
<tr><td><code id="IC_+3A_text.cex">text.cex</code></td>
<td>
<p>the size of the models/families in the text of the plot of <code>GAIC.scaled()</code>.</p>
</td></tr>
<tr><td><code id="IC_+3A_diff.dev">diff.dev</code></td>
<td>
<p>this argument prevents models with a difference in deviance greater than <code>diff.dev</code> from the &lsquo;best&rsquo; model to be considered (or plotted).</p>
</td></tr>
<tr><td><code id="IC_+3A_which">which</code></td>
<td>
<p>which column of GAIC scaled to plot in <code>GAIC.scaled()</code>.</p>
</td></tr>
<tr><td><code id="IC_+3A_text.to.show">text.to.show</code></td>
<td>
<p>if NULL, <code>GAIC.scaled()</code> shows the model names otherwise the character in this list</p>
</td></tr>
<tr><td><code id="IC_+3A_col">col</code></td>
<td>
<p>The colour of the bars in  <code>GAIC.scaled()</code></p>
</td></tr>
<tr><td><code id="IC_+3A_horiz">horiz</code></td>
<td>
<p>whether to plot the bars vertically (default) or horizontally</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>IC()</code> returns the GAIC for given penalty k of the GAMLSS object.
The function <code>AIC()</code> returns a matrix contains the df's and the GAIC's for given penalty k. 
The function <code>GAIC()</code> returns identical results to <code>AIC</code>. 
The function <code>GAIC.table()</code> returns a table which its rows showing different models and its columns different <code>k</code>'s.  
The function <code>extractAIC()</code> returns vector of length two with the degrees of freedom and the AIC criterion.  
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

 
<p>Burnham K. P.  and  Anderson D. R (2002). <em>Model Selection and Multi model Inference
A Practical Information-Theoretic Approach</em>, Second Edition, Springer-Verlag New York, Inc.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
m1 &lt;-  gamlss(y~x, family=NO, data=abdom)
IC(m1)
extractAIC(m1,k=2)
m2 &lt;-  gamlss(y~x, sigma.fo=~x, family=NO, data=abdom)
m3 &lt;-  gamlss(y~pb(x), sigma.fo=~x, family=NO, data=abdom)
m4 &lt;-  gamlss(y~pb(x), sigma.fo=~pb(x), family=NO, data=abdom)
AIC(m1,m2, m3, m4)
AIC(m1,m2, m3, m4, c=TRUE)
AIC(m1,m2, m3, m4, k=3)
GAIC.table(m1,m2, m3, m4)
GAIC.scaled(m1,m2, m3, m4)
## Not run: 
MT &lt;- chooseDist(m3)
GAIC.scaled(MT)
GAIC.scaled(MT, which=2)
## End(Not run)
</code></pre>

<hr>
<h2 id='lms'>A function to fit LMS curves for centile estimation</h2><span id='topic+lms'></span>

<h3>Description</h3>

<p>This function is design to help the user to easily construct growth curve centile estimation.
It is  applicable when only &quot;one&quot; explanatory variable is available (usually age).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lms(y, x, families = LMS, data = NULL, k = 2, 
        cent = c(0.4, 2, 10, 25, 50, 75, 90, 98, 99.6),
        calibration = TRUE, trans.x = FALSE, 
        fix.power = NULL, lim.trans = c(0, 1.5), 
        prof = FALSE, step = 0.1, legend = FALSE, 
        mu.df = NULL, sigma.df = NULL, nu.df = NULL, 
        tau.df = NULL, c.crit = 0.01, 
        method.pb = c("ML", "GAIC"), ...)        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lms_+3A_y">y</code></td>
<td>
<p>The response variable</p>
</td></tr>
<tr><td><code id="lms_+3A_x">x</code></td>
<td>
<p>The unique explanatory variable</p>
</td></tr>
<tr><td><code id="lms_+3A_families">families</code></td>
<td>
<p>a list of <code>gamlss.families</code> with default <code>LMS=c("BCCGo",  "BCPEo", "BCTo")</code></p>
</td></tr>
<tr><td><code id="lms_+3A_data">data</code></td>
<td>
<p>the data frame</p>
</td></tr>
<tr><td><code id="lms_+3A_k">k</code></td>
<td>
<p>the penalty to be used in the GAIC</p>
</td></tr>
<tr><td><code id="lms_+3A_cent">cent</code></td>
<td>
<p>a vector with elements the % centile values for which the centile curves have to be evaluated</p>
</td></tr> 
<tr><td><code id="lms_+3A_calibration">calibration</code></td>
<td>
<p>whether calibration is required with default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="lms_+3A_trans.x">trans.x</code></td>
<td>
<p>whether to check for transformation in x with default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="lms_+3A_fix.power">fix.power</code></td>
<td>
<p>if set it fix the power of the transformation for x</p>
</td></tr>
<tr><td><code id="lms_+3A_lim.trans">lim.trans</code></td>
<td>
<p>the limits for the search of the power parameter for x</p>
</td></tr>
<tr><td><code id="lms_+3A_prof">prof</code></td>
<td>
<p>whether to use the profile GAIC of the power transformation</p>
</td></tr>
<tr><td><code id="lms_+3A_step">step</code></td>
<td>
<p>if <code>prof=TRUE</code> is used this determine the step for the profile GAIC </p>
</td></tr>
<tr><td><code id="lms_+3A_legend">legend</code></td>
<td>
<p>whether a legend is required in the plot with default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="lms_+3A_mu.df">mu.df</code></td>
<td>
<p><code>mu</code> effective degrees of freedom if required otherwise are estimated</p>
</td></tr>
<tr><td><code id="lms_+3A_sigma.df">sigma.df</code></td>
<td>
<p><code>sigma</code> effective degrees of freedom if required otherwise are estimated</p>
</td></tr>
<tr><td><code id="lms_+3A_nu.df">nu.df</code></td>
<td>
<p><code>nu</code> effective degrees of freedom if required otherwise are estimated</p>
</td></tr>
<tr><td><code id="lms_+3A_tau.df">tau.df</code></td>
<td>
<p><code>tau</code> effective degrees of freedom if required otherwise are estimated</p>
</td></tr>
<tr><td><code id="lms_+3A_c.crit">c.crit</code></td>
<td>
<p>the convergence criterion to be pass to <code>gamlss()</code> </p>
</td></tr>
<tr><td><code id="lms_+3A_method.pb">method.pb</code></td>
<td>
<p>the method used in the <code>pb()</code> for estimating the smoothing 
parameters. The default is local maximum likelihood <code>"ML"</code>. <code>"GAIC"</code> is also permitted where <code>k</code> is taken from the <code>k</code> argument of the function.</p>
</td></tr>
<tr><td><code id="lms_+3A_...">...</code></td>
<td>
<p>extra argument which can be passed to <code>gamlss()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be used if the construction of the centile curves involves only one explanatory variable. 
</p>
<p>The model assumes that the response variable has a flexible distribution i.e. <code class="reqn">y ~ D(\mu, \sigma, \nu, \tau)</code> where the parameters of the distribution are smooth functions of the explanatory variable i.e. <code class="reqn">g(\mu)= s(x)</code>, where <code class="reqn">g()</code> is a link function and <code class="reqn">s()</code> is a smooth function. Occasionally a power transformation in the x-axis helps the construction of the centile curves. That is, in this case the parameters are modelled by <code class="reqn">x^p</code> rather than just x, i.e.<code class="reqn">g(\mu)= s(x^p)</code>. The function <code>lms()</code> uses  P-splines (<code>pb()</code>) as a smoother. 
</p>
<p>If a transformation is needed for <code>x</code> the function <code>lms()</code>  starts by finding an optimum value for <code>p</code>  using the simple model  <code class="reqn">NO(\mu=s(x^p))</code>. (Note that this value of <code>p</code> is not the optimum for the final chosen model but it works well in practice.) 
</p>
<p>After fitting a Normal error model for staring values the function proceeds by fitting several &quot;appropriate&quot; distributions for the response variable.
The set of <code>gamlss.family</code> distributions to fit is specified by the argument <code>families</code>. 
The default <code>families</code> arguments is <code>LMS=c("BCCGo",  "BCPEo", "BCTo")</code> that is the LMS class of distributions, Cole and Green (1992).
Note that this class is only appropriate when y is positive (with no zeros). If the response variable contains negative values and zeros then use the argument <code>families=theSHASH</code> where <code>theSHASH &lt;-  c("NO", "SHASHo")</code> or add any other list of distributions which you may think is appropriate.
Justification of using the specific centile (0.38  2.27  9.1211220 25.25, 50, 74.75, 90.88, 97.72, 99.62) is given in Cole (1994).
</p>


<h3>Value</h3>

<p>It returns a <code>gamlss</code> fitted object</p>


<h3>Note</h3>

<p>The function is fitting several models and for large data can be slow</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Vlasios Voudouris</p>


<h3>References</h3>

<p>Cole, T. J. (1994) Do growth chart centiles need a face lift?
<em>BMJ</em>, 308&ndash;641.
</p>
<p>Cole,  T. J. and Green,  P. J. (1992) Smoothing reference centile curves: the LMS method and penalized likelihood, <em>Statist. Med.</em> <b>11</b>, 1305&ndash;1319
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles">centiles</a></code>, <code><a href="#topic+calibration">calibration</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(abdom)
m1 &lt;- lms(y,x , data=abdom, n.cyc=30)
m2 &lt;- lms(y,x ,data=abdom, method.pb="GAIC", k=log(610))
# this example takes time
data(db)
m1 &lt;- lms(y=head, x=age, data=db, trans.x=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='lo'> Specify a loess fit in a GAMLSS formula</h2><span id='topic+lo'></span><span id='topic+lo.control'></span><span id='topic+vis.lo'></span>

<h3>Description</h3>

<p>Allows the user to specify a <code>loess</code> fit within a GAMLSS model. This function is similar to the <code>lo</code> function in the <code>gam</code> implementation of package <code>gam</code> see Chambers and Hastie (1991).
</p>
<p>The function <code>vis.lo()</code> allows plotting the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lo(formula, control = lo.control(...), ...)
lo.control(span = 0.75, enp.target = NULL, 
          degree = 2, parametric = FALSE, drop.square = FALSE, 
          normalize = TRUE, family = c("gaussian", "symmetric"), 
          method = c("loess", "model.frame"), 
          surface = c("interpolate", "direct"), 
          statistics = c("approximate", "exact", "none"), 
          trace.hat = c("exact", "approximate"), 
          cell = 0.2, iterations = 4,iterTrace = FALSE, ...)
vis.lo(obj, se=-1, rug = FALSE, partial.resid = FALSE, 
          col.term = "darkred",  col.shaded = "gray", 
          col.res = "lightblue", col.rug = "gray", lwd.term = 1.5, 
          cex.res = 1, pch.res = par("pch"), 
          type = c("persp", "contour"), col.surface = "gray", 
          nlevels = 30, n.grid = 30, image = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lo_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the explanatory variables </p>
</td></tr>
<tr><td><code id="lo_+3A_control">control</code></td>
<td>
<p>a control to be passed to the <code>loess</code> function </p>
</td></tr>
<tr><td><code id="lo_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
<tr><td><code id="lo_+3A_span">span</code></td>
<td>
<p>the number of observations in a neighbourhood. This is the smoothing parameter for a loess fit.</p>
</td></tr>
<tr><td><code id="lo_+3A_enp.target">enp.target</code></td>
<td>
<p>an alternative way to specify span, as the approximate equivalent number degrees of freedom to be used. See also the help file of the <span class="rlang"><b>R</b></span> function <code>loess</code>. For consistency with the older version of <code>lo</code> the effective degrees of freedom <code>df</code> can be also specified instead of span, e.g. <code>df=5</code></p>
</td></tr>
<tr><td><code id="lo_+3A_degree">degree</code></td>
<td>
<p>the degree of local polynomial; can be 1 or 2. See also the help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_parametric">parametric</code></td>
<td>
<p>should any terms be fitted globally rather than locally? See the help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_drop.square">drop.square</code></td>
<td>
<p>for fits with more than one predictor and degree=2, should the quadratic term be dropped for particular predictors?. See also help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_normalize">normalize</code></td>
<td>
<p>should the predictors be normalized to a common scale if there is more than one? See the help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_family">family</code></td>
<td>
<p>if <code>"gaussian"</code> fitting is by least-squares, and if &quot;symmetric&quot; a re-descending M estimator is used with Tukey's biweight function. See the help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_method">method</code></td>
<td>
<p>fit the model or just extract the model frame. See the help file of <code>loess</code></p>
</td></tr>
<tr><td><code id="lo_+3A_surface">surface</code></td>
<td>
<p>should the fitted surface be computed exactly or via interpolation from a kd tree? See also
the help file of <code>loess.control</code></p>
</td></tr>
<tr><td><code id="lo_+3A_statistics">statistics</code></td>
<td>
<p>should the statistics be computed exactly or approximately? See the help file of <code>loess.control</code></p>
</td></tr>
<tr><td><code id="lo_+3A_trace.hat">trace.hat</code></td>
<td>
<p>should the trace of the smoother matrix be computed exactly or approximately? See the help file of <code>loess.control</code></p>
</td></tr>
<tr><td><code id="lo_+3A_cell">cell</code></td>
<td>
<p>if interpolation is used this controls the accuracy of the approximation via the maximum number of points in a cell in the kd tree. See the help file of <code>loess.control</code></p>
</td></tr>
<tr><td><code id="lo_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used in robust fitting. See the help file of <code>loess.control</code></p>
</td></tr>
<tr><td><code id="lo_+3A_itertrace">iterTrace</code></td>
<td>
<p>logical (or integer) determining if tracing information during the robust iterations (iterations&gt;= 2) is produced. See the help file of <code>loess.control</code></p>
</td></tr>

<tr><td><code id="lo_+3A_obj">obj</code></td>
<td>
<p>an <code>lowss</code> object fitted within gamlss</p>
</td></tr>
<tr><td><code id="lo_+3A_se">se</code></td>
<td>
<p>if <code>se&gt;0</code> then standard errors surfaces are drawn in the 3-dimensional plot. Set <code>se</code> at the required level i.e <code>se=1.96</code> will be an approximated 95% CI.</p>
</td></tr>
<tr><td><code id="lo_+3A_rug">rug</code></td>
<td>
<p>whether to plot a rug in the plot</p>
</td></tr>
<tr><td><code id="lo_+3A_partial.resid">partial.resid</code></td>
<td>
<p>whether to plot the partial residuals</p>
</td></tr> 
<tr><td><code id="lo_+3A_col.term">col.term</code></td>
<td>
<p>the colour of the line of fitted term</p>
</td></tr>
<tr><td><code id="lo_+3A_cex.res">cex.res</code></td>
<td>
<p> the shading of standard</p>
</td></tr>
<tr><td><code id="lo_+3A_col.shaded">col.shaded</code></td>
<td>
<p>the shading of standard error intervals</p>
</td></tr>
<tr><td><code id="lo_+3A_col.res">col.res</code></td>
<td>
<p>the colour of partial residuals</p>
</td></tr>
<tr><td><code id="lo_+3A_col.rug">col.rug</code></td>
<td>
<p>the colour of the rug</p>
</td></tr>
<tr><td><code id="lo_+3A_lwd.term">lwd.term</code></td>
<td>
<p>the width of the line</p>
</td></tr>
<tr><td><code id="lo_+3A_pch.res">pch.res</code></td>
<td>
<p>The character for the partial residuals</p>
</td></tr>
<tr><td><code id="lo_+3A_type">type</code></td>
<td>
<p>The type of the plot if the x's are two dimensional</p>
</td></tr>
<tr><td><code id="lo_+3A_col.surface">col.surface</code></td>
<td>
<p>the colour of the fitted surface</p>
</td></tr>
<tr><td><code id="lo_+3A_nlevels">nlevels</code></td>
<td>
<p>the number of levels used in <code>cotour()</code> plot.</p>
</td></tr>
<tr><td><code id="lo_+3A_n.grid">n.grid</code></td>
<td>
<p>The number of points to evaluate the surface</p>
</td></tr> 
<tr><td><code id="lo_+3A_image">image</code></td>
<td>
<p>whether to use <code>image()</code> or just <code>contour</code></p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Note that <code>lo</code> itself does no smoothing; it simply sets things up for the function <code>gamlss.lo()</code> which is used by the backfitting function  <code>gamlss.add()</code>.
</p>


<h3>Value</h3>

<p>a <code>loess</code> object is returned.  
</p>


<h3>Warning </h3>

<p>In this version the first argument is a formula NOT a list as in the previous one</p>


<h3>Note</h3>

<p>Note that <code>lo</code> itself does no smoothing; it simply sets things up for <code>gamlss.lo()</code> to do the backfitting.</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby, (The original <code>lo()</code> function was based on the Trevor Hastie's S-plus <code>lo()</code> function. See also the documentation of the <code>loess</code> function for the authorship of the function.</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cs">cs</a></code>, <code><a href="#topic+random">random</a></code>,  </p>


<h3>Examples</h3>

<pre><code class='language-R'># fitting a loess curve with span=0.4 plus the a quarterly  effect 
aids1&lt;-gamlss(y~lo(~x,span=0.4)+qrt,data=aids,family=PO) # 
term.plot(aids1, page=1)
## Not run: 
r1 &lt;- gamlss(R~lo(~Fl)+lo(~A), data=rent, family=GA)
 term.plot(r1, pages=1)
 vis.lo(getSmo(r1, which=1), partial=T)
r2 &lt;- gamlss(R~lo(~Fl+A), data=rent, family=GA)
 term.plot(r2, pages=1)
 vis.lo(getSmo(r2, which=1))
 vis.lo(getSmo(r2, which=1), se=1.97)
 vis.lo(getSmo(r2, which=1), partial.res=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='loglogSurv'>
Survival function plots for checking the tail behaviour of the data
</h2><span id='topic+loglogSurv'></span><span id='topic+loglogSurv1'></span><span id='topic+loglogSurv2'></span><span id='topic+loglogSurv3'></span><span id='topic+logSurv'></span><span id='topic+logSurv0'></span><span id='topic+ECDF'></span><span id='topic+loglogplot'></span><span id='topic+loglogplot0'></span>

<h3>Description</h3>

<p>The log-log Survival functions are design for checking the tails of a single response variable (no explanatory should be involved). There are three different function:
</p>
<p>a) the function <code>loglogSurv1()</code> which plot the right tails of the empirical log-log Survival function against <code>loglog(y)</code>, where y is the variable of interest. The coefficient of a linear fit to the plot can be used as an estimated for Type I tails  (see Chapter 17 in Rigby <em>et al.</em> (2019) for definition of the different types of tails.) 
</p>
<p>b)  the function <code>loglogSurv2()</code> which plot the  right tails of the empirical log-log Survival function against <code>log(y)</code>. The coefficient of a linear fit to the plot can be used as an  estimated for Type II tails. 
</p>
<p>c)  the function <code>loglogSurv3()</code> which plot the (left or right) tails of the empirical log-log Survival function against
<code>y</code>. The coefficient of a linear fit to the plot can be used as an estimated for Type III tails. 
</p>
<p>The function <code>loglogSurv()</code> combines all the above functions. 
</p>
<p>The function <code>logSurv()</code> is design for exploring the heavy tails of a single response variable. It plots the empirical log-survival function of the right tail of the distribution or the empirical log-cdf function  of the  left tail against <code>log(y)</code> for a specified probability of the tail. Then fits a linear, a quadratic and an exponential curve to the points of the plot. For distributions defined on the positive real line a good linear fit would indicate a Pareto type tail, a good quadratic fit a log-normal type tail and good exponential fit a Weibull type tail. Note that this function is only appropriate to investigate rather heavy tails and it is not very good to discriminate between different type of tails, as the <code>loglogSurv()</code>. The function <code>logSurv0()</code> plots but do not fit the curves.
</p>
<p>The function <code>loglogplot()</code> plot  the empirical log-survival function of all data against  <code>log(y)</code>. 
The function <code>ECDF()</code> calculates the empirical commutative distribution function. It is similar to <code>ecdf()</code> but divides by <code>n+1</code> rather <code>n</code>, the number of conservations.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglogSurv(y, prob = 0.9, print = TRUE, title = NULL, lcol = gray(0.1), 
           ltype = 1, plot = TRUE, ...)

loglogSurv1(y, prob = 0.9, print = TRUE, title = NULL, lcol = gray(0.1), 
           ltype = 1, ...)

loglogSurv2(y, prob = 0.9, print = TRUE, title = NULL, lcol = gray(0.1), 
           ltype = 1, ...)
           
loglogSurv3(y, prob = 0.9, print = TRUE, title = NULL, lcol = gray(0.1), 
           ltype = 1, ...)
          
logSurv(y, prob = 0.9, tail = c("right", "left"), plot = TRUE, 
       lines = TRUE, print = TRUE, title = NULL, lcol = c(gray(0.1), 
       gray(0.2), gray(0.3)), ltype = c(1, 2, 3), ...)  

logSurv0(y, prob = 0.9, tail = c("right", "left"), plot = TRUE, 
           title = NULL, ...)
           
         
ECDF(y, weights=NULL)

loglogplot(y, nplus1 = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglogSurv_+3A_y">y</code></td>
<td>
<p>a vector, the variable of interest</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_prob">prob</code></td>
<td>
<p>what probability. The defaul is  0.90 which means 10% for &quot;right&quot; tail 90% for &quot;left&quot; tail </p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_tail">tail</code></td>
<td>
<p>which tall needs checking the right (default) of the left</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_plot">plot</code></td>
<td>
<p>whether to plot with default equal <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_print">print</code></td>
<td>
<p>whether to print the coefficients with default equal <code>TRUE</code></p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_title">title</code></td>
<td>
<p>if a different title rather the default is needed</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_lcol">lcol</code></td>
<td>
<p>The line colour in the plot</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_lines">lines</code></td>
<td>
<p>whether to plot the fitted lines</p>
</td></tr>  
<tr><td><code id="loglogSurv_+3A_ltype">ltype</code></td>
<td>
<p>The line type in the plot</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_nplus1">nplus1</code></td>
<td>
<p>whether to divide by n+1 or n when calculating the ecdf</p>
</td></tr>
<tr><td><code id="loglogSurv_+3A_weights">weights</code></td>
<td>
<p>prior weights for <code>ECDF()</code></p>
</td></tr>  
<tr><td><code id="loglogSurv_+3A_...">...</code></td>
<td>
<p>for extra argument in the plot command</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>loglogSurv1()</code>, <code>loglogSurv3()</code> and <code>loglogSurv3()</code> take the upper  part of an ordered variable, create its empirical survival function, and plot the log-log of this functions against <code>log(log(y))</code>, <code>log(y)</code> and <code>y</code>, respectively. Then they fit a line to the plot. The coefficients of the line can be interpreted as parameters determined the behaviour of the tail.
The function <code>loglogSurv()</code> fits all three models and displays  the best. 
</p>
<p>The function <code>logSurv()</code> takes the upper (or lower) part of an ordered variable  and plots the log empirical survival function against log(y). Also display three curves i) linear ii) quadratic and iii) exponential to determine what kind of tail relationship exist. Plotting the log  empirical survival function against log(y) often call in the literature the &quot;log-log plot&quot;. 
</p>
<p>The function <code>loglogplot()</code> plots the whole log  empirical survival function against log(y) (not just the tail).  The function <code>ECDF()</code>  calculate the step function of the empirical cumulative distribution function.
</p>
<p>More details can be found in Chapter 17 of  &quot;Rigby <em>et al.</em> (2019)  book  an old version on which can be found in   <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>)
</p>


<h3>Value</h3>

<p>The functions create plots. 
</p>


<h3>Author(s)</h3>

<p>Bob Rigby, Mikis Stasinopoulos and Vlassios Voudouris 
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modelling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. (In press)
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(film90)
y &lt;- film90$lborev1
op&lt;-par(mfrow=c(3,1))
loglogSurv1(y)
loglogSurv2(y)
loglogSurv3(y)
par(op)
loglogSurv(y)

logSurv(y)

loglogplot(y)

plot(ECDF(y), main="ECDF")
</code></pre>

<hr>
<h2 id='lpred'>Extract Linear Predictor Values and Standard Errors For A GAMLSS Model </h2><span id='topic+lpred'></span><span id='topic+lp'></span>

<h3>Description</h3>

<p>The function <code>lpred()</code> is the GAMLSS specific method which extracts the linear predictor and its (approximate) standard errors 
for a specified model parameter from a GAMLSS objects.  
The <code>lpred()</code> can be used to extract the predictor fitted values (and its approximate standard errors) or the contribution of specific terms in the model  
(with their approximate standard errors) in the same way that the <code>predict.lm()</code> and <code>predict.glm()</code> functions can be used for 
<code>lm</code> or <code>glm</code> objects. 
Note that <code>lpred()</code> extract information for the predictors of <code>mu</code>,<code>sigma</code>, <code>nu</code> and <code>tau</code> at the training data values.  If predictions are  required for new data then use the 
functions <code>predict.gamlss()</code> or <code>predictAll()</code>.
</p>
<p>The function <code>lp</code> extract only the linear predictor at the training data values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpred(obj, what = c("mu", "sigma", "nu", "tau"), parameter= NULL,
           type = c("link", "response", "terms"), 
           terms = NULL, se.fit = FALSE, ...)
lp(obj, what = c("mu", "sigma", "nu", "tau"), parameter= NULL, ... ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpred_+3A_obj">obj</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="lpred_+3A_what">what</code></td>
<td>
<p>which distribution parameter is required, default <code>what="mu"</code> </p>
</td></tr>
<tr><td><code id="lpred_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="lpred_+3A_type">type</code></td>
<td>
<p><code>type="link"</code> (the default) gets the linear predictor for the specified distribution parameter. 
<code>type="response"</code> gets the fitted values for the parameter while <code>type="terms"</code> gets the fitted terms contribution</p>
</td></tr>
<tr><td><code id="lpred_+3A_terms">terms</code></td>
<td>
<p>if <code>type="terms"</code>, which terms to be selected (default is all terms) </p>
</td></tr>
<tr><td><code id="lpred_+3A_se.fit">se.fit</code></td>
<td>
<p>if TRUE the approximate standard errors of the appropriate type are extracted</p>
</td></tr>
<tr><td><code id="lpred_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>se.fit=FALSE</code> a vector (or a matrix) of the appropriate <code>type</code> is extracted from the GAMLSS object for the given parameter in <code>what</code>.
If <code>se.fit=TRUE</code> a list containing  the appropriate <code>type</code>, <code>fit</code>, and  its (approximate) standard errors, <code>se.fit</code>. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+predict.gamlss">predict.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
mod&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
mod.t &lt;- lpred(mod, type = "terms", terms= "qrt")
mod.t
mod.lp &lt;- lp(mod)
mod.lp 
rm(mod, mod.t,mod.lp)
</code></pre>

<hr>
<h2 id='LR.test'>Likelihood Ratio test for nested GAMLSS models
</h2><span id='topic+LR.test'></span>

<h3>Description</h3>

<p>The function performs  a likelihood ration test for two nested fitted model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR.test(null, alternative, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR.test_+3A_null">null</code></td>
<td>
<p>The null hypothesis (simpler) fitted model 
</p>
</td></tr>
<tr><td><code id="LR.test_+3A_alternative">alternative</code></td>
<td>

<p>The alternative hypothesis (more complex) fitted model
</p>
</td></tr>
<tr><td><code id="LR.test_+3A_print">print</code></td>
<td>
<p>whether to print or save the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Warning: no checking whether the models are nested 
is performed. </p>


<h3>Value</h3>

<p> If <code>print=FALSE</code> a list with 
<code>chi</code>, <code>df</code> and <code>p.val</code> is produced.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="MASS.html#topic+dropterm">dropterm</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(usair)
m0&lt;-gamlss(y~x1+x2, data=usair)
m1&lt;-gamlss(y~x1+x2+x3+x4, data=usair)
LR.test(m0,m1)
</code></pre>

<hr>
<h2 id='model.frame.gamlss'>Extract a model.frame, a model matrix or terms from a GAMLSS object for a given distributional parameter</h2><span id='topic+model.frame.gamlss'></span><span id='topic+terms.gamlss'></span><span id='topic+model.matrix.gamlss'></span>

<h3>Description</h3>

<p><code>model.frame.gamlss</code>, <code>model.matrix.gamlss</code> and <code>terms.gamlss</code> are the gamlss versions of the  generic functions
<code>model.frame</code>, <code>model.matrix</code> and <code>terms</code> respectively. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
model.frame(formula, what = c("mu", "sigma", "nu", "tau"),
                     parameter= NULL, ...)
## S3 method for class 'gamlss'
terms(x, what = c("mu", "sigma", "nu", "tau"), 
                     parameter= NULL,  ...)
## S3 method for class 'gamlss'
model.matrix(object, what = c("mu", "sigma", "nu", "tau"), 
                      parameter= NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.gamlss_+3A_formula">formula</code></td>
<td>
<p>a gamlss object</p>
</td></tr>
<tr><td><code id="model.frame.gamlss_+3A_x">x</code></td>
<td>
<p>a gamlss object</p>
</td></tr>
<tr><td><code id="model.frame.gamlss_+3A_object">object</code></td>
<td>
<p>a gamlss object</p>
</td></tr>
<tr><td><code id="model.frame.gamlss_+3A_what">what</code></td>
<td>
<p>for which parameter to extract the model.frame, terms or model.frame </p>
</td></tr>
<tr><td><code id="model.frame.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="model.frame.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model.frame, a model.matrix or terms 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos </p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
mod&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
model.frame(mod)
model.matrix(mod)
terms(mod, "mu")
rm(mod)
</code></pre>

<hr>
<h2 id='numeric.deriv'>An internal GAMLSS function for numerical derivatives</h2><span id='topic+numeric.deriv'></span>

<h3>Description</h3>

<p>A function to calculate numerical derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric.deriv(expr, theta, delta = NULL, 
              rho = sys.frame(sys.parent()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numeric.deriv_+3A_expr">expr</code></td>
<td>
<p>The expression to be differentiated</p>
</td></tr>
<tr><td><code id="numeric.deriv_+3A_theta">theta</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="numeric.deriv_+3A_delta">delta</code></td>
<td>
<p>constant for the accuracy</p>
</td></tr>
<tr><td><code id="numeric.deriv_+3A_rho">rho</code></td>
<td>
<p>environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is use by several GAMLSS functions  but it is not for general use since there are more reliable  function to do that in <code>R</code>.
</p>


<h3>Value</h3>

<p>A vector of numerical derivatives
</p>


<h3>Note</h3>

<p>Do not use this function unless you know what you are doing
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion),  <em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>

<hr>
<h2 id='par.plot'>A function to plot parallel plot for repeated measurement data</h2><span id='topic+par.plot'></span>

<h3>Description</h3>

<p>This function can be used to plot parallel plots for each individual in a repeated measurement study. 
It is based on the <code>coplot()</code> function of <code>R</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.plot(formula = NULL, data = NULL, subjects = NULL, 
          color = TRUE, show.given = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.plot_+3A_formula">formula</code></td>
<td>
<p> a formula describing the form of conditioning plot.  A
formula of the form <code>y ~ x | a</code> indicates that plots of <code>y</code>
versus <code>x</code> should be produced conditional on the variable
<code>a</code>.  A formula of the form <code>y ~ x| a * b</code> indicates that
plots of <code>y</code> versus <code>x</code> should be produced conditional on the
two variables <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="par.plot_+3A_data">data</code></td>
<td>
<p> a data frame containing values for any variables in the
formula.  This argument is compulsory.</p>
</td></tr>
<tr><td><code id="par.plot_+3A_subjects">subjects</code></td>
<td>
<p>a factor which distinguish between the individual participants </p>
</td></tr>
<tr><td><code id="par.plot_+3A_color">color</code></td>
<td>
<p>whether the parallel plot are shown in colour, <code>color=TRUE</code> (the default) or not <code>color=FALSE</code>  </p>
</td></tr>
<tr><td><code id="par.plot_+3A_show.given">show.given</code></td>
<td>
<p> logical (possibly of length 2 for 2 conditioning variables): 
should conditioning plots be shown for the  corresponding conditioning variables (default 'TRUE')</p>
</td></tr>
<tr><td><code id="par.plot_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a plot. 
</p>


<h3>Note</h3>

<p>Note that similar plot can be fount in the library <code>nlme</code> by Pinheiro and Bates</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>App. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(nlme)
data(Orthodont)
par.plot(distance~age,data=Orthodont,subject=Subject)
par.plot(distance~age|Sex,data=Orthodont,subject=Subject)
par.plot(distance~age|Subject,data=Orthodont,subject=Subject,show.given=FALSE)

</code></pre>

<hr>
<h2 id='pcat'>
Reduction for the Levels of a Factor.
</h2><span id='topic+pcat'></span><span id='topic+gamlss.pcat'></span><span id='topic+plotLambda'></span><span id='topic+plotDF'></span>

<h3>Description</h3>

<p>The function is trying to merged similar levels of a given factor. Its based on ideas given by 
Tutz (2013). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcat(fac, df = NULL, lambda = NULL, method = c("ML", "GAIC"), start = 0.001, 
         Lp = 0, kappa = 1e-05, iter = 100, c.crit = 1e-04, k = 2)

gamlss.pcat(x, y, w, xeval = NULL, ...)

plotDF(y, factor = NULL, formula = NULL, data, along = seq(0, nlevels(factor)), 
         kappa = 1e-06, Lp = 0, ...)

plotLambda(y, factor = NULL, formula = NULL, data, along = seq(-2, 2, 0.1), 
         kappa = 1e-06, Lp = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcat_+3A_fac">fac</code>, <code id="pcat_+3A_factor">factor</code></td>
<td>
<p>a factor to reduce its levels</p>
</td></tr> 
<tr><td><code id="pcat_+3A_df">df</code></td>
<td>
<p>the effective degrees of freedom df</p>
</td></tr>
<tr><td><code id="pcat_+3A_lambda">lambda</code></td>
<td>
<p>the smoothing parameter</p>
</td></tr>
<tr><td><code id="pcat_+3A_method">method</code></td>
<td>
<p>which method is used for the estimation of the smoothing parameter, <code>"ML"</code> or <code>"GAIC"</code> are allowed.</p>
</td></tr>
<tr><td><code id="pcat_+3A_start">start</code></td>
<td>
<p> starting value for <code>lambda</code> if it estimated using <code>"ML"</code> or <code>"GAIC"</code></p>
</td></tr>
<tr><td><code id="pcat_+3A_lp">Lp</code></td>
<td>

<p>The type of penalty required, <code>Lp=0</code> is the default. Use <code>Lp=1</code> for lasso type and different values for different required penalty.
</p>
</td></tr>
<tr><td><code id="pcat_+3A_kappa">kappa</code></td>
<td>
<p>a regulation parameters used for the weights in the penalties.</p>
</td></tr>
<tr><td><code id="pcat_+3A_iter">iter</code></td>
<td>

<p>the number of internal iteration allowed
</p>
</td></tr>
<tr><td><code id="pcat_+3A_c.crit">c.crit</code></td>
<td>
<p>the convergent criterion</p>
</td></tr>
<tr><td><code id="pcat_+3A_k">k</code></td>
<td>
<p>the penalty if <code>"GAIC"</code> method is used.</p>
</td></tr>
<tr><td><code id="pcat_+3A_x">x</code></td>
<td>
<p>explanatory factor</p>
</td></tr>
<tr><td><code id="pcat_+3A_y">y</code></td>
<td>
<p>the response or iterative response variable</p>
</td></tr>
<tr><td><code id="pcat_+3A_w">w</code></td>
<td>
<p>iterative weights</p>
</td></tr>
<tr><td><code id="pcat_+3A_xeval">xeval</code></td>
<td>
<p>indicator whether to predict</p>
</td></tr>
<tr><td><code id="pcat_+3A_formula">formula</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="pcat_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="pcat_+3A_along">along</code></td>
<td>
<p>a sequence of values</p>
</td></tr> 
<tr><td><code id="pcat_+3A_...">...</code></td>
<td>
<p>for extra variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pcat()</code> is used for the fitting of the factor. The function shrinks the levels of the categorical factor (not towards the overall mean as the function <code>random()</code> is doing) but towards each other.  This results to a reduction of the number if levels of the factors.  Different norms can be used for the shrinkage by specifying the argument <code>Lp</code>.  
</p>


<h3>Value</h3>

<p>The function <code>pcat</code> reruns a vector  endowed with a number of attributes. 
The vector itself is used in the construction of the model matrix, while the attributes are needed for the backfitting algorithms additive.fit(). The backfitting is done in <code>gamlss.pcat</code>.
</p>


<h3>Note</h3>

<p>Note that <code>pcat</code> itself does no smoothing; it simply sets things up for <code>gamlss.pcat()</code> to do the smoothing within the backfitting.</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos,  Paul Eilers and Marco Enea</p>


<h3>References</h3>

<p>Tutz G. (2013) Regularization and Sparsity in Discrete Structures in the <em>Proceedings of the 29th International Workshop on Statistical Modelling</em>, Volume 1, p 29-42, Gottingen, Germany
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+random">random</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data 1
    n &lt;- 10  # number of levels 
    m &lt;- 200 # number of observations  
set.seed(2016)
level &lt;-  as.factor(floor(runif(m) * n) + 1)
  a0  &lt;-  rnorm(n)
sigma &lt;-  0.4
   mu &lt;-  a0[level]
   y &lt;-  mu + sigma * rnorm(m)
plot(y~level)
points(1:10,a0, col="red")
 da1 &lt;- data.frame(y, level)
#------------------
  mn &lt;- gamlss(y~1,data=da1 ) # null model 
  ms &lt;- gamlss(y~level-1, data=da1) # saturated model 
  m1 &lt;- gamlss(y~pcat(level), data=da1) # calculating lambda ML
AIC(mn, ms, m1)
## Not run: 
m11 &lt;- gamlss(y~pcat(level, method="GAIC", k=log(200)), data=da1) # GAIC
AIC(mn, ms, m1, m11) 
#gettng the fitted object -----------------------------------------------------
getSmo(m1)
coef(getSmo(m1))
fitted(getSmo(m1))[1:10]
plot(getSmo(m1)) # 
# After the fit a new factor is created  this factor has the reduced levels
 levels(getSmo(m1)$factor)
# -----------------------------------------------------------------------------

## End(Not run)
</code></pre>

<hr>
<h2 id='pdf.plot'>Plots Probability Distribution Functions for GAMLSS Family</h2><span id='topic+pdf.plot'></span>

<h3>Description</h3>

<p>A function to plot probability distribution functions (pdf) belonging to the gamlss family of distributions.
This function allows either plotting of the fitted distributions for up to eight observations or plotting specified distributions belonging in the gamlss family</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf.plot(obj = NULL, obs = c(1), family = NO(), mu = NULL, 
         sigma = NULL, nu = NULL, tau = NULL, from = 0, 
         to = 10, min = NULL, max = NULL, no.points = 201, 
         no.title = FALSE, col = gray(0.4), y.axis.lim = 1.1, 
         frame.plot = TRUE, ...)         
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.plot_+3A_obj">obj</code></td>
<td>
<p>An gamlss object e.g. <code>obj=model1</code> where model1 is a fitted gamlss object</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_obs">obs</code></td>
<td>
<p>A number or vector of up to length eight indicating the case numbers of the observations for which fitted distributions are to be displayed, e.g. <code>obs=c(23,58)</code> will display the fitted distribution for the 23th and 58th observations</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_family">family</code></td>
<td>
<p>This must be a gamlss family i.e. <code>family=NO</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_mu">mu</code></td>
<td>
<p>The value(s) of the location parameter mu for which the distribution has to be evaluated e.g <code>mu=c(3,7)</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_sigma">sigma</code></td>
<td>
<p>The value(s) the scale parameter sigma for which the distribution has to be evaluated e.g <code>sigma=c(3,7)</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_nu">nu</code></td>
<td>
<p>The value(s) the parameter nu for which the distribution has to be evaluated e.g. <code>nu=3</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_tau">tau</code></td>
<td>
<p>The value(s) the parameter tau for which the distribution has be evaluated e.g. <code>tau=5</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_from">from</code></td>
<td>
<p>Minimum value of the random variable y (identical to <code>min</code>)</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_to">to</code></td>
<td>
<p>Maximum value of the random variable y(identical to <code>max</code>)</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_min">min</code></td>
<td>
<p>Minimum value of the random variable y e.g. <code>min=0</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_max">max</code></td>
<td>
<p>Maximum value of y e.g. <code>max=10</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_no.points">no.points</code></td>
<td>
<p>the number fo point in which the function will be evaluated</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_no.title">no.title</code></td>
<td>
<p>Whether you need title in the plot, default is  <code>no.title=FALSE</code></p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_col">col</code></td>
<td>
<p>the colot of the lines</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_y.axis.lim">y.axis.lim</code></td>
<td>
<p>the limits for the y-axis</p>
</td></tr>
<tr><td><code id="pdf.plot_+3A_frame.plot">frame.plot</code></td>
<td>
<p>whether to frame the individual plots</p>
</td></tr> 
<tr><td><code id="pdf.plot_+3A_...">...</code></td>
<td>
<p>for extra arguments, Note that a  useful argument can be <code>col.axis</code>, <code>col.lab</code>, <code>cex.axis</code>, <code>cex.lab</code> etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to plot distributions of the GAMLSS family. 
If the first argument <code>obj</code> is specified and it is a GAMLSS fitted object, then the fitted distribution of this model 
at specified observation values (given by the second argument <code>obs</code>) is  plotted for a specified y-variable range (arguments 
<code>min</code>, <code>max</code>, and <code>step</code>).
</p>
<p>If the first argument is not given then the <code>family</code> argument has to be specified and the pdf is plotted at specified values of the parameters 
<code>mu</code>, <code>sigma</code>, <code>nu</code>, <code>tau</code>. Again the range of the y-variable has to be given.   
</p>


<h3>Value</h3>

<p>plot(s) of the required pdf(s) are returned </p>


<h3>Warning</h3>

<p>The range of some distributions depends on the fitted parameters</p>


<h3>Note</h3>

<p>The range of the y values given by min, max and step are very important in the plot</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Calliope Akantziliotou</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf.plot(family=BCT, min=1, max=20, mu=10, sigma=0.15, nu=-1, tau=c(4,10,20,40) )
## Not run: 
# now using an gamlss object
data(abdom)
h&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom) # fits 
pdf.plot(obj=h , obs=c(23,67), min=50, max=150)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.gamlss'>Plot Residual Diagnostics for an GAMLSS Object</h2><span id='topic+plot.gamlss'></span>

<h3>Description</h3>

<p>This function provides four plots for checking the normalized (randomized for a discrete response distribution) quantile 
residuals of a fitted GAMLSS object, referred to as residuals below : a plot of residuals against fitted values, a plot of the residuals against 
an index or a specific explanatory variable,  a density plot of the residuals and a normal Q-Q plot of the residuals.
If argument <code>ts=TRUE</code> then the first two plots are replaced by the autocorrelation function (ACF) and partial autocorrelation function (PACF)
of the residuals 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
plot(x, xvar = NULL, parameters = NULL, ts = FALSE, 
           summaries = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gamlss_+3A_x">x</code></td>
<td>
<p>a GAMLSS fitted object </p>
</td></tr>
<tr><td><code id="plot.gamlss_+3A_xvar">xvar</code></td>
<td>
<p>an explanatory variable to plot the residuals against</p>
</td></tr>
<tr><td><code id="plot.gamlss_+3A_parameters">parameters</code></td>
<td>
<p>plotting parameters can be specified here</p>
</td></tr>
<tr><td><code id="plot.gamlss_+3A_ts">ts</code></td>
<td>
<p>set this to TRUE if ACF and PACF plots of the residuals are required </p>
</td></tr>
<tr><td><code id="plot.gamlss_+3A_summaries">summaries</code></td>
<td>
<p>set this to FALSE if no summary statistics of the residuals are required</p>
</td></tr>
<tr><td><code id="plot.gamlss_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides four plots for checking the normalized (randomized) quantile residuals (called <code>residuals</code>) of a fitted GAMLSS object. 
Randomization is only performed for discrete response variables.  The four plots are 
</p>
 
<ul>
<li><p> residuals against the fitted values (or ACF of the residuals if <code>ts=TRUE</code>)
</p>
</li>
<li><p> residuals against an index or specified x-variable (or PACF of the residuals if <code>ts=TRUE</code>)
</p>
</li>
<li><p> kernel density estimate of the residuals 
</p>
</li>
<li><p> QQ-normal plot of the residuals 
</p>
</li></ul>

<p>For time series response variables option <code>ts=TRUE</code> can be used to plot the ACF and PACF functions of the residuals. 
</p>


<h3>Value</h3>

<p>Returns four plots related to the residuals of the fitted GAMLSS model and prints summary statistics for the residuals if the <code>summary=T</code>
</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby  and Kalliope Akantziliotou </p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(aids)
a&lt;-gamlss(y~pb(x)+qrt,family=PO,data=aids)
plot(a)
rm(a)
</code></pre>

<hr>
<h2 id='plot.histSmo'>
A Plotting Function for density estimator object histSmo 
</h2><span id='topic+plot.histSmo'></span>

<h3>Description</h3>

<p>Plots the estimated density or its c.d.f function or its inverse cdf function  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'histSmo'
plot(x, type = c("hist", "cdf", "invcdf"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.histSmo_+3A_x">x</code></td>
<td>
<p>An histSmo object</p>
</td></tr>
<tr><td><code id="plot.histSmo_+3A_type">type</code></td>
<td>
<p>Different plots: a histogram and density estimator, a cdf function or an inverse cdf function. 
</p>
</td></tr>
<tr><td><code id="plot.histSmo_+3A_...">...</code></td>
<td>

<p>for further arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the relevant plot
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Paul Eilers, Bob Rigby, Vlasios Voudouris and Majid  Djennad
</p>


<h3>References</h3>

<p>Eilers, P. (2003). A perfect smoother. <em>Analytical Chemistry</em>, 75: 3631-3636.
</p>
<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>,
<b>11</b>, 89-121.
</p>
<p>Lindsey, J.K. (1997) <em>Applying Generalized Linear Models</em>. New York: Springer-Verlag. 
ISBN 0-387-98218-3 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+histSmo">histSmo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rPARETO2(1000) 
m1&lt;- histSmo(Y, lower=0, save=TRUE)
plot(m1)
plot(m1, "cdf")
plot(m1, "invcdf")
</code></pre>

<hr>
<h2 id='plot2way'>
Function to plot two interaction in a GAMLSS model
</h2><span id='topic+plot2way'></span>

<h3>Description</h3>

<p>This function is designed to plot a factor to factor interaction in a GAMLSS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2way(obj, terms = list(), what = c("mu", "sigma", "nu", "tau"), 
        parameter= NULL, show.legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2way_+3A_obj">obj</code></td>
<td>
<p>A gamlss model
</p>
</td></tr>
<tr><td><code id="plot2way_+3A_terms">terms</code></td>
<td>
<p>this should be a character vector with the names of the two factors to be plotted</p>
</td></tr>
<tr><td><code id="plot2way_+3A_what">what</code></td>
<td>
<p>which parameters? <code>mu</code>, <code>sigma</code>, <code>nu</code>, or <code>tau</code> </p>
</td></tr>
<tr><td><code id="plot2way_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="plot2way_+3A_show.legend">show.legend</code></td>
<td>

<p>whether to show the legend in the two way plot 
</p>
</td></tr>
<tr><td><code id="plot2way_+3A_...">...</code></td>
<td>
<p>Further arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an experimental function which should be use with prudence since no other check is done on whether this interaction interfere with other terms in the model
</p>


<h3>Value</h3>

<p>The function creates a 2 way interaction plot 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+term.plot">term.plot</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
ti &lt;- factor(c(rep(1,18),rep(2,27))) 
m1 &lt;- gamlss(y~x+qrt*ti, data=aids, family=NBI)
m2 &lt;- gamlss(y~x+qrt*ti, data=aids, family=NO)
plot2way(m1, c("qrt","ti")) 
plot2way(m1, c("ti", "qrt"))
</code></pre>

<hr>
<h2 id='polyS'>Auxiliary support for the GAMLSS</h2><span id='topic+polyS'></span><span id='topic+poly.matrix'></span>

<h3>Description</h3>

<p>These two functions are similar to the <code>poly</code> and <code>polym</code> in R. 
Are needed for the <code>gamlss.lo</code> function of GAMLSS and should not be used on their own.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyS(x, ...)
poly.matrix(m, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyS_+3A_x">x</code></td>
<td>
<p>a variable</p>
</td></tr>
<tr><td><code id="polyS_+3A_m">m</code></td>
<td>
<p>a variable </p>
</td></tr>
<tr><td><code id="polyS_+3A_degree">degree</code></td>
<td>
<p>the degree of the polynomial</p>
</td></tr>
<tr><td><code id="polyS_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of orthogonal polynomials
</p>


<h3>Warning </h3>

<p>Not be use by the user</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+gamlss.lo">gamlss.lo</a></code> </p>

<hr>
<h2 id='predict.gamlss'>Extract Predictor Values and Standard Errors For New Data In a GAMLSS Model </h2><span id='topic+predict.gamlss'></span><span id='topic+predictAll'></span>

<h3>Description</h3>

<p><code>predict.gamlss</code> is the GAMLSS specific method which produce predictors for a new data set   
for a specified parameter from a GAMLSS objects.  
The <code>predict.gamlss</code> can be used to extract the linear predictors, fitted values and specific  terms in the model at new 
data values in the same way that the <code>predict.lm()</code> and <code>predict.glm()</code> functions can be used for 
<code>lm</code> or <code>glm</code> objects. Note that linear predictors, fitted values and specific terms in the model at the current  
data values can also be extracted using the function <code>lpred()</code> (which is called from predict if new data is NULL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
predict(object, what = c("mu", "sigma", "nu", "tau"), 
                parameter= NULL,
                newdata = NULL, type = c("link", "response", "terms"), 
                terms = NULL, se.fit = FALSE, data = NULL, ...)
predictAll(object, newdata = NULL, type = c("response", "link", "terms"), 
                terms = NULL, se.fit = FALSE, use.weights = FALSE, 
                data = NULL, y.value = "median", 
                set.to = .Machine$double.xmin,
                  output = c("list","data.frame", "matrix"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_what">what</code></td>
<td>
<p> which distribution parameter is required, default <code>what="mu"</code></p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing new values for the explanatory variables used in the model</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_type">type</code></td>
<td>
<p>the default, gets the linear predictor for the specified distribution parameter. 
<code>type="response"</code> gets the fitted values for the parameter while <code>type="terms"</code> gets the fitted terms contribution</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_terms">terms</code></td>
<td>
<p>if <code>type="terms"</code>, which terms to be selected (default is all terms)</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_se.fit">se.fit</code></td>
<td>
<p>if TRUE the approximate standard errors of the appropriate type are extracted if exist</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_use.weights">use.weights</code></td>
<td>
<p>if <code>use.weights=TRUE</code> the old data and the <code>newdata</code> are merged and the model is refitted with weights equal to the prior weights for the old data  observational and   equal to a very small value (see option <code>set.to</code>) for the .<code>newdata</code> values. This trick allows to obtain standard errors for all parameters</p>
</td></tr> 
<tr><td><code id="predict.gamlss_+3A_data">data</code></td>
<td>
<p> the data frame used in the original fit if is not defined in the call</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_y.value">y.value</code></td>
<td>
<p>how to get  the response values for the <code>newdata</code> if they do not exist. The default is taking the median, <code>y.value="median"</code>. Other function like &quot;max&quot;, &quot;min&quot; are allowed. Also numerical values.</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_set.to">set.to</code></td>
<td>
<p>what values the weights for the <code>newdata</code> should take</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_output">output</code></td>
<td>
<p>whether the output to be a &lsquo;list&rsquo; (default) or a 'matrix'</p>
</td></tr>
<tr><td><code id="predict.gamlss_+3A_...">...</code></td>
<td>
<p> for extra arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predict function  assumes that the object given in <code>newdata</code> is a data frame containing the right x-variables
used in the model. This could possible cause problems if transformed variables are used in the fitting of the original model.
For example, let us assume that a transformation of age is needed in the model i.e. <code>nage&lt;-age^.5</code>. This could be fitted as 
<code>mod&lt;-gamlss(y~cs(age^.5),data=mydata)</code> or as  <code>nage&lt;-age^.5;  mod&lt;-gamlss(y~cs(nage), data=mydata)</code>.
The later could more efficient if the data are in thousands rather in hundreds. In the first case,   
the code <code>predict(mod,newdata=data.frame(age=c(34,56)))</code> would produce the right results.  
In the second case a new data frame has to be created containing the old data plus any new transform data. This data frame has to 
be declared in the <code>data</code> option. The option <code>newdata</code> should 
contain a data.frame with the new names and the transformed values in which prediction is required, (see the last example). </p>


<h3>Value</h3>

<p>A vector or a matrix  depending on the options. 
</p>


<h3>Note</h3>

<p> This function is under development</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos </p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+lp">lp</a></code>,  <code><a href="#topic+lpred">lpred</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
a&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
newaids&lt;-data.frame(x=c(45,46,47), qrt=c(2,3,4))
ap &lt;- predict(a, newdata=newaids, type = "response")
ap
# now getting all the parameters
predictAll(a, newdata=newaids)
rm(a, ap)
data(abdom)
# transform x 
aa&lt;-gamlss(y~cs(x^.5),data=abdom)
# predict at old values
predict(aa)[610]
# predict at new values 
predict(aa,newdata=data.frame(x=42.43))
# now transform x first 
nx&lt;-abdom$x^.5
aaa&lt;-gamlss(y~cs(nx),data=abdom)
# create a new data frame 
newd&lt;-data.frame( abdom, nx=abdom$x^0.5)
# predict at old values
predict(aaa)[610]
# predict at new values 
predict(aaa,newdata=data.frame(nx=42.43^.5), data=newd)
</code></pre>

<hr>
<h2 id='print.gamlss'> Prints a GAMLSS fitted model </h2><span id='topic+print.gamlss'></span>

<h3>Description</h3>

<p><code>print.gamlss</code> is the GAMLSS specific method for the generic function <code>print</code> which prints 
objects returned by modelling functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gamlss_+3A_x">x</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="print.gamlss_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing </p>
</td></tr>
<tr><td><code id="print.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a gamlss object</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby  and Calliope Akantziliotou </p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) 
print(h) # or just h
rm(h)
</code></pre>

<hr>
<h2 id='prodist.gamlss'>Extracting Fitted or Predicted Probability Distributions from gamlss Models</h2><span id='topic+prodist.gamlss'></span>

<h3>Description</h3>

<p>Methods for <span class="pkg">gamlss</span> model objects for extracting fitted (in-sample) or
predicted (out-of-sample) probability distributions as <span class="pkg">distributions3</span>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
prodist(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodist.gamlss_+3A_object">object</code></td>
<td>
<p>A model object of class <code><a href="#topic+gamlss">gamlss</a></code>.</p>
</td></tr>
<tr><td><code id="prodist.gamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+predictAll">predictAll</a></code>, e.g., <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To facilitate making probabilistic forecasts based on <code><a href="#topic+gamlss">gamlss</a></code>
model objects, the <code><a href="distributions3.html#topic+prodist">prodist</a></code> method extracts fitted
or predicted probability <code>distribution</code> objects. Internally, the
<code><a href="#topic+predictAll">predictAll</a></code> method is used first to obtain the distribution
parameters (<code>mu</code>, <code>sigma</code>, <code>tau</code>, <code>nu</code>, or a subset thereof).
Subsequently, the corresponding <code>distribution</code> object is set up using the
<code><a href="gamlss.dist.html#topic+GAMLSS">GAMLSS</a></code> class from the <span class="pkg">gamlss.dist</span> package,
enabling the workflow provided by the <span class="pkg">distributions3</span> package (see Zeileis
et al. 2022).
</p>
<p>Note that these probability distributions only reflect the random variation in
the dependent variable based on the model employed (and its associated
distributional assumption for the dependent variable). This does not capture the
uncertainty in the parameter estimates.
</p>


<h3>Value</h3>

<p>An object of class <code>GAMLSS</code> inheriting from <code>distribution</code>.
</p>


<h3>References</h3>

<p>Zeileis A, Lang MN, Hayes A (2022).
&ldquo;distributions3: From Basic Probability to Probabilistic Regression.&rdquo;
Presented at <em>useR! 2022 - The R User Conference</em>.
Slides, video, vignette, code at <a href="https://www.zeileis.org/news/user2022/">https://www.zeileis.org/news/user2022/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.dist.html#topic+GAMLSS">GAMLSS</a></code>, <code><a href="#topic+predictAll">predictAll</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## packages, code, and data
library("gamlss")
library("distributions3")
data("cars", package = "datasets")

## fit heteroscedastic normal GAMLSS model
## stopping distance (ft) explained by speed (mph)
m &lt;- gamlss(dist ~ pb(speed), ~ pb(speed), data = cars, family = "NO")

## obtain predicted distributions for three levels of speed
d &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))
print(d)

## obtain quantiles (works the same for any distribution object 'd' !)
quantile(d, 0.5)
quantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)
quantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)

## visualization
plot(dist ~ speed, data = cars)
nd &lt;- data.frame(speed = 0:240/4)
nd$dist &lt;- prodist(m, newdata = nd)
nd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))
matplot(nd$speed, nd$fit, type = "l", lty = 1, col = "slategray", add = TRUE)

## moments
mean(d)
variance(d)

## simulate random numbers
random(d, 5)

## density and distribution
pdf(d, 50 * -2:2)
cdf(d, 50 * -2:2)

## Poisson example
data("FIFA2018", package = "distributions3")
m2 &lt;- gamlss(goals ~ pb(difference), data = FIFA2018, family = "PO")
d2 &lt;- prodist(m2, newdata = data.frame(difference = 0))
print(d2)
quantile(d2, c(0.05, 0.5, 0.95))

## note that log_pdf() can replicate logLik() value
sum(log_pdf(prodist(m2), FIFA2018$goals))
logLik(m2)
</code></pre>

<hr>
<h2 id='prof.dev'>Plotting the Profile Deviance for one of the Parameters in a GAMLSS model</h2><span id='topic+prof.dev'></span>

<h3>Description</h3>

<p>This functions plots the profile deviance of one of the (four) parameters in a GAMLSS model. It can be used if one 
of the parameters <code>mu</code>, <code>sigma</code>, <code>nu</code> or <code>tau</code> is a constant (not a function of explanatory variables) to obtain 
a profile confidence intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof.dev(object, which = NULL, min = NULL, max = NULL, 
        step = NULL, length = 7, startlastfit = TRUE, 
        plot = TRUE, perc = 95, col="darkgreen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof.dev_+3A_object">object</code></td>
<td>
<p>A fitted GAMLSS model</p>
</td></tr>
<tr><td><code id="prof.dev_+3A_which">which</code></td>
<td>
<p>which parameter to  get the profile deviance e.g. <code>which="tau"</code></p>
</td></tr>
<tr><td><code id="prof.dev_+3A_min">min</code></td>
<td>
<p>the minimum value for the parameter e.g. <code>min=1</code></p>
</td></tr>
<tr><td><code id="prof.dev_+3A_max">max</code></td>
<td>
<p>the maximum value for the parameter e.g.  <code>max=20</code></p>
</td></tr>
<tr><td><code id="prof.dev_+3A_step">step</code></td>
<td>
<p>how often to evaluate the global deviance (defines the step length of the grid for the parameter) e.g. <code>step=1</code> </p>
</td></tr>
<tr><td><code id="prof.dev_+3A_length">length</code></td>
<td>
<p>the length if step is not set, default equal 7</p>
</td></tr>
<tr><td><code id="prof.dev_+3A_startlastfit">startlastfit</code></td>
<td>
<p>whether to start fitting from the last fit or not, default value is <code>startlastfit=TRUE</code>  </p>
</td></tr>
<tr><td><code id="prof.dev_+3A_plot">plot</code></td>
<td>
<p>whether to plot, <code>plot=TRUE</code> or save the results, <code>plot=FALSE</code>  </p>
</td></tr>
<tr><td><code id="prof.dev_+3A_perc">perc</code></td>
<td>
<p>what % confidence interval is required </p>
</td></tr>
<tr><td><code id="prof.dev_+3A_col">col</code></td>
<td>
<p>The colour of the profile line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be use to provide likelihood based confidence intervals for a parameter for which a constant model (i.e. no explanatory model) is fitted and
consequently for checking the adequacy of a particular values of the parameter. This can be used to check the adequacy of one distribution (e.g. Box-Cox Cole and Green) 
nested within another (e.g. Box-Cox power exponential). For example one can test whether a Box-Cox Cole and Green (Box-Cox-normal) distribution 
or a Box-Cox power exponential is appropriate by plotting the profile of the parameter <code>tau</code>. 
A profile deviance showing support for  <code>tau=2</code> indicates adequacy of the Box-Cox Cole and Green (i.e. Box-Cox normal) distribution.      
</p>


<h3>Value</h3>

<p>Return a profile plot (if the argument <code>plot=TRUE</code>) and an <code>ProfLikelihood.gamlss</code> object if saved.  The object contains:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>the values at the grid where the parameter was evaluated</p>
</td></tr>
<tr><td><code>fun</code></td>
<td>
<p>the function which approximates the points using splines</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum values in the grid</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>te maximum values in the grid</p>
</td></tr>
<tr><td><code>max.value</code></td>
<td>
<p>the value of the parameter maximising the Profile deviance (or GAIC) </p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>the profile confidence interval (if global deviance is used)</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>which criterion was used</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>A dense grid (i.e. small step) evaluation of the global deviance can take a long time, so start with a sparse grid (i.e. large step) 
and decrease  gradually the step length for more accuracy. </p>


<h3>Author(s)</h3>

<p>Calliope Akantziliotou, Mikis Stasinopoulos and Bob Rigby</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>,  <code><a href="#topic+prof.term">prof.term</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(abdom)
h&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom) 
prof.dev(h,"nu",min=-2.000,max=2)
rm(h)
## End(Not run)
</code></pre>

<hr>
<h2 id='prof.term'>Plotting the Profile: deviance or information criterion for one of the terms (or hyper-parameters) in a GAMLSS model </h2><span id='topic+prof.term'></span>

<h3>Description</h3>

<p>This functions plots the profile deviance for a chosen parameter included in the linear predictor of any of the <code>mu</code>,<code>sigma</code>, <code>nu</code> or <code>tau</code> models so profile confidence intervals can be obtained. In can also be used to plot the profile of a specified information criterion for any hyper-parameter when smooth additive terms are used.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof.term(model = NULL, criterion = c("GD", "GAIC"), penalty = 2.5, 
          other = NULL, min = NULL, max = NULL, step = NULL, 
          length = 7, xlabel = NULL, plot = TRUE, perc = 95, 
          start.prev = TRUE, col="darkgreen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof.term_+3A_model">model</code></td>
<td>
<p>this is a GAMLSS model, e.g. <br />
<code>model=gamlss(y~cs(x,df=this),sigma.fo=~cs(x,df=3),data=abdom)</code>, where <code>this</code> indicates the (hyper)parameter to be profiled</p>
</td></tr>
<tr><td><code id="prof.term_+3A_criterion">criterion</code></td>
<td>
<p>whether global deviance (&quot;GD&quot;) or information criterion (&quot;GAIC&quot;) is profiled. The default is global deviance <code>criterion="GD"</code></p>
</td></tr>
<tr><td><code id="prof.term_+3A_penalty">penalty</code></td>
<td>
<p> The penalty value if information criterion is used in <code>criterion</code>, default <code>penalty=2.5</code>  </p>
</td></tr>
<tr><td><code id="prof.term_+3A_other">other</code></td>
<td>
<p>this can be used to evaluate an expression before the actual fitting of the model (Make sure that those expressions are well define in the global environment)</p>
</td></tr>
<tr><td><code id="prof.term_+3A_min">min</code></td>
<td>
<p>the minimum value for the parameter e.g. <code>min=1</code> </p>
</td></tr>
<tr><td><code id="prof.term_+3A_max">max</code></td>
<td>
<p>the maximum value for the parameter e.g.  <code>max=20</code></p>
</td></tr>
<tr><td><code id="prof.term_+3A_step">step</code></td>
<td>
<p>how often to evaluate the global deviance (defines the step length of the grid for the parameter) e.g. <code>step=1</code></p>
</td></tr>
<tr><td><code id="prof.term_+3A_length">length</code></td>
<td>
<p>if the step is left NULL then <code>length</code> is considered for evaluating the grid for the parameter. It has a default value of 11</p>
</td></tr>
<tr><td><code id="prof.term_+3A_xlabel">xlabel</code></td>
<td>
<p>if a label for the axis is required </p>
</td></tr>
<tr><td><code id="prof.term_+3A_plot">plot</code></td>
<td>
<p>whether to plot, <code>plot=TRUE</code> the resulting profile deviance (or GAIC)</p>
</td></tr>
<tr><td><code id="prof.term_+3A_perc">perc</code></td>
<td>
<p>what % confidence interval is required</p>
</td></tr>
<tr><td><code id="prof.term_+3A_start.prev">start.prev</code></td>
<td>
<p>whether to start from the previous fitted model parameters values or not (default is TRUE)</p>
</td></tr>
<tr><td><code id="prof.term_+3A_col">col</code></td>
<td>
<p>the color of the profile line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be use to provide likelihood based confidence intervals for a parameter involved in terms in the linear predictor(s). 
These confidence intervals are more accurate than the ones obtained from the parameters' standard errors. 
The function can also be used to plot a profile information criterion (with a given penalty) against a hyper-parameter. This can be used to check the uniqueness in hyper-parameter determination using for example <code>find.df</code>. 
</p>


<h3>Value</h3>

<p>Return a profile plot (if the argument <code>plot=TRUE</code>) and an <code>ProfLikelihood.gamlss</code> object if saved.  The object contains:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>the values at the grid where the parameter was evaluated</p>
</td></tr>
<tr><td><code>fun</code></td>
<td>
<p>the function which approximates the points using splines</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum values in the grid</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum values in the grid</p>
</td></tr>
<tr><td><code>max.value</code></td>
<td>
<p>the value of the parameter maximising the Profile deviance (or GAIC) </p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>the profile confidence interval (if global deviance is used)</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>which criterion was used</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>A dense grid (i.e. small step) evaluation of the global deviance can take a long time, so start with a sparse grid (i.e. large step) 
and decrease  gradually the step length for more accuracy. </p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos and Bob Rigby</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>,  <code><a href="#topic+prof.dev">prof.dev</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
# fitting a linear model
gamlss(y~x+qrt,family=NBI,data=aids)
# testing the linear beta parameter
mod&lt;-quote(gamlss(y ~ offset(this * x) + qrt, data = aids, family = NBI))
prof.term(mod, min=0.06, max=0.11)
# find the hyper parameter using cubic splines smoothing
mod1&lt;-quote(gamlss(y ~ cs(x,df=this) + qrt, data = aids, family = NBI))
prof.term(mod1, min=1, max=15, step=1, criterion="GAIC", penalty=log(45))
# find a break point in x
mod2 &lt;- quote(gamlss(y ~ x+I((x&gt;this)*(x-this))+qrt,family=NBI,data=aids))
prof.term(mod2, min=1, max=45, step=1, criterion="GD")
rm(mod,mod1,mod2)
</code></pre>

<hr>
<h2 id='ps'>P-Splines Fits in a GAMLSS Formula</h2><span id='topic+ps'></span><span id='topic+pb'></span><span id='topic+pbo'></span><span id='topic+pbp'></span><span id='topic+pbc'></span><span id='topic+pbc.control'></span><span id='topic+pb.control'></span><span id='topic+pbo.control'></span><span id='topic+pbp.control'></span><span id='topic+pvc'></span><span id='topic+pvc.control'></span><span id='topic+cy'></span><span id='topic+cy.control'></span><span id='topic+pbm'></span><span id='topic+pbm.control'></span><span id='topic+pbz'></span><span id='topic+pbz.control'></span><span id='topic+getZmatrix'></span><span id='topic+.hat.WX'></span>

<h3>Description</h3>

<p>There are several function which use P-spline methodology:
</p>
<p>a) <code>pb()</code>, the current version of P-splines which uses SVD in the fitting and therefore is the most reliable 
</p>
<p>b) <code>pbo()</code> and <code>pbp()</code>, older versions of P-splines. The first  uses a simple matrix algebra in the fits. The second is the last version of <code>pb()</code> with SVD  but uses different method  for prediction.
</p>
<p>c) <code>pbc()</code> the new version of cycle P-splines (using SVD)
</p>
<p>d) <code>cy()</code> the older version of cycle P-splines.
</p>
<p>e) <code>pbm()</code> for fitting monotonic  P-splines (using SVD)
</p>
<p>f) <code>pbz()</code> for fitting  P-splines which allow the fitted curve to shrink to zero degrees of freedom 
</p>
<p>g) <code>ps()</code> the original P-splines with no facility of estimating the smoothing parameters and 
</p>
<p>j) <code>pvc()</code> penalised varying coefficient models.
</p>
<p>k) <code>pvp()</code> older version of pb() where the prediction was different (it is here in case someone would like to compare the results).
</p>
<p>Theoretical explanation of the above P-splines can be found in Eilers <em>et al.</em> (2016)
</p>
<p>The functions take a vector and return it with several attributes. The vector is used in the construction of the design matrix X used in the fitting. The functions do not do the  smoothing, but assign the attributes to the vector to aid gamlss in the smoothing. The functions doing the smoothing are   <code><a href="#topic+gamlss.pb">gamlss.pb</a>()</code>, <code><a href="#topic+gamlss.pbo">gamlss.pbo</a>()</code>, <code><a href="#topic+gamlss.pbc">gamlss.pbc</a>()</code>  <code><a href="#topic+gamlss.cy">gamlss.cy</a>()</code>  <code><a href="#topic+gamlss.pvc">gamlss.pvc</a>()</code>,  <code><a href="#topic+gamlss.pbm">gamlss.pbm</a>()</code>, <code><a href="#topic+gamlss.pbz">gamlss.pbz</a></code> and <code><a href="#topic+gamlss.ps">gamlss.ps</a>()</code> which are used in the backfitting  function <code><a href="#topic+additive.fit">additive.fit</a></code>.
</p>
<p>The function <code>pb()</code> is more efficient and faster than the original penalised smoothing function <code>ps()</code>. After December 2014 the  <code>pb()</code> has changed radically to improved performance. The older version of the <code>pb()</code> function is called now <code>pbo()</code>. 
<code>pb()</code> allows the estimation of the smoothing parameters using different local (performance iterations) methods. The method are &quot;ML&quot;, &quot;ML-1&quot;, &quot;EM&quot;, &quot;GAIC&quot; and &quot;GCV&quot;. 
</p>
<p>The function <code>pbm()</code> fits monotonic smooth functions, that is functions which increase or decrease monotonically depending on the value of the argument <code>mono</code> which takes the values <code>"up"</code> or <code>"down"</code>.
</p>
<p>The function <code>pbz()</code> is similar to <code>pb()</code> with the extra property that when lambda becomes very large the resulting smooth function  goes to a constant rather than to a linear function. This is very useful for model selection. The function is based on Maria Durban idea of using a double penalty, one of order 2 and one of order 1. The second penalty only applies if the effective df are close to 2 (that is if a linear is already selected). 
</p>
<p>The function <code>pbc()</code> fits a cycle penalised beta regression spline such as  the last fitted value of the smoother is equal to the first fitted value. <code>cy()</code> is the older version.
</p>
<p>The function <code>pvc()</code> fits  varying coefficient models see Hastie and Tibshirani(1993) and it is more general and flexible than the old <code>vc()</code> function which was based on cubic splines.
</p>
<p>The function <code>getZmatrix()</code> creates a (random effect) design matrix <code>Z</code> which can be  used to fit a P-splines smoother using the <code>re())</code> function. (The <code>re()</code>  is an interface with the random effect function <code>lme</code> of the package <span class="pkg">nlme</span>. 
</p>
<p>The function <code>.hat.WX()</code> is for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pb(x, df = NULL, lambda = NULL, max.df=NULL, 
    control = pb.control(...), ...)
pbo(x, df = NULL, lambda = NULL, control = pbo.control(...), ...)
pbp(x, df = NULL, lambda = NULL, control = pbp.control(...), ...)
pbo.control(inter = 20, degree = 3, order = 2, start = 10, quantiles = FALSE, 
               method = c("ML", "GAIC", "GCV", "EM", "ML-1"), k = 2, ...)
pb.control(inter = 20, degree = 3, order = 2, start = 10, quantiles = FALSE, 
          method = c("ML", "GAIC", "GCV"), k = 2, ...)
pbp.control(inter = 20, degree = 3, order = 2, start = 10, quantiles = FALSE, 
          method = c("ML", "GAIC", "GCV"), k = 2, ...)
pbc(x,  df = NULL, lambda = NULL, max.df=NULL, 
    control = pbc.control(...), ...)
pbc.control(inter = 20, degree = 3, order = 2, start = 10, 
          method = c("ML", "GAIC", "GCV"), k = 2, sin = TRUE, ...)
cy(x, df = NULL, lambda = NULL, control = cy.control(...), ...)
cy.control(inter = 20, degree = 3, order = 2, start = 10, 
          method = c("ML", "GAIC", "GCV", "EM", "ML-1"), k = 2, ts=FALSE, ...)
pvc(x, df = NULL, lambda = NULL, by = NULL, control = pvc.control(...), ...)          
pvc.control(inter = 20, degree = 3, order = 2, start = 10, quantiles = FALSE, 
             method = c("ML", "GAIC", "GCV"), k = 2, ...) 
pbm(x, df = NULL, lambda = NULL, mono=c("up", "down"), 
            control = pbm.control(...), ...)
pbm.control(inter = 20, degree = 3, order = 2, start = 10, quantiles = FALSE, 
            method=c("ML","GAIC", "GCV"), k=2, kappa = 1e10, ...)
pbz(x, df = NULL, lambda = NULL, control = pbz.control(...), ...)
pbz.control(inter = 20, degree = 3, order = 2, start = c(1e-04, 1e-04), 
     quantiles = FALSE, method = c("ML", "GAIC", "GCV"), k = 2, lim = 3, ...)

ps(x, df = 3, lambda = NULL, ps.intervals = 20, degree = 3, order = 3)

getZmatrix(x, xmin = NULL, xmax = NULL, inter = 20, degree = 3, order = 2)

.hat.WX(w, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_+3A_x">x</code></td>
<td>
<p>the univariate predictor</p>
</td></tr>
<tr><td><code id="ps_+3A_df">df</code></td>
<td>
<p>the desired equivalent number of degrees of freedom (trace of the smoother matrix minus two for the constant and linear fit)</p>
</td></tr>
<tr><td><code id="ps_+3A_lambda">lambda</code></td>
<td>
<p>the smoothing parameter</p>
</td></tr>
<tr><td><code id="ps_+3A_max.df">max.df</code></td>
<td>
<p>the limit of how large the effective degrees of freedom should be allowed to be</p>
</td></tr>
<tr><td><code id="ps_+3A_control">control</code></td>
<td>
<p>setting the control parameters</p>
</td></tr>
<tr><td><code id="ps_+3A_by">by</code></td>
<td>
<p>a factor, for fitting different smoothing curves to each level of the factor or a continuous explanatory variable in which case  
the coefficients of the <code>by</code> variable change smoothly according to <code>x</code> i.e. beta(x)*z where z is the <code>by</code> variable. </p>
</td></tr>
<tr><td><code id="ps_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
<tr><td><code id="ps_+3A_inter">inter</code></td>
<td>
<p>the no of break points (knots) in the x-axis</p>
</td></tr>
<tr><td><code id="ps_+3A_degree">degree</code></td>
<td>
<p>the degree of the piecewise polynomial</p>
</td></tr>
<tr><td><code id="ps_+3A_order">order</code></td>
<td>
<p>the required difference in the vector of coefficients</p>
</td></tr>
<tr><td><code id="ps_+3A_start">start</code></td>
<td>
<p>the lambda starting value if the local methods are used, see below</p>
</td></tr>
<tr><td><code id="ps_+3A_quantiles">quantiles</code></td>
<td>
<p>if TRUE the quantile values of x are use to determine the knots</p>
</td></tr> 
<tr><td><code id="ps_+3A_ts">ts</code></td>
<td>
<p>if TRUE assumes that it is a seasonal factor</p>
</td></tr> 
<tr><td><code id="ps_+3A_method">method</code></td>
<td>
<p>The method used in the (local) performance iterations. Available methods are &quot;ML&quot;, &quot;ML-1&quot;, &quot;EM&quot;, &quot;GAIC&quot; and &quot;GCV&quot;</p>
</td></tr>
<tr><td><code id="ps_+3A_k">k</code></td>
<td>
<p>the penalty used in &quot;GAIC&quot; and &quot;GCV&quot;</p>
</td></tr>
<tr><td><code id="ps_+3A_mono">mono</code></td>
<td>
<p>for monotonic P-splines whether going &quot;up&quot;  or &quot;down&quot;</p>
</td></tr>
<tr><td><code id="ps_+3A_kappa">kappa</code></td>
<td>
<p>the smoothing hyper-parameter for the monotonic part of smoothing</p>
</td></tr>
<tr><td><code id="ps_+3A_ps.intervals">ps.intervals</code></td>
<td>
<p>the no of break points in the x-axis</p>
</td></tr>
<tr><td><code id="ps_+3A_xmin">xmin</code></td>
<td>
<p>minimum value for creating the B-spline</p>
</td></tr>
<tr><td><code id="ps_+3A_xmax">xmax</code></td>
<td>
<p>maximum value for creating the B-spline</p>
</td></tr>
<tr><td><code id="ps_+3A_sin">sin</code></td>
<td>
<p>whether to use the sin penalty or not</p>
</td></tr>
<tr><td><code id="ps_+3A_lim">lim</code></td>
<td>
<p>at which level the second penalty of order 1 should start</p>
</td></tr>
<tr><td><code id="ps_+3A_w">w</code></td>
<td>
<p>iterative weights only for function <code>.hat.WX</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ps()</code> function is based on Brian Marx function which can be found in his website.
The <code>pb()</code>, <code>cy()</code>, <code>pvc()</code> and  <code>pbm()</code> functions are based on Paul Eilers's original R functions. 
Note that  <code>ps()</code> and  <code>pb()</code> functions behave differently at their default values if df and lambda are not specified.
<code>ps(x)</code> by default  uses 3 extra degrees of freedom for smoothing <code>x</code>.
<code>pb(x)</code> by default  estimates lambda (and therefore the degrees of freedom) automatically using a &quot;local&quot; method.
The local (or performance iterations) methods available are: 
(i) local Maximum Likelihood, &quot;ML&quot;, 
(ii) local Generalized Akaike information criterion, &quot;GAIC&quot;,
(iii) local Generalized Cross validation &quot;GCV&quot; 
(iv) local EM-algorithm, &quot;EM&quot; (which is very slow) and 
(v) a modified version of the ML, &quot;ML-1&quot; which produce identical results with &quot;EM&quot; but faster.
</p>
<p>The  function <code>pb()</code> fits a P-spline smoother.
</p>
<p>The  function <code>pbm()</code> fits a monotonic (going up or down) P-spline smoother.
</p>
<p>The  function <code>pbc()</code> fits a P-spline smoother where the beginning and end are the same.  
</p>
<p>The <code>pvc()</code> fits a varying coefficient model.  
</p>
<p>Note that the local (or performance iterations) methods can occasionally  make the convergence of gamlss less stable compared to models where the degrees of freedom are fixed.           
</p>


<h3>Value</h3>

<p>the vector x is returned, endowed with a number of attributes. The vector itself is used in the construction of the model matrix, 
while the attributes are needed for the backfitting algorithms <code>additive.fit()</code>.  
</p>


<h3>Warning</h3>

<p>There are occasions where the automatic local methods do not work. One accusation which came to our attention is  when 
the range of the response variable values is very large. Scaling the response variable will solve the problem.</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby and Paul Eilers</p>


<h3>References</h3>

<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>,
<b>11</b>, 89-121.
</p>
<p>Eilers, Paul HC, Marx, Brian D and Durban, Maria, (2016) Twenty years of P-splines. <em>SORT-Statistics and Operations Research Transactions</em>, <b>39</b>, 149&ndash;186.
</p>
<p>Hastie, T. J. and Tibshirani, R. J. (1993), Varying coefficient models (with discussion),J. R. Statist. Soc. B., <b>55</b>,
757-796.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+gamlss.ps">gamlss.ps</a></code>, <code><a href="#topic+cs">cs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#==============================
# pb() and ps() functions
data(aids)
# fitting a smoothing cubic spline with 7 degrees of freedom
# plus the a quarterly  effect  
aids1&lt;-gamlss(y~ps(x,df=7)+qrt,data=aids,family=PO) # fix df's 
aids2&lt;-gamlss(y~pb(x,df=7)+qrt,data=aids,family=PO) # fix df's
aids3&lt;-gamlss(y~pb(x)+qrt,data=aids,family=PO) # estimate lambda
with(aids, plot(x,y))
with(aids, lines(x,fitted(aids1),col="red"))
with(aids, lines(x,fitted(aids2),col="green"))
with(aids, lines(x,fitted(aids1),col="yellow"))
rm(aids1, aids2, aids3)
#=============================
## Not run: 
# pbc()
# simulate data
set.seed(555)
x = seq(0, 1, length = 100)
y = sign(cos(1 * x * 2 * pi + pi / 4)) + rnorm(length(x)) * 0.2
plot(y~x)
m1&lt;-gamlss(y~pbc(x)) 
lines(fitted(m1)~x)
rm(y,x,m1)
#=============================
# the pvc() function
# function to generate data
genData &lt;- function(n=200)
 {
f1 &lt;- function(x)-60+15*x-0.10*x^2
f2 &lt;- function(x)-120+10*x+0.08*x^2
set.seed(1441)
x1 &lt;- runif(n/2, min=0, max=55)
x2 &lt;- runif(n/2, min=0, max=55)
y1 &lt;- f1(x1)+rNO(n=n/2,mu=0,sigma=20)
y2 &lt;- f2(x2)+rNO(n=n/2,mu=0,sigma=30)
 y &lt;- c(y1,y2)
 x &lt;- c(x1,x2)
 f &lt;- gl(2,n/2)
da&lt;-data.frame(y,x,f)
da
}
da&lt;-genData(500)
plot(y~x, data=da, pch=21,bg=c("gray","yellow3")[unclass(f)])
# fitting models
# smoothing x
m1 &lt;- gamlss(y~pb(x), data=da)
# parallel smoothing lines
m2 &lt;- gamlss(y~pb(x)+f, data=da)
# linear interaction
m3 &lt;- gamlss(y~pb(x)+f*x, data=da)
# varying coefficient model
m4 &lt;- gamlss(y~pvc(x, by=f), data=da)
GAIC(m1,m2,m3,m4)
# plotting the fit
lines(fitted(m4)[da$f==1][order(da$x[da$f==1])]~da$x[da$f==1]
         [order(da$x[da$f==1])], col="blue", lwd=2)
lines(fitted(m4)[da$f==2][order(da$x[da$f==2])]~da$x[da$f==2]
         [order(da$x[da$f==2])], col="red", lwd=2)
rm(da,m1,m2,m3,m4)
#=================================
# the rent data
# first with a factor
data(rent)
plot(R~Fl, data=rent, pch=21,bg=c("gray","blue")[unclass(rent$B)])
r1 &lt;- gamlss(R~pb(Fl), data=rent)
# identical to model
r11 &lt;- gamlss(R~pvc(Fl), data=rent)
# now with the factor
r2 &lt;- gamlss(R~pvc(Fl, by=B), data=rent)
lines(fitted(r2)[rent$B==1][order(rent$Fl[rent$B==1])]~rent$Fl[rent$B==1]
                [order(rent$Fl[rent$B==1])], col="blue", lwd=2)
lines(fitted(r2)[rent$B==0][order(rent$Fl[rent$B==0])]~rent$Fl[rent$B==0]
                [order(rent$Fl[rent$B==0])], col="red", lwd=2)
# probably not very sensible model
rm(r1,r11,r2)
#-----------
# now with a continuous variable
# additive model
 h1 &lt;-gamlss(R~pb(Fl)+pb(A), data=rent)
# varying-coefficient model
 h2 &lt;-gamlss(R~pb(Fl)+pb(A)+pvc(A,by=Fl), data=rent)
AIC(h1,h2)
rm(h1,h2)
#-----------
# monotone function
set.seed(1334)
x = seq(0, 1, length = 100)
p = 0.4
y = sin(2 * pi * p * x) + rnorm(100) * 0.1
plot(y~x)
m1 &lt;- gamlss(y~pbm(x))
points(fitted(m1)~x, col="red")
yy &lt;- -y
plot(yy~x)
m2 &lt;- gamlss(yy~pbm(x, mono="down"))
points(fitted(m2)~x, col="red")
#==========================================
# the pbz() function
# creating uncorrelated data
set.seed(123)
y&lt;-rNO(100)
x&lt;-1:100
plot(y~x)
#----------------------
# ML estimation
m1&lt;-gamlss(y~pbz(x))
m2 &lt;-gamlss(y~pb(x))
AIC(m1,m2)
op &lt;- par( mfrow=c(1,2))
term.plot(m1, partial=T)
term.plot(m2, partial=T)
par(op)
# GAIC estimation
m11&lt;-gamlss(y~pbz(x, method="GAIC", k=2))
m21 &lt;-gamlss(y~pb(x, method="GAIC", k=2))
AIC(m11,m21)
op &lt;- par( mfrow=c(1,2))
term.plot(m11, partial=T)
term.plot(m21, partial=T)
par(op)
# GCV estimation
m12&lt;-gamlss(y~pbz(x, method="GCV"))
m22 &lt;-gamlss(y~pb(x, method="GCV"))
AIC(m12,m22)
op &lt;- par( mfrow=c(1,2))
term.plot(m12, partial=T)
term.plot(m22, partial=T)
par(op)
# fixing df is more trycky since df are the extra df 
m13&lt;-gamlss(y~pbz(x, df=0))
m23 &lt;-gamlss(y~pb(x, df=0))
AIC(m13,m23)
# here the second penalty is not take effect therefore identical results 
m14&lt;-gamlss(y~pbz(x, df=1))
m24 &lt;-gamlss(y~pb(x, df=1))
AIC(m14,m24)
# fixing lambda
m15&lt;-gamlss(y~pbz(x, lambda=1000))
m25 &lt;-gamlss(y~pb(x, lambda=1000))
AIC(m15,m25)
#--------------------------------------------------
# prediction 
m1&lt;-gamlss(y~pbz(x), data=data.frame(y,x))
m2 &lt;-gamlss(y~pb(x), data=data.frame(y,x))
AIC(m1,m2)
predict(m1, newdata=data.frame(x=c(80, 90, 100, 110)))
predict(m2, newdata=data.frame(x=c(80, 90, 100, 110)))
#---------------------------------------------------

## End(Not run)
</code></pre>

<hr>
<h2 id='Q.stats'>A function to calculate the Q-statistics</h2><span id='topic+Q.stats'></span>

<h3>Description</h3>

<p>This function calculates and prints the Q-statistics (or Z-statistics) which are useful to test normality of the residuals within a range of an independent variable, for example age in centile estimation, see Royston and Wright (2000). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.stats(obj = NULL, xvar = NULL, resid = NULL, xcut.points = NULL, n.inter = 10, 
      zvals = TRUE, save = TRUE, plot = TRUE, digits.xvar = getOption("digits"),
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.stats_+3A_obj">obj</code></td>
<td>
<p>a GAMLSS object</p>
</td></tr>
<tr><td><code id="Q.stats_+3A_xvar">xvar</code></td>
<td>
<p>a unique explanatory variable</p>
</td></tr>
<tr><td><code id="Q.stats_+3A_resid">resid</code></td>
<td>
<p>quantile or standardised residuals can be given here instead of a GAMLSS object in <code>obj</code>. In this case the function behaves differently (see details below) </p>
</td></tr>
<tr><td><code id="Q.stats_+3A_xcut.points">xcut.points</code></td>
<td>
<p>the x-axis cut off points e.g. <code>c(20,30)</code>. If <code>xcut.points=NULL</code> then the <code>n.inter</code> argument is activated </p>
</td></tr>
<tr><td><code id="Q.stats_+3A_n.inter">n.inter</code></td>
<td>
<p>if <code>xcut.points=NULL</code> this argument gives the number of intervals in which the x-variable will be split, with default 10</p>
</td></tr>
<tr><td><code id="Q.stats_+3A_zvals">zvals</code></td>
<td>
<p>if <code>TRUE</code> the output matrix contains the individual Z-statistics rather that  the Q statistics</p>
</td></tr>
<tr><td><code id="Q.stats_+3A_save">save</code></td>
<td>
<p>whether to save the Q-statistics or not with default equal to <code>TRUE</code>. 
In this case the functions produce a matrix giving individual Q (or z) statistics and the final aggregate Q's</p>
</td></tr>
<tr><td><code id="Q.stats_+3A_plot">plot</code></td>
<td>
<p>whether to plot  a visual version of the Q statistics  (default is TRUE)  </p>
</td></tr>
<tr><td><code id="Q.stats_+3A_digits.xvar">digits.xvar</code></td>
<td>
<p>to control the number of digits of the <code>xvar</code> in the plot </p>
</td></tr>
<tr><td><code id="Q.stats_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the function <code>Q.stats</code> behaves differently depending whether the <code>obj</code> or the <code>resid</code> argument is set. The <code>obj</code> argument produces the Q-statistics (or Z-statistics) table appropriate for centile estimation (therefore it expect a reasonable large number of observations). The argument <code>resid</code> allows any model residuals, (not necessary GAMLSS), suitable standardised and is appropriate for any size of data. The resulting table contains only the  individuals  Z-statistics. 
</p>


<h3>Value</h3>

<p>A table containing the  Q-statistics or Z-statistics. If <code>plot=TRUE</code> it produces also an graphical representation of the table. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby with contributions from Elaine Borghie</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Royston P. and Wright E. M. (2000) Goodness of fit statistics for the age-specific reference intervals. 
<em>Statistics in Medicine</em>, 19, pp 2943-2962.  
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+centiles.split">centiles.split</a></code>,  <code><a href="#topic+wp">wp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
h&lt;-gamlss(y~pb(x), sigma.formula=~pb(x), family=BCT, data=abdom) 
Q.stats(h,xvar=abdom$x,n.inter=8)
Q.stats(h,xvar=abdom$x,n.inter=8,zvals=FALSE)
Q.stats(resid=resid(h),  xvar=abdom$x, n.inter=5)
rm(h)
</code></pre>

<hr>
<h2 id='quantSheets'>
Quantile Sheets
</h2><span id='topic+quantSheets'></span><span id='topic+quantSheets.control'></span><span id='topic+findPower'></span><span id='topic+z.scoresQS'></span>

<h3>Description</h3>

<p>The quantile sheets function <code>quantSheets()</code> is based on the work of Sabine
Schnabe and Paul  Eiler (see references below). The estimation  of the quantile curves 
is done simultaneously by also smoothing in the direction of y as well as x. This avoids (but do not eliminate completely) the problem of crossing quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantSheets(y, x, x.lambda = 1, p.lambda = 1, data = NULL, 
            cent = 100 * pnorm((-4:4) * 2/3), 
            control = quantSheets.control(...), print = TRUE,  ...)

quantSheets.control(x.inter = 10, p.inter = 10, degree = 3, logit = FALSE, 
            order = 2, kappa = 0, n.cyc = 100, c.crit = 1e-05, plot = TRUE, 
            power = NULL, ...)

findPower(y, x, data = NULL, lim.trans = c(0, 1.5), prof = FALSE, 
            k = 2, c.crit = 0.01, step = 0.1)

z.scoresQS(object, y, x, plot = FALSE, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantSheets_+3A_y">y</code></td>
<td>
<p>the y variable</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_x">x</code></td>
<td>
<p>the x variable</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_x.lambda">x.lambda</code></td>
<td>
<p>smoothing parameter in the direction of x</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_p.lambda">p.lambda</code></td>
<td>
<p>smoothing parameter in the direction of y (probabilities)</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_data">data</code></td>
<td>
<p>the data frame</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_cent">cent</code></td>
<td>
<p>the centile values where the quantile sheets is evaluated</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_control">control</code></td>
<td>
<p>for the parameters controlling the algorithm</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_print">print</code></td>
<td>
<p>whether to print the sample percentages</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_x.inter">x.inter</code></td>
<td>
<p>number of intervals in the x direction for the B-splines</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_p.inter">p.inter</code></td>
<td>
<p>number of intervals in the probabilities (y-direction) for the B-splines</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_degree">degree</code></td>
<td>
<p>the degree for the B-splines</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_logit">logit</code></td>
<td>
<p>whether to use <code>logit(p)</code> instead of <code>p</code> (probabilities) for the y-axis</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_order">order</code></td>
<td>
<p>the order of the penalty</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_kappa">kappa</code></td>
<td>
<p>is a ridge parameter set to zero (for no ridge effect) </p>
</td></tr>
<tr><td><code id="quantSheets_+3A_n.cyc">n.cyc</code></td>
<td>
<p>number of cycles of the algorithm</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_c.crit">c.crit</code></td>
<td>
<p>convergence criterion of the algorithm</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_plot">plot</code></td>
<td>
<p>whether to plot the resulting quantile sheets</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_power">power</code></td>
<td>
<p>The value of the power transformation in the x axis if needed</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_lim.trans">lim.trans</code></td>
<td>
<p>the limits for looking for the power transformation 
parameter using <code>findPower()</code> </p>
</td></tr>
<tr><td><code id="quantSheets_+3A_prof">prof</code></td>
<td>
<p>whether to use the profile GAIC or <code>optim()</code> to the parameter
the power transformation</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_k">k</code></td>
<td>
<p>the  GAIC penalty</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_step">step</code></td>
<td>
<p>the steps for the profile GAIC if the argument <code>prof</code> of 
<code>findPower()</code> is TRUE</p>
</td></tr> 
<tr><td><code id="quantSheets_+3A_object">object</code></td>
<td>
<p>a fitted <code>quantSheets</code> object</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_tol">tol</code></td>
<td>
<p>how far out from the range of the y variable should go for 
estimating the distribution of y using the <code>flexDist()</code> 
function</p>
</td></tr>
<tr><td><code id="quantSheets_+3A_...">...</code></td>
<td>
<p>for further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The advantage  of quantile sheets is that they estimates simultaneously all the quantiles.
This almost eliminates the problem of crossing quantiles. The method is very fast and
useful for  exploratory  tool. The function needs two smoothing parameters. 
Those two parameters have to specified by the user. They are <em>not</em> estimated automatically. They can be selected by visual inspection.
</p>
<p>The disadvantages of quantile sheets comes from the fact that like all non-parametric techniques do not have a goodness of fit measure to change how good is the models and the residuals based diagnostics are not existence since it is difficult to define residuals in this set up.  
</p>
<p>In this implementation we do provide residuals by using the  <code>flexDist()</code> 
function from package <span class="pkg">gamlss.dist</span>. This is based on the idea that by 
knowing the quantiles of the distribution we can reconstruct non parametrically 
the distribution itself and this is what <code>flexDist()</code> is doing.
As a word of caution, such a construct is based on several assumptions and depends on 
several smoothing parameters.   Treat those residuals with caution. 
The same caution should apply to the function <code>z.scoresQS()</code>. 
</p>


<h3>Value</h3>

<p>Using the function <code>quantSheets()</code> a <code>quantSheets</code> object is returned having the following  methods:
<code>print()</code>, <code>fitted()</code>, <code>predict()</code> and <code>resid()</code>. 
</p>
<p>Using <code>findPower()</code> a single values of the power parameter is returned.
</p>
<p>Using <code>z.scoresQS</code> a vector of z-scores is returned.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos based on function provided by Paul Eiler and Sabine
Schnabe</p>


<h3>References</h3>

<p>Schnabel, S.K. (2011) <em>Expectile smoothing: new perspectives on asymmetric least squares. An application to life expectancy</em>, Utrecht University.
</p>
<p>Schnabel, S. K and Eilers, P. H. C.(2013) Simultaneous estimation of quantile curves using quantile sheets, <em>AStA Advances in Statistical Analysis</em>, <b>97</b>, 1, 
pp 77-87, Springer.
</p>
<p>Schnabel, S. K and Eilers, P. H. (2013) A location-scale model for non-crossing 
expectile curves, <em>Stat</em>, <b>2</b>, 1, pp 171-183.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lms">lms</a></code>: for  a parametric equivalent results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
m1 &lt;- quantSheets(y,x, data=abdom)
head(fitted(m1))
p1 &lt;- predict(m1, newdata=c(20,30,40))
matpoints(c(20,30,40), p1)
z.scoresQS(m1,y=c(150, 300),x=c(20, 30) )
# If we needed a power transformation not appropriate for this data
findPower(y,x, data=abdom)
</code></pre>

<hr>
<h2 id='random'>Specify a random intercept model in a GAMLSS formula</h2><span id='topic+random'></span><span id='topic+re'></span>

<h3>Description</h3>

<p>They are two functions for fitting random effects within a  GAMLSS model, <code>random()</code> and <code>re()</code>. 
</p>
<p>The function <code>random()</code> is based on the original <code>random()</code> function of Trevor Hastie in the package <code>gam</code>. In our version the function has been modified to allow a &quot;local&quot; maximum likelihood estimation of the smoothing parameter <code>lambda</code>. This method is  equivalent to the PQL method of Breslow and Clayton (1993) applied at the local iterations of the algorithm. In fact for a GLM model and a simple random effect it is equivalent to <code>glmmPQL()</code> function in the package <code>MASS</code> see Venables and Ripley (2002).  Venables and Ripley (2002) claimed that this iterative method was first introduced by Schall (1991). Note that in order for the &quot;local&quot; maximum likelihood estimation procedure to operate both argument <code>df</code> and <code>lambda</code> has to be <code>NULL</code>.
</p>
<p>The function <code>re()</code> is an interface for calling the <code>lme()</code> function of the package  <span class="pkg">nlme</span>. This gives the user the ability to fit complicated random effect models while the assumption of the normal distribution for the response variable is relaxed.  The theoretical justification comes again from the fact that this is a PQL method,  Breslow and Clayton (1993). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(x, df = NULL, lambda = NULL, start=10)

re(fixed = ~1, random = NULL, correlation = NULL, method = "ML",
          level = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_x">x</code></td>
<td>
<p>a factor </p>
</td></tr>
<tr><td><code id="random_+3A_df">df</code></td>
<td>
<p>the target degrees of freedom</p>
</td></tr>
<tr><td><code id="random_+3A_lambda">lambda</code></td>
<td>
<p>the smoothing parameter lambda which can be viewed as a shrinkage parameter.</p>
</td></tr>
<tr><td><code id="random_+3A_start">start</code></td>
<td>
<p>starting value for lambda if local Maximul likelihood is used.</p>
</td></tr>
<tr><td><code id="random_+3A_fixed">fixed</code></td>
<td>
<p>a formula specify the fixed effects of the <code>lme()</code> model. This, in most cases  can be also included in the <code>gamlss</code> parameter formula</p>
</td></tr>
<tr><td><code id="random_+3A_random">random</code></td>
<td>
<p>a formula or list specifying the random effect  part of the model as in  <code>lme()</code> function</p>
</td></tr>
<tr><td><code id="random_+3A_correlation">correlation</code></td>
<td>
<p>the correlation structure of the <code>lme()</code> model</p>
</td></tr>
<tr><td><code id="random_+3A_method">method</code></td>
<td>
<p>which method, &quot;ML&quot; (the default), or &quot;REML&quot;</p>
</td></tr>
<tr><td><code id="random_+3A_level">level</code></td>
<td>
<p>this argument has to be set to zero (0) if when use <code>predict()</code> you want to get the marginal contribution</p>
</td></tr> 
<tr><td><code id="random_+3A_...">...</code></td>
<td>
<p>this can be used to pass arguments for <code>lmeControl()</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>random()</code> can be seen as  a smoother for use with factors in gamlss(). 
It allows the fitted values for a factor predictor to be shrunk towards the overall mean, 
where the amount of shrinking depends either on lambda, or on the equivalent degrees of freedom or on the estimated sigma parameter (default).  Similar in spirit to smoothing splines, this fitting method can be justified on Bayesian grounds or by a random effects model. Note that the behaviour of the function is different from the original Hastie function. Here the function behaves as follows: i) if both <code>df</code> and <code>lambda</code> are <code>NULL</code> then the PQL method is used
ii) if  <code>lambda</code> is not <code>NULL</code>,  <code>lambda</code> is used for fitting
iii) if  <code>lambda</code> is  <code>NULL</code> and   <code>df</code> is not <code>NULL</code> then <code>df</code>
is used for fitting. 
</p>
<p>Since factors are coded by model.matrix() into a set of contrasts, care has been taken to add an appropriate &quot;contrast&quot; 
attribute to the output of random(). This zero contrast results in a column of zeros in the model matrix,  which is aliased with any column and is hence ignored.
</p>
<p>The use of the function <code>re()</code> requires knowledge of the use of the function <code>lme()</code> of the package <span class="pkg">nlme</span> for the specification of the appropriate random effect model. Some care should betaken whether the data set is  
</p>


<h3>Value</h3>

<p>x is returned with class &quot;smooth&quot;, with an attribute named &quot;call&quot; which is to be evaluated in the backfitting  <code>additive.fit()</code> 
called by <code>gamlss()</code>
</p>


<h3>Author(s)</h3>

<p>For <code>re()</code> Mikis Stasinopoulos and Marco Enea and for <code>random()</code> Trevor Hastie (amended by Mikis Stasinopoulos), </p>


<h3>References</h3>

<p>Breslow, N. E. and Clayton, D. G. (1993) Approximate inference in generalized linear mixed models. <em>Journal of the American Statistical Association</em> <b>88</b>, 9???25.
</p>
<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Pinheiro, Jose C and Bates, Douglas M (2000) <em>Mixed effects models in S and S-PLUS</em>
Springer.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Schall, R. (1991) Estimation in generalized linear models with random effects. <em>Biometrika</em> <b>78</b>, 719???727.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+gamlss.random">gamlss.random</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#------------- Example 1 from Pinheiro and Bates (2000) page 15-----------------
# bring nlme
library(nlme)
data(ergoStool)
# lme model
l1&lt;-lme(effort~Type, data=ergoStool, random=~1|Subject, method="ML")
# use random() 
t1&lt;-gamlss(effort~Type+random(Subject), data=ergoStool )
# use re() with fixed effect within re()
t2&lt;-gamlss(effort~re(fixed=~Type, random=~1|Subject), data=ergoStool )
# use re() with fixed effect in gamlss formula
t3&lt;-gamlss(effort~Type+re(random=~1|Subject), data=ergoStool )
# compare lme fitted values with random
plot(fitted(l1), fitted(t1))
# compare lme fitted values with random
plot(fitted(l1), fitted(t2))
lines(fitted(l1), fitted(t3), col=2)
# getting the fitted coefficients 
getSmo(t2)
#-------------------------------------------------------------------------------
## Not run: 
#-------------Example 2 Hodges data---------------------------------------------
data(hodges)
plot(prind~state, data=hodges)
m1&lt;- gamlss(prind~random(state), sigma.fo=~random(state), nu.fo=~random(state), 
            tau.fo=~random(state), family=BCT, data=hodges)
m2&lt;- gamlss(prind~re(random=~1|state), sigma.fo=~re(random=~1|state), 
            nu.fo=~re(random=~1|state), tau.fo=~re(random=~1|state), family=BCT, 
            data=hodges)
# comparing the fitted effective degrees of freedom
m1$mu.df
m2$mu.df
m1$sigma.df
m2$sigma.df
m1$nu.df
m2$nu.df
m1$tau.df
m2$tau.df
# random effect for tau is not needed
m3&lt;- gamlss(prind~random(state), sigma.fo=~random(state), nu.fo=~random(state),  
            family=BCT, data=hodges, start.from=m1)
plot(m3)
# term plots work for random but not at the moment for re()
op &lt;- par(mfrow=c(2,2))
term.plot(m3, se=TRUE)
term.plot(m3, se=TRUE, what="sigma")
term.plot(m3, se=TRUE, what="nu")
par(op)
# getting information from a fitted lme object
coef(getSmo(m2))
ranef(getSmo(m2))
VarCorr(getSmo(m2))
summary(getSmo(m2))
intervals(getSmo(m2))
fitted(getSmo(m2))
fixef(getSmo(m2))
#  plotting 
plot(getSmo(m2))
qqnorm(getSmo(m2))
#----------------Example 3 from Pinheiro and Bates (2000) page 42---------------
data(Pixel)
l1 &lt;- lme(pixel~ day+I(day^2), data=Pixel, random=list(Dog=~day, Side=~1),
          method="ML")
# this will fail 
#t1&lt;-gamlss(pixel~re(fixed=~day+I(day^2), random=list(Dog=~day, Side=~1)), 
#           data=Pixel)
# but this  is working 
t1&lt;-gamlss(pixel~re(fixed=~day+I(day^2), random=list(Dog=~day, Side=~1), 
                    opt="optim"), data=Pixel)
plot(fitted(l1)~fitted(t1))
#---------------Example 4 from Pinheiro and Bates (2000)page 146----------------
data(Orthodont)
l1 &lt;- lme(distance~ I(age-11), data=Orthodont, random=~I(age-11)|Subject,
           method="ML")

t1&lt;-gamlss(distance~I(age-11)+re(random=~I(age-11)|Subject), data=Orthodont)
plot(fitted(l1)~fitted(t1))
# checking the model
plot(t1)
wp(t1, ylim.all=2)
# two observation fat try LO
t2&lt;-gamlss(distance~I(age-11)+re(random=~I(age-11)|Subject,  opt="optim", 
     numIter=100), data=Orthodont, family=LO)
plot(t2)
wp(t2,ylim.all=2)
# a bit better but not satisfactory Note that  3 paramters distibutions fail
#------------example 5 from Venable and Ripley (2002)--------------------------
library(MASS)
data(bacteria)
summary(glmmPQL(y ~ trt + I(week &gt; 2), random = ~ 1 | ID,
                family = binomial, data = bacteria))
s1 &lt;- gamlss(y ~ trt + I(week &gt; 2)+random(ID), family = BI, data = bacteria)
s2 &lt;- gamlss(y ~ trt + I(week &gt; 2)+re(random=~1|ID), family = BI, 
             data = bacteria)
s3 &lt;- gamlss(y ~ trt + I(week &gt; 2)+re(random=~1|ID, method="REML"), family = BI, 
             data = bacteria)
# the esimate of the random effect sd sigma_b 
sqrt(getSmo(s1)$tau2)
getSmo(s2)
getSmo(s3)
#-------------Example 6 from Pinheiro and Bates (2000) page 239-244-------------
# using corAR1()
data(Ovary)
# AR1 
l1 &lt;- lme(follicles~sin(2*pi*Time)+cos(2*pi*Time), data=Ovary, 
          random=pdDiag(~sin(2*pi*Time)), correlation=corAR1())
# ARMA
l2 &lt;- lme(follicles~sin(2*pi*Time)+cos(2*pi*Time), data=Ovary, 
          random=pdDiag(~sin(2*pi*Time)), correlation=corARMA(q=2))
# now gamlss
# AR1 
t1 &lt;- gamlss(follicles~re(fixed=~sin(2*pi*Time)+cos(2*pi*Time), 
                         random=pdDiag(~sin(2*pi*Time)),
                         correlation=corAR1()), data=Ovary)
plot(fitted(l1)~fitted(t1))
# ARMA
t2 &lt;- gamlss(follicles~re(fixed=~sin(2*pi*Time)+cos(2*pi*Time), 
                          random=pdDiag(~sin(2*pi*Time)),
                          correlation=corARMA(q=2)), data=Ovary)
plot(fitted(l2)~fitted(t2))
AIC(t1,t2)
wp(t2, ylim.all=1)
#-------------------------------------------------------------------------------  

## End(Not run)
</code></pre>

<hr>
<h2 id='refit'>Refit a GAMLSS model</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>This function refits a GAMLSS model. It is useful when the algorithm 
has not converged after 20 outer iteration (the default value)</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model which has not converged</p>
</td></tr>
<tr><td><code id="refit_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when the iterations have reach the maximum value set by the code(n.cyc) of the 
<code>gamlss.control</code> function and the model has not converged yet
</p>


<h3>Value</h3>

<p>Returns a GAMLSS fitted model 
</p>


<h3>Note</h3>

<p>The function <code><a href="stats.html#topic+update">update</a></code> does a very similar job</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+update.gamlss">update.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
refit(h)
rm(h)
</code></pre>

<hr>
<h2 id='residuals.gamlss'>Extract Residuals from GAMLSS model</h2><span id='topic+residuals.gamlss'></span>

<h3>Description</h3>

<p><code>residuals.gamlss</code> is the GAMLSS specific method for the generic function <code>residuals</code> which extracts the  
residuals for a fitted model.  The abbreviated form <code>resid</code> is an alias for <code>residuals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
residuals(object, what = c("z-scores", "mu", "sigma", "nu", "tau"), 
                         type = c("simple", "weighted", "partial"), 
                         terms=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="residuals.gamlss_+3A_what">what</code></td>
<td>
<p>specify whether the standardized residuals are required, called here the &quot;z-scores&quot;, or residuals for a specific parameter</p>
</td></tr>
<tr><td><code id="residuals.gamlss_+3A_type">type</code></td>
<td>
<p>the type of residual if residuals for a parameter are required</p>
</td></tr>
<tr><td><code id="residuals.gamlss_+3A_terms">terms</code></td>
<td>
<p>if type is &quot;partial&quot; this specifies which term is required</p>
</td></tr>
<tr><td><code id="residuals.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;z-scores&quot; residuals saved in a GAMLSS object are the normalized (randomized) quantile residuals (see Dunn and Smyth, 1996). 
Randomization is only needed for the discrete family distributions, see also <code><a href="#topic+rqres.plot">rqres.plot</a></code>. Residuals for a specific parameter can be
&quot;simple&quot; = (working variable - linear predictor), &quot;weighted&quot;= sqrt(working weights)*(working variable - linear predictor) or
&quot;partial&quot;=  (working variable - linear predictor)+contribution of specific terms. 
</p>


<h3>Value</h3>

<p>a vector or a matrix of the appropriate residuals of a GAMLSS model. Note that when weights are used in the fitting the length of the residuals can be 
different from <code>N</code> the length of the fitted values. Observations with weights equal to zero are not appearing in the residuals. 
Also observations with frequencies as weights will appear more than once according to their frequencies.      
</p>


<h3>Note</h3>

<p>The &quot;weighted&quot; residuals of a specified parameter can be zero and one if the square of first derivative 
have been used in the fitting of this parameter</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby</p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.gamlss">print.gamlss</a></code>, <code><a href="#topic+summary.gamlss">summary.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code>,  <code><a href="#topic+coef.gamlss">coef.gamlss</a></code>,  
<code><a href="#topic+residuals.gamlss">residuals.gamlss</a></code>, <code><a href="#topic+update.gamlss">update.gamlss</a></code>,  <code><a href="#topic+plot.gamlss">plot.gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>, <code><a href="#topic+formula.gamlss">formula.gamlss</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=NBI, data=aids) # 
plot(aids$x,resid(h))
plot(aids$x,resid(h,"sigma") )
rm(h)
</code></pre>

<hr>
<h2 id='ri'>Specify ridge  or lasso  Regression within a  GAMLSS Formula</h2><span id='topic+ri'></span>

<h3>Description</h3>

<p>The function <code>ri()</code> allow the user to fit a ridge regression within GAMLSS. 
It allows the coefficients of a set of explanatory variables to be shrunk towards zero.
The amount of shrinking depends either on lambda, or on the equivalent degrees of freedom (df). The type of shrinking depends on the argument <code>Lp</code> see example.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ri(X = NULL, x.vars = NULL, df = NULL, lambda = NULL, 
   method = c("ML", "GAIC"), order = 0, start = 10, Lp = 2, 
   kappa = 1e-05, iter = 100, c.crit = 1e-06, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ri_+3A_x">X</code></td>
<td>
<p>A matrix of explanatory variables <code>X</code> which is standardised (mean=0, sd=1)  automatically. Note that in order to get predictions you should use the option <code>x.vars</code></p>
</td></tr>
<tr><td><code id="ri_+3A_x.vars">x.vars</code></td>
<td>
<p>which variables from the <code>data.frame</code> declared in <code>data</code> needs to be included. This is a way to fit the model if predictions are required.</p>
</td></tr>
<tr><td><code id="ri_+3A_df">df</code></td>
<td>

<p>the effective degrees of freedom <code>df</code> 
</p>
</td></tr>
<tr><td><code id="ri_+3A_lambda">lambda</code></td>
<td>

<p>the smoothing parameter <code>lambda</code>
</p>
</td></tr>
<tr><td><code id="ri_+3A_method">method</code></td>
<td>

<p>which method is used for the estimation of the smoothing parameter, &lsquo;ML&rsquo; or &lsquo;GAIC&rsquo; are allowed. 
</p>
</td></tr>
<tr><td><code id="ri_+3A_order">order</code></td>
<td>

<p>the <code>order</code> of the difference applied to the coefficients with default zero. (Do not change this unless there is some ordering in the explanatory variables).)
</p>
</td></tr>
<tr><td><code id="ri_+3A_start">start</code></td>
<td>

<p>starting value for lambda if it estimated using &lsquo;ML&rsquo; or &lsquo;GAIC&rsquo;
</p>
</td></tr>
<tr><td><code id="ri_+3A_lp">Lp</code></td>
<td>

<p>The type of penalty required, <code>Lp=2</code> a proper ridge regression is the default. Use <code>Lp=1</code> for lasso and different values for different penalties.  
</p>
</td></tr>
<tr><td><code id="ri_+3A_kappa">kappa</code></td>
<td>
<p>a regulation parameters used for the weights in the penalties.</p>
</td></tr>
<tr><td><code id="ri_+3A_iter">iter</code></td>
<td>
<p>the number of internal iteration allowed see details.</p>
</td></tr>
<tr><td><code id="ri_+3A_c.crit">c.crit</code></td>
<td>

<p><code>c.crit</code> is the convergent criterion 
</p>
</td></tr>
<tr><td><code id="ri_+3A_k">k</code></td>
<td>

<p><code>k</code> is the penalty if &lsquo;GAIC&rsquo; method is used. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of ridge and related regressions is based on an idea of Paul Eilers which used weights in the penalty matrix. The type of weights are defined by the argument <code>Lp</code>. <code>Lp=2</code> is the standard ridge regression,  <code>Lp=1</code> fits a lasso regression while  <code>Lp=0</code> allows a &quot;best subset&quot;&quot; regression see Hastie et al (2009) page 71.
</p>


<h3>Value</h3>

<p>x is returned with class &quot;smooth&quot;, with an attribute named &quot;call&quot; which is to be evaluated in the backfitting  <code>additive.fit()</code> called by <code>gamlss()</code>
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Paul Eilers
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. and Stasinopoulos, D. M (2013) Automatic smoothing parameter selection in GAMLSS with an application to centile estimation, <em>Statistical methods in medical research</em>.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss">gamlss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># USAIR DATA
# standarise data 1-------------------------------------------------------------
# ridge
m1&lt;- gamlss(y~ri(x.vars=c("x1","x2","x3","x4","x5","x6")), 
            data=usair)
# lasso
m2&lt;- gamlss(y~ri(x.vars=c("x1","x2","x3","x4","x5","x6"), Lp=1), 
     data=usair)
# best subset
m3&lt;- gamlss(y~ri(x.vars=c("x1","x2","x3","x4","x5","x6"), Lp=0), 
     data=usair)
#--------  plotting the coefficients
op &lt;- par(mfrow=c(3,1))
plot(getSmo(m1)) #
plot(getSmo(m2))
plot(getSmo(m3))
par(op)
</code></pre>

<hr>
<h2 id='rqres.plot'>Creating and Plotting Randomized Quantile Residuals</h2><span id='topic+rqres.plot'></span><span id='topic+get.rqres'></span>

<h3>Description</h3>

<p>This function plots worm plots, van Buuren and Fredriks M. (2001),  or QQ-plots of the normalized randomized quantile residuals (Dunn and Smyth, 1996) for a model using a discrete GAMLSS family distribution.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqres.plot(obj = NULL, howmany = 6, plot.type = c("few", "all"), 
           type = c("wp", "QQ"),  xlim = NULL, ylim = NULL, ...)
get.rqres(obj = NULL, howmany = 10, order = FALSE)           
           
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rqres.plot_+3A_obj">obj</code></td>
<td>
<p>a fitted GAMLSS model object from a &quot;discrete&quot; type of family </p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_howmany">howmany</code></td>
<td>
<p>The number randomise  quantile residuals required i.e. <code>howmany=6</code></p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>whether to plot few of the randomised quantile residual realisations, <code>"few"</code> in a separate plots (there must be less than 8)  or all   <code>"all"</code> in one plot (with their median)</p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_type">type</code></td>
<td>
<p>whether to plot worm plots <code>"wp"</code>or QQ plots <code>"QQ"</code> with default worm plots</p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_xlim">xlim</code></td>
<td>
<p>setting manually the <code>xlim</code> of the graph</p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_ylim">ylim</code></td>
<td>
<p>setting manually the <code>ylim</code> of the graph</p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_order">order</code></td>
<td>
<p>whether to order the ealization of randomised quantile residuals</p>
</td></tr>
<tr><td><code id="rqres.plot_+3A_...">...</code></td>
<td>
<p>for extra arguments to be passed to <code>wp()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For discrete family distributions, the <code><a href="#topic+gamlss">gamlss</a>()</code> function saves on exit one realization of randomized quantile residuals which 
can be plotted using the generic function <code>plot</code> which calls the <code>plot.gamlss</code>. Looking at only one realization can be misleading, so the 
current function creates QQ-plots for several 
realizations. The function allows up to 10 QQ-plots to be plotted. Occasionally  one wishes to create a lot of realizations 
and then take a median of them (separately for each ordered value) to create a single median realization. The option <code>all</code> in combinations 
with the option <code>howmany</code> creates a 
QQ-plot of the medians of the normalized randomized quantile residuals. These 'median' randomized quantile residuals can be saved using the option
(<code>save=TRUE</code>).  
</p>


<h3>Value</h3>

<p>If <code>save</code> it is TRUE then the vector of the median residuals is saved. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p> Dunn, P. K. and Smyth, G. K. (1996) Randomised quantile residuals,
<em>J. Comput. Graph. Statist.</em>, <b>5</b>, 236&ndash;244
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>van Buuren and Fredriks M. (2001) Worm plot: simple diagnostic device for modelling growth reference curves. 
<em>Statistics in Medicine</em>, <b>20</b>, 1259&ndash;1277
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.gamlss">plot.gamlss</a></code>, <code><a href="#topic+gamlss">gamlss</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids) # fitting a model from a discrete distribution 
h&lt;-gamlss(y~pb(x)+qrt, family=NBI, data=aids) # 
plot(h)
# plot qq- plots from 6 realization of the randomized quantile residuals
rqres.plot(h) 
# a worm-plot of the medians from 10 realizations
rqres.plot(h,howmany=40,plot="all") # 
</code></pre>

<hr>
<h2 id='Rsq'>Generalised  (Pseudo) R-squared for GAMLSS models</h2><span id='topic+Rsq'></span>

<h3>Description</h3>

<p>This function gives the generalised R-squared of Nagelkerke (1991) for a GAMLSS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rsq(object, type = c("Cox Snell","Cragg Uhler","both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rsq_+3A_object">object</code></td>
<td>
<p>a GAMLSS object</p>
</td></tr>
<tr><td><code id="Rsq_+3A_type">type</code></td>
<td>
<p>which definition of R squared.  Can be the &quot;Cox Snell&quot; or the Nagelkerke, &quot;Cragg Uhler&quot; or &quot;both&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Rsq()</code> function  uses the definition for R-squared: 
</p>
<p style="text-align: center;"><code class="reqn">R^2=1- \left(\frac{L(0)}{L(\hat{\theta})}\right)^(2/n)</code>
</p>

<p>where <code class="reqn">L(0)</code> is the null model (only a constant is  fitted to all parameters) and 
<code class="reqn">L(\hat{\theta})</code> is the current fitted model. This definition sometimes is referred to as the Cox &amp; Snell R-squared.   The Nagelkerke /Cragg &amp; Uhler's definition divides the above with
</p>
<p style="text-align: center;"><code class="reqn">1- L(0)^(2/n)</code>
</p>



<h3>Value</h3>

<p>The  <code>Rsq()</code> produces a single value if type=&quot;Cox Snell&quot; or &quot;Cragg Uhler&quot; and a list if type=&quot;both&quot;.</p>


<h3>Note</h3>

<p>The null model is fitted using the function gamlssML() which can create warning messages</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Nagelkerke, N. J. (1991). A note on a general definition of the coefficient of determination. Biometrika, 78(3), 691-692.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GAIC">GAIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
m1 &lt;- gamlss(y~x+qrt, data=aids, family=NBI)
Rsq(m1)
Rsq(m1, type="both")
</code></pre>

<hr>
<h2 id='rvcov'>
Robust Variance-Covariance matrix of the parameters from a fitted GAMLSS model
</h2><span id='topic+rvcov'></span><span id='topic+get.K'></span>

<h3>Description</h3>

<p>The function <code>rvcov()</code> is design for providing  robust standard errors for the parameters estimates of a GAMLSS fitted model. The same result can be achieved by using <code>vcov(fitted_model,robust=TRUE)</code>. The function <code>get.()</code> gets the <code class="reqn">K</code> matrix (see details below).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvcov(object, type = c("vcov", "cor", "se", "coef", "all"),
                      hessian.fun = c("R", "PB") )
get.K(object, what = c("K", "Deriv"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvcov_+3A_object">object</code></td>
<td>

<p>a GAMLSS fitted object
</p>
</td></tr>
<tr><td><code id="rvcov_+3A_type">type</code></td>
<td>
<p>this argument for <code>rvcov()</code> function 
whether variance-covariance matrix, correlation matrix, standard errors  or  all of them  
</p>
</td></tr>
<tr><td><code id="rvcov_+3A_what">what</code></td>
<td>
<p>this an argument for the function <code>ket.K()</code> allowing to get either <code class="reqn">K</code> or the first derivative of the likelihood with respect to the parameters (the <code class="reqn">\beta</code>'s in  the GAMLSS notation).</p>
</td></tr> 
<tr><td><code id="rvcov_+3A_hessian.fun">hessian.fun</code></td>
<td>
<p>How to obtain numerically the Hessian i) using <code>optimHess()</code>, option     <code>"R"</code>  ii) using a function by Pinheiro and Bates taken from package <code>nlme</code>, option <code>"PB"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The robust standard errors are calculated for the robust sandwich estimator of the variance-covariance given by <code class="reqn">S=VKV</code> where <code class="reqn">V</code> is the standard variance-covariance matrix (the inverse of the information matrix) and <code class="reqn">K</code> is an estimate of the variance of he first derivatives of he likelihood.  The function <code>get.K()</code> is use the get the required <code class="reqn">K</code> matrix.
</p>


<h3>Value</h3>

<p>A variance covariance matrix or other relevant output
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby and Vlasios Voudouris</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'># gererate from a gamma distribution 
Y &lt;- rGA(200, mu=1, sigma=2)
hist(Y)
# fitting the wrong model i.e. sigma=1 
m1 &lt;- gamlss(Y~1, family=EXP) 
# the conventinal se is too precise 
vcov(m1, type="se")
# the sandwich se is wider  
rvcov(m1, type="se") 
# fitting the correct model 
 m2 &lt;- gamlss(Y~1, family=GA)
 vcov(m2, type="se")
 rvcov(m2, type="se")
# similar stadard errors
# also obtained using 
vcov(m2, type="se", robust=TRUE)


</code></pre>

<hr>
<h2 id='stepGAIC'>Choose a model by GAIC in a Stepwise Algorithm</h2><span id='topic+stepGAIC'></span><span id='topic+stepGAIC.CH'></span><span id='topic+stepGAIC.VR'></span><span id='topic+stepGAICAll.A'></span><span id='topic+stepGAICAll.B'></span><span id='topic+drop1All'></span><span id='topic+add1All'></span>

<h3>Description</h3>

<p>The function <code>stepGAIC()</code> performs stepwise model selection using a Generalized Akaike Information Criterion (GAIC). It is based on the function <code>stepAIC()</code> given in the library MASS of Venables and Ripley (2002). The function has been changed recently to allow parallel computation.  The parallel computations are similar to the ones performed in the function <code>boot()</code> of the <span class="pkg">boot</span> package. Note that since version 4.3-5 of <span class="pkg">gamlss</span> the  <code>stepGAIC()</code> do not have the option of using the function <code>stepGAIC.CH</code> through the argument <code>additive</code>. 
</p>
<p>Note that <code>stepGAIC()</code>  is relying to the <code>dropterm()</code> and <code>addterm()</code> methods applied to gamlss objects.    <code>drop1()</code> and <code>add1()</code> are equivalent methods  to the  <code>dropterm()</code> and <code>addterm()</code> respectively but with different default arguments (see the examples). 
</p>
<p>The function <code>stepGAIC.VR()</code> is the old version  of <code>stepGAIC()</code> with no parallel computations.    
</p>
<p>The function  <code>stepGAIC.CH</code> is based on the S function <code>step.gam()</code> (see Chambers and Hastie (1991)) and it is more suited for model with smoothing additive terms when the degrees of freedom for smoothing are fixed in advance. This is something which rarely used these days, as most of the smoothing functions allow the calculations of the smoothing parameter,  see for example the additive function <code>pb()</code>).  
</p>
<p>The functions <code>stepGAIC.VR()</code> and <code>stepGAIC.CH()</code> have been adapted to work with  gamlss objects and  the main difference is the <code>scope</code> argument, see below. 
</p>
<p>While the functions <code>stepGAIC()</code> is used to build models for individual parameters of the distribution  of the response variable, the functions <code>stepGAICAll.A()</code> and <code>stepGAICAll.A()</code>  are building  models for all  the parameters.
</p>
<p>The functions  <code>stepGAICAll.A()</code> and <code>stepGAICAll.B()</code> are based on the <code>stepGAIC()</code> function but use  different  strategies for selecting a appropriate final model.    
</p>
<p><code>stepGAICAll.A()</code> has the following strategy: 
</p>
<p>Strategy A:
</p>
<p>i) build a model for <code>mu</code> using a forward approach. 
</p>
<p>ii) given the model for <code>mu</code> build a model for <code>sigma</code>  (forward)
</p>
<p>iii) given the models for  <code>mu</code> and <code>sigma</code> build a model for <code>nu</code> (forward) 
</p>
<p>iv)  given the models for  <code>mu</code>, <code>sigma</code> and <code>nu</code> build a model for <code>tau</code> (forward) 
</p>
<p>v) given the models for  <code>mu</code>, <code>sigma</code>,  <code>nu</code> and <code>tau</code> check whether the terms for <code>nu</code> 
are needed using backward elimination. 
</p>
<p>vi) given the models for  <code>mu</code>, <code>sigma</code>,  <code>nu</code> and <code>tau</code> check whether the terms for <code>sigma</code> 
are needed (backward).
</p>
<p>vii) given the models for  <code>mu</code>, <code>sigma</code>,  <code>nu</code> and <code>tau</code> check whether the terms for <code>mu</code> 
are needed (backward).
</p>
<p>Note for this strategy to work the <code>scope</code> argument should be set appropriately. 
</p>
<p><code>stepGAICAll.B()</code> uses the same procedure as the function  <code>stepGAIC()</code> but each term in the scope is fitted  to all the parameters of the distribution, rather than the one specified  by the argument <code>what</code> of <code>stepGAIC()</code>. 
The <code>stepGAICAll.B()</code> relies on the <code>add1All()</code> and <code>drop1All()</code> functions for the selection of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
stepGAIC(object, scope, direction = c("both", "backward", "forward"), 
          trace = TRUE, keep = NULL, steps = 1000, scale = 0, 
          what = c("mu", "sigma", "nu", "tau"), parameter= NULL, k = 2, 
          parallel = c("no", "multicore", "snow"), ncpus = 1L, cl = NULL, 
          ...)

stepGAIC.VR(object, scope, direction = c("both", "backward", "forward"), 
         trace = TRUE, keep = NULL, steps = 1000, scale = 0, 
         what = c("mu", "sigma", "nu", "tau"), parameter= NULL, k = 2, 
         ...)

stepGAIC.CH(object, scope = gamlss.scope(model.frame(object)), 
            direction = c("both", "backward", "forward"), trace = TRUE, 
            keep = NULL, steps = 1000, what = c("mu", "sigma", "nu", "tau"),
            parameter= NULL, k = 2, ...)

stepGAICAll.A(object, scope = NULL, sigma.scope = NULL, nu.scope = NULL, 
              tau.scope = NULL, mu.try = TRUE, sigma.try = TRUE, 
              nu.try = TRUE, tau.try = TRUE,  direction = NULL,  
              parallel = c("no", "multicore", "snow"), ncpus = 1L, 
              cl = NULL,  ...)

stepGAICAll.B(object, scope, direction = c("both", "backward", "forward"), 
              trace = T, keep = NULL, steps = 1000, scale = 0, k = 2, 
              parallel = c("no", "multicore", "snow"), ncpus = 1L, 
              cl = NULL, ...) 
               
drop1All(object, scope, test = c("Chisq", "none"), k = 2, sorted = FALSE, 
              trace = FALSE, parallel = c("no", "multicore", "snow"), 
              ncpus = 1L, cl = NULL, ...)
              
add1All(object, scope, test = c("Chisq", "none"), k = 2, sorted = FALSE, 
              trace = FALSE, parallel = c("no", "multicore", "snow"), 
              ncpus = 1L, cl = NULL, ...)              
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepGAIC_+3A_object">object</code></td>
<td>
<p>an gamlss object. This
is used as the initial model in the stepwise search. </p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_scope">scope</code></td>
<td>
<p>defines the range of models examined in the stepwise search.
For the function   <code>stepAIC()</code> this should be either a single formula, 
or a list containing  components <code>upper</code> and <code>lower</code>, both formulae.  
See the details for how to specify the formulae and how they are
used.
For the function <code>stepGAIC</code> the scope defines the range of models examined in the step-wise search.
It is a list of formulas, with each formula corresponding to a term in the model. 
A 1 in the formula allows the additional option of leaving the term out of the model entirely. +          
</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_direction">direction</code></td>
<td>
<p>the mode of stepwise search, can be one of <code>both</code>,
<code>backward</code>, or <code>forward</code>, with a default of <code>both</code>. If
the <code>scope</code> argument is missing the default for <code>direction</code>
is <code>backward</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="stepGAIC_+3A_trace">trace</code></td>
<td>
<p>if positive, information is printed during the running of
<code>stepAIC</code>. Larger values may give more information on the
fitting process.</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_keep">keep</code></td>
<td>
<p>a filter function whose input is a fitted model object and
the associated 'AIC' statistic, and whose output is
arbitrary. Typically 'keep' will select a subset of the
components of the object and return them. The default is not
to keep anything.</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_steps">steps</code></td>
<td>
<p> the maximum number of steps to be considered.  The default is
1000 (essentially as many as required).  It is typically used
to stop the process early. </p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_scale">scale</code></td>
<td>
<p>scale is nor used in gamlss</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_what">what</code></td>
<td>
<p>which distribution parameter is required, default <code>what="mu"</code> </p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_k">k</code></td>
<td>
<p> the multiple of the number of degrees of freedom used for the
penalty. Only 'k = 2' gives the genuine AIC: 'k = log(n)' is
sometimes referred to as BIC or SBC.</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically     one would chose this to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel = "snow"</code>. If not supplied, a cluster on the local machine is created for the duration of the call.
</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_sigma.scope">sigma.scope</code></td>
<td>
<p>scope for <code>sigma</code> if different to <code>scope</code> in <code>stepGAICAll.A()</code></p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_nu.scope">nu.scope</code></td>
<td>
<p>scope for <code>nu</code> if different to <code>scope</code> in <code>stepGAICAll.A()</code></p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_tau.scope">tau.scope</code></td>
<td>
<p>scope for <code>tau</code> if different to <code>scope</code> in <code>stepGAICAll.A()</code></p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_mu.try">mu.try</code></td>
<td>
<p>The default value is is TRUE, set to FALSE if no model for <code>mu</code> is needed</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_sigma.try">sigma.try</code></td>
<td>
<p>The default value is TRUE, set to FALSE if no model for <code>sigma</code> is needed</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_nu.try">nu.try</code></td>
<td>
<p>The default value is TRUE, set to FALSE if no model for <code>nu</code> is needed</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_tau.try">tau.try</code></td>
<td>
<p>The default value is TRUE, set to FALSE if no model for <code>tau</code> is needed</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_test">test</code></td>
<td>
<p>whether to print the chi-square test or not</p>
</td></tr>
<tr><td><code id="stepGAIC_+3A_sorted">sorted</code></td>
<td>
<p>whether to sort the results</p>
</td></tr>        
<tr><td><code id="stepGAIC_+3A_...">...</code></td>
<td>
<p> any additional arguments to 'extractAIC'. (None are currently
used.)  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of models searched is determined by the <code>scope</code> argument.
</p>
<p>For the function <code>stepGAIC.VR()</code> the right-hand-side of its <code>lower</code> 
component is always included in  the model, and right-hand-side of the model is included in the <code>upper</code> 
component.  If <code>scope</code> is a single formula, it specifies  the <code>upper</code> component,
and the <code>lower</code> model is empty.  If <code>scope</code> is missing, the initial model 
is used as the <code>upper</code> model.
</p>
<p>Models specified by <code>scope</code> can be templates to update <code>object</code> as
used by <code>update.formula</code>.
</p>
<p>For the function <code>stepGAIC.CH()</code> each of the formulas in scope specifies a 
&quot;regimen&quot; of candidate forms in which the particular term may enter the model. 
For example, a term formula might be 
</p>
<p>~ x1 + log(x1) + cs(x1, df=3)
</p>
<p>This means that x1 could either appear linearly, linearly in its logarithm, or as a smooth function estimated non-parametrically.
Every term in the model is described by such a term formula, and the final model is built up by selecting a component from each formula. 
</p>
<p>The function <code>gamlss.scope</code> similar to the S <code>gam.scope()</code> in Chambers and Hastie (1991) can be used to create automatically
term formulae from specified data or model frames.
</p>
<p>The supplied model object is used as the starting model, and hence there is the requirement 
that one term from each of the term formulas of the parameters be present in the formula of the distribution parameter. 
This also implies that any terms in formula of the distribution parameter not contained in any of the term formulas 
will be forced to be present in every model considered.
</p>
<p>When the smoother used in <code>gamlss</code> modelling belongs to the new generation of smoothers allowing the determination of the  smoothing parameters
automatically (i.e. <code>pb()</code>, <code>cy()</code>) then the function   <code>stepGAIC.VR()</code> can be used for model selection (see example below).
</p>


<h3>Value</h3>

<p>the stepwise-selected model is returned, with up to two additional
components.  There is an '&quot;anova&quot;' component corresponding to the
steps taken in the search, as well as a '&quot;keep&quot;' component if the
'keep=' argument was supplied in the call. The '&quot;Resid. Dev&quot;'
column of the analysis of deviance table refers to a constant
minus twice the maximized log likelihood
</p>
<p>The function <code>stepGAICAll.A()</code> returns with a component &quot;anovaAll&quot; containing all the different anova tables used in the process.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos based on functions in MASS library and in Statistical Models in S</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S</em>. Fourth edition.  Springer.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gamlss.scope">gamlss.scope</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(usair)
# -----------------------------------------------------------------------------
#  null model 
mod0&lt;-gamlss(y~1, data=usair, family=GA)
#  all the explanatotory variables x1:x6 fitted linearly 
mod1&lt;-gamlss(y~., data=usair, family=GA)
#-------------------------------------------------------------------------------
# droping terms 
dropterm(mod1)
# with chi-square information
drop1(mod1)
# for parallel computations use something like 
nC &lt;- detectCores()
drop1(mod1, parallel="snow",  ncpus=nC)
drop1(mod1, parallel="multicore",  ncpus=nC)
#------------------------------------------------------------------------------
# adding terms
addterm(mod0, scope=as.formula(paste("~", paste(names(usair[-1]),
                  collapse="+"),sep="")))
# with chi-square information
add1(mod0, scope=as.formula(paste("~", paste(names(usair[-1]),
                  collapse="+"),sep="")))
# for parallel computations 
nC &lt;- detectCores()
add1(mod0, scope=as.formula(paste("~", paste(names(usair[-1]),
                  collapse="+"),sep="")), parallel="snow",  ncpus=nC)
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# stepGAIC 
# find the best subset for the mu
mod2 &lt;- stepGAIC(mod1)
mod2$anova
#--------------------------------------------------------------
# for parallel computations 
mod21 &lt;- stepGAIC(mod1, , parallel="snow",  ncpus=nC)
#--------------------------------------------------------------
# find the best subset for sigma
mod3&lt;-stepGAIC(mod2, what="sigma", scope=~x1+x2+x3+x4+x5+x6)
mod3$anova
#--------------------------------------------------------------
# find the best model using pb() smoother 
#only three variables are used here for simplicity
mod20&lt;-stepGAIC(mod0, scope=list(lower=~1, upper=~pb(x1)+pb(x2)+pb(x5)))
edf(mod20)
# note that x1 and x2 enter linearly
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# the stepGAIC.CH function (no parallel here)
# creating a scope from the usair model frame 
gs&lt;-gamlss.scope(model.frame(y~x1+x2+x3+x4+x5+x6, data=usair))
gs 
mod5&lt;-stepGAIC.CH(mod0,gs)
mod5$anova
#-----------------------------------------------------------------------------=-
#------------------------------------------------------------------------------
# now stepGAICAll.A    
mod7&lt;-stepGAICAll.A(mod0, scope=list(lower=~1,upper=~x1+x2+x3+x4+x5+x6)) 
#-----------------------------------------------------------------------------=-
#------------------------------------------------------------------------------
# now  stepGAICAll.B
drop1All(mod1, parallel="snow",  ncpus=nC)
add1All(mod0, scope=as.formula(paste("~", paste(names(usair[-1]),
                  collapse="+"))), parallel="snow",  ncpus=nC)
mod8&lt;-stepGAICAll.B(mod0, scope=list(lower=~1,upper=~x1+x2+x3+x4+x5+x6))
#-----------------------------------------------------------------------------=-
#------------------------------------------------------------------------------

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.gamlss'>Summarizes a GAMLSS fitted model</h2><span id='topic+summary.gamlss'></span>

<h3>Description</h3>

<p><code>summary.gamlss</code> is the GAMLSS specific method for the generic function <code>summary</code> which summarize 
objects returned by modelling functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
summary(object, type = c("vcov", "qr"), 
                       robust=FALSE, save = FALSE,
                       hessian.fun = c("R", "PB"), 
                       digits = max(3, getOption("digits") - 3),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_type">type</code></td>
<td>
<p>the default value <code>vcov</code> uses the <code>vcov()</code> method for gamlss to get the 
variance-covariance  matrix of the estimated beta coefficients, see details below. 
The alternative <code>qr</code> is the original method used in gamlss to 
estimated the standard errors but it is not reliable since it do not take into the account the inter-correlation between
the distributional parameters <code>mu</code>, <code>sigma</code>, <code>nu</code> and <code>tau</code>.
</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_robust">robust</code></td>
<td>
<p>whether robust (sandwich) standard errors are required</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_save">save</code></td>
<td>
<p>whether to save the environment of the function so to have access to its values</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_hessian.fun">hessian.fun</code></td>
<td>
<p>whether when calculate the Hessian should use the &quot;R&quot; function <code>optimHess()</code> or a function based on Pinheiro and Bates <code>nlme</code> package, &quot;PB&quot;.</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_digits">digits</code></td>
<td>
<p>the number of digits in the output</p>
</td></tr>
<tr><td><code id="summary.gamlss_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the  default value <code>type="vcov"</code>, the <code>vcov()</code> method for gamlss is used to get  
the variance covariance matrix (and consequently the standard errors) of the beta parameters. 
The variance covariance matrix is  calculated using the inverse of the numerical second derivatives
of the observed information matrix. This is a more reliable method since it take into the account the 
inter-correlation between the all the parameters. The <code>type="qr"</code> assumes that the parameters are fixed 
at the estimated values. Note that both methods are not appropriate and should be used with caution if smoothing 
terms are used in the fitting. </p>


<h3>Value</h3>

<p>Print summary of a GAMLSS object
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby  and Calliope Akantziliotou </p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
h&lt;-gamlss(y~poly(x,3)+qrt, family=PO, data=aids) # 
summary(h)
rm(h)
</code></pre>

<hr>
<h2 id='term.plot'>Plot regression terms for a specified parameter of a fitted GAMLSS object</h2><span id='topic+term.plot'></span>

<h3>Description</h3>

<p>Plots regression terms against their predictors, optionally with
standard errors and partial residuals added. It is based on the R function <code>termplot</code> but is suitably changed to apply to GAMLSS objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term.plot(object, what = c("mu", "sigma", "nu", "tau"), 
         parameter= NULL, data = NULL, 
         envir = environment(formula(object)), partial.resid = FALSE, 
         rug = FALSE, terms = NULL, se = TRUE, ylim = c("common", "free"), 
         scheme = c("shaded", "lines"), xlabs = NULL, ylabs = NULL, 
         main = NULL, pages = 0, col.term = "darkred", 
         col.se = "orange", col.shaded = "gray", col.res = "lightblue", 
         col.rug = "gray", lwd.term = 1.5, lty.se = 2, lwd.se = 1, 
         cex.res = 1, pch.res = par("pch"), 
         ask = interactive() &amp;&amp; nb.fig &lt; n.tms &amp;&amp; .Device != "postscript", 
         use.factor.levels = TRUE, surface.gam = FALSE,     
         polys = NULL, polys.scheme = "topo",...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term.plot_+3A_object">object</code></td>
<td>
<p>a fitted GAMLSS object</p>
</td></tr>
<tr><td><code id="term.plot_+3A_what">what</code></td>
<td>
<p>the required parameter of the GAMLSS distribution i.e. &quot;mu&quot;</p>
</td></tr>
<tr><td><code id="term.plot_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="term.plot_+3A_data">data</code></td>
<td>
<p>data frame in which variables in <code>object</code> can be found</p>
</td></tr>
<tr><td><code id="term.plot_+3A_envir">envir</code></td>
<td>
<p>environment in which variables in <code>object</code> can be found </p>
</td></tr>
<tr><td><code id="term.plot_+3A_partial.resid">partial.resid</code></td>
<td>
<p>logical; should partial residuals be plotted or not</p>
</td></tr>
<tr><td><code id="term.plot_+3A_rug">rug</code></td>
<td>
<p> add rug plots (jitter 1-d histograms) to the axes?</p>
</td></tr>
<tr><td><code id="term.plot_+3A_terms">terms</code></td>
<td>
<p>which terms to be plotted (default 'NULL' means all terms) </p>
</td></tr>
<tr><td><code id="term.plot_+3A_se">se</code></td>
<td>
<p>plot point-wise standard errors?</p>
</td></tr>
<tr><td><code id="term.plot_+3A_ylim">ylim</code></td>
<td>
<p>there are two options here a) &quot;common&quot; and b) &quot;free&quot;. 
The &quot;common&quot; option plots all figures with the same <code>ylim</code> 
range and therefore allows the viewer to check the relative 
contribution of each terms compare to the rest.  
In the&lsquo;free&rsquo; option the limits are computed for each plot separately.</p>
</td></tr>
<tr><td><code id="term.plot_+3A_scheme">scheme</code></td>
<td>
<p>whether the se's should appear shaded or as lines</p>
</td></tr>
<tr><td><code id="term.plot_+3A_xlabs">xlabs</code></td>
<td>
<p>vector of labels for the x axes </p>
</td></tr>
<tr><td><code id="term.plot_+3A_ylabs">ylabs</code></td>
<td>
<p>vector of labels for the y axes </p>
</td></tr>
<tr><td><code id="term.plot_+3A_main">main</code></td>
<td>
<p>logical, or vector of main titles;  if 'TRUE', the model's
call is taken as main title, 'NULL' or 'FALSE' mean no
titles.</p>
</td></tr>
<tr><td><code id="term.plot_+3A_pages">pages</code></td>
<td>
<p>in how many pages the plot should appear. The default 
is 0 which allows different page for each plot</p>
</td></tr>
<tr><td><code id="term.plot_+3A_col.term">col.term</code></td>
<td>
<p>the colour of the term line</p>
</td></tr>
<tr><td><code id="term.plot_+3A_col.se">col.se</code></td>
<td>
<p>the colour of the se's lines</p>
</td></tr>
<tr><td><code id="term.plot_+3A_col.shaded">col.shaded</code></td>
<td>
<p>the colour of the shaded area</p>
</td></tr>
<tr><td><code id="term.plot_+3A_col.res">col.res</code></td>
<td>
<p>the colour of the partial residuals</p>
</td></tr>
<tr><td><code id="term.plot_+3A_col.rug">col.rug</code></td>
<td>
<p>the colour of the rug</p>
</td></tr>
<tr><td><code id="term.plot_+3A_lwd.term">lwd.term</code></td>
<td>
<p>line width of the fitted terms</p>
</td></tr>
<tr><td><code id="term.plot_+3A_lty.se">lty.se</code></td>
<td>
<p>line ype for standard errors</p>
</td></tr>
<tr><td><code id="term.plot_+3A_lwd.se">lwd.se</code></td>
<td>
<p>line width for the stadard errors</p>
</td></tr>
<tr><td><code id="term.plot_+3A_cex.res">cex.res</code></td>
<td>
<p> plotting character expansion for the partial residuals</p>
</td></tr>
<tr><td><code id="term.plot_+3A_pch.res">pch.res</code></td>
<td>
<p>characters for points in the partial residuals</p>
</td></tr>
<tr><td><code id="term.plot_+3A_ask">ask</code></td>
<td>
<p>logical; if 'TRUE', the user is asked before each plot, see
'par(ask=.)'.</p>
</td></tr>        
<tr><td><code id="term.plot_+3A_use.factor.levels">use.factor.levels</code></td>
<td>
<p>Should x-axis ticks use factor levels or numbers for
factor terms? </p>
</td></tr>
<tr><td><code id="term.plot_+3A_surface.gam">surface.gam</code></td>
<td>
<p>whether to use surface plot if a <code>ga()</code> term is fitted</p>
</td></tr>
<tr><td><code id="term.plot_+3A_polys">polys</code></td>
<td>
<p>The polygon information file for MRF models</p>
</td></tr>
<tr><td><code id="term.plot_+3A_polys.scheme">polys.scheme</code></td>
<td>
<p>Color scheme for polygons for RMF models</p>
</td></tr>
<tr><td><code id="term.plot_+3A_...">...</code></td>
<td>
<p>other graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the <code>lpred</code> function of GAMLSS.  
The 'data' argument should rarely be needed, but in some cases
'termplot' may be unable to reconstruct the original data frame.
Using 'na.action=na.exclude' makes these problems less likely.
Nothing sensible happens for interaction terms.
</p>


<h3>Value</h3>

<p>a plot of fitted terms.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos based on the existing termplot() function</p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+termplot">termplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
a&lt;-gamlss(y~pb(x)+qrt,data=aids,family=NBI)
term.plot(a, pages=1)
rm(a)
</code></pre>

<hr>
<h2 id='update.gamlss'> Update and Re-fit a GAMLSS Model</h2><span id='topic+update.gamlss'></span>

<h3>Description</h3>

<p><code>update.gamlss</code> is the GAMLSS specific method for the generic function <code>update</code> 
which updates and (by default) refits a GAMLSS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
update(object, formula., ..., 
               what = c("mu", "sigma", "nu", "tau", "All"), 
               parameter= NULL, evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.gamlss_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted model</p>
</td></tr>
<tr><td><code id="update.gamlss_+3A_formula.">formula.</code></td>
<td>
<p>the formula to update</p>
</td></tr>
<tr><td><code id="update.gamlss_+3A_...">...</code></td>
<td>
<p>for updating argument in <code>gamlss()</code></p>
</td></tr>
<tr><td><code id="update.gamlss_+3A_what">what</code></td>
<td>
<p>the parameter in which the formula needs updating for example &quot;mu&quot;, &quot;sigma&quot;, &quot;nu&quot; &quot;tau&quot; or &quot;All&quot;. If &quot;All&quot; all the formulae are updated. Note that the <code>what</code> argument has an effect only if only if the 
argument <code>formula.</code> is set</p>
</td></tr>
<tr><td><code id="update.gamlss_+3A_parameter">parameter</code></td>
<td>
<p>equivalent to <code>what</code></p>
</td></tr>
<tr><td><code id="update.gamlss_+3A_evaluate">evaluate</code></td>
<td>
<p>whether to evaluate the call or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a GAMLSS call or fitted object.  
</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos, Bob Rigby </p>


<h3>References</h3>

<p> Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.gamlss">print.gamlss</a></code>, <code><a href="#topic+summary.gamlss">summary.gamlss</a></code>,  <code><a href="#topic+fitted.gamlss">fitted.gamlss</a></code>,  <code><a href="#topic+coef.gamlss">coef.gamlss</a></code>,  
<code><a href="#topic+residuals.gamlss">residuals.gamlss</a></code>,  <code><a href="#topic+plot.gamlss">plot.gamlss</a></code>, <code><a href="#topic+deviance.gamlss">deviance.gamlss</a></code>, <code><a href="#topic+formula.gamlss">formula.gamlss</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
# fit a poisson model
h.po &lt;-gamlss(y~pb(x)+qrt, family=PO, data=aids) 
# update with a negative binomial
h.nb &lt;-update(h.po, family=NBI) 
# update the smoothing 
h.nb1 &lt;-update(h.nb,~cs(x,8)+qrt) 
# remove qrt
h.nb2 &lt;-update(h.nb1,~.-qrt)
# put back qrt take log of y and fit a normal distribution 
h.nb3 &lt;-update(h.nb1,log(.)~.+qrt, family=NO) 
# verify that it is the same 
h.no&lt;-gamlss(log(y)~cs(x,8)+qrt,data=aids )
</code></pre>

<hr>
<h2 id='VC.test'>Vuong and Clarke tests</h2><span id='topic+VC.test'></span>

<h3>Description</h3>

<p>The Vuong and Clarke tests for GAMLSS fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VC.test(obj1, obj2, sig.lev = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VC.test_+3A_obj1">obj1</code></td>
<td>
<p>The first  fitted gamlss object</p>
</td></tr>
<tr><td><code id="VC.test_+3A_obj2">obj2</code></td>
<td>
<p>The second  fitted gamlss object</p>
</td></tr>
<tr><td><code id="VC.test_+3A_sig.lev">sig.lev</code></td>
<td>
<p>Significance level used for testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vuong (1989) and Clarke (2007) tests are likelihood-ratio-based tests for model selection that use the Kullback-Leibler information criterion. 
The implemented tests can be used for choosing between two bivariate models which are non necessary nested.
</p>
<p>In the Vuong test, the null hypothesis is that the two models are equally close to the actual model, whereas the alternative is that one model is closer. The test follows asymptotically a standard normal distribution under the null. Assume that the critical region is <code>(-c,c)</code>, where <code>c</code> is typically set to 1.96. If the value of the test is greater than <code>c</code> then we reject the null hypothesis that the models are equivalent in favour of the model in <code>obj1</code>. Vice-versa if the value is smaller than <code>-c</code> we reject the null hypothesis that the models are equivalent in favour of the model in <code>obj2</code>. If the value falls within <code>(-c,c0)</code> then we cannot discriminate between the two competing models given the data.
</p>
<p>In the Clarke test, if the two models are statistically equivalent then the log-likelihood ratios of the observations should be evenly distributed around zero and around half of the ratios should be larger than zero. The test follows asymptotically a binomial distribution with parameters n and 0.5. Critical values can be obtained as shown in Clarke (2007). Intuitively, the model in <code>obj1</code> is preferred over that in <code>obj2</code> if the value of the test is significantly larger than its expected value under the null hypothesis (<code>n/2</code>), and vice versa. If the value is not significantly different from <code>n/2</code> then <code>obj1</code> can be thought of as equivalent to <code>obj2</code>.
</p>


<h3>Value</h3>

<p>For the Vuong test it returns its value and the decision and for the Clarke test returns the value the p-value and the decision. Decisions criteria are as discussed above.  
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Giampierro Marra
</p>


<h3>References</h3>

<p>Clarke K. (2007), A Simple Distribution-Free Test for Non-Nested Model Selection. <em>Political Analysis</em>, 15, 347-363.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Vuong Q.H. (1989), Likelihood Ratio Tests for Model Selection and Non-Nested Hypotheses. <em>Econometrica</em>, 57(2), 307-333.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LR.test">LR.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gamlss)
# fitting different models 
m0 &lt;- gamlss(y~x+qrt, data=aids, family=PO)
m1 &lt;- gamlss(y~pb(x)+qrt, data=aids, family=PO)
m2 &lt;- gamlss(y~pb(x)+qrt, data=aids, family=NBI)
# comparison of the mdels
VC.test(m0,m2)
VC.test(m0,m1)
VC.test(m1,m2)
</code></pre>

<hr>
<h2 id='wp'> Worm plot</h2><span id='topic+wp'></span>

<h3>Description</h3>

<p>Provides a single plot or multiple worm plots for a GAMLSS fitted or more general for any fitted models where the method <code>resid()</code> exist and the residuals are defined sensibly. The worm plot (a de-trended QQ-plot), van Buuren and Fredriks M. (2001), is a diagnostic tool for checking the residuals within different ranges (by default not overlapping) of the explanatory variable(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wp(object = NULL, xvar = NULL, resid = NULL, n.inter = 4,
xcut.points = NULL, overlap = 0, xlim.all = 4, 
xlim.worm = 3.5, show.given = TRUE, line = TRUE, 
ylim.all = 12 * sqrt(1/length(resid)), 
ylim.worm = 12 * sqrt(n.inter/length(resid)), 
cex = 1, cex.lab = 1, pch = 21, bg = "wheat", 
col = "red", bar.bg = c(num = "light blue"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wp_+3A_object">object</code></td>
<td>
<p>a GAMLSS fitted object or any other fitted model where the <code>resid()</code> method works (preferably it should be standardised or quantile residuals)</p>
</td></tr>
<tr><td><code id="wp_+3A_xvar">xvar</code></td>
<td>
<p>the explanatory variable(s) against which the worm plots will be plotted. If only one variable is involved use <code>xvar=x1</code> if two variables are involved use <code>xvar=~x1*x2</code>. See also note below for use of formula if the data argument is not found in the fitted model</p>
</td></tr>
<tr><td><code id="wp_+3A_resid">resid</code></td>
<td>
<p>if object is missing this argument can be used to specify the residual vector (again it should a quantile residuals or it be assumed to come from a normal distribution)</p>
</td></tr>
<tr><td><code id="wp_+3A_n.inter">n.inter</code></td>
<td>
<p>the number of intervals in which the explanatory variable <code>xvar</code> will be cut</p>
</td></tr>
<tr><td><code id="wp_+3A_xcut.points">xcut.points</code></td>
<td>
<p>the x-axis cut off points e.g. <code>c(20,30)</code>. If <code>xcut.points=NULL</code> then the <code>n.inter</code> argument is activated </p>
</td></tr>
<tr><td><code id="wp_+3A_overlap">overlap</code></td>
<td>
<p>how much overlapping in the <code>xvar</code> intervals. Default value is <code>overlap=0</code> for non overlapping intervals</p>
</td></tr>
<tr><td><code id="wp_+3A_xlim.all">xlim.all</code></td>
<td>
<p>for the single plot, this value is the x-variable limit, default is <code>xlim.all=4</code></p>
</td></tr>
<tr><td><code id="wp_+3A_xlim.worm">xlim.worm</code></td>
<td>
<p>for multiple plots, this value is the x-variable limit, default is <code>xlim.worm=3.5</code></p>
</td></tr>
<tr><td><code id="wp_+3A_show.given">show.given</code></td>
<td>
<p>whether to show the x-variable intervals in the top of the graph, default is <code>show.given=TRUE</code> </p>
</td></tr>
<tr><td><code id="wp_+3A_line">line</code></td>
<td>
<p>whether to plot the polynomial line in the worm plot, default value is <code>line=TRUE</code></p>
</td></tr>
<tr><td><code id="wp_+3A_ylim.all">ylim.all</code></td>
<td>
<p>for the single plot, this value is the y-variable limit, default value is <code>ylim.all=12*sqrt(1/length(fitted(object)))</code></p>
</td></tr>
<tr><td><code id="wp_+3A_ylim.worm">ylim.worm</code></td>
<td>
<p>for multiple plots, this values is the y-variable limit, default value is <code>ylim.worm=12*sqrt(n.inter/length(fitted(object)))</code></p>
</td></tr>
<tr><td><code id="wp_+3A_cex">cex</code></td>
<td>
<p> the cex plotting parameter for changing the side of worm with default <code>cex=1</code></p>
</td></tr>
<tr><td><code id="wp_+3A_cex.lab">cex.lab</code></td>
<td>
<p>the cex plotting parameter for changing the size of the axis labels</p>
</td></tr>
<tr><td><code id="wp_+3A_pch">pch</code></td>
<td>
<p> the pch plotting parameter with default <code>pch=21</code> </p>
</td></tr>
<tr><td><code id="wp_+3A_bg">bg</code></td>
<td>
<p>The background colour of the worm plot points</p>
</td></tr>
<tr><td><code id="wp_+3A_col">col</code></td>
<td>
<p>the colour of the fitted (and horizontal and vertical) 
lines</p>
</td></tr>
<tr><td><code id="wp_+3A_bar.bg">bar.bg</code></td>
<td>
<p>the colour of the bars when <code>xvar</code> is used</p>
</td></tr>
<tr><td><code id="wp_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>xvar</code> argument is not specified then a single worm plot is used. In this case a worm plot is a de-trended normal QQ-plot so departure from normality is highlighted. 
</p>
<p>If a single  <code>xvar</code> is specified (with or without the use of a formula) i.e. <code>xvar=x1</code> or <code>xvar=~x1</code>) then we have as many worm plot as <code>n.iter</code>. 
In this case the x-variable is cut into <code>n.iter</code> intervals with an equal number observations and de-trended normal QQ (i.e. worm) plots for each interval are plotted. This is a way of highlighting failures of the model within different ranges of the 
the single explanatory variable. The fitted coefficients from fitting cubic polynomials to the residuals (within each x-variable interval) can be obtain by e.g. <code>coeffs&lt;-wp(model1,xvar=x,n.iner=9)</code>.  van Buuren and Fredriks M. (2001) used these residuals to identify regions (intervals) of the explanatory variable within which the model does not fit adequately the data (called &quot;model violation&quot;)  
</p>
<p>Two variables can be displayed with the use of a formula, i.e. <code>xvar=~x1*x2</code>. In this case the <code>n.inter</code> can be a vector with two values.   
</p>


<h3>Value</h3>

<p>For multiple plots the <code>xvar</code> intervals and the coefficients of the fitted cubic polynomials to the residuals (within each <code>xvar</code> interval) are returned.   
</p>


<h3>Note</h3>

<p>Note that the <code>wp()</code> function, if the argument <code>object</code> is used, is looking for the data argument of the object. If the argument <code>data</code> exists it uses its environment to find   <code>xvar</code> (whether it is a formula or not). As a result if <code>data</code> exists within <code>object</code>  
<code>xvar=~x*f</code> can be used (assuming that <code>x</code> and <code>f</code> are in the data) otherwise the variable should be explicitly defined i.e. <code>xvar=~data$x*data$f</code>.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), <em>Appl. Statist.</em>, <b>54</b>, part 3,
1-38. 
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>van Buuren and Fredriks M. (2001) Worm plot: simple diagnostic device for modelling growth reference curves. 
<em>Statistics in Medicine</em>, <b>20</b>, 1259&ndash;1277
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+gamlss">gamlss</a></code>, <code><a href="#topic+plot.gamlss">plot.gamlss</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
# with data
a&lt;-gamlss(y~pb(x),sigma.fo=~pb(x,1),family=LO,data=abdom)
wp(a)
coeff1&lt;-wp(a,xvar=x)
coeff1
## Not run: 
# no data argument
b &lt;- gamlss(abdom$y~pb(abdom$x),sigma.fo=~pb(abdom$x),family=LO)
wp(b) 
wp(b, xvar=abdom$x)# not wp(b, xvar=x)
# using  the argument resid
# this will work
wp(resid=resid(a),  xvar=abdom$x)
# not this
# wp(resid=resid(a),  xvar=x)
# this example uses the rent data
m1 &lt;- gamlss(R~pb(Fl)+pb(A)+loc, sigma.fo=~pb(Fl)+pb(A), data=rent, family=GA)
# a single worm plot
wp(m1, ylim.all=0.5)
# a single continuous x variable 
wp(m1, xvar=Fl, ylim.worm=.8)
# a single x variable changing the default number of intervals
wp(m1, xvar=Fl, ylim.worm=1.5, n.inter=9)
# different x variable changing the default number of intervals
B1&lt;-wp(m1, xvar=A, ylim.worm=1.2, n.inter=9) 
B1
# the number five plot has intervals 
# [5,] 1957.5 1957.5 
# rather disappoining 
# try formula for xvar
wp(m1, xvar=~A, ylim.worm=1.2, n.inter=9)
# better in this case using formula
# now using a factor included in the model
wp(m1, xvar=~loc, ylim.worm=1.2, n.inter=9)
# using a factor notin the model
wp(m1, xvar=~B, ylim.worm=1.5, n.inter=9)
# level 2 (with B=1) did not fit well
# trying two continuous variable 
wp(m1, xvar=~Fl*A, ylim.worm=1.5, n.inter=4)
# one continuous and one categorical 
wp(m1, xvar=~Fl*loc, ylim.worm=1.5, n.inter=4)
# two categorical
wp(m1, xvar=~B*loc, ylim.worm=1.5, n.inter=4)

## End(Not run)

</code></pre>

<hr>
<h2 id='z.scores'>Z-scores for lms objects</h2><span id='topic+z.scores'></span>

<h3>Description</h3>

<p>This creates z-scores for new values of y and x given a fitted <code>lms</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.scores(object, y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z.scores_+3A_object">object</code></td>
<td>
<p>a <code>lms</code> fitted object</p>
</td></tr>
<tr><td><code id="z.scores_+3A_y">y</code></td>
<td>
<p>new y values</p>
</td></tr>
<tr><td><code id="z.scores_+3A_x">x</code></td>
<td>
<p>new x values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a job that can be also done by <code>centiles.pred()</code>.
</p>


<h3>Value</h3>

<p>the required z-scores
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos 
</p>


<h3>References</h3>

<p>Cole, T. J. (1994) Do growth chart centiles need a face lift?
<em>BMJ</em>, 308&ndash;641.
</p>
<p>Cole,  T. J. and Green,  P. J. (1992) Smoothing reference centile curves: the LMS method and penalized likelihood, <em>Statist. Med.</em> <b>11</b>, 1305&ndash;1319
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centiles.pred">centiles.pred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
IND&lt;-sample.int(7040, 1000, replace=FALSE)
db1 &lt;- db[IND,]
plot(head~age, data=db1)
m0 &lt;-  lms(head, age, data=db1,trans.x=TRUE )
z.scores(m0, x=c(2,15,30,40),y=c(45,50,56,63))
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
