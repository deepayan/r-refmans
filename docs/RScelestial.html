<!DOCTYPE html><html lang="en-US"><head><title>Help for package RScelestial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RScelestial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.scelestial'><p>Internal function for running scelestial algorithm.</p></a></li>
<li><a href='#.synthesis'><p>Internal function for generating synthetic single-cell</p>
data through simulation of tumor growth and evolution.</a></li>
<li><a href='#as.mutation.matrix'><p>Conversion of ten-state sequencing matrix to 0/1-mutation matrix.</p></a></li>
<li><a href='#as.ten.state.matrix'><p>Conversion of 0/1 matrix to 10-state matrix</p></a></li>
<li><a href='#as.ten.state.matrix.from.node.seq'><p>Generates 10-state sequence matrix from name/10-char string</p>
matrix.</a></li>
<li><a href='#distance.matrix.scelestial'><p>Calculates distance matrix for result of scelestial</p></a></li>
<li><a href='#distance.matrix.tree'><p>Calculates distance matrix for a nodes on a tree.</p></a></li>
<li><a href='#distance.matrix.true.tree'><p>Calculates distance matrix for a synthetized data</p></a></li>
<li><a href='#Li'><p>Bladder invasive single cell tumor dataset</p></a></li>
<li><a href='#my.dfs'><p>Runs DFS on tree and calculates parent of each node</p>
as well as depth and upper-depth of nodes.</a></li>
<li><a href='#my.general.dfs'><p>Running depth first search on a tree and calling</p>
functions on entrance/exit events</a></li>
<li><a href='#read.sequence.table'><p>Read mutation table</p></a></li>
<li><a href='#RScelestial'><p>RScelestial: An R wrapper for scelestial algorithm for single-cell lineage tree reconstruction</p>
through an approximation algorithm based on Steiner tree problem</a></li>
<li><a href='#scelestial'><p>Infer the single-cell phylogenetic tree</p></a></li>
<li><a href='#synthesis'><p>Synthesize single-cell data through tumor simulation</p></a></li>
<li><a href='#tree.plot'><p>Plotting the tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scelestial: Steiner Tree Based Single-Cell Lineage Tree
Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohammad Hadi Foroughmand Araabi &lt;foroughmand@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Scelestial infers a lineage tree from single-cell DNA mutation matrix. 
	It generates a tree with approximately maximum parsimony through 
	a Steiner tree approximation algorithm. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, knitr, rmarkdown, stringr, seqinr, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 18:58:29 UTC; hforoughmand</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohammad Hadi Foroughmand Araabi [aut, cre],
  Sama Goliaei [aut, ctb],
  Alice McHardy [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.scelestial'>Internal function for running scelestial algorithm.</h2><span id='topic+.scelestial'></span>

<h3>Description</h3>

<p>Internal function for running scelestial algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scelestial(data, minK = 3L, maxK = 4L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".scelestial_+3A_data">data</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code id=".scelestial_+3A_mink">minK</code>, <code id=".scelestial_+3A_maxk">maxK</code></td>
<td>
<p>Minimum and maximum number of vertices to be considered 
for k-restricted Steiner tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tree as well as missing value imputation
</p>

<hr>
<h2 id='.synthesis'>Internal function for generating synthetic single-cell
data through simulation of tumor growth and evolution.</h2><span id='topic+.synthesis'></span>

<h3>Description</h3>

<p>Internal function for generating synthetic single-cell
data through simulation of tumor growth and evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.synthesis(
  sample,
  site,
  evolutionSteps,
  mutationRate = 0.01,
  advantageIncreaseRatio = 1,
  advantageDecreaseRatio = 10,
  advantageKeepRatio = 100,
  advantageIncreaseStep = 0.01,
  advantageDecreaseStep = 0.01,
  mvRate = 0.5,
  fpRate = 0.2,
  fnRate = 0.1,
  seed = -1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".synthesis_+3A_sample">sample</code></td>
<td>
<p>Number of samples</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_site">site</code></td>
<td>
<p>Number of sites</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_evolutionsteps">evolutionSteps</code></td>
<td>
<p>Number of non-root nodes in the evolutionary tree 
to be generated.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_mutationrate">mutationRate</code></td>
<td>
<p>The rate of mutation on each evolutionary step in evolutionary tree synthesis.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_advantageincreaseratio">advantageIncreaseRatio</code>, <code id=".synthesis_+3A_advantagedecreaseratio">advantageDecreaseRatio</code>, <code id=".synthesis_+3A_advantagekeepratio">advantageKeepRatio</code></td>
<td>
<p>A child node
in the evolutionary tree is chosen for increase/decrease/keep its parent advantage with
probabilities proportional to <code>advantage.increase.ratio</code>/<code>advantage.decrease.ratio</code>/<code>advantage.keep.ratio</code>.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_advantageincreasestep">advantageIncreaseStep</code>, <code id=".synthesis_+3A_advantagedecreasestep">advantageDecreaseStep</code></td>
<td>
<p>The amount of 
increasing or decreasing the advantage of a cell relative to its parent.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_mvrate">mvRate</code></td>
<td>
<p>Rate of missing value to be added to the resulting sequences.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_fprate">fpRate</code>, <code id=".synthesis_+3A_fnrate">fnRate</code></td>
<td>
<p>Rate of false positive (0 -&gt; 1) and false negative (1 -&gt; 0)
in the sequences.</p>
</td></tr>
<tr><td><code id=".synthesis_+3A_seed">seed</code></td>
<td>
<p>The seed for randomization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list. The list consists of 
</p>

<ul>
<li> <p><code>sequence</code>: A data frame representing
result of sequencing. The data frame has a row for each locus and a column for each sample.
</p>
</li>
<li> <p><code>true.sequence</code>: The actual sequence for the sample before adding errors and missing values.
</p>
</li>
<li> <p><code>true.clone</code>: A list that stores index of sampled cells for each node in the evolutionary tree.
</p>
</li>
<li> <p><code>true.tree</code>: The evolutionary tree that the samples are sampled from. It is a data frame
with <code>src</code>, <code>dest</code>, and <code>len</code> columns representing source, destination and weight of edges of the tree,
respectively.
</p>
</li></ul>


<hr>
<h2 id='as.mutation.matrix'>Conversion of ten-state sequencing matrix to 0/1-mutation matrix.</h2><span id='topic+as.mutation.matrix'></span>

<h3>Description</h3>

<p>Conversion of ten-state sequencing matrix to 0/1-mutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mutation.matrix(seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.mutation.matrix_+3A_seq">seq</code></td>
<td>
<p>A dataframe representing the ten-state sequencing matrix. Elements of the matrix
are the from &quot;X/Y&quot; for X and Y being nucleotides or &quot;./.&quot; for missing value.
Rows represent loci and columns represent samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with exactly the same size as the input <code>seq</code> matrix.
The most abundant state in each loci (row) translated to 0, and 
the others are translated to 1. Missing values are translated to 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A small 10-state matrix
seq = data.frame("C1" = c("C/C", "C/C"), "C2" = c("A/A", NA), "C3" = c("C/C", "A/A"))
## Convert it to mutation matrix
as.mutation.matrix(seq)
#   C1 C2 C3
# 1  0  1  0
# 2  1  3  0

</code></pre>

<hr>
<h2 id='as.ten.state.matrix'>Conversion of 0/1 matrix to 10-state matrix</h2><span id='topic+as.ten.state.matrix'></span>

<h3>Description</h3>

<p>It converts 0 to A/A and 1 to C/C. 3 that represents missing values are converted
to &quot;./.&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ten.state.matrix(mut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ten.state.matrix_+3A_mut">mut</code></td>
<td>
<p>A dataframe representing the mutation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the exact size as <code>mut</code>, in which
0, 1 and 3 (or NAs) are replaced with &quot;A/A&quot;, &quot;C/C&quot;, and &quot;./.&quot;,
respectively.
</p>


<h3>Note</h3>

<p>Note that following function does not provide inverse of as.mutation.matrix.
It could be used to generate input for scelestial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A small 0/1/NA mutation matrix
mut = data.frame("C1" = c(0, 0), "C2" = c(0, 3), "C3" = c(1, 0))
## Convert it to 10-state matrix
as.ten.state.matrix(mut)
#    C1  C2  C3
# 1 A/A A/A C/C
# 2 A/A ./. A/A
</code></pre>

<hr>
<h2 id='as.ten.state.matrix.from.node.seq'>Generates 10-state sequence matrix from name/10-char string
matrix.</h2><span id='topic+as.ten.state.matrix.from.node.seq'></span>

<h3>Description</h3>

<p>This function is used for conversion of results of internal
scelestial result to 10-state sequence matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ten.state.matrix.from.node.seq(n.seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ten.state.matrix.from.node.seq_+3A_n.seq">n.seq</code></td>
<td>
<p>A two column data frame. First column is the name of a node
and the second column is a string representation of the sequencing result.
Each element of the sequencing result is from a 10-state representation in which
each state represented as a character according to the following encoding:
</p>

<table>
<tr>
 <td style="text-align: center;">
   One character representation </td><td style="text-align: center;"> 10-state representation  </td>
</tr>
<tr>
 <td style="text-align: center;">
   "A" </td><td style="text-align: center;"> "A/A",    </td>
</tr>
<tr>
 <td style="text-align: center;">
   "T" </td><td style="text-align: center;"> "T/T", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "C" </td><td style="text-align: center;"> "C/C", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "G" </td><td style="text-align: center;"> "G/G", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "K" </td><td style="text-align: center;"> "A/C", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "L" </td><td style="text-align: center;"> "A/G", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "M" </td><td style="text-align: center;"> "C/T", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "N" </td><td style="text-align: center;"> "C/G", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "O" </td><td style="text-align: center;"> "T/G", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "P" </td><td style="text-align: center;"> "T/A", </td>
</tr>
<tr>
 <td style="text-align: center;">
   "X" </td><td style="text-align: center;"> "./."
 </td>
</tr>

</table>
</td></tr>
</table>


<h3>Value</h3>

<p>A 10-state sequence data frame with samples as columns
and loci as rows. Elements of <code>n.seq</code> are translated
to their 10-state representations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A node sequence data frame
n.seq = data.frame("node" = c("C1", "C2"), "seq" = c("AKLTCXAAC", "AKKOCXAPC"))
## Convert it to ten state matrix
as.ten.state.matrix.from.node.seq(n.seq)
#     V1  V2  V3  V4  V5  V6  V7  V8  V9
# C1 A/A A/C A/G T/T C/C ./. A/A A/A C/C
# C2 A/A A/C A/C T/G C/C ./. A/A T/A C/C

</code></pre>

<hr>
<h2 id='distance.matrix.scelestial'>Calculates distance matrix for result of scelestial</h2><span id='topic+distance.matrix.scelestial'></span>

<h3>Description</h3>

<p>Calculates distance matrix for result of scelestial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.matrix.scelestial(SP, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance.matrix.scelestial_+3A_sp">SP</code></td>
<td>
<p>Output of scelestial function</p>
</td></tr>
<tr><td><code id="distance.matrix.scelestial_+3A_normalize">normalize</code></td>
<td>
<p>If true, sum of all elements of resulting
table is added up to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Synthesise an evolution
S = synthesis(10, 5, 20, seed=7)
## Run Scelestial
SC = scelestial(as.ten.state.matrix(S$seqeunce))
## Calculate the distance matrix
distance.matrix.scelestial(SC)
#              C1         C10          C2          C3          C4
# C1  0.000000000 0.003512891 0.015222451 0.014051472 0.008196692
# C10 0.003512891 0.000000000 0.011709560 0.010538580 0.004683800
# C2  0.015222451 0.011709560 0.000000000 0.010538627 0.007025759
# C3  0.014051472 0.010538580 0.010538627 0.000000000 0.005854780
# C4  0.008196692 0.004683800 0.007025759 0.005854780 0.000000000
# C5  0.011709560 0.008196668 0.003512891 0.007025736 0.003512868
# C6  0.023419213 0.019906322 0.019906368 0.009367741 0.015222521
# C7  0.018735342 0.015222451 0.015222498 0.004683871 0.010538651
# C8  0.015222474 0.011709583 0.014051542 0.012880562 0.007025783
# C9  0.010538627 0.007025736 0.009367695 0.008196715 0.002341935
# C5          C6          C7          C8          C9
# C1  0.011709560 0.023419213 0.018735342 0.015222474 0.010538627
# C10 0.008196668 0.019906322 0.015222451 0.011709583 0.007025736
# C2  0.003512891 0.019906368 0.015222498 0.014051542 0.009367695
# C3  0.007025736 0.009367741 0.004683871 0.012880562 0.008196715
# C4  0.003512868 0.015222521 0.010538651 0.007025783 0.002341935
# C5  0.000000000 0.016393477 0.011709606 0.010538651 0.005854803
# C6  0.016393477 0.000000000 0.004683871 0.022248304 0.017564457
# C7  0.011709606 0.004683871 0.000000000 0.017564433 0.012880586
# C8  0.010538651 0.022248304 0.017564433 0.000000000 0.004683847
# C9  0.005854803 0.017564457 0.012880586 0.004683847 0.000000000

</code></pre>

<hr>
<h2 id='distance.matrix.tree'>Calculates distance matrix for a nodes on a tree.</h2><span id='topic+distance.matrix.tree'></span>

<h3>Description</h3>

<p>It is used for internal purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.matrix.tree(graph, cell.names, tree.nodes, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance.matrix.tree_+3A_graph">graph</code></td>
<td>
<p>The tree</p>
</td></tr>
<tr><td><code id="distance.matrix.tree_+3A_cell.names">cell.names</code></td>
<td>
<p>Name of the cells to be the row and column
name of the resulting matrix</p>
</td></tr>
<tr><td><code id="distance.matrix.tree_+3A_tree.nodes">tree.nodes</code></td>
<td>
<p>For each cell.names a tree node is stored
in tree.nodes.</p>
</td></tr>
<tr><td><code id="distance.matrix.tree_+3A_normalize">normalize</code></td>
<td>
<p>If TRUE the resulting matrix is normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with equal number of rows and columns, a row/column
for each cell. Elements of matrix represent distance between cells
on the <code>graph</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Synthesise an evolution
S = synthesis(10, 5, 20, seed=7)
## Run Scelestial
SC = scelestial(as.ten.state.matrix(S$seqeunce))
## Calculate the distance matrix
vertices &lt;- rownames(SC$input);
distance.matrix.tree(SC$tree, vertices, vertices, normalize = TRUE)
#              C1         C10          C2          C3          C4
# C1  0.000000000 0.003512891 0.015222451 0.014051472 0.008196692
# C10 0.003512891 0.000000000 0.011709560 0.010538580 0.004683800
# C2  0.015222451 0.011709560 0.000000000 0.010538627 0.007025759
# C3  0.014051472 0.010538580 0.010538627 0.000000000 0.005854780
# C4  0.008196692 0.004683800 0.007025759 0.005854780 0.000000000
# C5  0.011709560 0.008196668 0.003512891 0.007025736 0.003512868
# C6  0.023419213 0.019906322 0.019906368 0.009367741 0.015222521
# C7  0.018735342 0.015222451 0.015222498 0.004683871 0.010538651
# C8  0.015222474 0.011709583 0.014051542 0.012880562 0.007025783
# C9  0.010538627 0.007025736 0.009367695 0.008196715 0.002341935
# C5          C6          C7          C8          C9
# C1  0.011709560 0.023419213 0.018735342 0.015222474 0.010538627
# C10 0.008196668 0.019906322 0.015222451 0.011709583 0.007025736
# C2  0.003512891 0.019906368 0.015222498 0.014051542 0.009367695
# C3  0.007025736 0.009367741 0.004683871 0.012880562 0.008196715
# C4  0.003512868 0.015222521 0.010538651 0.007025783 0.002341935
# C5  0.000000000 0.016393477 0.011709606 0.010538651 0.005854803
# C6  0.016393477 0.000000000 0.004683871 0.022248304 0.017564457
# C7  0.011709606 0.004683871 0.000000000 0.017564433 0.012880586
# C8  0.010538651 0.022248304 0.017564433 0.000000000 0.004683847
# C9  0.005854803 0.017564457 0.012880586 0.004683847 0.000000000

</code></pre>

<hr>
<h2 id='distance.matrix.true.tree'>Calculates distance matrix for a synthetized data</h2><span id='topic+distance.matrix.true.tree'></span>

<h3>Description</h3>

<p>Calculates distance matrix for a synthetized data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.matrix.true.tree(D, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance.matrix.true.tree_+3A_d">D</code></td>
<td>
<p>Output of synthesis function</p>
</td></tr>
<tr><td><code id="distance.matrix.true.tree_+3A_normalize">normalize</code></td>
<td>
<p>If true, sum of all elements of resulting
table is added up to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix of the true tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Synthesise an evolution
S = synthesis(10, 5, 20, seed=7)
## Calculating the distance matrix of the true tree.
distance.matrix.true.tree(S)
#              C3          C6          C4          C2          C7
# C3  0.000000000 0.004587156 0.006880734 0.009174312 0.013761468
# C6  0.004587156 0.000000000 0.002293578 0.009174312 0.013761468
# C4  0.006880734 0.002293578 0.000000000 0.011467890 0.016055046
# C2  0.009174312 0.009174312 0.011467890 0.000000000 0.004587156
# C7  0.013761468 0.013761468 0.016055046 0.004587156 0.000000000
# C10 0.006880734 0.006880734 0.009174312 0.011467890 0.016055046
# C8  0.006880734 0.011467890 0.013761468 0.016055046 0.020642202
# C9  0.006880734 0.011467890 0.013761468 0.016055046 0.020642202
# C1  0.011467890 0.011467890 0.013761468 0.002293578 0.006880734
# C5  0.011467890 0.011467890 0.013761468 0.002293578 0.006880734
# C10          C8          C9          C1          C5
# C3  0.006880734 0.006880734 0.006880734 0.011467890 0.011467890
# C6  0.006880734 0.011467890 0.011467890 0.011467890 0.011467890
# C4  0.009174312 0.013761468 0.013761468 0.013761468 0.013761468
# C2  0.011467890 0.016055046 0.016055046 0.002293578 0.002293578
# C7  0.016055046 0.020642202 0.020642202 0.006880734 0.006880734
# C10 0.000000000 0.013761468 0.013761468 0.013761468 0.013761468
# C8  0.013761468 0.000000000 0.000000000 0.018348624 0.018348624
# C9  0.013761468 0.000000000 0.000000000 0.018348624 0.018348624
# C1  0.013761468 0.018348624 0.018348624 0.000000000 0.000000000
# C5  0.013761468 0.018348624 0.018348624 0.000000000 0.000000000

</code></pre>

<hr>
<h2 id='Li'>Bladder invasive single cell tumor dataset</h2><span id='topic+Li'></span>

<h3>Description</h3>

<p>Bladder invasive single cell tumor dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Li)
</code></pre>


<h3>Format</h3>

<p>Each column represent a cell and each row represent a locus. 
&quot;./.&quot; represent the missing value, &quot;A/A&quot; the normal state and &quot;C/C&quot; the mutated state.
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3626503/bin/2047-217X-1-12-S2.xls">QTL Archive</a>
</p>


<h3>References</h3>

<p>Gigascience. 2012 Aug 14;1(1):12. doi: 10.1186/2047-217X-1-12.
(<a href="https://pubmed.ncbi.nlm.nih.gov/23587365/">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Li)
</code></pre>

<hr>
<h2 id='my.dfs'>Runs DFS on tree and calculates parent of each node
as well as depth and upper-depth of nodes.</h2><span id='topic+my.dfs'></span>

<h3>Description</h3>

<p>It is used for internal purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.dfs(graph, root = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.dfs_+3A_graph">graph</code></td>
<td>
<p>The tree</p>
</td></tr>
<tr><td><code id="my.dfs_+3A_root">root</code></td>
<td>
<p>The starting node of DFS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with <code>father</code> representing the parent node, and
<code>balance.depth</code> representing the distance between the node and
the farthest node to it, as the elements.
</p>

<hr>
<h2 id='my.general.dfs'>Running depth first search on a tree and calling
functions on entrance/exit events</h2><span id='topic+my.general.dfs'></span>

<h3>Description</h3>

<p>It is used for internal purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.general.dfs(
  nei,
  v,
  f,
  extra,
  in.call,
  mid.call.before,
  mid.call.after,
  out.call
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.general.dfs_+3A_nei">nei</code></td>
<td>
<p>Neighbor list for each vertex</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_v">v</code></td>
<td>
<p>Starting node</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_f">f</code></td>
<td>
<p>Parent node</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_extra">extra</code></td>
<td>
<p>the shared object for the whole DFS</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_in.call">in.call</code></td>
<td>
<p>First function to call</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_mid.call.before">mid.call.before</code></td>
<td>
<p>Function to call before calling child DFS</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_mid.call.after">mid.call.after</code></td>
<td>
<p>Function to call after calling child DFS</p>
</td></tr>
<tr><td><code id="my.general.dfs_+3A_out.call">out.call</code></td>
<td>
<p>Last function to call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>extra</code> parameter modified with <code>in.call</code>, <code>mid.call.before</code>, <code>mid.call.after</code>, and <code>out.call</code> functions
</p>

<hr>
<h2 id='read.sequence.table'>Read mutation table</h2><span id='topic+read.sequence.table'></span>

<h3>Description</h3>

<p>A simple read of a sequencing file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.sequence.table(file.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.sequence.table_+3A_file.name">file.name</code></td>
<td>
<p>Name of the file to be loaded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table representing the content of the file. 
First column of the file represents the row names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example input without header could be like following:
# 1 C/C A/A A/A A/A 
# 2 ./. A/A C/C C/C 
# 3 C/C A/A C/C ./. 
# 4 A/A ./. ./. ./. 
# 5 ./. A/A A/A A/A 
# 
# For this file you can run
read.sequence.table(system.file("extdata/sample1.txt", package="RScelestial"))

</code></pre>

<hr>
<h2 id='RScelestial'>RScelestial: An R wrapper for scelestial algorithm for single-cell lineage tree reconstruction
through an approximation algorithm based on Steiner tree problem</h2><span id='topic+RScelestial'></span>

<h3>Description</h3>

<p>This package provides a wrapper for the scelestial which is implemented in C++.
The package contains function <code>scelestial</code> for running the algorithm and 
<code>synthesis</code> for tumor simulation for providing synthetic data.
</p>

<hr>
<h2 id='scelestial'>Infer the single-cell phylogenetic tree</h2><span id='topic+scelestial'></span>

<h3>Description</h3>

<p>Performs the Scelestial algorithm and calculates the phylogenetic tree reconstruction 
based on an approximation algorithm for Steiner tree problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scelestial(
  seq,
  mink = 3,
  maxk = 3,
  root.assign.method = c("none", "balance", "fix"),
  root = NULL,
  return.graph = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scelestial_+3A_seq">seq</code></td>
<td>
<p>The sequence matrix. Rows represent loci and columns represent samples.
Elements of the matrix represent 10-state genome sequencing results, or missing values.
I.e each element is in the format &quot;X/Y&quot; where X and Y are from the set {A, T, C, G}. 
There is a special case &quot;./.&quot; that represents the missing value.</p>
</td></tr>
<tr><td><code id="scelestial_+3A_mink">mink</code></td>
<td>
<p>The minimum k used in the calculation of k-restricted Steiner trees. 
It is supposed to be 3.</p>
</td></tr>
<tr><td><code id="scelestial_+3A_maxk">maxk</code></td>
<td>
<p>The maximum k used in the calculation of k-restricted Steiner trees.
When maxk=3, the approximation algorithm produces an 11/6-approximation result.
Increasing k increases the running time as well as the approximation ratio of the algorithm.
maxk should be not less than mink.</p>
</td></tr>
<tr><td><code id="scelestial_+3A_root.assign.method">root.assign.method</code>, <code id="scelestial_+3A_root">root</code></td>
<td>
<p>root.assign.method is the method for choosing the root. </p>

<ul>
<li><p> &quot;none&quot; for undirected tree,
</p>
</li>
<li><p> &quot;fix&quot; for a tree with <code>root</code> as its root. 
</p>
</li>
<li><p> &quot;balance&quot; to let the root to be chosen to produce the most balanced tree.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scelestial_+3A_return.graph">return.graph</code></td>
<td>
<p>If TRUE, the actual graph through igraph library is generated and produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing following elements: 
</p>

<ul>
<li> <p><code>tree</code>: A data frame representing edges of the tree. <code>tree$src</code> is the source of the edge,
<code>tree$dest</code> represents the destination of the edge, and <code>tree$len</code> represents its weight (evolutionary distance).
</p>
</li>
<li> <p><code>input</code>: input sequences. 
</p>
</li>
<li> <p><code>sequence</code>: inferred or imputed sequences for the tree nodes. If the node is already
in the input, sequence represents its missing value imputation, in the case of presence of missing values, 
and if the node is not an input node, the sequence represents inferred sequence for the tree node.
</p>
</li>
<li> <p><code>graph</code>: graph. If the return.graph is TRUE, there is an element G that represents the graph 
from the igraph library.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## simulates tumor evolution
S = synthesis(10, 10, 2, seed=7)
## convert to 10-state matrix
seq = as.ten.state.matrix(S$seqeunce)
## runs the scelestial to generate 4-restricted Steiner trees. It represents the tree and graph
SP = scelestial(seq, mink=3, maxk=4, return.graph = TRUE)
SP
## Expected output: 
# $input
#    node   sequence
# 1     0 AAXACAAXXA
# 2     1 AXXXAXAAXA
# 3     2 AXAXCAXXAX
# 4     3 AXCCCAXAAX
# 5     4 AXCXAXXCAX
# 6     5 XXCAXXXXXX
# 7     6 XACXACAAAC
# 8     7 AXAXXAXAXA
# 9     8 AXAAXXAXXX
# 10    9 AAXXXXCXCX
#
# $sequence
#    node   sequence
# 1     0 AAAACAAACA
# 2     1 AACAAAAAAA
# 3     2 AAAACAAAAA
# 4     3 AACCCAAAAA
# 5     4 AACAACACAC
# 6     5 AACAACAAAC
# 7     6 AACAACAAAC
# 8     7 AAAACAAACA
# 9     8 AAAACAAACA
# 10    9 AAAACACACA
# 11   10 AAAACAAACA
# 12   16 AACAAAAAAA
# 13   18 AACACAAAAA
#
# $tree
#    src dest     len
# 1    9   10 4.00006
# 2    8   10 3.00006
# 3    7   10 2.50005
# 4    0   10 1.50003
# 5    6   16 3.00002
# 6    1   16 2.50005
# 7    3   18 2.50003
# 8    0   18 1.50003
# 9   16   18 1.00000
# 10   0    2 3.50008
# 11   4    6 4.00007
# 12   5    6 4.50010
#
# $graph
# IGRAPH 6ba60f3 DNW- 13 12 --
# + attr: name (v/c), weight (e/n)
# + edges from 6ba60f3 (vertex names):
#  [1] 9 -&gt;10 8 -&gt;10 7 -&gt;10 0 -&gt;10 6 -&gt;16 1 -&gt;16 3 -&gt;18 0 -&gt;18 16-&gt;18 0 -&gt;2
# [11] 4 -&gt;6  5 -&gt;6
#
</code></pre>

<hr>
<h2 id='synthesis'>Synthesize single-cell data through tumor simulation</h2><span id='topic+synthesis'></span>

<h3>Description</h3>

<p>This function simulates a evolution in a tumor through two phases: 1) simulation of evolution,
2) sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthesis(
  sample,
  site,
  evolution.step,
  mutation.rate = 1,
  advantage.increase.ratio = 1,
  advantage.decrease.ratio = 10,
  advantage.keep.ratio = 100,
  advantage.increase.step = 0.01,
  advantage.decrease.step = 0.01,
  mv.rate = 0.5,
  fp.rate = 0.2,
  fn.rate = 0.1,
  seed = -1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synthesis_+3A_sample">sample</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_site">site</code></td>
<td>
<p>number of sites (loci)</p>
</td></tr>
<tr><td><code id="synthesis_+3A_evolution.step">evolution.step</code></td>
<td>
<p>Number of evolutionary steps in the process of production of 
the evolutionary tree.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_mutation.rate">mutation.rate</code></td>
<td>
<p>The rate of mutation on each evolutionary step in evolutionary tree synthesis.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_advantage.increase.ratio">advantage.increase.ratio</code>, <code id="synthesis_+3A_advantage.decrease.ratio">advantage.decrease.ratio</code>, <code id="synthesis_+3A_advantage.keep.ratio">advantage.keep.ratio</code></td>
<td>
<p>A child node
in the evolutionary tree is chosen for increase/decrease/keep its parent advantage with
probabilities proportional to <code>advantage.increase.ratio</code>/<code>advantage.decrease.ratio</code>/<code>advantage.keep.ratio</code>.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_advantage.increase.step">advantage.increase.step</code>, <code id="synthesis_+3A_advantage.decrease.step">advantage.decrease.step</code></td>
<td>
<p>The amount of 
increasing or decreasing the advantage of a cell relative to its parent.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_mv.rate">mv.rate</code></td>
<td>
<p>Rate of missing value to be added to the resulting sequences.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_fp.rate">fp.rate</code>, <code id="synthesis_+3A_fn.rate">fn.rate</code></td>
<td>
<p>Rate of false positive (0 -&gt; 1) and false negative (1 -&gt; 0)
in the sequences.</p>
</td></tr>
<tr><td><code id="synthesis_+3A_seed">seed</code></td>
<td>
<p>The seed for randomization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation of evolution starts with a single cell. 
Then for <code>evolution.step</code> steps, on each step a cell is selected for duplication. 
A new cell as its child is added to 
the evolutionary tree. To each node in the evolutionary tree an advantage is assigned
representing its relative advantage in replication and in being sampled. Advantage of a node
is calculated by increasing (decreasing) its parents advantage by <code>advantage.increase.step</code> 
(<code>advantage.decrease.step</code>) with probability proportional to <code>advantage.increase.ratio</code> 
(<code>advantage.decrease.ratio</code>). 
With a probability proportional to <code>advantage.keep.ratio</code> the advantage of a node
is equal to its parent's advantage.
</p>
<p>Sequences for each node is build based on its parent's sequence by adding some mutations.
Mutations are added for each locus independently with rate <code>mutation.rate</code>.
</p>
<p>In the sampling phase, <code>sample</code> cells are selected from the evolutionary tree nodes.
Result of the sequencing process for a cell is determined by the sequence of the node in the evolutionary tree
with addition of some random errors. Errors are result of applying some false positives with rate <code>fp.rate</code>,
applying some false negatives with rate <code>fn.rate</code>, and adding some missing values
with rate <code>mv.rate</code>.
</p>


<h3>Value</h3>

<p>The function returns a list. The list consists of 
</p>

<ul>
<li> <p><code>sequence</code>: A data frame representing
result of sequencing. The data frame has a row for each locus and a column for each sample.
</p>
</li>
<li> <p><code>true.sequence</code>: The actual sequence for the sample before adding errors and missing values.
</p>
</li>
<li> <p><code>true.clone</code>: A list that stores index of sampled cells for each node in the evolutionary tree.
</p>
</li>
<li> <p><code>true.tree</code>: The evolutionary tree that the samples are sampled from. It is a data frame
with <code>src</code>, <code>dest</code>, and <code>len</code> columns representing source, destination and weight of edges of the tree,
respectively.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## generating a data set with 10 samples and 5 loci through simulation of
## 20-step evolution.
synthesis(10, 5, 20, seed=7)
## The result is
# $seqeunce
#     C1 C2 C3 C4 C5
# L1   1  1  1  1  1
# L2   3  1  3  3  0
# L3   3  1  3  3  1
# L4   3  0  1  0  0
# L5   1  3  0  3  3
# L6   3  1  3  1  0
# L7   3  3  1  0  3
# L8   3  1  1  3  3
# L9   3  3  1  3  1
# L10  0  3  0  3  0
#
# $true.sequence
#     C1 C2 C3 C4 C5
# L1   0  1  1  1  1
# L2   0  1  0  0  1
# L3   0  1  0  0  1
# L4   0  1  1  1  1
# L5   1  1  0  1  0
# L6   0  1  0  1  0
# L7   0  1  0  0  1
# L8   0  1  1  1  1
# L9   0  1  1  1  1
# L10  0  0  0  0  0
#
# $true.clone
# $true.clone[[1]]
# [1] 4
#
# $true.clone[[2]]
# [1] 1
#
# $true.clone[[3]]
# [1] 6
#
# $true.clone[[4]]
# [1] 10
#
# $true.clone[[5]]
# [1] 2
#
# $true.clone[[6]]
# [1] 3
#
# $true.clone[[7]]
# [1] 8 9
#
# $true.clone[[8]]
# [1] 7
#
# $true.clone[[9]]
# [1] 5
#
#
# $true.tree
#   src dest len
# 1   1    5   3
# 2   5    7   1
# 3   5   10   2
# 4   1   11   3
# 5   1   12   2
# 6   1   13   3
# 7   7   14   2
# 8  12   19   1
# 9  10   20   1
#
</code></pre>

<hr>
<h2 id='tree.plot'>Plotting the tree</h2><span id='topic+tree.plot'></span>

<h3>Description</h3>

<p>Plotting the igraph tree created by scelestial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.plot(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.plot_+3A_graph">graph</code></td>
<td>
<p>Output of scelestial or the G element of the scelestial output.</p>
</td></tr>
<tr><td><code id="tree.plot_+3A_...">...</code></td>
<td>
<p>Parameters passing to the plot function</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
