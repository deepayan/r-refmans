<!DOCTYPE html><html><head><title>Help for package GPFDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPFDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcScaleDistMats'><p>Calculate matrices for NSGP covariance function</p></a></li>
<li><a href='#covMat'><p>Calculate a covariance matrix</p></a></li>
<li><a href='#D2'><p>Second derivative of the likelihood</p></a></li>
<li><a href='#dataExampleGPFR'><p>Data simulated in the GPFR example</p></a></li>
<li><a href='#dataExampleMGPR'><p>Data simulated in the MGPR example</p></a></li>
<li><a href='#distanceMatrix'><p>Calculate generalised distances</p></a></li>
<li><a href='#GPFDA'><p>GPFDA: A package for Gaussian Process Regression for Functional Data Analysis</p></a></li>
<li><a href='#gpfr'><p>Gaussian process functional regression (GPFR) model</p></a></li>
<li><a href='#gpfrPredict'><p>Prediction of GPFR model</p></a></li>
<li><a href='#gpr'><p>Gaussian process regression (GPR) model</p></a></li>
<li><a href='#gprPredict'><p>Prediction of GPR model</p></a></li>
<li><a href='#mat2fd'><p>Create an 'fd' object from a matrix</p></a></li>
<li><a href='#mgpCovMat'><p>Calculate a multivariate Gaussian processes covariance matrix given a</p>
vector of hyperparameters</a></li>
<li><a href='#mgpr'><p>Multivariate Gaussian process regression (MGPR) model</p></a></li>
<li><a href='#mgprPredict'><p>Prediction of MGPR model</p></a></li>
<li><a href='#nsgpCovMat'><p>Calculate a NSGP covariance matrix given a vector of hyperparameters</p></a></li>
<li><a href='#nsgpCovMatAsym'><p>Calculate an asymmetric NSGP covariance matrix</p></a></li>
<li><a href='#nsgpr'><p>Estimation of a nonseparable and/or nonstationary covariance structure (NSGPR</p>
model)</a></li>
<li><a href='#nsgprPredict'><p>Prediction of NSGPR model</p></a></li>
<li><a href='#plot.gpfr'><p>Plot GPFR model for either training or prediction</p></a></li>
<li><a href='#plot.gpr'><p>Plot GPR model for either training or prediction</p></a></li>
<li><a href='#plot.mgpr'><p>Plot predictions of GPR model</p></a></li>
<li><a href='#plotImage'><p>Draw an image plot for a given two-dimensional input</p></a></li>
<li><a href='#plotmgpCovFun'><p>Plot auto- or cross-covariance function of a multivariate Gaussian process</p></a></li>
<li><a href='#unscaledCorr'><p>Calculate an unscaled NSGP correlation matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Process for Functional Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Jian Qing Shi, Yafeng Cheng, Evandro Konzen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evandro Konzen &lt;gpfda.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionalities for modelling functional data with 
    multidimensional inputs, multivariate functional data, and non-separable 
    and/or non-stationary covariance structure of function-valued processes. 
    In addition, there are functionalities for functional regression models where 
    the mean function depends on scalar and/or functional covariates and 
    the covariance structure depends on functional covariates. 
    The development version of the package can be found on 
    <a href="https://github.com/gpfda/GPFDA-dev">https://github.com/gpfda/GPFDA-dev</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, splines, mgcv, fields, interp, stats, graphics,
grDevices, fda, fda.usc</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, mvtnorm, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-10 15:24:14 UTC; evandro</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-10 22:22:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcScaleDistMats'>Calculate matrices for NSGP covariance function</h2><span id='topic+calcScaleDistMats'></span>

<h3>Description</h3>

<p>Calculates matrices 'ScaleMat' and 'DistMat', which are used to 
obtain NSGP covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcScaleDistMats(A_List, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcScaleDistMats_+3A_a_list">A_List</code></td>
<td>
<p>List of anisotropy matrices</p>
</td></tr>
<tr><td><code id="calcScaleDistMats_+3A_coords">coords</code></td>
<td>
<p>Matrix of input coordinates (covariates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ScaleMat and DistMat matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("nsgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='covMat'>Calculate a covariance matrix</h2><span id='topic+covMat'></span><span id='topic+cov.pow.ex'></span><span id='topic+cov.rat.qu'></span><span id='topic+cov.matern'></span><span id='topic+cov.linear'></span>

<h3>Description</h3>

<p>Evaluates one of the following covariance functions at input 
vectors t and t': 
</p>

<ul>
<li><p> Powered exponential
</p>
</li>
<li><p> Rational quadratic
</p>
</li>
<li><p> Matern
</p>
</li>
<li><p> Linear
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cov.pow.ex(hyper, input, inputNew = NULL, gamma = 2)

cov.rat.qu(hyper, input, inputNew = NULL)

cov.matern(hyper, input, inputNew = NULL, nu)

cov.linear(hyper, input, inputNew = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMat_+3A_hyper">hyper</code></td>
<td>
<p>The hyperparameters. It must be a list with certain names. See 
details.</p>
</td></tr>
<tr><td><code id="covMat_+3A_input">input</code></td>
<td>
<p>The covariate t. It must be either a matrix, where each column
represents a covariate, or a vector if there is only one covariate.</p>
</td></tr>
<tr><td><code id="covMat_+3A_inputnew">inputNew</code></td>
<td>
<p>The covariate t'. It also must be a vector or a matrix. 
If NULL (default), 'inputNew' will be set to be equal to &lsquo;input&rsquo; and the 
function will return a squared, symmetric covariance matrix.</p>
</td></tr>
<tr><td><code id="covMat_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2. Default to 2, which gives the squared exponential 
covariance function.</p>
</td></tr>
<tr><td><code id="covMat_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names for the hyperparameters should be: 
</p>

<ul>
<li><p> &quot;pow.ex.v&quot; and &quot;pow.ex.w&quot; (powered exponential);
</p>
</li>
<li><p> &quot;rat.qu.v&quot;, &quot;rat.qu.w&quot; and &quot;rat.qu.a&quot; (rational quadratic);
</p>
</li>
<li><p> &quot;matern.v&quot; and &quot;matern.w&quot; (Matern);
</p>
</li>
<li><p> &quot;linear.i&quot; and &quot;linear.a&quot; (linear);
</p>
</li>
<li><p> &quot;vv&quot; (Gaussian white noise).
</p>
</li></ul>



<h3>Value</h3>

<p>A covariance matrix
</p>


<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional input&rdquo;, CRC Press.
</p>

<hr>
<h2 id='D2'>Second derivative of the likelihood</h2><span id='topic+D2'></span>

<h3>Description</h3>

<p>Calculate the second derivative of the likelihood function with respect to
one of the hyperparameters, given the first and second derivative of the
kernel with respect to that hyperparameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2(d1, d2, inv.Q, Alpha.Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D2_+3A_d1">d1</code></td>
<td>
<p>First derivative of the kernel function with respect to the required
hyperparameter.</p>
</td></tr>
<tr><td><code id="D2_+3A_d2">d2</code></td>
<td>
<p>Second derivative of the kernel function with respect to the
required hyperparameter.</p>
</td></tr>
<tr><td><code id="D2_+3A_inv.q">inv.Q</code></td>
<td>
<p>Inverse of covariance matrix Q.</p>
</td></tr>
<tr><td><code id="D2_+3A_alpha.q">Alpha.Q</code></td>
<td>
<p>This is alpha * alpha'- invQ, where invQ is the inverse of the
covariance matrix Q, and alpha = invQ * Y, where Y is the response.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the second derivative of the log-likelihood,
using the first and second derivative of the kernel functions.
</p>


<h3>Value</h3>

<p>A number.
</p>


<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional Data&rdquo;, CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This function is used in the vignette 'co2':
# vignette("co2", package = "GPFDA")
</code></pre>

<hr>
<h2 id='dataExampleGPFR'>Data simulated in the GPFR example</h2><span id='topic+dataExampleGPFR'></span>

<h3>Description</h3>

<p>A list containing training and test data simulated from a functional 
regression model. <br /> <br />
In the training set, there are M=20 independent realisations and 
the functional response and the functional covariate are observed on a grid 
of n=20 time points.  <br /> <br />
The test set includes a single realisation observed on a grid of n_new=60 
time points.  <br /> <br />
Both training and test sets also have a scalar covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataExampleGPFR
</code></pre>


<h3>Format</h3>

<p>A list with seven elements:
</p>
 <dl>
<dt>tt</dt><dd><p>A vector of length 50</p>
</dd> 
<dt>response_train</dt><dd><p>A (20 x 50) matrix</p>
</dd>
<dt>x_train</dt><dd><p>A (20 x 50) matrix</p>
</dd>
<dt>scalar_train</dt><dd><p>A (20 x 2) matrix</p>
</dd>
<dt>t_new</dt><dd><p>A vector of length 60</p>
</dd> 
<dt>response_new</dt><dd><p>A vector of length 60</p>
</dd>
<dt>x_new</dt><dd><p>A vector of length 60</p>
</dd>
<dt>scalar_new</dt><dd><p>A (1 x 2) matrix</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used in the GPFR example, see vignette(&quot;gpfr&quot;).
</p>

<hr>
<h2 id='dataExampleMGPR'>Data simulated in the MGPR example</h2><span id='topic+dataExampleMGPR'></span>

<h3>Description</h3>

<p>A list containing data simulated from a MGPR model. <br /> <br /> 
The dataset contains 30 realisations from a trivariate process. Each of the 
three functions is observed on 250 time points on [0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataExampleMGPR
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>
 <dl>
<dt>input</dt><dd><p>List of 3 numeric vectors, each one being the time 
points where the corresponding function is observed.</p>
</dd> 
<dt>response</dt><dd><p>List of 3 matrices containing the observed 250 datapoints. 
Each column is an independent realisation.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used in the MGPR example, see vignette(&quot;mgpr&quot;).
</p>

<hr>
<h2 id='distanceMatrix'>Calculate generalised distances</h2><span id='topic+distanceMatrix'></span><span id='topic+distMat'></span><span id='topic+distMatSq'></span><span id='topic+distMatLinear'></span><span id='topic+distMatLinearSq'></span>

<h3>Description</h3>

<p>Calculate the generalised distance between vectors t and t'
using an anisotropy matrix A.
</p>

<ul>
<li> <p><code>distMat</code> and <code>distMatSq</code> calculate:
</p>
<p style="text-align: center;"><code class="reqn"> [(t - t')^{p/2}]^T A  (t - t')^{p/2}  </code>
</p>

</li>
<li> <p><code>distMatLinear</code> and <code>distMatLinearSq</code> calculate:
</p>
<p style="text-align: center;"><code class="reqn"> t^T A t' </code>
</p>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>distMat(input, inputNew, A, power)

distMatSq(input, A, power)

distMatLinear(input, inputNew, A)

distMatLinearSq(input, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceMatrix_+3A_input">input</code></td>
<td>
<p>Vector of the input coordinate t</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_inputnew">inputNew</code></td>
<td>
<p>Vector of the input coordinate t'</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_a">A</code></td>
<td>
<p>Anisotropy matrix A</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_power">power</code></td>
<td>
<p>Power value p</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distMatSq</code> and <code>distMatLinearSq</code> functions are 
used when input vectors t and t' are identical, returning a symmetric matrix. <br /> <br />
When <code>distMat</code> and <code>distMatSq</code> functions are used in 
powered exponential kernels, power=1 gives the exponential kernel and 
power=2 gives the squared exponential one. <br /> <br />
<code>distMatLinear</code> and <code>distMatLinearSq</code> functions are used in the 
linear covariance kernel.
</p>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='GPFDA'>GPFDA: A package for Gaussian Process Regression for Functional Data Analysis</h2><span id='topic+GPFDA'></span><span id='topic+GPFDA-package'></span>

<h3>Description</h3>

<p>Gaussian Process Regression for Functional Data Analysis
</p>


<h3>Details</h3>

<p>The main functions of the package are:
</p>
 <dl>
<dt>gpr</dt><dd><p>Gaussian process regression using stationary separable
covariance kernels.</p>
</dd> <dt>nsgpr</dt><dd><p>Gaussian process regression using
nonstationary and/or nonseparable covariance kernels.</p>
</dd> 
<dt>mgpr</dt><dd><p>Multivariate Gaussian process &ndash; regression for multivariate outputs.</p>
</dd>
<dt>gpfr</dt><dd><p>Functional regression model given by
</p>
<p style="text-align: center;"><code class="reqn">y_m(t)=\mu_m(t)+\tau_m(x)+\epsilon_m(t),</code>
</p>
<p> where <code class="reqn">m</code> is the
<code class="reqn">m</code>-th curve or surface; <code class="reqn">\mu_m</code> is from functional regression;
and <code class="reqn">\tau_m</code> is from Gaussian Process regression with mean 0 covariance
matrix <code class="reqn">k(\bf \theta)</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jian Qing Shi, Yafeng Cheng, Evandro Konzen
</p>


<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional Data&rdquo;, CRC Press.
</p>

<hr>
<h2 id='gpfr'>Gaussian process functional regression (GPFR) model</h2><span id='topic+gpfr'></span>

<h3>Description</h3>

<p>Use functional regression (FR) model for the mean structure and Gaussian
Process (GP) for the covariance structure. <br /> <br /> Let 'n' be the number of
time points 't' of functional objects and 'nrep' the number of independent
replications in the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpfr(
  response,
  time = NULL,
  uReg = NULL,
  fxReg = NULL,
  fyList = NULL,
  uCoefList = NULL,
  fxList = NULL,
  concurrent = TRUE,
  fxCoefList = NULL,
  gpReg = NULL,
  hyper = NULL,
  NewHyper = NULL,
  Cov = "pow.ex",
  gamma = 2,
  nu = 1.5,
  useGradient = T,
  rel.tol = 1e-10,
  trace.iter = 5,
  fitting = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpfr_+3A_response">response</code></td>
<td>
<p>Response data. It can be an 'fd' object or a matrix with
'nrep' rows and 'n' columns.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_time">time</code></td>
<td>
<p>Input 't' of functional objects. It is a numeric vector of
length 'n'.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_ureg">uReg</code></td>
<td>
<p>Scalar covariates for the FR model. It should be a matrix with
'nrep' rows.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_fxreg">fxReg</code></td>
<td>
<p>Functional covariates for the FR model. It can be a matrix with
'nrep' rows  and 'n' columns, an 'fd' object, or a list of matrices or 'fd'
objects.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_fylist">fyList</code></td>
<td>
<p>A list to control the smoothing of response.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_ucoeflist">uCoefList</code></td>
<td>
<p>A list to control the smoothing of the regression
coefficient function of the scalar covariates in the FR model.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_fxlist">fxList</code></td>
<td>
<p>A list to control the smoothing of functional covariates in the
FR model.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_concurrent">concurrent</code></td>
<td>
<p>Logical. If TRUE (default), concurrent functional
regression will be carried out; otherwise, the full functional regression
will be carried out.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_fxcoeflist">fxCoefList</code></td>
<td>
<p>A list to control the smoothing of the regression
coefficient function of functional covariates in the functional concurrent
model.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_gpreg">gpReg</code></td>
<td>
<p>Covariates in the GP model. It should be a matrix, a numeric vector, 
an 'fd' object, a list of matrices or a list of 'fd' objects.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_hyper">hyper</code></td>
<td>
<p>Vector of initial hyperparameters. Default to NULL.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_newhyper">NewHyper</code></td>
<td>
<p>Vector of names of new hyperparameters from the customized
kernel function.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_cov">Cov</code></td>
<td>
<p>Covariance function(s) to use. Options are: 'linear', 'pow.ex',
'rat.qu', and 'matern'. Default to 'power.ex'.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_usegradient">useGradient</code></td>
<td>
<p>Logical. If TRUE, first derivatives will be used in the
optimization.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Relative tolerance passed to nlminb(). Default to be 1e-10.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_trace.iter">trace.iter</code></td>
<td>
<p>Print the processing of iterations of optimization.</p>
</td></tr>
<tr><td><code id="gpfr_+3A_fitting">fitting</code></td>
<td>
<p>Logical. If TRUE, fitting is carried out. Default to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fyList</code> is a list with the following items:
</p>
 <ul>
<li> <p><code>time</code>: a sequence of time points; default to be 100
points from 0 to 1. </p>
</li>
<li> <p><code>nbasis</code>: number of basis functions used in
smoothing, default to be less than or equal to 23. </p>
</li>
<li> <p><code>norder</code>:
order of the functional curves; default to be 6. </p>
</li>
<li> <p><code>bSpline</code>:
logical. If TRUE (default), B-splines basis is used; otherwise, Fourier
basis is used. </p>
</li>
<li> <p><code>Pen</code>: default to be c(0,0), meaning that the
penalty is only applied to the second order derivative of the curve, with
no penalty for the zero-th and first order derivatives of the curve. </p>
</li>
<li>
<p><code>lambda</code>: smoothing parameter for the penalty, default to be 1e-4. </p>
</li></ul>

<p><code>fxList</code> is similar to <code>fyList</code>. However, it is a list of lists
to allow for different specifications for each functional covariate if
there are multiple ones.
</p>
<p><code>uCoefList</code> and <code>fxCoefList</code> are similar to
each other. Each one is expected to be a list of lists. If a list of one 
element is provided, then the items of this element are applied to each of 
the functional coefficients of scalar covariates and of functional covariates,
respectively. 
</p>
 <ul>
<li> <p><code>rtime</code>: range of time, default to be c(0,1). </p>
</li>
<li>
<p><code>nbasis</code>: nnumber of basis functions used in smoothing, default to be
less than or equal to 19. </p>
</li>
<li>  <p><code>norder</code>: order of the functional
curves; default to be 6. </p>
</li>
<li> <p><code>bSpline</code>: logical. If TRUE (default),
B-splines basis is used; otherwise, Fourier basis is used. </p>
</li>
<li>
<p><code>Pen</code>: default to be c(0,0). </p>
</li>
<li> <p><code>lambda</code>: smoothing parameter
for the penalty, default to be 1e4. </p>
</li>
<li> <p><code>bivar</code>:logical. Used for
non-concurrent models; if TRUE, bivariate basis will be used; if FALSE
(default), normal basis will be used; see details in
<code><a href="fda.html#topic+bifdPar">bifdPar</a></code>. </p>
</li>
<li> <p><code>lambdas</code>: smoothing parameter for
the penalty of the additional basis, default to be 1. </p>
</li></ul>
<p> Note that all items
have default settings.
</p>


<h3>Value</h3>

<p>A list containing: </p>
 <dl>
<dt>hyper</dt><dd><p>Estimated hyperparameters</p>
</dd>
<dt>I</dt><dd><p>A vector of estimated standard deviation of hyperparameters</p>
</dd>
<dt>modellist</dt><dd><p>List of FR models fitted before Gaussian process</p>
</dd>
<dt>CovFun</dt><dd><p>Covariance function used</p>
</dd> <dt>gamma</dt><dd><p>Parameter 'gamma' used
in Gaussian process with powered exponential kernel</p>
</dd> <dt>nu</dt><dd><p>Parameter
'nu' used in Gaussian process with Matern kernel</p>
</dd> <dt>init_resp</dt><dd><p>Raw
response data</p>
</dd> <dt>resid_resp</dt><dd><p>Residual after the fitted values from FR
models have been taken out</p>
</dd> <dt>fitted</dt><dd><p>Fitted values</p>
</dd>
<dt>fitted.sd</dt><dd><p>Standard deviation of the fitted values</p>
</dd>
<dt>ModelType</dt><dd><p>The type of the model applied in the function.</p>
</dd>
<dt>lTrain</dt><dd><p>Training scalar covariates for the FR model</p>
</dd>
<dt>fTrain</dt><dd><p>Training functional covariates for the FR model</p>
</dd>
<dt>mfTrainfd</dt><dd><p>List of 'fd' objects from training data for FR model with
functional covariates</p>
</dd> <dt>gpTrain</dt><dd><p>Training data for Gaussian Process</p>
</dd>
<dt>time</dt><dd><p>Input time 't'</p>
</dd> <dt>iuuL</dt><dd><p>Inverse of covariance matrix for
uReg</p>
</dd> <dt>iuuF</dt><dd><p>Inverse of covariance matrix for fxReg</p>
</dd>
<dt>fittedFM</dt><dd><p>Fitted values from the FR model</p>
</dd> <dt>fyList</dt><dd><p>fyList
object used</p>
</dd> </dl>



<h3>References</h3>

 <ul>
<li><p> Ramsay, J., and Silverman, B. W. (2006),
&ldquo;Functional Data Analysis&rdquo;, 2nd ed., Springer, New York. </p>
</li>
<li><p> Shi, J.
Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression Analysis for
Functional Data&rdquo;, CRC Press. </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("gpfr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='gpfrPredict'>Prediction of GPFR model</h2><span id='topic+gpfrPredict'></span>

<h3>Description</h3>

<p>Make predictions for test input data based on the GPFR model learnt by the
'gpfr' function. Both Type I and Type II predictions can be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpfrPredict(
  train,
  testInputGP,
  testTime = NULL,
  uReg = NULL,
  fxReg = NULL,
  gpReg = NULL,
  GPpredict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpfrPredict_+3A_train">train</code></td>
<td>
<p>An object of class 'gpfr' obtained by the the 'gpfr' function.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_testinputgp">testInputGP</code></td>
<td>
<p>Test input data for the GP prediction. It must be a numeric 
vector, a matrix or an 'fd' object.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_testtime">testTime</code></td>
<td>
<p>Test time points for prediction. If NULL, default settings
will be applied.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_ureg">uReg</code></td>
<td>
<p>Scalar covariates data of a new batch for the FR model.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_fxreg">fxReg</code></td>
<td>
<p>Functional covariates data of a new batch for the FR model.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_gpreg">gpReg</code></td>
<td>
<p>Input data for the GP part used for Type I prediction. It must
be a list of three items. The names of the items must be 'response',
'input', and 'time'. The item 'response' is the observed response for a new
batch; 'input' is the observed functional covariates for a new
batch,;'time' is the observed time for the previous two. If NULL (default),
Type II prediction is carried out.</p>
</td></tr>
<tr><td><code id="gpfrPredict_+3A_gppredict">GPpredict</code></td>
<td>
<p>Logical. If TRUE (default), GPFR prediction is carried out;
otherwise only predictions based on the FR model is carried out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'gpReg' is provided, then Type I prediction is made. Otherwise,
Type II prediction is made.
</p>


<h3>Value</h3>

<p>A list containing: </p>
 <dl>
<dt>ypred.mean</dt><dd><p>The mean values of
the prediction.</p>
</dd> <dt>ypred.sd</dt><dd><p>The standard deviation of the
predictions.</p>
</dd> <dt>predictionType</dt><dd><p>Prediction type if  GPFR prediction is
carried out.</p>
</dd> <dt>train</dt><dd><p>All items trained by 'gpfr'.</p>
</dd> </dl>



<h3>References</h3>

 <ul>
<li><p> Ramsay, J., and Silverman, B. W. (2006),
&ldquo;Functional Data Analysis&rdquo;, 2nd ed., Springer, New York. </p>
</li>
<li><p> Shi, J.
Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression Analysis for
Functional Data&rdquo;, CRC Press. </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("gpfr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='gpr'>Gaussian process regression (GPR) model</h2><span id='topic+gpr'></span>

<h3>Description</h3>

<p>Gaussian process regression for a single or multiple independent
realisations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpr(
  response,
  input,
  Cov = "pow.ex",
  m = NULL,
  hyper = NULL,
  NewHyper = NULL,
  meanModel = 0,
  mu = NULL,
  gamma = 2,
  nu = 1.5,
  useGradient = T,
  iter.max = 100,
  rel.tol = 8e-10,
  trace = 0,
  nInitCandidates = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpr_+3A_response">response</code></td>
<td>
<p>Response data. It should be a matrix, where each column is a
realisation. It can be a vector if there is only one realisation.</p>
</td></tr>
<tr><td><code id="gpr_+3A_input">input</code></td>
<td>
<p>Input covariates. It must be either a matrix, where each column
represents a covariate, or a vector if there is only one covariate.</p>
</td></tr>
<tr><td><code id="gpr_+3A_cov">Cov</code></td>
<td>
<p>Covariance function(s) to use. Options are: 'linear', 'pow.ex',
'rat.qu', and 'matern'. Default to 'power.ex'.</p>
</td></tr>
<tr><td><code id="gpr_+3A_m">m</code></td>
<td>
<p>If Subset of Data is to be used, m denotes the subset size and
cannot be larger than the total sample size. Default to NULL.</p>
</td></tr>
<tr><td><code id="gpr_+3A_hyper">hyper</code></td>
<td>
<p>The hyperparameters. Default to NULL. If not NULL, then it must
be a list with appropriate names.</p>
</td></tr>
<tr><td><code id="gpr_+3A_newhyper">NewHyper</code></td>
<td>
<p>Vector of names of the new hyperparameters of the customized
kernel function. These names must have the format: xxxxxx.x, i.e. '6 digit'
followed by 'a dot' followed by '1 digit'. This is required for both
'hyper' and 'NewHyper'</p>
</td></tr>
<tr><td><code id="gpr_+3A_meanmodel">meanModel</code></td>
<td>
<p>Type of mean function. It can be </p>
 <dl>
<dt>0</dt><dd><p>Zero
mean function</p>
</dd> <dt>1</dt><dd><p>Constant mean function to be estimated</p>
</dd>
<dt>'t'</dt><dd><p>Linear model for the mean function</p>
</dd> <dt>'avg'</dt><dd><p>The average
across replications is used as the mean function. This is only used if
there are more than two realisations observed at the same input coordinate
values.</p>
</dd> </dl>
<p> Default to 0. If argument 'mu' is specified, then 'meanModel'
will be set to 'userDefined'.</p>
</td></tr>
<tr><td><code id="gpr_+3A_mu">mu</code></td>
<td>
<p>Mean function specified by the user. It must be a vector. Its
length must be the same as the sample size, that is, nrow(response).</p>
</td></tr>
<tr><td><code id="gpr_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="gpr_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="gpr_+3A_usegradient">useGradient</code></td>
<td>
<p>Logical. If TRUE, first derivatives will be used in the
optimization.</p>
</td></tr>
<tr><td><code id="gpr_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed. Default to 100. If
'rel.tol' is reduced, then the number of iterations needed will be less.</p>
</td></tr>
<tr><td><code id="gpr_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Relative convergence tolerance. Default to 8e-10. Smaller
rel.tol means higher accuracy and more time to converge.</p>
</td></tr>
<tr><td><code id="gpr_+3A_trace">trace</code></td>
<td>
<p>The value of the objective function and the parameters is
printed every trace'th iteration. Defaults to 0 which indicates no trace
information is to be printed.</p>
</td></tr>
<tr><td><code id="gpr_+3A_ninitcandidates">nInitCandidates</code></td>
<td>
<p>Number of initial hyperparameter vectors. The
optimization starts with the best.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most important function of the package. It fits the GPR model
and stores everything necessary for prediction. The optimization used in
the function is 'nlminb'. The names for the hyperparameters should be:
&quot;linear.a&quot; for linear covariance function, &quot;pow.ex.w&quot;, &quot;pow.ex.v&quot; for power
exponential, &quot;rat.qu.s&quot;, &quot;rat.qu.a&quot; for rational quadratic, &quot;matern.w&quot;,
&quot;matern.v&quot; for Matern, &quot;vv&quot; for variance of Gaussian white noise. All
hyperparameters should be in one list.
</p>


<h3>Value</h3>

<p>A list containing: </p>
 <dl>
<dt>hyper</dt><dd><p>Hyperparameters vector
estimated from training data</p>
</dd> <dt>var.hyper</dt><dd><p> Variance of the estimated
hyperparameters</p>
</dd> <dt>fitted.mean </dt><dd><p>Fitted values for the training data </p>
</dd>
<dt>fitted.sd </dt><dd><p>Standard deviation of the fitted values for the training 
data</p>
</dd>
<dt>train.x </dt><dd><p> Training covariates</p>
</dd> <dt>train.y </dt><dd><p> Training response</p>
</dd>
<dt> train.yOri</dt><dd><p>Original training response </p>
</dd> <dt>train.DataOri </dt><dd>
<p>Original training covariates</p>
</dd> <dt>idxSubset </dt><dd><p>Index vector identifying
which observations were selected if Subset of Data was used.</p>
</dd> <dt>
CovFun</dt><dd><p> Covariance function type</p>
</dd> <dt> gamma</dt><dd><p>Parameter used in powered
exponential covariance function </p>
</dd> <dt>nu </dt><dd><p>Parameter used in Matern
covariance function </p>
</dd> <dt>Q</dt><dd><p>Covariance matrix </p>
</dd> <dt>mean</dt><dd><p>Mean
function </p>
</dd> <dt>meanModel</dt><dd><p>Mean model used</p>
</dd> <dt>meanLinearModel</dt><dd><p>'lm'
object if mean is a linear regression. NULL otherwise.</p>
</dd> <dt>conv</dt><dd><p>An
integer. 0 means converge; 1 otherwise. </p>
</dd> <dt>hyper0</dt><dd><p>Starting point of
the hyperparameters vector.</p>
</dd> </dl>



<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional Data&rdquo;, CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignettes:

# vignette("gpr_ex1", package = "GPFDA")
# vignette("gpr_ex2", package = "GPFDA")
# vignette("co2", package = "GPFDA")
</code></pre>

<hr>
<h2 id='gprPredict'>Prediction of GPR model</h2><span id='topic+gprPredict'></span>

<h3>Description</h3>

<p>Prediction of GPR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprPredict(
  train = NULL,
  inputNew = NULL,
  noiseFreePred = F,
  hyper = NULL,
  input = NULL,
  Y = NULL,
  mSR = NULL,
  Cov = NULL,
  gamma = NULL,
  nu = NULL,
  meanModel = 0,
  mu = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprPredict_+3A_train">train</code></td>
<td>
<p>A 'gpr' object obtained from 'gpr' function. Default to NULL. If
NULL, learning is done based on the other given arguments; otherwise,
prediction is made based on the trained model of class gpr'.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_inputnew">inputNew</code></td>
<td>
<p>Test input covariates.  It must be either a matrix, where
each column represents a covariate, or a vector if there is only one
covariate.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_noisefreepred">noiseFreePred</code></td>
<td>
<p>Logical. If TRUE, predictions will be noise-free.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_hyper">hyper</code></td>
<td>
<p>The hyperparameters. Default to NULL. If not NULL, then it must
be a list with appropriate names.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_input">input</code></td>
<td>
<p>Input covariates. It must be either a matrix, where each column
represents a covariate, or a vector if there is only one covariate.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_y">Y</code></td>
<td>
<p>Training response. It should be a matrix, where each column is a
realisation. It can be a vector if there is only one realisation.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_msr">mSR</code></td>
<td>
<p>Subset size m if Subset of Regressors method is used for
prediction. It must be smaller than the total sample size.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_cov">Cov</code></td>
<td>
<p>Covariance function(s) to use. Options are: 'linear', 'pow.ex',
'rat.qu', and 'matern'. Default to 'power.ex'.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_meanmodel">meanModel</code></td>
<td>
<p>Type of mean function. It can be </p>
 <dl>
<dt>0</dt><dd><p>Zero
mean function</p>
</dd> <dt>1</dt><dd><p>Constant mean function to be estimated</p>
</dd>
<dt>'t'</dt><dd><p>Linear model for the mean function</p>
</dd> <dt>'avg'</dt><dd><p>The average
across replications is used as the mean function. This is only used if
there are more than two realisations observed at the same input coordinate
values.</p>
</dd> </dl>
<p> Default to 0. If argument 'mu' is specified, then 'meanModel'
will be set to 'userDefined'.</p>
</td></tr>
<tr><td><code id="gprPredict_+3A_mu">mu</code></td>
<td>
<p>Mean function specified by the user. It must be a vector. Its
length must be the same as the sample size, that is, nrow(response).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing  </p>
 <dl>
<dt>pred.mean</dt><dd><p>Mean of predictions</p>
</dd>
<dt>pred.sd</dt><dd><p>Standard deviation of predictions</p>
</dd> <dt>newdata</dt><dd><p>Test input 
data</p>
</dd>
<dt>noiseFreePred</dt><dd><p>Logical. If TRUE, predictions are noise-free.</p>
</dd>
<dt>...</dt><dd><p>Objects of 'gpr' class. </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignettes:

# vignette("gpr_ex1", package = "GPFDA")
# vignette("gpr_ex2", package = "GPFDA")
# vignette("co2", package = "GPFDA")
</code></pre>

<hr>
<h2 id='mat2fd'>Create an 'fd' object from a matrix</h2><span id='topic+mat2fd'></span>

<h3>Description</h3>

<p>Easy setting up for creating an 'fd' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2fd(mat, fdList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2fd_+3A_mat">mat</code></td>
<td>
<p>Input data, should be a matrix with ncol time points and nrow
replications or samples.</p>
</td></tr>
<tr><td><code id="mat2fd_+3A_fdlist">fdList</code></td>
<td>
<p>A list with following items: </p>
 <dl>
<dt>time</dt><dd><p>Sequence
of time points (default to be 100 points from 0 to 1).</p>
</dd>
<dt>nbasis</dt><dd><p>Number of basis functions used in smoothing, default to be
less or equal to 23.</p>
</dd> <dt>norder</dt><dd><p>Order of the functional curves default
to be 6.</p>
</dd> <dt>bSpline</dt><dd><p>Logical, if TRUE (default), b-Spline basis is
used; otherwise, Fourier basis is used.</p>
</dd> <dt>Pen</dt><dd><p>Default to be c(0,0),
meaning that the penalty is on the second order derivative of the curve,
since the weight for zero-th and first order derivatives of the curve are
set to zero.</p>
</dd> <dt>lambda</dt><dd><p>Smoothing parameter for the penalty. Default to
be 1e-4.</p>
</dd> </dl>
</td></tr>
</table>


<h3>Details</h3>

<p>All items listed above have default values. If any item is required
to change, add that item into the list; otherwise, leave it as NULL. For
example, if one only wants to change the number of basis functions, do:
</p>
<p><code>mat2fd(SomeMatrix,list(nbasis=21))</code>
</p>


<h3>Value</h3>

<p>An 'fd' object
</p>


<h3>References</h3>

<p>Ramsay, J., and Silverman, B. W. (2006),
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(fda)
require(fda.usc)
nrep &lt;- 20   # number of replications
n &lt;- 100     # number of time points
input &lt;- seq(-1, pi, length.out=n) # time points
ry &lt;- rnorm(nrep, sd=10)
y &lt;- matrix(NA, ncol=n, nrow=nrep)
for(i in 1:nrep)  y[i,] &lt;- sin(2*input)*ry[i]

plot.fdata(fdata(y,input))

yfd &lt;- mat2fd(y, list(lambda=0.01))
plot(yfd)

yfd &lt;- mat2fd(y, list(lambda=0.00001))
plot(yfd)

</code></pre>

<hr>
<h2 id='mgpCovMat'>Calculate a multivariate Gaussian processes covariance matrix given a
vector of hyperparameters</h2><span id='topic+mgpCovMat'></span>

<h3>Description</h3>

<p>Calculate a multivariate Gaussian processes covariance matrix given a
vector of hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgpCovMat(Data, hp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgpCovMat_+3A_data">Data</code></td>
<td>
<p>List of two elements: 'input' and 'response'. The element 'input'
is a list of N vectors, where each vector represents the input covariate
values for a particular output. The element 'response' is the corresponding
list of N matrices (if there are multiple realisations) or vectors (for a
single realisation) representing the response variables.</p>
</td></tr>
<tr><td><code id="mgpCovMat_+3A_hp">hp</code></td>
<td>
<p>Vector of hyperparameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariance matrix
</p>


<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional Data&rdquo;, CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("mgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='mgpr'>Multivariate Gaussian process regression (MGPR) model</h2><span id='topic+mgpr'></span>

<h3>Description</h3>

<p>Multivariate Gaussian process regression where each of the N
outputs is unidimensional. The multivariate output is allowed to have
multiple independent realisations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgpr(Data, m = NULL, meanModel = 0, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgpr_+3A_data">Data</code></td>
<td>
<p>List of two elements: 'input' and 'response'. The element 'input'
is a list of N vectors, where each vector represents the input covariate
values for a particular output. The element 'response' is the corresponding
list of N matrices (if there are multiple realisations) or vectors (for a
single realisation) representing the response variables.</p>
</td></tr>
<tr><td><code id="mgpr_+3A_m">m</code></td>
<td>
<p>If Subset of Data is to be used in the estimation, m denotes the
subset size. It cannot be larger than the total sample size. Default to
NULL (Subsetting is not used).</p>
</td></tr>
<tr><td><code id="mgpr_+3A_meanmodel">meanModel</code></td>
<td>
<p>Type of mean function applied to all outputs. It can be
</p>
 <dl>
<dt>0</dt><dd><p>Zero mean function for each output.</p>
</dd> <dt>1</dt><dd><p>Constant
mean function to be estimated for each output.</p>
</dd> <dt>'t'</dt><dd><p>Linear model for
the mean function of each output.</p>
</dd> <dt>'avg'</dt><dd><p>The average across
replications is used as the mean function of each output. This can only be
used if there are more than two realisations observed at the same input
values.</p>
</dd> </dl>
<p> Default to 0. If argument 'mu' is specified, then 'meanModel'
will be set to 'userDefined'.</p>
</td></tr>
<tr><td><code id="mgpr_+3A_mu">mu</code></td>
<td>
<p>Vector of concatenated mean function values defined by the user.
Default to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing: </p>
 <dl>
<dt>fitted.mean </dt><dd><p>Fitted values for
the training data </p>
</dd> <dt>fitted.sd </dt><dd><p>Standard deviation of the fitted
values for training data</p>
</dd> <dt>N</dt><dd><p>Number of response variables</p>
</dd>
<dt>X</dt><dd><p>Original input variables</p>
</dd>
<dt>Y</dt><dd><p>Original response</p>
</dd> <dt>idx</dt><dd><p>Index vector identifying to which 
output the elements of concatenated vectors correspond to.</p>
</dd> 
<dt>Cov</dt><dd><p>Covariance matrix</p>
</dd> <dt>mean</dt><dd><p>Concatenated mean function </p>
</dd> 
<dt>meanModel</dt><dd><p>Mean model used for each output</p>
</dd> 
<dt>meanLinearModel</dt><dd><p>'lm' object for each output if the linear regression 
model is used for the mean functions. NULL otherwise.</p>
</dd> </dl>



<h3>References</h3>

<p>Shi, J. Q., and Choi, T. (2011), &ldquo;Gaussian Process Regression
Analysis for Functional Data&rdquo;, CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("mgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='mgprPredict'>Prediction of MGPR model</h2><span id='topic+mgprPredict'></span>

<h3>Description</h3>

<p>Prediction of MGPR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgprPredict(
  train,
  DataObs = NULL,
  DataNew,
  noiseFreePred = F,
  meanModel = NULL,
  mu = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgprPredict_+3A_train">train</code></td>
<td>
<p>A 'mgpr' object obtained from 'mgpr' function. 
If NULL, predictions are made based on DataObs informed by the user.</p>
</td></tr>
<tr><td><code id="mgprPredict_+3A_dataobs">DataObs</code></td>
<td>
<p>List of observed data. Default to NULL. If NULL,
predictions are made based on the trained data 
(included in the object of class 'mgpr') used for learning.</p>
</td></tr>
<tr><td><code id="mgprPredict_+3A_datanew">DataNew</code></td>
<td>
<p>List of test input data.</p>
</td></tr>
<tr><td><code id="mgprPredict_+3A_noisefreepred">noiseFreePred</code></td>
<td>
<p>Logical. If TRUE, predictions will be noise-free.</p>
</td></tr>
<tr><td><code id="mgprPredict_+3A_meanmodel">meanModel</code></td>
<td>
<p>Type of mean function applied to all outputs. It can be
</p>
 <dl>
<dt>0</dt><dd><p>Zero mean function for each output.</p>
</dd> <dt>1</dt><dd><p>Constant
mean function to be estimated for each output.</p>
</dd> <dt>'t'</dt><dd><p>Linear model for
the mean function of each output.</p>
</dd> <dt>'avg'</dt><dd><p>The average across
replications is used as the mean function of each output. This can only be
used if there are more than two realisations observed at the same input
values.</p>
</dd> </dl>
<p> Default to 0. If argument 'mu' is specified, then 'meanModel'
will be set to 'userDefined'.</p>
</td></tr>
<tr><td><code id="mgprPredict_+3A_mu">mu</code></td>
<td>
<p>Vector of concatenated mean function values defined by the user.
Default to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing  </p>
 <dl>
<dt>pred.mean</dt><dd><p>Mean of predictions 
for the test set.</p>
</dd>
<dt>pred.sd</dt><dd><p>Standard deviation of predictions for the test set.</p>
</dd>
<dt>noiseFreePred</dt><dd><p>Logical. If TRUE, predictions are noise-free.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("mgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='nsgpCovMat'>Calculate a NSGP covariance matrix given a vector of hyperparameters</h2><span id='topic+nsgpCovMat'></span>

<h3>Description</h3>

<p>Calculate a NSGP covariance matrix given a vector of hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgpCovMat(
  hp,
  input,
  inputSubsetIdx = NULL,
  nBasis = 5,
  corrModel = corrModel,
  gamma = NULL,
  nu = NULL,
  cyclic = NULL,
  whichTau = NULL,
  calcCov = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgpCovMat_+3A_hp">hp</code></td>
<td>
<p>Vector of hyperparameters estimated by function nsgpr.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_input">input</code></td>
<td>
<p>List of Q input variables (see Details).</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_inputsubsetidx">inputSubsetIdx</code></td>
<td>
<p>A list identifying a subset of the input values to be
used in the estimation (see Details).</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_nbasis">nBasis</code></td>
<td>
<p>Number of B-spline basis functions in each coordinate direction
along which parameters change.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_corrmodel">corrModel</code></td>
<td>
<p>Correlation function specification used for g(.). It can be
either &quot;pow.ex&quot; or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_cyclic">cyclic</code></td>
<td>
<p>Logical vector of dimension Q which defines which covariates
are cyclic (periodic). For example, if basis functions should be cyclic
only in the first coordinate direction, then cyclic=c(T,F). cyclic must
have the same dimension of whichTau. If cyclic is TRUE for some coordinate
direction, then cyclic B-spline functions will be used and the varying
parameters (and their first two derivatives) will match at the boundaries
of that coordinate direction.</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_whichtau">whichTau</code></td>
<td>
<p>Logical vector of dimension Q identifying which input
coordinates the parameters are function of. For example, if Q=2 and
parameters change only with respect to the first coordinate, then we set
whichTau=c(T,F).</p>
</td></tr>
<tr><td><code id="nsgpCovMat_+3A_calccov">calcCov</code></td>
<td>
<p>Logical. Calculate covariance matrix or not. If FALSE, time or
spatially-varying parameters are still provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing  </p>
 
<dl>
<dt>Cov</dt><dd><p>Covariance matrix</p>
</dd>
<dt>vareps</dt><dd><p>Noise variance</p>
</dd>
<dt>As_perTau</dt><dd><p>List of varying anisotropy matrix over the input space</p>
</dd>
<dt>sig2_perTau</dt><dd><p>Vector of signal variance over the input space</p>
</dd>
</dl>



<h3>References</h3>

<p>Konzen, E., Shi, J. Q. and Wang, Z. (2020) &quot;Modeling
Function-Valued Processes with Nonseparable and/or Nonstationary Covariance
Structure&quot; &lt;arXiv:1903.09981&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("nsgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='nsgpCovMatAsym'>Calculate an asymmetric NSGP covariance matrix</h2><span id='topic+nsgpCovMatAsym'></span>

<h3>Description</h3>

<p>Calculate an asymmetric NSGP covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgpCovMatAsym(
  hp,
  input,
  inputNew,
  nBasis = 5,
  corrModel = corrModel,
  gamma = NULL,
  nu = NULL,
  cyclic = NULL,
  whichTau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgpCovMatAsym_+3A_hp">hp</code></td>
<td>
<p>Vector of hyperparameters estimated by function nsgpr.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_input">input</code></td>
<td>
<p>List of Q input variables (see Details).</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_inputnew">inputNew</code></td>
<td>
<p>List of Q test set input variables.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_nbasis">nBasis</code></td>
<td>
<p>Number of B-spline basis functions in each coordinate direction
along which parameters change.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_corrmodel">corrModel</code></td>
<td>
<p>Correlation function specification used for g(.). It can be
either &quot;pow.ex&quot; or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_cyclic">cyclic</code></td>
<td>
<p>Logical vector of dimension Q which defines which covariates
are cyclic (periodic). For example, if basis functions should be cyclic
only in the first coordinate direction, then cyclic=c(T,F). cyclic must
have the same dimension of whichTau. If cyclic is TRUE for some coordinate
direction, then cyclic B-spline functions will be used and the varying
parameters (and their first two derivatives) will match at the boundaries
of that coordinate direction.</p>
</td></tr>
<tr><td><code id="nsgpCovMatAsym_+3A_whichtau">whichTau</code></td>
<td>
<p>Logical vector of dimension Q identifying which input
coordinates the parameters are function of. For example, if Q=2 and
parameters change only with respect to the first coordinate, then we set
whichTau=c(T,F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An asymmetric covariance matrix
</p>


<h3>References</h3>

<p>Konzen, E., Shi, J. Q. and Wang, Z. (2020) &quot;Modeling
Function-Valued Processes with Nonseparable and/or Nonstationary Covariance
Structure&quot; &lt;arXiv:1903.09981&gt;.
</p>

<hr>
<h2 id='nsgpr'>Estimation of a nonseparable and/or nonstationary covariance structure (NSGPR
model)</h2><span id='topic+nsgpr'></span>

<h3>Description</h3>

<p>Estimate the covariance structure of a zero-mean Gaussian Process with
Q-dimensional input coordinates (covariates). <br />  <br /> Multiple realisations
for the response variable can be used, provided they are observed on the same
grid of dimension n_1 x n_2 x ... x n_Q.<br /> <br /> Let n = n_1 x n_2 x ... x n_Q
and let nSamples be the number of realisations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgpr(
  response,
  input,
  corrModel = "pow.ex",
  gamma = 2,
  nu = 1.5,
  whichTau = NULL,
  nBasis = 5,
  cyclic = NULL,
  unitSignalVariance = F,
  zeroNoiseVariance = F,
  sepCov = F,
  nInitCandidates = 300,
  absBounds = 6,
  inputSubsetIdx = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgpr_+3A_response">response</code></td>
<td>
<p>Response variable. This should be a (n x nSamples) matrix
where each column is a realisation</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_input">input</code></td>
<td>
<p>List of Q input variables (see Details).</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_corrmodel">corrModel</code></td>
<td>
<p>Correlation function specification used for g(.). It can be
either &quot;pow.ex&quot; or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_whichtau">whichTau</code></td>
<td>
<p>Logical vector of dimension Q identifying which input
coordinates the parameters are function of. For example, if Q=2 and
parameters change only with respect to the first coordinate, then we set
whichTau=c(T,F).</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_nbasis">nBasis</code></td>
<td>
<p>Number of B-spline basis functions in each coordinate direction
along which parameters change.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_cyclic">cyclic</code></td>
<td>
<p>Logical vector of dimension Q which defines which covariates
are cyclic (periodic). For example, if basis functions should be cyclic
only in the first coordinate direction, then cyclic=c(T,F). cyclic must
have the same dimension of whichTau. If cyclic is TRUE for some coordinate
direction, then cyclic B-spline functions will be used and the varying
parameters (and their first two derivatives) will match at the boundaries
of that coordinate direction.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_unitsignalvariance">unitSignalVariance</code></td>
<td>
<p>Logical. TRUE if we assume realisations have
variance 1. This is useful when we want to estimate an NSGP correlation
function.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_zeronoisevariance">zeroNoiseVariance</code></td>
<td>
<p>Logical. TRUE if we assume the realisations are
noise-free.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_sepcov">sepCov</code></td>
<td>
<p>Logical. TRUE only if we fix to zero all off-diagonal elements
of the varying anisotropy matrix. Default to FALSE, allowing for a
separable covariance function.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_ninitcandidates">nInitCandidates</code></td>
<td>
<p>number of initial hyperparameter vectors which are
used to evaluate the log-likelihood function at a first step. After
evaluating the log-likelihood using these 'nInitCandidates' vectors, the
optimisation via nlminb() begins with the best of these vectors.</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_absbounds">absBounds</code></td>
<td>
<p>lower and upper boundaries for B-spline coefficients (if
wanted).</p>
</td></tr>
<tr><td><code id="nsgpr_+3A_inputsubsetidx">inputSubsetIdx</code></td>
<td>
<p>A list identifying a subset of the input values to be
used in the estimation (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument for Q=2 can be constructed as follows: 
</p>
<pre>
  n1 &lt;- 10
  n2 &lt;- 1000
  input &lt;- list()
  input[[1]] &lt;- seq(0,1,length.out = n1)
  input[[2]] &lt;- seq(0,1,length.out = n2)
 </pre>
<p>If we want to use every third lattice point in
the second input variable (using Subset of Data), then we can set
</p>
<pre>
  inputSubsetIdx &lt;- list()
  inputSubsetIdx[[1]] &lt;- 1:n1
  inputSubsetIdx[[2]] &lt;- seq(1,n2, by=3)
 </pre>


<h3>Value</h3>

<p>A list containing:  </p>
 <dl>
<dt>MLEsts</dt><dd><p>Maximum likelihood
estimates of B-spline coefficients and noise variance.</p>
</dd>
<dt>response</dt><dd><p>Matrix of response.</p>
</dd> <dt>inputMat</dt><dd><p>Input coordinates in a
matrix form</p>
</dd> <dt>corrModel</dt><dd><p>Correlation function specification used for
g(.)</p>
</dd> </dl>



<h3>References</h3>

<p>Konzen, E., Shi, J. Q. and Wang, Z. (2020) &quot;Modeling
Function-Valued Processes with Nonseparable and/or Nonstationary Covariance
Structure&quot; &lt;arXiv:1903.09981&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("nsgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='nsgprPredict'>Prediction of NSGPR model</h2><span id='topic+nsgprPredict'></span>

<h3>Description</h3>

<p>Prediction of NSGPR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgprPredict(
  hp,
  response,
  input,
  inputNew,
  noiseFreePred = F,
  nBasis = nBasis,
  corrModel = corrModel,
  gamma = gamma,
  nu = nu,
  cyclic = cyclic,
  whichTau = whichTau
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgprPredict_+3A_hp">hp</code></td>
<td>
<p>Vector of hyperparameters estimated by function nsgpr.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_response">response</code></td>
<td>
<p>Response variable. This should be a (n x nSamples) matrix
where each column is a realisation</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_input">input</code></td>
<td>
<p>List of Q input variables (see Details).</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_inputnew">inputNew</code></td>
<td>
<p>List of Q test set input variables.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_noisefreepred">noiseFreePred</code></td>
<td>
<p>Logical.  If TRUE, predictions will be noise-free.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_nbasis">nBasis</code></td>
<td>
<p>Number of B-spline basis functions in each coordinate direction
along which parameters change.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_corrmodel">corrModel</code></td>
<td>
<p>Correlation function specification used for g(.). It can be
either &quot;pow.ex&quot; or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_cyclic">cyclic</code></td>
<td>
<p>Logical vector of dimension Q which defines which covariates
are cyclic (periodic). For example, if basis functions should be cyclic
only in the first coordinate direction, then cyclic=c(T,F). cyclic must
have the same dimension of whichTau. If cyclic is TRUE for some coordinate
direction, then cyclic B-spline functions will be used and the varying
parameters (and their first two derivatives) will match at the boundaries
of that coordinate direction.</p>
</td></tr>
<tr><td><code id="nsgprPredict_+3A_whichtau">whichTau</code></td>
<td>
<p>Logical vector of dimension Q identifying which input
coordinates the parameters are function of. For example, if Q=2 and
parameters change only with respect to the first coordinate, then we set
whichTau=c(T,F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing  </p>
 
<dl>
<dt>pred.mean</dt><dd><p>Mean of predictions for the test set.</p>
</dd>
<dt>pred.sd</dt><dd><p>Standard deviation of predictions for the test set.</p>
</dd>
<dt>noiseFreePred</dt><dd><p>Logical. If TRUE, predictions are noise-free.</p>
</dd>
</dl>



<h3>References</h3>

<p>Konzen, E., Shi, J. Q. and Wang, Z. (2020) &quot;Modeling
Function-Valued Processes with Nonseparable and/or Nonstationary Covariance
Structure&quot; &lt;arXiv:1903.09981&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("nsgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='plot.gpfr'>Plot GPFR model for either training or prediction</h2><span id='topic+plot.gpfr'></span>

<h3>Description</h3>

<p>Plot GPFR model for either training or prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpfr'
plot(
  x,
  type = c("raw", "meanFunction", "fitted", "prediction"),
  ylab = "y",
  xlab = "t",
  ylim = NULL,
  realisations = NULL,
  alpha = 0.05,
  colourTrain = 2,
  colourNew = 4,
  mar = c(4.5, 5.1, 2.2, 0.8),
  oma = c(0, 0, 1, 0),
  cex.lab = 1.5,
  cex.axis = 1,
  cex.main = 1.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gpfr_+3A_x">x</code></td>
<td>
<p>Plot GPFR for training or prediction from a given object of 'gpfr'
class.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_type">type</code></td>
<td>
<p>Required type of plots. Options are: 'raw',
'meanFunction', 'fitted' and 'prediction'.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_ylab">ylab</code></td>
<td>
<p>Title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_xlab">xlab</code></td>
<td>
<p>Title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter. If NULL (default), it is chosen automatically.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_realisations">realisations</code></td>
<td>
<p>Index vector identifying which training realisations
should be plotted. If NULL (default), all training realisations are plotted. 
For predictions, 'realisations' should be '0' if no training realisation 
is to be plotted.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_alpha">alpha</code></td>
<td>
<p>Significance level used for 'fitted' or 'prediction'. Default is 0.05.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_colourtrain">colourTrain</code></td>
<td>
<p>Colour for training realisations when 'type' is set to 
'prediction' and 'realisations' is positive.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_colournew">colourNew</code></td>
<td>
<p>Colour for predictive mean for the new curve when 'type' is 
set to 'prediction'.</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_mar">mar</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_oma">oma</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_cex.main">cex.main</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.gpfr_+3A_...">...</code></td>
<td>
<p>Other graphical parameters passed to plot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("gpfr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='plot.gpr'>Plot GPR model for either training or prediction</h2><span id='topic+plot.gpr'></span>

<h3>Description</h3>

<p>Plot Gaussian process for a given an object of class 'gpr'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpr'
plot(
  x,
  fitted = F,
  col.no = 1,
  ylim = NULL,
  realisation = NULL,
  main = NULL,
  cex.points = NULL,
  lwd.points = NULL,
  pch = NULL,
  lwd = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gpr_+3A_x">x</code></td>
<td>
<p>The 'gpr' object from either training or predicting of the Gaussian
Process.</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_fitted">fitted</code></td>
<td>
<p>Logical. Plot fitted values or not. Default to FALSE. If FALSE,
plot the predictions.</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_col.no">col.no</code></td>
<td>
<p>Column number of the input matrix. If the input matrix has more
than one columns, than one of them will be used in the plot. Default to be
the first one.</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_ylim">ylim</code></td>
<td>
<p>Range value for y-axis.</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_realisation">realisation</code></td>
<td>
<p>Integer identifying which realisation should be plotted
(if there are multiple).</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_main">main</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_cex.points">cex.points</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_lwd.points">lwd.points</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_pch">pch</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_lwd">lwd</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plot.gpr_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed to plot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("gpr_ex1", package = "GPFDA")
</code></pre>

<hr>
<h2 id='plot.mgpr'>Plot predictions of GPR model</h2><span id='topic+plot.mgpr'></span>

<h3>Description</h3>

<p>Plot predictons of each element of the multivariate Gaussian Process for a
given an object of class 'mgpr'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgpr'
plot(
  x,
  DataObs,
  DataNew,
  realisation,
  alpha = 0.05,
  ylim = NULL,
  mfrow = NULL,
  cex = 2,
  mar = c(4.5, 7.1, 0.2, 0.8),
  oma = c(0, 0, 0, 0),
  cex.lab = 2,
  cex.axis = 1.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgpr_+3A_x">x</code></td>
<td>
<p>An object of class 'mgpr'.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_dataobs">DataObs</code></td>
<td>
<p>List of observed data.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_datanew">DataNew</code></td>
<td>
<p>List of test data.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_realisation">realisation</code></td>
<td>
<p>Index identifying which realisation should be plotted.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_alpha">alpha</code></td>
<td>
<p>Significance level used for MGPR predictions. Default is 0.05.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_ylim">ylim</code></td>
<td>
<p>Range of y-axis.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_mfrow">mfrow</code></td>
<td>
<p>Graphical parameter.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_cex">cex</code></td>
<td>
<p>Graphical parameter.</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_mar">mar</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_oma">oma</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plot.mgpr_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed to plot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot showing predictions of each element of the multivariate
process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("mgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='plotImage'>Draw an image plot for a given two-dimensional input</h2><span id='topic+plotImage'></span>

<h3>Description</h3>

<p>Draw an image plot for a given two-dimensional input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImage(
  response,
  input,
  realisation = 1,
  n1,
  n2,
  main = " ",
  zlim = NULL,
  cex.axis = 1,
  cex.lab = 2.5,
  legend.cex.axis = 1,
  font.main = 2,
  cex.main = 2,
  legend.width = 2,
  mar = c(2.1, 2.1, 3.1, 6.1),
  oma = c(0, 1, 0, 0),
  nGrid = 200,
  enlarge_zlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImage_+3A_response">response</code></td>
<td>
<p>Data to be plotted (e.g. matrix of predictions)</p>
</td></tr>
<tr><td><code id="plotImage_+3A_input">input</code></td>
<td>
<p>Matrix of two columns representing the input coordinates.</p>
</td></tr>
<tr><td><code id="plotImage_+3A_realisation">realisation</code></td>
<td>
<p>Integer identifying which realisation should be plotted
(if there are multiple).</p>
</td></tr>
<tr><td><code id="plotImage_+3A_n1">n1</code></td>
<td>
<p>Number of datapoints in the first coordinate direction</p>
</td></tr>
<tr><td><code id="plotImage_+3A_n2">n2</code></td>
<td>
<p>Number of datapoints in the second coordinate direction</p>
</td></tr>
<tr><td><code id="plotImage_+3A_main">main</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plotImage_+3A_zlim">zlim</code></td>
<td>
<p>Range of z-axis</p>
</td></tr>
<tr><td><code id="plotImage_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_legend.cex.axis">legend.cex.axis</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_font.main">font.main</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_cex.main">cex.main</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_legend.width">legend.width</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_mar">mar</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_oma">oma</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotImage_+3A_ngrid">nGrid</code></td>
<td>
<p>Dimension of output grid in each coordinate direction</p>
</td></tr>
<tr><td><code id="plotImage_+3A_enlarge_zlim">enlarge_zlim</code></td>
<td>
<p>Additional quantity to increase the range of zlim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("gpr_ex2", package = "GPFDA")
</code></pre>

<hr>
<h2 id='plotmgpCovFun'>Plot auto- or cross-covariance function of a multivariate Gaussian process</h2><span id='topic+plotmgpCovFun'></span>

<h3>Description</h3>

<p>Plot auto- or cross-covariance function of a multivariate Gaussian process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmgpCovFun(
  type = "Cov",
  output,
  outputp,
  Data,
  hp,
  idx,
  ylim = NULL,
  xlim = NULL,
  mar = c(4.5, 5.1, 2.2, 0.8),
  oma = c(0, 0, 0, 0),
  cex.lab = 1.5,
  cex.axis = 1,
  cex.main = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmgpCovFun_+3A_type">type</code></td>
<td>
<p>Logical. It can be either 'Cov' (for covariance function) or
'Cor' (for corresponding correlation function).</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_output">output</code></td>
<td>
<p>Integer identifying one element of the multivariate process.</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_outputp">outputp</code></td>
<td>
<p>Integer identifying one element of the multivariate process.
If 'output' and 'outputp' are the same, the auto-covariance function will
be plotted. Otherwise, the cross-covariance function between 'output' and
'outputp' will be plotted.</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_data">Data</code></td>
<td>
<p>List of two elements: 'input' and 'response'. The element 'input'
is a list of N vectors, where each vector represents the input covariate
values for a particular output. The element 'response' is the corresponding
list of N matrices (if there are multiple realisations) or vectors (for a
single realisation) representing the response variables.</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_hp">hp</code></td>
<td>
<p>Vector of hyperparameters</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_idx">idx</code></td>
<td>
<p>Index vector identifying to which output the elements of
concatenated vectors correspond to.</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_xlim">xlim</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_mar">mar</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_oma">oma</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
<tr><td><code id="plotmgpCovFun_+3A_cex.main">cex.main</code></td>
<td>
<p>Graphical parameter passed to par().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("mgpr", package = "GPFDA")
</code></pre>

<hr>
<h2 id='unscaledCorr'>Calculate an unscaled NSGP correlation matrix</h2><span id='topic+unscaledCorr'></span>

<h3>Description</h3>

<p>Calculate an unscaled NSGP correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscaledCorr(Dist.mat, corrModel, gamma = NULL, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unscaledCorr_+3A_dist.mat">Dist.mat</code></td>
<td>
<p>Distance matrix</p>
</td></tr>
<tr><td><code id="unscaledCorr_+3A_corrmodel">corrModel</code></td>
<td>
<p>Correlation function specification used for g(.). It can be
either &quot;pow.ex&quot; or &quot;matern&quot;.</p>
</td></tr>
<tr><td><code id="unscaledCorr_+3A_gamma">gamma</code></td>
<td>
<p>Power parameter used in powered exponential kernel function. It
must be 0&lt;gamma&lt;=2.</p>
</td></tr>
<tr><td><code id="unscaledCorr_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter of the Matern class. It must be a positive
value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>References</h3>

<p>Konzen, E., Shi, J. Q. and Wang, Z. (2020) &quot;Modeling
Function-Valued Processes with Nonseparable and/or Nonstationary Covariance
Structure&quot; &lt;arXiv:1903.09981&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in vignette:
# vignette("nsgpr", package = "GPFDA")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
