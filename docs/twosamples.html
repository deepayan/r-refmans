<!DOCTYPE html><html><head><title>Help for package twosamples</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {twosamples}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ad_test'><p>Anderson-Darling Test</p></a></li>
<li><a href='#combine.twosamples'><p>Combine two objects of class <code>twosamples</code></p></a></li>
<li><a href='#cvm_test'><p>Cramer-von Mises Test</p></a></li>
<li><a href='#ks_test'><p>Kolmogorov-Smirnov Test</p></a></li>
<li><a href='#kuiper_test'><p>Kuiper Test</p></a></li>
<li><a href='#permutation_test_builder'><p>Permutation Test Builder</p></a></li>
<li><a href='#plot.twosamples'><p>Default plots for <code>twosamples</code> objects</p></a></li>
<li><a href='#print.twosamples'><p>twosamples_class</p></a></li>
<li><a href='#two_sample'><p>DTS Test</p></a></li>
<li><a href='#wass_test'><p>Wasserstein Distance Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Permutation Based Two Sample Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast randomization based two sample tests. 
  Testing the hypothesis that two samples come from the same distribution using randomization to create p-values. Included tests are: Kolmogorov-Smirnov, Kuiper, Cramer-von Mises, Anderson-Darling, Wasserstein, and DTS. The default test (two_sample) is based on the DTS test statistic, as it is the most powerful, and thus most useful to most users. 
  The DTS test statistic builds on the Wasserstein distance by using a weighting scheme like that of Anderson-Darling. See the companion paper at &lt;<a href="https://arxiv.org/abs/2007.01360">arXiv:2007.01360</a>&gt; or <a href="https://codowd.com/public/DTS.pdf">https://codowd.com/public/DTS.pdf</a> for details of that test statistic, and non-standard uses of the package (parallel for big N, weighted observations, one sample tests, etc). We also include the permutation scheme to make test building simple for others.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://twosampletest.com">https://twosampletest.com</a>, <a href="https://github.com/cdowd/twosamples">https://github.com/cdowd/twosamples</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cdowd/twosamples/issues">https://github.com/cdowd/twosamples/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-23 18:50:48 UTC; cdowd</td>
</tr>
<tr>
<td>Author:</td>
<td>Connor Dowd <a href="https://orcid.org/0000-0002-9782-0931"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Connor Dowd &lt;cd@codowd.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-23 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ad_test'>Anderson-Darling Test</h2><span id='topic+ad_test'></span><span id='topic+ad_stat'></span>

<h3>Description</h3>

<p>A two-sample test based on the Anderson-Darling test statistic (<code>ad_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ad_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

ad_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ad_test_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="ad_test_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="ad_test_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="ad_test_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="ad_test_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="ad_test_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="ad_test_+3A_power">power</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AD test compares two ECDFs by looking at the weighted sum of the squared differences between them &ndash; evaluated at each point in the joint sample. The weights are determined by the variance of the joint ECDF at that point, which peaks in the middle of the joint distribution (see figure below). Formally &ndash; if E is the ECDF of sample 1, F is the ECDF of sample 2, and G is the ECDF of the joint sample then </p>
<p style="text-align: center;"><code class="reqn">AD = \sum_{x \in k} \left({|E(x)-F(x)| \over \sqrt{2G(x)(1-G(x))/n} }\right)^p </code>
</p>
<p> where k is the joint sample. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample. Intuitively the AD test improves on the CVM test by giving lower weight to noisy observations.
</p>
<p>In the example plot below, we see the variance of the joint ECDF over the range of the data. It clearly peaks in the middle of the joint sample.
</p>
<p><img src="../help/figures/var.png" alt="Plot of Variance of joint ECDF" />
</p>
<p>In the example plot below, the AD statistic is the weighted sum of the heights of the vertical lines, where weights are represented by the shading of the lines.
</p>
<p><img src="../help/figures/ad.png" alt="Example AD stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ad_test()</code>: Permutation based two sample Anderson-Darling test
</p>
</li>
<li> <p><code>ad_stat()</code>: Permutation based two sample Anderson-Darling test
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code> for a more powerful test statistic. See <code><a href="#topic+cvm_test">cvm_test()</a></code> for the predecessor to this test statistic. See <code><a href="#topic+dts_test">dts_test()</a></code> for the natural successor to this test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = ad_test(vec1,vec2)
out
summary(out)
plot(out)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
ad_test(vec1,vec2)
</code></pre>

<hr>
<h2 id='combine.twosamples'>Combine two objects of class <code>twosamples</code></h2><span id='topic+combine.twosamples'></span>

<h3>Description</h3>

<p>This function combines two <code>twosamples</code> objects &ndash; concatenating bootstraps, recalculating pvalues, etc.
It only works if both objects were created with &quot;keep.boots=T&quot; This function is intended for one main purposes: combining parallized null calculations and then plotting those combined outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.twosamples(x, y, check.sample = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.twosamples_+3A_x">x</code></td>
<td>
<p>a twosamples object</p>
</td></tr>
<tr><td><code id="combine.twosamples_+3A_y">y</code></td>
<td>
<p>a different twosamples object from the same <code style="white-space: pre;">&#8288;*_test&#8288;</code> function run on the same data</p>
</td></tr>
<tr><td><code id="combine.twosamples_+3A_check.sample">check.sample</code></td>
<td>
<p>check that the samples saved in each object are the same? (can be slow)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a twosamples object that correctly re-calculates the p-value and determines all the other attributes
</p>


<h3>See Also</h3>

<p><a href="#topic+twosamples_class">twosamples_class</a>, <a href="#topic+plot.twosamples">plot.twosamples</a>, <a href="#topic+dts_test">dts_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec1 = rnorm(10)
vec2 = rnorm(10,1)
out1 = dts_test(vec1,vec2)
out2 = dts_test(vec1,vec2)
combined = combine.twosamples(out1,out2)
summary(out1)
summary(out2)
summary(combined)
plot(combined)
</code></pre>

<hr>
<h2 id='cvm_test'>Cramer-von Mises Test</h2><span id='topic+cvm_test'></span><span id='topic+cvm_stat'></span>

<h3>Description</h3>

<p>A two-sample test based on the Cramer-Von Mises test statistic (<code>cvm_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvm_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

cvm_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvm_test_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="cvm_test_+3A_power">power</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CVM test compares two ECDFs by looking at the sum of the squared differences between them &ndash; evaluated at each point in the joint sample. Formally &ndash; if E is the ECDF of sample 1 and F is the ECDF of sample 2, then </p>
<p style="text-align: center;"><code class="reqn">CVM = \sum_{x\in k}|E(x)-F(x)|^p</code>
</p>
<p> where k is the joint sample. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample. Intuitively the CVM test improves on KS by using the full joint sample, rather than just the maximum distance &ndash; this gives it greater power against shifts in higher moments, like variance changes.
</p>
<p>In the example plot below, the CVM statistic is the sum of the heights of the vertical black lines.
</p>
<p><img src="../help/figures/cvm.png" alt="Example CVM stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cvm_test()</code>: Permutation based two sample Cramer-Von Mises test
</p>
</li>
<li> <p><code>cvm_stat()</code>: Permutation based two sample Cramer-Von Mises test
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code> for a more powerful test statistic. See <code><a href="#topic+ks_test">ks_test()</a></code> or <code><a href="#topic+kuiper_test">kuiper_test()</a></code> for the predecessors to this test statistic. See <code><a href="#topic+wass_test">wass_test()</a></code> and <code><a href="#topic+ad_test">ad_test()</a></code> for the successors to this test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = cvm_test(vec1,vec2)
out
summary(out)
plot(out)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
cvm_test(vec1,vec2)
</code></pre>

<hr>
<h2 id='ks_test'>Kolmogorov-Smirnov Test</h2><span id='topic+ks_test'></span><span id='topic+ks_stat'></span>

<h3>Description</h3>

<p>A two-sample test using the Kolmogorov-Smirnov test statistic (<code>ks_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

ks_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks_test_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="ks_test_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="ks_test_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="ks_test_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="ks_test_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="ks_test_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="ks_test_+3A_power">power</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The KS test compares two ECDFs by looking at the maximum difference between them. Formally &ndash; if E is the ECDF of sample 1 and F is the ECDF of sample 2, then </p>
<p style="text-align: center;"><code class="reqn">KS = max |E(x)-F(x)|^p</code>
</p>
<p> for values of x in the joint sample. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample.
</p>
<p>In the example plot below, the KS statistic is the height of the vertical black line.
</p>
<p><img src="../help/figures/ks.png" alt="Example KS stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ks_test()</code>: Permutation based two sample Kolmogorov-Smirnov test
</p>
</li>
<li> <p><code>ks_stat()</code>: Permutation based two sample Kolmogorov-Smirnov test
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code> for a more powerful test statistic. See <code><a href="#topic+kuiper_test">kuiper_test()</a></code> or <code><a href="#topic+cvm_test">cvm_test()</a></code> for the natural successors to this test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = ks_test(vec1,vec2)
out
summary(out)
plot(out)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
ks_test(vec1,vec2)
</code></pre>

<hr>
<h2 id='kuiper_test'>Kuiper Test</h2><span id='topic+kuiper_test'></span><span id='topic+kuiper_stat'></span>

<h3>Description</h3>

<p>A two-sample test based on the Kuiper test statistic (<code>kuiper_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kuiper_test(
  a,
  b,
  nboots = 2000,
  p = default.p,
  keep.boots = T,
  keep.samples = F
)

kuiper_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kuiper_test_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_power">power</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kuiper test compares two ECDFs by looking at the maximum positive and negative difference between them. Formally &ndash; if E is the ECDF of sample 1 and F is the ECDF of sample 2, then </p>
<p style="text-align: center;"><code class="reqn">KUIPER = |max_x E(x)-F(x)|^p + |max_x F(x)-E(x)|^p</code>
</p>
<p>. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample.
</p>
<p>In the example plot below, the Kuiper statistic is the sum of the heights of the vertical black lines.
</p>
<p><img src="../help/figures/kuiper.png" alt="Example Kuiper stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>kuiper_test()</code>: Permutation based two sample Kuiper test
</p>
</li>
<li> <p><code>kuiper_stat()</code>: Permutation based two sample Kuiper test
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code> for a more powerful test statistic. See <code><a href="#topic+ks_test">ks_test()</a></code> for the predecessor to this test statistic, and <code><a href="#topic+cvm_test">cvm_test()</a></code> for its natural successor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = kuiper_test(vec1,vec2)
out
summary(out)
plot(out)


# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
kuiper_test(vec1,vec2)
</code></pre>

<hr>
<h2 id='permutation_test_builder'>Permutation Test Builder</h2><span id='topic+permutation_test_builder'></span>

<h3>Description</h3>

<p>(<strong>Warning!</strong> This function has changed substantially between v1.2.0 and v2.0.0) This function takes a two-sample test statistic and produces a function which performs randomization tests (sampling with replacement) using that test stat. This is an internal function of the <code>twosamples</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation_test_builder(test_stat_function, default.p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_test_builder_+3A_test_stat_function">test_stat_function</code></td>
<td>
<p>a function of the joint vector and a label vector producing a positive number, intended as the test-statistic to be used.</p>
</td></tr>
<tr><td><code id="permutation_test_builder_+3A_default.p">default.p</code></td>
<td>
<p>This allows for some introduction of defaults and parameters. Typically used to control the power functions raise something to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>test_stat_function must be structured to take two vectors &ndash; the first a combined sample vector and the second a logical vector indicating which sample each value came from, as well as a third and fourth value. i.e. (fun = function(jointvec,labelvec,val1,val2) ...). See examples.
</p>


<h4>Conversion Function</h4>

<p>Test stat functions designed to work with the prior version of <code>permutation_test_builder</code> will not work.
E.g. If your test statistic is
</p>
<div class="sourceCode"><pre>mean_diff_stat = function(x,y,pow) abs(mean(x)-mean(y))^pow
</pre></div>
<p>then <code>permutation_test_builder(mean_diff_stat,1)</code> will no longer work as intended, but it will if you run the below code first.
</p>
<div class="sourceCode"><pre>perm_stat_helper = function(stat_fn,def_power) {
  output = function(joint,vec_labels,power=def_power,na) {
    a = joint[vec_labels]
    b = joint[!vec_labels]
    stat_fn(a,b,power)
  }
  output
}

mean_diff_stat = perm_stat_helper(mean_diff_stat)
</pre></div>



<h3>Value</h3>

<p>This function returns a function which will perform permutation tests on given test stat.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>permutation_test_builder()</code>: Takes a test statistic, returns a testing function.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+two_sample">two_sample()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_stat = function(joint,label,p,na) abs(mean(joint[label])-mean(joint[!label]))**p
myfun = twosamples:::permutation_test_builder(mean_stat,2.0)
set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = myfun(vec1,vec2)
out
summary(out)
plot(out)

</code></pre>

<hr>
<h2 id='plot.twosamples'>Default plots for <code>twosamples</code> objects</h2><span id='topic+plot.twosamples'></span>

<h3>Description</h3>

<p>Typically for now this will produce a histogram of the
null distribution based on the bootstrapped values,
with a vertical line marking the value of the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twosamples'
plot(x, plot_type = c("boots_hist"), nbins = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.twosamples_+3A_x">x</code></td>
<td>
<p>an object produced by one of the twosamples <code style="white-space: pre;">&#8288;*_test&#8288;</code> functions</p>
</td></tr>
<tr><td><code id="plot.twosamples_+3A_plot_type">plot_type</code></td>
<td>
<p>which plot to create? only current option is &quot;boots_hist&quot;,</p>
</td></tr>
<tr><td><code id="plot.twosamples_+3A_nbins">nbins</code></td>
<td>
<p>how many bins (or breaks) in the histogram</p>
</td></tr>
<tr><td><code id="plot.twosamples_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code>, <a href="#topic+twosamples_class">twosamples_class</a>, <a href="#topic+combine.twosamples">combine.twosamples</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out = dts_test(rnorm(10),rnorm(10,1))
plot(out)

</code></pre>

<hr>
<h2 id='print.twosamples'>twosamples_class</h2><span id='topic+print.twosamples'></span><span id='topic+summary.twosamples'></span><span id='topic+twosamples_class'></span>

<h3>Description</h3>

<p>Objects of Class twosamples are output by all of the <code style="white-space: pre;">&#8288;*_test&#8288;</code> functions in the <code>twosamples</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twosamples'
print(x, ...)

## S3 method for class 'twosamples'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.twosamples_+3A_x">x</code></td>
<td>
<p>twosamples object</p>
</td></tr>
<tr><td><code id="print.twosamples_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to print or summary functions</p>
</td></tr>
<tr><td><code id="print.twosamples_+3A_object">object</code></td>
<td>
<p>twosamples-object to summarize</p>
</td></tr>
<tr><td><code id="print.twosamples_+3A_alpha">alpha</code></td>
<td>
<p>Significance threshold for determining null rejection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default they consist of:a length 2 vector, the first item being the test statistic, the second the p-value.
That vector has the following attributes:
</p>

<ol>
<li><p> details: length 3 vector with the sample sizes for each sample and the number of bootstraps
</p>
</li>
<li><p> test_type: a string describing the type of the test statistic
</p>
</li></ol>

<p>It may also have two more attributes, depending on options used when running the <code style="white-space: pre;">&#8288;*_test&#8288;</code> function. These are useful for plotting and combining test runs.
</p>

<ol>
<li><p> bootstraps: a vector containing all the bootstrapped null values
</p>
</li>
<li><p> samples: a list containing both the samples that were tested
</p>
</li></ol>

<p>and by virtue of being a named length 2 vector of class &quot;twosamples&quot; it has the following two attributes:
</p>

<ol>
<li><p> names: c(&quot;Test Stat&quot;,&quot;P-Value&quot;)
</p>
</li>
<li><p> class: &quot;twosamples&quot;
</p>
</li></ol>

<p>Multiple Twosamples objects made by the same <code style="white-space: pre;">&#8288;*_test&#8288;</code> routine being run on the same data can be combined (getting correct p-value and correct attributes) with the function <code>combine_twosamples()</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>print.twosamples()</code> returns nothing
</p>
</li>
<li> <p><code>summarize.twosamples()</code> returns nothing
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>print(twosamples)</code>: Print method for objects of class twosamples
</p>
</li>
<li> <p><code>summary(twosamples)</code>: Summary method for objects of class twosamples
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot.twosamples">plot.twosamples()</a></code>, <code><a href="#topic+combine.twosamples">combine.twosamples()</a></code>
</p>

<hr>
<h2 id='two_sample'>DTS Test</h2><span id='topic+two_sample'></span><span id='topic+dts_test'></span><span id='topic+dts_stat'></span>

<h3>Description</h3>

<p>A two-sample test based on the DTS test statistic (<code>dts_stat</code>). This is the recommended two-sample test in this package because of its power. The DTS statistic is the reweighted integral of the distance between the two ECDFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dts_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

two_sample(
  a,
  b,
  nboots = 2000,
  p = default.p,
  keep.boots = T,
  keep.samples = F
)

dts_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_sample_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="two_sample_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="two_sample_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="two_sample_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="two_sample_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="two_sample_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="two_sample_+3A_power">power</code></td>
<td>
<p>also the power to raise the test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DTS test compares two ECDFs by looking at the reweighted Wasserstein distance between the two. See the companion paper at <a href="https://arxiv.org/abs/2007.01360">arXiv:2007.01360</a> or <a href="https://codowd.com/public/DTS.pdf">https://codowd.com/public/DTS.pdf</a> for details of this test statistic, and non-standard uses of the package (parallel for big N, weighted observations, one sample tests, etc).
</p>
<p>If the <code><a href="#topic+wass_test">wass_test()</a></code> extends <code><a href="#topic+cvm_test">cvm_test()</a></code> to interval data, then <code><a href="#topic+dts_test">dts_test()</a></code> extends <code><a href="#topic+ad_test">ad_test()</a></code> to interval data. Formally &ndash; if E is the ECDF of sample 1, F is the ECDF of sample 2, and G is the ECDF of the combined sample, then </p>
<p style="text-align: center;"><code class="reqn">DTS = \int_{x\in R} \left({|E(x)-F(x)| \over \sqrt{2G(x)(1-G(x))/n}}\right)^p</code>
</p>
<p> for all x.
The test p-value is calculated by randomly resampling two samples of the same size using the combined sample. Intuitively the DTS test improves on the AD test by allowing more extreme observations to carry more weight. At a higher level &ndash; CVM/AD/KS/etc only require ordinal data. DTS (and Wasserstein) gain power because they take advantages of the properties of interval data &ndash; i.e. the distances have some meaning. However, DTS, like Anderson-Darling (AD) also downweights noisier observations relative to Wass, thus (hopefully) giving it extra power.
</p>
<p>In the example plot below, the DTS statistic is the shaded area between the ECDFs, weighted by the variances &ndash; shown by the color of the shading.
</p>
<p><img src="../help/figures/dts.png" alt="Example Wasserstein stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power. The dts test will assume the distance between adjacent factors is 1.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dts_test()</code>: Permutation based two sample test
</p>
</li>
<li> <p><code>two_sample()</code>: Recommended two-sample test
</p>
</li>
<li> <p><code>dts_stat()</code>: Permutation based two sample test
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+wass_test">wass_test()</a></code>, <code><a href="#topic+ad_test">ad_test()</a></code> for the predecessors of this test statistic. <a href="https://arxiv.org/abs/2007.01360">arXiv:2007.01360</a> or <a href="https://codowd.com/public/DTS.pdf">https://codowd.com/public/DTS.pdf</a> for details of this test statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
dts_stat(vec1,vec2)
out = dts_test(vec1,vec2)
out
summary(out)
plot(out)
two_sample(vec1,vec2)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
dts_test(vec1,vec2)
</code></pre>

<hr>
<h2 id='wass_test'>Wasserstein Distance Test</h2><span id='topic+wass_test'></span><span id='topic+wass_stat'></span>

<h3>Description</h3>

<p>A two-sample test based on Wasserstein's distance (<code>wass_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wass_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

wass_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wass_test_+3A_a">a</code></td>
<td>
<p>a vector of numbers (or factors &ndash; see details)</p>
</td></tr>
<tr><td><code id="wass_test_+3A_b">b</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="wass_test_+3A_nboots">nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="wass_test_+3A_p">p</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
<tr><td><code id="wass_test_+3A_keep.boots">keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td></tr>
<tr><td><code id="wass_test_+3A_keep.samples">keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td></tr>
<tr><td><code id="wass_test_+3A_power">power</code></td>
<td>
<p>power to raise test stat to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wasserstein test compares two ECDFs by looking at the Wasserstein distance between the two. This is of course the area between the two ECDFs. Formally &ndash; if E is the ECDF of sample 1 and F is the ECDF of sample 2, then </p>
<p style="text-align: center;"><code class="reqn">WASS = \int_{x \in R} |E(x)-F(x)|^p</code>
</p>
<p> across all x. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample. Intuitively the Wasserstein test improves on CVM by allowing more extreme observations to carry more weight. At a higher level &ndash; CVM/AD/KS/etc only require ordinal data. Wasserstein gains its power because it takes advantages of the properties of interval data &ndash; i.e. the distances have some meaning.
</p>
<p>In the example plot below, the Wasserstein statistic is the shaded area between the ECDFs.
</p>
<p><img src="../help/figures/wass.png" alt="Example Wasserstein stat plot" />
</p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power. <code>wass_test</code> will assume the distance between adjacent factors is 1.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes &ndash; the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wass_test()</code>: Permutation based two sample test using Wasserstein metric
</p>
</li>
<li> <p><code>wass_stat()</code>: Permutation based two sample test using Wasserstein metric
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+dts_test">dts_test()</a></code> for a more powerful test statistic. See <code><a href="#topic+cvm_test">cvm_test()</a></code> for the predecessor to this test statistic. See <code><a href="#topic+dts_test">dts_test()</a></code> for the natural successor of this test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = wass_test(vec1,vec2)
out
summary(out)
plot(out)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
wass_test(vec1,vec2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
