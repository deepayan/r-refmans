<!DOCTYPE html><html><head><title>Help for package multifamm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multifamm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_var'><p>Compute the Number of FPCs needed</p></a></li>
<li><a href='#conduct_mfpca'><p>Conduct the MFPCA</p></a></li>
<li><a href='#extract_components'><p>Extract Model Components to be Compared</p></a></li>
<li><a href='#extract_components_uni'><p>Extract Model Components to be Compared from Univariate Model</p></a></li>
<li><a href='#extract_var_info'><p>Extract Variance Information from MFPCA Object</p></a></li>
<li><a href='#multiFAMM'><p>Multivariate Functional Additive Mixed Model Regression</p></a></li>
<li><a href='#phonetic'><p>Phonetic data</p></a></li>
<li><a href='#phonetic_subset'><p>Phonetic data (subset)</p></a></li>
<li><a href='#predict_mean'><p>Predict The Mean Function For the FPC Plots</p></a></li>
<li><a href='#prepare_mfpca'><p>Prepare Information Necessary for MFPCA</p></a></li>
<li><a href='#prune_mfpc'><p>Prune the MFPC object to include only a prespecified level of explained var</p></a></li>
<li><a href='#refit_for_weights'><p>Refit the model under an independence assumption</p></a></li>
<li><a href='#snooker'><p>Snooker data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Functional Additive Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation for multivariate functional additive mixed
    models (multiFAMM), see Volkmann et al. (2021, &lt;<a href="https://doi.org/10.48550/arXiv.2103.06606">doi:10.48550/arXiv.2103.06606</a>&gt;). It builds on developed methods for univariate sparse 
    functional regression models and multivariate functional principal component
    analysis. This package contains the function to run a multiFAMM and some
    convenience functions useful when working with large models. An additional 
    package on GitHub contains more convenience functions to reproduce the 
    analyses of the corresponding paper 
    (<a href="https://github.com/alexvolkmann/multifammPaper">https://github.com/alexvolkmann/multifammPaper</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, funData, MFPCA (&ge; 1.3-2), mgcv, sparseFLMM (&gt;
0.3.0), stats, zoo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-24 10:04:19 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Volkmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Volkmann &lt;alexandervolkmann8@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-28 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_var'>Compute the Number of FPCs needed</h2><span id='topic+compute_var'></span>

<h3>Description</h3>

<p>This is an internal function. The function takes all the information needed
to calculate how many FPCs are needed to reach the pre-specified cutoff
level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_var(sigma_sq, values, norms_sq, mfpc_cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_var_+3A_sigma_sq">sigma_sq</code></td>
<td>
<p>Vector containing the estimated variances on each dimension.</p>
</td></tr>
<tr><td><code id="compute_var_+3A_values">values</code></td>
<td>
<p>List containing the multivariate Eigenvalues for each variance
component.</p>
</td></tr>
<tr><td><code id="compute_var_+3A_norms_sq">norms_sq</code></td>
<td>
<p>Vector containing the squared norms to be used as weights on
the Eigenvalues.</p>
</td></tr>
<tr><td><code id="compute_var_+3A_mfpc_cutoff">mfpc_cutoff</code></td>
<td>
<p>Pre-specified level of explained variance of results of
MFPCA.</p>
</td></tr>
</table>

<hr>
<h2 id='conduct_mfpca'>Conduct the MFPCA</h2><span id='topic+conduct_mfpca'></span>

<h3>Description</h3>

<p>This is an internal function contained in the multiFAMM function. This step
uses the information from the univariate FLMMs for the MFPCA. It also allows
a single weighting scheme of the MFPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conduct_mfpca(mfpca_info, mfpc_weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conduct_mfpca_+3A_mfpca_info">mfpca_info</code></td>
<td>
<p>Object containing all the neccessary information for the
MFPCA. List as given by the output of prepare_mfpca().</p>
</td></tr>
<tr><td><code id="conduct_mfpca_+3A_mfpc_weight">mfpc_weight</code></td>
<td>
<p>TRUE if the estimated univariate error variance is to be
used as weights in the scalar product of the MFPCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, it is possible to conduct a non-weighted MFPCA (default) as well
as a MFPCA that uses the estimated univariate error variances as weights.
</p>

<hr>
<h2 id='extract_components'>Extract Model Components to be Compared</h2><span id='topic+extract_components'></span>

<h3>Description</h3>

<p>This is an internal function that helps to compare different models. The
models resulting from a multiFAMM() call are typically very big. This
function extracts the main information from a model so that a smaller R
object can be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_components(model, dimnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_components_+3A_model">model</code></td>
<td>
<p>multiFAMM model object from which to extract the information.</p>
</td></tr>
<tr><td><code id="extract_components_+3A_dimnames">dimnames</code></td>
<td>
<p>Names of the dimensions of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far the grid is fixed to be on [0,1].
</p>


<h3>Value</h3>

<p>A list with the following elements
</p>

<ul>
<li> <p><code>error_var</code>: A list containing the following elements
</p>

<ul>
<li> <p><code>model_weights</code>: Model weights used in the final multiFAMM.
</p>
</li>
<li> <p><code>modelsig2</code>: Estimate of sigma squared in the final model.
</p>
</li>
<li> <p><code>uni_vars</code>: Univariate estimates of sigma squared.</p>
</li></ul>

</li>
<li> <p><code>eigenvals</code>: List containing the estimated eigenvalues.
</p>
</li>
<li> <p><code>fitted_curves</code>: multiFunData object containing the fitted
curves.
</p>
</li>
<li> <p><code>eigenfcts</code>: multiFunData object containing the estimated
eigenfunctions.
</p>
</li>
<li> <p><code>cov_preds</code>: multiFunData object containing the estimated
covariate effects.
</p>
</li>
<li> <p><code>ran_preds</code>: List containing multiFunData objects of the
predicted random effects.
</p>
</li>
<li> <p><code>scores</code>: List containing matrices of the estimated scores.
</p>
</li>
<li> <p><code>meanfun</code>: multiFunData object containing the estimated mean
function.
</p>
</li>
<li> <p><code>var_info</code>: List containing all eigenvalues and univariate
norms before the MFPC pruning step
</p>

<ul>
<li> <p><code>eigenvals</code>: Vector of all multivariate eigenvalues.
</p>
</li>
<li> <p><code>uni_norms</code>: List of univariate norms of all
eigenfunctions.</p>
</li></ul>
</li></ul>


<hr>
<h2 id='extract_components_uni'>Extract Model Components to be Compared from Univariate Model</h2><span id='topic+extract_components_uni'></span>

<h3>Description</h3>

<p>This is an internal function that helps to compare different models. The
models resulting from a multiFAMM() call are typically very big. This
function extracts the main information from a univariate model so that a
smaller R object can be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_components_uni(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_components_uni_+3A_model">model</code></td>
<td>
<p>Univariate multiFAMM model object from which to extract the
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far the grid is fixed to be on [0,1].
</p>


<h3>Value</h3>

<p>A list with the following elements
</p>

<ul>
<li> <p><code>error_var</code>: A list containing the following elements
</p>

<ul>
<li> <p><code>model_weights</code>: Model weights used in the final multiFAMM.
</p>
</li>
<li> <p><code>modelsig2</code>: Estimate of sigma squared in the final model.
</p>
</li>
<li> <p><code>uni_vars</code>: Univariate estimates of sigma squared.</p>
</li></ul>

</li>
<li> <p><code>eigenvals</code>: List containing the estimated eigenvalues.
</p>
</li>
<li> <p><code>fitted_curves</code>: multiFunData object containing the fitted
curves.
</p>
</li>
<li> <p><code>eigenfcts</code>: multiFunData object containing the estimated
eigenfunctions.
</p>
</li>
<li> <p><code>cov_preds</code>: multiFunData object containing the estimated
covariate effects.
</p>
</li>
<li> <p><code>ran_preds</code>: List containing multiFunData objects of the
predicted random effects.
</p>
</li>
<li> <p><code>scores</code>: List containing matrices of the estimated scores.</p>
</li></ul>


<hr>
<h2 id='extract_var_info'>Extract Variance Information from MFPCA Object</h2><span id='topic+extract_var_info'></span>

<h3>Description</h3>

<p>This is an internal function contained in the multiFAMM function. This step
allows to extract the information of the total variation in the data (multi-
and univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_var_info(MFPC = MFPC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_var_info_+3A_mfpc">MFPC</code></td>
<td>
<p>MFPCA object from which to extract multivariate eigenvalues and
univariate norms.</p>
</td></tr>
</table>

<hr>
<h2 id='multiFAMM'>Multivariate Functional Additive Mixed Model Regression</h2><span id='topic+multiFAMM'></span>

<h3>Description</h3>

<p>This is the main function of the package and fits the multivariate functional
additive regression model with potentially nested or crossed functional
random intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiFAMM(data, fRI_B = FALSE, fRI_C = FALSE, nested = FALSE,
  bs = "ps", bf_mean = 8, bf_covariates = 8, m_mean = c(2, 3),
  covariate = FALSE, num_covariates = NULL, covariate_form = NULL,
  interaction = FALSE, which_interaction = matrix(NA), bf_covs, m_covs,
  var_level = 1, use_famm = FALSE, save_model_famm = FALSE,
  one_dim = NULL, mfpc_weight = FALSE, mfpc_cutoff = 0.95,
  number_mfpc = NULL, mfpc_cut_method = c("total_var", "unidim"),
  final_method = c("w_bam", "bam", "gaulss"), weight_refit = FALSE,
  verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiFAMM_+3A_data">data</code></td>
<td>
<p>Data.table that contains the information with some fixed variable
names, see Details.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_fri_b">fRI_B</code></td>
<td>
<p>Boolean for including functional random intercept for individual
(B in Cederbaum). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_fri_c">fRI_C</code></td>
<td>
<p>Boolean for including functional random intercept
for word (C in Cederbaum). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_nested">nested</code></td>
<td>
<p><code>TRUE</code> to specify a model with nested functional random
intercepts for the first and second grouping variable and a smooth error
curve. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_bs">bs</code></td>
<td>
<p>Spline basis function, only tested for &quot;ps&quot; (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_bf_mean">bf_mean</code></td>
<td>
<p>Basis dimension for functional intercept (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_bf_covariates">bf_covariates</code></td>
<td>
<p>Basis dimension for all covariates (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_m_mean">m_mean</code></td>
<td>
<p>Order of penalty for basis function (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_covariate">covariate</code></td>
<td>
<p>Covariate effects (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_num_covariates">num_covariates</code></td>
<td>
<p>Number of covariates included in the model (as in
sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_covariate_form">covariate_form</code></td>
<td>
<p>Vector of strings for type of covariate (as in
sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_interaction">interaction</code></td>
<td>
<p>TRUE if there are interactions between covariates (as in
sparseFLMM). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_which_interaction">which_interaction</code></td>
<td>
<p>Symmetric matrix specifying the interaction terms
(as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_bf_covs">bf_covs</code></td>
<td>
<p>Vector of marginal basis dimensions for fRI covariance
estimation (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_m_covs">m_covs</code></td>
<td>
<p>List of marginal orders for the penalty in fRI covariance
estimation (as in sparseFLMM).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_var_level">var_level</code></td>
<td>
<p>Pre-specified level of explained variance on each
dimension (as in sparseFLMM). Defaults to including all non-negative
Eigenvalues.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_use_famm">use_famm</code></td>
<td>
<p>Re-estimate the mean in FAMM context (as in sparseFLMM) -
overwritten by one_dim.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_save_model_famm">save_model_famm</code></td>
<td>
<p>Give out the FAMM model object (as in sparseFLMM) -
overwritten by one_dim.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_one_dim">one_dim</code></td>
<td>
<p>Specify the name of the dimension if sparseFLMM is to be
computed only on one dimension.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_mfpc_weight">mfpc_weight</code></td>
<td>
<p>TRUE if the estimated univariate error variance is to be
used as weights in the scalar product of the MFPCA.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_mfpc_cutoff">mfpc_cutoff</code></td>
<td>
<p>Pre-specified level of explained variance of results of
MFPCA. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_number_mfpc">number_mfpc</code></td>
<td>
<p>List containing the number of mfPCs needed for each
variance component e.g. list(&quot;E&quot; = x, &quot;B&quot; = y).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_mfpc_cut_method">mfpc_cut_method</code></td>
<td>
<p>Method to determine the level of explained variance
</p>

<ul>
<li><p> total_var: (weighted) sum of variation over the dimensions.
</p>
</li>
<li><p> unidim: separate on each dimension.
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiFAMM_+3A_final_method">final_method</code></td>
<td>
<p>Function used for estimation of final model to allow for
potential heteroscedasticity (&quot;w_bam&quot;, &quot;bam&quot;, &quot;gaulss&quot;).</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_weight_refit">weight_refit</code></td>
<td>
<p>Get the weights for the weighted bam by first refitting
the model under an independence assumption but with mfpc basis functions.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_verbose">verbose</code></td>
<td>
<p>Print progress of the multifamm. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="multiFAMM_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to (mainly) the underlying
sparseFLMM function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expand the method proposed by Fabian Scheipl to incorporate the variance
decomposition developed by Cederbaum et al. (2016). To account for the
correlation between the dimensions, the MFPCA approach by Happ and Greven
(2016) is applied.
</p>
<p>The data set has to be of the following format:
</p>

<ul>
<li><p> y_vec (numeric): vector of response values
</p>
</li>
<li><p> t (numeric): observation point locations
</p>
</li>
<li><p> n_long (integer): curve identification
</p>
</li>
<li><p> subject_long (integer): subject identification (NEEDS TO BE
SPECIFIED)
</p>
</li>
<li><p> word_long (integer): word identification
</p>
</li>
<li><p> combi_long (integer): repetition
</p>
</li>
<li><p> dim (factor): level of the dimension
</p>
</li>
<li><p> covariate.1 (numeric): potential covariate(s) named with trailing
1,2,3,...
</p>
</li></ul>

<p>It is possible to introduce weights for the final estimation of the
multiFAMM. Currently, it is only implemented to use the inverse of the
univariate measurement error estimates as weights. Note that negative
values of variance estimates are set to zero in fast symmetric additive
covariance smoothing. In order to still include weights, zero-values are
substituted by values of the smallest positive variance estimate.
</p>


<h3>Value</h3>

<p>A list with five elements
</p>

<ul>
<li><p> the final multivariate FAMM
</p>
</li>
<li><p> the sparseFLMM output for each of the dimensions
</p>
</li>
<li><p> information on the untruncated MPFCA results
</p>
</li>
<li><p> the truncated MFPC output
</p>
</li>
<li><p> the data used to fit the model.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# subset of the phonetic data (very small subset, no meaningful results can
# be expected and no random effects other than the random smooth should be
# included in the model)

data(phonetic_subset)

m &lt;- multiFAMM(data = phonetic_subset, covariate = TRUE, num_covariates = 2,
               covariate_form = c("by", "by"), interaction = TRUE,
               which_interaction = matrix(c(FALSE, TRUE, TRUE, FALSE),
               nrow = 2, ncol = 2), bf_covs = c(5), m_covs = list(c(2, 3)),
               mfpc_cut_method = "total_var", final_method = "w_bam")

</code></pre>

<hr>
<h2 id='phonetic'>Phonetic data</h2><span id='topic+phonetic'></span>

<h3>Description</h3>

<p>The data are part of a large study on consonant assimilation, which is
the phenomenon that the articulation of two consonants becomes
phonetically more alike when they appear subsequently in fluent speech.
The data set contains the audio signals of nine different speakers which
repeated the same sixteen German target words each five times. In addition to
these acoustic signals, the data set also contains the electropalatographic
data. The target words are bisyllabic noun-noun compound words which
contained the two abutting consonants of interest, s and sh, in either order.
Consonant assimilation is accompanied by a complex interplay of
language-specific, perceptual and articulatory factors. The aim in the study
was to investigate the assimilation of the two consonants as a function of
their order (either first s, then sh or vice-versa), syllable stress
(stressed or unstressed) and vowel context, i.e. which vowels are immediately
adjacent to the target consonants of interest. The vowels are either of the
form ia or ai. For more details, see references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phonetic
</code></pre>


<h3>Format</h3>

<p>A data.frame with 50644 observations and 12 variables:
</p>

<dl>
<dt><code>dim</code></dt><dd><p>Factor for identifying the acoustic (aco) and
electropalatographic (epg) dimensions.</p>
</dd>
<dt><code>subject_long</code></dt><dd><p>Unique identification number for each speaker.</p>
</dd>
<dt><code>word_long</code></dt><dd><p>Unique identification number for each target word.</p>
</dd>
<dt><code>combi_long</code></dt><dd><p>Number of the repetition of the combination of the
corresponding speaker and target word.</p>
</dd>
<dt><code>y_vec</code></dt><dd><p>The response values for each observation point.</p>
</dd>
<dt><code>n_long</code></dt><dd><p>Unique identification number for each curve.</p>
</dd>
<dt><code>t</code></dt><dd><p>The observations point locations.</p>
</dd>
<dt><code>covariate.1</code></dt><dd><p>Order of the consonants, reference category first
/s/ then /sh/.</p>
</dd>
<dt><code>covariate.2</code></dt><dd><p>Stress of the final syllable of the first
compound, reference category 'stressed'.</p>
</dd>
<dt><code>covariate.3</code></dt><dd><p>Stress of the initial syllable of the second
compound, reference category 'stressed'.</p>
</dd>
<dt><code>covariate.4</code></dt><dd><p>Vowel context, reference category ia.</p>
</dd>
<dt><code>word_names_long</code></dt><dd><p>Names of the target words</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pouplier, Marianne and Hoole, Philip (2016): Articulatory and
Acoustic Characteristics of German Fricative Clusters, Phonetica, 73(1),
52&ndash;78.
</p>
<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed
Models for Irregularly or Sparsely Sampled Data. Statistical Modelling,
16(1), 67-88.
</p>
<p>Jona Cederbaum (2019). sparseFLMM: Functional Linear Mixed Models for
Irregularly or Sparsely Sampled Data. R package version 0.3.0.
<a href="https://CRAN.R-project.org/package=sparseFLMM">https://CRAN.R-project.org/package=sparseFLMM</a>
</p>

<hr>
<h2 id='phonetic_subset'>Phonetic data (subset)</h2><span id='topic+phonetic_subset'></span>

<h3>Description</h3>

<p>A small subset of the phonetics data set <code><a href="#topic+phonetic">phonetic</a></code>
with observations from two speakers and two items only. This will not produce
meaningful results but can be used as a toy data set when testing the code.
The variables are as in the full data set, see
<code><a href="#topic+phonetic">phonetic</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phonetic_subset
</code></pre>


<h3>Format</h3>

<p>A data.frame with 1336 observations and 12 variables.
</p>


<h3>Source</h3>

<p>Pouplier, Marianne and Hoole, Philip (2016): Articulatory and
Acoustic Characteristics of German Fricative Clusters, Phonetica, 73(1),
52&ndash;78.
</p>
<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed
Models for Irregularly or Sparsely Sampled Data. Statistical Modelling,
16(1), 67-88.
</p>
<p>Jona Cederbaum (2019). sparseFLMM: Functional Linear Mixed Models for
Irregularly or Sparsely Sampled Data. R package version 0.3.0.
<a href="https://CRAN.R-project.org/package=sparseFLMM">https://CRAN.R-project.org/package=sparseFLMM</a>
</p>

<hr>
<h2 id='predict_mean'>Predict The Mean Function For the FPC Plots</h2><span id='topic+predict_mean'></span>

<h3>Description</h3>

<p>This is an internal function that helps to interpret the FPCs. Extract the
mean function for all covariates set to 0.5. This is useful if combined with
the estimated FPCs because one can then add and subtract suitable multiples
from this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_mean(model, multi = TRUE, dimnames = c("aco", "epg"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_mean_+3A_model">model</code></td>
<td>
<p>multiFAMM model or list of univariate models for which to
predict the mean.</p>
</td></tr>
<tr><td><code id="predict_mean_+3A_multi">multi</code></td>
<td>
<p>Indicator if it is a multiFAMM model (TRUE) or a list of
univariate models.</p>
</td></tr>
<tr><td><code id="predict_mean_+3A_dimnames">dimnames</code></td>
<td>
<p>Vector of strings containing the names of the dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multiFunData object.
</p>

<hr>
<h2 id='prepare_mfpca'>Prepare Information Necessary for MFPCA</h2><span id='topic+prepare_mfpca'></span>

<h3>Description</h3>

<p>This is an internal function contained in the multiFAMM function. This step
uses the information from the univariate FLMMs for the MFPCA. It also allows
a simple weighting scheme of the MFPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_mfpca(model_list, fRI_B, mfpc_weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_mfpca_+3A_model_list">model_list</code></td>
<td>
<p>List containing sparseFLMM objects for each dimension as
given by the output of apply_sparseFLMM()</p>
</td></tr>
<tr><td><code id="prepare_mfpca_+3A_fri_b">fRI_B</code></td>
<td>
<p>Boolean for including functional random intercept for individual
(B in Cederbaum). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepare_mfpca_+3A_mfpc_weight">mfpc_weight</code></td>
<td>
<p>TRUE if the estimated univariate error variance is to be
used as weights in the scalar product of the MFPCA.</p>
</td></tr>
</table>

<hr>
<h2 id='prune_mfpc'>Prune the MFPC object to include only a prespecified level of explained var</h2><span id='topic+prune_mfpc'></span>

<h3>Description</h3>

<p>This is an internal function contained in the multiFAMM function. This
function takes the MFPCA object and decides how many functional principal
components are to be included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_mfpc(MFPC, mfpc_cutoff, model_list, mfpc_cut_method, number_mfpc,
  mfpca_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_mfpc_+3A_mfpc">MFPC</code></td>
<td>
<p>List containing MFPC objects for each variance component as given
by the function conduct_mfpca()</p>
</td></tr>
<tr><td><code id="prune_mfpc_+3A_mfpc_cutoff">mfpc_cutoff</code></td>
<td>
<p>Pre-specified level of explained variance of results of
MFPCA. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="prune_mfpc_+3A_model_list">model_list</code></td>
<td>
<p>List containing sparseFLMM objects for each dimension as
given by the output of apply_sparseFLMM()</p>
</td></tr>
<tr><td><code id="prune_mfpc_+3A_mfpc_cut_method">mfpc_cut_method</code></td>
<td>
<p>Method to determine the level of explained variance
</p>

<ul>
<li><p> total_var: (weighted) sum of variation over the dimensions.
</p>
</li>
<li><p> unidim: separate on each dimension.
</p>
</li></ul>
</td></tr>
<tr><td><code id="prune_mfpc_+3A_number_mfpc">number_mfpc</code></td>
<td>
<p>List containing the number of mfPCs needed for each
variance component e.g. list(&quot;E&quot; = x, &quot;B&quot; = y).</p>
</td></tr>
<tr><td><code id="prune_mfpc_+3A_mfpca_info">mfpca_info</code></td>
<td>
<p>Object containing all the neccessary information for the
MFPCA. List as given by the output of prepare_mfpca().</p>
</td></tr>
</table>

<hr>
<h2 id='refit_for_weights'>Refit the model under an independence assumption</h2><span id='topic+refit_for_weights'></span>

<h3>Description</h3>

<p>This is an internal function. Refit the model under an independence
assumption now with the basis functions from the MFPCA. Goal is to extract an
estimate for the error variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit_for_weights(formula, data, model_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_for_weights_+3A_formula">formula</code></td>
<td>
<p>Formula to fit the final model.</p>
</td></tr>
<tr><td><code id="refit_for_weights_+3A_data">data</code></td>
<td>
<p>Data that contains all the variables specified in formula.</p>
</td></tr>
<tr><td><code id="refit_for_weights_+3A_model_list">model_list</code></td>
<td>
<p>List containing sparseFLMM objects for each dimension</p>
</td></tr>
</table>

<hr>
<h2 id='snooker'>Snooker data</h2><span id='topic+snooker'></span>

<h3>Description</h3>

<p>The data are part of a study on the impact of a muscular training program on
snooker technique. 25 recreational snooker players were split into treatment
(receiving instructions for a training program) and control group (no
training program). The data set contains the movement trajectories of the
snooker players in two sessions (before and after the training period), where
each snooker player repeated a snooker shot of maximal force six times. The
interest lies in the movement of hand, elbow, and shoulder on a
two-dimensional grid (called X and Y). The trajectories are normalized on a
[0,1] time grid and the beginning of the hand trajectories are centered to
the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snooker
</code></pre>


<h3>Format</h3>

<p>A data.frame with 56910 observations and 11 variables:
</p>

<dl>
<dt><code>y_vec</code></dt><dd><p>The response values for each observation point.</p>
</dd>
<dt><code>t</code></dt><dd><p>The observations point locations.</p>
</dd>
<dt><code>n_long</code></dt><dd><p>Unique identification number for each curve.</p>
</dd>
<dt><code>subject_long</code></dt><dd><p>Unique identification number for each snooker
player.</p>
</dd>
<dt><code>word_long</code></dt><dd><p>Integer specifying the session. 1: Before the
training, 2: After the training.</p>
</dd>
<dt><code>dim</code></dt><dd><p>Factor for identifying the univariate dimensions.</p>
</dd>
<dt><code>combi_long</code></dt><dd><p>Number of the repetition of the snooker shot.</p>
</dd>
<dt><code>covariate.1</code></dt><dd><p>Skill level of the snooker player. 0: Unskilled,
1: Skilled.</p>
</dd>
<dt><code>covariate.2</code></dt><dd><p>Group of the snooker player. 0: Control group,
1: Treatment group.</p>
</dd>
<dt><code>covariate.3</code></dt><dd><p>Session indicator. 0: Before the treatment, 1:
After the treatment.</p>
</dd>
<dt><code>covariate.4</code></dt><dd><p>Interaction of group and session, i.e. the
treatment effect indicator.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Enghofer, T. (2014). Überblick über die Sportart Snooker, Entwicklung
eines Muskeltrainings und Untersuchung dessen Einflusses auf die
Stoßtechnik. Unpublished Zulassungsarbeit, Technische Universität
München.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
