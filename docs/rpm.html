<!DOCTYPE html><html><head><title>Help for package rpm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rpm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.rpm'><p>ANOVA for rpm Fits</p></a></li>
<li><a href='#control.rpm'><p>Auxiliary for Controlling rpm</p></a></li>
<li><a href='#fauxmatching'><p>Faux Data on Heterosexual Matching</p></a></li>
<li><a href='#Gale_Shapley'><p>This is the version of Gale-Shapley stable matching algorithm (translated from the Matlab code in Menzel (2015)).</p></a></li>
<li><a href='#gof'><p>Calculate goodness-of-fit statistics for Revealed Preference Matchings Model based on observed data</p></a></li>
<li><a href='#list_rhs.formula'><p>Returns a list containing the terms in a given formula</p></a></li>
<li><a href='#logLik.rpm'><p>A <code>logLik</code> method for ['rpm'] fits.</p></a></li>
<li><a href='#logLikNull'><p>Calculate the null model likelihood</p></a></li>
<li><a href='#message_print'><p>['print'] objects to the ['message'] output.</p></a></li>
<li><a href='#microsimulate'><p>Micro simulate a population from a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpm'><p>Fit a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpm_MLPLE'><p>Fit a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpm-internal'><p>Internal rpm Objects</p></a></li>
<li><a href='#rpm-package'><p>Modeling of Revealed Preferences Matchings</p></a></li>
<li><a href='#rpm-terms'><p>Terms used in a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpm.model.functions'><p>Creates a model function list for the continuous terms in a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpm.model.matrix'><p>Creates a model matrix to estimate the parameters of a Revealed Preference Matchings Model</p></a></li>
<li><a href='#rpmpopulationpmf'><p>Compute the population distribution of pairs and singles from a Revealed Preference Matchings Model</p></a></li>
<li><a href='#simulate.rpm'><p>Simulate a sample of pairs and singles from a Revealed Preference Matchings Model</p></a></li>
<li><a href='#summary_rpm'><p>Summarize Revealed Preference Matchings data via a Model Specification</p></a></li>
<li><a href='#summary.rpm'><p>Summarizing rpm Model Fits</p></a></li>
<li><a href='#ult&lt;-'><p>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling of Revealed Preferences Matchings</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical estimation of revealed preference models from data collected on bipartite matchings. The models are for matchings within a bipartite population where individuals have utility for people based on known and unknown characteristics. People can form a partnership or remain unpartnered. The model represents both the availability of potential partners of different types and preferences of individuals for such people. The software estimates preference parameters based on sample survey data on partnerships and population composition. The simulation of matchings and goodness-of-fit are considered.  See Goyal, Handcock, Jackson, Rendall and Yeung (2022) &lt;<a href="https://doi.org/10.1093%2Fjrsssa%2Fqnad031">doi:10.1093/jrsssa/qnad031</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>License_is_FOSS:</td>
<td>yes</td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/handcock/rpm">https://github.com/handcock/rpm</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), abind, future, doRNG, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, nloptr, matrixStats, MASS, dplyr, ggplot2, coda,
doFuture, foreach</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 15:27:07 UTC; handcock</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark S. Handcock <a href="https://orcid.org/0000-0002-9985-2785"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ryan M. Admiraal [ctb],
  Fiona C. Yeung [ctb],
  Heide M. Jackson [ctb],
  Michael S. Rendall [ctb],
  Shuchi Goyal [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark S. Handcock &lt;handcock@stat.ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-21 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.rpm'>ANOVA for rpm Fits</h2><span id='topic+anova.rpm'></span><span id='topic+anova_rpmlist'></span>

<h3>Description</h3>

<p>Compute an analysis of variance table for one or more rpm fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpm'
anova(object, ...)

anova_rpmlist(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.rpm_+3A_object">object</code>, <code id="anova.rpm_+3A_...">...</code></td>
<td>
<p>objects of class <code><a href="#topic+rpm">rpm</a></code>, usually, a result of a
call to <code><a href="#topic+rpm">rpm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a single object gives a sequential analysis of variance table for
that fit.  That is, the reductions in the residual sum of squares as each
term of the formula is added in turn are given in the rows of a table, plus
the residual sum of squares.
</p>
<p>The table will contain F statistics (and P values) comparing the mean square
for the row to the residual mean square.
</p>
<p>If more than one object is specified, the table has a row for the residual
degrees of freedom and sum of squares for each model.  For all but the first
model, the change in degrees of freedom and sum of squares is also given.
(This only make statistical sense if the models are nested.)  It is
conventional to list the models from smallest to largest, but this is up to
the user.
</p>
<p>Optionally the table can include test statistics.  Normally the F statistic
is most appropriate, which compares the mean square for a row to the
residual sum of squares for the largest model considered.  If <code>scale</code>
is specified chi-squared tests can be used. Mallows' <code class="reqn">C_p</code> statistic
is the residual sum of squares plus twice the estimate of
<code class="reqn">\sigma^2</code> times the residual degrees of freedom.
</p>
<p>If any of the objects do not have estimated log-likelihoods, produces an
error, unless <code>eval.loglik=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class
<code>"data.frame"</code>.
</p>


<h3>Warning</h3>

<p>The comparison between two or more models will only be
valid if they are fitted to the same dataset. This may be a problem if there
are missing values.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+rpm">rpm</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>,
<code><a href="#topic+logLik.rpm">logLik.rpm</a></code> for adding the log-likelihood to an existing
<code><a href="#topic+rpm.object">rpm</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
anova(fit)

</code></pre>

<hr>
<h2 id='control.rpm'>Auxiliary for Controlling rpm</h2><span id='topic+control.rpm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning RPM model fitting algorithm,
which computes the MLPLE of the Revealed Preferences Model via optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.rpm(
  init_theta = NULL,
  algorithm = "NLOPT_LD_SLSQP",
  print_level = 0,
  xtol_rel = 1e-08,
  ftol_rel = 1e-08,
  ftol_abs = 1e-06,
  lower.bound = -10,
  upper.bound = 10,
  maxeval = 2000,
  bs.maxeval = 2000,
  bs.xtol_rel = 1e-08,
  check_derivatives = FALSE,
  bootstrap = TRUE,
  hessian = FALSE,
  seed = NULL,
  parallel.type = "PSOCK",
  parallel.ncores = 1,
  ncores = 1,
  constraints = c("none", "M_single"),
  logodds_single = FALSE,
  save.data = TRUE,
  robust.cov = FALSE,
  local_opts = list(algorithm = "NLOPT_LD_SLSQP", xtol_rel = 1e-07, maxeval = maxeval),
  nbootstrap = 50,
  nbootstrap.SD = 20,
  large.population.bootstrap = 5000,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.rpm_+3A_init_theta">init_theta</code></td>
<td>
<p>vector; numeric vector of starting parameter values. This value and other possible 
starting values are applied to find a good optimizer. This can either have length the number of parameters
corresponding to the terms in the formula or in addition the equilibrium constraints.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_algorithm">algorithm</code></td>
<td>
<p>string; The optimization algorithm to use. See <code>nloptr::nloptr.print.options()</code>
and the <code>NLopt</code> website for a description of the algorithms.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_print_level">print_level</code></td>
<td>
<p>integer; possible values: 0, 1, 2, or 3.
This controls how much output is shown during the
optimization process. Possible values: 0 (default): no output; 1:
show iteration number and value of objective function; 2: 1 + show
value of equalities/constraints; 3: 2 + show value of controls.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_xtol_rel">xtol_rel</code></td>
<td>
<p>scalar; Stop when an optimization step (or an estimate of the optimum)
changes every parameter by less than xtol_rel multiplied by the
absolute value of the parameter. If there is any chance that an
optimal parameter is close to zero, you might want to set an absolute
tolerance with xtol_abs as well. Criterion is disabled if xtol_rel is
non-positive. Possible values: xtol_rel &gt; 0. Default value: 1.0e-08.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_ftol_rel">ftol_rel</code></td>
<td>
<p>scalar; Stop when an optimization step (or an estimate of the optimum)
changes the log-likelihood by less than ftol_rel multiplied by the
absolute value of the log-likelihood.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_ftol_abs">ftol_abs</code></td>
<td>
<p>scalar; Stop when an optimization step (or an estimate of the optimum)
changes the log-likelihood by less than ftol_abs.
tolerance with xtol_abs as well. Criterion is disabled if ftol_abs is
non-positive. Possible values: ftol_abs &gt; 0. Default value: 1.0e-06.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_lower.bound">lower.bound</code></td>
<td>
<p>numeric; lower bounds on the parameter estimates (that is, the beta 
and gamma parameters in the model). Can be a vector of the same size as the coefficient
vector or a single number which is used for all bounds.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_upper.bound">upper.bound</code></td>
<td>
<p>numeric; upper bounds on the parameter estimates (that is, the beta 
and gamma parameters in the model). Can be a vector of the same size as the coefficient
vector or a single number which is used for all bounds.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_maxeval">maxeval</code></td>
<td>
<p>integer; Stop when the number of function evaluations exceeds maxeval. This is
not a strict maximum: the number of function evaluations may exceed
maxeval slightly, depending upon the algorithm. Criterion is disabled
if maxeval is non-positive. Default value: 1000.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_bs.maxeval">bs.maxeval</code></td>
<td>
<p>integer; Stop the bootstrap optimization when the number of function evaluations exceeds bs.maxeval. This is
not a strict maximum: the number of function evaluations may exceed
bs.maxeval slightly, depending upon the algorithm. Criterion is disabled
if bs.maxeval is non-positive. Default value:50</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_bs.xtol_rel">bs.xtol_rel</code></td>
<td>
<p>scalar; Stop the bootstrap optimization when an optimization step (or an estimate of the optimum)
changes every parameter by less than bs.xtol_rel multiplied by the
absolute value of the parameter. See the parameter xtol_rel for details.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_check_derivatives">check_derivatives</code></td>
<td>
<p>logical; Compare the user-supplied analytic gradients
with the finite difference approximations.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical; If  'TRUE' use a bootstrap to compute the standard errors and associated
covariance matrices. If 'FALSE' base the standard errors and associated
covariance matrices on the Hessian of the
(constrained) log-likelihood. 
In all cases the extended covariance matrix is returned in <code>ext.covar.hessian</code>.
This is the matrix of parameters, log-odds of being single and the Lagrange multipliers.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_hessian">hessian</code></td>
<td>
<p>logical; Depreciated. The negation of the 'bootstrap' argument.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code></p>
</td></tr>
<tr><td><code id="control.rpm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>The type of cluster to run. The typical choices are &quot;MPI&quot; and &quot;PSOCK&quot;, where you
must have &quot;MPI&quot; installed to use the former. The default
is &quot;PSOCK&quot;.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_parallel.ncores">parallel.ncores</code></td>
<td>
<p>count; Depreciated. The renamed 'ncores' argument.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_ncores">ncores</code></td>
<td>
<p>Number of processors to use in the bootstrap computations. The default
is 1, that is no parallel processing.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_constraints">constraints</code></td>
<td>
<p>string; Additional constraints to force the proportions of singles to
match the (weighted) population estimates? This should not be required, but does stabilize
the estimates in cases where there is much uncertainty.
The possible values are &quot;none&quot; and &quot;M_single&quot; (the numbers of male singles of 
each type are reproduced). Note that adding constraints leads to 
over-constrained optimization which may fail.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_logodds_single">logodds_single</code></td>
<td>
<p>logical; Should the log-odds ratio of being single relative to a randomly chosen person of the same sex from the 
the population be returned. If FALSE the log-odds of being single relative is returned. This is a pure preference parameter.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_save.data">save.data</code></td>
<td>
<p>logical; Should the data be saved in the return list (as components
<code>Xdata</code> and <code>Zdata</code>).</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_robust.cov">robust.cov</code></td>
<td>
<p>logical; Should the covariance matrix of the estimates be computed using a
robust method (MASS::cov.mcd)? Only use if the bootstrap is unstable.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_local_opts">local_opts</code></td>
<td>
<p>list; list of options for <code>nloptr</code> sub-algorithm. See the <code>nloptr</code> package, but these are rarely changed.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_nbootstrap">nbootstrap</code></td>
<td>
<p>integer; Number of bootstrap resamples to take in the estimation of the
covariance matrix of the parameter estimates.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_nbootstrap.sd">nbootstrap.SD</code></td>
<td>
<p>integer; Number of bootstrap resamples to take in the estimation of the
variances used in the studentized bootstrap. This is run for each nbootstrap sample and so is expensive.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_large.population.bootstrap">large.population.bootstrap</code></td>
<td>
<p>integer; If the population size exceeds <code>large.population.bootstrap</code> then 
the large population approximation is used to simulate the matchings in the bootstrap. Otherwise the 
small population simulation is used (including the Gale-Shapley algorithm).
The small population method is more accurate in smaller populations, with the default cutoff being 5000 people.</p>
</td></tr>
<tr><td><code id="control.rpm_+3A_alpha">alpha</code></td>
<td>
<p>proportion; Type I error rate for the confidence intervals produced by the bootstrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+rpm">rpm</a></code>
function.
</p>
<p>Some of the arguments are not yet fully implemented.
It will evolve slower to incorporate more
arguments as the package develops.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpm">rpm</a></code>
</p>

<hr>
<h2 id='fauxmatching'>Faux Data on Heterosexual Matching</h2><span id='topic+fauxmatching'></span>

<h3>Description</h3>

<p>This data set represents a simulation of a bipartite matching.
The data set is named fauxmatching.
Its primary use is to illustrate the fitting of a Revealed Preference Matchings Model (rpm).
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities. This provides such data
for a matching between men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fauxmatching)
</code></pre>


<h3>Format</h3>

<p><code>fauxmatching</code> is a list containing a pair of <code>data.frame</code> objects: <code>Xdata</code> and <code>Zdata</code>.
</p>
<p><code>Xdata</code> is for women. Each row is a woman, each column is a variable on that women
or her partnerships. The women's ID variable s called <code>pid</code> and
the variable with the ID of the women's partner is called <code>pair_id</code>. If the women is single the men's ID is NA.
<code>Zdata</code> is for men. Each row is a man, each column is a variable on that men
The men's ID variable is called <code>pid</code>.
</p>

<ul>
<li><p>pair_id The ID of the person's partner. This is in both <code>Xdata</code> and <code>Zdata</code>.
</p>
</li>
<li><p>sampled The indicator that the person was sampled directly (as distinct from being included as the match of a directly sampled
person. All single people are directly sampled.  This is in both <code>Xdata</code> and <code>Zdata</code>.
</p>
</li></ul>



<h3>Details</h3>

<p>The pairings are determined by the <code>pair_id</code> variable in <code>Xdata</code>. 
If that variable is NA then the women is
assumed to be single. If men are listed in <code>Zdata</code> and are not partnered then they are assumed single.
Weights are specified by three optional variables in <code>Xdata</code>.
</p>

<ul>
<li><p>X_w: The weight variable for women. The sum of the weights of the sampled women is the
number of women in the population.
</p>
</li>
<li><p>Z_w: The weight variable for men. The sum of the weights of the sampled men is the
number of men in the population.
</p>
</li>
<li><p>pair_w: The weight variable for pairs.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Source</h3>

<p>The data set is simulation based upon an rpm model fit to data from
the 2008 SIPP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
summary(fit)

</code></pre>

<hr>
<h2 id='Gale_Shapley'>This is the version of Gale-Shapley stable matching algorithm (translated from the Matlab code in Menzel (2015)).</h2><span id='topic+Gale_Shapley'></span>

<h3>Description</h3>

<p>This code allows the self-matched option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gale_Shapley(U, V, return.data.frame = FALSE, cpp = TRUE, nmax = 10 * nrow(U))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gale_Shapley_+3A_u">U</code></td>
<td>
<p>The utility matrix for the women's side. Each row is a woman, each column is a man.
The matrix entry (i,j) is the utility that woman <code>i</code> gains from pairing with man <code>j</code>. 
In other words, the utility is computed from woman <code>i</code>'s perspective.</p>
</td></tr>
<tr><td><code id="Gale_Shapley_+3A_v">V</code></td>
<td>
<p>The utility matrix for the men's side. Each column is a man, each row is a woman.
The matrix entry (i,j) is the utility that man <code>j</code> gains from pairing with woman <code>i</code>. 
In other words, the utility is computed from man <code>j</code>'s perspective.</p>
</td></tr>
<tr><td><code id="Gale_Shapley_+3A_return.data.frame">return.data.frame</code></td>
<td>
<p>logical Should a <code>data.frame</code> of the matching be returned instead of the
paring matrix mu?</p>
</td></tr>
<tr><td><code id="Gale_Shapley_+3A_cpp">cpp</code></td>
<td>
<p>logical Should the <code>Rcpp</code> version of the code be used. This is much faster and uses a lot less memory.</p>
</td></tr>
<tr><td><code id="Gale_Shapley_+3A_nmax">nmax</code></td>
<td>
<p>count The maximum number of iterations of the inner loop within the Gale-Shapley algorithm.
This can be reduced to speed up the algorithm at the potential cost of many partnerships being non-equilibruim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return depends on the <code>return.data.frame</code> value. 
If TRUE, it returns
</p>
<table>
<tr><td><code>data.frame</code></td>
<td>
<p>a two-column <code>data.frame</code> with the first column a women's index and the second column the 
men's index of their partner. It has as many rows as there are partnerships.</p>
</td></tr>
</table>
<p>If FALSE, it returns the following matrix: 
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>If <code>cpp=TRUE</code>, a vector of length the number of women (<code>nrow(U)</code>) with the 
index of the matching man (i.e., the index is the row in <code>V</code> of the man). If there is no
matching man, the index is 0. This can be used to reconstruct the matching matrix.
If <code>cpp=FALSE</code>, the matching matrix, where 1 represents a pairing, 0 otherwise. 
Each row is a woman, each column is a man. The order of the rows is the same as the 
rows in <code>U</code>. The order of the columns is the same as the columns in <code>V</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>rpm
</p>

<hr>
<h2 id='gof'>Calculate goodness-of-fit statistics for Revealed Preference Matchings Model based on observed data</h2><span id='topic+gof'></span><span id='topic+gof.default'></span><span id='topic+gof.rpm'></span><span id='topic+plot.gofrpm'></span>

<h3>Description</h3>

<p><code><a href="#topic+gof.rpm">gof.rpm</a></code> ...
It is typically based on the estimate from a <code>rpm()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, ...)

## S3 method for class 'rpm'
gof(
  object,
  ...,
  empirical_p = TRUE,
  compare_sim = "sim-est",
  control = object$control,
  reboot = FALSE,
  verbose = FALSE
)

## S3 method for class 'gofrpm'
plot(x, ..., cex.axis = 0.7, main = "Goodness-of-fit diagnostics")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>list; an object of class<code>rpm</code> that is typically the result of a call to <code>rpm()</code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="gof_+3A_empirical_p">empirical_p</code></td>
<td>
<p>logical; (Optional) If TRUE the function returns the empirical p-value of the sample
statistic based on <code>nsim</code> simulations</p>
</td></tr>
<tr><td><code id="gof_+3A_compare_sim">compare_sim</code></td>
<td>
<p>string; describes which two objects are compared to compute simulated goodness-of-fit
statistics; valid values are <code>"sim-est"</code>: compares the marginal distribution of pairings in a
simulated sample to the <code>rpm</code> model estimate of the marginal distribution based on that same simulated sample;
<code>mod-est</code>: compares the marginal distribution of pairings in a
simulated sample to the <code>rpm</code> model estimate used to generate the sample</p>
</td></tr>
<tr><td><code id="gof_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="gof_+3A_reboot">reboot</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will rerun the bootstrap at the coefficient values, rather than 
expect the object to contain a <code>bs.results</code> component with the bootstrap results run at the solution values.
The latter is the default for <code>rpm</code> fits.</p>
</td></tr>
<tr><td><code id="gof_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out
additional information, including data summary statistics.</p>
</td></tr>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>a list, usually an object of class gofrpm</p>
</td></tr>
<tr><td><code id="gof_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification of the text used in axis notation;</p>
</td></tr>
<tr><td><code id="gof_+3A_main">main</code></td>
<td>
<p>Title for the goodness-of-fit plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+rpm">rpm</a></code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>
<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code><a href="#topic+rpm">rpm</a></code>. This function simulates from such a model.
</p>


<h3>Value</h3>

<p><code><a href="#topic+gof.rpm">gof.rpm</a></code> returns a list consisting of the following elements:
</p>
<table>
<tr><td><code>observed_pmf</code></td>
<td>
<p>numeric matrix giving observed probability mass distribution over different household types</p>
</td></tr>
<tr><td><code>model_pmf</code></td>
<td>
<p>numeric matrix giving expected probability mass distribution from <code>rpm</code> model</p>
</td></tr>
<tr><td><code>obs_chi_sq</code></td>
<td>
<p>the count-based observed chi-square statistic comparing marginal distributions of the population
the data and the model estimate</p>
</td></tr>
<tr><td><code>obs_chi_sq_cell</code></td>
<td>
<p>the contribution to the observed chi-squared statistic by household type</p>
</td></tr>
<tr><td><code>obs_kl</code></td>
<td>
<p>the Kullback-Leibler (KL) divergence computed by comparing the observed marginal distributions to the
expected marginal distribution based on the <code>rpm</code> model estimate</p>
</td></tr>
<tr><td><code>obs_kl_cell</code></td>
<td>
<p>the contribution to the observed KL divergence by household type</p>
</td></tr>
<tr><td><code>empirical_p_chi_sq</code></td>
<td>
<p>the proportion of simulated chi-square statistics that are greater than
or equal to the observed chi-square statistic</p>
</td></tr>
<tr><td><code>empirical_p_kl</code></td>
<td>
<p>the proportion of simulated KL divergences that are greater than
or equal to the observed KL divergence</p>
</td></tr>
<tr><td><code>chi_sq_simulated</code></td>
<td>
<p>vector of size <code>nsim</code> storing all simulated chi-square statistics</p>
</td></tr>
<tr><td><code>kl_simulated</code></td>
<td>
<p>vector of size <code>nsim</code> storing all simulated KL divergences</p>
</td></tr>
<tr><td><code>chi_sq_cell_mean</code></td>
<td>
<p>Mean contributions of each household type to the simulated chi_sq statistic</p>
</td></tr>
<tr><td><code>chi_sq_cell_sd</code></td>
<td>
<p>Standard deviation of the contributions of each household type to the simulated chi_sq statistics</p>
</td></tr>
<tr><td><code>chi_sq_cell_median</code></td>
<td>
<p>Median contributions of each household type to the simulated chi_sq statistic</p>
</td></tr>
<tr><td><code>chi_sq_cell_iqr</code></td>
<td>
<p>Interquartile range of the contributions of each household type to the simulated chi_sq statistics</p>
</td></tr>
<tr><td><code>kl_cell_mean</code></td>
<td>
<p>Mean contributions of each household type to the simulated KL divergences</p>
</td></tr>
<tr><td><code>kl_cell_sd</code></td>
<td>
<p>Standard deviation of the contributions of each household type to the simulated KL divergencesc</p>
</td></tr>
<tr><td><code>kl_cell_median</code></td>
<td>
<p>Median contributions of each household type to the simulated KL divergences</p>
</td></tr>
<tr><td><code>kl_cell_iqr</code></td>
<td>
<p>Interquartile range of the contributions of each household type to the simulated KL divergences</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gof(rpm)</code>: Calculate goodness-of-fit statistics for Revealed Preference Matchings Model based on observed data
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(gofrpm)</code>: <code><a href="#topic+plot.gofrpm">plot.gofrpm</a></code> plots diagnostics such empirical p-value
based on chi-square statistics and KL divergences.
See <code><a href="#topic+rpm">rpm</a></code> for more information on these models.
</p>
</li></ul>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)

data(fauxmatching)
fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
a &lt;- gof(fit)

</code></pre>

<hr>
<h2 id='list_rhs.formula'>Returns a list containing the terms in a given formula</h2><span id='topic+list_rhs.formula'></span>

<h3>Description</h3>

<p>Returns a list containing the terms in a given formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_rhs.formula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_rhs.formula_+3A_object">object</code></td>
<td>
<p>formula A formula having a right-hand-side that can be interpretated as a rpm specification.
returns a list containing terms in a given
formula, handling <code>+</code> and <code>-</code> operators and parentheses, and
keeping track of whether a term has a plus or a minus sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list_rhs.formula</code> returns a list of formula terms, with an additional numerical vector attribute <code>"sign"</code> with of the same length, giving the corresponding term's sign as <code>+1</code> or <code>-1</code>.
</p>

<hr>
<h2 id='logLik.rpm'>A <code><a href="stats.html#topic+logLik">logLik</a></code> method for ['rpm'] fits.</h2><span id='topic+logLik.rpm'></span>

<h3>Description</h3>

<p>A function to return the log-likelihood associated with an
<code><a href="#topic+rpm.object">rpm</a></code> fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.rpm_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+rpm.object">rpm</a></code> fit, returned by
<code><a href="#topic+rpm">rpm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.rpm_+3A_...">...</code></td>
<td>
<p>Other arguments to the likelihood functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="stats.html#topic+logLik">logLik</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="#topic+logLikNull">logLikNull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
logLik(fit)


</code></pre>

<hr>
<h2 id='logLikNull'>Calculate the null model likelihood</h2><span id='topic+logLikNull'></span><span id='topic+logLikNull.rpm'></span>

<h3>Description</h3>

<p>Calculate the null model likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikNull(object, ...)

## S3 method for class 'rpm'
logLikNull(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikNull_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="logLikNull_+3A_...">...</code></td>
<td>
<p>further arguments to lower-level functions.
</p>
<p><code>logLikNull</code> computes, when possible the log-probability of
the data under the null model (reference distribution).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logLikNull</code> returns an object of type <code><a href="stats.html#topic+logLik">logLik</a></code> if it is
able to compute the null model probability, and <code>NA</code> otherwise.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>logLikNull(rpm)</code>: A method for ['rpm'] fits to compute the null likelihood (that is, relative to the constant only model).
</p>
</li></ul>

<hr>
<h2 id='message_print'>['print'] objects to the ['message'] output.</h2><span id='topic+message_print'></span>

<h3>Description</h3>

<p>A thin wrapper around ['print'] that captures its output and prints
it as a ['message'], usually to STDERR.
Tis is part of ['statnet.common'].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>message_print(..., messageArgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="message_print_+3A_...">...</code></td>
<td>
<p>arguments to ['print'].</p>
</td></tr>
<tr><td><code id="message_print_+3A_messageargs">messageArgs</code></td>
<td>
<p>a list of arguments to be passed directly to ['message'].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(1:5)

print(1:5)
message_print(1:5) # Looks the same (though may be in a different color on some frontends).

suppressMessages(print(1:5)) # Still prints
suppressMessages(message_print(1:5)) # Silenced
</code></pre>

<hr>
<h2 id='microsimulate'>Micro simulate a population from a Revealed Preference Matchings Model</h2><span id='topic+microsimulate'></span>

<h3>Description</h3>

<p><code><a href="#topic+microsimulate">microsimulate</a></code> simulates a population of the pairs and singles
from a Revealed Preference Matchings Model. It is typically based on the estimate from a <code>rpm()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microsimulate(
  object,
  nsim = 1,
  seed = NULL,
  pmfW_N = NULL,
  pmfM_N = NULL,
  large.population = TRUE,
  bootstrap = FALSE,
  control = control.rpm(),
  counts.only = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="microsimulate_+3A_object">object</code></td>
<td>
<p>list; an object of class<code>rpm</code> that is typically the result of a call to <code>rpm()</code>.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_nsim">nsim</code></td>
<td>
<p>Number of matchings to be randomly drawn from the given
model on the set of all matchings / singles.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_seed">seed</code></td>
<td>
<p>integer; (Optional) random number seed.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_pmfw_n">pmfW_N</code></td>
<td>
<p>vector; The population count of the number of women of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_pmfm_n">pmfM_N</code></td>
<td>
<p>vector; The population count of the number of men of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_large.population">large.population</code></td>
<td>
<p>logical; If TRUE a large population approximation is used to generate
the matchings (rather than the individual level generation of utilities). This is much faster and
uses a lot less memory. It is TRUE by default. If used, a sample is drawn rather than the
population being returned. The sample size is controlled by <code>pmfW_N</code> and <code>pmfM_N</code>.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical; If TRUE the original population is sampled from. If FALSE the
population underlying the fitted model is sampled from.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_counts.only">counts.only</code></td>
<td>
<p>logical; If TRUE only the matrices of counts and the PMF of the population of households is returned.
If FALSE 
It is FALSE by default.</p>
</td></tr>
<tr><td><code id="microsimulate_+3A_verbose">verbose</code></td>
<td>
<p>logical; Should verbose messages be printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requites the numbers of women of each type and the number of men of each type to be specified. 
</p>
<p>The function <code><a href="#topic+rpm">rpm</a></code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>
<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code><a href="#topic+rpm">rpm</a></code>. This function simulates a population from such a model.
</p>


<h3>Value</h3>

<p>A list of lists, each a simulation from the population. Each of the simulation lists contains
components <code>population</code> being a list with components <code>Xdata</code> and <code>Zdata</code> (for use with <code>rpm()</code>).
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)

data(fauxmatching)
fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
num_women = fit$N*exp(fit$gw)
num_men   = fit$N*exp(fit$gm)
pmfW_N &lt;- round(fit$pmfW * num_women)
pmfM_N &lt;- round(fit$pmfM * num_men)
a &lt;- microsimulate(fit, pmfW_N=pmfW_N, pmfM_N=pmfM_N)

</code></pre>

<hr>
<h2 id='rpm'>Fit a Revealed Preference Matchings Model</h2><span id='topic+rpm'></span><span id='topic+rpm.object'></span>

<h3>Description</h3>

<p><code><a href="#topic+rpm">rpm</a></code> estimates the parameters of a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpm(
  formula,
  Xdata,
  Zdata,
  Xid = NULL,
  Zid = NULL,
  pair_id = NULL,
  X_w = NULL,
  Z_w = NULL,
  pair_w = NULL,
  sampled = NULL,
  sampling_design = "stock-flow",
  control = control.rpm(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpm_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="stats.html#topic+formula">formula</a></code> object, of the form <code>
~ &lt;model terms&gt;</code>. For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+rpm-terms">rpm-terms</a></code>.</p>
</td></tr>
<tr><td><code id="rpm_+3A_xdata">Xdata</code></td>
<td>
<p>data.frame for women. Each row is a woman, each column is a variable on that women
or her partnerships. It must contain the women's ID variable (see <code>Xid</code>) and
a variable with the ID of the women's partner. If the women is single the men's ID should be NA.</p>
</td></tr>
<tr><td><code id="rpm_+3A_zdata">Zdata</code></td>
<td>
<p>data.frame for men. Each row is a man, each column is a variable on that men
It must contain the men's ID variable (see <code>Zid</code>).</p>
</td></tr>
<tr><td><code id="rpm_+3A_xid">Xid</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the IDs of the women.</p>
</td></tr>
<tr><td><code id="rpm_+3A_zid">Zid</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the IDs of the men.</p>
</td></tr>
<tr><td><code id="rpm_+3A_pair_id">pair_id</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the ID of the men paired with the women in
<code>Xid</code>. If the women is not paired it must be NA.</p>
</td></tr>
<tr><td><code id="rpm_+3A_x_w">X_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the individual weight of the women.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 women in it.</p>
</td></tr>
<tr><td><code id="rpm_+3A_z_w">Z_w</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the individual weight of the man
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="rpm_+3A_pair_w">pair_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the pair weight of that women.
If the women is not paired it should be NA.
If this is NULL then it is computed from the individual weights using the <code>sampling_design</code>.
Note that the pair weights currently do not play a role in the estimation. They do in the quasi-likelihood version of the code.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="rpm_+3A_sampled">sampled</code></td>
<td>
<p>string The name of the logical variable in <code>Xdata</code> and <code>Zdata</code> containing the 
indicator that the person was sampled directly (as distinct from being included as the match of a directly sampled
person. All single people are directly sampled.</p>
</td></tr>
<tr><td><code id="rpm_+3A_sampling_design">sampling_design</code></td>
<td>
<p>string; The name of the sampling protocol used to select the survey data. Valid values are
<code>"stock-flow"</code> (default) (individuals are sampled, data contains both
singles and couples);
<code>"stock-stock"</code> (households are sampled, each household can be a single or a couple);
<code>"census"</code> (the sample is a census of the population of people).</p>
</td></tr>
<tr><td><code id="rpm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="rpm_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out
additional information, including data summary statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pairings are determined by the <code>pair_id</code> variable in <code>Xdata</code>. 
If that variable is NA then the women is
assumed to be single. If men are listed in <code>Zdata</code> and are not partnered then they are assumed single.
Weights are specified by three optional variables in <code>Xdata</code>.
</p>

<ul>
<li><p>X_w: This is character string of the name of the weight variable for women. The sum of the weights should be the
number of women in the population.
</p>
</li>
<li><p>Z_w: This is character string of the name of the weight variable for men. The sum of the weights should be the
number of men in the population.
</p>
</li>
<li><p>pair_w: This is character string of the name of the weight variable for pairs.
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="#topic+rpm">rpm</a></code> returns an object of class <code><a href="#topic+rpm.object">rpm.object</a></code>
that is a list consisting of the following elements: 
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>The maximum psuedo-likelihood estimate of <code class="reqn">\theta</code>, the vector of
coefficients for the model parameters. This includes the model <code class="reqn">\beta</code> and the model <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The bias-corrected bootstrap estimate of <code class="reqn">\theta</code>, the vector of
coefficients for the model parameters. This includes the model <code class="reqn">\beta</code> and the model <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The value of the maximized log-likelihood.</p>
</td></tr>
<tr><td><code>exitflag</code></td>
<td>
<p>integer value with the status of the optimization (4 is success as 
<code>xtol_rel</code> or <code>xtol_abs</code> was reached). Other codes are 1 = generic success; 2 = optimization stopped because 
<code>ftol_rel</code> or <code>ftol_abs</code> was reached; 3 = optimization stopped 
because <code>stopval</code> was reached; 4 = optimization stopped because <code>xtol_rel</code> or <code>xtol_abs</code> was reached; 
5 = optimization stopped because
<code>maxeval</code> was reached; 6 = optimization stopped because <code>maxtime</code> was reached.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call that was made to <code>nloptr</code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>vector with starting values for the optimization.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>more informative message with the status of the optimization.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations that were executed.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>value if the objective function in the solution.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>optimal value of the controls.</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>version of NLopt that was used.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>Approximate covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>eq</code></td>
<td>
<p>Values from the equality constraints. Larger values indicate non-convergence.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A matrix with the number of rows the MCMC sample size and the number of rows the number of parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>control.rpm, summary.rpm, print.rpm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
summary(fit)

</code></pre>

<hr>
<h2 id='rpm_MLPLE'>Fit a Revealed Preference Matchings Model</h2><span id='topic+rpm_MLPLE'></span>

<h3>Description</h3>

<p><code><a href="#topic+rpm_MLPLE">rpm_MLPLE</a></code> estimates the parameters of a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpm_MLPLE(
  formula,
  Xdata,
  Zdata,
  Xid = NULL,
  Zid = NULL,
  pair_id = NULL,
  X_w = NULL,
  Z_w = NULL,
  pair_w = NULL,
  sampled = NULL,
  sampling_design = "stock-flow",
  control = control.rpm(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpm_MLPLE_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="stats.html#topic+formula">formula</a></code> object, of the form <code>
~ &lt;model terms&gt;</code>. For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+rpm-terms">rpm-terms</a></code>.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_xdata">Xdata</code></td>
<td>
<p>data.frame for women. Each row is a woman, each column is a variable on that women
or her partnerships. It must contain the women's ID variable (see <code>Xid</code>) and
a variable with the ID of the women's partner. If the women is single the men's ID should be NA.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_zdata">Zdata</code></td>
<td>
<p>data.frame for men. Each row is a man, each column is a variable on that men
It must contain the men's ID variable (see <code>Zid</code>).</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_xid">Xid</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the IDs of the women.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_zid">Zid</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the IDs of the men.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_pair_id">pair_id</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the ID of the men paired with the women in
<code>Xid</code>. If the women is not paired it must be NA.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_x_w">X_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the individual weight of the women.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 women in it.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_z_w">Z_w</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the individual weight of the man
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_pair_w">pair_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the pair weight of that women.
If the women is not paired it should be NA.
If this is NULL then it is computed from the individual weights using the <code>sampling_design</code>.
Note that the pair weights currently do not play a role in the estimation. They do in the quasi-likelihood version of the code.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_sampled">sampled</code></td>
<td>
<p>string The name of the logical variable in <code>Xdata</code> and <code>Zdata</code> containing the 
indicator that the person was sampled directly (as distinct from being included as the match of a directly sampled
person. All single people are directly sampled.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_sampling_design">sampling_design</code></td>
<td>
<p>string; The name of the sampling protocol used to select the survey data. Valid values are
<code>"stock-flow"</code> (default) (individuals are sampled, data contains both
singles and couples);
<code>"stock-stock"</code> (households are sampled, each household can be a single or a couple);
<code>"census"</code> (the sample is a census of the population of people).</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="rpm_MLPLE_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out
additional information, including data summary statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is usually called via the <code><a href="#topic+rpm">rpm</a></code> function.
</p>
<p>The pairings are determined by the <code>pair_id</code> variable in <code>Xdata</code>. 
If that variable is NA then the women is
assumed to be single. If men are listed in <code>Zdata</code> and are not partnered then they are assumed single.
Weights are specified by three optional variables in <code>Xdata</code>.
</p>

<ul>
<li><p>X_w: This is character string of the name of the weight variable for women. The sum of the weights should be the
number of women in the population.
</p>
</li>
<li><p>Z_w: This is character string of the name of the weight variable for men. The sum of the weights should be the
number of men in the population.
</p>
</li>
<li><p>pair_w: This is character string of the name of the weight variable for pairs.
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="#topic+rpm">rpm</a></code> returns an object of class <code><a href="#topic+rpm.object">rpm.object</a></code>
that is a list consisting of the following elements: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The bias-corrected bootstrap estimate of <code class="reqn">\theta</code>, the vector of
coefficients for the model parameters. This includes the model <code class="reqn">\beta</code> and the model <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The value of the maximized log-likelihood.</p>
</td></tr>
<tr><td><code>exitflag</code></td>
<td>
<p>integer value with the status of the optimization (4 is success as 
<code>xtol_rel</code> or <code>xtol_abs</code> was reached). Other codes are 1 = generic success; 2 = optimization stopped because 
<code>ftol_rel</code> or <code>ftol_abs</code> was reached; 3 = optimization stopped 
because <code>stopval</code> was reached; 4 = optimization stopped because <code>xtol_rel</code> or <code>xtol_abs</code> was reached; 
5 = optimization stopped because
<code>maxeval</code> was reached; 6 = optimization stopped because <code>maxtime</code> was reached.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call that was made to <code>nloptr</code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>vector with starting values for the optimization.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>more informative message with the status of the optimization.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations that were executed.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>value if the objective function in the solution.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>optimal value of the controls.</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>version of NLopt that was used.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>Approximate covariance matrix of the estimates.</p>
</td></tr>
<tr><td><code>eq</code></td>
<td>
<p>Values from the equality constraints. Larger values indicate non-convergence.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>control.rpm, summary.rpm, print.rpm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)

data(fauxmatching)
fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
summary(fit)

</code></pre>

<hr>
<h2 id='rpm-internal'>Internal rpm Objects</h2><span id='topic+rpm-internal'></span><span id='topic+GSi_NTU'></span><span id='topic+GS_NTU'></span><span id='topic+GSi_NTU_O'></span><span id='topic+PSeqcond'></span><span id='topic+PSgeqcond'></span><span id='topic+augpmf'></span><span id='topic+augpmfWM'></span><span id='topic+augpmfnew'></span><span id='topic+checkstable'></span><span id='topic+eqcond'></span><span id='topic+jeqcond_nog'></span><span id='topic+gloglik_nog'></span><span id='topic+hloglik_nog'></span><span id='topic+loglik'></span><span id='topic+probcounts'></span><span id='topic+qloglik'></span><span id='topic+stablearma'></span><span id='topic+loglikfun_nog'></span>

<h3>Description</h3>

<p>Internal <code><a href="#topic+rpm-package">rpm</a></code> functions.
</p>


<h3>Details</h3>

<p>Most of these are not to be called by the user (or in some cases are just
waiting for proper documentation to be written.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p>rpm-package
</p>

<hr>
<h2 id='rpm-package'>Modeling of Revealed Preferences Matchings</h2><span id='topic+rpm-package'></span>

<h3>Description</h3>

<p>An integrated set of tools to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>


<h3>Details</h3>

<p>For a complete list of the functions, use <code>library(help="rpm")</code> or
read the rest of the manual.
</p>
<p>When publishing results obtained using this package the original authors are
to be cited as:
</p>
<p>Mark S. Handcock, Ryan M. Admiraal, Fiona C. Yeung, Heide M. Jackson, Michael S. Rendall and Shuchi Goyal (2022) <span class="pkg">rpm</span>: Modeling of Revealed Preferences Matchings
R package, Los Angeles, CA.  Version 0.70, <a href="https://github.com/handcock/rpm">https://github.com/handcock/rpm</a>.
</p>
<p>All programs derived from this package must cite it. For complete citation
information, use<br /> <code>citation(package="rpm")</code>.
</p>
<p>For details on how to construct data for input to <code>rpm()</code> see the documentation:
</p>
<p><code>help(fauxmatching)</code>
</p>
<p>For information on the current terms that can be used in formulas for <code>rpm()</code> see the documentation:
</p>
<p><code>help("rpm-terms")</code>
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock &lt;handcock@stat.ucla.edu&gt;
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
summary(fit)

# For details on how to construct data for input:
help(fauxmatching)
# For information on the current terms that can be used in formulas:
help("rpm-terms")

</code></pre>

<hr>
<h2 id='rpm-terms'>Terms used in a Revealed Preference Matchings Model</h2><span id='topic+rpm-terms'></span><span id='topic+rpm.terms'></span><span id='topic+terms-rpm'></span><span id='topic+terms.rpm'></span><span id='topic+absdiff'></span><span id='topic+W_atleast'></span><span id='topic+W_atmost'></span><span id='topic+W_cov'></span><span id='topic+W_factor'></span><span id='topic+W_greaterthan'></span><span id='topic+M_atleast'></span><span id='topic+M_atmost'></span><span id='topic+M_cov'></span><span id='topic+M_factor'></span><span id='topic+M_greaterthan'></span><span id='topic+WtoM_diff'></span><span id='topic+MtoW_diff'></span><span id='topic+match'></span><span id='topic+diff'></span><span id='topic+mix'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+rpm">rpm</a></code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>


<h3>Details</h3>

<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code><a href="#topic+rpm">rpm</a></code>.  This page describes the possible terms (and hence
linear utility functions) included in <code><a href="#topic+rpm-package">rpm</a></code> package.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Specifying models</h3>

<p>Terms to <code><a href="#topic+rpm">rpm</a></code> are specified by a formula to represent the
pairings and covariates This is done via a <code>formula</code>, that is,
an formula object, of the form <code>~ &lt;term 1&gt; + &lt;term 2&gt; ...</code>, where
<code>&lt;term 1&gt;</code>, <code>&lt;term 2&gt;</code>, etc, are each terms chosen
from the list given below.
</p>

<dl>
<dt><code>absdiff(attr)</code> (quantitative attribute),
<code>absdiff(attr)</code> (quantitative attribute)</dt><dd><p><em>Absolute difference:</em>
The <code>attr</code> argument specifies a quantitative attribute 
This term adds one statistic to the model equaling
<code>abs(attr[i]-attr[j])</code> for all women-man dyad (i,j).
</p>
</dd>
<dt><code>W_greaterthan(attr)</code></dt><dd><p><em>Women's value
greater than the men's value</em> Adds one statistic
indicating if the women's value exceeds the men's value.
</p>
</dd>
<dt><code>M_greaterthan(attr)</code></dt><dd><p><em>Men's value
greater than the women's value</em> Adds one statistic
indicating if the men's value exceeds the women's value.
</p>
</dd>
<dt><code>W_atleast(attr,threshold=0)</code></dt><dd><p><em>Values
greater than or equal to a threshold</em> Adds one statistic
indicating if the women's value of the attribute equals or exceeds
<code>threshold</code>.
</p>
</dd>
<dt><code>W_atmost(threshold=0)</code></dt><dd><p><em>Values
less than or equal to a threshold</em> Adds one statistic
indicating if the women's value equals or is exceeded by
<code>threshold</code>.
</p>
</dd>
<dt><code>W_cov(attr)</code> (quantitative attribute),
<code>W_cov(attr)</code> (quantitative attribute)
</dt><dd><p><em>Main effect of a covariate for women:</em>
The <code>attr</code> argument specifies a quantitative attribute
This term adds a single statistic equaling the 
value of <code>attr(i)</code> for women <code class="reqn">i</code> in the dyad.
For categorical attributes,
see <code>W_factor</code>.
</p>
</dd>
<dt><code>diff(attr)</code> (quantitative attribute), <code>diff(attr)</code>
(quantitative attribute)</dt><dd><p><em>Woman's Gap:</em>
The <code>attr</code> argument specifies a quantitative attribute
This term adds one statistic to the model
being <code>attr[i]-attr[j]</code> for women <code class="reqn">i</code> and man <code class="reqn">j</code>.
Specifically, it is the excess of the woman's value over the man's value.
</p>
</dd>
<dt><code>WtoM_diff(attr, diff)</code> (ordinal categorical attribute), <code>WtoM_diff(attr)</code>
(ordinal categorical discrete attribute)</dt><dd><p><em>Woman's Gap:</em>
The <code>attr</code> argument specifies a ordinal categorical attribute
This term adds one statistic to the model
being an indicator that <code>attr[i]=attr[j]+diff</code> for women <code class="reqn">i</code> and man <code class="reqn">j</code>.
Specifically, it indicates if the woman's value is <code>diff</code> higher than the man's value.
</p>
</dd>
<dt><code>MtoW_diff(attr, diff)</code> (ordinal categorical attribute), <code>MtoW_diff(attr)</code>
(ordinal categorical discrete attribute)</dt><dd><p><em>Man's Gap:</em>
The <code>attr</code> argument specifies a ordinal categorical attribute
This term adds one statistic to the model
being an indicator that <code>attr[j]=attr[i]+diff</code> for women <code class="reqn">i</code> and man <code class="reqn">j</code>.
Specifically, it indicates if the man's value is <code>diff</code> higher than the woman's value.
</p>
</dd>
<dt><code>MtoW_diff(attr)</code> (quantitative attribute), <code>MtoW_diff(attr)</code>
(quantitative attribute)</dt><dd><p><em>Difference:</em>
The <code>attr</code> argument specifies a quantitative attribute
This term adds one statistic to the model
<code>attr[j]-attr[i]</code> for women <code class="reqn">i</code> and man <code class="reqn">j</code>.
</p>
</dd>
<dt><code>W_factor(attr, base=1, levels=-1)</code> (categorical attribute),
<code>W_factor(attr, base=1, levels=-1)</code> (categorical attribute)
</dt><dd><p><em>Factor attribute effect for women:</em>
The <code>attr</code> argument specifies a categorical attribute
This term adds
multiple statistics to the model, one for each of (a subset of) the
unique values of the <code>attr</code> attribute. Each of these statistics
indicates if the women's has that attribute.
</p>
</dd>
<dt><code>homophily(attr)</code>
</dt><dd><p><em>Uniform homophily effect:</em>
The <code>attr</code> argument specifies a categorical attribute
This term adds one statistic to the model
indicating that the dyad matches on that attribute.
</p>
</dd>
<dt><code>match(attr, diff=FALSE, collapse=NULL)</code>
</dt><dd><p><em>Attribute-based homophily effect:</em>
The <code>attr</code> argument specifies a categorical attribute
This term adds one statistic to the model for each categorical level,
unless <code>diff</code> is set to <code>TRUE</code>, in which case the term adds multiple 
statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code>
attribute. 
If <code>diff</code> is set to <code>TRUE</code>, the optional argument <code>collapse</code> control what dyads 
are collapsed (or pooled).
Specifically, it is a list of indices of attribute values which are to be collapsed into a
single term. For example, <code>collapse=list(c(1,4))</code> will collapse the <code>(1,1)</code> and the 
<code>(4,4)</code> dyads into a single term (and group). Multiple lists can be included with arbitrary numbers of 
dyads in a group. 
</p>
</dd>
<dt><code>mix(attr, base=NULL, collapse=NULL)</code>
</dt><dd><p><em>Attribute mixing:</em> The <code>attr</code> argument specifies a categorical attributes
By default, this term adds one statistic to
the model for each possible pairing of attribute values. The
statistic indicates if the dyad 
has that pairing of values.
In other words, this term produces one statistic for
every entry in the mixing matrix for the attribute(s). The ordering of
the attribute values is lexicographic: alphabetical (for nominal categories) or
numerical (for ordered categories).
The optional argument <code>base</code> control what statistics are 
included in the model, specifically it lists the index of the omitted terms (in order).
For example, <code>base=2</code> omits the second term. 
The optional argument <code>collapse</code> control what dyads are collapsed (or pooled).
Specifically, it is a list of lists. Each element of the list is a list of dyads which are to be collapsed into a
single term. For example, <code>collapse=list(list(c(1,4),c(2,4)))</code> will collapse the <code>(1,4)</code> and the 
<code>(2,4)</code> dyads into a single term (and group). Multiple lists can be included with arbitrary numbers of 
dyads in a group. 
</p>
</dd>
</dl>



<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpm-package">rpm</a></code> package,
<code><a href="#topic+rpm">rpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
summary(fit)

</code></pre>

<hr>
<h2 id='rpm.model.functions'>Creates a model function list for the continuous terms in a Revealed Preference Matchings Model</h2><span id='topic+rpm.model.functions'></span>

<h3>Description</h3>

<p><code><a href="#topic+rpm.model.matrix">rpm.model.matrix</a></code> assumes a bipartite network (i.e. two-sided matching market)
It creates a model matrix according to the formula passed in.
See <code><a href="#topic+rpm-terms">rpm-terms</a></code> for a description of the possible terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpm.model.functions(model.terms, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpm.model.functions_+3A_model.terms">model.terms</code></td>
<td>
<p>For the details on the possible countinuous <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+rpm-terms">rpm-terms</a></code>. This includes the 
covariates used to construct the model matrix.
They are used in conjunction with the model terms.</p>
</td></tr>
<tr><td><code id="rpm.model.functions_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model terms as bivariate functions.
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>rpm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># nothing yet
</code></pre>

<hr>
<h2 id='rpm.model.matrix'>Creates a model matrix to estimate the parameters of a Revealed Preference Matchings Model</h2><span id='topic+rpm.model.matrix'></span>

<h3>Description</h3>

<p><code><a href="#topic+rpm.model.matrix">rpm.model.matrix</a></code> assumes a bipartite network (i.e. two-sided matching market)
It creates a model matrix according to the formula passed in.
See <code><a href="#topic+rpm-terms">rpm-terms</a></code> for a description of the possible terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpm.model.matrix(model.terms, Xall, Zall, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpm.model.matrix_+3A_model.terms">model.terms</code></td>
<td>
<p>For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+rpm-terms">rpm-terms</a></code>. This includes the 
covariates used to construct the model matrix.
They are used in conjunction with the model terms.</p>
</td></tr>
<tr><td><code id="rpm.model.matrix_+3A_xall">Xall</code></td>
<td>
<p>the unique types of women</p>
</td></tr>
<tr><td><code id="rpm.model.matrix_+3A_zall">Zall</code></td>
<td>
<p>the unique types of men</p>
</td></tr>
<tr><td><code id="rpm.model.matrix_+3A_intercept">intercept</code></td>
<td>
<p>logical; If TRUE, the default, an intercept term is prepended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consists of the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the model matrix for women.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the model matrix for men.</p>
</td></tr>
<tr><td><code>Xnames</code></td>
<td>
<p>the names of the covariates for women.</p>
</td></tr> 
<tr><td><code>Znames</code></td>
<td>
<p>the names of the covariates for men.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>rpm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># nothing yet
</code></pre>

<hr>
<h2 id='rpmpopulationpmf'>Compute the population distribution of pairs and singles from a Revealed Preference Matchings Model</h2><span id='topic+rpmpopulationpmf'></span>

<h3>Description</h3>

<p><code><a href="#topic+rpmpopulationpmf">rpmpopulationpmf</a></code> computes the probability mass function for a population of the pairs and singles
from a Revealed Preference Matchings Model based on arbitary availability distribution and 
preferences. It is typically based on the estimate from a <code>rpm()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpmpopulationpmf(
  object,
  N = 2000,
  num_women = NULL,
  num_men = NULL,
  pmfW = NULL,
  pmfM = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpmpopulationpmf_+3A_object">object</code></td>
<td>
<p>list; an object of class<code>rpm</code> that is typically the result of a call to <code>rpm()</code>.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_n">N</code></td>
<td>
<p>integer; The total population size. This must be set. The number of women and men are derived from the
(weighted) data.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_num_women">num_women</code></td>
<td>
<p>integer; (Optional) The number of women in the population.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_num_men">num_men</code></td>
<td>
<p>integer; (Optional) The number of men in the population.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_pmfw">pmfW</code></td>
<td>
<p>vector; (Optional) The population proportions of the numbers of women of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_pmfm">pmfM</code></td>
<td>
<p>vector; (Optional) The population proportions of the numbers of men of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="rpmpopulationpmf_+3A_verbose">verbose</code></td>
<td>
<p>logical; Should verbose messages be printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+rpm">rpm</a></code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>
<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code><a href="#topic+rpm">rpm</a></code>. This function simulates from such a model.
</p>


<h3>Value</h3>

<p>A list of data.frame, each a simulation from the population.
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
a &lt;- rpmpopulationpmf(fit)

</code></pre>

<hr>
<h2 id='simulate.rpm'>Simulate a sample of pairs and singles from a Revealed Preference Matchings Model</h2><span id='topic+simulate.rpm'></span>

<h3>Description</h3>

<p><code><a href="#topic+simulate.rpm">simulate.rpm</a></code> simulates a population of the pairs and singles
from a Revealed Preference Matchings Model. It is typically based on the estimate from a <code>rpm()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  ...,
  N = NULL,
  num_women = NULL,
  num_men = NULL,
  pmfW = NULL,
  pmfM = NULL,
  large.population = TRUE,
  num_sampled = NULL,
  bootstrap = FALSE,
  sampling_design = NULL,
  control = control.rpm(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.rpm_+3A_object">object</code></td>
<td>
<p>list; an object of class<code>rpm</code> that is typically the result of a call to <code>rpm()</code>.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_nsim">nsim</code></td>
<td>
<p>Number of matchings to be randomly drawn from the given
model on the set of all matchings / singles.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_seed">seed</code></td>
<td>
<p>integer; (Optional) random number seed.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_n">N</code></td>
<td>
<p>integer; The total population size. This must be set. The number of women and men are derived from the
(weighted) data.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_num_women">num_women</code></td>
<td>
<p>integer; (Optional) The number of women in the population.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_num_men">num_men</code></td>
<td>
<p>integer; (Optional) The number of men in the population.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_pmfw">pmfW</code></td>
<td>
<p>vector; (Optional) The population proportions of the numbers of women of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_pmfm">pmfM</code></td>
<td>
<p>vector; (Optional) The population proportions of the numbers of men of each type. 
This should be compatible with the type in the object.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_large.population">large.population</code></td>
<td>
<p>logical; If TRUE a large population approximation is used to generate
the matchings (rather than the individual level generation of utilities). This is much faster and
uses a lot less memory. It is TRUE by default. If used, a sample is drawn rather than the
population being returned. The sample size is controlled by <code>num_sampled</code>.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_num_sampled">num_sampled</code></td>
<td>
<p>integer; The size of the sample to be drawn. For &quot;stock-stock&quot; sampling this is the 
number of sampled households. For &quot;stock-flow&quot; it is the number of sampled people.
For &quot;census&quot; it is the total population size, N. If NULL the size is the same as
the passed fitted object (that is, the original data), although this is only a guess and it should be explicitly set.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical; If TRUE the original population is sampled from. If FALSE the
population underlying the fitted model is sampled from.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_sampling_design">sampling_design</code></td>
<td>
<p>string; The name of the sampling protocol used to select the survey data. Valid values are
<code>"stock-flow"</code> (individuals are sampled, data contains both
singles and couples);
<code>"stock-stock"</code> (households are sampled, each household can be a single or a couple);
<code>"census"</code> (the sample is a census of the population of people).
The final option, the default, is NULL whereby the design is taken from the passed object.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="simulate.rpm_+3A_verbose">verbose</code></td>
<td>
<p>logical; Should verbose messages be printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+rpm">rpm</a></code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>
<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code><a href="#topic+rpm">rpm</a></code>. This function simulates from such a model.
</p>


<h3>Value</h3>

<p>A list of data.frame, each a simulation from the population.
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)

data(fauxmatching)
fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
a &lt;- simulate(fit)

</code></pre>

<hr>
<h2 id='summary_rpm'>Summarize Revealed Preference Matchings data via a Model Specification</h2><span id='topic+summary_rpm'></span><span id='topic+print.summary_rpm'></span><span id='topic+show.summary_rpm'></span>

<h3>Description</h3>

<p><code><a href="#topic+summary_rpm">summary_rpm</a></code> produces tabular summaries of data revealed preference matchings
based on a formula specifying a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_rpm(
  formula,
  Xdata,
  Zdata,
  Xid = NULL,
  Zid = NULL,
  pair_id = NULL,
  X_w = NULL,
  Z_w = NULL,
  pair_w = NULL,
  sampled = NULL,
  sampling_design = "stock-flow",
  control = control.rpm(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_rpm_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="stats.html#topic+formula">formula</a></code> object, of the form <code>
~ &lt;model terms&gt;</code>. For the details on the possible <code>&lt;model terms&gt;</code>, see
<code><a href="#topic+rpm-terms">rpm-terms</a></code>.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_xdata">Xdata</code></td>
<td>
<p>data.frame for women. Each row is a woman, each column is a variable on that women
or her partnerships. It must contain the women's ID variable (see <code>Xid</code>) and
a variable with the ID of the women's partner. If the women is single the men's ID should be NA.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_zdata">Zdata</code></td>
<td>
<p>data.frame for men. Each row is a man, each column is a variable on that men
It must contain the men's ID variable (see <code>Zid</code>).</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_xid">Xid</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the IDs of the women.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_zid">Zid</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the IDs of the men.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_pair_id">pair_id</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the ID of the men paired with the women in
<code>Xid</code>. If the women is not paired it must be NA.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_x_w">X_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the individual weight of the women.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 women in it.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_z_w">Z_w</code></td>
<td>
<p>string The name of the variable in <code>Zdata</code> containing the individual weight of the man
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_pair_w">pair_w</code></td>
<td>
<p>string The name of the variable in <code>Xdata</code> containing the pair weight of that women.
If the women is not paired it should be NA.
If this is NULL then it is computed from the individual weights using the <code>sampling_design</code>.
Note that the pair weights currently do not play a role in the estimation. They do in the quasi-likelihood version of the code.
If this is NULL then it is assumed the sample is unweighted from a population with 2000 men in it.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_sampled">sampled</code></td>
<td>
<p>string The name of the logical variable in <code>Xdata</code> and <code>Zdata</code> containing the 
indicator that the person was sampled directly (as distinct from being included as the match of a directly sampled
person. All single people are directly sampled.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_sampling_design">sampling_design</code></td>
<td>
<p>string; The name of the sampling protocol used to select the survey data. Valid values are
<code>"stock-flow"</code> (default) (individuals are sampled, data contains both
singles and couples);
<code>"stock-stock"</code> (households are sampled, each household can be a single or a couple);
<code>"census"</code> (the sample is a census of the population of people).</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code><a href="#topic+control.rpm">control.rpm</a></code>, which should be consulted for specifics.</p>
</td></tr>
<tr><td><code id="summary_rpm_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out
additional information, including data summary statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pairings are determined by the <code>pair_id</code> variable in <code>Xdata</code>. 
If that variable is NA then the women is
assumed to be single. If men are listed in <code>Zdata</code> and are not partnered then they are assumed single.
Weights are specified by three optional variables in <code>Xdata</code>.
</p>

<ul>
<li><p>X_w: This is character string of the name of the weight variable for women. The sum of the weights should be the
number of women in the population.
</p>
</li>
<li><p>Z_w: This is character string of the name of the weight variable for men. The sum of the weights should be the
number of men in the population.
</p>
</li>
<li><p>pair_w: This is character string of the name of the weight variable for pairs.
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> returns a list with many components, like <code><a href="#topic+rpm">rpm</a></code> object without the model estimates. In particular it includes <code>stats</code> and <code>popstats</code>.
<code>stats</code> is the named vector of sample statistics from the model. 
while <code>popstats</code> is the named vector of population statistics from the model. 
It alos includes <code>counts</code> and <code>pmf</code>. Each of these is a contingency table in array
representation of S3 class <code>c("xtabs", "table")</code>, with a <code>"call"</code>
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>See Also</h3>

<p>control.rpm, summary.rpm, rpm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)
summary_rpm(~match("edu") + WtoM_diff("edu",3),
        Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
        X_w="X_w", Z_w="Z_w",
        pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
        sampled="sampled",sampling_design="stock-flow")
</code></pre>

<hr>
<h2 id='summary.rpm'>Summarizing rpm Model Fits</h2><span id='topic+summary.rpm'></span><span id='topic+print.summary.rpm'></span>

<h3>Description</h3>

<p>[base::summary()] method for [rpm()] fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpm'
summary(
  object,
  ...,
  digits = max(3, getOption("digits") - 3),
  correlation = FALSE,
  covariance = FALSE,
  include.single = TRUE
)

## S3 method for class 'summary.rpm'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  correlation = FALSE,
  covariance = FALSE,
  signif.stars = getOption("show.signif.stars"),
  eps.Pvalue = 1e-04,
  print.header = TRUE,
  print.formula = FALSE,
  print.fitinfo = TRUE,
  print.coefmat = TRUE,
  print.message = TRUE,
  print.deviances = TRUE,
  print.drop = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rpm_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+rpm">rpm</a></code>, usually, a result of a call to
[rpm()].</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_...">...</code></td>
<td>
<p>For [summary.rpm()] additional arguments are passed to
[logLik.rpm()]. For [print.summary.rpm()], to [stats::printCoefmat()].</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_digits">digits</code></td>
<td>
<p>significant digits for coefficients. The default is max(3, getOption(&quot;digits&quot;)-3).</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_correlation">correlation</code></td>
<td>
<p>logical whether the correlation matrix of the estimated parameters
should be printed (T or F); default=FALSE</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_covariance">covariance</code></td>
<td>
<p>logical whether the covariance matrix of the estimated parameters
should be printed (T or F); default=FALSE</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_include.single">include.single</code></td>
<td>
<p>logical; if 'TRUE', include in the summary table the 
coefficients of the log-odds of being single for each category of women and men.</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_x">x</code></td>
<td>
<p>object of class 'summary.rpm' returned by [summary.rpm()].</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>whether to print dots and stars to signify
statistical significance. See [print.summary.lm()].</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_eps.pvalue">eps.Pvalue</code></td>
<td>
<p><code class="reqn">p</code>-values below this level will be printed
as &quot;&lt;'eps.Pvalue'&quot;.</p>
</td></tr>
<tr><td><code id="summary.rpm_+3A_print.formula">print.formula</code>, <code id="summary.rpm_+3A_print.fitinfo">print.fitinfo</code>, <code id="summary.rpm_+3A_print.coefmat">print.coefmat</code>, <code id="summary.rpm_+3A_print.message">print.message</code>, <code id="summary.rpm_+3A_print.deviances">print.deviances</code>, <code id="summary.rpm_+3A_print.drop">print.drop</code>, <code id="summary.rpm_+3A_print.header">print.header</code></td>
<td>
<p>which components of the fit summary to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>[summary.rpm()] tries to be smart about formatting the
coefficients, standard errors, etc.
</p>
<p>The default printout of the summary object contains the
call, number of iterations used, null and residual deviances, and
the values of AIC and BIC.
The coefficient table contains the following
columns:
</p>
<p>- 'Estimate', 'Std. Error' - parameter estimates and their standard errors
- 'z value', 'Pr(&gt;|z|)' - z-test and p-values
</p>


<h3>Value</h3>

<p>The function [summary.rpm()] computes and returns a list of summary
statistics of the fitted [rpm()] model given in 'object'. Note that for
backwards compatibility, it returns the coefficient table.
</p>
<p>The returned object is a list of class &quot;summary.rpm&quot; with the following
elements:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>ERGM model formula</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>the 'digits' inputted to &lt;summary.rpm&gt; or the default value (despite the fact the digits will be 5)</p>
</td></tr>
<tr><td><code>correlation</code>, <code>covariance</code></td>
<td>
<p>whether to print correlation/covariance matrices of the estimated parameters</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>object$iterations</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the [control.rpm()] object used</p>
</td></tr>
<tr><td><code>samplesize</code></td>
<td>
<p>MCMC sample size</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>optional message on the validity of the standard error estimates</p>
</td></tr>
<tr><td><code>aic.null</code>, <code>bic.null</code></td>
<td>
<p>values of AIC and BIC for the null model</p>
</td></tr>
<tr><td><code>aic</code>, <code>bic</code></td>
<td>
<p>values of AIC and BIC</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>data frames with model parameters and associated statistics</p>
</td></tr>
<tr><td><code>asycov</code></td>
<td>
<p>asymptotic covariance matrix</p>
</td></tr>
<tr><td><code>asyse</code></td>
<td>
<p>asymptotic standard error matrix</p>
</td></tr>
<tr><td><code>offset</code>, <code>drop</code>, <code>estimate</code>, <code>iterations</code>, <code>mle.lik</code>, <code>null.lik</code></td>
<td>

<p>see documentation of the object returned by [rpm()]
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function [rpm()], [print.rpm()], and
[base::summary()]. Function [stats::coef()] will extract the data frame of
coefficients with standard errors, t-statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpm)
data(fauxmatching)

fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled",sampling_design="stock-flow")
summary(fit)

</code></pre>

<hr>
<h2 id='ult+26lt+3B-'>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.</h2><span id='topic+ult+3C-'></span><span id='topic+ult'></span>

<h3>Description</h3>

<p>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ult(x, i = 1L) &lt;- value

ult(x, i = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ult+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a vector or a list.</p>
</td></tr>
<tr><td><code id="ult+2B26lt+2B3B-_+3A_i">i</code></td>
<td>
<p>index from the end of the list to extract or replace (where 1 is the last element, 2 is the penultimate element, etc.).</p>
</td></tr>
<tr><td><code id="ult+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Replacement value for the 'i'th element from the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of 'x'.
</p>


<h3>Note</h3>

<p>Due to the way in which assigning to a function is
implemented in R, 'ult(x) &lt;- e' may be less efficient than
'x[[length(x)]] &lt;- e'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(1:5))
(ult(x) &lt;- 6)
(ult(x, 2) &lt;- 7) # 2nd last.
x



x &lt;- 1:5
(last &lt;- ult(x))
(penultimate &lt;- ult(x, 2)) # 2nd last.



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
