<!DOCTYPE html><html><head><title>Help for package stagedtrees</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stagedtrees}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stagedtrees'><p>Staged event trees.</p></a></li>
<li><a href='#as_adj_matrix'><p>Convert to an adjacency matrix</p></a></li>
<li><a href='#as_bn'><p>Convert to a <span class="pkg">bnlearn</span> object</p></a></li>
<li><a href='#as_parentslist'><p>Obtain the equivalent DAG as list of parents</p></a></li>
<li><a href='#as_sevt'><p>Coerce to sevt</p></a></li>
<li><a href='#as.character.parentslist'><p>Print a parentslist object</p></a></li>
<li><a href='#Asym'><p>Asym dataset</p></a></li>
<li><a href='#barplot.sevt'><p>Bar plots of stage probabilities</p></a></li>
<li><a href='#ceg'><p>Chain event graph (CEG)</p></a></li>
<li><a href='#ci_matrices'><p>Conditional independences matrices of stages</p></a></li>
<li><a href='#cid'><p>Context specific interventional discrepancy</p></a></li>
<li><a href='#compare_stages'><p>Compare two staged event tree</p></a></li>
<li><a href='#confint.sevt'><p>Confidence intervals for staged event tree parameters</p></a></li>
<li><a href='#covid_patients'><p>Trajectories of hospitalized SARS-CoV-2 patients</p></a></li>
<li><a href='#depsubtree'><p>Extract dependency subtree</p></a></li>
<li><a href='#distance_mat_stages'><p>Compute the distance matrix</p></a></li>
<li><a href='#edge'><p>Plot an edge</p></a></li>
<li><a href='#erase_fit'><p>Erase the sevt fit</p></a></li>
<li><a href='#expand_prob'><p>Expand probabilities of a staged event tree</p></a></li>
<li><a href='#find_stage'><p>Find the stage of the path</p></a></li>
<li><a href='#full_indep'><p>Full and independent staged event tree</p></a></li>
<li><a href='#generate_linear_dataset'><p>Generate a random binary dataset for classification</p></a></li>
<li><a href='#generate_random_dataset'><p>Generate a random binary dataset</p></a></li>
<li><a href='#generate_xor_dataset'><p>Generate a xor dataset</p></a></li>
<li><a href='#get_stage'><p>Get stage or path</p></a></li>
<li><a href='#has_ctables'><p>Check sevt objects</p></a></li>
<li><a href='#igraph-conversion'><p><span class="pkg">igraph</span> conversion</p></a></li>
<li><a href='#inclusions_stages'><p>Inclusions of stages</p></a></li>
<li><a href='#join_positions'><p>join positions in a staged tree model</p></a></li>
<li><a href='#join_stages'><p>Join stages</p></a></li>
<li><a href='#join_unobserved'><p>Join situations with no observations</p></a></li>
<li><a href='#logLik.sevt'><p>Log-Likelihood of a staged event tree</p></a></li>
<li><a href='#lr_test'><p>Likelihood Ratio Test for staged trees models</p></a></li>
<li><a href='#make_ctables'><p>Distribute counts along tree</p></a></li>
<li><a href='#new_label'><p>New label</p></a></li>
<li><a href='#node'><p>Plot a node</p></a></li>
<li><a href='#noisy_xor'><p>noisy xor function</p></a></li>
<li><a href='#path_probability'><p>Compute probability of a path from root</p></a></li>
<li><a href='#PhDArticles'><p>PhD Students Publications</p></a></li>
<li><a href='#plot.ceg'><p>igraph's plotting for CEG</p></a></li>
<li><a href='#plot.sevt'><p>Plot method for staged event trees</p></a></li>
<li><a href='#Pokemon'><p>Pokemon Go Users</p></a></li>
<li><a href='#predict.sevt'><p>Predict method for staged event tree</p></a></li>
<li><a href='#print.sevt'><p>Print a staged event tree</p></a></li>
<li><a href='#prob'><p>Probabilities for a staged event tree</p></a></li>
<li><a href='#probdist'><p>Distances between probabilities</p></a></li>
<li><a href='#random_parentslist'><p>Generate a random <code>parentslist</code> object (DAG)</p></a></li>
<li><a href='#random_sevt'><p>Generate a random (fitted) sevt</p></a></li>
<li><a href='#rename_stage'><p>Rename stage(s) in staged event tree</p></a></li>
<li><a href='#sample_from'><p>Sample from a staged event tree</p></a></li>
<li><a href='#search_best'><p>Optimal Order Search</p></a></li>
<li><a href='#search_greedy'><p>Greedy Order Search</p></a></li>
<li><a href='#sevt'><p>Staged event tree (sevt) class</p></a></li>
<li><a href='#sevt_add'><p>Add a variable to a staged event tree</p></a></li>
<li><a href='#sevt_df'><p>Number of parameters of a staged event tree</p></a></li>
<li><a href='#sevt_fit'><p>Fit a staged event tree</p></a></li>
<li><a href='#sevt_nvar'><p>Number of variables</p></a></li>
<li><a href='#sevt_simplify'><p>Simplify a staged tree model</p></a></li>
<li><a href='#sevt_varnames'><p>Variable names</p></a></li>
<li><a href='#split_stage_random'><p>Split randomly a stage</p></a></li>
<li><a href='#stages'><p>The stages of a staged event tree</p></a></li>
<li><a href='#stages_bhc'><p>Backward hill-climbing</p></a></li>
<li><a href='#stages_bhcr'><p>Backward random hill-climbing</p></a></li>
<li><a href='#stages_bj'><p>Backward joining of stages</p></a></li>
<li><a href='#stages_csbhc'><p>Context-specific Backward hill-climbing</p></a></li>
<li><a href='#stages_fbhc'><p>Fast backward hill-climbing</p></a></li>
<li><a href='#stages_hc'><p>Hill-climbing</p></a></li>
<li><a href='#stages_hclust'><p>Learn a staged tree with hierarchical clustering</p></a></li>
<li><a href='#stages_kmeans'><p>Learn a staged tree with k-means clustering</p></a></li>
<li><a href='#stages_simplebhc'><p>Backward hill-climbing for simple staged trees</p></a></li>
<li><a href='#stndnaming'><p>Standard renaming of stages</p></a></li>
<li><a href='#subtree'><p>Extract subtree</p></a></li>
<li><a href='#summary.sevt'><p>Summarizing staged event trees</p></a></li>
<li><a href='#text.sevt'><p>Add text to a staged event tree plot</p></a></li>
<li><a href='#trajectories'><p>Hospital trajectories</p></a></li>
<li><a href='#tree_idx'><p>return path index</p></a></li>
<li><a href='#tree_string'><p>Tree string</p></a></li>
<li><a href='#uni_idx'><p>Unique id from named list</p></a></li>
<li><a href='#which_class'><p>Find maximum value</p></a></li>
<li><a href='#write_tikz'><p>Export the staged tree or CEG graph to tikz</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Staged Event Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates and fits staged event tree probability models,
             which are probabilistic graphical models capable of representing
             asymmetric conditional independence statements
             for categorical variables.
             Includes functions to create, plot and fit staged
             event trees from data, as well as many efficient structure
             learning algorithms.
             References:
             Carli F, Leonelli M, Riccomagno E, Varando G (2022).
             &lt;<a href="https://doi.org/10.18637%2Fjss.v102.i06">doi:10.18637/jss.v102.i06</a>&gt;.
             Collazo R. A., Görgen C. and Smith J. Q.
             (2018, ISBN:9781498729604).
             Görgen C., Bigatti A., Riccomagno E. and Smith J. Q. (2018)
             &lt;<a href="https://doi.org/10.48550/arXiv.1705.09457">doi:10.48550/arXiv.1705.09457</a>&gt;.
             Thwaites P. A., Smith, J. Q. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1510.00186">doi:10.48550/arXiv.1510.00186</a>&gt;.
             Barclay L. M., Hutton J. L. and Smith J. Q. (2013)
             &lt;<a href="https://doi.org/10.1016%2Fj.ijar.2013.05.006">doi:10.1016/j.ijar.2013.05.006</a>&gt;.
             Smith J. Q. and Anderson P. E. (2008)
             &lt;<a href="https://doi.org/10.1016%2Fj.artint.2007.05.004">doi:10.1016/j.artint.2007.05.004</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stagedtrees/stagedtrees">https://github.com/stagedtrees/stagedtrees</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stagedtrees/stagedtrees/issues">https://github.com/stagedtrees/stagedtrees/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, cli, rlang, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), bnlearn, covr, clue, igraph</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 10:59:25 UTC; gherardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Gherardo Varando <a href="https://orcid.org/0000-0002-6708-1103"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Federico Carli [aut],
  Manuele Leonelli <a href="https://orcid.org/0000-0002-2562-5192"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Eva Riccomagno [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gherardo Varando &lt;gherardo.varando@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stagedtrees'>Staged event trees.</h2><span id='topic+stagedtrees-package'></span><span id='topic+stagedtrees'></span>

<h3>Description</h3>

<p>Algorithms to create, learn, fit and explore staged event tree models.
Functions to compute probabilities, make predictions from the fitted
models and to plot, analyze and manipulate staged event trees.
</p>


<h3>Details</h3>

<p>A staged event tree is a representation of a particular
factorization of a joint probability over a product space.
In particular, given a vector of categorical random variables
<code class="reqn">X1, X2, \ldots</code>, a staged event tree represents the factorization
<code class="reqn">P(X1, X2, X3, \ldots) = P(X1)P(X2 | X1) P(X3 | X1, X2) \ldots </code>.
Additionally, the stages structure indicates which conditional probabilities
are equal.
</p>
<p>Model selection algorithms:
</p>

<ul>
<li><p> full model <code><a href="#topic+full">full</a></code>
</p>
</li>
<li><p> independence model <code><a href="#topic+indep">indep</a></code>
</p>
</li>
<li><p> Hill-Climbing <code><a href="#topic+stages_hc">stages_hc</a></code>
</p>
</li>
<li><p> Backward Hill-Climbing <code><a href="#topic+stages_bhc">stages_bhc</a></code>
</p>
</li>
<li><p> Fast Backward Hill-Climbing <code><a href="#topic+stages_fbhc">stages_fbhc</a></code>
</p>
</li>
<li><p> Backward Hill-Climbing Random <code><a href="#topic+stages_bhcr">stages_bhcr</a></code>
</p>
</li>
<li><p> Backward joining <code><a href="#topic+stages_bj">stages_bj</a></code>
</p>
</li>
<li><p> Simple Backward Hill-Climbing <code><a href="#topic+stages_simplebhc">stages_simplebhc</a></code>
</p>
</li>
<li><p> Hierarchical Clustering <code><a href="#topic+stages_hclust">stages_hclust</a></code>
</p>
</li>
<li><p> K-Means Clustering <code><a href="#topic+stages_kmeans">stages_kmeans</a></code>
</p>
</li>
<li><p> Optimal order search <code><a href="#topic+search_best">search_best</a></code>
</p>
</li>
<li><p> Greedy order search <code><a href="#topic+search_greedy">search_greedy</a></code>
</p>
</li></ul>

<p>Probabilities, log-likelihood and predictions:
</p>

<ul>
<li><p> Marginal/Conditional probabilities <code><a href="#topic+prob">prob</a></code>
</p>
</li>
<li><p> Log-Likelihood <code><a href="#topic+logLik.sevt">logLik.sevt</a></code>
</p>
</li>
<li><p> Predict method <code><a href="#topic+predict.sevt">predict.sevt</a></code>
</p>
</li>
<li><p> Confidence intervals <code><a href="#topic+confint.sevt">confint.sevt</a></code>
</p>
</li></ul>

<p>Plot, explore and compare:
</p>

<ul>
<li><p> Plot <code><a href="#topic+plot.sevt">plot.sevt</a></code>
</p>
</li>
<li><p> Compare <code><a href="#topic+compare_stages">compare_stages</a></code>
</p>
</li>
<li><p> Stages inclusion <code><a href="#topic+inclusions_stages">inclusions_stages</a></code>
</p>
</li>
<li><p> Stages info <code><a href="#topic+summary.sevt">summary.sevt</a></code>
</p>
</li>
<li><p> List of parents <code><a href="#topic+as_parentslist">as_parentslist</a></code>
</p>
</li>
<li><p> Barplot construction <code><a href="#topic+barplot.sevt">barplot.sevt</a></code>
</p>
</li>
<li><p> Likelihood-ratio test <code><a href="#topic+lr_test">lr_test</a></code>
</p>
</li>
<li><p> Context-specific interventional distance <code><a href="#topic+cid">cid</a></code>
</p>
</li></ul>

<p>Modify models:
</p>

<ul>
<li><p> Join and isolate unobserved situations <code><a href="#topic+join_unobserved">join_unobserved</a></code>
</p>
</li>
<li><p> Join two stages <code><a href="#topic+join_stages">join_stages</a></code>
</p>
</li>
<li><p> Join two positions <code><a href="#topic+join_positions">join_positions</a></code>
</p>
</li>
<li><p> Rename a stage <code><a href="#topic+rename_stage">rename_stage</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gherardo Varando <a href="mailto:gherardo.varando@gmail.com">gherardo.varando@gmail.com</a> (<a href="https://orcid.org/0000-0002-6708-1103">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Federico Carli
</p>
</li>
<li><p> Manuele Leonelli (<a href="https://orcid.org/0000-0002-2562-5192">ORCID</a>)
</p>
</li>
<li><p> Eva Riccomagno
</p>
</li></ul>



<h3>References</h3>

<p>Collazo R. A., Görgen C. and Smith J. Q.
Chain event graphs. CRC Press, 2018.
</p>
<p>Görgen C., Bigatti A., Riccomagno E. and Smith J. Q.
Discovery of statistical equivalence classes using computer algebra.
<em>International Journal of Approximate Reasoning</em>, vol. 95, pp. 167-184, 2018.
</p>
<p>Barclay L. M., Hutton J. L. and Smith J. Q.
Refining a Bayesian network using a chain event graph.
<em>International Journal of Approximate Reasoning</em>, vol. 54, pp. 1300-1309, 2013.
</p>
<p>Smith J. Q. and Anderson P. E.
Conditional independence and chain event graphs.
<em>Artificial Intelligence</em>, vol. 172, pp. 42-68, 2008.
</p>
<p>Thwaites P. A., Smith, J. Q.
A new method for tackling asymmetric decision problems.
<em>International Journal of Approximate Reasoning</em>, vol. 88, pp. 624–639, 2017.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stagedtrees/stagedtrees">https://github.com/stagedtrees/stagedtrees</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stagedtrees/stagedtrees/issues">https://github.com/stagedtrees/stagedtrees/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("PhDArticles")
mf &lt;- full(PhDArticles, join_unobserved = TRUE)
mod &lt;- stages_fbhc(mf)
plot(mod)
</code></pre>

<hr>
<h2 id='as_adj_matrix'>Convert to an adjacency matrix</h2><span id='topic+as_adj_matrix'></span><span id='topic+as_adj_matrix.parentslist'></span><span id='topic+as_adj_matrix.ceg'></span>

<h3>Description</h3>

<p>Convert to an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_matrix(x, ...)

## S3 method for class 'parentslist'
as_adj_matrix(x, ...)

## S3 method for class 'ceg'
as_adj_matrix(x, ignore = x$name_unobserved, endnode = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_matrix_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="as_adj_matrix_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="as_adj_matrix_+3A_ignore">ignore</code></td>
<td>
<p>list of stages to be ignored.</p>
</td></tr>
<tr><td><code id="as_adj_matrix_+3A_endnode">endnode</code></td>
<td>
<p>logical value. If <code>TRUE</code> a final node fil be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the equivalent adjacency matrix
</p>
<p>for <code>as_adj_matrix.ceg</code>: the adj matrix corresponding to the CEG.
</p>

<hr>
<h2 id='as_bn'>Convert to a <span class="pkg">bnlearn</span> object</h2><span id='topic+as_bn'></span><span id='topic+as_bn.parentslist'></span><span id='topic+as_bn.sevt'></span>

<h3>Description</h3>

<p>Convert a staged tree object into an object of class <code>bn</code>
from the <span class="pkg">bnlearn</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bn(x)

## S3 method for class 'parentslist'
as_bn(x)

## S3 method for class 'sevt'
as_bn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_bn_+3A_x">x</code></td>
<td>
<p>an R object of class <code>sevt</code> or <code>parentslist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>bn</code> from package <span class="pkg">bnlearn</span>.
</p>

<hr>
<h2 id='as_parentslist'>Obtain the equivalent DAG as list of parents</h2><span id='topic+as_parentslist'></span><span id='topic+as_parentslist.bn'></span><span id='topic+as_parentslist.bn.fit'></span><span id='topic+as_parentslist.sevt'></span>

<h3>Description</h3>

<p>Convert to the equivalent representation as list of parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_parentslist(x, ...)

## S3 method for class 'bn'
as_parentslist(x, order = NULL, ...)

## S3 method for class 'bn.fit'
as_parentslist(x, order = NULL, ...)

## S3 method for class 'sevt'
as_parentslist(x, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_parentslist_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as_parentslist_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code id="as_parentslist_+3A_order">order</code></td>
<td>
<p>order of the variables, usually a topological order.</p>
</td></tr>
<tr><td><code id="as_parentslist_+3A_silent">silent</code></td>
<td>
<p>if function should be silent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of this function is an object of class
<code>parentslist</code> which is one of the possible encoding for
a directed graph. This is mainly an internal class and its
specification can be changed in the future.
For example, now it may also include information on the
sample space of the variables and the context/partial/local
independences.
</p>
<p>In <code>as_parentslist.sevt</code>, if a context-specific or a local-partial independence is detected
a message is printed (if <code>silent = FALSE</code>) and the minimal super-model is returned.
</p>


<h3>Value</h3>

<p>An object of class <code>parentslist</code> for which a
print method exists.
Basically a list with
one entries for each variable with fields:
</p>

<ul>
<li> <p><code>parents</code> The parents of the variable.
</p>
</li>
<li> <p><code>context</code> Where context independences are detected.
</p>
</li>
<li> <p><code>partial</code> Where partial independences are detected.
</p>
</li>
<li> <p><code>local</code> Where no context/partial independences are detected,
but local independences are present.
</p>
</li>
<li> <p><code>values</code> values for the variable.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+print.parentslist">print.parentslist</a></code> and
<code><a href="#topic+as.character.parentslist">as.character.parentslist</a></code> for the parenthesis-encoding of the
DAG structure and the asymmetric independences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_hclust(full(Titanic), k = 2)
pl &lt;- as_parentslist(model)
pl$Age
</code></pre>

<hr>
<h2 id='as_sevt'>Coerce to sevt</h2><span id='topic+as_sevt'></span><span id='topic+as_sevt.bn.fit'></span><span id='topic+as_sevt.bn'></span><span id='topic+as_sevt.parentslist'></span>

<h3>Description</h3>

<p>Convert to an equivalent object of class <code><a href="#topic+sevt">sevt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sevt(x, ...)

## S3 method for class 'bn.fit'
as_sevt(x, order = NULL, ...)

## S3 method for class 'bn'
as_sevt(x, order = NULL, values = NULL, ...)

## S3 method for class 'parentslist'
as_sevt(x, order = NULL, values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sevt_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as_sevt_+3A_...">...</code></td>
<td>
<p>additional parameters to be used by specific methods.</p>
</td></tr>
<tr><td><code id="as_sevt_+3A_order">order</code></td>
<td>
<p>order of the variables.</p>
</td></tr>
<tr><td><code id="as_sevt_+3A_values">values</code></td>
<td>
<p>the values for each variable, the sample space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>as_sevt.bn.fit</code> the <code>order</code>
argument, if provided, must be a topological order of the
<code>bn.fit</code> object (no check is performed). If the order is not provided
a topological order will be used (the one returned by
<code>bnlearn::node.ordering</code>).
</p>
<p>In <code>as_sevt.parentslist</code> the <code>order</code>
argument, if provided, must be a topological order of the
corresponding DAG (no check is performed).
If the order is not provided
<code>names(x)</code> is used.
</p>
<p>The <code>values</code> parameter is used to specify the sample space
of each variable. For a <code>parentslist</code> object created with
<code><a href="#topic+as_parentslist">as_parentslist</a></code> from an object of class <code>sevt</code>,
it is, usually, not needed to specify the <code>values</code> parameter,
since the sample space is saved in the <code>parentslist</code> object.
</p>


<h3>Value</h3>

<p>the equivalent object of class <code><a href="#topic+sevt">sevt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_hclust(full(Titanic), k = 2)
plot(model)
pl &lt;- as_parentslist(model)
model2 &lt;- as_sevt(pl)
plot(model2) ## this is a super-model of the first staged tree
## we can check it with
inclusions_stages(model, model2)
</code></pre>

<hr>
<h2 id='as.character.parentslist'>Print a parentslist object</h2><span id='topic+as.character.parentslist'></span><span id='topic+print.parentslist'></span>

<h3>Description</h3>

<p>Nice print of a parentslist object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parentslist'
as.character(x, only_parents = FALSE, ...)

## S3 method for class 'parentslist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.parentslist_+3A_x">x</code></td>
<td>
<p>an object of class <code>parentslist</code>.</p>
</td></tr>
<tr><td><code id="as.character.parentslist_+3A_only_parents">only_parents</code></td>
<td>
<p>logical, if the basic DAG encoding is to be returned.</p>
</td></tr>
<tr><td><code id="as.character.parentslist_+3A_...">...</code></td>
<td>
<p>additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.character.parentslist</code> returns a string
encoding the associated directed graph and eventually
the context specific independences.
The encoding is similar to the one returned by
<code>modelstring</code> in package <span class="pkg">bnlearn</span>
and package <span class="pkg">deal</span>.
In particular, parents of a variable can be enclosed in:
</p>

<ul>
<li> <p><code>( )</code> if a partial (conditional) independence is present.
</p>
</li>
<li> <p><code>{ }</code> if a context specific independence is present.
</p>
</li>
<li> <p><code>&lt; &gt;</code> if no context specific and partial (conditional)
independences are present, but at least a
local independence is detected.
</p>
</li></ul>

<p>If a parent is not enclosed in parenthesis the dependence is full.
</p>
<p>If <code>only_parents = TRUE</code>, the simple DAG encoding as in <span class="pkg">bnlearn</span>
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_hclust(full(Titanic), k = 2)
pl &lt;- as_parentslist(model)
pl
as.character(pl)
as.character(pl, only_parents = TRUE)
</code></pre>

<hr>
<h2 id='Asym'>Asym dataset</h2><span id='topic+Asym'></span>

<h3>Description</h3>

<p>Artificial dataset with observations from four variables
having a non-symmetrical conditional independence structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Asym
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations of 4 binary variables.
</p>


<h3>Source</h3>

<p>The data has been generated by Federico Carli <a href="mailto:carli@dima.unige">carli@dima.unige</a>.
</p>

<hr>
<h2 id='barplot.sevt'>Bar plots of stage probabilities</h2><span id='topic+barplot.sevt'></span>

<h3>Description</h3>

<p>Create a bar plot visualizing probabilities associated to the
different stages of a variable in a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
barplot(
  height,
  var,
  ignore = height$name_unobserved,
  beside = TRUE,
  horiz = FALSE,
  legend.text = FALSE,
  col = NULL,
  xlab = ifelse(horiz, "probability", NA),
  ylab = ifelse(!horiz, "probability", NA),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot.sevt_+3A_height">height</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_var">var</code></td>
<td>
<p>name of a variable in <code>object</code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_beside">beside</code></td>
<td>
<p>a logical value. See <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_horiz">horiz</code></td>
<td>
<p>a logical value. See <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_legend.text">legend.text</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_col">col</code></td>
<td>
<p>color mapping for the stages, see <code>col</code>
argument in <code><a href="#topic+plot.sevt">plot.sevt</a></code>.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="barplot.sevt_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As <code><a href="graphics.html#topic+barplot">barplot</a></code>:
A numeric vector (or matrix, when beside = TRUE),
giving the coordinates of all the bar midpoints drawn, useful
for adding to the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_fbhc(full(PhDArticles, lambda = 1))
barplot(model, "Kids", beside = TRUE)
</code></pre>

<hr>
<h2 id='ceg'>Chain event graph (CEG)</h2><span id='topic+ceg'></span>

<h3>Description</h3>

<p>Build the CEG representation from an object of class <code><a href="#topic+sevt">sevt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceg(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceg_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>ceg</code> is a staged event tree object with
additional information on the positions.
</p>


<h3>Value</h3>

<p>an object of class <code>ceg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(3, 100)
model &lt;- stages_bhc(full(DD))
model.ceg &lt;- ceg(model)
model.ceg$positions
</code></pre>

<hr>
<h2 id='ci_matrices'>Conditional independences matrices of stages</h2><span id='topic+ci_matrices'></span>

<h3>Description</h3>

<p>Generate the sequence of all the
conditional independences
matrices of stages for a given variable in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_matrices(object, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_matrices_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="ci_matrices_+3A_var">var</code></td>
<td>
<p>string, the name of one of the variables in <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>i-1</code> matrices, where <code>i</code> is the depth
of variable <code>var</code> in the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- sevt(list(A = c("a", "aa"),
                 B = c("b", "bb", "bbb"),
                 C = c("c", "cc")), full = TRUE)
stages(mod)["C", A = "a", B = c("b", "bb")] &lt;- "stage1"
stages(mod)["C", A = "aa"] &lt;- "stage2"
stages(mod)["C", A = "a", B = "bbb"] &lt;- "stage2"

ci_matrices(mod, "C")
</code></pre>

<hr>
<h2 id='cid'>Context specific interventional discrepancy</h2><span id='topic+cid'></span>

<h3>Description</h3>

<p>Compute the context specific interventional discrepeancy
of a staged tree with respect to a reference staged tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cid(object1, object2, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cid_+3A_object1">object1</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code>.</p>
</td></tr>
<tr><td><code id="cid_+3A_object2">object2</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code>.</p>
</td></tr>
<tr><td><code id="cid_+3A_fun">FUN</code></td>
<td>
<p>a function that is used to aggregate CID for each variable.
The default <code>mean</code> will obtain the CID
as defined in Leonelli and Varando (2023).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>wrong</code> a stages-like structure which record where
<code>object2</code> wrongly infer the interventional distance
with respect to <code>object1</code>.
</p>
</li>
<li> <p><code>cid</code> the value of the computed CID.
</p>
</li></ul>



<h3>References</h3>

<p>Leonelli M., Varando G.
<em>Context-Specific Causal Discovery for Categorical Data Using Staged Trees</em>,
The 26th International Conference on Artificial Intelligence and Statistics (AISTATS), 2023,
<a href="https://arxiv.org/abs/2106.04416">https://arxiv.org/abs/2106.04416</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- stages_bhc(full(Titanic))
model2 &lt;- stages_bhc(full(Titanic,
  order = c("Survived", "Sex", "Age", "Class")
))
cid(model1, model2)$cid
cid(model1, model2)$wrong
</code></pre>

<hr>
<h2 id='compare_stages'>Compare two staged event tree</h2><span id='topic+compare_stages'></span><span id='topic+hamming_stages'></span><span id='topic+diff_stages'></span>

<h3>Description</h3>

<p>Compare two staged event trees, return the differences of the stages
structure and plot the difference tree. Three different methods to
compute the difference tree are available (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_stages(
  object1,
  object2,
  method = "naive",
  return_tree = FALSE,
  plot = FALSE,
  ...
)

hamming_stages(object1, object2, return_tree = FALSE)

diff_stages(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_stages_+3A_object1">object1</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="compare_stages_+3A_object2">object2</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="compare_stages_+3A_method">method</code></td>
<td>
<p>character, method to compare staged event trees.
One of: <code>"naive"</code>,
<code>"hamming"</code> or <code>"stages"</code>.</p>
</td></tr>
<tr><td><code id="compare_stages_+3A_return_tree">return_tree</code></td>
<td>
<p>logical, if <code>TRUE</code> the difference tree is returned.</p>
</td></tr>
<tr><td><code id="compare_stages_+3A_plot">plot</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="compare_stages_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code><a href="#topic+plot.sevt">plot.sevt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compare_stages</code> tests if the stage structure of two <code>sevt</code>
objects
is the same.
Three methods are available:
</p>

<ul>
<li> <p><code>naive</code> first applies <code><a href="#topic+stndnaming">stndnaming</a></code> to both
objects and then simply compares the resulting stage names.
</p>
</li>
<li> <p><code>hamming</code> uses the <code>hamming_stages</code> function that finds
a minimal subset of nodes which stages
must be changed to obtain the same structure.
</p>
</li>
<li> <p><code>stages</code> uses the <code>diff_stages</code> function that compares
stages to check whether the same stage structure is present in both models.
</p>
</li></ul>

<p>Setting <code>return_tree = TRUE</code> will return the stages
difference obtained with the selected method.
The stages difference is a list of numerical vectors with same
lengths and structure as <code>stages(object1)</code> or <code>stages(object2)</code>,
where values are 1 if the corresponding node has different
(with respect to the selected <code>method</code>) associated stage, and
0 otherwise.
</p>
<p>With <code>plot = TRUE</code> the plot of the difference tree is displayed.
</p>
<p>If <code>return_tree = FALSE</code> and <code>plot = FALSE</code>
the logical output is the same for the
three methods and thus the <code>naive</code> method should be used
since it is computationally faster.
</p>
<p><code>hamming_stages</code> finds a minimal set of nodes for which the associated stages
should be changed to obtain equivalent structures. To do that, a maximum-weight bipartite
matching problem between the stages of the two staged trees is solved using the
Hungarian method implemented in the <code>solve_LSAP</code> function of the <span class="pkg">clue</span>
package.
<code>hamming_stages</code> requires the package <code>clue</code>.
</p>


<h3>Value</h3>

<p><code>compare_stages</code>: if <code>return_tree = FALSE</code>, logical: <code>TRUE</code> if the two
models are exactly equal, otherwise <code>FALSE</code>.
Else if <code>return_tree = TRUE</code>, the differences between
the two trees, according to the selected <code>method</code>.
</p>
<p><code>hamming_stages</code>: if <code>return_tree = FALSE</code>, integer, the minimum
number of situations where the stage should be changed to obtain the same
models. If <code>return_tree = TRUE</code> a stages-like structure showing which
situations should be modified to obtain the same models.
</p>
<p><code>diff_stages</code>: a stages-like structure marking the situations belonging
to stages which are not the exactly equal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Asym")
mod1 &lt;- stages_bhc(full(Asym, lambda = 1))
mod2 &lt;- stages_fbhc(full(Asym, lambda = 1))
compare_stages(mod1, mod2)

##########
m0 &lt;- full(PhDArticles[, 1:4], lambda = 0)
m1 &lt;- stages_bhc(m0)
m2 &lt;- stages_bj(m0, distance = "totvar", thr = 0.25)
diff_stages(m1, m2)
</code></pre>

<hr>
<h2 id='confint.sevt'>Confidence intervals for staged event tree parameters</h2><span id='topic+confint.sevt'></span>

<h3>Description</h3>

<p>Confint method for class <code>sevt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
confint(
  object,
  parm,
  level = 0.95,
  method = c("wald", "waldcc", "wilson", "goodman", "quesenberry-hurst"),
  ignore = object$name_unobserved,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.sevt_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="confint.sevt_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given
confidence intervals, either a vector of numbers
or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.sevt_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.sevt_+3A_method">method</code></td>
<td>
<p>a character string specifing which method to use:
wald&quot;, &quot;waldcc&quot;, &quot;goodman&quot;, &quot;quesenberry-hurst&quot; or &quot;wilson&quot;.</p>
</td></tr>
<tr><td><code id="confint.sevt_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="confint.sevt_+3A_...">...</code></td>
<td>
<p>additional argument(s) for compatibility
with <code>confint</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute confidence intervals for staged event trees.
Currently five methods are available:
</p>

<ul>
<li> <p><code>wald</code>, <code>waldcc</code>: Wald method and with continuity correction.
</p>
</li>
<li> <p><code>wilson</code>, <code>quesenberry-hurst</code> and <code>goodman</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix with columns giving lower and upper confidence
limits for each parameter. These will be labelled as
<code>(1-level)/2</code> and <code>1 - (1-level)/2</code> in %
(by default 2.5% and 97.5%).
</p>


<h3>Author(s)</h3>

<p>The function is partially inspired by code in the
<code>MultinomCI</code> function from the <span class="pkg">DescTools</span> package,
implemented by Andri Signorelli and Pablo J. Villacorta Iglesias.
</p>


<h3>References</h3>

<p>Goodman, L. A. (1965) On Simultaneous Confidence Intervals for
Multinomial Proportions Technometrics, 7, 247-254.
</p>
<p>Wald, A. Tests of statistical hypotheses concerning several
parameters when the number of observations is large, Trans.
Am. Math. Soc. 54 (1943) 426-482.
</p>
<p>Wilson, E. B. Probable inference, the law of succession and
statistical inference, J.Am. Stat. Assoc. 22 (1927) 209-212.
</p>
<p>Quesenberry, C., &amp; Hurst, D. (1964). Large Sample Simultaneous
Confidence Intervals for Multinomial Proportions.
Technometrics, 6(2), 191-195
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- stages_bj(full(PhDArticles), distance = "kullback", thr = 0.01)
confint(m1, "Prestige", level = 0.90)
confint(m1, "Married", method = "goodman")
confint(m1, c("Married", "Kids"))
</code></pre>

<hr>
<h2 id='covid_patients'>Trajectories of hospitalized SARS-CoV-2 patients</h2><span id='topic+covid_patients'></span>

<h3>Description</h3>

<p>Dataset with observations from four variables (Sex, Age,
ICU, death) for 10000 simulated SARS-CoV-2 hospital patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid_patients
</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 observations of 4 variables.
The variables and their levels are as follows:
</p>

<ul>
<li><p> Sex: Female, Male
</p>
</li>
<li><p> Age: 0-39, 40-49, 50-59, 60-69, 70-79, 80+
</p>
</li>
<li><p> ICU: yes, no
</p>
</li>
<li><p> death: yes, no
</p>
</li></ul>



<h3>Details</h3>

<p>The data are simulated from an event tree where conditional
probabilities for ICU and death are taken from the results of
Lefrancq et al. (2021).
Lefrancq et al. (2021) estimated such probabilities from data
on patients, recorded in the
SI-VIC database, who started their hospitalization between
13 March and 30 November 2020.
</p>


<h3>Source</h3>

<p>The data has been generated with the code in the Examples section.
Conditional probabilities were copied from the tables in the
Supplementary materials of Lefrancq et al. (2021).
Marginal probabilities of gender and
probabilities of age given gender were instead
obtained from the linked GitHub repository
<a href="https://github.com/noemielefrancq/Evolution-Outcomes-COVID19-France">https://github.com/noemielefrancq/Evolution-Outcomes-COVID19-France</a>.
</p>


<h3>References</h3>

<p>Leonelli, M. and Varando, G. (2023).
Context-Specific Causal Discovery for Categorical Data Using Staged Trees.
<em>Proceedings of The 26th International Conference on Artificial Intelligence and Statistics</em>, in <em>Proceedings of Machine Learning Research</em>
206:8871-8888 Available from https://proceedings.mlr.press/v206/leonelli23a.html.
</p>
<p>Lefrancq N., Paireau J., Hozé N., Courtejoie N., Yazdanpanah Y., Bouadma L. (2021).
Evolution of outcomes for patients hospitalised during the first 9 months of
the SARS-CoV-2 pandemic in France: A retrospective national surveillance
data analysis.
<em>The Lancet Regional Health - Europe</em>, 5:100087.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stagedtrees)

data_model &lt;- sevt(list(
  Sex = c("Female", "Male"),
  Age = c(
    "0-39", "40-49", "50-59", "60-69",
    "70-79", "80+"
  ),
  ICU = c("yes", "no"),
  death = c("yes", "no")
), full = TRUE)
data_model$prob &lt;- list()
data_model$prob$Sex &lt;- list("1" = c(Female = 0.45185, Male = 0.54815))

dist_age_male &lt;- c(
  0.01616346, # 0 - 39
  0.04159445, # 40 - 49
  0.10130439, # 50 - 59
  0.16825686, # 60 - 69
  0.25217550, # 70 - 79
  0.42050534
) # 80+

dist_age_female &lt;- c(
  0.01688613, # 0 - 39
  0.04271329, # 40 - 49
  0.10131681, # 50 - 59
  0.16841872, # 60 - 69
  0.25289366, # 70 - 79
  0.41777138
) # 80+

names(dist_age_male) &lt;- data_model$tree$Age
names(dist_age_female) &lt;- data_model$tree$Age
data_model$prob$Age &lt;- list(
  "1" = dist_age_female,
  "2" = dist_age_male
)
data_model$prob$ICU &lt;- list(
  "1" = c(yes = 0.125, no = 1 - 0.125), # Female 0-39
  "2" = c(yes = 0.149, no = 1 - 0.149), # Female 40-49
  "3" = c(yes = 0.193, no = 1 - 0.193), # Female 50-59
  "4" = c(yes = 0.225, no = 1 - 0.225), # Female 60-69
  "5" = c(yes = 0.175, no = 1 - 0.175), # Female 70-79
  "6" = c(yes = 0.037, no = 1 - 0.037), # Female 80+
  "7" = c(yes = 0.197, no = 1 - 0.197), # Male 0-39
  "8" = c(yes = 0.2687, no = 1 - 0.2687), # Male 40-49
  "9" = c(yes = 0.3171, no = 1 - 0.3171), # Male 50-59
  "10" = c(yes = 0.3415, no = 1 - 0.3415), # Male 60-69
  "11" = c(yes = 0.274, no = 1 - 0.274), # Male 70-79
  "12" = c(yes = 0.073, no = 1 - 0.073) # Male 80+
)
data_model$prob$death &lt;- list(
  ################### FEMALE ################################
  "1"  = c(yes = 0.077, no = 1 - 0.077), # Female 0-39 ICU
  "2"  = c(yes = 0.004, no = 1 - 0.004), # Female 0-39 no-ICU
  "3"  = c(yes = 0.117, no = 1 - 0.117), # Female 40-49 ICU
  "4"  = c(yes = 0.017, no = 1 - 0.017), # Female 40-49 no-ICU
  "5"  = c(yes = 0.185, no = 1 - 0.185), # Female 50-59 ICU
  "6"  = c(yes = 0.030, no = 1 - 0.030), # Female 50-59 no-ICU
  "7"  = c(yes = 0.239, no = 1 - 0.239), # Female 60-69 ICU
  "8"  = c(yes = 0.058, no = 1 - 0.058), # Female 60-69 no-ICU
  "9"  = c(yes = 0.324, no = 1 - 0.324), # Female 70-79 ICU
  "10" = c(yes = 0.124, no = 1 - 0.124), # Female 70-79 no-ICU
  "11" = c(yes = 0.454, no = 1 - 0.454), # Female 80+ ICU
  "12" = c(yes = 0.266, no = 1 - 0.266), # Female 80+ no-ICU
  ################# MALE ##################################
  "13" = c(yes = 0.079, no = 1 - 0.079), # Male 0-39 ICU
  "14" = c(yes = 0.008, no = 1 - 0.008), # Male 0-39 no-ICU
  "15" = c(yes = 0.098, no = 1 - 0.098), # Male 40-49 ICU
  "16" = c(yes = 0.016, no = 1 - 0.016), # Male 40-49 no-ICU
  "17" = c(yes = 0.171, no = 1 - 0.171), # Male 50-59 ICU
  "18" = c(yes = 0.030, no = 1 - 0.030), # Male 50-59 no-ICU
  "19" = c(yes = 0.278, no = 1 - 0.278), # Male 60-69 ICU
  "20" = c(yes = 0.067, no = 1 - 0.067), # Male 60-69 no-ICU
  "21" = c(yes = 0.383, no = 1 - 0.383), # Male 70-79 ICU
  "22" = c(yes = 0.150, no = 1 - 0.150), # Male 70-79 no-ICU
  "23" = c(yes = 0.478, no = 1 - 0.478), # Male 80+ ICU
  "24" = c(yes = 0.363, no = 1 - 0.363) # Male 80+ no-ICU
)

# covid_patients &lt;- sample_from(data_model, 10000, seed = 123)
# usethis::use_data(covid_patients, overwrite = TRUE)
</code></pre>

<hr>
<h2 id='depsubtree'>Extract dependency subtree</h2><span id='topic+depsubtree'></span>

<h3>Description</h3>

<p>Extract the dependency subtree of a staged tree with respect to
a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depsubtree(object, var, other_stages = c("NA", "indep", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depsubtree_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code>.</p>
</td></tr>
<tr><td><code id="depsubtree_+3A_var">var</code></td>
<td>
<p>the name of one of the variable of the staged event tree.</p>
</td></tr>
<tr><td><code id="depsubtree_+3A_other_stages">other_stages</code></td>
<td>
<p>how to set stages for other variables (if any).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependency sub-tree is a staged event tree which is
sufficient to describe the conditional distribution of the variable
<code>var</code> given its predecessors in the original tree represented by
<code>object</code>.
In particular the preceding variables are restricted to the
parents of <code>var</code> in the minimal-DAG obtained with
<code><a href="#topic+as_parentslist">as_parentslist</a></code>. This is the minimal set of
variables which contexts are sufficient to fully represent the
conditional distribution of <code>var</code>.
Stages for variables different from <code>var</code> are either set to
NA, or to the full or indep model, depending on <code>other_stages</code>.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+sevt">sevt</a></code> representing the
dependency sub-tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- stages_kmeans(full(Titanic), k = 2)
par(mfrow = c(1, 2))
plot(mod, main = "staged tree")
plot(depsubtree(mod, "Age"), main = "dependency subtree for Age")
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='distance_mat_stages'>Compute the distance matrix</h2><span id='topic+distance_mat_stages'></span>

<h3>Description</h3>

<p>Compute the matrix of distances between probabilities,
e.g the transition probabilities for a given variable in a
staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_mat_stages(x, distance = probdist.kl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_mat_stages_+3A_x">x</code></td>
<td>
<p>list of conditional probabilities for each stage.</p>
</td></tr>
<tr><td><code id="distance_mat_stages_+3A_distance">distance</code></td>
<td>
<p>the distance function e.g. <code><a href="#topic+probdist.kl">probdist.kl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix with the distances between stages.
</p>

<hr>
<h2 id='edge'>Plot an edge</h2><span id='topic+edge'></span>

<h3>Description</h3>

<p>Plot an edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge(from, to, label = "", col = "black", cex_label = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_+3A_from">from</code></td>
<td>
<p>From</p>
</td></tr>
<tr><td><code id="edge_+3A_to">to</code></td>
<td>
<p>To</p>
</td></tr>
<tr><td><code id="edge_+3A_label">label</code></td>
<td>
<p>the label</p>
</td></tr>
<tr><td><code id="edge_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="edge_+3A_cex_label">cex_label</code></td>
<td>
<p>numerical</p>
</td></tr>
<tr><td><code id="edge_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>par()</code></p>
</td></tr>
</table>

<hr>
<h2 id='erase_fit'>Erase the sevt fit</h2><span id='topic+erase_fit'></span>

<h3>Description</h3>

<p>Erase the sevt fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erase_fit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erase_fit_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>sevt</code> without
<code>prob</code> and <code>ll</code> field.
</p>

<hr>
<h2 id='expand_prob'>Expand probabilities of a staged event tree</h2><span id='topic+expand_prob'></span>

<h3>Description</h3>

<p>Return the list of complete probability tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_prob(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_prob_+3A_object">object</code></td>
<td>
<p>a fitted staged event tree object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>probability tables.
</p>

<hr>
<h2 id='find_stage'>Find the stage of the path</h2><span id='topic+find_stage'></span>

<h3>Description</h3>

<p>no checking is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_stage(object, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_stage_+3A_object">object</code></td>
<td>
<p>a staged event tree object.</p>
</td></tr>
<tr><td><code id="find_stage_+3A_path">path</code></td>
<td>
<p>vector of the path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the stage name corresponding of the path.
</p>

<hr>
<h2 id='full_indep'>Full and independent staged event tree</h2><span id='topic+full_indep'></span><span id='topic+full'></span><span id='topic+full.table'></span><span id='topic+full.data.frame'></span><span id='topic+indep'></span><span id='topic+indep.table'></span><span id='topic+indep.data.frame'></span>

<h3>Description</h3>

<p>Build fitted staged event tree from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full(
  data,
  order = NULL,
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)

## S3 method for class 'table'
full(
  data,
  order = names(dimnames(data)),
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)

## S3 method for class 'data.frame'
full(
  data,
  order = colnames(data),
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)

indep(
  data,
  order = NULL,
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)

## S3 method for class 'table'
indep(
  data,
  order = names(dimnames(data)),
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)

## S3 method for class 'data.frame'
indep(
  data,
  order = colnames(data),
  join_unobserved = TRUE,
  lambda = 0,
  name_unobserved = "UNOBSERVED"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_indep_+3A_data">data</code></td>
<td>
<p>data to create the model, data.frame or table.</p>
</td></tr>
<tr><td><code id="full_indep_+3A_order">order</code></td>
<td>
<p>character vector, order of variables.</p>
</td></tr>
<tr><td><code id="full_indep_+3A_join_unobserved">join_unobserved</code></td>
<td>
<p>logical, if situations with zero observations should
be joined (default TRUE).</p>
</td></tr>
<tr><td><code id="full_indep_+3A_lambda">lambda</code></td>
<td>
<p>smoothing coefficient (default 0).</p>
</td></tr>
<tr><td><code id="full_indep_+3A_name_unobserved">name_unobserved</code></td>
<td>
<p>name to pass to <code><a href="#topic+join_unobserved">join_unobserved</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to create full or independent staged tree models from
data.
The full (or saturated) staged tree is the model where every
situation is in a different stage, and thus the model has the
maximum number of parameters.
Conversely, the independent staged tree (<code>indep</code>) assigns
all the situations related to the same variable to the same
stage, thus it is equivalent to the independence factorization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## full model
DD &lt;- generate_xor_dataset(4, 100)
model_full &lt;- full(DD, lambda = 1)

## independence model (data.frame)
DD &lt;- generate_xor_dataset(4, 100)
model &lt;- indep(DD, lambda = 1)
model
</code></pre>

<hr>
<h2 id='generate_linear_dataset'>Generate a random binary dataset for classification</h2><span id='topic+generate_linear_dataset'></span>

<h3>Description</h3>

<p>Randomly generate a simple classification problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_linear_dataset(
  p,
  n,
  eps = 1.2,
  gamma = runif(1, min = -p, max = p),
  alpha = runif(p, min = -p, max = p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_linear_dataset_+3A_p">p</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code id="generate_linear_dataset_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="generate_linear_dataset_+3A_eps">eps</code></td>
<td>
<p>noise.</p>
</td></tr>
<tr><td><code id="generate_linear_dataset_+3A_gamma">gamma</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="generate_linear_dataset_+3A_alpha">alpha</code></td>
<td>
<p>numeric vector of length <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>n</code> independent random variables and
one class variable <code>C</code> computed as
<code>sign(sum(x * alpha) + runif(1, -eps, eps) + gamma)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_linear_dataset(p = 5, n = 1000)
</code></pre>

<hr>
<h2 id='generate_random_dataset'>Generate a random binary dataset</h2><span id='topic+generate_random_dataset'></span>

<h3>Description</h3>

<p>Randomly generate a data.frame of independent binary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_dataset(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_dataset_+3A_p">p</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code id="generate_random_dataset_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>n</code> independent random variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_random_dataset(p = 5, n = 1000)
</code></pre>

<hr>
<h2 id='generate_xor_dataset'>Generate a xor dataset</h2><span id='topic+generate_xor_dataset'></span>

<h3>Description</h3>

<p>Generate a xor dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_xor_dataset(p, n, eps = 1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_xor_dataset_+3A_p">p</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code id="generate_xor_dataset_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="generate_xor_dataset_+3A_eps">eps</code></td>
<td>
<p>error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The xor dataset with <code>n</code> + 1 variables, where the first one is
the class variable <code>C</code> computed as a noisy xor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 5, n = 1000, eps = 1.2)
</code></pre>

<hr>
<h2 id='get_stage'>Get stage or path</h2><span id='topic+get_stage'></span><span id='topic+get_path'></span>

<h3>Description</h3>

<p>Utility functions to obtain stages from paths and
paths from stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stage(object, path)

get_path(object, var, stage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stage_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="get_stage_+3A_path">path</code></td>
<td>
<p>character vector, the path from root or
a two dimensional array where each row is a path
from root.</p>
</td></tr>
<tr><td><code id="get_stage_+3A_var">var</code></td>
<td>
<p>character, one of the variable in
the staged tree.</p>
</td></tr>
<tr><td><code id="get_stage_+3A_stage">stage</code></td>
<td>
<p>character vector, the name
of the stages for which the paths should be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_stage</code> returns
the stage name(s)  for given path(s).
</p>
<p><code>get_path</code> returns a
data.frame containing the paths
corresponding to the given stage(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_fbhc(full(PhDArticles))
get_stage(model, c("0", "male"))
paths &lt;- expand.grid(model$tree[2:1])[, 2:1]
get_stage(model, paths)
get_path(model, "Kids", "5")
get_path(model, "Gender", "2")
get_path(model, "Kids", c("5", "6"))
</code></pre>

<hr>
<h2 id='has_ctables'>Check sevt objects</h2><span id='topic+has_ctables'></span><span id='topic+has_prob'></span><span id='topic+is_fitted_sevt'></span><span id='topic+check_sevt'></span><span id='topic+check_tree'></span><span id='topic+check_stages'></span><span id='topic+check_sevt_prob'></span><span id='topic+check_sevt_ctables'></span><span id='topic+check_sevt_fit'></span><span id='topic+check_same_tree'></span><span id='topic+check_var_in'></span><span id='topic+check_scope'></span><span id='topic+check_path'></span><span id='topic+check_context'></span>

<h3>Description</h3>

<p>Check sevt objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_ctables(object)

has_prob(object)

is_fitted_sevt(object)

check_sevt(object, arg = rlang::caller_arg(object), call = rlang::caller_env())

check_tree(tree, arg = rlang::caller_arg(tree), call = rlang::caller_env())

check_stages(
  object,
  arg = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_sevt_prob(
  object,
  arg = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_sevt_ctables(
  object,
  arg = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_sevt_fit(
  object,
  arg = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_same_tree(
  object,
  object2,
  arg1 = rlang::caller_arg(object),
  arg2 = rlang::caller_arg(object2),
  call = rlang::caller_env()
)

check_var_in(
  var,
  object,
  arg1 = rlang::caller_arg(var),
  arg2 = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_scope(
  x,
  object,
  arg1 = rlang::caller_arg(x),
  arg2 = rlang::caller_arg(object),
  call = rlang::caller_env()
)

check_path(x, tree)

check_context(x, var, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_ctables_+3A_object">object</code></td>
<td>
<p>an object of class sevt</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_arg">arg</code></td>
<td>
<p>passed arg name</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_call">call</code></td>
<td>
<p>passed call</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_tree">tree</code></td>
<td>
<p>a list of levels specifying an event tree</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_object2">object2</code></td>
<td>
<p>a staged event tree object.</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_arg1">arg1</code></td>
<td>
<p>passed arg1 name</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_arg2">arg2</code></td>
<td>
<p>passed arg2 name</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_var">var</code></td>
<td>
<p>name of a variable to be checked.</p>
</td></tr>
<tr><td><code id="has_ctables_+3A_x">x</code></td>
<td>
<p>scope, context or path to be checked against a model or tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical.
</p>
<p>logical.
</p>
<p>logical.
</p>

<hr>
<h2 id='igraph-conversion'><span class="pkg">igraph</span> conversion</h2><span id='topic+igraph-conversion'></span><span id='topic+get_edges'></span><span id='topic+get_edges.sevt'></span><span id='topic+get_vertices'></span><span id='topic+get_vertices.sevt'></span><span id='topic+get_edges.ceg'></span><span id='topic+get_vertices.ceg'></span><span id='topic+as_igraph'></span><span id='topic+as_igraph.sevt'></span><span id='topic+as_igraph.ceg'></span>

<h3>Description</h3>

<p>Obtain the graph representation of a staged tree or a CEG as
an object from the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edges(x, ignore = x$name_unobserved, ...)

## S3 method for class 'sevt'
get_edges(x, ignore = x$name_unobserved, ...)

get_vertices(x, ignore = x$name_unobserved, ...)

## S3 method for class 'sevt'
get_vertices(x, ignore = x$name_unobserved, ...)

## S3 method for class 'ceg'
get_edges(x, ignore = x$name_unobserved, ...)

## S3 method for class 'ceg'
get_vertices(x, ignore = x$name_unobserved, ...)

as_igraph(x, ignore = x$name_unobserved, ...)

## S3 method for class 'sevt'
as_igraph(x, ignore = x$name_unobserved, ...)

## S3 method for class 'ceg'
as_igraph(x, ignore = x$name_unobserved, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-conversion_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code> or <code><a href="#topic+ceg">ceg</a></code>.</p>
</td></tr>
<tr><td><code id="igraph-conversion_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and excluded,
by default the name of the unobserved stages stored in
<code>x$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="igraph-conversion_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to transalte the graph structure of a <code><a href="#topic+sevt">sevt</a></code>
or <code><a href="#topic+ceg">ceg</a></code> object to a graph object from the
<span class="pkg">igraph</span> package.
Additional functions that extract the edge lists
and the vertices are available.
This can be useful, for example to plot the staged tree  with
<span class="pkg">igraph</span> or additional packages (see the examples).
</p>


<h3>Value</h3>

<p>for <code>get_edges</code>: the edges list corresponding
to the graph associated to <code>x</code>.
</p>
<p>for <code>get_vertices</code>: the vertices list corresponding
to the graph associated to <code>x</code>.
</p>
<p>for <code>as.igraph</code>: a graph object from the
<span class="pkg">igraph</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- stages_bhc(full(Titanic))
get_edges(mod)
get_vertices(mod)
## Not run: 
library(igraph)
library(ggraph)
######## sevt example ########
## convert to igraph object
g &lt;- as_igraph(mod)
## plot with igraph directly
plot(g, layout = layout_with_sugiyama)
## plot with ggraph
ggraph(g, "sugiyama") +
  geom_edge_fan(
    aes(
      label = label,
      label_pos = 0.5 + runif(length(label), -0.1, 0.1)
    ),
    angle_calc = "along", show.legend = FALSE, check_overlap = FALSE,
    end_cap = circle(0.02, "npc"),
    arrow = grid::arrow(
      angle = 25,
      length = unit(0.025, "npc"),
      type = "closed"
    )
  ) +
  geom_node_point(aes(x = x, y = y, color = stage),
    size = 5,
    show.legend = FALSE
  ) +
  ggforce::theme_no_axes() + coord_flip() + scale_y_reverse()

######## ceg example ########
g.ceg &lt;- as_igraph(ceg(mod))
### igraph plotting functions can be used
plot(g.ceg, layout = layout.sugiyama)
### igraph object can be also plotted with ggplot2 and ggraph
ggraph(g.ceg, "sugiyama") +
  geom_edge_fan(
    aes(
      label = label,
      color = label,
      label_pos = 0.5 + runif(length(label), -0.1, 0.1)
    ),
    angle_calc = "along", show.legend = FALSE, check_overlap = FALSE,
    end_cap = circle(0.02, "npc"),
    arrow = grid::arrow(
      angle = 25,
      length = unit(0.025, "npc"),
      type = "closed"
    )
  ) +
  geom_node_point(aes(x = x, y = y, color = stage), size = 3, show.legend = FALSE) +
  ggforce::theme_no_axes() + coord_flip() + scale_y_reverse()

## End(Not run)
</code></pre>

<hr>
<h2 id='inclusions_stages'>Inclusions of stages</h2><span id='topic+inclusions_stages'></span>

<h3>Description</h3>

<p>Display the relationship between two staged tree models over the
same variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusions_stages(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclusions_stages_+3A_object1">object1</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="inclusions_stages_+3A_object2">object2</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the
relations between
the stages structures of the two models.
</p>
<p>The relations between stages of the same variable
are stored in a data frame with three columns
where each row represent
a relation between a stage of the first model (<code>s1</code>) and
a stage of the second model (<code>s2</code>).
The relation can be one of the following: inclusion (<code>s1 &lt; s2</code>
or <code>s1 &gt; s2</code>; equal (<code>s1 = s2</code>); not-equal (<code>s1 != s2</code>).
</p>


<h3>Value</h3>

<p>a list with inclusion relations between stage
structures for each variable in the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- stages_bhc(full(PhDArticles[, 1:5], lambda = 1))
mod2 &lt;- stages_fbhc(full(PhDArticles[, 1:5], lambda = 1))
inclusions_stages(mod1, mod2)
</code></pre>

<hr>
<h2 id='join_positions'>join positions in a staged tree model</h2><span id='topic+join_positions'></span>

<h3>Description</h3>

<p>join positions in a staged tree model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_positions(model, var, s1, s2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_positions_+3A_model">model</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="join_positions_+3A_var">var</code></td>
<td>
<p>the name of a variable in the model.</p>
</td></tr>
<tr><td><code id="join_positions_+3A_s1">s1</code></td>
<td>
<p>stage to join</p>
</td></tr>
<tr><td><code id="join_positions_+3A_s2">s2</code></td>
<td>
<p>stage to join</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions works similarly to the <code>join_stages</code>
function in the <code>stagedtrees</code> package, but it also joins
downstream stages to make nodes with stages <code>s1,s2</code> in the same
position. This function works properly only when downstream variables
from <code>var</code> have full stages vectors.
</p>

<hr>
<h2 id='join_stages'>Join stages</h2><span id='topic+join_stages'></span><span id='topic+join_stages_unsafe'></span><span id='topic+join_all'></span>

<h3>Description</h3>

<p>Join two stages in a staged event tree object, updating
probabilities and log-likelihood accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_stages(object, var, s1, s2)

join_stages_unsafe(object, var, s1, s2)

join_all(object, var, stages, ignore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_stages_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="join_stages_+3A_var">var</code></td>
<td>
<p>variable.</p>
</td></tr>
<tr><td><code id="join_stages_+3A_s1">s1</code></td>
<td>
<p>first stage.</p>
</td></tr>
<tr><td><code id="join_stages_+3A_s2">s2</code></td>
<td>
<p>second stage.</p>
</td></tr>
<tr><td><code id="join_stages_+3A_stages">stages</code></td>
<td>
<p>a vector of stage names for variable <code>var</code>.</p>
</td></tr>
<tr><td><code id="join_stages_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function joins two stages associated to the
same variable,
updating probabilities and log-likelihood if
the object was fitted.
</p>


<h3>Value</h3>

<p>the staged event tree where <code>s1</code> and <code>s2</code> are joined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- full(PhDArticles, lambda = 0)
model &lt;- stages_fbhc(model)
model$stages$Kids
model &lt;- join_stages(model, "Kids", "5", "6")
model$stages$Kids
</code></pre>

<hr>
<h2 id='join_unobserved'>Join situations with no observations</h2><span id='topic+join_unobserved'></span>

<h3>Description</h3>

<p>Join situations with no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_unobserved(
  object,
  fit = TRUE,
  trace = 0,
  name = "UNOBSERVED",
  scope = sevt_varnames(object)[-1],
  lambda = object$lambda
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_unobserved_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with associated data.</p>
</td></tr>
<tr><td><code id="join_unobserved_+3A_fit">fit</code></td>
<td>
<p>if TRUE update model's probabilities.</p>
</td></tr>
<tr><td><code id="join_unobserved_+3A_trace">trace</code></td>
<td>
<p>if <code>&gt; 0</code> print information to console.</p>
</td></tr>
<tr><td><code id="join_unobserved_+3A_name">name</code></td>
<td>
<p>character, name for the new stage storing unobserved situations.</p>
</td></tr>
<tr><td><code id="join_unobserved_+3A_scope">scope</code></td>
<td>
<p>character vector, list of variables in <code>object</code>.</p>
</td></tr>
<tr><td><code id="join_unobserved_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter for the fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It takes as input a (fitted) staged event tree object
and  it joins,
in the same stage, all the situations with zero
recorded observations.
Since such joining does not change
the log-likelihood of the model, it is a useful (time-wise)
pre-processing prior to others model selection algorithms.
</p>
<p>Unobserved situations can be joined directly in
<code><a href="#topic+full">full</a></code> or <code><a href="#topic+indep">indep</a></code>, by setting
<code>join_unobserved = TRUE</code>.
</p>


<h3>Value</h3>

<p>a staged event tree with at most one stage per variable with
no observations.
If, as default, <code>fit=TRUE</code> the model will be re-fitted, if
<code>fit=FALSE</code> probabilities in the output model are not estimated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 5, n = 10)
model_full &lt;- full(DD, lambda = 1, join_unobserved = FALSE)
model &lt;- join_unobserved(model_full)
logLik(model_full)
logLik(model)
BIC(model_full, model)
</code></pre>

<hr>
<h2 id='logLik.sevt'>Log-Likelihood of a staged event tree</h2><span id='topic+logLik.sevt'></span>

<h3>Description</h3>

<p>Compute, or extract the log-likelihood of a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.sevt_+3A_object">object</code></td>
<td>
<p>an fitted object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="logLik.sevt_+3A_...">...</code></td>
<td>
<p>additional parameters (compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("PhDArticles")
mod &lt;- indep(PhDArticles)
logLik(mod)
</code></pre>

<hr>
<h2 id='lr_test'>Likelihood Ratio Test for staged trees models</h2><span id='topic+lr_test'></span>

<h3>Description</h3>

<p>Function to perform likelihood ratio test between
two or multiple staged event tree models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr_test(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_test_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code>.</p>
</td></tr>
<tr><td><code id="lr_test_+3A_...">...</code></td>
<td>
<p>further objects of class <code><a href="#topic+sevt">sevt</a></code>.
Must specify super-models of <code>object</code>.
See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a single object of class <code>sevt</code> is passed as
argument, it computes
the likelihood-ratio test with respect to the
independence model.
If multiple objects are passed,
likelihood-ratio tests between the first
object and the followings are computed.
In the latter case the function checks automatically if
the first model is nested in the additional ones,
via <code><a href="#topic+inclusions_stages">inclusions_stages</a></code>, and throws
an error if not.
</p>


<h3>Value</h3>

<p>An object of class <code>anova</code>
which contains the log-likelihood,
degrees of freedom,
difference in degrees of freedom, likelihood ratio
statistics and corresponding p values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PhDArticles)
order &lt;- c("Gender", "Kids", "Married", "Articles")
phd.mod1 &lt;- stages_hc(indep(PhDArticles, order))
phd.mod2 &lt;- stages_hc(full(PhDArticles, order))

## compare two nested models
lr_test(phd.mod1, phd.mod2)

## compare a single model vs the independence model
lr_test(phd.mod1)
</code></pre>

<hr>
<h2 id='make_ctables'>Distribute counts along tree</h2><span id='topic+make_ctables'></span>

<h3>Description</h3>

<p>Create the list of <code>ftable</code>s
storing the observations distributed along
the path of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ctables(object, data, useNA = "ifany")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ctables_+3A_object">object</code></td>
<td>
<p>A stratified event tree, a list with a <code>tree</code> field.</p>
</td></tr>
<tr><td><code id="make_ctables_+3A_data">data</code></td>
<td>
<p>table or data.frame containing observations
of the variable in <code>object</code>.</p>
</td></tr>
<tr><td><code id="make_ctables_+3A_usena">useNA</code></td>
<td>
<p>whether to include NA values in the tables.
Argument passed to <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distribute the counts along the event tree.
This is an internal function, the user will
usually just directly fit the staged event tree
model using <code>sevt.fit</code>.
We refer here to stratified event tree, because actually
the stage information is never used and thus this function
will work for an object with only a <code>tree</code> field.
</p>


<h3>Value</h3>

<p>A list of <code>ftable</code>s.
</p>

<hr>
<h2 id='new_label'>New label</h2><span id='topic+new_label'></span>

<h3>Description</h3>

<p>give a safe-to-add label that is not in <code>labels</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_label(labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_label_+3A_labels">labels</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string label that is different from each <code>labels</code>.
</p>

<hr>
<h2 id='node'>Plot a node</h2><span id='topic+node'></span>

<h3>Description</h3>

<p>Plot a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node(x, label = "", col = "black", cex_label = 1, cex_node = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_+3A_x">x</code></td>
<td>
<p>the center</p>
</td></tr>
<tr><td><code id="node_+3A_label">label</code></td>
<td>
<p>the label</p>
</td></tr>
<tr><td><code id="node_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="node_+3A_cex_label">cex_label</code></td>
<td>
<p>cex parameter to be passed to text</p>
</td></tr>
<tr><td><code id="node_+3A_cex_node">cex_node</code></td>
<td>
<p>cex parameter for nodes</p>
</td></tr>
<tr><td><code id="node_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>par()</code></p>
</td></tr>
</table>

<hr>
<h2 id='noisy_xor'>noisy xor function</h2><span id='topic+noisy_xor'></span>

<h3>Description</h3>

<p>noisy xor function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisy_xor(x, eps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisy_xor_+3A_x">x</code></td>
<td>
<p>a vector of +1 and -1.</p>
</td></tr>
<tr><td><code id="noisy_xor_+3A_eps">eps</code></td>
<td>
<p>the uniform noise amount.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the computed noisy xor.
</p>

<hr>
<h2 id='path_probability'>Compute probability of a path from root</h2><span id='topic+path_probability'></span>

<h3>Description</h3>

<p>Internal function to compute probability of a path. It does not
check the validity of the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_probability(object, x, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_probability_+3A_object">object</code></td>
<td>
<p>An object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="path_probability_+3A_x">x</code></td>
<td>
<p>the path, expressed
as a character vector containing the sequence of the value of the variables.</p>
</td></tr>
<tr><td><code id="path_probability_+3A_log">log</code></td>
<td>
<p>logical, if <code>TRUE</code> log-probability is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the probability of following a given path (<code>x</code>) starting from the root.
Can be a full path from the root to a leaf or a shorter path.
</p>


<h3>Value</h3>

<p>The probability of the given path or its logarithm if <code>log=TRUE</code>.
</p>

<hr>
<h2 id='PhDArticles'>PhD Students Publications</h2><span id='topic+PhDArticles'></span>

<h3>Description</h3>

<p>Number of publications of 915 PhD biochemistry students
during the 1950’s and 1960’s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhDArticles
</code></pre>


<h3>Format</h3>

<p>A data frame with 915 rows and 6 variables:
</p>

<dl>
<dt>Articles</dt><dd><p>Number of articles during the last 3 years of PhD: either
<code>0</code>, <code>1-2</code> or <code>&gt;2</code>.</p>
</dd>
<dt>Gender</dt><dd><p><code>male</code> or <code>female</code>.</p>
</dd>
<dt>Kids</dt><dd><p><code>yes</code> if the student has at least one kid 5 or younger,
<code>no</code> otherwise.</p>
</dd>
<dt>Married</dt><dd><p><code>yes</code> or <code>no</code>.</p>
</dd>
<dt>Mentor</dt><dd><p>Number of publications of the student's mentor:
<code>low</code> between 0 and 3, <code>medium</code> between 4 and 10,
<code>high</code> otherwise.</p>
</dd>
<dt>Prestige</dt><dd><p><code>low</code> if the student is at a low-prestige university,
<code>high</code> otherwise.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data has been modified from the <code>Rchoice</code> package.
</p>


<h3>References</h3>

<p>Long, J. S. (1990). The origins of sex differences in science.
<em>Social Forces</em>, 68(4), 1297-1316.
</p>

<hr>
<h2 id='plot.ceg'>igraph's plotting for CEG</h2><span id='topic+plot.ceg'></span>

<h3>Description</h3>

<p>igraph's plotting for CEG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ceg'
plot(x, col = NULL, ignore = x$name_unobserved, layout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ceg_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+ceg">ceg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ceg_+3A_col">col</code></td>
<td>
<p>colors specification see <code><a href="#topic+plot.sevt">plot.sevt</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ceg_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>x$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="plot.ceg_+3A_layout">layout</code></td>
<td>
<p>an igraph layout.</p>
</td></tr>
<tr><td><code id="plot.ceg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>plot.igraph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around
<span class="pkg">igraph</span>'s <code>plot.igraph</code>.
The ceg object is converted to an igraph object
with <code><a href="#topic+as_igraph">as_igraph</a></code>.
If not specified, the default <code>layout</code> used is
a rotated <code>layout.sugiyama</code>.
</p>
<p>We use <code>palette()</code> as palette for
the <span class="pkg">igraph</span> plotting, while <code>plot.igraph</code> uses
as default a different palette. This is to allow matching
stages colors between <code>plot.ceg</code>
and <code><a href="#topic+plot.sevt">plot.sevt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 model &lt;- stages_bhc(full(Titanic))
 model.ceg &lt;- ceg(model)
 plot(model.ceg, edge.arrow.size = 0.1, vertex.label.dist = -2)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.sevt'>Plot method for staged event trees</h2><span id='topic+plot.sevt'></span><span id='topic+make_stages_col'></span>

<h3>Description</h3>

<p>Plot method for staged event tree
objects. It allows easy plotting of staged event trees with some
options (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
plot(
  x,
  y = 10,
  limit = y,
  xlim = c(0, 1),
  ylim = c(0, 1),
  main = NULL,
  sub = NULL,
  asp = 1,
  cex_label_nodes = 0,
  cex_label_edges = 1,
  cex_nodes = 2,
  cex_tree_y = 0.9,
  col = NULL,
  col_edges = "black",
  var_names = TRUE,
  ignore = x$name_unobserved,
  pch_nodes = 16,
  lwd_nodes = 1,
  lwd_edges = 1,
  ...
)

make_stages_col(x, col = NULL, ignore = x$name_unobserved, limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sevt_+3A_x">x</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_y">y</code></td>
<td>
<p>alias for <code>limit</code> for compatibility with <code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_limit">limit</code></td>
<td>
<p>maximum number of variables plotted.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_sub">sub</code></td>
<td>
<p>a sub title for the plot.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_cex_label_nodes">cex_label_nodes</code></td>
<td>
<p>the magnification to be used for
the node labels.
If set to <code>0</code> (as default)
node labels are not showed.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_cex_label_edges">cex_label_edges</code></td>
<td>
<p>the magnification
for the edge labels.
If set to <code>0</code> edge labels are not displayed.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_cex_nodes">cex_nodes</code></td>
<td>
<p>the magnification  for
the nodes of the tree.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_cex_tree_y">cex_tree_y</code></td>
<td>
<p>the magnification for the
tree in the vertical direction.
Default is <code>0.9</code> to leave some space
for the variable names.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_col">col</code></td>
<td>
<p>color mapping for stages, one of the following:
NULL (color will be assigned based on the current palette);
a named (variables) list of named (stages)
vectors of colors;
the character <code>"stages"</code>, in which case the stage names
will be used as colors;
a function that takes
as input a vector of stages and output the corresponding colors.
Check the provided examples.
The function <code>make_stages_col</code> is used internally
and <code>make_stages_col(x, NULL)</code> or <code>make_stages_col(x, "stages")</code>
can be used as a starting point for colors tweaking.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_col_edges">col_edges</code></td>
<td>
<p>color for the edges.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_var_names">var_names</code></td>
<td>
<p>logical, if variable names should be added to the plot,
otherwise variable names can be added manually using
<code><a href="#topic+text.sevt">text.sevt</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>x$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_pch_nodes">pch_nodes</code></td>
<td>
<p>either an integer specifying a symbol or a single character
to be used as the default in plotting nodes shapes see
<code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_lwd_nodes">lwd_nodes</code></td>
<td>
<p>the line width for edges, a positive number, defaulting to 1.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_lwd_edges">lwd_edges</code></td>
<td>
<p>the line width for nodes, a positive number, defaulting to 1.</p>
</td></tr>
<tr><td><code id="plot.sevt_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed to
<code>points</code>, <code>lines</code>, <code>title</code>,
<code>text</code> and <code>plot.window</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("PhDArticles")
mod &lt;- stages_bj(full(PhDArticles, join_unobserved = TRUE))

### simple plotting
plot(mod)

### labels in nodes
plot(mod, cex_label_nodes = 1, cex_nodes = 0)

### reduce nodes size
plot(mod, cex_nodes = 0.5)

### change line width and nodes style
plot(mod, lwd_edges = 3, pch_nodes = 5)

### changing palette
plot(mod, col = function(s) heat.colors(length(s)))

### or changing global palette
palette(hcl.colors(10, "Harmonic"))
plot(mod)
palette("default") ##

### forcing plotting of unobserved stages
plot(mod, ignore = NULL)

### use function to specify colors
plot(mod, col = function(stages) {
  hcl.colors(n = length(stages))
})

### manually give stages colors
### as an example we will assign colors only to the stages of two variables
### Gender (one stage named "1") and Mentor (six stages)
col &lt;- list(
  Gender = c("1" = "blue"),
  Mentor = c(
    "UNOBSERVED" = "grey",
    "2" = "red",
    "3" = "purple",
    "10" = "pink",
    "18" = "green",
    "22" = "brown"
  )
)
### by setting ignore = NULL we will plot also the UNOBSERVED stage for Mentor
plot(mod, col = col, ignore = NULL)
</code></pre>

<hr>
<h2 id='Pokemon'>Pokemon Go Users</h2><span id='topic+Pokemon'></span>

<h3>Description</h3>

<p>Demographic information of a population of possible Pokemon Go users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pokemon
</code></pre>


<h3>Format</h3>

<p>A data frame with 999 rows and 5 variables:
</p>

<dl>
<dt>Use</dt><dd><p><code>Y</code> if the individual used the app, <code>N</code> otherwise</p>
</dd>
<dt>Age</dt><dd><p><code>&gt;30</code> if the individual is older than 30,
<code>&lt;=30</code> otherwise</p>
</dd>
<dt>Degree</dt><dd><p><code>Yes</code> if the individual completed a Higher
Education degree, <code>No</code> otherwise</p>
</dd>
<dt>Gender</dt><dd><p><code>Male</code> or <code>Female</code></p>
</dd>
<dt>Activity</dt><dd><p><code>Yes</code> if the individual was physically active
(i.e. had a walk longer than 30 mins, went for a run or
had a bike ride to get some exercise) in the past week
before the experiment, <code>No</code> otherwise</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://osf.io/xy5g6/">https://osf.io/xy5g6/</a>
</p>


<h3>References</h3>

<p>Gabbiadini, Alessandro, Christina Sagioglou, and Tobias Greitemeyer.
&quot;Does Pokémon Go lead to a more physically active life style?.&quot;
<em>Computers in Human Behavior</em> 84 (2018): 258-263.
</p>

<hr>
<h2 id='predict.sevt'>Predict method for staged event tree</h2><span id='topic+predict.sevt'></span>

<h3>Description</h3>

<p>Predict class values from a staged event tree model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
predict(object, newdata = NULL, class = NULL, prob = FALSE, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sevt_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities.</p>
</td></tr>
<tr><td><code id="predict.sevt_+3A_newdata">newdata</code></td>
<td>
<p>the newdata to perform predictions</p>
</td></tr>
<tr><td><code id="predict.sevt_+3A_class">class</code></td>
<td>
<p>character, the name of the variable to use as
the class variable, if NULL  the first element <code>names(object$tree)</code>
will be used.</p>
</td></tr>
<tr><td><code id="predict.sevt_+3A_prob">prob</code></td>
<td>
<p>logical, if <code>TRUE</code> the probabilities of class are
returned</p>
</td></tr>
<tr><td><code id="predict.sevt_+3A_log">log</code></td>
<td>
<p>logical, if <code>TRUE</code> log-probabilities are returned</p>
</td></tr>
<tr><td><code id="predict.sevt_+3A_...">...</code></td>
<td>
<p>additional parameters, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predict the most probable a posterior value for the class variable
given all the other variables in the model. Ties are broken at random and
if, for a given vector of predictor variables, all conditional probabilities
are 0, NA is returned.
</p>
<p>if <code>prob = TRUE</code>, a matrix with number of rows equals to the number of
rows in the <code>newdata</code> and number of columns as the number of levels of the
<code>class</code> variable is returned. if <code>log = TRUE</code>, log-probabilities are returned.
</p>
<p>if <code>prob = FALSE</code>, a vector of length as the number of rows in the <code>newdata</code>
with the level with higher estimated probability for each new observations is returned.
</p>


<h3>Value</h3>

<p>A vector of predictions or the corresponding matrix of probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 4, n = 600)
order &lt;- c("C", "X1", "X2", "X3", "X4")
train &lt;- DD[1:500, order]
test &lt;- DD[501:600, order]
model &lt;- full(train)
model &lt;- stages_bhc(model)
pr &lt;- predict(model, newdata = test, class = "C")
table(pr, test$C)
# class values:
predict(model, newdata = test, class = "C")
# probabilities:
predict(model, newdata = test, class = "C", prob = TRUE)
# log-probabilities:
predict(model, newdata = test, class = "C", prob = TRUE, log = TRUE)
</code></pre>

<hr>
<h2 id='print.sevt'>Print a staged event tree</h2><span id='topic+print.sevt'></span>

<h3>Description</h3>

<p>Print a staged event tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
print(x, ..., max = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sevt_+3A_x">x</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="print.sevt_+3A_...">...</code></td>
<td>
<p>additional parameters (compatibility).</p>
</td></tr>
<tr><td><code id="print.sevt_+3A_max">max</code></td>
<td>
<p>integer, limit on the numebr of variables to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the variables in the staged tree
is printed (from root). In addition the number of levels of each
variable is shown in square brackets.
If available the log-likelihood of the model is printed.
</p>


<h3>Value</h3>

<p>An invisible copy of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(5, 100)
model &lt;- full(DD, lambda = 1)
print(model)
</code></pre>

<hr>
<h2 id='prob'>Probabilities for a staged event tree</h2><span id='topic+prob'></span>

<h3>Description</h3>

<p>Compute (marginal and/or conditional) probabilities of elementary
events with respect
to the probability encoded in a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob(object, x, conditional_on = NULL, log = FALSE, na0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with probabilities.</p>
</td></tr>
<tr><td><code id="prob_+3A_x">x</code></td>
<td>
<p>the vector or data.frame of observations.</p>
</td></tr>
<tr><td><code id="prob_+3A_conditional_on">conditional_on</code></td>
<td>
<p>named vector, the conditioning event.</p>
</td></tr>
<tr><td><code id="prob_+3A_log">log</code></td>
<td>
<p>logical, if <code>TRUE</code> log-probabilities are returned.</p>
</td></tr>
<tr><td><code id="prob_+3A_na0">na0</code></td>
<td>
<p>logical, if <code>NA</code> should be converted to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes probabilities related to a vector or a
data.frame of observations.
</p>
<p>Optionally, conditional probabilities can be obtained by specifying
the conditioning event in <code>conditional_on</code>. This can be done either
with a single named vector or with a data.frame object with the
same number of rows of <code>x</code>. In the former, the same conditioning
is used for all the computed probabilities (if <code>x</code> has multiple rows);
while with the latter different conditioning events (but on the same variables)
can be specified for each row of <code>x</code>.
</p>


<h3>Value</h3>

<p>the probabilities to observe each observation in <code>x</code>, possibly
conditional on the event(s) in <code>conditional_on</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Titanic)
model &lt;- full(Titanic, lambda = 1)
samples &lt;- expand.grid(model$tree[c(1, 4)])
pr &lt;- prob(model, samples)
## probabilities sum up to one
sum(pr)
## print observations with probabilities
print(cbind(samples, probability = pr))

## compute one probability
prob(model, c(Class = "1st", Survived = "Yes"))

## compute conditional probability
prob(model, c(Survived = "Yes"), conditional_on = c(Class = "1st"))

## compute conditional probabilities with different conditioning set
prob(model, data.frame(Age = rep("Adult", 8)),
  conditional_on = expand.grid(model$tree[2:1])
)
## the above should be the same as
summary(model)$stages.info$Age
</code></pre>

<hr>
<h2 id='probdist'>Distances between probabilities</h2><span id='topic+probdist'></span><span id='topic+probdist.l2'></span><span id='topic+probdist.l1'></span><span id='topic+probdist.ry'></span><span id='topic+probdist.kl'></span><span id='topic+probdist.tv'></span><span id='topic+probdist.hl'></span><span id='topic+probdist.bh'></span><span id='topic+probdist.cd'></span>

<h3>Description</h3>

<p>Distances between probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probdist.l2(x, y)

probdist.l1(x, y)

probdist.ry(x, y)

probdist.kl(x, y)

probdist.tv(x, y)

probdist.hl(x, y)

probdist.bh(x, y)

probdist.cd(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probdist_+3A_x">x</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="probdist_+3A_y">y</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to compute distances between probabilities:
</p>

<ul>
<li> <p><code>lp</code>: the <code class="reqn">L^p</code> distance, <code class="reqn">||x - y||_p^p</code> for <code class="reqn">p = 1,2</code>
</p>
</li>
<li> <p><code>ry</code>: the symmetric Renyi divergence of order <code class="reqn">\alpha = 2</code>
</p>
</li>
<li> <p><code>kl</code>: the symmetrized Kullback-Leibler divergence
</p>
</li>
<li> <p><code>tv</code>: the total variation or <code class="reqn">L^1</code> norm
</p>
</li>
<li> <p><code>hl</code>: the (squared) Hellinger distance
</p>
</li>
<li> <p><code>bh</code>: the Bhattacharyya distance
</p>
</li>
<li> <p><code>cd</code>: the Chan-Darwiche distance
</p>
</li></ul>



<h3>Value</h3>

<p>The distance between <code>p</code> and <code>q</code>
</p>

<hr>
<h2 id='random_parentslist'>Generate a random <code>parentslist</code> object (DAG)</h2><span id='topic+random_parentslist'></span>

<h3>Description</h3>

<p>generate a random DAG coded as
<code><a href="#topic+as_parentslist">parentslist</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_parentslist(n, k = 2, maxp = n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_parentslist_+3A_n">n</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code id="random_parentslist_+3A_k">k</code></td>
<td>
<p>maximum number of levels for each variable.</p>
</td></tr>
<tr><td><code id="random_parentslist_+3A_maxp">maxp</code></td>
<td>
<p>maximum cardinality of parents sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable a subset of random cardinality
(maximum <code>maxp</code>) of the preceding
variables is randomly selected as parents set.
The possible levels of each variables are randomly selected
in <code>2,...,k</code>.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+as_parentslist">parentslist</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_parentslist(5, 3, 2)

## we can generate the associated staged tree
pl &lt;- random_parentslist(4, 2, 2)
plot(as_sevt(pl), main = as.character(pl))
</code></pre>

<hr>
<h2 id='random_sevt'>Generate a random (fitted) sevt</h2><span id='topic+random_sevt'></span><span id='topic+random_sevt.list'></span><span id='topic+random_sevt.parentslist'></span><span id='topic+random_sevt.sevt'></span>

<h3>Description</h3>

<p>Generate a random <code>sevt</code> from a DAG or a tree.
Probabilities are also randomly generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_sevt(x, q = 0.5, rfun = rexp)

## S3 method for class 'list'
random_sevt(x, q = 0.5, rfun = rexp)

## S3 method for class 'parentslist'
random_sevt(x, q = 0.5, rfun = rexp)

## S3 method for class 'sevt'
random_sevt(x, q = 0.5, rfun = rexp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_sevt_+3A_x">x</code></td>
<td>
<p>a <code>sevt</code> object, a <code>parentslist</code> object or a
<code>list</code>.</p>
</td></tr>
<tr><td><code id="random_sevt_+3A_q">q</code></td>
<td>
<p>probability of joining stages.</p>
</td></tr>
<tr><td><code id="random_sevt_+3A_rfun">rfun</code></td>
<td>
<p>a function which is used to generate random
conditional probabilities associated to each stage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated staged tree is obtained by randomly
joining stages with probability <code>q</code>.
</p>
<p>For <code>random_sevt.list</code>, <code>x</code> should be
a list representing an event tree, same format
as lists provided to <code><a href="#topic+sevt.list">sevt.list</a></code>.
The random generated <code>sevt</code> will be
obtained by randomly joining stages starting from
a full staged event tree.
</p>
<p>For <code>random_sevt.parentslist</code>, <code>x</code> should be
a <code><a href="#topic+as_parentslist">parentslist</a></code> object
representing a DAG, this could be obtained with
<code><a href="#topic+as_parentslist">as_parentslist</a></code> or with
<code><a href="#topic+random_parentslist">random_parentslist</a></code>.
The random generated <code>sevt</code> will be
obtained by randomly joining stages starting from
a the staged tree equivalent to the DAG.
</p>
<p>For <code>random_sevt.sevt</code>, <code>x</code> should be
a <code><a href="#topic+sevt">sevt</a></code>.
The random generated <code>sevt</code> will be
obtained by randomly joining stages starting
from the provided sevt object.
</p>
<div class="sourceCode"><pre>     Stages (conditional) probabilities are sampled from
     the corresponding probability simplex by generating
     a vector with the user-defined function \code{rfun} and
     normalizing it to sum up to one.
     Absolute value is applied to assure non-negativity.
     The default \code{rfun = rexp} induces a uniform sampling
     from the probability simplex.
</pre></div>


<h3>Value</h3>

<p>A randomly generated fitted <code>sevt</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_gt &lt;- random_sevt(list(
  X = c("a", "b"), Y = c("c", "d", "e"),
  Z = c("1", "2", "3"), W = c("yes", "no")
))

## sample data from model_gt and estimate a staged tree
data &lt;- sample_from(model_gt, 100)
model_est &lt;- stages_bhc(full(data))

## compare true and estimated model
hamming_stages(model_gt, model_est)
compare_stages(model_gt, model_est, method = "hamming", plot = TRUE)
</code></pre>

<hr>
<h2 id='rename_stage'>Rename stage(s) in staged event tree</h2><span id='topic+rename_stage'></span>

<h3>Description</h3>

<p>Change the name of a stage in a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_stage(object, var, stage, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_stage_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="rename_stage_+3A_var">var</code></td>
<td>
<p>name of a variable in <code>object</code>.</p>
</td></tr>
<tr><td><code id="rename_stage_+3A_stage">stage</code></td>
<td>
<p>name of the stage to be renamed.</p>
</td></tr>
<tr><td><code id="rename_stage_+3A_new">new</code></td>
<td>
<p>new name for the stage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No internal checks are performed and as side effect
stages can be joined, if e.g. <code>new</code> is equal to the name
of a stage for variable <code>var</code>.
</p>


<h3>Value</h3>

<p>a staged event tree object where stages <code>stage</code>
have been renamed to <code>new</code>.
</p>

<hr>
<h2 id='sample_from'>Sample from a staged event tree</h2><span id='topic+sample_from'></span>

<h3>Description</h3>

<p>Generate a random sample from the distribution encoded
in a staged event tree object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from(object, size = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_from_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_size">size</code></td>
<td>
<p>number of observations to sample.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized (‘seeded’). Either NULL or an integer
that will be used in a call to set.seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It samples <code>size</code> observations according to
the transition probabilities (<code>object$prob</code>) in the model.
</p>


<h3>Value</h3>

<p>A data frame containing <code>size</code> observations from the
variables in <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_fbhc(full(PhDArticles, lambda = 1))
sample_from(model, 10)
</code></pre>

<hr>
<h2 id='search_best'>Optimal Order Search</h2><span id='topic+search_best'></span>

<h3>Description</h3>

<p>Find the optimal staged event tree
with a dynamic programming approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_best(
  data,
  alg = stages_bhc,
  search_criterion = BIC,
  lambda = 0,
  join_unobserved = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_best_+3A_data">data</code></td>
<td>
<p>either a data.frame or a table containing the data.</p>
</td></tr>
<tr><td><code id="search_best_+3A_alg">alg</code></td>
<td>
<p>a function that performs stages structure estimation. Similar to
<code><a href="#topic+stages_bhc">stages_bhc</a></code> or <code><a href="#topic+stages_hclust">stages_hclust</a></code>.
The function <code>alg</code> must accept the argument
<code>scope</code>.</p>
</td></tr>
<tr><td><code id="search_best_+3A_search_criterion">search_criterion</code></td>
<td>
<p>the criterion minimized in the order search.</p>
</td></tr>
<tr><td><code id="search_best_+3A_lambda">lambda</code></td>
<td>
<p>numerical value passed to <code><a href="#topic+full">full</a></code>.</p>
</td></tr>
<tr><td><code id="search_best_+3A_join_unobserved">join_unobserved</code></td>
<td>
<p>logical, passed to <code><a href="#topic+full">full</a></code>.</p>
</td></tr>
<tr><td><code id="search_best_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code>alg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of the
dynamic programming approach
of Silander and Leong (2013).
If the <code>search_criterion</code> is decomposable
the returned model attains the best value
among all possible orders.
</p>


<h3>Value</h3>

<p>The estimated staged event tree model.
</p>


<h3>References</h3>

<p>Silander T., Leong TY.
A Dynamic Programming Algorithm for Learning Chain Event Graphs.
In: Fürnkranz J., Hüllermeier E., Higuchi T. (eds)
Discovery Science. DS 2013. <em>Lecture Notes in Computer Science</em>,
vol 8140. Springer, Berlin, Heidelberg. 2013.
</p>
<p>Cowell R and Smith J.
Causal discovery through MAP selection of stratified chain event graphs.
<em>Electronic Journal of Statistics</em>, 8(1):965–997, 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default search using BIC score
model &lt;- search_best(Titanic, alg = stages_kmeans)

## use df as search_criterion
model1 &lt;- search_best(Titanic, alg = stages_bhc,
                      search_criterion = function(m) attr(logLik(m), "df"))
</code></pre>

<hr>
<h2 id='search_greedy'>Greedy Order Search</h2><span id='topic+search_greedy'></span>

<h3>Description</h3>

<p>Search the optimal staged event tree
with a greedy heuristic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_greedy(
  data,
  alg = stages_bhc,
  search_criterion = BIC,
  lambda = 0,
  join_unobserved = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_greedy_+3A_data">data</code></td>
<td>
<p>either a data.frame or a table containing the data.</p>
</td></tr>
<tr><td><code id="search_greedy_+3A_alg">alg</code></td>
<td>
<p>a function that performs stages structure estimation. Similar to
<code><a href="#topic+stages_bhc">stages_bhc</a></code> or <code><a href="#topic+stages_hclust">stages_hclust</a></code>.
The function <code>alg</code> must accept the argument
<code>scope</code>.</p>
</td></tr>
<tr><td><code id="search_greedy_+3A_search_criterion">search_criterion</code></td>
<td>
<p>the criterion minimized in the order search.</p>
</td></tr>
<tr><td><code id="search_greedy_+3A_lambda">lambda</code></td>
<td>
<p>numerical value passed to <code><a href="#topic+full">full</a></code>.</p>
</td></tr>
<tr><td><code id="search_greedy_+3A_join_unobserved">join_unobserved</code></td>
<td>
<p>logical, passed to <code><a href="#topic+full">full</a></code>.</p>
</td></tr>
<tr><td><code id="search_greedy_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code>alg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The greedy approach implemented in this function
iteratively adds variables to the staged tree that
better improve the <code>search_criterion</code>.
</p>


<h3>Value</h3>

<p>The estimated staged event tree model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- search_greedy(Titanic, alg = stages_fbhc)
print(model)
</code></pre>

<hr>
<h2 id='sevt'>Staged event tree (sevt) class</h2><span id='topic+sevt'></span><span id='topic+sevt.table'></span><span id='topic+sevt.data.frame'></span><span id='topic+sevt.list'></span>

<h3>Description</h3>

<p>Structure and usage of S3 class <code>sevt</code>,
used to store a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt(x, full = FALSE, order = NULL)

## S3 method for class 'table'
sevt(x, full = FALSE, order = names(dimnames(x)))

## S3 method for class 'data.frame'
sevt(x, full = FALSE, order = colnames(x))

## S3 method for class 'list'
sevt(x, full = FALSE, order = names(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_+3A_x">x</code></td>
<td>
<p>a list, a data frame or table object.</p>
</td></tr>
<tr><td><code id="sevt_+3A_full">full</code></td>
<td>
<p>logical, if TRUE the full model is created
otherwise the independence model.</p>
</td></tr>
<tr><td><code id="sevt_+3A_order">order</code></td>
<td>
<p>character vector,
order of the variables to build the
tree, by default the order of the variables
in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A staged event tree object is a list with components:
</p>

<ul>
<li><p> tree (required): A named list with one component
for each variable in the model,
a character vector with the names of
the levels for that variable.
The order of the variables in <code>tree</code> is the
order of the event tree.
</p>
</li>
<li><p> stages (required): A named list with one component
for each variable but the first,
a character vector storing the stages for
the situations related to path ending in that
variable.
</p>
</li>
<li><p> ctables: A named list with one component
for each variable, the flat contingency table of that variable
given the previous variables.
</p>
</li>
<li><p> lambda: The smoothing parameter used to compute probabilities.
</p>
</li>
<li><p> name_unobserved: The stage name for unobserved situations.
</p>
</li>
<li><p> prob: The conditional probability tables for every
variable and stage. Stored in a named list with
one component for each variable, a list with
one component for each stage.
</p>
</li>
<li><p> ll: The log-likelihood of the <code>estimated</code> model.
If present, <code><a href="#topic+logLik.sevt">logLik.sevt</a></code> will
return this value instead of computing the log-likelihood.
</p>
</li></ul>

<p>The tree structure is never defined explicitly, instead it
is implicitly defined by the list <code>tree</code> containing the order
of the variables and the names of their levels. This is
sufficient to define a complete symmetric tree where an
internal node at a depth related to a variable <code>v</code>
has a number of children equal to the cardinality of
the levels of <code>v</code>.
The stages information is instead stored as a list of
vectors, where each vector is indexed as the internal nodes
of the tree at a given depth.
</p>
<p>To define a staged tree from data (data frame or table) the
user can call either <code><a href="#topic+full">full</a></code> or <code><a href="#topic+indep">indep</a></code>
which both construct the staged tree object, attach the data in
<code>ctables</code> and compute probabilities. After, one of the
available model selection algorithm can be used, see for example
<code><a href="#topic+stages_hc">stages_hc</a></code>, <code><a href="#topic+stages_bhc">stages_bhc</a></code> or
<code><a href="#topic+stages_hclust">stages_hclust</a></code>.
If, mainly for development, only the staged tree structure is needed
(without data or probabilities) the basic
<code><a href="#topic+sevt">sevt</a></code> constructor can
be used.
</p>


<h3>Value</h3>

<p>A staged event tree object, an object of class <code>sevt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######### from table
model.titanic &lt;- sevt(Titanic, full = TRUE)

######### from data frame
DD &lt;- generate_random_dataset(p = 4, n = 1000)
model.indep &lt;- sevt(DD)
model.full &lt;- sevt(DD, full = TRUE)

######### from list
model &lt;- sevt(list(
  X = c("good", "bad"),
  Y = c("high", "low")
))
</code></pre>

<hr>
<h2 id='sevt_add'>Add a variable to a staged event tree</h2><span id='topic+sevt_add'></span>

<h3>Description</h3>

<p>Return an updated staged event tree with one additional
variable at the end of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_add(object, var, data, join_unobserved = TRUE, useNA = "ifany")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_add_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="sevt_add_+3A_var">var</code></td>
<td>
<p>character, the name of the new variable to be added.</p>
</td></tr>
<tr><td><code id="sevt_add_+3A_data">data</code></td>
<td>
<p>either a <code>data.frame</code> or a <code>table</code> containing
the data from the variables in <code>object</code> plus <code>var</code>.</p>
</td></tr>
<tr><td><code id="sevt_add_+3A_join_unobserved">join_unobserved</code></td>
<td>
<p>logical, passed to <code><a href="#topic+full">full</a></code>.</p>
</td></tr>
<tr><td><code id="sevt_add_+3A_usena">useNA</code></td>
<td>
<p>whether to include NA values in the tables.
Argument passed to <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function update a staged event tree object with
an additional variable. The stages structure of the
new variable is initialized as in the saturated model.
</p>


<h3>Value</h3>

<p>An object of class <code>sevt</code> representing a
staged event tree model with <code>var</code> added as last variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- full(Titanic, order = c("Age", "Class"))
print(model)
model &lt;- sevt_add(model, "Survived", Titanic)
print(model)
</code></pre>

<hr>
<h2 id='sevt_df'>Number of parameters of a staged event tree</h2><span id='topic+sevt_df'></span>

<h3>Description</h3>

<p>Return the number of parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_df_+3A_x">x</code></td>
<td>
<p>An object of class <code>sevt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, degrees of freedom of the staged event tree.
</p>

<hr>
<h2 id='sevt_fit'>Fit a staged event tree</h2><span id='topic+sevt_fit'></span>

<h3>Description</h3>

<p>Estimate transition probabilities in a staged event tree from data.
Probabilities are estimated with the relative frequencies plus,
eventually, an additive (Laplace) smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_fit(
  object,
  data = NULL,
  lambda = NULL,
  scope = NULL,
  compute_logLik = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_fit_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="sevt_fit_+3A_data">data</code></td>
<td>
<p>data.frame or contingency table with observations of
the variables in <code>object</code>.</p>
</td></tr>
<tr><td><code id="sevt_fit_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter or pseudocount. Default (NULL) to
lambda value stored in <code>object</code>. If no lambda value is
stored nor provided, 0 will be used with a warning.</p>
</td></tr>
<tr><td><code id="sevt_fit_+3A_scope">scope</code></td>
<td>
<p>which variable should be fitted. Default (NULL) to
all variables in the model. A partial re-fit is
possible only for model which are already fitted and in
that case the provided <code>lambda</code> will be ignored if
different from <code>object$lambda</code>.</p>
</td></tr>
<tr><td><code id="sevt_fit_+3A_compute_loglik">compute_logLik</code></td>
<td>
<p>logical value. If <code>TRUE</code> the log-likelihood
of the model is computed and stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data in form of contingency tables and the
log-likelihood of the model is (eventually)
stored in the returned staged event tree.
Partial re-fit of a model can be performed
with the <code>scope</code> argument.
Partial re-fit can only be done over a
fully fitted model, e.g. when changing
the stages structure of one of the variables.
In case of a partial re-fit, the <code>data</code> and <code>lambda</code> arguments
will be ignored and the data and lambda value stored in the
sevt object will be used (a warning is issued if such arguments are
supplied).
</p>


<h3>Value</h3>

<p>A fitted staged event tree,
that is an object of class <code>sevt</code>
with <code>ctables</code> and <code>prob</code> components.
Additionally the chosen <code>lambda</code> is stored in the returned object
and eventually the log-likelihood of the model is saved in
the <code>ll</code> field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#########
model &lt;- sevt(list(
  X = c("good", "bad"),
  Y = c("high", "low")
))
D &lt;- data.frame(
  X = c("good", "good", "bad"),
  Y = c("high", "low", "low")
)
model.fit &lt;- sevt_fit(model, data = D, lambda = 1)
</code></pre>

<hr>
<h2 id='sevt_nvar'>Number of variables</h2><span id='topic+sevt_nvar'></span>

<h3>Description</h3>

<p>Utility returning the number of variables
in a staged event tree model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_nvar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_nvar_+3A_object">object</code></td>
<td>
<p>An object of class <code>sevt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the number of variables.
</p>

<hr>
<h2 id='sevt_simplify'>Simplify a staged tree model</h2><span id='topic+sevt_simplify'></span>

<h3>Description</h3>

<p>Function to simplify a staged tree model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_simplify(object, fit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_simplify_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code></p>
</td></tr>
<tr><td><code id="sevt_simplify_+3A_fit">fit</code></td>
<td>
<p>logical, if <code>TRUE</code> refit the model after simplification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simplify</code> function will produce the corresponding simple
staged tree, that is a staged tree where stages and positions are
equivalent.
To do so the function <code>ceg</code> is used to compute positions, and
then the stages' vectors are replaced with the positions' vectors.
The model is the re-fitted if the input was a fitted staged tree.
Despite the name, the simplified staged tree has always a number
of stages greater or equal to the initial staged tree, thus it is
a more complex statistical model.
</p>


<h3>Value</h3>

<p>an object of class <code>sevt</code>
representing the simplified model.
The returned model will be fitted if the input <code>model</code> was.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- stages_kmeans(full(Titanic), k = 2)
simpl &lt;- sevt_simplify(mod)
plot(simpl)
</code></pre>

<hr>
<h2 id='sevt_varnames'>Variable names</h2><span id='topic+sevt_varnames'></span>

<h3>Description</h3>

<p>Utility returning variable-names in a staged event tree
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevt_varnames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevt_varnames_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='split_stage_random'>Split randomly a stage</h2><span id='topic+split_stage_random'></span>

<h3>Description</h3>

<p>Randomly assign some of the paths to a new stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_stage_random(object, var, stage, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_stage_random_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="split_stage_random_+3A_var">var</code></td>
<td>
<p>the variable name.</p>
</td></tr>
<tr><td><code id="split_stage_random_+3A_stage">stage</code></td>
<td>
<p>the name of the stage.</p>
</td></tr>
<tr><td><code id="split_stage_random_+3A_p">p</code></td>
<td>
<p>probability to move a situation from the
original stage into the new stage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splits randomly a given stage into two stages. More precisely,
it assigns each situation within the given stage into a new stage with
probability <code>p</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sevt</code>.
</p>

<hr>
<h2 id='stages'>The stages of a staged event tree</h2><span id='topic+stages'></span><span id='topic+stages.sevt'></span><span id='topic+print.sevt.stgs'></span><span id='topic+stages+3C-'></span><span id='topic++5B.sevt.stgs'></span><span id='topic++5B+3C-.sevt.stgs'></span><span id='topic++5B+5B.sevt.stgs'></span><span id='topic++5B+5B+3C-.sevt.stgs'></span>

<h3>Description</h3>

<p>Functions to get or set the stages of an object of class
<code>sevt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages(object)

## S3 method for class 'sevt'
stages(object)

## S3 method for class 'sevt.stgs'
print(x, ..., max = 5)

stages(object) &lt;- value

## S3 method for class 'sevt.stgs'
x[i, ...]

## S3 replacement method for class 'sevt.stgs'
x[i, ..., fit = TRUE] &lt;- value

## S3 method for class 'sevt.stgs'
x[[...]]

## S3 replacement method for class 'sevt.stgs'
x[[..., fit = TRUE]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="stages_+3A_x">x</code></td>
<td>
<p>an object of class <code>sevt.stgs</code>
(obtained by <code>stages(object)</code>).</p>
</td></tr>
<tr><td><code id="stages_+3A_...">...</code></td>
<td>
<p>a path or context in the event tree.</p>
</td></tr>
<tr><td><code id="stages_+3A_max">max</code></td>
<td>
<p>integer, limit on the number of variables to print.</p>
</td></tr>
<tr><td><code id="stages_+3A_value">value</code></td>
<td>
<p>the stages replacement value.</p>
</td></tr>
<tr><td><code id="stages_+3A_i">i</code></td>
<td>
<p>index of variables in the tree.</p>
</td></tr>
<tr><td><code id="stages_+3A_fit">fit</code></td>
<td>
<p>logical, if TRUE (default) the model will be re-fitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions are the preferred way to access and modify directly
the stages of an object of class <code>sevt</code>.
In particular the indexing and replacing methods for the
object extracted with the function <code>stages()</code> take care of checking
the stages sanity and refit the object probabilities when needed.
This is useful for manually setting some independence statements
(see the Examples).
</p>


<h3>Value</h3>

<p>For <code>stages()</code>: returns an object of class
<code>sevt.stgs</code> which encode the stages of <code>object</code>.
Objects of class <code>sevt.stgs</code> have dedicated
method for sub-setting and replacing.
</p>


<h3>Stages indexing</h3>

<p>Stages can be indexed, retrieved and replaced
by the corresponding variables names and/or by
paths or contexts.
</p>
<p>In particular,
<code>stages(object)[[var]]</code> extracts the
stages vector corresponding to variable <code>var</code> (similarly
to <code>object$stages[[var]]</code>.
Alternatively <code>stages(object)[[path]]</code> indexes
a stage via the corresponding path from root
(similar to <code><a href="#topic+get_stage">get_stage</a></code>); a path is
recognized as such if named or if of length &gt; 2.
</p>
<p><code>stages(object)[var, context]</code> extracts multiple stages
corresponding to a variable and eventually filtered by
a specific context on the preceding variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with full model
mod &lt;- full(Titanic)

# impose the context independence Survived indep Sex, Age | Class = 1st
stages(mod)["Survived", Class = "1st"] &lt;- "C1"

# impose Survived indep Class | Class in (2nd 3rd)
stages(mod)["Survived", Class = "3rd"] &lt;- stages(mod)["Survived", Class = "2nd"]

# impose Age indep Class | Sex
stages(mod)["Age", Sex = "Female"] &lt;- "S-female"
stages(mod)["Age", Sex = "Male"] &lt;- "S-male"

# stages of Survived
stages(mod)[["Survived"]]

# stages of Survived and Age
stages(mod)[c("Survived", "Age")]

# stages of Survived in the context Class 2nd or 3rd
stages(mod)["Survived", Class = c("2nd", "3rd")]

# check independencies
as_parentslist(mod)
</code></pre>

<hr>
<h2 id='stages_bhc'>Backward hill-climbing</h2><span id='topic+stages_bhc'></span>

<h3>Description</h3>

<p>Greedy search of staged event trees with
iterative joining of stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_bhc(
  object,
  score = function(x) {
     return(-BIC(x))
 },
  max_iter = Inf,
  scope = NULL,
  ignore = object$name_unobserved,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_bhc_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_bhc_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_bhc_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations per variable.</p>
</td></tr>
<tr><td><code id="stages_bhc_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered for the optimization.</p>
</td></tr>
<tr><td><code id="stages_bhc_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_bhc_+3A_trace">trace</code></td>
<td>
<p>if &gt;0 increasingly amount of info
is printed (via <code>message</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable the algorithm tries to join stages
and moves to the best model that increases the score. When no
increase is possible it moves to the next variable.
</p>


<h3>Value</h3>

<p>The final staged event tree obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 4, n = 100)
model &lt;- stages_bhc(full(DD), trace = 2)
summary(model)
</code></pre>

<hr>
<h2 id='stages_bhcr'>Backward random hill-climbing</h2><span id='topic+stages_bhcr'></span>

<h3>Description</h3>

<p>Randomly try to join stages.
This is a pretty-useless function, used for comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_bhcr(
  object,
  score = function(x) {
     return(-BIC(x))
 },
  max_iter = 100,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_bhcr_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="stages_bhcr_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_bhcr_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iteration.</p>
</td></tr>
<tr><td><code id="stages_bhcr_+3A_trace">trace</code></td>
<td>
<p>if &gt;0 increasingly amount of info
is printed (via <code>message</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each iteration a variable and
two of its stages are randomly selected.
If joining the stages increases the score, the model is
updated. The procedure is repeated until the
number of iterations reaches <code>max_iter</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sevt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 4, n = 100)
model &lt;- stages_bhcr(full(DD), trace = 2)
summary(model)
</code></pre>

<hr>
<h2 id='stages_bj'>Backward joining of stages</h2><span id='topic+stages_bj'></span>

<h3>Description</h3>

<p>Join stages from more complex to simpler models
using a distance and a threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_bj(
  object,
  distance = "kullback",
  thr = 0.1,
  scope = NULL,
  ignore = object$name_unobserved,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_bj_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_bj_+3A_distance">distance</code></td>
<td>
<p>character, see details.</p>
</td></tr>
<tr><td><code id="stages_bj_+3A_thr">thr</code></td>
<td>
<p>the threshold for joining stages</p>
</td></tr>
<tr><td><code id="stages_bj_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered
for the optimization.</p>
</td></tr>
<tr><td><code id="stages_bj_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_bj_+3A_trace">trace</code></td>
<td>
<p>if &gt;0 increasingly amount of info
is printed (via <code>message</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable in the model stages are joined iteratively.
At each iteration the two stages with minimum distance are selected and
joined if their distance is less than <code>thr</code>.
</p>
<p>Available distances are: manhattan (<code>manhattan</code>), euclidean (<code>euclidean</code>),
Renyi divergence (<code>reny</code>), Kullback-Liebler (<code>kullback</code>),
total-variation (<code>totvar</code>), squared Hellinger (<code>hellinger</code>),
Bhattacharyya (<code>bhatt</code>), Chan-Darwiche (<code>chandarw</code>).
See also <a href="#topic+probdist">probdist</a>.
</p>


<h3>Value</h3>

<p>The final staged event tree obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 5, n = 1000)
model &lt;- stages_bj(full(DD, lambda = 1), trace = 2)
summary(model)
</code></pre>

<hr>
<h2 id='stages_csbhc'>Context-specific Backward hill-climbing</h2><span id='topic+stages_csbhc'></span>

<h3>Description</h3>

<p>Greedy search of staged event trees with
iterative joining of stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_csbhc(
  object,
  score = function(x) {
     return(-BIC(x$ll))
 },
  max_iter = Inf,
  scope = NULL,
  ignore = object$name_unobserved
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_csbhc_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_csbhc_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_csbhc_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations per variable.</p>
</td></tr>
<tr><td><code id="stages_csbhc_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered for the optimization.</p>
</td></tr>
<tr><td><code id="stages_csbhc_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable the algorithm tries to join stages
, by adding context specific independences,
and moves to the best model that increases the score. When no
increase is possible it moves to the next variable.
</p>


<h3>Value</h3>

<p>The final staged event tree obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_csbhc(full(Titanic))
summary(model)
</code></pre>

<hr>
<h2 id='stages_fbhc'>Fast backward hill-climbing</h2><span id='topic+stages_fbhc'></span>

<h3>Description</h3>

<p>Greedy search of staged event trees with
iterative joining of stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_fbhc(
  object,
  score = function(x) {
     return(-BIC(x))
 },
  max_iter = Inf,
  scope = NULL,
  ignore = object$name_unobserved,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_fbhc_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_fbhc_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_fbhc_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iteration.</p>
</td></tr>
<tr><td><code id="stages_fbhc_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered for the optimization.</p>
</td></tr>
<tr><td><code id="stages_fbhc_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_fbhc_+3A_trace">trace</code></td>
<td>
<p>if &gt;0 increasingly amount of info
is printed (via <code>message</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable the algorithm tries to join stages
and moves to the first model that increases the score. When no
increase is possible it moves to the next variable.
</p>


<h3>Value</h3>

<p>The final staged event tree obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_xor_dataset(p = 5, n = 100)
model &lt;- stages_fbhc(full(DD), trace = 2)
summary(model)
</code></pre>

<hr>
<h2 id='stages_hc'>Hill-climbing</h2><span id='topic+stages_hc'></span>

<h3>Description</h3>

<p>Greedy search of staged event trees with
iterative moving of nodes between stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_hc(
  object,
  score = function(x) {
     return(-BIC(x))
 },
  max_iter = Inf,
  scope = NULL,
  ignore = object$name_unobserved,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_hc_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_hc_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_hc_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations per variable.</p>
</td></tr>
<tr><td><code id="stages_hc_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered for the optimization</p>
</td></tr>
<tr><td><code id="stages_hc_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_hc_+3A_trace">trace</code></td>
<td>
<p>if &gt;0 increasingly amount of info
is printed (via <code>message</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable node-moves that best increases the
score are performed until no increase is possible.
A node-move is either changing the stage
associate to a node or move the node to a new stage.
</p>
<p>The <code>ignore</code> argument can be used to specify stages that should not
be affected during the search, that is left untouched.
This is useful for preserving structural zeroes and to speed-up
computations.
</p>


<h3>Value</h3>

<p>The final staged event tree obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>start &lt;- indep(PhDArticles[, 1:5], join_unobserved = TRUE)
model &lt;- stages_hc(start)
</code></pre>

<hr>
<h2 id='stages_hclust'>Learn a staged tree with hierarchical clustering</h2><span id='topic+stages_hclust'></span>

<h3>Description</h3>

<p>Build a stage event tree with <code>k</code> stages for each variable by
clustering stage probabilities with hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_hclust(
  object,
  distance = "totvar",
  k = NA,
  method = "complete",
  ignore = object$name_unobserved,
  limit = length(object$tree),
  scope = NULL,
  score = function(x) {
     return(-BIC(x))
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_hclust_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_distance">distance</code></td>
<td>
<p>character, the distance measure to be used, either
a possible <code>method</code> for <code><a href="stats.html#topic+dist">dist</a></code> or
one of the following: <code>"totvar", "hellinger"</code>.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_k">k</code></td>
<td>
<p>integer or (named) vector: number of clusters, that is stages per variable.
Values will be recycled if needed. If <code>NA</code> (default) a search of
the number of stage is performed with respect to the maximization of
the <code>score</code> function. <code>NA</code> and integer can be mixed
to fix the number of stage for some variables and use the
score to select others.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used in <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched.
By default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_limit">limit</code></td>
<td>
<p>the maximum number of variables to consider.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_scope">scope</code></td>
<td>
<p>names of the variables to consider.</p>
</td></tr>
<tr><td><code id="stages_hclust_+3A_score">score</code></td>
<td>
<p>A function. Score to maximize for automatic selection
of the number of stages. Used if <code>k=NA</code> for some variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hclust_sevt</code> performs hierarchical clustering
of the initial stage probabilities in <code>object</code>
and it aggregates them into the specified number
of stages (<code>k</code>).
A different number of stages for the different variables
in the model can be specified by supplying a (named) vector
via the argument <code>k</code>.
If <code>k</code> is <code>NA</code> for some variables, all
possible number of stages will be checked and the
one that maximize the <code>score</code> will be selected.
</p>


<h3>Value</h3>

<p>A staged event tree object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")
model &lt;- stages_hclust(full(Titanic, join_unobserved = TRUE, lambda = 1), k = 2)
summary(model)

### or search k via BIC minimization
model1 &lt;- stages_hclust(full(Titanic), k = NA)
</code></pre>

<hr>
<h2 id='stages_kmeans'>Learn a staged tree with k-means clustering</h2><span id='topic+stages_kmeans'></span>

<h3>Description</h3>

<p>Build a stage event tree with <code>k</code> stages for each variable
by clustering (transformed) probabilities with k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_kmeans(
  object,
  k = length(object$tree[[1]]),
  algorithm = "Hartigan-Wong",
  transform = sqrt,
  ignore = object$name_unobserved,
  limit = length(object$tree),
  scope = NULL,
  nstart = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_kmeans_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code> with fitted probabilities and
data, as returned by <code>full</code> or <code>sevt_fit</code>.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_k">k</code></td>
<td>
<p>integer or (named) vector: number of clusters, that is stages per variable.
Values will be recycled if needed.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>character: as in <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_transform">transform</code></td>
<td>
<p>function applied to the probabilities before clustering.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_limit">limit</code></td>
<td>
<p>the maximum number of variables to consider.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_scope">scope</code></td>
<td>
<p>names of the variables to consider.</p>
</td></tr>
<tr><td><code id="stages_kmeans_+3A_nstart">nstart</code></td>
<td>
<p>as in <code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kmenas_sevt</code> performs k-means clustering
to aggregate the stage probabilities of the initial
staged tree <code>object</code>.
Different values for k can be specified by supplying a
(named) vector to <code>k</code>.
<code><a href="stats.html#topic+kmeans">kmeans</a></code> from the <code>stats</code> package is used
internally and arguments <code>algorithm</code> and <code>nstart</code>
refer to the same arguments as <code><a href="stats.html#topic+kmeans">kmeans</a></code>.
</p>


<h3>Value</h3>

<p>A staged event tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")
model &lt;- stages_kmeans(full(Titanic, join_unobserved = TRUE, lambda = 1), k = 2)
summary(model)
</code></pre>

<hr>
<h2 id='stages_simplebhc'>Backward hill-climbing for simple staged trees</h2><span id='topic+stages_simplebhc'></span>

<h3>Description</h3>

<p>Greedy search of simple staged event trees
with iterative joining of positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stages_simplebhc(
  object,
  score = function(x) {
     return(-BIC(x))
 },
  scope = NULL,
  max_iter = Inf,
  ignore = object$name_unobserved
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stages_simplebhc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code>
with fitted probabilities and data,
as returned by <code><a href="#topic+full">full</a></code> or
<code><a href="#topic+sevt_fit">sevt_fit</a></code>.</p>
</td></tr>
<tr><td><code id="stages_simplebhc_+3A_score">score</code></td>
<td>
<p>the score function to be maximized.</p>
</td></tr>
<tr><td><code id="stages_simplebhc_+3A_scope">scope</code></td>
<td>
<p>names of variables that should be considered for
the optimization.</p>
</td></tr>
<tr><td><code id="stages_simplebhc_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations per variable.</p>
</td></tr>
<tr><td><code id="stages_simplebhc_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to the classical
backward hill-climbing implemented in <code><a href="#topic+stages_bhc">stages_bhc</a></code>, but
instead of joining stages it consider joining of <em>positions</em> via
<code><a href="#topic+join_positions">join_positions</a></code>.
Thus, the search is in the space of simple staged tree models if the
initial stage tree is simple.
See the references for additional details.
</p>


<h3>Value</h3>

<p>an object of class <code>sevt</code>, the simple staged tree resulting
from the search.
</p>


<h3>References</h3>

<p>Leonelli M, Varando G.
Structural Learning of Simple Staged Trees,
<em>arXiv preprint</em>
<a href="https://arxiv.org/abs/2203.04390">arXiv:2203.04390v1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join_positions">join_positions()</a></code>
<code><a href="#topic+sevt_simplify">sevt_simplify()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- stages_simplebhc(full(Titanic))
plot(mod)
</code></pre>

<hr>
<h2 id='stndnaming'>Standard renaming of stages</h2><span id='topic+stndnaming'></span>

<h3>Description</h3>

<p>Rename all stages in a staged event tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stndnaming(
  object,
  uniq = FALSE,
  prefix = FALSE,
  ignore = object$name_unobserved
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stndnaming_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="stndnaming_+3A_uniq">uniq</code></td>
<td>
<p>logical, if stage numbers should be unique over all tree.</p>
</td></tr>
<tr><td><code id="stndnaming_+3A_prefix">prefix</code></td>
<td>
<p>logical, if stage names should be prefixed with variable name.</p>
</td></tr>
<tr><td><code id="stndnaming_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and left untouched,
by default the name of the unobserved stages stored in
<code>object$name_unobserved</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a staged event tree object with stages named with
consecutive integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_fbhc(full(PhDArticles, join_unobserved = TRUE))
model$stages
model1 &lt;- stndnaming(model)
model1$stages

### unique stage names in all tree
model2 &lt;- stndnaming(model, uniq = TRUE)
model2$stages

### prefix stage names with variable name
model3 &lt;- stndnaming(model, prefix = TRUE)
model3$stages

### manuallty select stage names left untouched
model4 &lt;- stndnaming(model, ignore = c("2", "6"), prefix = TRUE)
model4$stages
</code></pre>

<hr>
<h2 id='subtree'>Extract subtree</h2><span id='topic+subtree'></span>

<h3>Description</h3>

<p>Extract subtree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtree(object, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtree_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="subtree_+3A_path">path</code></td>
<td>
<p>the path from root after which extract the subtree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the subtree of the staged event tree, starting from
<code>path</code>.
</p>


<h3>Value</h3>

<p>A staged event tree object corresponding to the subtree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DD &lt;- generate_random_dataset(4, 100)
model &lt;- sevt(DD, full = TRUE)
plot(model)
model1 &lt;- subtree(model, path = c("-1", "1"))
plot(model1)
</code></pre>

<hr>
<h2 id='summary.sevt'>Summarizing staged event trees</h2><span id='topic+summary.sevt'></span><span id='topic+print.summary.sevt'></span>

<h3>Description</h3>

<p>Summary method for class <code>sevt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
summary(object, ...)

## S3 method for class 'summary.sevt'
print(x, max = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sevt_+3A_object">object</code></td>
<td>
<p>an object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="summary.sevt_+3A_...">...</code></td>
<td>
<p>arguments for compatibility.</p>
</td></tr>
<tr><td><code id="summary.sevt_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sevt</code>.</p>
</td></tr>
<tr><td><code id="summary.sevt_+3A_max">max</code></td>
<td>
<p>the maximum number of variables for which
information is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print model information and summary of stages.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.sevt</code>
for which a <code>print</code>
method exist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- stages_fbhc(full(PhDArticles, lambda = 1))
summary(model)
</code></pre>

<hr>
<h2 id='text.sevt'>Add text to a staged event tree plot</h2><span id='topic+text.sevt'></span>

<h3>Description</h3>

<p>Add text to a staged event tree plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sevt'
text(x, y = ylim[1], limit = 10, xlim = c(0, 1), ylim = c(0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text.sevt_+3A_x">x</code></td>
<td>
<p>An object of class <code>sevt</code>.</p>
</td></tr>
<tr><td><code id="text.sevt_+3A_y">y</code></td>
<td>
<p>the position of the labels.</p>
</td></tr>
<tr><td><code id="text.sevt_+3A_limit">limit</code></td>
<td>
<p>maximum number of variables plotted.</p>
</td></tr>
<tr><td><code id="text.sevt_+3A_xlim">xlim</code></td>
<td>
<p>graphical parameter.</p>
</td></tr>
<tr><td><code id="text.sevt_+3A_ylim">ylim</code></td>
<td>
<p>graphical parameter.</p>
</td></tr>
<tr><td><code id="text.sevt_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='trajectories'>Hospital trajectories</h2><span id='topic+trajectories'></span>

<h3>Description</h3>

<p>Generated dataset with observations from five variables (SEX, AGE,
ICU, RSP, OUT) describing imaginary patients' trajectories
in a hospital.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectories
</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 observations of 5 variables.
</p>


<h3>Source</h3>

<p>The data has been generated with the code in the Examples section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("stagedtrees")

tree &lt;- list(SEX = c("male", "female"),
             AGE = c("child", "adult", "elder"),
             ICU = c("0", "1"),
             RSP = c("intub", "mask", "no"),
             OUT = c("death", "survived"))

model &lt;- sevt(tree, full = TRUE)

stages(model)["ICU", AGE = "child"] &lt;- "ICUchild"

stages(model)["ICU", SEX = "male", AGE = "elder"] &lt;-
  stages(model)["ICU", SEX = "female", AGE = "elder"]

stages(model)["RSP", AGE = c("child"), ICU = "0"] &lt;- "childnoICU"
stages(model)["RSP", AGE = c("child"), ICU = "1"] &lt;- "childICU"

stages(model)["RSP", AGE = c("adult")] &lt;- stages(model)["RSP", AGE = c("elder")]


stages(model)["OUT", AGE = "adult",
              SEX = "female",
              ICU = "1",
              RSP = c("intub", "mask")] &lt;- "femaleICUresp"

stages(model)["OUT", AGE = "child",
                     ICU = "1",
                     RSP = "intub"] &lt;- "childICUintub"

stages(model)["OUT", AGE = "child",
              ICU = "1",
              RSP = "mask"] &lt;- "childICUmask"

stages(model)["OUT", AGE = "child",
              ICU = "1",
              RSP = "no"] &lt;- "childICUno"

stages(model)["OUT", AGE = "adult", SEX = "male"] &lt;-
  stages(model)["OUT", AGE = "elder", SEX = "female"]

stages(model)["OUT", ICU = "0", RSP = "intub"] &lt;- "UNOBS"
stages(model)["OUT", ICU = "0", RSP = "intub"] &lt;- "UNOBS"
stages(model)["OUT", AGE = "child", ICU = "0"] &lt;- "UNOBS"

model$prob &lt;- list()
model$prob$SEX &lt;- list( "NA" = c(male = 0.4, female = 0.6))
model$prob$AGE &lt;- list("1" = c("child" = 0.1, "adult" = 0.5, "elder" = 0.4),
                       "2" = c("child" = 0.1, "adult" = 0.3, "elder" = 0.6))

model$prob$ICU &lt;- list("ICUchild" = c("0" = 0, "1" = 1),
                       "2" = c("0" = 0.4, "1" = 0.6), ## male adult
                       "5" = c("0" = 0.2, "1" = 0.8), ## female adult
                       "6" = c("0" = 0.7, "1" = 0.3)) ## elder

model$prob$RSP &lt;- list("childnoICU" = c("intub" = NA, "mask" = NA, "no" = NA),
                       "childICU" = c("intub" = 0.1, "mask" = 0.7, "no" = 0.2),
                       "5" = c("intub" = 0, "mask" = 0.7, "no" = 0.3), # male noICU
                       "6" = c("intub" = 0.4, "mask" = 0.5, "no" = 0.1), # male ICU
                       "11" = c("intub" = 0, "mask" = 0.5, "no" = 0.5), # female noICU
                       "12" = c("intub" = 0.4, "mask" = 0.5, "no" = 0.1)) # female ICU


model$prob$OUT &lt;- list("UNOBS" = c("death" = NA, "survived" = NA),
                       "childICUintub" = c("death" = 0.03, "survived" = 0.97),
                       "childICUmask" = c("death" = 0.02, "survived" = 0.98),
                       "childICUno" = c("death" = 0.01, "survived" = 0.99),
                       ### male adult and female elder ICU = 0 :
                       "32" = c("death" = 0.05, "survived" = 0.95), ## mask
                       "33" = c("death" = 0.01, "survived" = 0.99), ## no
                       ### male adult and female elder ICU = 1 :
                       "34" = c("death" = 0.15, "survived" = 0.85), ## intub
                       "35" = c("death" = 0.08, "survived" = 0.92), ## mask
                       "36" = c("death" = 0.04, "survived" = 0.96), ## no
                       ##############
                       "14" = c("death" = 0.2, "survived" = 0.8), # male elder 0 mask
                       "15" = c("death" = 0.1, "survived" = 0.9), # male elder 0 no
                       "16" = c("death" = 0.3, "survived" = 0.7), # male elder 1 intub
                       "17" = c("death" = 0.25, "survived" = 0.75), # male elder 1 mask
                       "18" = c("death" = 0.3, "survived" = 0.7), # male elder 1 no
                       ##############
                       "26" = c("death" = 0.1, "survived" = 0.9), # female adult 0 mask
                       "27" = c("death" = 0.15, "survived" = 0.85), # female adult 0 no
                       "30" = c("death" = 0.2, "survived" = 0.8),  # female adult 1 no
                       ##############
                       "femaleICUresp" = c("death" = 0.1, "survived" = 0.9)
                       )

# trajectories &lt;- sample_from(model, 10000, seed = 1)
# usethis::use_data(trajectories, overwrite = TRUE)
</code></pre>

<hr>
<h2 id='tree_idx'>return path index</h2><span id='topic+tree_idx'></span>

<h3>Description</h3>

<p>return path index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_idx(path, tree, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_idx_+3A_path">path</code></td>
<td>
<p>a path from root in the tree.</p>
</td></tr>
<tr><td><code id="tree_idx_+3A_tree">tree</code></td>
<td>
<p>a symmetric tree given as a list of levels.</p>
</td></tr>
<tr><td><code id="tree_idx_+3A_complete">complete</code></td>
<td>
<p>logical, if <code>TRUE</code> the complete indexing
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the integer index of the node associated with the
given path in a symmetric tree defined by <code>tree</code>.
</p>


<h3>Value</h3>

<p>an integer, the index of the node corresponding to <code>path</code>
</p>

<hr>
<h2 id='tree_string'>Tree string</h2><span id='topic+tree_string'></span>

<h3>Description</h3>

<p>Tree string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_string(tree, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_string_+3A_tree">tree</code></td>
<td>
<p>ordered list of variables</p>
</td></tr>
</table>

<hr>
<h2 id='uni_idx'>Unique id from named list</h2><span id='topic+uni_idx'></span>

<h3>Description</h3>

<p>Unique id from named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uni_idx(x, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uni_idx_+3A_x">x</code></td>
<td>
<p>a named list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with unique ids.
</p>

<hr>
<h2 id='which_class'>Find maximum value</h2><span id='topic+which_class'></span>

<h3>Description</h3>

<p>Find maximum value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_class(x, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_class_+3A_x">x</code></td>
<td>
<p>numerical, the log-probabilities.</p>
</td></tr>
<tr><td><code id="which_class_+3A_levels">levels</code></td>
<td>
<p>the levels to be returned same length as x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>factor.
</p>

<hr>
<h2 id='write_tikz'>Export the staged tree or CEG graph to tikz</h2><span id='topic+write_tikz'></span><span id='topic+write_tikz.sevt'></span>

<h3>Description</h3>

<p>Generate tikz code to draw the staged tree or CEG graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_tikz(
  x,
  layout = NULL,
  file = "",
  col = NULL,
  ignore = x$name_unobserved,
  node_label = function(node) {
     ifelse(is.na(node$stage), "", node$stage)
 },
  edge_label = function(edge) {
     ifelse(is.na(edge$label), "", edge$label)
 },
  edge_label_options = function(edge) {
     return("sloped")
 },
  scale = 10,
  normalize_layout = TRUE,
  node_shape = "circle",
  node_inner_sep = "1mm",
  node_minimum_size = "0.3cm",
  node_draw_color = "black",
  node_thickness = "very thick",
  node_text_color = "black"
)

## S3 method for class 'sevt'
write_tikz(
  x,
  layout = NULL,
  file = "",
  col = NULL,
  ignore = x$name_unobserved,
  node_label = function(node) {
     ifelse(is.na(node$stage), "", node$stage)
 },
  edge_label = function(edge) {
     ifelse(is.na(edge$label), "", edge$label)
 },
  edge_label_options = function(edge) {
     return("sloped")
 },
  scale = 10,
  normalize_layout = TRUE,
  node_shape = "circle",
  node_inner_sep = "1mm",
  node_minimum_size = "0.3cm",
  node_draw_color = "black",
  node_thickness = "very thick",
  node_text_color = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_tikz_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+sevt">sevt</a></code> or <code><a href="#topic+ceg">ceg</a></code>.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_layout">layout</code></td>
<td>
<p>the layout of the graph, given as matrix with two columns
and as many rows as nodes in the staged tree.
By default, a modified sugiyama layout is used.
The layout matrix can be obtained with <span class="pkg">igraph</span>
layout functions.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_file">file</code></td>
<td>
<p>A connection or a character string naming the file to print to.
Passed to <code><a href="base.html#topic+cat">cat</a></code>.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_col">col</code></td>
<td>
<p>color specifications for the stages of the staged even tree.
Same as <code><a href="#topic+plot.sevt">plot.sevt</a></code> and <code><a href="#topic+make_stages_col">make_stages_col</a></code>.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_ignore">ignore</code></td>
<td>
<p>vector of stages which will be ignored and not plotted,
by default the name of the unobserved stages stored in <code>x$name_unobserved</code>.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_label">node_label</code></td>
<td>
<p>a function that produces nodes labels.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_edge_label">edge_label</code></td>
<td>
<p>a function that produces edge labels.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_edge_label_options">edge_label_options</code></td>
<td>
<p>a function that produces edge label options.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_scale">scale</code></td>
<td>
<p>for the tikzfigure.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_normalize_layout">normalize_layout</code></td>
<td>
<p>a logical value. If <code>TRUE</code>
layout positions are scaled to the <code>[0,1]</code> interval.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_shape">node_shape</code></td>
<td>
<p>the shape to be used for nodes.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_inner_sep">node_inner_sep</code></td>
<td>
<p>the <code>inner sep</code> parameter.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_minimum_size">node_minimum_size</code></td>
<td>
<p>the <code>minimum size</code> parameter for the nodes.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_draw_color">node_draw_color</code></td>
<td>
<p>the color for line drawing the nodes.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_thickness">node_thickness</code></td>
<td>
<p>the thickness of the lines.</p>
</td></tr>
<tr><td><code id="write_tikz_+3A_node_text_color">node_text_color</code></td>
<td>
<p>the color for label in nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to create a working
tikz code that compile to a graph similar to the
one obtained by <code>plot.sevt(x, ...)</code> or
<code>plot.ceg(x, ...)</code>.
</p>


<h3>References</h3>

<p>Code partially inspired by the code in
<em>Exporting graphs to LaTeX, using igraph and TikZ</em>
<a href="http://igraph.wikidot.com/r-recipes#toc2">http://igraph.wikidot.com/r-recipes#toc2</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
