<!DOCTYPE html><html lang="en"><head><title>Help for package metasnf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metasnf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#metasnf-package'><p>metasnf: Meta Clustering with Similarity Network Fusion</p></a></li>
<li><a href='#abcd_anxiety'><p>Mock ABCD anxiety data</p></a></li>
<li><a href='#abcd_colour'><p>Mock ABCD &quot;colour&quot; data</p></a></li>
<li><a href='#abcd_cort_sa'><p>Mock ABCD cortical surface area data</p></a></li>
<li><a href='#abcd_cort_t'><p>Mock ABCD cortical thickness data</p></a></li>
<li><a href='#abcd_depress'><p>Mock ABCD depression data</p></a></li>
<li><a href='#abcd_h_income'><p>Mock ABCD income data</p></a></li>
<li><a href='#abcd_income'><p>Mock ABCD income data</p></a></li>
<li><a href='#abcd_pubertal'><p>Mock ABCD pubertal status data</p></a></li>
<li><a href='#abcd_subc_v'><p>Mock ABCD subcortical volumes data</p></a></li>
<li><a href='#add_columns'><p>Add columns to a data frame</p></a></li>
<li><a href='#add_settings_df_rows'><p>Add rows to a settings_df</p></a></li>
<li><a href='#adjusted_rand_index_heatmap'><p>Heatmap of pairwise adjusted rand indices between solutions</p></a></li>
<li><a href='#age_df'><p>Mock age data</p></a></li>
<li><a href='#alluvial_cluster_plot'><p>Alluvial plot of patients across cluster counts and important features</p></a></li>
<li><a href='#anxiety'><p>Mock ABCD anxiety data</p></a></li>
<li><a href='#arrange'><p>Arrange rows in an object</p></a></li>
<li><a href='#arrange_dll'><p>Sort data frames in a data list by their unique ID values.</p></a></li>
<li><a href='#as_ari_matrix'><p>Convert an object to an ARI matrix</p></a></li>
<li><a href='#as_data_list'><p>Convert an object to a data list</p></a></li>
<li><a href='#as_settings_df'><p>Convert an object to a settings data frame</p></a></li>
<li><a href='#as_sim_mats_list'><p>Convert an object to a similarity matrix list</p></a></li>
<li><a href='#as_snf_config'><p>Convert an object to a snf config</p></a></li>
<li><a href='#as_weights_matrix'><p>Convert an object to a weights matrix</p></a></li>
<li><a href='#as.data.frame.data_list'><p>Coerce a <code>data_list</code> class object into a <code>data.frame</code> class object</p></a></li>
<li><a href='#as.data.frame.ext_solutions_df'><p>Coerce a <code>ext_solutions_df</code> class object into a <code>data.frame</code> class object</p></a></li>
<li><a href='#as.data.frame.solutions_df'><p>Coerce a <code>solutions_df</code> class object into a <code>data.frame</code> class object</p></a></li>
<li><a href='#assemble_data'><p>Collapse a data frame and/or a data list into a single data frame</p></a></li>
<li><a href='#assoc_pval_heatmap'><p>Heatmap of pairwise associations between features</p></a></li>
<li><a href='#auto_plot'><p>Automatically plot features across clusters</p></a></li>
<li><a href='#bar_plot'><p>Bar plot separating a feature by cluster</p></a></li>
<li><a href='#batch_row_closure'><p>Generate closure function to run batch_snf in an apply-friendly format</p></a></li>
<li><a href='#batch_snf'><p>Run variations of SNF.</p></a></li>
<li><a href='#batch_snf_subsamples'><p>Run SNF clustering pipeline on a list of subsampled data lists.</p></a></li>
<li><a href='#calc_aris'><p>Construct an ARI matrix storing inter-solution similarities</p></a></li>
<li><a href='#calc_assoc_pval'><p>Calculate p-values based on feature vectors and their types</p></a></li>
<li><a href='#calc_assoc_pval_matrix'><p>Calculate p-values for all pairwise associations of features in a data list</p></a></li>
<li><a href='#calc_nmis'><p>Calculate feature NMIs for a data list and a solutions data frame</p></a></li>
<li><a href='#calculate_coclustering'><p>Calculate coclustering data.</p></a></li>
<li><a href='#cancer_diagnosis_df'><p>Mock diagnosis data</p></a></li>
<li><a href='#cat_colours'><p>Helper function for generating categorical colour palette</p></a></li>
<li><a href='#cell_significance_fn'><p>Place significance stars on ComplexHeatmap cells.</p></a></li>
<li><a href='#char_to_fac'><p>Convert character-type columns of a data frame to factor-type</p></a></li>
<li><a href='#check_cfll_fn_args'><p>Check if functions in a distance metrics list-like have valid arguments</p></a></li>
<li><a href='#check_cfll_fns'><p>Check if items of a clustering functions list-like object are functions</p></a></li>
<li><a href='#check_cfll_named'><p>Check if clustering functions list-like object has named algorithms</p></a></li>
<li><a href='#check_cfll_unique_names'><p>Check if names in a clustering functions list-like object are unique</p></a></li>
<li><a href='#check_compatible_sdf_cfl'><p>Check if settings_df exceeds bounds of clust_fns_list</p></a></li>
<li><a href='#check_compatible_sdf_dfl'><p>Check if settings_df exceeds bounds of dist_fns_list</p></a></li>
<li><a href='#check_compatible_sdf_wm'><p>Check if settings_df and weights_matrix have same number of rows</p></a></li>
<li><a href='#check_dataless_annotations'><p>Helper function to stop annotation building when no data was provided</p></a></li>
<li><a href='#check_dfll_fn_args'><p>Check if functions in a distance metrics list-like have valid arguments</p></a></li>
<li><a href='#check_dfll_fn_names'><p>Check if functions in a distance metrics list-like have names</p></a></li>
<li><a href='#check_dfll_item_names'><p>Check if items of a distance metrics list-like object have valid names</p></a></li>
<li><a href='#check_dfll_subitems_are_fns'><p>Check if subitems of a distance metrics list-like object are functions</p></a></li>
<li><a href='#check_dfll_unique_names'><p>Check if names in a distance metrics list-like object are unique</p></a></li>
<li><a href='#check_dll_duplicate_components'><p>Check if data list contains any duplicate names</p></a></li>
<li><a href='#check_dll_duplicate_features'><p>Check if data list contains any duplicate features</p></a></li>
<li><a href='#check_dll_empty_input'><p>Error if empty input provided during data list initalization</p></a></li>
<li><a href='#check_dll_four_subitems'><p>Error if data list-like list doesn't have only 4-item nested lists</p></a></li>
<li><a href='#check_dll_inherits_list'><p>Error if data list-like structure isn't a list</p></a></li>
<li><a href='#check_dll_subitem_classes'><p>Check if UID columns in a nested list have valid structure for a data list</p></a></li>
<li><a href='#check_dll_subitem_names'><p>Check valid subitem names for a data list-like list</p></a></li>
<li><a href='#check_dll_types'><p>Error if data list-like structure has invalid feature types</p></a></li>
<li><a href='#check_dll_uid'><p>Check if UID columns in a nested list have valid structure for a data list</p></a></li>
<li><a href='#check_hm_dependencies'><p>Check for ComplexHeatmap and circlize dependencies</p></a></li>
<li><a href='#check_sdfl_colnames'><p>Check if settings data frame inherits class <code>data.frame</code></p></a></li>
<li><a href='#check_sdfl_is_df'><p>Check if settings data frame inherits class <code>data.frame</code></p></a></li>
<li><a href='#check_sdfl_numeric'><p>Check if settings data frame is numeric</p></a></li>
<li><a href='#check_similarity_matrices'><p>Check validity of similarity matrices</p></a></li>
<li><a href='#check_valid_k'><p>Check if max K exceeds the number of observations</p></a></li>
<li><a href='#check_valid_sc'><p>Check if SNF config has valid structure</p></a></li>
<li><a href='#chi_squared_pval'><p>Chi-squared test p-value (generic)</p></a></li>
<li><a href='#clust_fns'><p>Built-in clustering algorithms</p></a></li>
<li><a href='#clust_fns_list'><p>Build a clusteing algorithms list</p></a></li>
<li><a href='#cocluster_density'><p>Density plot coclustering stability across subsampled data.</p></a></li>
<li><a href='#cocluster_heatmap'><p>Heatmap of observation co-clustering across resampled data.</p></a></li>
<li><a href='#coclustering_coverage_check'><p>Coclustering coverage check</p></a></li>
<li><a href='#collapse_dl'><p>Convert a data list into a data frame</p></a></li>
<li><a href='#colour_scale'><p>Return a colour ramp for a given vector</p></a></li>
<li><a href='#config_heatmap'><p>Heatmap for visualizing an SNF config</p></a></li>
<li><a href='#convert_uids'><p>Convert unique identifiers of data list to &quot;uid&quot;</p></a></li>
<li><a href='#cort_sa'><p>Mock ABCD cortical surface area data</p></a></li>
<li><a href='#cort_t'><p>Mock ABCD cortical thickness data</p></a></li>
<li><a href='#data_list'><p>Build a <code>data_list</code> class object</p></a></li>
<li><a href='#depress'><p>Mock ABCD depression data</p></a></li>
<li><a href='#diagnosis_df'><p>Mock diagnosis data</p></a></li>
<li><a href='#discretisation'><p>Internal function for <code>estimate_nclust_given_graph</code></p></a></li>
<li><a href='#discretisation_evec_data'><p>Internal function for <code>estimate_nclust_given_graph</code></p></a></li>
<li><a href='#dist_fns'><p>Built-in distance functions</p></a></li>
<li><a href='#dist_fns_list'><p>Build a distance metrics list</p></a></li>
<li><a href='#dl_variable_summary'><p>Variable-level summary of a data list</p></a></li>
<li><a href='#dlapply'><p>Lapply-like function for data list objects</p></a></li>
<li><a href='#dll_uid_first_col'><p>Make the uid UID columns of a data list first</p></a></li>
<li><a href='#domains'><p>Pull domains from a data list</p></a></li>
<li><a href='#drop_cols'><p>Helper function to remove columns from a data frame</p></a></li>
<li><a href='#drop_inputs'><p>Execute inclusion</p></a></li>
<li><a href='#ensure_dll_df'><p>Ensure the data subitem of each component is a <code>data.frame</code> class object</p></a></li>
<li><a href='#esm_manhattan_plot'><p>Manhattan plot of feature-cluster association p-values</p></a></li>
<li><a href='#estimate_nclust_given_graph'><p>Estimate number of clusters for a similarity matrix</p></a></li>
<li><a href='#expression_df'><p>Modification of SNFtool mock data frame &quot;Data1&quot;</p></a></li>
<li><a href='#ext_solutions_df'><p>Constructor for <code>ext_solutions_df</code> class object.</p></a></li>
<li><a href='#extend_solutions'><p>Extend a solutions data frame to include outcome evaluations</p></a></li>
<li><a href='#fav_colour'><p>Mock ABCD &quot;colour&quot; data</p></a></li>
<li><a href='#features'><p>Return character vector of features stored in an object</p></a></li>
<li><a href='#fisher_exact_pval'><p>Fisher exact test p-value</p></a></li>
<li><a href='#gender_df'><p>Mock gender data</p></a></li>
<li><a href='#generate_annotations_list'><p>Generate annotations list</p></a></li>
<li><a href='#generate_clust_algs_list'><p>Generate a clustering algorithms list</p></a></li>
<li><a href='#generate_distance_metrics_list'><p>Generate a list of distance metrics</p></a></li>
<li><a href='#generate_settings_matrix'><p>Build a settings data frame</p></a></li>
<li><a href='#get_cluster_df'><p>Extract cluster membership information from one solutions data frame row</p></a></li>
<li><a href='#get_cluster_solutions'><p>Extract cluster membership information from a sol_df</p></a></li>
<li><a href='#get_clusters'><p>Extract cluster membership vector from one solutions data frame row</p></a></li>
<li><a href='#get_complete_uids'><p>Pull complete-data UIDs from a list of data frames</p></a></li>
<li><a href='#get_dist_matrix'><p>Calculate distance matrices</p></a></li>
<li><a href='#get_dl_uids'><p>Extract UIDs from a data list</p></a></li>
<li><a href='#get_heatmap_order'><p>Return the row or column ordering present in a heatmap</p></a></li>
<li><a href='#get_matrix_order'><p>Return the hierarchical clustering order of a matrix</p></a></li>
<li><a href='#get_mean_pval'><p>Get mean p-value</p></a></li>
<li><a href='#get_min_pval'><p>Get minimum p-value</p></a></li>
<li><a href='#get_pvals'><p>Get p-values from an extended solutions data frame</p></a></li>
<li><a href='#get_representative_solutions'><p>Extract representative solutions from a matrix of ARIs</p></a></li>
<li><a href='#gexclude'><p>Helper function to drop columns from a data frame by grepl search</p></a></li>
<li><a href='#gselect'><p>Helper function to pick columns from a data frame by grepl search</p></a></li>
<li><a href='#income'><p>Mock ABCD income data</p></a></li>
<li><a href='#is_data_list'><p>Test if the object is a data list</p></a></li>
<li><a href='#jitter_plot'><p>Jitter plot separating a feature by cluster</p></a></li>
<li><a href='#label_meta_clusters'><p>Assign meta cluster labels to rows of a solutions data frame or extended</p>
solutions data frame</a></li>
<li><a href='#label_prop'><p>Label propagation</p></a></li>
<li><a href='#label_propagate'><p>Label propagate cluster solutions to unclustered observations</p></a></li>
<li><a href='#label_splits'><p>Convert a vector of partition indices into meta cluster labels</p></a></li>
<li><a href='#linear_adjust'><p>Linearly correct data list by features with unwanted signal</p></a></li>
<li><a href='#linear_model_pval'><p>Linear model p-value (generic)</p></a></li>
<li><a href='#mc_manhattan_plot'><p>Manhattan plot of feature-meta cluster associaiton p-values</p></a></li>
<li><a href='#merge_df_list'><p>Merge list of data frames into a single data frame</p></a></li>
<li><a href='#merge_dls'><p>Horizontally merge compatible data lists</p></a></li>
<li><a href='#merge.snf_config'><p>Merge method for SNF config objects</p></a></li>
<li><a href='#meta_cluster_heatmap'><p>Heatmap of pairwise adjusted rand indices between solutions</p></a></li>
<li><a href='#metasnf_alert'><p>Helper function for raising alerts</p></a></li>
<li><a href='#metasnf_defunct'><p>Helper function for defunct function errors.</p></a></li>
<li><a href='#metasnf_deprecated'><p>Helper function for deprecated function warnings.</p></a></li>
<li><a href='#metasnf_error'><p>Helper function for raising errors.</p></a></li>
<li><a href='#metasnf_warning'><p>Helper function for raising warnings.</p></a></li>
<li><a href='#methylation_df'><p>Modification of SNFtool mock data frame &quot;Data2&quot;</p></a></li>
<li><a href='#n_features'><p>Extract number of features stored in an object</p></a></li>
<li><a href='#n_observations'><p>Extract number of observations stored in an object</p></a></li>
<li><a href='#new_ari_matrix'><p>Constructor for <code>ari_matrix</code> class object</p></a></li>
<li><a href='#new_clust_fns_list'><p>Constructor for <code>clust_fns_list</code> class object</p></a></li>
<li><a href='#new_data_list'><p>Constructor for <code>data_list</code> class object</p></a></li>
<li><a href='#new_dist_fns_list'><p>Constructor for <code>dist_fns_list</code> class object</p></a></li>
<li><a href='#new_ext_solutions_df'><p>Constructor for <code>ext_solutions_df</code> class object</p></a></li>
<li><a href='#new_settings_df'><p>Constructor for <code>settings_df</code> class object</p></a></li>
<li><a href='#new_sim_mats_list'><p>Constructor for <code>similarity_matrix_list</code> class object</p></a></li>
<li><a href='#new_snf_config'><p>Constructor for <code>snf_config</code> class object</p></a></li>
<li><a href='#new_solutions_df'><p>Constructor for <code>solutions_df</code> class object</p></a></li>
<li><a href='#new_weights_matrix'><p>Constructor for <code>weights_matrix</code> class object</p></a></li>
<li><a href='#not_shown_message'><p>Helper function for creating what hidden ft/obs/sols message.</p></a></li>
<li><a href='#numcol_to_numeric'><p>Convert columns of a data frame to numeric type (if possible)</p></a></li>
<li><a href='#ord_reg_pval'><p>Ordinal regression p-value</p></a></li>
<li><a href='#parallel_batch_snf'><p>Parallel processing form of batch_snf</p></a></li>
<li><a href='#pick_cols'><p>Helper function to pick columns from a data frame</p></a></li>
<li><a href='#prefix_dll_uid'><p>Add &quot;uid_&quot; prefix to all UID values in uid column</p></a></li>
<li><a href='#print_with_n_message'><p>Helper function for outputting tip on changing rows printed</p></a></li>
<li><a href='#print_with_t_message'><p>Helper function for transposing solutions_df message</p></a></li>
<li><a href='#print.ari_matrix'><p>Print method for class <code>ari_matrix</code></p></a></li>
<li><a href='#print.clust_fns_list'><p>Print method for class <code>clust_fns_list</code></p></a></li>
<li><a href='#print.data_list'><p>Print method for class <code>data_list</code></p></a></li>
<li><a href='#print.dist_fns_list'><p>Print method for class <code>dist_fns_list</code></p></a></li>
<li><a href='#print.ext_solutions_df'><p>Print method for class <code>ext_solutions_df</code></p></a></li>
<li><a href='#print.settings_df'><p>Print method for class <code>settings_df</code></p></a></li>
<li><a href='#print.snf_config'><p>Print method for class <code>snf_config</code></p></a></li>
<li><a href='#print.solutions_df'><p>Print method for class <code>weights_matrix</code></p></a></li>
<li><a href='#print.t_ext_solutions_df'><p>Print method for class <code>t_ext_solutions_df</code></p></a></li>
<li><a href='#print.t_solutions_df'><p>Print method for class <code>t_solutions_df</code></p></a></li>
<li><a href='#print.weights_matrix'><p>Print method for class <code>weights_matrix</code></p></a></li>
<li><a href='#pubertal'><p>Mock ABCD pubertal status data</p></a></li>
<li><a href='#pval_heatmap'><p>Heatmap of p-values</p></a></li>
<li><a href='#quality_measures'><p>Quality metrics</p></a></li>
<li><a href='#random_removal'><p>Generate random removal sequence</p></a></li>
<li><a href='#rbind.ext_solutions_df'><p>Row-binding of solutions data frame class objects.</p></a></li>
<li><a href='#rbind.solutions_df'><p>Row-binding of solutions data frame class objects.</p></a></li>
<li><a href='#remove_dll_incomplete'><p>Remove observations with incomplete data from a data list-like list object</p></a></li>
<li><a href='#rename_dl'><p>Rename features in a data list</p></a></li>
<li><a href='#reorder_dl_uids'><p>Reorder the uids in a data list</p></a></li>
<li><a href='#resample'><p>Helper resample function found in ?sample</p></a></li>
<li><a href='#run_snf'><p>Run SNF</p></a></li>
<li><a href='#save_heatmap'><p>Save a heatmap object to a file</p></a></li>
<li><a href='#scale_diagonals'><p>Adjust the diagonals of a matrix</p></a></li>
<li><a href='#settings_df'><p>Build a settings data frame</p></a></li>
<li><a href='#shiny_annotator'><p>Launch a shiny app to identify meta cluster boundaries</p></a></li>
<li><a href='#sim_mats_list'><p>Create or extract a <code>sim_mats_list</code> class object</p></a></li>
<li><a href='#similarity_matrix_heatmap'><p>Plot heatmap of similarity matrix</p></a></li>
<li><a href='#similarity_matrix_path'><p>Generate a complete path and filename to store an similarity matrix</p></a></li>
<li><a href='#siw_euclidean_distance'><p>Squared (including weights) Euclidean distance</p></a></li>
<li><a href='#snf_config'><p>Define configuration for generating a set of SNF-based cluster solutions</p></a></li>
<li><a href='#snf_scheme'><p>SNF schemes</p></a></li>
<li><a href='#snf_step'><p>Helper function for using the correct SNF scheme</p></a></li>
<li><a href='#sol_df_col_order'><p>Helper function for organizing solutions df-like column order</p></a></li>
<li><a href='#solutions_df'><p>Constructor for <code>solutions_df</code> class object</p></a></li>
<li><a href='#split_parser'><p>Helper function to determine which row and columns to split on</p></a></li>
<li><a href='#subc_v'><p>Mock ABCD subcortical volumes data</p></a></li>
<li><a href='#subsample_dl'><p>Create subsamples of a data list</p></a></li>
<li><a href='#subsample_pairwise_aris'><p>Calculate pairwise adjusted Rand indices across subsamples of data</p></a></li>
<li><a href='#summarize_clust_fns_list'><p>Summarize a clust_fns_list object</p></a></li>
<li><a href='#summarize_dfl'><p>Summarize metrics contained in a dist_fns_list</p></a></li>
<li><a href='#summarize_dl'><p>Summarize a data list</p></a></li>
<li><a href='#summarize_pvals'><p>Summarize p-value columns of an extended solutions data frame</p></a></li>
<li><a href='#summary_features'><p>Pull features used to calculate summary p-values from an object</p></a></li>
<li><a href='#summary.data_list'><p>Summary method for class <code>data_list</code></p></a></li>
<li><a href='#train_test_assign'><p>Training and testing split</p></a></li>
<li><a href='#uids'><p>Pull UIDs from an object</p></a></li>
<li><a href='#validate_ari_matrix'><p>Validator for <code>ari_matrix</code> class object</p></a></li>
<li><a href='#validate_clust_fns_list'><p>Validator for <code>clust_fns_list</code> class object</p></a></li>
<li><a href='#validate_data_list'><p>Validator for data_list class object</p></a></li>
<li><a href='#validate_dist_fns_list'><p>Validator for dist_fns_list class object</p></a></li>
<li><a href='#validate_ext_solutions_df'><p>Validator for <code>ext_solutions_df</code> class object</p></a></li>
<li><a href='#validate_settings_df'><p>Validator for <code>settings_df</code> class object</p></a></li>
<li><a href='#validate_sim_mats_list'><p>Validator for <code>similarity_matrix_list</code> class object</p></a></li>
<li><a href='#validate_snf_config'><p>Validator for snf_config class object</p></a></li>
<li><a href='#validate_solutions_df'><p>Validator for <code>solutions_df</code> class object</p></a></li>
<li><a href='#validate_weights_matrix'><p>Validator for <code>weights_matrix</code> class object</p></a></li>
<li><a href='#var_manhattan_plot'><p>Manhattan plot of feature-feature association p-values</p></a></li>
<li><a href='#weights_matrix'><p>Generate a matrix to store feature weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Meta Clustering with Similarity Network Fusion</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Framework to facilitate patient subtyping with similarity network fusion and meta clustering. The similarity network fusion (SNF) algorithm was introduced by Wang et al. (2014) in &lt;<a href="https://doi.org/10.1038%2Fnmeth.2810">doi:10.1038/nmeth.2810</a>&gt;. SNF is a data integration approach that can transform high-dimensional and diverse data types into a single similarity network suitable for clustering with minimal loss of information from each initial data source. The meta clustering approach was introduced by Caruana et al. (2006) in &lt;<a href="https://doi.org/10.1109%2FICDM.2006.103">doi:10.1109/ICDM.2006.103</a>&gt;. Meta clustering involves generating a wide range of cluster solutions by adjusting clustering hyperparameters, then clustering the solutions themselves into a manageable number of qualitatively similar solutions, and finally characterizing representative solutions to find ones that are best for the user's specific context. This package provides a framework to easily transform multi-modal data into a wide range of similarity network fusion-derived cluster solutions as well as to visualize, characterize, and validate those solutions. Core package functionality includes easy customization of distance metrics, clustering algorithms, and SNF hyperparameters to generate diverse clustering solutions; calculation and plotting of associations between features, between patients, and between cluster solutions; and standard cluster validation approaches including resampled measures of cluster stability, standard metrics of cluster quality, and label propagation to evaluate generalizability in unseen data. Associated vignettes guide the user through using the package to identify patient subtypes while adhering to best practices for unsupervised learning.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, cluster, data.table, digest, dplyr, ggplot2, grDevices,
MASS, mclust, methods, progressr, purrr, RColorBrewer, rlang,
SNFtool, stats, tibble, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>circlize, ComplexHeatmap, InteractiveComplexHeatmap, clv,
future, future.apply, knitr, rmarkdown, testthat (&ge; 3.0.0),
ggalluvial, lifecycle, dbscan</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://branchlab.github.io/metasnf/">https://branchlab.github.io/metasnf/</a>,
<a href="https://github.com/BRANCHlab/metasnf/">https://github.com/BRANCHlab/metasnf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BRANCHlab/metasnf/issues">https://github.com/BRANCHlab/metasnf/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 20:10:05 UTC; prashanth</td>
</tr>
<tr>
<td>Author:</td>
<td>Prashanth S Velayudhan [aut, cre],
  Xiaoqiao Xu [aut],
  Prajkta Kallurkar [aut],
  Ana Patricia Balbon [aut],
  Maria T Secara [aut],
  Adam Taback [aut],
  Denise Sabac [aut],
  Nicholas Chan [aut],
  Shihao Ma [aut],
  Bo Wang [aut],
  Daniel Felsky [aut],
  Stephanie H Ameis [aut],
  Brian Cox [aut],
  Colin Hawco [aut],
  Lauren Erdman [aut],
  Anne L Wheeler [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Prashanth S Velayudhan &lt;psvelayu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='metasnf-package'>metasnf: Meta Clustering with Similarity Network Fusion</h2><span id='topic+metasnf'></span><span id='topic+metasnf-package'></span>

<h3>Description</h3>

<p>Framework to facilitate patient subtyping with similarity network fusion and meta clustering. The similarity network fusion (SNF) algorithm was introduced by Wang et al. (2014) in <a href="https://doi.org/10.1038/nmeth.2810">doi:10.1038/nmeth.2810</a>. SNF is a data integration approach that can transform high-dimensional and diverse data types into a single similarity network suitable for clustering with minimal loss of information from each initial data source. The meta clustering approach was introduced by Caruana et al. (2006) in <a href="https://doi.org/10.1109/ICDM.2006.103">doi:10.1109/ICDM.2006.103</a>. Meta clustering involves generating a wide range of cluster solutions by adjusting clustering hyperparameters, then clustering the solutions themselves into a manageable number of qualitatively similar solutions, and finally characterizing representative solutions to find ones that are best for the user's specific context. This package provides a framework to easily transform multi-modal data into a wide range of similarity network fusion-derived cluster solutions as well as to visualize, characterize, and validate those solutions. Core package functionality includes easy customization of distance metrics, clustering algorithms, and SNF hyperparameters to generate diverse clustering solutions; calculation and plotting of associations between features, between patients, and between cluster solutions; and standard cluster validation approaches including resampled measures of cluster stability, standard metrics of cluster quality, and label propagation to evaluate generalizability in unseen data. Associated vignettes guide the user through using the package to identify patient subtypes while adhering to best practices for unsupervised learning.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Prashanth S Velayudhan <a href="mailto:psvelayu@gmail.com">psvelayu@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Xiaoqiao Xu
</p>
</li>
<li><p> Prajkta Kallurkar
</p>
</li>
<li><p> Ana Patricia Balbon
</p>
</li>
<li><p> Maria T Secara
</p>
</li>
<li><p> Adam Taback
</p>
</li>
<li><p> Denise Sabac
</p>
</li>
<li><p> Nicholas Chan
</p>
</li>
<li><p> Shihao Ma
</p>
</li>
<li><p> Bo Wang
</p>
</li>
<li><p> Daniel Felsky
</p>
</li>
<li><p> Stephanie H Ameis
</p>
</li>
<li><p> Brian Cox
</p>
</li>
<li><p> Colin Hawco
</p>
</li>
<li><p> Lauren Erdman
</p>
</li>
<li><p> Anne L Wheeler <a href="mailto:anne.wheeler@sickkids.ca">anne.wheeler@sickkids.ca</a> [thesis advisor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://branchlab.github.io/metasnf/">https://branchlab.github.io/metasnf/</a>
</p>
</li>
<li> <p><a href="https://github.com/BRANCHlab/metasnf/">https://github.com/BRANCHlab/metasnf/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/BRANCHlab/metasnf/issues">https://github.com/BRANCHlab/metasnf/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abcd_anxiety'>Mock ABCD anxiety data</h2><span id='topic+abcd_anxiety'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of anxiety data from the NIMH Data
archive. The original file used was pdem02.txt. The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_cbcl_anxiety</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_anxiety
</code></pre>


<h3>Format</h3>



<h4><code>abcd_anxiety</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>cbcl_anxiety_r</dt><dd><p>Ordinal value of impairment on CBCL anxiety, either 0 (no impairment), 1 (borderline clinical), or 2 (clinically impaired)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_colour'>Mock ABCD &quot;colour&quot; data</h2><span id='topic+abcd_colour'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of depression data from the NIMH
Data archive. The original file used was pdem02.txt. The file was
pre-processed by the abcdutils package
(https://github.com/BRANCHlab/abcdutils) function <code>get_cbcl_depress</code>.
The data was transformed into categorical colour values to demonstrate
the Chi-squared test capabilities of <code>extend_solutions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_colour
</code></pre>


<h3>Format</h3>



<h4><code>abcd_colour</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>colour</dt><dd><p>Categorical transformation of <code>cbcl_depress</code>.</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_cort_sa'>Mock ABCD cortical surface area data</h2><span id='topic+abcd_cort_sa'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of cortical surface area data from the NIMH Data
archive. The original file used was mrisdp10201.txt The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_cort_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_cort_sa
</code></pre>


<h3>Format</h3>



<h4><code>abcd_cort_sa</code></h4>

<p>A data frame with 188 rows and 152 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Cortical surface areas of various ROIs (mm^2, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_cort_t'>Mock ABCD cortical thickness data</h2><span id='topic+abcd_cort_t'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of cortical thickness data from the NIMH Data
archive. The original file used was mrisdp10201.txt The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_cort_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_cort_t
</code></pre>


<h3>Format</h3>



<h4><code>abcd_cort_t</code></h4>

<p>A data frame with 188 rows and 152 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Cortical thicknesses of various ROIs (mm^3, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_depress'>Mock ABCD depression data</h2><span id='topic+abcd_depress'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of depression data from the NIMH
Data archive. The original file used was pdem02.txt. The file was
pre-processed by the abcdutils package
(https://github.com/BRANCHlab/abcdutils) function <code>get_cbcl_depress</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_depress
</code></pre>


<h3>Format</h3>



<h4><code>abcd_depress</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>cbcl_depress_r</dt><dd><p>Ordinal value of impairment on CBCL anxiety, either 0 (no impairment), 1 (borderline clinical), or 2 (clinically impaired)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_h_income'>Mock ABCD income data</h2><span id='topic+abcd_h_income'></span>

<h3>Description</h3>

<p>Like abcd_income, but with no NAs in patient column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_h_income
</code></pre>


<h3>Format</h3>



<h4><code>abcd_income</code></h4>

<p>A data frame with 300 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>household_income</dt><dd><p>Household income in 3 category levels (low = 1, medium = 2, high = 3)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_income'>Mock ABCD income data</h2><span id='topic+abcd_income'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of income data from the NIMH Data
archive. The original file used was pdem02.txt The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_income</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_income
</code></pre>


<h3>Format</h3>



<h4><code>abcd_income</code></h4>

<p>A data frame with 300 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>household_income</dt><dd><p>Household income in 3 category levels (low = 1, medium = 2, high = 3)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_pubertal'>Mock ABCD pubertal status data</h2><span id='topic+abcd_pubertal'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of pubertal status data from the NIMH Data
archive. The original files used were abcd_ssphp01.txt and abcd_ssphy01.txt. The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_pubertal_status</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_pubertal
</code></pre>


<h3>Format</h3>



<h4><code>abcd_pubertal</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>pubertal_status</dt><dd><p>Average reported pubertal status between child and parent (1-5 categorical scale)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='abcd_subc_v'>Mock ABCD subcortical volumes data</h2><span id='topic+abcd_subc_v'></span>

<h3>Description</h3>

<p>A randomly shuffled and anonymized copy of subcortical volume data from the NIMH Data
archive. The original file used was smrip10201.txt The file was pre-processed
by the abcdutils package (https://github.com/BRANCHlab/abcdutils) function
<code>get_subc_v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcd_subc_v
</code></pre>


<h3>Format</h3>



<h4><code>abcd_subc_v</code></h4>

<p>A data frame with 174 rows and 31 columns:
</p>

<dl>
<dt>patient</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Subcortical volumes of various ROIs (mm^3, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='add_columns'>Add columns to a data frame</h2><span id='topic+add_columns'></span>

<h3>Description</h3>

<p>Add new columns to a data frame by specifying their names and a value to
initialize them with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_columns(df, cols, value = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_columns_+3A_df">df</code></td>
<td>
<p>The data frame to extend.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_cols">cols</code></td>
<td>
<p>The vector containing new column names.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_value">value</code></td>
<td>
<p>The values stored in the newly added columns. NA by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing with the same columns as the <code>df</code> argument
as well as the new columns specified in the <code>cols</code> argument.
</p>

<hr>
<h2 id='add_settings_df_rows'>Add rows to a settings_df</h2><span id='topic+add_settings_df_rows'></span>

<h3>Description</h3>

<p>Add rows to a settings_df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_settings_df_rows(
  sdf,
  n_solutions = 0,
  min_removed_inputs = 0,
  max_removed_inputs = sum(startsWith(colnames(sdf), "inc_")) - 1,
  dropout_dist = "exponential",
  min_alpha = NULL,
  max_alpha = NULL,
  min_k = NULL,
  max_k = NULL,
  min_t = NULL,
  max_t = NULL,
  alpha_values = NULL,
  k_values = NULL,
  t_values = NULL,
  possible_snf_schemes = c(1, 2, 3),
  clustering_algorithms = NULL,
  continuous_distances = NULL,
  discrete_distances = NULL,
  ordinal_distances = NULL,
  categorical_distances = NULL,
  mixed_distances = NULL,
  dfl = NULL,
  snf_input_weights = NULL,
  snf_domain_weights = NULL,
  retry_limit = 10,
  allow_duplicates = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_settings_df_rows_+3A_sdf">sdf</code></td>
<td>
<p>The existing settings data frame</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_n_solutions">n_solutions</code></td>
<td>
<p>Number of rows to generate for the settings data frame.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_min_removed_inputs">min_removed_inputs</code></td>
<td>
<p>The smallest number of input data frames that may be
randomly removed. By default, 0.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_max_removed_inputs">max_removed_inputs</code></td>
<td>
<p>The largest number of input data frames that may be
randomly removed. By default, this is 1 less than all the provided input
data frames in the data list.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_dropout_dist">dropout_dist</code></td>
<td>
<p>Parameter controlling how the random removal of input
data frames should occur. Can be &quot;none&quot; (no input data frames are randomly
removed), &quot;uniform&quot; (uniformly sample between min_removed_inputs and
max_removed_inputs to determine number of input data frames to remove), or
&quot;exponential&quot; (pick number of input data frames to remove by sampling from
min_removed_inputs to max_removed_inputs with an exponential distribution;
the default).</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_min_alpha">min_alpha</code></td>
<td>
<p>The minimum value that the alpha hyperparameter can have.
Random assigned value of alpha for each row will be obtained by uniformly
sampling numbers between <code>min_alpha</code> and <code>max_alpha</code> at intervals of 0.1.
Cannot be used in conjunction with the <code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_max_alpha">max_alpha</code></td>
<td>
<p>The maximum value that the alpha hyperparameter can have.
See <code>min_alpha</code> parameter. Cannot be used in conjunction with the
<code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_min_k">min_k</code></td>
<td>
<p>The minimum value that the k hyperparameter can have.
Random assigned value of k for each row will be obtained by uniformly
sampling numbers between <code>min_k</code> and <code>max_k</code> at intervals of 1.
Cannot be used in conjunction with the <code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_max_k">max_k</code></td>
<td>
<p>The maximum value that the k hyperparameter can have.
See <code>min_k</code> parameter. Cannot be used in conjunction with the
<code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_min_t">min_t</code></td>
<td>
<p>The minimum value that the t hyperparameter can have.
Random assigned value of t for each row will be obtained by uniformly
sampling numbers between <code>min_t</code> and <code>max_t</code> at intervals of 1.
Cannot be used in conjunction with the <code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_max_t">max_t</code></td>
<td>
<p>The maximum value that the t hyperparameter can have.
See <code>min_t</code> parameter. Cannot be used in conjunction with the
<code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_alpha_values">alpha_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that alpha can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_alpha</code> or <code>max_alpha</code>
parameters.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_k_values">k_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that k can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_k</code> or <code>max_k</code>
parameters.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_t_values">t_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that t can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_t</code> or <code>max_t</code>
parameters.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_possible_snf_schemes">possible_snf_schemes</code></td>
<td>
<p>A vector containing the possible snf_schemes to
uniformly randomly select from. By default, the vector contains all
3 possible schemes: c(1, 2, 3). 1 corresponds to the &quot;individual&quot; scheme,
2 corresponds to the &quot;domain&quot; scheme, and 3 corresponds to the &quot;twostep&quot;
scheme.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_clustering_algorithms">clustering_algorithms</code></td>
<td>
<p>A list of clustering algorithms to uniformly
randomly pick from when clustering. When not specified, randomly select
between spectral clustering using the eigen-gap heuristic and spectral
clustering using the rotation cost heuristic. See ?clust_fns_list
for more details on running custom clustering algorithms.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_continuous_distances">continuous_distances</code></td>
<td>
<p>A vector of continuous distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_discrete_distances">discrete_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_ordinal_distances">ordinal_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_categorical_distances">categorical_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_mixed_distances">mixed_distances</code></td>
<td>
<p>A vector of mixed distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_dfl">dfl</code></td>
<td>
<p>List containing distance metrics to vary over.
See ?generate_dist_fns_list.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_snf_input_weights">snf_input_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge individual input measures (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_snf_domain_weights">snf_domain_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge domains (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_retry_limit">retry_limit</code></td>
<td>
<p>The maximum number of attempts to generate a novel row.
This function does not return matrices with identical rows. As the range of
requested possible settings tightens and the number of requested rows
increases, the risk of randomly generating a row that already exists
increases. If a new random row has matched an existing row <code>retry_limit</code>
number of times, the function will terminate.</p>
</td></tr>
<tr><td><code id="add_settings_df_rows_+3A_allow_duplicates">allow_duplicates</code></td>
<td>
<p>If TRUE, enables creation of a settings data frame
with duplicate non-feature weighting related hyperparameters. This function
should only be used when paired with a custom weights matrix that has
non-duplicate rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A settings data frame
</p>

<hr>
<h2 id='adjusted_rand_index_heatmap'>Heatmap of pairwise adjusted rand indices between solutions</h2><span id='topic+adjusted_rand_index_heatmap'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Defunct function to create an ARI heatmap. Please use
<code>meta_cluster_heatmap()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjusted_rand_index_heatmap(
  aris,
  order = NULL,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  log_graph = FALSE,
  scale_diag = "none",
  min_colour = "#282828",
  max_colour = "firebrick2",
  col = circlize::colorRamp2(c(min(aris), max(aris)), c(min_colour, max_colour)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjusted_rand_index_heatmap_+3A_aris">aris</code></td>
<td>
<p>Matrix of adjusted rand indices from <code>calc_aris()</code></p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_order">order</code></td>
<td>
<p>Numeric vector containing row order of the heatmap.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Whether rows should be clustered.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Whether columns should be clustered.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_log_graph">log_graph</code></td>
<td>
<p>If TRUE, log transforms the graph.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_scale_diag">scale_diag</code></td>
<td>
<p>Method of rescaling matrix diagonals. Can be &quot;none&quot;
(don't change diagonals), &quot;mean&quot; (replace diagonals with average value of
off-diagonals), or &quot;zero&quot; (replace diagonals with 0).</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_min_colour">min_colour</code></td>
<td>
<p>Colour used for the lowest value in the heatmap.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_max_colour">max_colour</code></td>
<td>
<p>Colour used for the highest value in the heatmap.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_col">col</code></td>
<td>
<p>Colour ramp to use for the heatmap.</p>
</td></tr>
<tr><td><code id="adjusted_rand_index_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>similarity_matrix_heatmap()</code>,
the function that this function wraps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the pairwise adjusted Rand indices (similarities) between
the cluster solutions of the provided solutions data frame.
</p>

<hr>
<h2 id='age_df'>Mock age data</h2><span id='topic+age_df'></span>

<h3>Description</h3>

<p>Mock age data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_df
</code></pre>


<h3>Format</h3>



<h4><code>age_df</code></h4>

<p>A data frame with 200 rows and 2 columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
<dt>age</dt><dd><p>Mock age feature</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='alluvial_cluster_plot'>Alluvial plot of patients across cluster counts and important features</h2><span id='topic+alluvial_cluster_plot'></span>

<h3>Description</h3>

<p>This alluvial plot shows how observations in a similarity matrix could
have been clustered over a set of clustering functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_cluster_plot(
  cluster_sequence,
  similarity_matrix,
  dl = NULL,
  data = NULL,
  key_outcome,
  key_label = key_outcome,
  extra_outcomes = NULL,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alluvial_cluster_plot_+3A_cluster_sequence">cluster_sequence</code></td>
<td>
<p>A list of clustering algorithms.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_similarity_matrix">similarity_matrix</code></td>
<td>
<p>A similarity matrix.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_dl">dl</code></td>
<td>
<p>A data list.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_data">data</code></td>
<td>
<p>A data frame that contains any features to include in the plot.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_key_outcome">key_outcome</code></td>
<td>
<p>The name of the feature that determines how each patient
stream is coloured in the alluvial plot.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_key_label">key_label</code></td>
<td>
<p>Name of key outcome to be used for the plot legend.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_extra_outcomes">extra_outcomes</code></td>
<td>
<p>Names of additional features to add to the plot.</p>
</td></tr>
<tr><td><code id="alluvial_cluster_plot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An alluvial plot (class &quot;gg&quot; and &quot;ggplot&quot;) showing distribution of
a feature across varying number cluster solutions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 1)

sol_df &lt;- batch_snf(input_dl, sc, return_sim_mats = TRUE)

sim_mats &lt;- sim_mats_list(sol_df)

clust_fn_sequence &lt;- list(spectral_two, spectral_four)

alluvial_cluster_plot(
    cluster_sequence = clust_fn_sequence,
    similarity_matrix = sim_mats[[1]],
    dl = input_dl,
    key_outcome = "gender", # the name of the feature of interest
    key_label = "Gender", # how the feature of interest should be displayed
    extra_outcomes = "diagnosis", # more features to plot but not colour by
    title = "Gender Across Cluster Counts"
)
</code></pre>

<hr>
<h2 id='anxiety'>Mock ABCD anxiety data</h2><span id='topic+anxiety'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_colour&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anxiety
</code></pre>


<h3>Format</h3>



<h4><code>anxiety</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>cbcl_anxiety_r</dt><dd><p>Ordinal value of impairment on CBCL anxiety, either 0 (no impairment), 1 (borderline clinical), or 2 (clinically impaired)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='arrange'>Arrange rows in an object</h2><span id='topic+arrange'></span>

<h3>Description</h3>

<p>Arrange rows in an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_.data">.data</code></td>
<td>
<p>The object to arrange columns from.</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>Additional arguments for arranging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with arrangeed columns.
</p>

<hr>
<h2 id='arrange_dll'>Sort data frames in a data list by their unique ID values.</h2><span id='topic+arrange_dll'></span>

<h3>Description</h3>

<p>Sort data frames in a data list by their unique ID values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_dll(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_dll_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>arranged_dl The data list-like object with all data frames sorted
by uid.
</p>

<hr>
<h2 id='as_ari_matrix'>Convert an object to an ARI matrix</h2><span id='topic+as_ari_matrix'></span>

<h3>Description</h3>

<p>This function coerces non-<code>ari_matrix</code> class objects into
<code>ari_matrix</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ari_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_ari_matrix_+3A_x">x</code></td>
<td>
<p>The object to convert into a weights matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ari_matrix</code> class object.
</p>

<hr>
<h2 id='as_data_list'>Convert an object to a data list</h2><span id='topic+as_data_list'></span>

<h3>Description</h3>

<p>This function coerces non-<code>data_list</code> class objects into <code>data_list</code> class
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_data_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_data_list_+3A_x">x</code></td>
<td>
<p>The object to convert into a data list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data_list</code> class object.
</p>

<hr>
<h2 id='as_settings_df'>Convert an object to a settings data frame</h2><span id='topic+as_settings_df'></span>

<h3>Description</h3>

<p>This function coerces non-<code>settings_df</code> class objects into <code>settings_df</code> class
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_settings_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_settings_df_+3A_x">x</code></td>
<td>
<p>The object to convert into a data list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>settings_df</code> class object.
</p>

<hr>
<h2 id='as_sim_mats_list'>Convert an object to a similarity matrix list</h2><span id='topic+as_sim_mats_list'></span>

<h3>Description</h3>

<p>This function converts non-<code>sim_mats_list</code> class objects into
<code>sim_mats_list</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sim_mats_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sim_mats_list_+3A_x">x</code></td>
<td>
<p>The object to convert into a <code>sim_mats_list</code>. Must be a list of
square matrices with identical column and row names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sim_mats_list</code> class object.
</p>

<hr>
<h2 id='as_snf_config'>Convert an object to a snf config</h2><span id='topic+as_snf_config'></span>

<h3>Description</h3>

<p>This function coerces non-<code>snf_config</code> class objects into <code>snf_config</code> class
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_snf_config(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_snf_config_+3A_x">x</code></td>
<td>
<p>The object to convert into a snf config.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>snf_config</code> class object.
</p>

<hr>
<h2 id='as_weights_matrix'>Convert an object to a weights matrix</h2><span id='topic+as_weights_matrix'></span>

<h3>Description</h3>

<p>This function converts non-<code>weights_matrix</code> objects into <code>weights_matrix</code>
class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_weights_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_weights_matrix_+3A_x">x</code></td>
<td>
<p>The object to convert into a data list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>weights_matrix</code> class object.
</p>

<hr>
<h2 id='as.data.frame.data_list'>Coerce a <code>data_list</code> class object into a <code>data.frame</code> class object</h2><span id='topic+as.data.frame.data_list'></span>

<h3>Description</h3>

<p>Horizontally joins data frames within a data list into a single data frame,
using the <code>uid</code> attribute as the joining key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_list'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.data_list_+3A_x">x</code></td>
<td>
<p>A <code>data_list</code> class object.</p>
</td></tr>
<tr><td><code id="as.data.frame.data_list_+3A_row.names">row.names</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.data_list_+3A_optional">optional</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.data_list_+3A_...">...</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dl_df A <code>data.frame</code> class object with all the features and
observations of <code>dl</code>.
</p>

<hr>
<h2 id='as.data.frame.ext_solutions_df'>Coerce a <code>ext_solutions_df</code> class object into a <code>data.frame</code> class object</h2><span id='topic+as.data.frame.ext_solutions_df'></span>

<h3>Description</h3>

<p>Coerce a <code>ext_solutions_df</code> class object into a <code>data.frame</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ext_solutions_df'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  keep_attributes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.ext_solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>ext_solutions_df</code> class object.</p>
</td></tr>
<tr><td><code id="as.data.frame.ext_solutions_df_+3A_row.names">row.names</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ext_solutions_df_+3A_optional">optional</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ext_solutions_df_+3A_keep_attributes">keep_attributes</code></td>
<td>
<p>If TRUE, resulting data frame includes settings
data frame and weights matrix.</p>
</td></tr>
<tr><td><code id="as.data.frame.ext_solutions_df_+3A_...">...</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> class object with all the columns of x and its
contained solutions data frame.
</p>

<hr>
<h2 id='as.data.frame.solutions_df'>Coerce a <code>solutions_df</code> class object into a <code>data.frame</code> class object</h2><span id='topic+as.data.frame.solutions_df'></span>

<h3>Description</h3>

<p>Coerce a <code>solutions_df</code> class object into a <code>data.frame</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solutions_df'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  keep_attributes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>solutions_df</code> class object.</p>
</td></tr>
<tr><td><code id="as.data.frame.solutions_df_+3A_row.names">row.names</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.solutions_df_+3A_optional">optional</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.solutions_df_+3A_keep_attributes">keep_attributes</code></td>
<td>
<p>If TRUE, resulting data frame includes settings
data frame and weights matrix.</p>
</td></tr>
<tr><td><code id="as.data.frame.solutions_df_+3A_...">...</code></td>
<td>
<p>Additional parameter passed to <code>as.data.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> class object with all the columns of x and its
contained solutions data frame.
</p>

<hr>
<h2 id='assemble_data'>Collapse a data frame and/or a data list into a single data frame</h2><span id='topic+assemble_data'></span>

<h3>Description</h3>

<p>Collapse a data frame and/or a data list into a single data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_data(data, dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assemble_data_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="assemble_data_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class &quot;data.frame&quot; object containing all the features of the
provided data frame and/or data list.
</p>

<hr>
<h2 id='assoc_pval_heatmap'>Heatmap of pairwise associations between features</h2><span id='topic+assoc_pval_heatmap'></span>

<h3>Description</h3>

<p>Heatmap of pairwise associations between features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assoc_pval_heatmap(
  correlation_matrix,
  scale_diag = "max",
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  show_heatmap_legend = FALSE,
  confounders = NULL,
  out_of_models = NULL,
  annotation_colours = NULL,
  labels_colour = NULL,
  split_by_domain = FALSE,
  dl = NULL,
  significance_stars = TRUE,
  slice_font_size = 8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assoc_pval_heatmap_+3A_correlation_matrix">correlation_matrix</code></td>
<td>
<p>Matrix containing all pairwise association
p-values. The recommended way to obtain this matrix is through the
calc_assoc_pval function.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_scale_diag">scale_diag</code></td>
<td>
<p>Parameter that controls how the diagonals of the
correlation_matrix are adjusted in the heatmap. For best viewing, this is
set to &quot;max&quot;, which will match the diagonals to whichever pairwise
association has the highest p-value.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap. Will be ignored
if split_by_domain is also provided.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap. Will be
ignored if split_by_domain is also provided.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_show_row_names">show_row_names</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_show_column_names">show_column_names</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_show_heatmap_legend">show_heatmap_legend</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_confounders">confounders</code></td>
<td>
<p>A named list where the elements are columns in the
correlation_matrix and the names are the corresponding display names.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_out_of_models">out_of_models</code></td>
<td>
<p>Like confounders, but a named list of out of model
measures (who are also present as columns in the correlation_matrix).</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_annotation_colours">annotation_colours</code></td>
<td>
<p>Named list of heatmap annotations and their
colours.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_labels_colour">labels_colour</code></td>
<td>
<p>Vector of colours to use for the columns and rows
of the heatmap.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_split_by_domain">split_by_domain</code></td>
<td>
<p>The results of <code>dl_var_summar</code> - a data frame that has
the domain of every feature in the plotted data.
columns of the correlation_matrix. Will be used to &quot;slice&quot; the heatmap into
visually separated sections.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_significance_stars">significance_stars</code></td>
<td>
<p>If TRUE (default), plots significance stars on
heatmap cells</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_slice_font_size">slice_font_size</code></td>
<td>
<p>Font size for domain separating labels.</p>
</td></tr>
<tr><td><code id="assoc_pval_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed into ComplexHeatmap::Heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the pairwise associations between features from the provided
correlation_matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data_list &lt;- data_list(
#    list(income, "household_income", "demographics", "ordinal"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    list(fav_colour, "favourite_colour", "demographics", "categorical"),
#    list(anxiety, "anxiety", "behaviour", "ordinal"),
#    list(depress, "depressed", "behaviour", "ordinal"),
#    uid = "unique_id"
#)
#
#assoc_pval_matrix &lt;- calc_assoc_pval_matrix(data_list)
#ap_heatmap &lt;- assoc_pval_heatmap(assoc_pval_matrix)
</code></pre>

<hr>
<h2 id='auto_plot'>Automatically plot features across clusters</h2><span id='topic+auto_plot'></span>

<h3>Description</h3>

<p>Given a single row of a solutions data frame and data provided through
a data list, this function will return a series of bar and/or
jitter plots based on feature types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_plot(
  sol_df_row = NULL,
  dl = NULL,
  cluster_df = NULL,
  return_plots = TRUE,
  save = NULL,
  jitter_width = 6,
  jitter_height = 6,
  bar_width = 6,
  bar_height = 6,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_plot_+3A_sol_df_row">sol_df_row</code></td>
<td>
<p>A single row of a solutions data frame.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_dl">dl</code></td>
<td>
<p>A data list containing data to plot.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_cluster_df">cluster_df</code></td>
<td>
<p>Directly provide a cluster_df rather than a solutions
matrix. Useful if plotting data from label propagated results.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_return_plots">return_plots</code></td>
<td>
<p>If <code>TRUE</code>, the function will return a list of plots.
If FALSE, the function will instead return the full data frame used for
plotting.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_save">save</code></td>
<td>
<p>If a string is provided, plots will be saved and this string
will be used to prefix plot names.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_jitter_width">jitter_width</code></td>
<td>
<p>Width of jitter plots if save is specified.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_jitter_height">jitter_height</code></td>
<td>
<p>Height of jitter plots if save is specified.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_bar_width">bar_width</code></td>
<td>
<p>Width of bar plots if save is specified.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_bar_height">bar_height</code></td>
<td>
<p>Height of bar plots if save is specified.</p>
</td></tr>
<tr><td><code id="auto_plot_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, returns a list of plots (class &quot;gg&quot;, &quot;ggplot&quot;) with
one plot for every feature in the provided data list and/or target list.
If <code>return_plots</code> is FALSE, will instead return a single &quot;data.frame&quot;
object containing every provided feature for every observation in long
format.
</p>

<hr>
<h2 id='bar_plot'>Bar plot separating a feature by cluster</h2><span id='topic+bar_plot'></span>

<h3>Description</h3>

<p>Bar plot separating a feature by cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bar_plot(df, feature)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bar_plot_+3A_df">df</code></td>
<td>
<p>A data.frame containing cluster column and the feature to plot.</p>
</td></tr>
<tr><td><code id="bar_plot_+3A_feature">feature</code></td>
<td>
<p>The feature to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot (class &quot;gg&quot;, &quot;ggplot&quot;) showing the distribution of a
feature across clusters.
</p>

<hr>
<h2 id='batch_row_closure'>Generate closure function to run batch_snf in an apply-friendly format</h2><span id='topic+batch_row_closure'></span>

<h3>Description</h3>

<p>Generate closure function to run batch_snf in an apply-friendly format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_row_closure(
  dl,
  dfl,
  cfl,
  sdf,
  wm,
  similarity_matrix_dir,
  return_sim_mats,
  prog
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_row_closure_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_dfl">dfl</code></td>
<td>
<p>An optional nested list containing which
distance metric function should be used for the various feature types
(continuous, discrete, ordinal, categorical, and mixed). See
?dist_fns_list for details on how to build this.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_cfl">cfl</code></td>
<td>
<p>List of custom clustering algorithms to apply
to the final fused network. See ?clust_fns_list.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_sdf">sdf</code></td>
<td>
<p>matrix indicating parameters to iterate SNF through.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_wm">wm</code></td>
<td>
<p>A matrix containing feature weights to use during
distance matrix calculation. See ?weights_matrix for details on
how to build this.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_similarity_matrix_dir">similarity_matrix_dir</code></td>
<td>
<p>If specified, this directory will be used to
save all generated similarity matrices.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_return_sim_mats">return_sim_mats</code></td>
<td>
<p>If TRUE, function will return a list where
the first element is the solutions data frame and the second element is a list
of similarity matrices for each row in the sol_df. Default FALSE.</p>
</td></tr>
<tr><td><code id="batch_row_closure_+3A_prog">prog</code></td>
<td>
<p>Progressr function to update parallel processing progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;function&quot; class object used to run <code>batch_snf</code> in lapply-form
for parallel processing.
</p>

<hr>
<h2 id='batch_snf'>Run variations of SNF.</h2><span id='topic+batch_snf'></span>

<h3>Description</h3>

<p>This is the core function of the <code>metasnf</code> package. Using the information
stored in a settings_df (see ?settings_df) and a data list
(see ?data_list), run repeated complete SNF pipelines to generate
a broad space of post-SNF cluster solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_snf(dl, sc, processes = 1, return_sim_mats = FALSE, sim_mats_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_snf_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="batch_snf_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> class object which stores all sets of
hyperparameters used to transform data in dl into a cluster solutions. See
<code>?settings_df</code> or
https://branchlab.github.io/metasnf/articles/settings_df.html for more
details.</p>
</td></tr>
<tr><td><code id="batch_snf_+3A_processes">processes</code></td>
<td>
<p>Specify number of processes used to complete SNF iterations
</p>

<ul>
<li> <p><code>1</code> (default) Sequential processing: function will iterate through the
<code>settings_df</code> one row at a time with a for loop. This option will
not make use of multiple CPU cores, but will show a progress bar.
</p>
</li>
<li> <p><code>2</code> or higher: Parallel processing will use the
<code>future.apply::future_apply</code> to distribute the SNF iterations across
the specified number of CPU cores. If higher than the number of
available cores, a warning will be raised and the maximum number of
cores will be used.
</p>
</li>
<li> <p><code>max</code>: All available cores will be used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="batch_snf_+3A_return_sim_mats">return_sim_mats</code></td>
<td>
<p>If TRUE, function will return a list where
the first element is the solutions data frame and the second element is a list
of similarity matrices for each row in the sol_df. Default FALSE.</p>
</td></tr>
<tr><td><code id="batch_snf_+3A_sim_mats_dir">sim_mats_dir</code></td>
<td>
<p>If specified, this directory will be used to
save all generated similarity matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, returns a solutions data frame (class &quot;data.frame&quot;), a
a data frame containing one row for every row of the provided settings
matrix, all the original columns of that settings data frame, and new columns
containing the assigned cluster of each observation from the cluster
solution derived by that row's settings. If <code>return_sim_mats</code> is
TRUE, the function will instead return a list containing the
solutions data frame as well as a list of the final similarity matrices (class
&quot;matrix&quot;) generated by SNF for each row of the settings data frame. If
<code>suppress_clustering</code> is TRUE, the solutions data frame will not be returned
in the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 3)

# A solutions data frame without similarity matrices:
sol_df &lt;- batch_snf(input_dl, sc)

# A solutions data frame with similarity matrices:
# sol_df &lt;- batch_snf(input_dl, sc, return_sim_mats = TRUE)
# sim_mats_list(sol_df)
</code></pre>

<hr>
<h2 id='batch_snf_subsamples'>Run SNF clustering pipeline on a list of subsampled data lists.</h2><span id='topic+batch_snf_subsamples'></span>

<h3>Description</h3>

<p>Run SNF clustering pipeline on a list of subsampled data lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_snf_subsamples(
  dl_subsamples,
  sc,
  processes = 1,
  return_sim_mats = FALSE,
  sim_mats_dir = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_snf_subsamples_+3A_dl_subsamples">dl_subsamples</code></td>
<td>
<p>A list of subsampled data lists. This object is
generated by the function <code>batch_snf_subsamples()</code>.</p>
</td></tr>
<tr><td><code id="batch_snf_subsamples_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> class object which stores all sets of
hyperparameters used to transform data in dl into a cluster solutions. See
<code>?settings_df</code> or
https://branchlab.github.io/metasnf/articles/settings_df.html for more
details.</p>
</td></tr>
<tr><td><code id="batch_snf_subsamples_+3A_processes">processes</code></td>
<td>
<p>Specify number of processes used to complete SNF iterations
</p>

<ul>
<li> <p><code>1</code> (default) Sequential processing: function will iterate through the
<code>settings_df</code> one row at a time with a for loop. This option will
not make use of multiple CPU cores, but will show a progress bar.
</p>
</li>
<li> <p><code>2</code> or higher: Parallel processing will use the
<code>future.apply::future_apply</code> to distribute the SNF iterations across
the specified number of CPU cores. If higher than the number of
available cores, a warning will be raised and the maximum number of
cores will be used.
</p>
</li>
<li> <p><code>max</code>: All available cores will be used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="batch_snf_subsamples_+3A_return_sim_mats">return_sim_mats</code></td>
<td>
<p>If TRUE, function will return a list where
the first element is the solutions data frame and the second element is a list
of similarity matrices for each row in the sol_df. Default FALSE.</p>
</td></tr>
<tr><td><code id="batch_snf_subsamples_+3A_sim_mats_dir">sim_mats_dir</code></td>
<td>
<p>If specified, this directory will be used to
save all generated similarity matrices.</p>
</td></tr>
<tr><td><code id="batch_snf_subsamples_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, returns a one-element list: <code>cluster_solutions</code>, which
is itself a list of cluster solution data frames corresponding to each of
the provided data list subsamples. Setting the parameters
<code>return_sim_mats</code>  and <code>return_solutions</code> to <code>TRUE</code>
will turn the result of the function to a three-element list containing the
corresponding solutions data frames and final fused similarity matrices of
those cluster solutions, should you require these objects for your own
stability calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results &lt;- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
</code></pre>

<hr>
<h2 id='calc_aris'>Construct an ARI matrix storing inter-solution similarities</h2><span id='topic+calc_aris'></span>

<h3>Description</h3>

<p>This function constructs an <code>ari_matrix</code> class object from a <code>solutions_df</code>
class object. The ARI matrix stores pairwise adjusted Rand indices for all
cluster solutions as well as a numeric order for the solutions data frame
based on the hierarchical clustering of the ARI matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_aris(
  sol_df,
  processes = 1,
  verbose = FALSE,
  dist_method = "euclidean",
  hclust_method = "complete"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_aris_+3A_sol_df">sol_df</code></td>
<td>
<p>Solutions data frame containing cluster solutions to calculate
pairwise ARIs for.</p>
</td></tr>
<tr><td><code id="calc_aris_+3A_processes">processes</code></td>
<td>
<p>Specify number of processes used to complete calculations
</p>

<ul>
<li> <p><code>1</code> (default) Sequential processing
</p>
</li>
<li> <p><code>2</code> or higher: Parallel processing will use the
<code>future.apply::future_apply</code> to distribute the calculations across
the specified number of CPU cores. If higher than the number of
available cores, a warning will be raised and the maximum number of
cores will be used.
</p>
</li>
<li> <p><code>max</code>: All available cores will be used.
Note that no progress indicator is available during multi-core processing.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_aris_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
<tr><td><code id="calc_aris_+3A_dist_method">dist_method</code></td>
<td>
<p>Distance method to use when calculating sorting order to
of the matrix. Argument is directly passed into stats::dist. Options
include &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, or
&quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="calc_aris_+3A_hclust_method">hclust_method</code></td>
<td>
<p>Agglomerative method to use when calculating sorting
order by <code>stats::hclust</code>. Options include &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, or &quot;centroid&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>om_aris ARIs between clustering solutions of an solutions data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dl &lt;- data_list(
    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    uid = "unique_id"
)

sc &lt;- snf_config(dl, n_solutions = 3)
sol_df &lt;- batch_snf(dl, sc)
calc_aris(sol_df)
</code></pre>

<hr>
<h2 id='calc_assoc_pval'>Calculate p-values based on feature vectors and their types</h2><span id='topic+calc_assoc_pval'></span>

<h3>Description</h3>

<p>Calculate p-values based on feature vectors and their types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_assoc_pval(var1, var2, type1, type2, cat_test = "chi_squared")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_assoc_pval_+3A_var1">var1</code></td>
<td>
<p>A single vector containing a feature.</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_+3A_var2">var2</code></td>
<td>
<p>A single vector containing a feature.</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_+3A_type1">type1</code></td>
<td>
<p>The type of var1 (continuous, discrete, ordinal, categorical).</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_+3A_type2">type2</code></td>
<td>
<p>The type of var2 (continuous, discrete, ordinal, categorical).</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_+3A_cat_test">cat_test</code></td>
<td>
<p>String indicating which statistical test will be used to
associate cluster with a categorical feature. Options are &quot;chi_squared&quot; for
the Chi-squared test and &quot;fisher_exact&quot; for Fisher's exact test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval A p-value from a statistical test based on the provided types.
Currently, this will either be the F-test p-value from a linear model
if at least one feature is non-categorical, or the chi-squared test
p-value if both features are categorical.
</p>

<hr>
<h2 id='calc_assoc_pval_matrix'>Calculate p-values for all pairwise associations of features in a data list</h2><span id='topic+calc_assoc_pval_matrix'></span>

<h3>Description</h3>

<p>Calculate p-values for all pairwise associations of features in a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_assoc_pval_matrix(dl, verbose = FALSE, cat_test = "chi_squared")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_assoc_pval_matrix_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_matrix_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to the console.</p>
</td></tr>
<tr><td><code id="calc_assoc_pval_matrix_+3A_cat_test">cat_test</code></td>
<td>
<p>String indicating which statistical test will be used to
associate cluster with a categorical feature. Options are &quot;chi_squared&quot; for
the Chi-squared test and &quot;fisher_exact&quot; for Fisher's exact test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;matrix&quot; class object containing pairwise association p-values
between the features in the provided data list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_list &lt;- data_list(
    list(income, "household_income", "demographics", "ordinal"),
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)

assoc_pval_matrix &lt;- calc_assoc_pval_matrix(data_list)
</code></pre>

<hr>
<h2 id='calc_nmis'>Calculate feature NMIs for a data list and a solutions data frame</h2><span id='topic+calc_nmis'></span>

<h3>Description</h3>

<p>Normalized mutual information scores can be used to indirectly measure how
important a feature may have been in producing a cluster solution. This
function will calculate the normalized mutual information between cluster
solutions in a solutions data frame as well as cluster solutions created
by including only a single feature from a provided data list, but otherwise
using all the same hyperparameters as specified in the original SNF config.
Note that NMIs can be calculated between two cluster solutions regardless
of what features were actually used to create those cluster solutions. For
example, a feature that was not involved in producing a particular cluster
solution may still have a high NMI with that cluster solution (typically
because it was highly correlated with a different feature that was used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_nmis(
  dl,
  sol_df,
  transpose = TRUE,
  ignore_inclusions = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_nmis_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="calc_nmis_+3A_sol_df">sol_df</code></td>
<td>
<p>Result of <code>batch_snf</code> storing cluster solutions and
the settings that were used to generate them. Use the same value as was used
in the original call to <code>batch_snf()</code>.</p>
</td></tr>
<tr><td><code id="calc_nmis_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, will transpose the output data frame.</p>
</td></tr>
<tr><td><code id="calc_nmis_+3A_ignore_inclusions">ignore_inclusions</code></td>
<td>
<p>If TRUE, will ignore the inclusion columns in the
solutions data frame and calculate NMIs for all features. If FALSE, will
give NAs for features that were dropped on a given settings_df row.</p>
</td></tr>
<tr><td><code id="calc_nmis_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;data.frame&quot; class object containing one row for every feature
in the provided data list and one column for every solution in the provided
solutions data frame. Populated values show the calculated NMI score for
each feature-solution combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 2)

sol_df &lt;- batch_snf(input_dl, sc)

calc_nmis(input_dl, sol_df)
</code></pre>

<hr>
<h2 id='calculate_coclustering'>Calculate coclustering data.</h2><span id='topic+calculate_coclustering'></span>

<h3>Description</h3>

<p>Calculate coclustering data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_coclustering(subsample_solutions, sol_df, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_coclustering_+3A_subsample_solutions">subsample_solutions</code></td>
<td>
<p>A list of containing cluster solutions from
distinct subsamples of the data. This object is generated by the function
<code>batch_snf_subsamples()</code>. These solutions should correspond to the ones in
the solutions data frame.</p>
</td></tr>
<tr><td><code id="calculate_coclustering_+3A_sol_df">sol_df</code></td>
<td>
<p>A solutions data frame. This object is generated by the
function <code>batch_snf()</code>. The solutions in the solutions data frame should
correspond to those in the subsample solutions.</p>
</td></tr>
<tr><td><code id="calculate_coclustering_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output time remaining estimates to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li><p> cocluster_dfs: A list of data frames, one per cluster solution, that shows
the number of times that every pair of observations in the original cluster
solution occurred in the same subsample, the number of times that every
pair clustered together in a subsample, and the corresponding fraction
of times that every pair clustered together in a subsample.
</p>
</li>
<li><p> cocluster_ss_mats: The number of times every pair of observations occurred
in the same subsample, formatted as a pairwise matrix.
</p>
</li>
<li><p> cocluster_sc_mats: The number of times every pair of observations occurred
in the same cluster, formatted as a pairwise matrix.
</p>
</li>
<li><p> cocluster_cf_mats: The fraction of times every pair of observations occurred
in the same cluster, formatted as a pairwise matrix.
</p>
</li>
<li><p> cocluster_summary: Specifically among pairs of observations that clustered
together in the original full cluster solution, what fraction of those
pairs remained clustered together throughout the subsample solutions. This
information is formatted as a data frame with one row per cluster solution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# sol_df &lt;- batch_snf(my_dl, sc)
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results &lt;- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
# 
# coclustering_results &lt;- calculate_coclustering(
#     batch_subsample_results,
#     sol_df,
#     verbose = TRUE
# )
</code></pre>

<hr>
<h2 id='cancer_diagnosis_df'>Mock diagnosis data</h2><span id='topic+cancer_diagnosis_df'></span>

<h3>Description</h3>

<p>This is the same data as <code>diagnosis_df</code>, with renamed features and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cancer_diagnosis_df
</code></pre>


<h3>Format</h3>



<h4><code>cancer_diagnosis_df</code></h4>

<p>A data frame with 200 rows and 2 columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
<dt>diagnosis</dt><dd><p>Mock cancer diagnosis feature (1, 2, or 3)</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='cat_colours'>Helper function for generating categorical colour palette</h2><span id='topic+cat_colours'></span>

<h3>Description</h3>

<p>Helper function for generating categorical colour palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_colours(vector, palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_colours_+3A_vector">vector</code></td>
<td>
<p>Vector of categorical data to generate palette for.</p>
</td></tr>
<tr><td><code id="cat_colours_+3A_palette">palette</code></td>
<td>
<p>Which RColorBrewer palette should be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of colours where the names correspond to the unique
values of vector and the values correspond to their colours.
</p>

<hr>
<h2 id='cell_significance_fn'>Place significance stars on ComplexHeatmap cells.</h2><span id='topic+cell_significance_fn'></span>

<h3>Description</h3>

<p>This is an internal function meant to be used to by the
assoc_pval_heatmap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_significance_fn(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cell_significance_fn_+3A_data">data</code></td>
<td>
<p>The matrix containing the cells to base the significance stars
on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cell_fn Another function that is well-formatted for usage as the
cell_fun argument in ComplexHeatmap::Heatmap.
</p>

<hr>
<h2 id='char_to_fac'>Convert character-type columns of a data frame to factor-type</h2><span id='topic+char_to_fac'></span>

<h3>Description</h3>

<p>Convert character-type columns of a data frame to factor-type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char_to_fac(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="char_to_fac_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame with factor columns instead of char columns.
</p>

<hr>
<h2 id='check_cfll_fn_args'>Check if functions in a distance metrics list-like have valid arguments</h2><span id='topic+check_cfll_fn_args'></span>

<h3>Description</h3>

<p>Check if functions in a distance metrics list-like have valid arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cfll_fn_args(cfll)
</code></pre>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the functions in dfll
don't have valid arguments.
</p>

<hr>
<h2 id='check_cfll_fns'>Check if items of a clustering functions list-like object are functions</h2><span id='topic+check_cfll_fns'></span>

<h3>Description</h3>

<p>Check if items of a clustering functions list-like object are functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cfll_fns(cfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cfll_fns_+3A_cfll">cfll</code></td>
<td>
<p>A clust_fns_list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the items of cfll are
not functions.
</p>

<hr>
<h2 id='check_cfll_named'>Check if clustering functions list-like object has named algorithms</h2><span id='topic+check_cfll_named'></span>

<h3>Description</h3>

<p>Check if clustering functions list-like object has named algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cfll_named(cfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cfll_named_+3A_cfll">cfll</code></td>
<td>
<p>A clust_fns_list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are unnamed
clustering functions in cfll.
</p>

<hr>
<h2 id='check_cfll_unique_names'>Check if names in a clustering functions list-like object are unique</h2><span id='topic+check_cfll_unique_names'></span>

<h3>Description</h3>

<p>Check if names in a clustering functions list-like object are unique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cfll_unique_names(cfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cfll_unique_names_+3A_cfll">cfll</code></td>
<td>
<p>A clust_fns_list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the names in cfll aren't
unique.
</p>

<hr>
<h2 id='check_compatible_sdf_cfl'>Check if settings_df exceeds bounds of clust_fns_list</h2><span id='topic+check_compatible_sdf_cfl'></span>

<h3>Description</h3>

<p>Check if settings_df exceeds bounds of clust_fns_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_compatible_sdf_cfl(sdf, cfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_compatible_sdf_cfl_+3A_sdf">sdf</code></td>
<td>
<p>A <code>settings_df</code> class object.</p>
</td></tr>
<tr><td><code id="check_compatible_sdf_cfl_+3A_cfl">cfl</code></td>
<td>
<p>A <code>clust_fns_list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if sdf calls for a clustering
function outside the range of cfl.
</p>

<hr>
<h2 id='check_compatible_sdf_dfl'>Check if settings_df exceeds bounds of dist_fns_list</h2><span id='topic+check_compatible_sdf_dfl'></span>

<h3>Description</h3>

<p>Check if settings_df exceeds bounds of dist_fns_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_compatible_sdf_dfl(sdf, dfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_compatible_sdf_dfl_+3A_sdf">sdf</code></td>
<td>
<p>A <code>settings_df</code> class object.</p>
</td></tr>
<tr><td><code id="check_compatible_sdf_dfl_+3A_dfl">dfl</code></td>
<td>
<p>A <code>dist_fns_list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if sdf calls for a distance
function outside the range of dfl.
</p>

<hr>
<h2 id='check_compatible_sdf_wm'>Check if settings_df and weights_matrix have same number of rows</h2><span id='topic+check_compatible_sdf_wm'></span>

<h3>Description</h3>

<p>Check if settings_df and weights_matrix have same number of rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_compatible_sdf_wm(sdf, wm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_compatible_sdf_wm_+3A_sdf">sdf</code></td>
<td>
<p>A <code>settings_df</code> class object.</p>
</td></tr>
<tr><td><code id="check_compatible_sdf_wm_+3A_wm">wm</code></td>
<td>
<p>A <code>weights_matrix</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if sdf and wm don't have the
same number of rows.
</p>

<hr>
<h2 id='check_dataless_annotations'>Helper function to stop annotation building when no data was provided</h2><span id='topic+check_dataless_annotations'></span>

<h3>Description</h3>

<p>Helper function to stop annotation building when no data was provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dataless_annotations(annotation_requests, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dataless_annotations_+3A_annotation_requests">annotation_requests</code></td>
<td>
<p>A list of requested annotations</p>
</td></tr>
<tr><td><code id="check_dataless_annotations_+3A_data">data</code></td>
<td>
<p>A data frame with data to build annotations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return any value. This function just raises an error when
annotations are requested without any provided data for a heatmap.
</p>

<hr>
<h2 id='check_dfll_fn_args'>Check if functions in a distance metrics list-like have valid arguments</h2><span id='topic+check_dfll_fn_args'></span>

<h3>Description</h3>

<p>Check if functions in a distance metrics list-like have valid arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dfll_fn_args(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dfll_fn_args_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the functions in dfll
don't have valid arguments.
</p>

<hr>
<h2 id='check_dfll_fn_names'>Check if functions in a distance metrics list-like have names</h2><span id='topic+check_dfll_fn_names'></span>

<h3>Description</h3>

<p>Check if functions in a distance metrics list-like have names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dfll_fn_names(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dfll_fn_names_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the functions in dfll
don't have names.
</p>

<hr>
<h2 id='check_dfll_item_names'>Check if items of a distance metrics list-like object have valid names</h2><span id='topic+check_dfll_item_names'></span>

<h3>Description</h3>

<p>Check if items of a distance metrics list-like object have valid names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dfll_item_names(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dfll_item_names_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the items of dfll don't
have valid formatted names.
</p>

<hr>
<h2 id='check_dfll_subitems_are_fns'>Check if subitems of a distance metrics list-like object are functions</h2><span id='topic+check_dfll_subitems_are_fns'></span>

<h3>Description</h3>

<p>Check if subitems of a distance metrics list-like object are functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dfll_subitems_are_fns(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dfll_subitems_are_fns_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the subitems of dfll are
not functions.
</p>

<hr>
<h2 id='check_dfll_unique_names'>Check if names in a distance metrics list-like object are unique</h2><span id='topic+check_dfll_unique_names'></span>

<h3>Description</h3>

<p>Check if names in a distance metrics list-like object are unique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dfll_unique_names(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dfll_unique_names_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if the items of dfll aren't
unique across layer 1 or within each item of layer 2.
</p>

<hr>
<h2 id='check_dll_duplicate_components'>Check if data list contains any duplicate names</h2><span id='topic+check_dll_duplicate_components'></span>

<h3>Description</h3>

<p>Check if data list contains any duplicate names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_duplicate_components(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_duplicate_components_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are features with
duplicate names in a generated data list.
</p>

<hr>
<h2 id='check_dll_duplicate_features'>Check if data list contains any duplicate features</h2><span id='topic+check_dll_duplicate_features'></span>

<h3>Description</h3>

<p>Check if data list contains any duplicate features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_duplicate_features(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_duplicate_features_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are features with
duplicate names in a generated data list.
</p>

<hr>
<h2 id='check_dll_empty_input'>Error if empty input provided during data list initalization</h2><span id='topic+check_dll_empty_input'></span>

<h3>Description</h3>

<p>Error if empty input provided during data list initalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_empty_input(data_list_input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_empty_input_+3A_data_list_input">data_list_input</code></td>
<td>
<p>Input data provided for data list initialization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error if data_list_input has 0 length.
</p>

<hr>
<h2 id='check_dll_four_subitems'>Error if data list-like list doesn't have only 4-item nested lists</h2><span id='topic+check_dll_four_subitems'></span>

<h3>Description</h3>

<p>Error if data list-like list doesn't have only 4-item nested lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_four_subitems(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_four_subitems_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises error if dll doesn't have only 4-item nested lists
</p>

<hr>
<h2 id='check_dll_inherits_list'>Error if data list-like structure isn't a list</h2><span id='topic+check_dll_inherits_list'></span>

<h3>Description</h3>

<p>Error if data list-like structure isn't a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_inherits_list(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_inherits_list_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises error if data list-like structure isn't a list
</p>

<hr>
<h2 id='check_dll_subitem_classes'>Check if UID columns in a nested list have valid structure for a data list</h2><span id='topic+check_dll_subitem_classes'></span>

<h3>Description</h3>

<p>Check if UID columns in a nested list have valid structure for a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_subitem_classes(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_subitem_classes_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error if the UID columns do not have a valid structure.
</p>

<hr>
<h2 id='check_dll_subitem_names'>Check valid subitem names for a data list-like list</h2><span id='topic+check_dll_subitem_names'></span>

<h3>Description</h3>

<p>Error if data list-like structure doesn't have nested names of &quot;data&quot;,
&quot;name&quot;, &quot;domain&quot;, and &quot;type&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_subitem_names(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_subitem_names_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises error if dll doesn't have only 4-item nested lists
</p>

<hr>
<h2 id='check_dll_types'>Error if data list-like structure has invalid feature types</h2><span id='topic+check_dll_types'></span>

<h3>Description</h3>

<p>Error if data list-like structure has invalid feature types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_types(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_types_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error if the loaded types are not among continuous,
discrete, ordinal, categorical, or mixed.
</p>

<hr>
<h2 id='check_dll_uid'>Check if UID columns in a nested list have valid structure for a data list</h2><span id='topic+check_dll_uid'></span>

<h3>Description</h3>

<p>Check if UID columns in a nested list have valid structure for a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dll_uid(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dll_uid_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error if the UID columns do not have a valid structure.
</p>

<hr>
<h2 id='check_hm_dependencies'>Check for ComplexHeatmap and circlize dependencies</h2><span id='topic+check_hm_dependencies'></span>

<h3>Description</h3>

<p>Check for ComplexHeatmap and circlize dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_hm_dependencies()
</code></pre>


<h3>Value</h3>

<p>Does not return any value. This function just checks that the
ComplexHeatmap and circlize packages are installed.
</p>

<hr>
<h2 id='check_sdfl_colnames'>Check if settings data frame inherits class <code>data.frame</code></h2><span id='topic+check_sdfl_colnames'></span>

<h3>Description</h3>

<p>Check if settings data frame inherits class <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sdfl_colnames(sdfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sdfl_colnames_+3A_sdfl">sdfl</code></td>
<td>
<p>A settings data frame-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are features with
duplicate names in a generated data list.
</p>

<hr>
<h2 id='check_sdfl_is_df'>Check if settings data frame inherits class <code>data.frame</code></h2><span id='topic+check_sdfl_is_df'></span>

<h3>Description</h3>

<p>Check if settings data frame inherits class <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sdfl_is_df(sdfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sdfl_is_df_+3A_sdfl">sdfl</code></td>
<td>
<p>A settings data frame-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are features with
duplicate names in a generated data list.
</p>

<hr>
<h2 id='check_sdfl_numeric'>Check if settings data frame is numeric</h2><span id='topic+check_sdfl_numeric'></span>

<h3>Description</h3>

<p>Check if settings data frame is numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sdfl_numeric(sdfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sdfl_numeric_+3A_sdfl">sdfl</code></td>
<td>
<p>A settings data frame-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if there are features with
duplicate names in a generated data list.
</p>

<hr>
<h2 id='check_similarity_matrices'>Check validity of similarity matrices</h2><span id='topic+check_similarity_matrices'></span>

<h3>Description</h3>

<p>Check to see if similarity matrices in a list have the following properties:
</p>

<ol>
<li><p> The maximum value in the entire matrix is 0.5
</p>
</li>
<li><p> Every value in the diagonal is 0.5
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>check_similarity_matrices(similarity_matrices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_similarity_matrices_+3A_similarity_matrices">similarity_matrices</code></td>
<td>
<p>A list of similarity matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>valid_matrices Boolean indicating if properties are met by all
similarity matrices
</p>

<hr>
<h2 id='check_valid_k'>Check if max K exceeds the number of observations</h2><span id='topic+check_valid_k'></span>

<h3>Description</h3>

<p>Check if max K exceeds the number of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_valid_k(sdf, dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_valid_k_+3A_sdf">sdf</code></td>
<td>
<p>A <code>settings_df</code> class object.</p>
</td></tr>
<tr><td><code id="check_valid_k_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if max K exceeds the number
of observations.
</p>

<hr>
<h2 id='check_valid_sc'>Check if SNF config has valid structure</h2><span id='topic+check_valid_sc'></span>

<h3>Description</h3>

<p>Check if SNF config has valid structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_valid_sc(sc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_valid_sc_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return any value. Raises error if snf_config is not an
<code>snf_config</code> class object.
</p>

<hr>
<h2 id='chi_squared_pval'>Chi-squared test p-value (generic)</h2><span id='topic+chi_squared_pval'></span>

<h3>Description</h3>

<p>Return p-value for chi-squared test for any two features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi_squared_pval(cat_var1, cat_var2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi_squared_pval_+3A_cat_var1">cat_var1</code></td>
<td>
<p>A categorical feature.</p>
</td></tr>
<tr><td><code id="chi_squared_pval_+3A_cat_var2">cat_var2</code></td>
<td>
<p>A categorical feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval A p-value (class &quot;numeric&quot;).
</p>

<hr>
<h2 id='clust_fns'>Built-in clustering algorithms</h2><span id='topic+clust_fns'></span><span id='topic+spectral_eigen'></span><span id='topic+spectral_rot'></span><span id='topic+spectral_eigen_classic'></span><span id='topic+spectral_rot_classic'></span><span id='topic+spectral_two'></span><span id='topic+spectral_three'></span><span id='topic+spectral_four'></span><span id='topic+spectral_five'></span><span id='topic+spectral_six'></span><span id='topic+spectral_seven'></span><span id='topic+spectral_eight'></span><span id='topic+spectral_nine'></span><span id='topic+spectral_ten'></span>

<h3>Description</h3>

<p>These functions can be used when building a <code>metasnf</code> clustering functions
list. Each function converts a similarity matrix (matrix class object) to a
cluster solution (numeric vector). Note that these functions (or custom
clustering functions) cannot accept number of clusters as a parameter; this
value must be built into the function itself if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_eigen(similarity_matrix)

spectral_rot(similarity_matrix)

spectral_eigen_classic(similarity_matrix)

spectral_rot_classic(similarity_matrix)

spectral_two(similarity_matrix)

spectral_three(similarity_matrix)

spectral_four(similarity_matrix)

spectral_five(similarity_matrix)

spectral_six(similarity_matrix)

spectral_seven(similarity_matrix)

spectral_eight(similarity_matrix)

spectral_nine(similarity_matrix)

spectral_ten(similarity_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_fns_+3A_similarity_matrix">similarity_matrix</code></td>
<td>
<p>A similarity matrix.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> spectral_eigen: Spectral clustering where the number of clusters is based
on the eigen-gap heuristic
</p>
</li>
<li><p> spectral_rot: Spectral clustering where the number of clusters is based
on the rotation-cost heuristic
</p>
</li>
<li><p> spectral_(C): Spectral clustering for a C-cluster solution.
</p>
</li></ul>



<h3>Value</h3>

<p>solution_data A vector of cluster assignments
</p>

<hr>
<h2 id='clust_fns_list'>Build a clusteing algorithms list</h2><span id='topic+clust_fns_list'></span>

<h3>Description</h3>

<p>This function can be used to specify custom clustering algorithms to apply
to the final similarity matrices produced by each run of the batch_snf
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_fns_list(clust_fns = NULL, use_default_clust_fns = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_fns_list_+3A_clust_fns">clust_fns</code></td>
<td>
<p>A list of named clustering functions</p>
</td></tr>
<tr><td><code id="clust_fns_list_+3A_use_default_clust_fns">use_default_clust_fns</code></td>
<td>
<p>If TRUE, prepend the base clustering algorithms
(spectral_eigen and spectral_rot, which apply spectral clustering and use
the eigen-gap and rotation cost heuristics respectively for determining
the number of clusters in the graph) to clust_fns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering algorithm functions that can
be passed into the batch_snf and generate_settings_list functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using just the base clustering algorithms --------------------------------
# This will just contain spectral_eigen and spectral_rot
cfl &lt;- clust_fns_list(use_default_clust_fns = TRUE)

# Adding algorithms provided by the package --------------------------------
# This will contain the base clustering algorithms (spectral_eigen,
#  spectral_rot) as well as two pre-defined spectral clustering functions
#  that force the number of clusters to be two or five
cfl &lt;- clust_fns_list(
     clust_fns = list(
        "two_cluster_spectral" = spectral_two,
        "five_cluster_spectral" = spectral_five
    )
)

# Adding your own algorithms -----------------------------------------------
# This will contain the base and user-provided clustering algorithms
my_clustering_algorithm &lt;- function(similarity_matrix) {
    # your code that converts similarity matrix to clusters here...
}

# Suppress the base algorithms----------------------------------------------
# This will contain only user-provided clustering algorithms
cfl &lt;- clust_fns_list(
    clust_fns = list(
        "two_cluster_spectral" = spectral_two,
        "five_cluster_spectral" = spectral_five
    )
)
</code></pre>

<hr>
<h2 id='cocluster_density'>Density plot coclustering stability across subsampled data.</h2><span id='topic+cocluster_density'></span>

<h3>Description</h3>

<p>This function creates a density plot that shows, for all pairs of
observations that originally clustered together, the distribution of the
the fractions that those pairs clustered together across subsampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocluster_density(cocluster_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cocluster_density_+3A_cocluster_df">cocluster_df</code></td>
<td>
<p>A data frame containing coclustering data for a single
cluster solution. This object is generated by the <code>calculate_coclustering</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density plot (class &quot;gg&quot;, &quot;ggplot&quot;) of the distribution of
coclustering across pairs and subsamples of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# sol_df &lt;- batch_snf(my_dl, sc)
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results &lt;- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
# 
# coclustering_results &lt;- calculate_coclustering(
#     batch_subsample_results,
#     sol_df,
#     verbose = TRUE
# )
# 
# cocluster_density(cocluster_dfs[[1]])
</code></pre>

<hr>
<h2 id='cocluster_heatmap'>Heatmap of observation co-clustering across resampled data.</h2><span id='topic+cocluster_heatmap'></span>

<h3>Description</h3>

<p>Create a heatmap that shows the distribution of observation co-clustering
across resampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocluster_heatmap(
  cocluster_df,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = FALSE,
  show_column_names = FALSE,
  dl = NULL,
  data = NULL,
  left_bar = NULL,
  right_bar = NULL,
  top_bar = NULL,
  bottom_bar = NULL,
  left_hm = NULL,
  right_hm = NULL,
  top_hm = NULL,
  bottom_hm = NULL,
  annotation_colours = NULL,
  min_colour = NULL,
  max_colour = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cocluster_heatmap_+3A_cocluster_df">cocluster_df</code></td>
<td>
<p>A data frame containing coclustering data for a single
cluster solution. This object is generated by the <code>calculate_coclustering</code>
function.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Argument passed to <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Argument passed to <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_show_row_names">show_row_names</code></td>
<td>
<p>Argument passed to <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_show_column_names">show_column_names</code></td>
<td>
<p>Argument passed to <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_dl">dl</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_data">data</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_left_bar">left_bar</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_right_bar">right_bar</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_top_bar">top_bar</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_bottom_bar">bottom_bar</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_left_hm">left_hm</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_right_hm">right_hm</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_top_hm">top_hm</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_bottom_hm">bottom_hm</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_annotation_colours">annotation_colours</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_min_colour">min_colour</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_max_colour">max_colour</code></td>
<td>
<p>See ?similarity_matrix_heatmap.</p>
</td></tr>
<tr><td><code id="cocluster_heatmap_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>ComplexHeatmap::Heatmap()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Heatmap (class &quot;Heatmap&quot; from ComplexHeatmap) object showing the
distribution of observation co-clustering across resampled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# sol_df &lt;- batch_snf(my_dl, sc)
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results &lt;- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
# 
# coclustering_results &lt;- calculate_coclustering(
#     batch_subsample_results, 
#     sol_df,
#     verbose = TRUE
# )
# 
# cocluster_dfs &lt;- coclustering_results$"cocluster_dfs"
# 
# cocluster_heatmap(
#     cocluster_dfs[[1]],
#     dl = my_dl,
#     top_hm = list(
#         "Income" = "household_income",
#         "Pubertal Status" = "pubertal_status"
#     ),
#     annotation_colours = list(
#         "Pubertal Status" = colour_scale(
#             c(1, 4),
#             min_colour = "black",
#             max_colour = "purple"
#         ),
#         "Income" = colour_scale(
#             c(0, 4),
#             min_colour = "black",
#             max_colour = "red"
#         )
#     )
# )
</code></pre>

<hr>
<h2 id='coclustering_coverage_check'>Coclustering coverage check</h2><span id='topic+coclustering_coverage_check'></span>

<h3>Description</h3>

<p>Check if coclustered data has at least one subsample in which every pair
of observations were a part of simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coclustering_coverage_check(cocluster_df, action = "warn")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coclustering_coverage_check_+3A_cocluster_df">cocluster_df</code></td>
<td>
<p>data frame containing coclustering data.</p>
</td></tr>
<tr><td><code id="coclustering_coverage_check_+3A_action">action</code></td>
<td>
<p>Control if parent function should warn or stop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any value. It checks a <code>cocluster_df</code>
for complete coverage (all pairs occur in the same solution at least once).
Will raise a warning or error if coverage is incomplete depending on the
value of the action parameter.
</p>

<hr>
<h2 id='collapse_dl'>Convert a data list into a data frame</h2><span id='topic+collapse_dl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Defunct function for converting a data list into a data frame. Please
use <code>as.data.frame()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_dl(data_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_dl_+3A_data_list">data_list</code></td>
<td>
<p>A nested list of input data from <code>generate_data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;data.frame&quot;-formatted version of the provided data list.
</p>

<hr>
<h2 id='colour_scale'>Return a colour ramp for a given vector</h2><span id='topic+colour_scale'></span>

<h3>Description</h3>

<p>Given a numeric vector and min and max colour values, return a colour ramp
that assigns a colour to each element in the vector. This function is a
wrapper for <code>circlize::colorRamp2</code>.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colour_scale(data, min_colour, max_colour)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colour_scale_+3A_data">data</code></td>
<td>
<p>Vector of numeric values.</p>
</td></tr>
<tr><td><code id="colour_scale_+3A_min_colour">min_colour</code></td>
<td>
<p>Minimum colour value.</p>
</td></tr>
<tr><td><code id="colour_scale_+3A_max_colour">max_colour</code></td>
<td>
<p>Maximum colour value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;function&quot; class object that can build a circlize-style colour
ramp.
</p>

<hr>
<h2 id='config_heatmap'>Heatmap for visualizing an SNF config</h2><span id='topic+config_heatmap'></span>

<h3>Description</h3>

<p>Create a heatmap where each row corresponds to a different set of
hyperparameters in an SNF config object. Numeric parameters are scaled
normalized and non-numeric parameters are added as heatmap annotations. Rows
can be reordered to match prior meta clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_heatmap(
  sc,
  order = NULL,
  hide_fixed = FALSE,
  show_column_names = TRUE,
  show_row_names = TRUE,
  rect_gp = grid::gpar(col = "black"),
  colour_breaks = c(0, 1),
  colours = c("black", "darkseagreen"),
  column_split_vector = NULL,
  row_split_vector = NULL,
  column_split = NULL,
  row_split = NULL,
  column_title = NULL,
  include_weights = TRUE,
  include_settings = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="config_heatmap_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> class object.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_order">order</code></td>
<td>
<p>Numeric vector indicating row ordering of SNF config.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_hide_fixed">hide_fixed</code></td>
<td>
<p>Whether fixed parameters should be removed.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_show_column_names">show_column_names</code></td>
<td>
<p>Whether show column names.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_show_row_names">show_row_names</code></td>
<td>
<p>Whether show row names.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_rect_gp">rect_gp</code></td>
<td>
<p>Graphic parameters for drawing rectangles (for heatmap body). The value should be specified by <code><a href="grid.html#topic+gpar">gpar</a></code> and <code>fill</code> parameter is ignored.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_colour_breaks">colour_breaks</code></td>
<td>
<p>Numeric vector of breaks for the legend.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_colours">colours</code></td>
<td>
<p>Vector of colours to use for the heatmap. Should match the
length of colour_breaks.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_column_split_vector">column_split_vector</code></td>
<td>
<p>Vector of indices to split columns by.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_row_split_vector">row_split_vector</code></td>
<td>
<p>Vector of indices to split rows by.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_column_split">column_split</code></td>
<td>
<p>Split on columns. For heatmap splitting, please refer to <a href="https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#heatmap-split">https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#heatmap-split</a> .</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_row_split">row_split</code></td>
<td>
<p>Same as <code>split</code>.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_column_title">column_title</code></td>
<td>
<p>Title on the column.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_include_weights">include_weights</code></td>
<td>
<p>If TRUE, includes feature weights of the weights
matrix into the config heatmap.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_include_settings">include_settings</code></td>
<td>
<p>If TRUE, includes columns from the settings data
frame into the config heatmap.</p>
</td></tr>
<tr><td><code id="config_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the scaled values of the provided SNF config.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dl &lt;- data_list(
    list(income, "household_income", "demographics", "ordinal"),
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    list(fav_colour, "favourite_colour", "demographics", "categorical"),
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)

sc &lt;- snf_config(
    dl,
    n_solutions = 10,
    dropout_dist = "uniform"
)

config_heatmap(sc)
</code></pre>

<hr>
<h2 id='convert_uids'>Convert unique identifiers of data list to &quot;uid&quot;</h2><span id='topic+convert_uids'></span>

<h3>Description</h3>

<p>Column name &quot;uid&quot; is reserved for the unique identifier of observations.
This function ensures all data frames have their UID set as &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_uids(dll, uid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_uids_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
<tr><td><code id="convert_uids_+3A_uid">uid</code></td>
<td>
<p>(string) the name of the uid column currently used data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dll The provided nested list with &quot;uid&quot; as UID.
</p>

<hr>
<h2 id='cort_sa'>Mock ABCD cortical surface area data</h2><span id='topic+cort_sa'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_cort_sa&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cort_sa
</code></pre>


<h3>Format</h3>



<h4><code>cort_sa</code></h4>

<p>A data frame with 188 rows and 152 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Cortical surface areas of various ROIs (mm^2, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='cort_t'>Mock ABCD cortical thickness data</h2><span id='topic+cort_t'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_cort_t&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cort_t
</code></pre>


<h3>Format</h3>



<h4><code>cort_t</code></h4>

<p>A data frame with 188 rows and 152 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Cortical thicknesses of various ROIs (mm^3, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='data_list'>Build a <code>data_list</code> class object</h2><span id='topic+data_list'></span>

<h3>Description</h3>

<p><code>data_list()</code> constructs a data list object which inherits from classes
<code>data_list</code> and <code>list</code>. This object is the primary way in which features to
be used along the <code>metasnf</code> clustering pipeline are stored. The data list is
fundamentally a 2-level nested list object where each inner list contains a
data frame and associated metadata for that data frame. The metadata
includes the name of the data frame, the 'domain' of that data frame (the
broader source of information that the input data frame is capturing,
determined by user's domain knowledge), and the type of feature stored in
the data frame (continuous, discrete, ordinal, categorical, or mixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_list(..., uid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_list_+3A_...">...</code></td>
<td>
<p>Any number of lists formatted as (df, &quot;df_name&quot;, &quot;df_domain&quot;,
&quot;df_type&quot;) and/or any number of lists of lists formatted as (df, &quot;df_name&quot;,
&quot;df_domain&quot;, &quot;df_type&quot;).</p>
</td></tr>
<tr><td><code id="data_list_+3A_uid">uid</code></td>
<td>
<p>(character) the name of the uid column currently used data.
data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>heart_rate_df &lt;- data.frame(
    patient_id = c("1", "2", "3"),
    var1 = c(0.04, 0.1, 0.3),
    var2 = c(30, 2, 0.3)
)

personality_test_df &lt;- data.frame(
    patient_id = c("1", "2", "3"),
    var3 = c(900, 1990, 373),
    var4 = c(509, 2209, 83)
)

survey_response_df &lt;- data.frame(
    patient_id = c("1", "2", "3"),
    var5 = c(1, 3, 3),
    var6 = c(2, 3, 3)
)

city_df &lt;- data.frame(
    patient_id = c("1", "2", "3"),
    var7 = c("toronto", "montreal", "vancouver")
)

# Explicitly (Name each nested list element):
dl &lt;- data_list(
    list(
        data = heart_rate_df,
        name = "heart_rate",
        domain = "clinical",
        type = "continuous"
    ),
    list(
        data = personality_test_df,
        name = "personality_test",
        domain = "surveys",
        type = "continuous"
    ),
    list(
        data = survey_response_df,
        name = "survey_response",
        domain = "surveys",
        type = "ordinal"
    ),
    list(
        data = city_df,
        name = "city",
        domain = "location",
        type = "categorical"
    ),
    uid = "patient_id"
)

# Compact loading
dl &lt;- data_list(
    list(heart_rate_df, "heart_rate", "clinical", "continuous"),
    list(personality_test_df, "personality_test", "surveys", "continuous"),
    list(survey_response_df, "survey_response", "surveys", "ordinal"),
    list(city_df, "city", "location", "categorical"),
    uid = "patient_id"
)

# Printing data list summaries
summary(dl)

# Alternative loading: providing a single list of lists
list_of_lists &lt;- list(
    list(heart_rate_df, "data1", "domain1", "continuous"),
    list(personality_test_df, "data2", "domain2", "continuous")
)

dl &lt;- data_list(
    list_of_lists,
    uid = "patient_id"
)
</code></pre>

<hr>
<h2 id='depress'>Mock ABCD depression data</h2><span id='topic+depress'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_depress&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depress
</code></pre>


<h3>Format</h3>



<h4><code>depress</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>cbcl_depress_r</dt><dd><p>Ordinal value of impairment on CBCL anxiety, either 0 (no impairment), 1 (borderline clinical), or 2 (clinically impaired)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='diagnosis_df'>Mock diagnosis data</h2><span id='topic+diagnosis_df'></span>

<h3>Description</h3>

<p>This is the same data as <code>cancer_diagnosis_df</code>, with renamed features and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosis_df
</code></pre>


<h3>Format</h3>



<h4><code>diagnosis_df</code></h4>

<p>A data frame with 200 rows and 2 columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
<dt>diagnosis</dt><dd><p>Mock diagnosis feature</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='discretisation'>Internal function for <code>estimate_nclust_given_graph</code></h2><span id='topic+discretisation'></span>

<h3>Description</h3>

<p>Internal function taken from <code>SNFtool</code> to use for number of cluster
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretisation(eigenvectors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretisation_+3A_eigenvectors">eigenvectors</code></td>
<td>
<p>Matrix of eigenvectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;Matrix&quot; class object, intermediate product in spectral clustering.
</p>

<hr>
<h2 id='discretisation_evec_data'>Internal function for <code>estimate_nclust_given_graph</code></h2><span id='topic+discretisation_evec_data'></span>

<h3>Description</h3>

<p>Internal function taken from <code>SNFtool</code> to use for number of cluster
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretisation_evec_data(eigenvector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretisation_evec_data_+3A_eigenvector">eigenvector</code></td>
<td>
<p>Matrix of eigenvectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;Matrix&quot; class object discretizing provided eigenvector to values 0
or 1.
</p>

<hr>
<h2 id='dist_fns'>Built-in distance functions</h2><span id='topic+dist_fns'></span><span id='topic+euclidean_distance'></span><span id='topic+gower_distance'></span><span id='topic+sn_euclidean_distance'></span><span id='topic+sew_euclidean_distance'></span><span id='topic+hamming_distance'></span>

<h3>Description</h3>

<p>These functions can be used when building a <code>metasnf</code> distance functions
list. Each function converts a data frame into to a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean_distance(df, weights_row)

gower_distance(df, weights_row)

sn_euclidean_distance(df, weights_row)

sew_euclidean_distance(df, weights_row)

hamming_distance(df, weights_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_fns_+3A_df">df</code></td>
<td>
<p>Data frame containing at least 1 data column</p>
</td></tr>
<tr><td><code id="dist_fns_+3A_weights_row">weights_row</code></td>
<td>
<p>Single-row data frame where the column names contain the
column names in df and the row contains the corresponding weights_row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions that work for numeric data:
</p>

<ul>
<li><p> euclidean_distance: typical Euclidean distance
</p>
</li>
<li><p> sn_euclidean_distance: Data frame is first standardized and normalized
before typical Euclidean distance is applied
</p>
</li>
<li><p> siw_euclidean_distance: Squared (including weights) Euclidean distance,
where the weights are also squared
</p>
</li>
<li><p> sew_euclidean_distance: Squared (excluding weights) Euclidean distance,
where the weights are not also squared
</p>
</li></ul>

<p>Functions that work for binary data:
</p>

<ul>
<li><p> hamming_distance: typical Hamming distance
</p>
</li></ul>

<p>Functions that work for any type of data:
</p>

<ul>
<li><p> gower_distance: Gower distance (cluster::daisy)
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix class object containing pairwise distances.
</p>

<hr>
<h2 id='dist_fns_list'>Build a distance metrics list</h2><span id='topic+dist_fns_list'></span>

<h3>Description</h3>

<p>The distance metrics list object (inherits classes <code>dist_fns_list</code>
and <code>list</code>) is a list that stores R functions which can convert a data
frame of features into a matrix of pairwise distances. The list is a nested
one, where the first layer of the list can hold up to 5 items (one for each
of the <code>metasnf</code> recognized feature types, continuous, discrete, ordinal,
categorical, and mixed), and the second layer can hold an arbitrary number
of distance functions for each of those types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_fns_list(
  cnt_dist_fns = NULL,
  dsc_dist_fns = NULL,
  ord_dist_fns = NULL,
  cat_dist_fns = NULL,
  mix_dist_fns = NULL,
  automatic_standard_normalize = FALSE,
  use_default_dist_fns = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_fns_list_+3A_cnt_dist_fns">cnt_dist_fns</code></td>
<td>
<p>A named list of continuous distance metric functions.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_dsc_dist_fns">dsc_dist_fns</code></td>
<td>
<p>A named list of discrete distance metric functions.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_ord_dist_fns">ord_dist_fns</code></td>
<td>
<p>A named list of ordinal distance metric functions.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_cat_dist_fns">cat_dist_fns</code></td>
<td>
<p>A named list of categorical distance metric functions.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_mix_dist_fns">mix_dist_fns</code></td>
<td>
<p>A named list of mixed distance metric functions.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_automatic_standard_normalize">automatic_standard_normalize</code></td>
<td>
<p>If TRUE, will automatically use
standard normalization prior to calculation of any numeric distances. This
parameter overrides all other distance functions list-related parameters.</p>
</td></tr>
<tr><td><code id="dist_fns_list_+3A_use_default_dist_fns">use_default_dist_fns</code></td>
<td>
<p>If TRUE, prepend the base distance metrics
(euclidean distance for continuous, discrete, and ordinal data and gower
distance for categorical and mixed data) to the resulting distance metrics
list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Call ?distance_metrics to see all distance metric functions provided in
metasnf.
</p>


<h3>Value</h3>

<p>A distance metrics list object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using just the base distance metrics  ------------------------------------
dist_fns_list &lt;- dist_fns_list()

# Adding your own metrics --------------------------------------------------
# This will contain only the and user-provided distance function:
cubed_euclidean &lt;- function(df, weights_row) {
    # (your code that converts a data frame to a distance metric here...)
    weights &lt;- diag(weights_row, nrow = length(weights_row))
    weighted_df &lt;- as.matrix(df) %*% weights
    distance_matrix &lt;- weighted_df |&gt;
        stats::dist(method = "euclidean") |&gt;
        as.matrix()
    distance_matrix &lt;- distance_matrix^3
    return(distance_matrix)
}

dist_fns_list &lt;- dist_fns_list(
    cnt_dist_fns = list(
         "my_cubed_euclidean" = cubed_euclidean
    )
)

# Using default base metrics------------------------------------------------
# Call ?distance_metrics to see all distance metric functions provided in
# metasnf. The code below will contain a mix of user-provided and built-in
# distance metric functions.
dist_fns_list &lt;- dist_fns_list(
    cnt_dist_fns = list(
         "my_distance_metric" = cubed_euclidean
    ),
    dsc_dist_fns = list(
         "my_distance_metric" = cubed_euclidean
    ),
    ord_dist_fns = list(
         "my_distance_metric" = cubed_euclidean
    ),
    cat_dist_fns = list(
         "my_distance_metric" = gower_distance
    ),
    mix_dist_fns = list(
         "my_distance_metric" = gower_distance
    ),
    use_default_dist_fns = TRUE
)
</code></pre>

<hr>
<h2 id='dl_variable_summary'>Variable-level summary of a data list</h2><span id='topic+dl_variable_summary'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Defunct function to summarize a data list. Please use <code>summary()</code> with
argument <code>scope = "feature"</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl_variable_summary(dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dl_variable_summary_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variable_level_summary A data frame containing the name, type, and
domain of every variable in a data list.
</p>

<hr>
<h2 id='dlapply'>Lapply-like function for data list objects</h2><span id='topic+dlapply'></span>

<h3>Description</h3>

<p>This function enables manipulating a <code>data_list</code> class object with lapply
syntax without removing that object's <code>data_list</code> class attribute. The
function will only preserve this attribute if the result of the apply call
has a valid data list structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlapply(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlapply_+3A_x">X</code></td>
<td>
<p>A <code>data_list</code> class object.</p>
</td></tr>
<tr><td><code id="dlapply_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied to each data list component.</p>
</td></tr>
<tr><td><code id="dlapply_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If FUN applied to each component of X yields a valid data list, a
data list. Otherwise, a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert all UID values to lowercase
dl &lt;- data_list(
    list(abcd_income, "income", "demographics", "discrete"),
    list(abcd_colour, "colour", "likes", "categorical"),
    uid = "patient"
)

dl_lower &lt;- dlapply(
    dl,
    function(x) {
        x$"data"$"uid" &lt;- tolower(x$"data"$"uid")
        return(x)
    }
)
</code></pre>

<hr>
<h2 id='dll_uid_first_col'>Make the uid UID columns of a data list first</h2><span id='topic+dll_uid_first_col'></span>

<h3>Description</h3>

<p>Make the uid UID columns of a data list first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dll_uid_first_col(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dll_uid_first_col_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with &quot;uid&quot; positioned as the first of each data frame
column.
</p>

<hr>
<h2 id='domains'>Pull domains from a data list</h2><span id='topic+domains'></span>

<h3>Description</h3>

<p>Pull domains from a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domains(dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domains_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>domain_list list of domains
</p>

<hr>
<h2 id='drop_cols'>Helper function to remove columns from a data frame</h2><span id='topic+drop_cols'></span>

<h3>Description</h3>

<p>Helper function to remove columns from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_cols(x, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_cols_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="drop_cols_+3A_cols">cols</code></td>
<td>
<p>Vector of column names to be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x without columns in cols
</p>

<hr>
<h2 id='drop_inputs'>Execute inclusion</h2><span id='topic+drop_inputs'></span>

<h3>Description</h3>

<p>Given a data list and a settings data frame row, returns a data list of
selected inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_inputs(sdf_row, dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_inputs_+3A_sdf_row">sdf_row</code></td>
<td>
<p>Row of a settings data frame.</p>
</td></tr>
<tr><td><code id="drop_inputs_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data list (class &quot;list&quot;) in which any component with a
corresponding 0 value in the provided settings data frame row has been removed.
</p>

<hr>
<h2 id='ensure_dll_df'>Ensure the data subitem of each component is a <code>data.frame</code> class object</h2><span id='topic+ensure_dll_df'></span>

<h3>Description</h3>

<p>Ensure the data subitem of each component is a <code>data.frame</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_dll_df(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensure_dll_df_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The provided dll with the data subitem of each component as a
data frame.
</p>

<hr>
<h2 id='esm_manhattan_plot'>Manhattan plot of feature-cluster association p-values</h2><span id='topic+esm_manhattan_plot'></span>

<h3>Description</h3>

<p>Manhattan plot of feature-cluster association p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esm_manhattan_plot(
  esm,
  neg_log_pval_thresh = 5,
  threshold = NULL,
  point_size = 5,
  jitter_width = 0.1,
  jitter_height = 0.1,
  text_size = 15,
  plot_title = NULL,
  hide_x_labels = FALSE,
  bonferroni_line = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="esm_manhattan_plot_+3A_esm">esm</code></td>
<td>
<p>Extended solutions data frame storing associations between features
and cluster assignments. See <code>?extend_solutions</code>.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_neg_log_pval_thresh">neg_log_pval_thresh</code></td>
<td>
<p>Threshold for negative log p-values.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_threshold">threshold</code></td>
<td>
<p>P-value threshold to plot dashed line at.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_point_size">point_size</code></td>
<td>
<p>Size of points in the plot.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_jitter_width">jitter_width</code></td>
<td>
<p>Width of jitter.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_jitter_height">jitter_height</code></td>
<td>
<p>Height of jitter.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_text_size">text_size</code></td>
<td>
<p>Size of text in the plot.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_plot_title">plot_title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_hide_x_labels">hide_x_labels</code></td>
<td>
<p>If TRUE, hides x-axis labels.</p>
</td></tr>
<tr><td><code id="esm_manhattan_plot_+3A_bonferroni_line">bonferroni_line</code></td>
<td>
<p>If TRUE, plots a dashed black line at the
Bonferroni-corrected equivalent of the p-value threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Manhattan plot (class &quot;gg&quot;, &quot;ggplot&quot;) showing the association
p-values of features against each solution in the provided solutions data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># full_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     list(anxiety, "anxiety", "behaviour", "ordinal"),
#     list(depress, "depressed", "behaviour", "ordinal"),
#     uid = "unique_id"
# )
# 
# dl &lt;- full_dl[1:3]
# target_dl &lt;- full_dl[4:5]
# 
# set.seed(42)
# sc &lt;- snf_config(
#     dl = dl,
#     n_solutions = 20,
#     min_k = 20,
#     max_k = 50
# )
# 
# sol_df &lt;- batch_snf(dl, sc)
# 
# ext_sol_df &lt;- extend_solutions(
#     sol_df,
#     dl = dl,
#     target = target_dl,
#     min_pval = 1e-10 # p-values below 1e-10 will be thresholded to 1e-10
# )
# 
# esm_manhattan &lt;- esm_manhattan_plot(
#     ext_sol_df[1:5, ],
#     neg_log_pval_thresh = 5,
#     threshold = 0.05,
#     point_size = 3,
#     jitter_width = 0.1,
#     jitter_height = 0.1,
#     plot_title = "Feature-Solution Associations",
#     text_size = 14,
#     bonferroni_line = TRUE
# )
</code></pre>

<hr>
<h2 id='estimate_nclust_given_graph'>Estimate number of clusters for a similarity matrix</h2><span id='topic+estimate_nclust_given_graph'></span>

<h3>Description</h3>

<p>Calculate eigengap and rotation-cost estimates of the number of clusters
to use when clustering a similarity matrix. This function was adapted
from <code>SNFtool::estimateClustersGivenGraph</code>, but scales up the Laplacian
operator prior to eigenvalue calculations to minimize the risk of
floating point-related errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_nclust_given_graph(W, NUMC = 2:10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_nclust_given_graph_+3A_w">W</code></td>
<td>
<p>Similarity matrix to calculate number of clusters for.</p>
</td></tr>
<tr><td><code id="estimate_nclust_given_graph_+3A_numc">NUMC</code></td>
<td>
<p>Range of cluster counts to consider among when picking best
number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the top two eigengap and rotation-cost estimates
for the number of clusters in a given similarity matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 1)
sol_df &lt;- batch_snf(input_dl, sc, return_sim_mats = TRUE)
sim_mat &lt;- sim_mats_list(sol_df)[[1]]
estimate_nclust_given_graph(sim_mat)
</code></pre>

<hr>
<h2 id='expression_df'>Modification of SNFtool mock data frame &quot;Data1&quot;</h2><span id='topic+expression_df'></span>

<h3>Description</h3>

<p>Modification of SNFtool mock data frame &quot;Data1&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expression_df
</code></pre>


<h3>Format</h3>



<h4><code>expression_df</code></h4>

<p>A data frame with 200 rows and 3 columns:
</p>

<dl>
<dt>gene_1_expression</dt><dd><p>Mock gene expression feature</p>
</dd>
<dt>gene_2_expression</dt><dd><p>Mock gene expression feature</p>
</dd>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='ext_solutions_df'>Constructor for <code>ext_solutions_df</code> class object.</h2><span id='topic+ext_solutions_df'></span>

<h3>Description</h3>

<p>The extended solutions data frame is a column-extended variation of the
solutions data frame. It contains association p-values relating cluster
membership to feature distribution for all solutions in a solutions data
frame and all features in a provided data list (or data lists). If a
target data list was used during the call to <code>extend_solutions</code>, the
extended solutions data frame will also have columns &quot;min_pval&quot;,
&quot;mean_pval&quot;, and &quot;max_pval&quot; summarizing the p-values of just those features
that were a part of the target list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext_solutions_df(ext_sol_dfl, sol_df, fts, target_dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext_solutions_df_+3A_ext_sol_dfl">ext_sol_dfl</code></td>
<td>
<p>An extended solutions data frame-like object.</p>
</td></tr>
<tr><td><code id="ext_solutions_df_+3A_sol_df">sol_df</code></td>
<td>
<p>Result of <code>batch_snf</code> storing cluster solutions and
the settings that were used to generate them.</p>
</td></tr>
<tr><td><code id="ext_solutions_df_+3A_fts">fts</code></td>
<td>
<p>A vector of all features that have association p-values stored
in the resulting extended solutions data frame.</p>
</td></tr>
<tr><td><code id="ext_solutions_df_+3A_target_dl">target_dl</code></td>
<td>
<p>A data list with features to calculate p-values for.
Features in the target list will be included during p-value summary
measure calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ext_solutions_df</code> class object.
</p>

<hr>
<h2 id='extend_solutions'>Extend a solutions data frame to include outcome evaluations</h2><span id='topic+extend_solutions'></span>

<h3>Description</h3>

<p>Extend a solutions data frame to include outcome evaluations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_solutions(
  sol_df,
  target_dl = NULL,
  dl = NULL,
  cat_test = "chi_squared",
  min_pval = 1e-10,
  processes = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_solutions_+3A_sol_df">sol_df</code></td>
<td>
<p>Result of <code>batch_snf</code> storing cluster solutions and
the settings that were used to generate them.</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_target_dl">target_dl</code></td>
<td>
<p>A data list with features to calculate p-values for.
Features in the target list will be included during p-value summary
measure calculations.</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_dl">dl</code></td>
<td>
<p>A data list with features to calcualte p-values for, but
that should not be incorporated into p-value summary measure columns (i.e.,
min/mean/max p-value columns).</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_cat_test">cat_test</code></td>
<td>
<p>String indicating which statistical test will be used to
associate cluster with a categorical feature. Options are &quot;chi_squared&quot; for
the Chi-squared test and &quot;fisher_exact&quot; for Fisher's exact test.</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_min_pval">min_pval</code></td>
<td>
<p>If assigned a value, any p-value less than this will be
replaced with this value.</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_processes">processes</code></td>
<td>
<p>The number of processes to use for parallelization.
Progress is only reported for sequential processing (processes = 1).</p>
</td></tr>
<tr><td><code id="extend_solutions_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extended solutions data frame (<code>ext_sol_df</code> class object)
that contains p-value columns for each outcome in the provided data lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 2)

sol_df &lt;- batch_snf(input_dl, sc)

ext_sol_df &lt;- extend_solutions(sol_df, input_dl)
</code></pre>

<hr>
<h2 id='fav_colour'>Mock ABCD &quot;colour&quot; data</h2><span id='topic+fav_colour'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_colour&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fav_colour
</code></pre>


<h3>Format</h3>



<h4><code>fav_colour</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>colour</dt><dd><p>Categorical transformation of <code>cbcl_depress</code>.</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='features'>Return character vector of features stored in an object</h2><span id='topic+features'></span>

<h3>Description</h3>

<p>Return character vector of features stored in an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="features_+3A_x">x</code></td>
<td>
<p>The object to pull features from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of features in x.
</p>

<hr>
<h2 id='fisher_exact_pval'>Fisher exact test p-value</h2><span id='topic+fisher_exact_pval'></span>

<h3>Description</h3>

<p>Return p-value for Fisher exact test for any two features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher_exact_pval(cat_var1, cat_var2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher_exact_pval_+3A_cat_var1">cat_var1</code></td>
<td>
<p>A categorical feature.</p>
</td></tr>
<tr><td><code id="fisher_exact_pval_+3A_cat_var2">cat_var2</code></td>
<td>
<p>A categorical feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval A p-value (class &quot;numeric&quot;).
</p>

<hr>
<h2 id='gender_df'>Mock gender data</h2><span id='topic+gender_df'></span>

<h3>Description</h3>

<p>Mock gender data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gender_df
</code></pre>


<h3>Format</h3>



<h4><code>gender_df</code></h4>

<p>A data frame with 200 rows and 2 columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
<dt>gender_df</dt><dd><p>Mock gene methylation feature</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='generate_annotations_list'>Generate annotations list</h2><span id='topic+generate_annotations_list'></span>

<h3>Description</h3>

<p>Intermediate function that takes in formatted lists of features and the
annotations they should be viewed through and returns annotation objects
usable by ComplexHeatmap::Heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_annotations_list(
  df,
  left_bar = NULL,
  right_bar = NULL,
  top_bar = NULL,
  bottom_bar = NULL,
  left_hm = NULL,
  right_hm = NULL,
  top_hm = NULL,
  bottom_hm = NULL,
  show_legend = TRUE,
  annotation_colours = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_annotations_list_+3A_df">df</code></td>
<td>
<p>data frame containing all the data that is specified in the
remaining arguments.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_left_bar">left_bar</code></td>
<td>
<p>Named list of strings, where the strings are features in
df that should be used for a barplot annotation on the left of the plot and
the names are the names that will be used to caption the plots and their
legends.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_right_bar">right_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_top_bar">top_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_bottom_bar">bottom_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_left_hm">left_hm</code></td>
<td>
<p>Like left_bar, but with a heatmap annotation instead of a
barplot annotation.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_right_hm">right_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_top_hm">top_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_bottom_hm">bottom_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_show_legend">show_legend</code></td>
<td>
<p>Add legends to the annotations.</p>
</td></tr>
<tr><td><code id="generate_annotations_list_+3A_annotation_colours">annotation_colours</code></td>
<td>
<p>Named list of heatmap annotations and their
colours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>annotations_list A named list of all the annotations.
</p>

<hr>
<h2 id='generate_clust_algs_list'>Generate a clustering algorithms list</h2><span id='topic+generate_clust_algs_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building a clustering algorithms list. Please use
<code>clust_fns_list()</code> (or better yet, <code>snf_config()</code>) instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_clust_algs_list(..., disable_base = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_clust_algs_list_+3A_...">...</code></td>
<td>
<p>An arbitrary number of named clustering functions</p>
</td></tr>
<tr><td><code id="generate_clust_algs_list_+3A_disable_base">disable_base</code></td>
<td>
<p>If TRUE, do not prepend the base clustering algorithms
(spectral_eigen and spectral_rot, which apply spectral clustering and use
the eigen-gap and rotation cost heuristics respectively for determining
the number of clusters in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering algorithm functions that can
be passed into the batch_snf and generate_settings_list functions.
</p>

<hr>
<h2 id='generate_distance_metrics_list'>Generate a list of distance metrics</h2><span id='topic+generate_distance_metrics_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building a distance metrics list. Please use
<code>dist_fns_list()</code> (or better yet, <code>snf_config()</code>) instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_distance_metrics_list(
  continuous_distances = NULL,
  discrete_distances = NULL,
  ordinal_distances = NULL,
  categorical_distances = NULL,
  mixed_distances = NULL,
  keep_defaults = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_distance_metrics_list_+3A_continuous_distances">continuous_distances</code></td>
<td>
<p>A named list of distance metric functions</p>
</td></tr>
<tr><td><code id="generate_distance_metrics_list_+3A_discrete_distances">discrete_distances</code></td>
<td>
<p>A named list of distance metric functions</p>
</td></tr>
<tr><td><code id="generate_distance_metrics_list_+3A_ordinal_distances">ordinal_distances</code></td>
<td>
<p>A named list of distance metric functions</p>
</td></tr>
<tr><td><code id="generate_distance_metrics_list_+3A_categorical_distances">categorical_distances</code></td>
<td>
<p>A named list of distance metric functions</p>
</td></tr>
<tr><td><code id="generate_distance_metrics_list_+3A_mixed_distances">mixed_distances</code></td>
<td>
<p>A named list of distance metric functions</p>
</td></tr>
<tr><td><code id="generate_distance_metrics_list_+3A_keep_defaults">keep_defaults</code></td>
<td>
<p>If TRUE (default), prepend the base distance metrics
(euclidean and standard normalized euclidean)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested and named list of distance metrics functions.
</p>

<hr>
<h2 id='generate_settings_matrix'>Build a settings data frame</h2><span id='topic+generate_settings_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building a settings matrix. Please use
<code>settings_df()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_settings_matrix(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_settings_matrix_+3A_...">...</code></td>
<td>
<p>Arguments used to generate a settings matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises a deprecated error.
</p>

<hr>
<h2 id='get_cluster_df'>Extract cluster membership information from one solutions data frame row</h2><span id='topic+get_cluster_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building extracting cluster solutions from a
solutions data frame. Please use <code>t()</code> instead.
</p>
<p>This function takes in a single row of a solutions data frame and returns a
data frame containing the cluster assignments for each uid. It is
similar to <code>get_clusters()</code>, which takes one solutions data frame row and
returns a vector of cluster assignments' and <code>get_cluster_solutions()</code>,
which takes a solutions data frame with any number of rows and returns a
data frame indicating the cluster assignments for each of those rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cluster_df(sol_df_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cluster_df_+3A_sol_df_row">sol_df_row</code></td>
<td>
<p>One row from a solutions data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cluster_df data frame of cluster and uid.
</p>

<hr>
<h2 id='get_cluster_solutions'>Extract cluster membership information from a sol_df</h2><span id='topic+get_cluster_solutions'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building extracting cluster solutions from a
solutions data frame. Please use <code>t()</code> instead.
</p>
<p>This function takes in a solutions data frame and returns a data frame containing
the cluster assignments for each uid. It is similar to
'<code>get_clusters()</code>, which takes one solutions data frame row and returns a vector
of cluster assignments' and <code>get_cluster_df()</code>, which takes a solutions
matrix with only one row and returns a data frame with two columns: &quot;cluster&quot;
and &quot;uid&quot; (the UID of the observation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cluster_solutions(sol_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cluster_solutions_+3A_sol_df">sol_df</code></td>
<td>
<p>A sol_df.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;data.frame&quot; object where each row is an
observation and each column (apart from the uid column) indicates
the cluster that observation was assigned to for the corresponding
solutions data frame row.
</p>

<hr>
<h2 id='get_clusters'>Extract cluster membership vector from one solutions data frame row</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for building extracting cluster solutions from a
solutions data frame. Please use <code>t()</code> instead.
</p>
<p>This function takes in a single row of a solutions data frame and returns a
vector containing the cluster assignments for each observation. It is
similar to <code>get_cluster_df()</code>, which takes a solutions data frame with only one
row and returns a data frame with two columns: &quot;cluster&quot; and &quot;uid&quot;
'(the UID of the observation) and <code>get_cluster_solutions()</code>, which takes a
solutions data frame with any number of rows and returns a data frame indicating
the cluster assignments for each of those rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(sol_df_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_clusters_+3A_sol_df_row">sol_df_row</code></td>
<td>
<p>Output matrix row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clusters Vector of assigned clusters.
</p>

<hr>
<h2 id='get_complete_uids'>Pull complete-data UIDs from a list of data frames</h2><span id='topic+get_complete_uids'></span>

<h3>Description</h3>

<p>This function identifies all observations within a list of data frames that
have no missing data across all data frames. This function is useful when
constructing data lists of distinct feature sets from the same sample of
observations. As <code>data_list()</code> strips away observations with any missing
data, distinct sets of observations may be generated by building a data
list from the same group of observations over different sets of features.
Reducing the pool of observations to only those with complete UIDs first
will avoid downstream generation of data lists of differing sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_complete_uids(list_of_dfs, uid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_complete_uids_+3A_list_of_dfs">list_of_dfs</code></td>
<td>
<p>List of data frames.</p>
</td></tr>
<tr><td><code id="get_complete_uids_+3A_uid">uid</code></td>
<td>
<p>Name of column across data frames containing UIDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the UIDs of observations that have complete
data across the provided list of data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>complete_uids &lt;- get_complete_uids(
    list(income, pubertal, anxiety, depress),
    uid = "unique_id"
)

income &lt;- income[income$"unique_id" %in% complete_uids, ]
pubertal &lt;- pubertal[pubertal$"unique_id" %in% complete_uids, ]
anxiety &lt;- anxiety[anxiety$"unique_id" %in% complete_uids, ]
depress &lt;- depress[depress$"unique_id" %in% complete_uids, ]

input_dl &lt;- data_list(
    list(income, "income", "demographics", "ordinal"),
    list(pubertal, "pubertal", "demographics", "continuous"),
    uid = "unique_id"
)

target_dl &lt;- data_list(
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)
</code></pre>

<hr>
<h2 id='get_dist_matrix'>Calculate distance matrices</h2><span id='topic+get_dist_matrix'></span>

<h3>Description</h3>

<p>Given a data frame of numerical features, return a euclidean distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_matrix(
  df,
  input_type,
  cnt_dist_fn,
  dsc_dist_fn,
  ord_dist_fn,
  cat_dist_fn,
  mix_dist_fn,
  weights_row
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_matrix_+3A_df">df</code></td>
<td>
<p>Raw data frame with subject IDs in column &quot;uid&quot;</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_input_type">input_type</code></td>
<td>
<p>Either &quot;numeric&quot; (resulting in euclidean distances),
&quot;categorical&quot; (resulting in binary distances), or &quot;mixed&quot; (resulting in
gower distances)</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_cnt_dist_fn">cnt_dist_fn</code></td>
<td>
<p>distance metric function for continuous data</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_dsc_dist_fn">dsc_dist_fn</code></td>
<td>
<p>distance metric function for discrete data</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_ord_dist_fn">ord_dist_fn</code></td>
<td>
<p>distance metric function for ordinal data</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_cat_dist_fn">cat_dist_fn</code></td>
<td>
<p>distance metric function for categorical data</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_mix_dist_fn">mix_dist_fn</code></td>
<td>
<p>distance metric function for mixed data</p>
</td></tr>
<tr><td><code id="get_dist_matrix_+3A_weights_row">weights_row</code></td>
<td>
<p>Single-row data frame where the column names contain the
column names in df and the row contains the corresponding weights_row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dist_matrix Matrix of inter-observation distances.
</p>

<hr>
<h2 id='get_dl_uids'>Extract UIDs from a data list</h2><span id='topic+get_dl_uids'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated function for extracting UIDs from a data list.
Please use <code>uids()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dl_uids(dl, prefix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dl_uids_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="get_dl_uids_+3A_prefix">prefix</code></td>
<td>
<p>If TRUE, preserves the &quot;uid_&quot; prefix added to UIDs when
creating a data list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the UID labels contained in a data list.
</p>

<hr>
<h2 id='get_heatmap_order'>Return the row or column ordering present in a heatmap</h2><span id='topic+get_heatmap_order'></span>

<h3>Description</h3>

<p>Return the row or column ordering present in a heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_heatmap_order(heatmap, type = "rows")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_heatmap_order_+3A_heatmap">heatmap</code></td>
<td>
<p>A heatmap object to collect ordering from.</p>
</td></tr>
<tr><td><code id="get_heatmap_order_+3A_type">type</code></td>
<td>
<p>The type of ordering to return. Either &quot;rows&quot; or &quot;columns&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the ordering used within the provided
ComplexHeatmap &quot;Heatmap&quot; object.
</p>

<hr>
<h2 id='get_matrix_order'>Return the hierarchical clustering order of a matrix</h2><span id='topic+get_matrix_order'></span>

<h3>Description</h3>

<p>Return the hierarchical clustering order of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_matrix_order(matrix, dist_method = "euclidean", hclust_method = "complete")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_matrix_order_+3A_matrix">matrix</code></td>
<td>
<p>Matrix to cluster.</p>
</td></tr>
<tr><td><code id="get_matrix_order_+3A_dist_method">dist_method</code></td>
<td>
<p>Distance method to use when calculating sorting order to
of the matrix. Argument is directly passed into stats::dist. Options
include &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, or
&quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="get_matrix_order_+3A_hclust_method">hclust_method</code></td>
<td>
<p>Agglomerative method to use when calculating sorting
order by <code>stats::hclust</code>. Options include &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, or &quot;centroid&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the ordering derivied by the specified
hierarchical clustering method applied to the provided matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     list(anxiety, "anxiety", "behaviour", "ordinal"),
#     list(depress, "depressed", "behaviour", "ordinal"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(
#     dl = dl,
#     n_solutions = 20,
#     min_k = 20,
#     max_k = 50
# )
# 
# sol_df &lt;- batch_snf(dl, sc)
# 
# ext_sol_df &lt;- extend_solutions(
#     sol_df,
#     dl = dl,
#     min_pval = 1e-10 # p-values below 1e-10 will be thresholded to 1e-10
# )
# 
# # Calculate pairwise similarities between cluster solutions
# sol_aris &lt;- calc_aris(sol_df)
# 
# # Extract hierarchical clustering order of the cluster solutions
# meta_cluster_order &lt;- get_matrix_order(sol_aris)
</code></pre>

<hr>
<h2 id='get_mean_pval'>Get mean p-value</h2><span id='topic+get_mean_pval'></span>

<h3>Description</h3>

<p>Given an solutions data frame row containing evaluated p-values, returns mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mean_pval(sol_df_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mean_pval_+3A_sol_df_row">sol_df_row</code></td>
<td>
<p>row of sol_df object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean_pval mean p-value
</p>

<hr>
<h2 id='get_min_pval'>Get minimum p-value</h2><span id='topic+get_min_pval'></span>

<h3>Description</h3>

<p>Given an solutions data frame row containing evaluated p-values, returns min.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_min_pval(sol_df_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_min_pval_+3A_sol_df_row">sol_df_row</code></td>
<td>
<p>row of sol_df object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>min_pval minimum p-value
</p>

<hr>
<h2 id='get_pvals'>Get p-values from an extended solutions data frame</h2><span id='topic+get_pvals'></span>

<h3>Description</h3>

<p>This function can be used to neatly format the p-values associated with an
extended solutions data frame. It can also calculate the negative logs of those
p-values to make it easier to interpret large-scale differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pvals(ext_sol_df, negative_log = FALSE, keep_summaries = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pvals_+3A_ext_sol_df">ext_sol_df</code></td>
<td>
<p>The output of <code>extend_solutions</code>. A
data frame that contains at least one p-value column ending in &quot;_pval&quot;.</p>
</td></tr>
<tr><td><code id="get_pvals_+3A_negative_log">negative_log</code></td>
<td>
<p>If TRUE, will replace p-values with negative log
p-values.</p>
</td></tr>
<tr><td><code id="get_pvals_+3A_keep_summaries">keep_summaries</code></td>
<td>
<p>If FALSE, will remove the mean, min, and max p-value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;data.frame&quot; class object Of only the p-value related columns
of the provided ext_sol_df.
</p>

<hr>
<h2 id='get_representative_solutions'>Extract representative solutions from a matrix of ARIs</h2><span id='topic+get_representative_solutions'></span>

<h3>Description</h3>

<p>Following clustering with <code>batch_snf</code>, a matrix of pairwise ARIs that show
how related each cluster solution is to each other can be generated by the
<code>calc_aris</code> function. Partitioning of the ARI matrix can be done by
visual inspection of <code>meta_cluster_heatmap()</code> results or by
<code>shiny_annotator</code>. Given the indices of meta cluster boundaries, this
function will return a single representative solution from each meta cluster
based on maximum average ARI to all other solutions within that meta
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_representative_solutions(aris, sol_df, filter_fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_representative_solutions_+3A_aris">aris</code></td>
<td>
<p>Matrix of adjusted rand indices from <code>calc_aris()</code></p>
</td></tr>
<tr><td><code id="get_representative_solutions_+3A_sol_df">sol_df</code></td>
<td>
<p>Output of <code>batch_snf</code> containing cluster solutions.</p>
</td></tr>
<tr><td><code id="get_representative_solutions_+3A_filter_fn">filter_fn</code></td>
<td>
<p>Optional function to filter the meta-cluster by prior to
maximum average ARI determination. This can be useful if you are explicitly
trying to select a solution that meets a certain condition, such as only
picking from the 4 cluster solutions within a meta cluster. An example
valid function could be <code>fn &lt;- function(x) x[x$"nclust" == 4, ]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The provided solutions data frame reduced to just one row per meta
cluster defined by the split vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     list(anxiety, "anxiety", "behaviour", "ordinal"),
#     list(depress, "depressed", "behaviour", "ordinal"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(
#     dl = dl,
#     n_solutions = 20,
#     min_k = 20,
#     max_k = 50
# )
# 
# sol_df &lt;- batch_snf(dl, sc)
# 
# ext_sol_df &lt;- extend_solutions(
#     sol_df,
#     dl = dl,
#     min_pval = 1e-10 # p-values below 1e-10 will be thresholded to 1e-10
# )
# 
# # Calculate pairwise similarities between cluster solutions
# sol_aris &lt;- calc_aris(sol_df)
# 
# # Extract hierarchical clustering order of the cluster solutions
# meta_cluster_order &lt;- get_matrix_order(sol_aris)
# 
# # Identify meta cluster boundaries with shiny app or trial and error
# # ari_hm &lt;- meta_cluster_heatmap(sol_aris, order = meta_cluster_order)
# # shiny_annotator(ari_hm)
# 
# # Result of meta cluster examination
# split_vec &lt;- c(2, 5, 12, 17)
# 
# ext_sol_df &lt;- label_meta_clusters(ext_sol_df, split_vec, meta_cluster_order)
# 
# # Extracting representative solutions from each defined meta cluster
# rep_solutions &lt;- get_representative_solutions(sol_aris, ext_sol_df)
</code></pre>

<hr>
<h2 id='gexclude'>Helper function to drop columns from a data frame by grepl search</h2><span id='topic+gexclude'></span>

<h3>Description</h3>

<p>Helper function to drop columns from a data frame by grepl search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gexclude(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gexclude_+3A_x">x</code></td>
<td>
<p>Data frame to drop columns from.</p>
</td></tr>
<tr><td><code id="gexclude_+3A_pattern">pattern</code></td>
<td>
<p>Pattern used to match columns to drop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x without columns matching pattern.
</p>

<hr>
<h2 id='gselect'>Helper function to pick columns from a data frame by grepl search</h2><span id='topic+gselect'></span>

<h3>Description</h3>

<p>Helper function to pick columns from a data frame by grepl search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gselect(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gselect_+3A_x">x</code></td>
<td>
<p>Data frame to select columns from.</p>
</td></tr>
<tr><td><code id="gselect_+3A_pattern">pattern</code></td>
<td>
<p>Pattern used to match columns to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with only columns matching pattern.
</p>

<hr>
<h2 id='income'>Mock ABCD income data</h2><span id='topic+income'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_h_income&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>
<p>Like the mock data frame &quot;abcd_cort_sa&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>income

income
</code></pre>


<h3>Format</h3>



<h4><code>income</code></h4>

<p>A data frame with 300 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>household_income</dt><dd><p>Household income in 3 category levels (low = 1, medium = 2, high = 3)</p>
</dd>
</dl>




<h4><code>income</code></h4>

<p>A data frame with 300 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>household_income</dt><dd><p>Household income in 3 category levels (low = 1, medium = 2, high = 3)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>
<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='is_data_list'>Test if the object is a data list</h2><span id='topic+is_data_list'></span>

<h3>Description</h3>

<p>Given an object, returns <code>TRUE</code> if that object inherits from the <code>data_list</code>
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_data_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_data_list_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from the <code>data_list</code> class.
</p>

<hr>
<h2 id='jitter_plot'>Jitter plot separating a feature by cluster</h2><span id='topic+jitter_plot'></span>

<h3>Description</h3>

<p>Jitter plot separating a feature by cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jitter_plot(df, feature)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jitter_plot_+3A_df">df</code></td>
<td>
<p>A data.frame containing cluster column and the feature to plot.</p>
</td></tr>
<tr><td><code id="jitter_plot_+3A_feature">feature</code></td>
<td>
<p>The feature to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A jitter+violin plot (class &quot;gg&quot;, &quot;ggplot&quot;) showing the
distribution of a feature across clusters.
</p>

<hr>
<h2 id='label_meta_clusters'>Assign meta cluster labels to rows of a solutions data frame or extended
solutions data frame</h2><span id='topic+label_meta_clusters'></span>

<h3>Description</h3>

<p>Given a solutions data frame or extended solutions data frame class object
and a numeric vector indicating which rows correspond to which meta
clusters, assigns meta clustering information to the &quot;meta_clusters&quot;
attribute of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_meta_clusters(sol_df, split_vector, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_meta_clusters_+3A_sol_df">sol_df</code></td>
<td>
<p>A solutions data frame or extended solutions data frame to
assign meta clusters to.</p>
</td></tr>
<tr><td><code id="label_meta_clusters_+3A_split_vector">split_vector</code></td>
<td>
<p>A numeric vector indicating which rows of sol_df should
be the split points for meta cluster labeling.</p>
</td></tr>
<tr><td><code id="label_meta_clusters_+3A_order">order</code></td>
<td>
<p>An optional numeric vector indicating how the solutions data
frame should be reordered prior to meta cluster labeling. This vector can
be obtained by running <code>get_matrix_order()</code> on an ARI matrix, which itself
can be obtained by calling <code>calc_aris()</code> on a solutions data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solutions data frame with a populated &quot;meta_clusters&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dl &lt;- data_list(
#    list(cort_sa, "cortical_surface_area", "neuroimaging", "continuous"),
#    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#    list(income, "household_income", "demographics", "continuous"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    uid = "unique_id"
#)
#
#set.seed(42)
#my_sc &lt;- snf_config(
#    dl = dl,
#    n_solutions = 20,
#    min_k = 20,
#    max_k = 50
#)
#
#sol_df &lt;- batch_snf(dl, my_sc)
#
#sol_df
#
#sol_aris &lt;- calc_aris(sol_df)
#
#meta_cluster_order &lt;- get_matrix_order(sol_aris)
#
## `split_vec` found by iteratively plotting ari_hm or by ?shiny_annotator()
#split_vec &lt;- c(6, 10, 16)
#ari_hm &lt;- meta_cluster_heatmap(
#    sol_aris,
#    order = meta_cluster_order,
#    split_vector = split_vec
#)
#
#mc_sol_df &lt;- label_meta_clusters(
#    sol_df,
#    order = meta_cluster_order,
#    split_vector = split_vec
#)
#
#mc_sol_df
</code></pre>

<hr>
<h2 id='label_prop'>Label propagation</h2><span id='topic+label_prop'></span>

<h3>Description</h3>

<p>Given a full fused network (one containing both pre-clustered observations
and to-be-clustered observations) and the clusters of the pre-clustered
observations, return a label propagated list of clusters for all observations.
This function is derived from SNFtool::groupPredict. Modifications are made
to take a full fused network as input, rather than taking input data frames
and running SNF internally. This ensures that alternative approaches to
data normalization and distance matrix calculations can be chosen by the
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_prop(full_fused_network, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_prop_+3A_full_fused_network">full_fused_network</code></td>
<td>
<p>A network made by running SNF on training and test
observations together.</p>
</td></tr>
<tr><td><code id="label_prop_+3A_clusters">clusters</code></td>
<td>
<p>A vector of assigned clusters for training observations in
matching order as they appear in full_fused_network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cluster labels for all observations.
</p>

<hr>
<h2 id='label_propagate'>Label propagate cluster solutions to unclustered observations</h2><span id='topic+label_propagate'></span>

<h3>Description</h3>

<p>Given a solutions data frame containing clustered observations and a
data list containing those clustered observations as well as additional
to-be-clustered observations, this function will re-run SNF to generate a
similarity matrix of all observations and use the label propagation
algorithm to assigned predicted clusters to the unclustered observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_propagate(partial_sol_df, full_dl, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_propagate_+3A_partial_sol_df">partial_sol_df</code></td>
<td>
<p>A solutions data frame derived from the training set.</p>
</td></tr>
<tr><td><code id="label_propagate_+3A_full_dl">full_dl</code></td>
<td>
<p>A data list containing observations from both the training
and testing sets.</p>
</td></tr>
<tr><td><code id="label_propagate_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per observation containing a column for
UIDs, a column for whether the observation was in the train (original) or test
(held out) set, and one column per row of the solutions data frame
indicating the original and propagated clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Function to identify obervations with complete data
#uids_with_complete_obs &lt;- get_complete_uids(
#    list(subc_v, income, pubertal, anxiety, depress),
#    uid = "unique_id"
#)
#
## Dataframe assigning 80% of observations to train and 20% to test
#train_test_split &lt;- train_test_assign(
#    train_frac = 0.8,
#    uids = uids_with_complete_obs
#)
#
## Pulling the training and testing observations specifically
#train_obs &lt;- train_test_split$"train"
#test_obs &lt;- train_test_split$"test"
#
## Partition a training set
#train_subc_v &lt;- subc_v[subc_v$"unique_id" %in% train_obs, ]
#train_income &lt;- income[income$"unique_id" %in% train_obs, ]
#train_pubertal &lt;- pubertal[pubertal$"unique_id" %in% train_obs, ]
#train_anxiety &lt;- anxiety[anxiety$"unique_id" %in% train_obs, ]
#train_depress &lt;- depress[depress$"unique_id" %in% train_obs, ]
#
## Partition a test set
#test_subc_v &lt;- subc_v[subc_v$"unique_id" %in% test_obs, ]
#test_income &lt;- income[income$"unique_id" %in% test_obs, ]
#test_pubertal &lt;- pubertal[pubertal$"unique_id" %in% test_obs, ]
#test_anxiety &lt;- anxiety[anxiety$"unique_id" %in% test_obs, ]
#test_depress &lt;- depress[depress$"unique_id" %in% test_obs, ]
#
## Find cluster solutions in the training set
#train_dl &lt;- data_list(
#    list(train_subc_v, "subc_v", "neuroimaging", "continuous"),
#    list(train_income, "household_income", "demographics", "continuous"),
#    list(train_pubertal, "pubertal_status", "demographics", "continuous"),
#    uid = "unique_id"
#)
#
## We'll pick a solution that has good separation over our target features
#train_target_dl &lt;- data_list(
#    list(train_anxiety, "anxiety", "behaviour", "ordinal"),
#    list(train_depress, "depressed", "behaviour", "ordinal"),
#    uid = "unique_id"
#)
#
#sc &lt;- snf_config(
#    train_dl,
#    n_solutions = 5,
#    min_k = 10,
#    max_k = 30
#)
#
#train_sol_df &lt;- batch_snf(
#    train_dl,
#    sc,
#    return_sim_mats = TRUE
#)
#
#ext_sol_df &lt;- extend_solutions(
#    train_sol_df,
#    train_target_dl
#)
#
## Determining solution with the lowest minimum p-value
#lowest_min_pval &lt;- min(ext_sol_df$"min_pval")
#which(ext_sol_df$"min_pval" == lowest_min_pval)
#top_row &lt;- ext_sol_df[1, ]
#
## Propagate that solution to the observations in the test set
## data list below has both training and testing observations
#full_dl &lt;- data_list(
#    list(subc_v, "subc_v", "neuroimaging", "continuous"),
#    list(income, "household_income", "demographics", "continuous"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    uid = "unique_id"
#)
#
## Use the solutions data frame from the training observations and the data list
## from the training and testing observations to propagate labels to the test observations
#propagated_labels &lt;- label_propagate(top_row, full_dl)
#
#propagated_labels_all &lt;- label_propagate(ext_sol_df, full_dl)
#
#head(propagated_labels_all)
#tail(propagated_labels_all)
</code></pre>

<hr>
<h2 id='label_splits'>Convert a vector of partition indices into meta cluster labels</h2><span id='topic+label_splits'></span>

<h3>Description</h3>

<p>Convert a vector of partition indices into meta cluster labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_splits(split_vector, nrow)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_splits_+3A_split_vector">split_vector</code></td>
<td>
<p>A vector of partition indices.</p>
</td></tr>
<tr><td><code id="label_splits_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows in the data being partitioned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector that expands the split_vector into an nrow-length
sequence of ascending letters of the alphabet. If the split vector is
c(3, 6) and the number of rows is 8, the result will be a vector of two
&quot;A&quot;s (up to the first index, 3), three &quot;B&quot;s (up to the second index, 6),
and three &quot;C&quot;s (up to and including the last index, 8).
</p>

<hr>
<h2 id='linear_adjust'>Linearly correct data list by features with unwanted signal</h2><span id='topic+linear_adjust'></span>

<h3>Description</h3>

<p>Given a data list to correct and another data list of categorical features
to linearly adjust for, corrects the first data list based on the residuals
of the linear model relating the numeric features in the first data list
to the unwanted signal features in the second data list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_adjust(dl, unwanted_signal_list, sig_digs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_adjust_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="linear_adjust_+3A_unwanted_signal_list">unwanted_signal_list</code></td>
<td>
<p>A data list of categorical features that should
have their mean differences removed in the first data list.</p>
</td></tr>
<tr><td><code id="linear_adjust_+3A_sig_digs">sig_digs</code></td>
<td>
<p>Number of significant digits to round the residuals to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data list (&quot;list&quot;) in which each data component has been converted
to contain residuals off of the linear model built against the features in
the unwanted_signal_list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_tutor &lt;- sample(c(1, 0), size = 9, replace = TRUE)
math_score &lt;- 70 + 30 * has_tutor + rnorm(9, mean = 0, sd = 5)

math_df &lt;- data.frame(uid = paste0("id_", 1:9), math = math_score)
tutor_df &lt;- data.frame(uid = paste0("id_", 1:9), tutor = has_tutor)

dl &lt;- data_list(
    list(math_df, "math_score", "school", "continuous"),
    uid = "uid"
)

adjustment_dl &lt;- data_list(
    list(tutor_df, "tutoring", "school", "categorical"),
    uid = "uid"
)

adjusted_dl &lt;- linear_adjust(dl, adjustment_dl)

adjusted_dl[[1]]$"data"$"math"

# Equivalent to:
as.numeric(resid(lm(math_score ~ has_tutor)))
</code></pre>

<hr>
<h2 id='linear_model_pval'>Linear model p-value (generic)</h2><span id='topic+linear_model_pval'></span>

<h3>Description</h3>

<p>Return p-value of F-test for a linear model of any two features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_model_pval(predictor, response)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_model_pval_+3A_predictor">predictor</code></td>
<td>
<p>A categorical or numeric feature.</p>
</td></tr>
<tr><td><code id="linear_model_pval_+3A_response">response</code></td>
<td>
<p>A numeric feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval A p-value (class &quot;numeric&quot;).
</p>

<hr>
<h2 id='mc_manhattan_plot'>Manhattan plot of feature-meta cluster associaiton p-values</h2><span id='topic+mc_manhattan_plot'></span>

<h3>Description</h3>

<p>Given a data frame of representative meta cluster solutions (see
<code>get_representative_solutions()</code>, returns a Manhattan plot for showing
feature separation across all features in provided data/target lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_manhattan_plot(
  ext_sol_df,
  dl = NULL,
  target_dl = NULL,
  variable_order = NULL,
  neg_log_pval_thresh = 5,
  threshold = NULL,
  point_size = 5,
  text_size = 20,
  plot_title = NULL,
  xints = NULL,
  hide_x_labels = FALSE,
  domain_colours = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_manhattan_plot_+3A_ext_sol_df">ext_sol_df</code></td>
<td>
<p>A sol_df that contains &quot;_pval&quot;
columns containing the values to be plotted. This object is the output of
<code>extend_solutions()</code>.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_dl">dl</code></td>
<td>
<p>List of data frames containing data information.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_target_dl">target_dl</code></td>
<td>
<p>List of data frames containing target information.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_variable_order">variable_order</code></td>
<td>
<p>Order of features to be displayed in the plot.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_neg_log_pval_thresh">neg_log_pval_thresh</code></td>
<td>
<p>Threshold for negative log p-values.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_threshold">threshold</code></td>
<td>
<p>p-value threshold to plot horizontal dashed line at.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_point_size">point_size</code></td>
<td>
<p>Size of points in the plot.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_text_size">text_size</code></td>
<td>
<p>Size of text in the plot.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_plot_title">plot_title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_xints">xints</code></td>
<td>
<p>Either &quot;outcomes&quot; or a vector of numeric values to plot
vertical lines at.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_hide_x_labels">hide_x_labels</code></td>
<td>
<p>If TRUE, hides x-axis labels.</p>
</td></tr>
<tr><td><code id="mc_manhattan_plot_+3A_domain_colours">domain_colours</code></td>
<td>
<p>Named vector of colours for domains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Manhattan plot (class &quot;gg&quot;, &quot;ggplot&quot;) showing the association
p-values of features against each solution in the provided solutions data frame,
stratified by meta cluster label.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     list(anxiety, "anxiety", "behaviour", "ordinal"),
#     list(depress, "depressed", "behaviour", "ordinal"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(
#     dl = dl,
#     n_solutions = 20,
#     min_k = 20,
#     max_k = 50
# )
# 
# sol_df &lt;- batch_snf(dl, sc)
# 
# ext_sol_df &lt;- extend_solutions(
#     sol_df,
#     dl = dl,
#     min_pval = 1e-10 # p-values below 1e-10 will be thresholded to 1e-10
# )
# 
# # Calculate pairwise similarities between cluster solutions
# sol_aris &lt;- calc_aris(sol_df)
# 
# # Extract hierarchical clustering order of the cluster solutions
# meta_cluster_order &lt;- get_matrix_order(sol_aris)
# 
# # Identify meta cluster boundaries with shiny app or trial and error
# # ari_hm &lt;- meta_cluster_heatmap(sol_aris, order = meta_cluster_order)
# # shiny_annotator(ari_hm)
# 
# # Result of meta cluster examination
# split_vec &lt;- c(2, 5, 12, 17)
# 
# ext_sol_df &lt;- label_meta_clusters(ext_sol_df, split_vec, meta_cluster_order)
# 
# # Extracting representative solutions from each defined meta cluster
# rep_solutions &lt;- get_representative_solutions(sol_aris, ext_sol_df)
# 
# mc_manhattan &lt;- mc_manhattan_plot(
#     rep_solutions,
#     dl = dl,
#     point_size = 3,
#     text_size = 12,
#     plot_title = "Feature-Meta Cluster Associations",
#     threshold = 0.05,
#     neg_log_pval_thresh = 5
# )
# 
# mc_manhattan
</code></pre>

<hr>
<h2 id='merge_df_list'>Merge list of data frames into a single data frame</h2><span id='topic+merge_df_list'></span>

<h3>Description</h3>

<p>This helper function combines all data frames in a single-level list into a
single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_df_list(df_list, join = "inner", uid = "uid", no_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_df_list_+3A_df_list">df_list</code></td>
<td>
<p>list of data frames.</p>
</td></tr>
<tr><td><code id="merge_df_list_+3A_join">join</code></td>
<td>
<p>String indicating if join should be &quot;inner&quot; or &quot;full&quot;.</p>
</td></tr>
<tr><td><code id="merge_df_list_+3A_uid">uid</code></td>
<td>
<p>Column name to join on. Default is &quot;uid&quot;.</p>
</td></tr>
<tr><td><code id="merge_df_list_+3A_no_na">no_na</code></td>
<td>
<p>Whether to remove NA values from the merged data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inner join of all data frames in list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>merge_df_list(list(income, pubertal), uid = "unique_id")
</code></pre>

<hr>
<h2 id='merge_dls'>Horizontally merge compatible data lists</h2><span id='topic+merge_dls'></span>

<h3>Description</h3>

<p>Join two data lists with the same components (data frames) but separate
observations. To instead merge two data lists that have the same
observations but different components, simply use <code>c()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_dls(dl_1, dl_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_dls_+3A_dl_1">dl_1</code></td>
<td>
<p>The first data list to merge.</p>
</td></tr>
<tr><td><code id="merge_dls_+3A_dl_2">dl_2</code></td>
<td>
<p>The second data list to merge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data list (&quot;list&quot;-class object) containing the observations of
both provided data lists.
</p>

<hr>
<h2 id='merge.snf_config'>Merge method for SNF config objects</h2><span id='topic+merge.snf_config'></span>

<h3>Description</h3>

<p>Merge method for SNF config objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snf_config'
merge(x, y, reset_indices = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge.snf_config_+3A_x">x</code></td>
<td>
<p>SNF config to merge.</p>
</td></tr>
<tr><td><code id="merge.snf_config_+3A_y">y</code></td>
<td>
<p>SNF config to merge.</p>
</td></tr>
<tr><td><code id="merge.snf_config_+3A_reset_indices">reset_indices</code></td>
<td>
<p>If TRUE (default), re-labels the &quot;solutions&quot; indices in
the config from 1 to the number of defined settings.</p>
</td></tr>
<tr><td><code id="merge.snf_config_+3A_...">...</code></td>
<td>
<p>Additional arguments passed into merge function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SNF config combining the rows of both prior configurations.
</p>

<hr>
<h2 id='meta_cluster_heatmap'>Heatmap of pairwise adjusted rand indices between solutions</h2><span id='topic+meta_cluster_heatmap'></span>

<h3>Description</h3>

<p>Heatmap of pairwise adjusted rand indices between solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_cluster_heatmap(
  aris,
  order = NULL,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  log_graph = FALSE,
  scale_diag = "none",
  min_colour = "#282828",
  max_colour = "firebrick2",
  col = circlize::colorRamp2(c(min(aris), max(aris)), c(min_colour, max_colour)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta_cluster_heatmap_+3A_aris">aris</code></td>
<td>
<p>Matrix of adjusted rand indices from <code>calc_aris()</code></p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_order">order</code></td>
<td>
<p>Numeric vector containing row order of the heatmap.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Whether rows should be clustered.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Whether columns should be clustered.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_log_graph">log_graph</code></td>
<td>
<p>If TRUE, log transforms the graph.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_scale_diag">scale_diag</code></td>
<td>
<p>Method of rescaling matrix diagonals. Can be &quot;none&quot;
(don't change diagonals), &quot;mean&quot; (replace diagonals with average value of
off-diagonals), or &quot;zero&quot; (replace diagonals with 0).</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_min_colour">min_colour</code></td>
<td>
<p>Colour used for the lowest value in the heatmap.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_max_colour">max_colour</code></td>
<td>
<p>Colour used for the highest value in the heatmap.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_col">col</code></td>
<td>
<p>Colour ramp to use for the heatmap.</p>
</td></tr>
<tr><td><code id="meta_cluster_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>similarity_matrix_heatmap()</code>,
the function that this function wraps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the pairwise adjusted Rand indices (similarities) between
the cluster solutions of the provided solutions data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dl &lt;- data_list(
#    list(cort_sa, "cortical_surface_area", "neuroimaging", "continuous"),
#    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#    list(income, "household_income", "demographics", "continuous"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    uid = "unique_id"
#)
#
#set.seed(42)
#my_sc &lt;- snf_config(
#    dl = dl,
#    n_solutions = 20,
#    min_k = 20,
#    max_k = 50
#)
#
#sol_df &lt;- batch_snf(dl, my_sc)
#
#sol_df
#
#sol_aris &lt;- calc_aris(sol_df)
#
#meta_cluster_order &lt;- get_matrix_order(sol_aris)
#
## `split_vec` found by iteratively plotting ari_hm or by ?shiny_annotator()
#split_vec &lt;- c(6, 10, 16)
#ari_hm &lt;- meta_cluster_heatmap(
#    sol_aris,
#    order = meta_cluster_order,
#    split_vector = split_vec
#)
</code></pre>

<hr>
<h2 id='metasnf_alert'>Helper function for raising alerts</h2><span id='topic+metasnf_alert'></span>

<h3>Description</h3>

<p>Helper function for raising alerts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metasnf_alert(..., env = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metasnf_alert_+3A_...">...</code></td>
<td>
<p>Arbitrary number of strings to be pasted together into alert
message.</p>
</td></tr>
<tr><td><code id="metasnf_alert_+3A_env">env</code></td>
<td>
<p>Environment to evaluate expressions in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value. Raises an alert through cli::cli_alert_info.
</p>

<hr>
<h2 id='metasnf_defunct'>Helper function for defunct function errors.</h2><span id='topic+metasnf_defunct'></span>

<h3>Description</h3>

<p>Helper function for defunct function errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metasnf_defunct(version, alternative, env = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metasnf_defunct_+3A_version">version</code></td>
<td>
<p>Version of <code>metasnf</code> in which function has been made defunct.</p>
</td></tr>
<tr><td><code id="metasnf_defunct_+3A_alternative">alternative</code></td>
<td>
<p>Recommended alternative approach.</p>
</td></tr>
<tr><td><code id="metasnf_defunct_+3A_env">env</code></td>
<td>
<p>Environment to evaluate expressions in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value. Raises an error through cli::cli_abort.
</p>

<hr>
<h2 id='metasnf_deprecated'>Helper function for deprecated function warnings.</h2><span id='topic+metasnf_deprecated'></span>

<h3>Description</h3>

<p>Helper function for deprecated function warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metasnf_deprecated(version, alternative, env = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metasnf_deprecated_+3A_version">version</code></td>
<td>
<p>Version of <code>metasnf</code> in which function has been deprecated.</p>
</td></tr>
<tr><td><code id="metasnf_deprecated_+3A_alternative">alternative</code></td>
<td>
<p>Recommended alternative approach.</p>
</td></tr>
<tr><td><code id="metasnf_deprecated_+3A_env">env</code></td>
<td>
<p>Environment to evaluate expressions in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value. Raises a warning through cli::cli_warn.
</p>

<hr>
<h2 id='metasnf_error'>Helper function for raising errors.</h2><span id='topic+metasnf_error'></span>

<h3>Description</h3>

<p>Helper function for raising errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metasnf_error(..., env = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metasnf_error_+3A_...">...</code></td>
<td>
<p>Arbitrary number of strings to be pasted together into error
message.</p>
</td></tr>
<tr><td><code id="metasnf_error_+3A_env">env</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value. Raises an error through cli::cli_abort.
</p>

<hr>
<h2 id='metasnf_warning'>Helper function for raising warnings.</h2><span id='topic+metasnf_warning'></span>

<h3>Description</h3>

<p>Helper function for raising warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metasnf_warning(..., env = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metasnf_warning_+3A_...">...</code></td>
<td>
<p>Arbitrary number of strings to be pasted together into warning
message.</p>
</td></tr>
<tr><td><code id="metasnf_warning_+3A_env">env</code></td>
<td>
<p>Environment to evaluate expressions in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value. Raises a warning through cli::cli_warn
</p>

<hr>
<h2 id='methylation_df'>Modification of SNFtool mock data frame &quot;Data2&quot;</h2><span id='topic+methylation_df'></span>

<h3>Description</h3>

<p>Modification of SNFtool mock data frame &quot;Data2&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methylation_df
</code></pre>


<h3>Format</h3>



<h4><code>methylation_df</code></h4>

<p>A data frame with 200 rows and 3 columns:
</p>

<dl>
<dt>gene_1_expression</dt><dd><p>Mock gene methylation feature</p>
</dd>
<dt>gene_2_expression</dt><dd><p>Mock gene methylation feature</p>
</dd>
<dt>patient_id</dt><dd><p>Random three-digit number uniquely identifying the patient</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data came from the SNFtool package, with slight modifications.
</p>

<hr>
<h2 id='n_features'>Extract number of features stored in an object</h2><span id='topic+n_features'></span>

<h3>Description</h3>

<p>Extract number of features stored in an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_features(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_features_+3A_x">x</code></td>
<td>
<p>The object to extract number of features from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of features in x.
</p>

<hr>
<h2 id='n_observations'>Extract number of observations stored in an object</h2><span id='topic+n_observations'></span>

<h3>Description</h3>

<p>Extract number of observations stored in an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_observations(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_observations_+3A_x">x</code></td>
<td>
<p>The object to extract number of observations from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations in x.
</p>

<hr>
<h2 id='new_ari_matrix'>Constructor for <code>ari_matrix</code> class object</h2><span id='topic+new_ari_matrix'></span>

<h3>Description</h3>

<p>Constructor for <code>ari_matrix</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_ari_matrix(aml, dist_method, hclust_method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_ari_matrix_+3A_aml">aml</code></td>
<td>
<p>An ari_matrix-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ari_matrix</code> object.
</p>

<hr>
<h2 id='new_clust_fns_list'>Constructor for <code>clust_fns_list</code> class object</h2><span id='topic+new_clust_fns_list'></span>

<h3>Description</h3>

<p>Constructor for <code>clust_fns_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_clust_fns_list(cfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_clust_fns_list_+3A_cfll">cfll</code></td>
<td>
<p>A clust_fns_list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>clust_fns_list</code> class object.
</p>

<hr>
<h2 id='new_data_list'>Constructor for <code>data_list</code> class object</h2><span id='topic+new_data_list'></span>

<h3>Description</h3>

<p>Constructor for <code>data_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_data_list(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_data_list_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data_list</code> object, which is a nested list with class <code>data_list</code>.
</p>

<hr>
<h2 id='new_dist_fns_list'>Constructor for <code>dist_fns_list</code> class object</h2><span id='topic+new_dist_fns_list'></span>

<h3>Description</h3>

<p>Constructor for <code>dist_fns_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_dist_fns_list(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_dist_fns_list_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dist_fns_list</code> object.
</p>

<hr>
<h2 id='new_ext_solutions_df'>Constructor for <code>ext_solutions_df</code> class object</h2><span id='topic+new_ext_solutions_df'></span>

<h3>Description</h3>

<p>Constructor for <code>ext_solutions_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_ext_solutions_df(ext_sol_dfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_ext_solutions_df_+3A_ext_sol_dfl">ext_sol_dfl</code></td>
<td>
<p>An extended solutions data frame-like object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ext_solutions_df</code> object, which is a data frame with class
<code>ext_solutions_df</code>.
</p>

<hr>
<h2 id='new_settings_df'>Constructor for <code>settings_df</code> class object</h2><span id='topic+new_settings_df'></span>

<h3>Description</h3>

<p>Constructor for <code>settings_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_settings_df(sdfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_settings_df_+3A_sdfl">sdfl</code></td>
<td>
<p>A settings data frame-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>settings_df</code> object.
</p>

<hr>
<h2 id='new_sim_mats_list'>Constructor for <code>similarity_matrix_list</code> class object</h2><span id='topic+new_sim_mats_list'></span>

<h3>Description</h3>

<p>Constructor for <code>similarity_matrix_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sim_mats_list(smll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_sim_mats_list_+3A_smll">smll</code></td>
<td>
<p>A similarity matrix list-like object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>similarity_matrix_list</code> class object.
</p>

<hr>
<h2 id='new_snf_config'>Constructor for <code>snf_config</code> class object</h2><span id='topic+new_snf_config'></span>

<h3>Description</h3>

<p>Constructor for <code>snf_config</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_snf_config(scl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_snf_config_+3A_scl">scl</code></td>
<td>
<p>An SNF config-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>snf_config</code> object.
</p>

<hr>
<h2 id='new_solutions_df'>Constructor for <code>solutions_df</code> class object</h2><span id='topic+new_solutions_df'></span>

<h3>Description</h3>

<p>Constructor for <code>solutions_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_solutions_df(sol_dfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_solutions_df_+3A_sol_dfl">sol_dfl</code></td>
<td>
<p>A solutions data frame-like object to be validated and
converted into a solutions data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>solutions_df</code> class object.
</p>

<hr>
<h2 id='new_weights_matrix'>Constructor for <code>weights_matrix</code> class object</h2><span id='topic+new_weights_matrix'></span>

<h3>Description</h3>

<p>Constructor for <code>weights_matrix</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_weights_matrix(wml)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_weights_matrix_+3A_wml">wml</code></td>
<td>
<p>A weights_matrix-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>weights_matrix</code> object.
</p>

<hr>
<h2 id='not_shown_message'>Helper function for creating what hidden ft/obs/sols message.</h2><span id='topic+not_shown_message'></span>

<h3>Description</h3>

<p>Helper function for creating what hidden ft/obs/sols message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not_shown_message(
  hidden_solutions = NULL,
  hidden_observations = NULL,
  hidden_features = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not_shown_message_+3A_hidden_solutions">hidden_solutions</code></td>
<td>
<p>Number of hidden solutions.</p>
</td></tr>
<tr><td><code id="not_shown_message_+3A_hidden_observations">hidden_observations</code></td>
<td>
<p>Number of hidden observations.</p>
</td></tr>
<tr><td><code id="not_shown_message_+3A_hidden_features">hidden_features</code></td>
<td>
<p>Number of hidden features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all arguments are NULL or 0, returns NULL. Otherwise, output a
neatly formatted string indicating how many observations, features, and/or
observations were not shown.
</p>

<hr>
<h2 id='numcol_to_numeric'>Convert columns of a data frame to numeric type (if possible)</h2><span id='topic+numcol_to_numeric'></span>

<h3>Description</h3>

<p>Converts all columns in a data frame that can be converted to numeric type to
numeric type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numcol_to_numeric(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numcol_to_numeric_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame coercible columns converted to type numeric.
</p>

<hr>
<h2 id='ord_reg_pval'>Ordinal regression p-value</h2><span id='topic+ord_reg_pval'></span>

<h3>Description</h3>

<p>Returns the overall p-value of an ordinal regression on a categorical
predictor and response vetors. If the ordinal response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ord_reg_pval(predictor, response)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ord_reg_pval_+3A_predictor">predictor</code></td>
<td>
<p>A categorical or numeric feature.</p>
</td></tr>
<tr><td><code id="ord_reg_pval_+3A_response">response</code></td>
<td>
<p>A numeric feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval A p-value (class &quot;numeric&quot;).
</p>

<hr>
<h2 id='parallel_batch_snf'>Parallel processing form of batch_snf</h2><span id='topic+parallel_batch_snf'></span>

<h3>Description</h3>

<p>Parallel processing form of batch_snf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_batch_snf(
  dl,
  dfl,
  cfl,
  sdf,
  wm,
  similarity_matrix_dir,
  return_sim_mats,
  processes
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_batch_snf_+3A_dl">dl</code></td>
<td>
<p>A data list.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_dfl">dfl</code></td>
<td>
<p>An optional nested list containing which
distance metric function should be used for the various feature types
(continuous, discrete, ordinal, categorical, and mixed). See
?dist_fns_list for details on how to build this.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_cfl">cfl</code></td>
<td>
<p>List of custom clustering algorithms to apply
to the final fused network. See ?clust_fns_list.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_sdf">sdf</code></td>
<td>
<p>matrix indicating parameters to iterate SNF through.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_wm">wm</code></td>
<td>
<p>A matrix containing feature weights to use during
distance matrix calculation. See ?weights_matrix for details on
how to build this.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_similarity_matrix_dir">similarity_matrix_dir</code></td>
<td>
<p>If specified, this directory will be used to
save all generated similarity matrices.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_return_sim_mats">return_sim_mats</code></td>
<td>
<p>If TRUE, function will return a list where
the first element is the solutions data frame and the second element is a list
of similarity matrices for each row in the sol_df. Default FALSE.</p>
</td></tr>
<tr><td><code id="parallel_batch_snf_+3A_processes">processes</code></td>
<td>
<p>Number of parallel processes used when executing SNF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same values as ?batch_snf().
</p>

<hr>
<h2 id='pick_cols'>Helper function to pick columns from a data frame</h2><span id='topic+pick_cols'></span>

<h3>Description</h3>

<p>Helper function to pick columns from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_cols(x, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_cols_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="pick_cols_+3A_cols">cols</code></td>
<td>
<p>Vector of column names to be picked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with only columns in cols
</p>

<hr>
<h2 id='prefix_dll_uid'>Add &quot;uid_&quot; prefix to all UID values in uid column</h2><span id='topic+prefix_dll_uid'></span>

<h3>Description</h3>

<p>Add &quot;uid_&quot; prefix to all UID values in uid column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefix_dll_uid(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prefix_dll_uid_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dl A data list with UIDs prefixed with the string &quot;uid_&quot;
</p>

<hr>
<h2 id='print_with_n_message'>Helper function for outputting tip on changing rows printed</h2><span id='topic+print_with_n_message'></span>

<h3>Description</h3>

<p>Helper function for outputting tip on changing rows printed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_with_n_message()
</code></pre>


<h3>Value</h3>

<p>Output a message to use print with <code>n</code> to change displayed rows.
</p>

<hr>
<h2 id='print_with_t_message'>Helper function for transposing solutions_df message</h2><span id='topic+print_with_t_message'></span>

<h3>Description</h3>

<p>Helper function for transposing solutions_df message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_with_t_message()
</code></pre>


<h3>Value</h3>

<p>Output a message to use print with <code>n</code> to change displayed rows.
</p>

<hr>
<h2 id='print.ari_matrix'>Print method for class <code>ari_matrix</code></h2><span id='topic+print.ari_matrix'></span>

<h3>Description</h3>

<p>Custom formatted print for weights matrices that outputs
information about feature weights functions to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ari_matrix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ari_matrix_+3A_x">x</code></td>
<td>
<p>A <code>ari_matrix</code> class object.</p>
</td></tr>
<tr><td><code id="print.ari_matrix_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.clust_fns_list'>Print method for class <code>clust_fns_list</code></h2><span id='topic+print.clust_fns_list'></span>

<h3>Description</h3>

<p>Custom formatted print for clustering functions list objects that outputs
information about the contained clustering functions to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clust_fns_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.clust_fns_list_+3A_x">x</code></td>
<td>
<p>A <code>clust_fns_list</code> class object.</p>
</td></tr>
<tr><td><code id="print.clust_fns_list_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.data_list'>Print method for class <code>data_list</code></h2><span id='topic+print.data_list'></span>

<h3>Description</h3>

<p>Custom formatted print for data list objects that outputs information about
the contained observations and components to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.data_list_+3A_x">x</code></td>
<td>
<p>A <code>data_list</code> class object.</p>
</td></tr>
<tr><td><code id="print.data_list_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.dist_fns_list'>Print method for class <code>dist_fns_list</code></h2><span id='topic+print.dist_fns_list'></span>

<h3>Description</h3>

<p>Custom formatted print for distance metrics list objects that outputs
information about the contained distance metrics to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dist_fns_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dist_fns_list_+3A_x">x</code></td>
<td>
<p>A <code>dist_fns_list</code> class object.</p>
</td></tr>
<tr><td><code id="print.dist_fns_list_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.ext_solutions_df'>Print method for class <code>ext_solutions_df</code></h2><span id='topic+print.ext_solutions_df'></span>

<h3>Description</h3>

<p>Custom formatted print for extended solutions data frame class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ext_solutions_df'
print(x, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ext_solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>ext_solutions_df</code> class object.</p>
</td></tr>
<tr><td><code id="print.ext_solutions_df_+3A_n">n</code></td>
<td>
<p>Number of rows to print, passed into <code>tibble::print.tbl_df()</code>.</p>
</td></tr>
<tr><td><code id="print.ext_solutions_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.settings_df'>Print method for class <code>settings_df</code></h2><span id='topic+print.settings_df'></span>

<h3>Description</h3>

<p>Custom formatted print for settings data frame that outputs information
about SNF hyperparameters to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'settings_df'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.settings_df_+3A_x">x</code></td>
<td>
<p>A <code>settings_df</code> class object.</p>
</td></tr>
<tr><td><code id="print.settings_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.snf_config'>Print method for class <code>snf_config</code></h2><span id='topic+print.snf_config'></span>

<h3>Description</h3>

<p>Custom formatted print for SNF config
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snf_config'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.snf_config_+3A_x">x</code></td>
<td>
<p>A <code>snf_config</code> class object.</p>
</td></tr>
<tr><td><code id="print.snf_config_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.solutions_df'>Print method for class <code>weights_matrix</code></h2><span id='topic+print.solutions_df'></span>

<h3>Description</h3>

<p>Custom formatted print for weights matrices that outputs
information about feature weights functions to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solutions_df'
print(x, n = NULL, tips = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>weights_matrix</code> class object.</p>
</td></tr>
<tr><td><code id="print.solutions_df_+3A_n">n</code></td>
<td>
<p>Number of rows to print, passed into <code>tibble::print.tbl_df()</code>.</p>
</td></tr>
<tr><td><code id="print.solutions_df_+3A_tips">tips</code></td>
<td>
<p>If TRUE, include lines on how to print more rows / transposed.</p>
</td></tr>
<tr><td><code id="print.solutions_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.t_ext_solutions_df'>Print method for class <code>t_ext_solutions_df</code></h2><span id='topic+print.t_ext_solutions_df'></span>

<h3>Description</h3>

<p>Custom formatted print for transposed solutions data frame class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 't_ext_solutions_df'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.t_ext_solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>t_solutions_df</code> class object.</p>
</td></tr>
<tr><td><code id="print.t_ext_solutions_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.t_solutions_df'>Print method for class <code>t_solutions_df</code></h2><span id='topic+print.t_solutions_df'></span>

<h3>Description</h3>

<p>Custom formatted print for transposed solutions data frame class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 't_solutions_df'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.t_solutions_df_+3A_x">x</code></td>
<td>
<p>A <code>t_solutions_df</code> class object.</p>
</td></tr>
<tr><td><code id="print.t_solutions_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='print.weights_matrix'>Print method for class <code>weights_matrix</code></h2><span id='topic+print.weights_matrix'></span>

<h3>Description</h3>

<p>Custom formatted print for weights matrices that outputs
information about feature weights functions to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weights_matrix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.weights_matrix_+3A_x">x</code></td>
<td>
<p>A <code>weights_matrix</code> class object.</p>
</td></tr>
<tr><td><code id="print.weights_matrix_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>print</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function prints to console but does not return any value.
</p>

<hr>
<h2 id='pubertal'>Mock ABCD pubertal status data</h2><span id='topic+pubertal'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_pubertal&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pubertal
</code></pre>


<h3>Format</h3>



<h4><code>pubertal</code></h4>

<p>A data frame with 275 rows and 2 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>pubertal_status</dt><dd><p>Average reported pubertal status between child and parent (1-5 categorical scale)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='pval_heatmap'>Heatmap of p-values</h2><span id='topic+pval_heatmap'></span>

<h3>Description</h3>

<p>Heatmap of p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_heatmap(
  ext_sol_df,
  order = NULL,
  cluster_columns = TRUE,
  cluster_rows = FALSE,
  show_row_names = FALSE,
  show_column_names = TRUE,
  min_colour = "red2",
  max_colour = "white",
  legend_breaks = c(0, 1),
  col = circlize::colorRamp2(legend_breaks, c(min_colour, max_colour)),
  heatmap_legend_param = list(color_bar = "continuous", title = "p-value", at = c(0, 1)),
  rect_gp = grid::gpar(col = "black"),
  column_split_vector = NULL,
  row_split_vector = NULL,
  column_split = NULL,
  row_split = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_heatmap_+3A_ext_sol_df">ext_sol_df</code></td>
<td>
<p>An ext_solutions_df class object (produced from
the function <code>extend_solutions</code>.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_order">order</code></td>
<td>
<p>Numeric vector containing row order of the heatmap.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Whether columns should be sorted by hierarchical
clustering.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Whether rows should be sorted by hierarchical
clustering.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_show_row_names">show_row_names</code></td>
<td>
<p>Whether row names should be shown.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_show_column_names">show_column_names</code></td>
<td>
<p>Whether column names should be shown.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_min_colour">min_colour</code></td>
<td>
<p>Colour used for the lowest value in the heatmap.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_max_colour">max_colour</code></td>
<td>
<p>Colour used for the highest value in the heatmap.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_legend_breaks">legend_breaks</code></td>
<td>
<p>Numeric vector of breaks for the legend.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_col">col</code></td>
<td>
<p>Colour function for <code>ComplexHeatmap::Heatmap()</code></p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_heatmap_legend_param">heatmap_legend_param</code></td>
<td>
<p>Legend function for <code>ComplexHeatmap::Heatmap()</code></p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_rect_gp">rect_gp</code></td>
<td>
<p>Cell border function for <code>ComplexHeatmap::Heatmap()</code></p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_column_split_vector">column_split_vector</code></td>
<td>
<p>Vector of indices to split columns by.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_row_split_vector">row_split_vector</code></td>
<td>
<p>Vector of indices to split rows by.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_column_split">column_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_row_split">row_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="pval_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the provided p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dl &lt;- data_list(
#    list(income, "household_income", "demographics", "ordinal"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    list(fav_colour, "favourite_colour", "demographics", "categorical"),
#    list(anxiety, "anxiety", "behaviour", "ordinal"),
#    list(depress, "depressed", "behaviour", "ordinal"),
#    uid = "unique_id"
#)
#
#sc &lt;- snf_config(
#    dl,
#    n_solutions = 4,
#    dropout_dist = "uniform",
#    max_k = 50
#)
#
#sol_df &lt;- batch_snf(dl, sc)
#
#ext_sol_df &lt;- extend_solutions(sol_df, dl)
#
#pval_heatmap(ext_sol_df)
</code></pre>

<hr>
<h2 id='quality_measures'>Quality metrics</h2><span id='topic+quality_measures'></span><span id='topic+calculate_silhouettes'></span><span id='topic+calculate_dunn_indices'></span><span id='topic+calculate_db_indices'></span>

<h3>Description</h3>

<p>These functions calculate conventional metrics of cluster solution quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_silhouettes(sol_df)

calculate_dunn_indices(sol_df)

calculate_db_indices(sol_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quality_measures_+3A_sol_df">sol_df</code></td>
<td>
<p>A <code>solutions_df</code> class object created by <code>batch_snf()</code> with
the parameter <code>return_sim_mats = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculate_silhouettes: A wrapper for <code>cluster::silhouette</code> that calculates
silhouette scores for all cluster solutions in a provided solutions data
frame. Silhouette values range from -1 to +1 and indicate an overall ratio
of how close together observations within a cluster are to how far apart
observations across clusters are. You can learn more about interpreting
the results of this function by calling <code>?cluster::silhouette</code>.
</p>
<p>calculate_dunn_indices: A wrapper for <code>clv::clv.Dunn</code> that calculates
Dunn indices for all cluster solutions in a provided solutions data
frame. Dunn indices, like silhouette scores, similarly reflect similarity
within clusters and separation across clusters. You can learn more about
interpreting the results of this function by calling <code>?clv::clv.Dunn</code>.
</p>
<p>calculate_db_indices: A wrapper for <code>clv::clv.Davies.Bouldin</code> that
calculates Davies-Bouldin indices for all cluster solutions in a provided
solutions data frame. These values can be interpreted similarly as those
above. You can learn more about interpreting the results of this function by
calling <code>?clv::clv.Davies.Bouldin</code>.
</p>


<h3>Value</h3>

<p>A list of <code>silhouette</code> class objects, a vector of Dunn indices, or a
vector of Davies-Bouldin indices depending on which function was used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(gender_df, "gender", "demographics", "categorical"),
    list(diagnosis_df, "diagnosis", "clinical", "categorical"),
    uid = "patient_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 5)

sol_df &lt;- batch_snf(input_dl, sc, return_sim_mats = TRUE)

# calculate Davies-Bouldin indices
davies_bouldin_indices &lt;- calculate_db_indices(sol_df)

# calculate Dunn indices
dunn_indices &lt;- calculate_dunn_indices(sol_df)

# calculate silhouette scores
silhouette_scores &lt;- calculate_silhouettes(sol_df)
</code></pre>

<hr>
<h2 id='random_removal'>Generate random removal sequence</h2><span id='topic+random_removal'></span>

<h3>Description</h3>

<p>Helper function to contribute to rows within the settings data frame. Number
of columns removed follows a uniform or exponential probability
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_removal(
  columns,
  min_removed_inputs,
  max_removed_inputs,
  dropout_dist = "exponential"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_removal_+3A_columns">columns</code></td>
<td>
<p>Columns of the settings_df that are passed in</p>
</td></tr>
<tr><td><code id="random_removal_+3A_min_removed_inputs">min_removed_inputs</code></td>
<td>
<p>The smallest number of input data frames that may
be randomly removed.</p>
</td></tr>
<tr><td><code id="random_removal_+3A_max_removed_inputs">max_removed_inputs</code></td>
<td>
<p>The largest number of input data frames that may be
randomly removed.</p>
</td></tr>
<tr><td><code id="random_removal_+3A_dropout_dist">dropout_dist</code></td>
<td>
<p>Indication of how input data frames should be dropped.
can be &quot;none&quot; (no dropout), &quot;uniform&quot; (uniformly draw number between min
and max removed inputs), or &quot;exponential&quot; (like uniform, but using an
exponential distribution; default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inclusions_df data frame that can be rbind'ed to the settings_df
</p>

<hr>
<h2 id='rbind.ext_solutions_df'>Row-binding of solutions data frame class objects.</h2><span id='topic+rbind.ext_solutions_df'></span>

<h3>Description</h3>

<p>Row-binding of solutions data frame class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ext_solutions_df'
rbind(reset_indices = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.ext_solutions_df_+3A_reset_indices">reset_indices</code></td>
<td>
<p>If TRUE, re-labels the &quot;solutions&quot; indices in
the solutions data frame from 1 to the number of defined settings.</p>
</td></tr>
<tr><td><code id="rbind.ext_solutions_df_+3A_...">...</code></td>
<td>
<p>An arbitrary number of <code>ext_solutions_df</code> class objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ext_solutions_df</code> class object.
</p>

<hr>
<h2 id='rbind.solutions_df'>Row-binding of solutions data frame class objects.</h2><span id='topic+rbind.solutions_df'></span>

<h3>Description</h3>

<p>Row-binding of solutions data frame class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solutions_df'
rbind(reset_indices = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.solutions_df_+3A_reset_indices">reset_indices</code></td>
<td>
<p>If TRUE, re-labels the &quot;solutions&quot; indices in
the solutions data frame from 1 to the number of defined settings.</p>
</td></tr>
<tr><td><code id="rbind.solutions_df_+3A_...">...</code></td>
<td>
<p>An arbitrary number of <code>solutions_df</code> class objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>solutions_df</code> class object.
</p>

<hr>
<h2 id='remove_dll_incomplete'>Remove observations with incomplete data from a data list-like list object</h2><span id='topic+remove_dll_incomplete'></span>

<h3>Description</h3>

<p>Helper function during <code>data_list</code> class initialization. First applies
<code>stats::na.omit()</code> to the data frames named &quot;data&quot; within a nested list.
Then removes any observations that are not present across all data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_dll_incomplete(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_dll_incomplete_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dll The provided data list-like object with missing observations
removed.
</p>

<hr>
<h2 id='rename_dl'>Rename features in a data list</h2><span id='topic+rename_dl'></span>

<h3>Description</h3>

<p>Rename features in a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_dl(dl, name_mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_dl_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="rename_dl_+3A_name_mapping">name_mapping</code></td>
<td>
<p>A named vector where the values are the features to be
renamed and the names are the new names for those features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data list (&quot;list&quot;-class object) with adjusted feature names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metasnf)

dl &lt;- data_list(
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)

summary(dl, "feature")

name_changes &lt;- c(
    "anxiety_score" = "cbcl_anxiety_r",
    "depression_score" = "cbcl_depress_r"
)

dl &lt;- rename_dl(dl, name_changes)

summary(dl, "feature")
</code></pre>

<hr>
<h2 id='reorder_dl_uids'>Reorder the uids in a data list</h2><span id='topic+reorder_dl_uids'></span>

<h3>Description</h3>

<p>Reorder the uids in a data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_dl_uids(dl, ordered_uids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder_dl_uids_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="reorder_dl_uids_+3A_ordered_uids">ordered_uids</code></td>
<td>
<p>A vector of the uid values in the data list
in the desired order of the sorted data list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data list (&quot;list&quot;-class object) with reordered observations.
</p>

<hr>
<h2 id='resample'>Helper resample function found in ?sample</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Like sample, but when given a single value x, returns back that single
value instead of a random value from 1 to x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>Vector or single value to sample from</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Remaining arguments for base::sample function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector result of running base::sample.
</p>

<hr>
<h2 id='run_snf'>Run SNF</h2><span id='topic+run_snf'></span>

<h3>Description</h3>

<p>Helper function for running a single SNF config pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_snf(i, dl, sc, return_sim_mats, sim_mats_dir, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_snf_+3A_i">i</code></td>
<td>
<p>Row of settings_df and weights_matrix within SNF config to use.</p>
</td></tr>
<tr><td><code id="run_snf_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="run_snf_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> class object which stores all sets of
hyperparameters used to transform data in dl into a cluster solutions. See
<code>?settings_df</code> or
https://branchlab.github.io/metasnf/articles/settings_df.html for more
details.</p>
</td></tr>
<tr><td><code id="run_snf_+3A_return_sim_mats">return_sim_mats</code></td>
<td>
<p>If TRUE, function will return a list where
the first element is the solutions data frame and the second element is a list
of similarity matrices for each row in the sol_df. Default FALSE.</p>
</td></tr>
<tr><td><code id="run_snf_+3A_sim_mats_dir">sim_mats_dir</code></td>
<td>
<p>If specified, this directory will be used to
save all generated similarity matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a cluster solution (numeric vector) and a
the fused network used to create that cluster solution. The fused network
is NULL if return_sim_mats is FALSE.
</p>

<hr>
<h2 id='save_heatmap'>Save a heatmap object to a file</h2><span id='topic+save_heatmap'></span>

<h3>Description</h3>

<p>Save a heatmap object to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_heatmap(heatmap, path, width = 480, height = 480, res = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_heatmap_+3A_heatmap">heatmap</code></td>
<td>
<p>The heatmap object to save.</p>
</td></tr>
<tr><td><code id="save_heatmap_+3A_path">path</code></td>
<td>
<p>The path to save the heatmap to.</p>
</td></tr>
<tr><td><code id="save_heatmap_+3A_width">width</code></td>
<td>
<p>The width of the heatmap.</p>
</td></tr>
<tr><td><code id="save_heatmap_+3A_height">height</code></td>
<td>
<p>The height of the heatmap.</p>
</td></tr>
<tr><td><code id="save_heatmap_+3A_res">res</code></td>
<td>
<p>The resolution of the heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return any value. Saves heatmap to file.
</p>

<hr>
<h2 id='scale_diagonals'>Adjust the diagonals of a matrix</h2><span id='topic+scale_diagonals'></span>

<h3>Description</h3>

<p>Adjust the diagonals of a matrix to reduce contrast with off-diagonals
during plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_diagonals(matrix, method = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_diagonals_+3A_matrix">matrix</code></td>
<td>
<p>Matrix to rescale.</p>
</td></tr>
<tr><td><code id="scale_diagonals_+3A_method">method</code></td>
<td>
<p>Method of rescaling. Can be:
</p>

<ul>
<li><p> &quot;mean&quot; (replace diagonals with average value of off-diagonals)
</p>
</li>
<li><p> &quot;zero&quot; (replace diagonals with 0)
</p>
</li>
<li><p> &quot;min&quot; (replace diagonals with min value of off-diagonals)
</p>
</li>
<li><p> &quot;max&quot; (replace diagonals with max value of off-diagonals)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;matrix&quot; class object with rescaled diagonals.
</p>

<hr>
<h2 id='settings_df'>Build a settings data frame</h2><span id='topic+settings_df'></span>

<h3>Description</h3>

<p>The settings_df is a data frame whose rows completely specify the
hyperparameters and decisions required to transform individual input
data frames (found in a data list, see ?data_list) into a single
similarity matrix through SNF. The format of the settings data frame is as
follows:
</p>

<ul>
<li><p> A column named &quot;solution&quot;: This column is used to keep
track of the rows and should have integer values only.
</p>
</li>
<li><p> A column named &quot;alpha&quot;: This column contains the value of the
alpha hyperparameter that will be used on that run of the SNF pipeline.
</p>
</li>
<li><p> A column named &quot;k&quot;: Like above, but for the K (nearest neighbours)
hyperparameter.
</p>
</li>
<li><p> A column named &quot;t&quot;: Like above, but for the t (number of iterations)
hyperparameter.
</p>
</li>
<li><p> A column named &quot;snf_scheme&quot;: Which of 3 pre-defined schemes will be used
to integrate the data frames of the data list into a final fused network.
The purpose of varying these schemes is primarily to increase the
diversity of the generated cluster solutions.
</p>

<ul>
<li><p> A value of 1 corresponds to the &quot;individual&quot; scheme, in which all data
frames are directly merged by SNF into the final fused network. This
scheme corresponds to the approach shown in the original SNF paper.
</p>
</li>
<li><p> A value of 2 corresponds to the &quot;two-step&quot; scheme, in which all data
frames witin a domain are first merged into a domain-specific fused
network. Next, domain-specific networks are fused once more by SNF
into the final fused network. This scheme is useful for fairly
re-weighting SNF pipelines with unequal numbers of data frames across
domains.
</p>
</li>
<li><p> A value of 3 corresponds to the &quot;domain&quot; scheme, in which all data
frames within a domain are first concatenated into a single domain-
specific data frame before being merged by SNF into the final fused
network. This approach serves as an alternative way to re-weight
SNF pipelines with unequal numbers of data frames across domains.
You can learn more about this parameter here:
https://branchlab.github.io/metasnf/articles/snf_schemes.html.
</p>
</li></ul>

</li>
<li><p> A column named &quot;clust_alg&quot;: Specification of which clustering algorithm
will be applied to the final similarity matrix. By default, this
column can take on the integer values 1 or 2, which correspond to
spectral clustering where the number of clusters is determined by the
eigen-gap or rotation cost heuristic respectively. You can learn more
about this parameter here:
https://branchlab.github.io/metasnf/articles/clustering_algorithms.html.
</p>
</li>
<li><p> A column named &quot;cnt_dist&quot;: Specification of which distance metric will be
used for data frames of purely continuous data. You can learn about this
metric and its defaults here:
https://branchlab.github.io/metasnf/articles/distance_metrics.html
</p>
</li>
<li><p> A column named &quot;dsc_dist&quot;: Like above, but for discrete data frames.
</p>
</li>
<li><p> A column named &quot;ord_dist&quot;: Like above, but for ordinal data frames.
</p>
</li>
<li><p> A column named &quot;cat_dist&quot;: Like above, but for categorical data frames.
</p>
</li>
<li><p> A column named &quot;mix_dist&quot;: Like above, but for mixed-type (e.g.,
both categorical and discrete) data frames.
</p>
</li>
<li><p> One column for every input data frame in the corresponding data list which
can either have the value of 0 or 1. The name of the column should be
formatted as &quot;inc_[]&quot; where the square brackets are replaced with the
name (as found in dl_summary(dl)$&quot;name&quot;) of each data frame. When
0, that data frame will be excluded from that run of the SNF pipeline. When
1, that data frame will be included.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>settings_df(
  dl,
  n_solutions = 0,
  min_removed_inputs = 0,
  max_removed_inputs = length(dl) - 1,
  dropout_dist = "exponential",
  min_alpha = NULL,
  max_alpha = NULL,
  min_k = NULL,
  max_k = NULL,
  min_t = NULL,
  max_t = NULL,
  alpha_values = NULL,
  k_values = NULL,
  t_values = NULL,
  possible_snf_schemes = c(1, 2, 3),
  clustering_algorithms = NULL,
  continuous_distances = NULL,
  discrete_distances = NULL,
  ordinal_distances = NULL,
  categorical_distances = NULL,
  mixed_distances = NULL,
  dfl = NULL,
  snf_input_weights = NULL,
  snf_domain_weights = NULL,
  retry_limit = 10,
  allow_duplicates = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="settings_df_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_n_solutions">n_solutions</code></td>
<td>
<p>Number of rows to generate for the settings data frame.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_min_removed_inputs">min_removed_inputs</code></td>
<td>
<p>The smallest number of input data frames that may be
randomly removed. By default, 0.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_max_removed_inputs">max_removed_inputs</code></td>
<td>
<p>The largest number of input data frames that may be
randomly removed. By default, this is 1 less than all the provided input
data frames in the data list.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_dropout_dist">dropout_dist</code></td>
<td>
<p>Parameter controlling how the random removal of input
data frames should occur. Can be &quot;none&quot; (no input data frames are randomly
removed), &quot;uniform&quot; (uniformly sample between min_removed_inputs and
max_removed_inputs to determine number of input data frames to remove), or
&quot;exponential&quot; (pick number of input data frames to remove by sampling from
min_removed_inputs to max_removed_inputs with an exponential distribution;
the default).</p>
</td></tr>
<tr><td><code id="settings_df_+3A_min_alpha">min_alpha</code></td>
<td>
<p>The minimum value that the alpha hyperparameter can have.
Random assigned value of alpha for each row will be obtained by uniformly
sampling numbers between <code>min_alpha</code> and <code>max_alpha</code> at intervals of 0.1.
Cannot be used in conjunction with the <code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_max_alpha">max_alpha</code></td>
<td>
<p>The maximum value that the alpha hyperparameter can have.
See <code>min_alpha</code> parameter. Cannot be used in conjunction with the
<code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_min_k">min_k</code></td>
<td>
<p>The minimum value that the k hyperparameter can have.
Random assigned value of k for each row will be obtained by uniformly
sampling numbers between <code>min_k</code> and <code>max_k</code> at intervals of 1.
Cannot be used in conjunction with the <code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_max_k">max_k</code></td>
<td>
<p>The maximum value that the k hyperparameter can have.
See <code>min_k</code> parameter. Cannot be used in conjunction with the
<code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_min_t">min_t</code></td>
<td>
<p>The minimum value that the t hyperparameter can have.
Random assigned value of t for each row will be obtained by uniformly
sampling numbers between <code>min_t</code> and <code>max_t</code> at intervals of 1.
Cannot be used in conjunction with the <code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_max_t">max_t</code></td>
<td>
<p>The maximum value that the t hyperparameter can have.
See <code>min_t</code> parameter. Cannot be used in conjunction with the
<code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_alpha_values">alpha_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that alpha can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_alpha</code> or <code>max_alpha</code>
parameters.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_k_values">k_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that k can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_k</code> or <code>max_k</code>
parameters.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_t_values">t_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that t can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_t</code> or <code>max_t</code>
parameters.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_possible_snf_schemes">possible_snf_schemes</code></td>
<td>
<p>A vector containing the possible snf_schemes to
uniformly randomly select from. By default, the vector contains all
3 possible schemes: c(1, 2, 3). 1 corresponds to the &quot;individual&quot; scheme,
2 corresponds to the &quot;domain&quot; scheme, and 3 corresponds to the &quot;twostep&quot;
scheme.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_clustering_algorithms">clustering_algorithms</code></td>
<td>
<p>A list of clustering algorithms to uniformly
randomly pick from when clustering. When not specified, randomly select
between spectral clustering using the eigen-gap heuristic and spectral
clustering using the rotation cost heuristic. See ?clust_fns_list
for more details on running custom clustering algorithms.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_continuous_distances">continuous_distances</code></td>
<td>
<p>A vector of continuous distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_discrete_distances">discrete_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_ordinal_distances">ordinal_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_categorical_distances">categorical_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_mixed_distances">mixed_distances</code></td>
<td>
<p>A vector of mixed distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_dfl">dfl</code></td>
<td>
<p>List containing distance metrics to vary over.
See ?generate_dist_fns_list.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_snf_input_weights">snf_input_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge individual input measures (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="settings_df_+3A_snf_domain_weights">snf_domain_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge domains (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="settings_df_+3A_retry_limit">retry_limit</code></td>
<td>
<p>The maximum number of attempts to generate a novel row.
This function does not return matrices with identical rows. As the range of
requested possible settings tightens and the number of requested rows
increases, the risk of randomly generating a row that already exists
increases. If a new random row has matched an existing row <code>retry_limit</code>
number of times, the function will terminate.</p>
</td></tr>
<tr><td><code id="settings_df_+3A_allow_duplicates">allow_duplicates</code></td>
<td>
<p>If TRUE, enables creation of a settings data frame
with duplicate non-feature weighting related hyperparameters. This function
should only be used when paired with a custom weights matrix that has
non-duplicate rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A settings data frame
</p>

<hr>
<h2 id='shiny_annotator'>Launch a shiny app to identify meta cluster boundaries</h2><span id='topic+shiny_annotator'></span>

<h3>Description</h3>

<p>This function calls the <code>htShiny()</code> function from the package
InteractiveComplexHeatmap to assist users in identifying the indices of the
boundaries between meta clusters in a meta cluster heatmap. By providing a
heatmap of inter-solution similarities (obtained through
meta_cluster_heatmap()), users can click on positions within the heatmap
that appear to meaningfully separate major sets of similar cluster
solutions by visual inspection. The corresponding indices of the clicked
positions are printed to the console and also shown within the app. This
function can only run from an interactive session of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_annotator(ari_heatmap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shiny_annotator_+3A_ari_heatmap">ari_heatmap</code></td>
<td>
<p>Heatmap of ARIs to divide into meta clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return any value. Launches interactive shiny applet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dl &lt;- data_list(
#    list(cort_sa, "cortical_surface_area", "neuroimaging", "continuous"),
#    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#    list(income, "household_income", "demographics", "continuous"),
#    list(pubertal, "pubertal_status", "demographics", "continuous"),
#    uid = "unique_id"
#)
#
#set.seed(42)
#my_sc &lt;- snf_config(
#    dl = dl,
#    n_solutions = 20,
#    min_k = 20,
#    max_k = 50
#)
#
#sol_df &lt;- batch_snf(dl, my_sc)
#
#sol_aris &lt;- calc_aris(sol_df)
#
#meta_cluster_order &lt;- get_matrix_order(sol_aris)
#
#ari_hm &lt;- meta_cluster_heatmap(sol_aris, order = meta_cluster_order)
#
## Click on meta cluster boundaries to obtain `split_vec` values
#shiny_annotator(ari_hm)
#
#split_vec &lt;- c(6, 10, 16)
#
#ari_hm &lt;- meta_cluster_heatmap(
#    sol_aris,
#    order = meta_cluster_order,
#    split_vector = split_vec
#)
</code></pre>

<hr>
<h2 id='sim_mats_list'>Create or extract a <code>sim_mats_list</code> class object</h2><span id='topic+sim_mats_list'></span>

<h3>Description</h3>

<p>Create or extract a <code>sim_mats_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mats_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_mats_list_+3A_x">x</code></td>
<td>
<p>The object to create or extract a <code>sim_mats_list</code> from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sim_mats_list</code> class object.
</p>

<hr>
<h2 id='similarity_matrix_heatmap'>Plot heatmap of similarity matrix</h2><span id='topic+similarity_matrix_heatmap'></span>

<h3>Description</h3>

<p>Plot heatmap of similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_matrix_heatmap(
  similarity_matrix,
  order = NULL,
  cluster_solution = NULL,
  scale_diag = "mean",
  log_graph = TRUE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  show_row_names = FALSE,
  show_column_names = FALSE,
  data = NULL,
  left_bar = NULL,
  right_bar = NULL,
  top_bar = NULL,
  bottom_bar = NULL,
  left_hm = NULL,
  right_hm = NULL,
  top_hm = NULL,
  bottom_hm = NULL,
  annotation_colours = NULL,
  min_colour = NULL,
  max_colour = NULL,
  split_vector = NULL,
  row_split = NULL,
  column_split = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_matrix_heatmap_+3A_similarity_matrix">similarity_matrix</code></td>
<td>
<p>A similarity matrix</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_order">order</code></td>
<td>
<p>Vector of numbers to reorder the similarity matrix (and data
if provided). Overwrites ordering specified by cluster_solution param.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_cluster_solution">cluster_solution</code></td>
<td>
<p>Row of a solutions data frame or column of a
transposed solutions data frame.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_scale_diag">scale_diag</code></td>
<td>
<p>Method of rescaling matrix diagonals. Can be &quot;none&quot;
(don't change diagonals), &quot;mean&quot; (replace diagonals with average value of
off-diagonals), or &quot;zero&quot; (replace diagonals with 0).</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_log_graph">log_graph</code></td>
<td>
<p>If TRUE, log transforms the graph.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_cluster_columns">cluster_columns</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_show_row_names">show_row_names</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_show_column_names">show_column_names</code></td>
<td>
<p>Parameter for ComplexHeatmap::Heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_data">data</code></td>
<td>
<p>A data frame containing elements requested for annotation.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_left_bar">left_bar</code></td>
<td>
<p>Named list of strings, where the strings are features in
df that should be used for a barplot annotation on the left of the plot and
the names are the names that will be used to caption the plots and their
legends.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_right_bar">right_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_top_bar">top_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_bottom_bar">bottom_bar</code></td>
<td>
<p>See left_bar.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_left_hm">left_hm</code></td>
<td>
<p>Like left_bar, but with a heatmap annotation instead of a
barplot annotation.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_right_hm">right_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_top_hm">top_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_bottom_hm">bottom_hm</code></td>
<td>
<p>See left_hm.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_annotation_colours">annotation_colours</code></td>
<td>
<p>Named list of heatmap annotations and their
colours.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_min_colour">min_colour</code></td>
<td>
<p>Colour used for the lowest value in the heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_max_colour">max_colour</code></td>
<td>
<p>Colour used for the highest value in the heatmap.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_split_vector">split_vector</code></td>
<td>
<p>A vector of partition indices.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_row_split">row_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_column_split">column_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="similarity_matrix_heatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters passed into ComplexHeatmap::Heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap (class &quot;Heatmap&quot; from package ComplexHeatmap)
that displays the similarities between observations in the provided matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#my_dl &lt;- data_list(
#    list(
#        data = expression_df,
#        name = "expression_data",
#        domain = "gene_expression",
#        type = "continuous"
#    ),
#    list(
#        data = methylation_df,
#        name = "methylation_data",
#        domain = "gene_methylation",
#        type = "continuous"
#    ),
#    uid = "patient_id"
#)
#
#sc &lt;- snf_config(my_dl, n_solutions = 10)
#
#sol_df &lt;- batch_snf(my_dl, sc, return_sim_mats = TRUE)
#
#sim_mats &lt;- sim_mats_list(sol_df)
#
#similarity_matrix_heatmap(
#    sim_mats[[1]],
#    cluster_solution = sol_df[1, ]
#)
</code></pre>

<hr>
<h2 id='similarity_matrix_path'>Generate a complete path and filename to store an similarity matrix</h2><span id='topic+similarity_matrix_path'></span>

<h3>Description</h3>

<p>Generate a complete path and filename to store an similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_matrix_path(similarity_matrix_dir, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_matrix_path_+3A_similarity_matrix_dir">similarity_matrix_dir</code></td>
<td>
<p>Directory to store similarity matrices.</p>
</td></tr>
<tr><td><code id="similarity_matrix_path_+3A_i">i</code></td>
<td>
<p>Corresponding solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Complete path and filename to store an similarity matrix.
</p>

<hr>
<h2 id='siw_euclidean_distance'>Squared (including weights) Euclidean distance</h2><span id='topic+siw_euclidean_distance'></span>

<h3>Description</h3>

<p>Squared (including weights) Euclidean distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siw_euclidean_distance(df, weights_row)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="siw_euclidean_distance_+3A_df">df</code></td>
<td>
<p>data frame containing at least 1 data column.</p>
</td></tr>
<tr><td><code id="siw_euclidean_distance_+3A_weights_row">weights_row</code></td>
<td>
<p>Single-row data frame where the column names contain the
column names in df and the row contains the corresponding weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance_matrix A distance matrix.
</p>

<hr>
<h2 id='snf_config'>Define configuration for generating a set of SNF-based cluster solutions</h2><span id='topic+snf_config'></span>

<h3>Description</h3>

<p><code>snf_config()</code> constructs an SNF config object which inherits from classes
<code>snf_config</code> and <code>list</code>. This object is used to store all settings
required to transform data stored in a <code>data_list</code> class object into a
space of cluster solutions by SNF. The SNF config object contains the
following components:
1. A settings data frame (inherits from <code>settings_df</code> and <code>data.frame</code>).
Data frame that stores SNF-specific hyperparameters and information
about feature selection and weighting, SNF schemes, clustering
algorithms, and distance metrics. Each row of the settings data frame
corresponds to a distinct cluster solution.
2. A clustering algorithms list (inherits from <code>clust_fns_list</code> and
<code>list</code>), which stores all clustering algorithms that the settings
data frame can point to.
3. A distance metrics list (inherits from <code>dist_metrics_list</code> and
<code>list</code>), which stores all distance metrics that the settings data
frame can point to.
4. A weights matrix (inherits from <code>weights_matrix</code>, <code>matrix</code>, and
<code>array</code>'), which stores the feature weights to use prior to distance
calculations. Each column of the weights matrix corresponds to a
different feature in the data list and each row corresponds to a
different row in the settings data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snf_config(
  dl = NULL,
  sdf = NULL,
  dfl = NULL,
  cfl = NULL,
  wm = NULL,
  n_solutions = 0,
  min_removed_inputs = 0,
  max_removed_inputs = length(dl) - 1,
  dropout_dist = "exponential",
  min_alpha = NULL,
  max_alpha = NULL,
  min_k = NULL,
  max_k = NULL,
  min_t = NULL,
  max_t = NULL,
  alpha_values = NULL,
  k_values = NULL,
  t_values = NULL,
  possible_snf_schemes = c(1, 2, 3),
  clustering_algorithms = NULL,
  continuous_distances = NULL,
  discrete_distances = NULL,
  ordinal_distances = NULL,
  categorical_distances = NULL,
  mixed_distances = NULL,
  snf_input_weights = NULL,
  snf_domain_weights = NULL,
  retry_limit = 10,
  cnt_dist_fns = NULL,
  dsc_dist_fns = NULL,
  ord_dist_fns = NULL,
  cat_dist_fns = NULL,
  mix_dist_fns = NULL,
  automatic_standard_normalize = FALSE,
  use_default_dist_fns = FALSE,
  clust_fns = NULL,
  use_default_clust_fns = FALSE,
  weights_fill = "ones"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snf_config_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_sdf">sdf</code></td>
<td>
<p>A <code>settings_df</code> class object. Overrides settings data frame
related parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_dfl">dfl</code></td>
<td>
<p>A <code>dist_fns_list</code> class object. Overrides distance functions list
related parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_cfl">cfl</code></td>
<td>
<p>A <code>clust_fns_list</code> class object. Overrides clustering functions
list related parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_wm">wm</code></td>
<td>
<p>A <code>weights_matrix</code> class object. Overrides weights matrix
related parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_n_solutions">n_solutions</code></td>
<td>
<p>Number of rows to generate for the settings data frame.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_min_removed_inputs">min_removed_inputs</code></td>
<td>
<p>The smallest number of input data frames that may be
randomly removed. By default, 0.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_max_removed_inputs">max_removed_inputs</code></td>
<td>
<p>The largest number of input data frames that may be
randomly removed. By default, this is 1 less than all the provided input
data frames in the data list.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_dropout_dist">dropout_dist</code></td>
<td>
<p>Parameter controlling how the random removal of input
data frames should occur. Can be &quot;none&quot; (no input data frames are randomly
removed), &quot;uniform&quot; (uniformly sample between min_removed_inputs and
max_removed_inputs to determine number of input data frames to remove), or
&quot;exponential&quot; (pick number of input data frames to remove by sampling from
min_removed_inputs to max_removed_inputs with an exponential distribution;
the default).</p>
</td></tr>
<tr><td><code id="snf_config_+3A_min_alpha">min_alpha</code></td>
<td>
<p>The minimum value that the alpha hyperparameter can have.
Random assigned value of alpha for each row will be obtained by uniformly
sampling numbers between <code>min_alpha</code> and <code>max_alpha</code> at intervals of 0.1.
Cannot be used in conjunction with the <code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_max_alpha">max_alpha</code></td>
<td>
<p>The maximum value that the alpha hyperparameter can have.
See <code>min_alpha</code> parameter. Cannot be used in conjunction with the
<code>alpha_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_min_k">min_k</code></td>
<td>
<p>The minimum value that the k hyperparameter can have.
Random assigned value of k for each row will be obtained by uniformly
sampling numbers between <code>min_k</code> and <code>max_k</code> at intervals of 1.
Cannot be used in conjunction with the <code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_max_k">max_k</code></td>
<td>
<p>The maximum value that the k hyperparameter can have.
See <code>min_k</code> parameter. Cannot be used in conjunction with the
<code>k_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_min_t">min_t</code></td>
<td>
<p>The minimum value that the t hyperparameter can have.
Random assigned value of t for each row will be obtained by uniformly
sampling numbers between <code>min_t</code> and <code>max_t</code> at intervals of 1.
Cannot be used in conjunction with the <code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_max_t">max_t</code></td>
<td>
<p>The maximum value that the t hyperparameter can have.
See <code>min_t</code> parameter. Cannot be used in conjunction with the
<code>t_values</code> parameter.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_alpha_values">alpha_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that alpha can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_alpha</code> or <code>max_alpha</code>
parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_k_values">k_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that k can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_k</code> or <code>max_k</code>
parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_t_values">t_values</code></td>
<td>
<p>A number or numeric vector of a set of possible values
that t can take on. Value will be obtained by uniformly sampling the
vector. Cannot be used in conjunction with the <code>min_t</code> or <code>max_t</code>
parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_possible_snf_schemes">possible_snf_schemes</code></td>
<td>
<p>A vector containing the possible snf_schemes to
uniformly randomly select from. By default, the vector contains all
3 possible schemes: c(1, 2, 3). 1 corresponds to the &quot;individual&quot; scheme,
2 corresponds to the &quot;domain&quot; scheme, and 3 corresponds to the &quot;twostep&quot;
scheme.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_clustering_algorithms">clustering_algorithms</code></td>
<td>
<p>A list of clustering algorithms to uniformly
randomly pick from when clustering. When not specified, randomly select
between spectral clustering using the eigen-gap heuristic and spectral
clustering using the rotation cost heuristic. See ?clust_fns_list
for more details on running custom clustering algorithms.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_continuous_distances">continuous_distances</code></td>
<td>
<p>A vector of continuous distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_discrete_distances">discrete_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_ordinal_distances">ordinal_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_categorical_distances">categorical_distances</code></td>
<td>
<p>A vector of categorical distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_mixed_distances">mixed_distances</code></td>
<td>
<p>A vector of mixed distance metrics to use
when a custom dist_fns_list is provided.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_snf_input_weights">snf_input_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge individual input measures (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="snf_config_+3A_snf_domain_weights">snf_domain_weights</code></td>
<td>
<p>Nested list containing weights for when SNF is
used to merge domains (see ?generate_snf_weights)</p>
</td></tr>
<tr><td><code id="snf_config_+3A_retry_limit">retry_limit</code></td>
<td>
<p>The maximum number of attempts to generate a novel row.
This function does not return matrices with identical rows. As the range of
requested possible settings tightens and the number of requested rows
increases, the risk of randomly generating a row that already exists
increases. If a new random row has matched an existing row <code>retry_limit</code>
number of times, the function will terminate.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_cnt_dist_fns">cnt_dist_fns</code></td>
<td>
<p>A named list of continuous distance metric functions.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_dsc_dist_fns">dsc_dist_fns</code></td>
<td>
<p>A named list of discrete distance metric functions.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_ord_dist_fns">ord_dist_fns</code></td>
<td>
<p>A named list of ordinal distance metric functions.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_cat_dist_fns">cat_dist_fns</code></td>
<td>
<p>A named list of categorical distance metric functions.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_mix_dist_fns">mix_dist_fns</code></td>
<td>
<p>A named list of mixed distance metric functions.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_automatic_standard_normalize">automatic_standard_normalize</code></td>
<td>
<p>If TRUE, will automatically use
standard normalization prior to calculation of any numeric distances. This
parameter overrides all other distance functions list-related parameters.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_use_default_dist_fns">use_default_dist_fns</code></td>
<td>
<p>If TRUE, prepend the base distance metrics
(euclidean distance for continuous, discrete, and ordinal data and gower
distance for categorical and mixed data) to the resulting distance metrics
list.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_clust_fns">clust_fns</code></td>
<td>
<p>A list of named clustering functions</p>
</td></tr>
<tr><td><code id="snf_config_+3A_use_default_clust_fns">use_default_clust_fns</code></td>
<td>
<p>If TRUE, prepend the base clustering algorithms
(spectral_eigen and spectral_rot, which apply spectral clustering and use
the eigen-gap and rotation cost heuristics respectively for determining
the number of clusters in the graph) to clust_fns.</p>
</td></tr>
<tr><td><code id="snf_config_+3A_weights_fill">weights_fill</code></td>
<td>
<p>String indicating what to populate generate rows with.
Can be &quot;ones&quot; (default; fill matrix with 1), &quot;uniform&quot; (fill matrix with
uniformly distributed random values), or &quot;exponential&quot; (fill matrix with
exponentially distributed random values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>snf_config</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple random config for 5 cluster solutions
input_dl &lt;- data_list(
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)
my_sc &lt;- snf_config(
    dl = input_dl,
    n_solutions = 5
)

# specifying possible K range
my_sc &lt;- snf_config(
    dl = input_dl,
    n_solutions = 5,
    min_k = 20,
    max_k = 40
)

# Random feature weights across from uniform distribution
my_sc &lt;- snf_config(
    dl = input_dl,
    n_solutions = 5,
    min_k = 20,
    max_k = 40,
    weights_fill = "uniform"
)

# Specifying custom pre-built clustering and distance functions
# - Random alternation between 2-cluster and 5-cluster solutions
# - When continuous or discrete data frames are being processed,
#   randomly alternate between standardized/normalized Euclidean
#   distance vs. regular Euclidean distance
my_sc &lt;- snf_config(
    dl = input_dl,
    n_solutions = 5,
    min_k = 20,
    max_k = 40,
    weights_fill = "uniform",
    clust_fns = list(
        "two_cluster_spectral" = spectral_two,
        "five_cluster_spectral" = spectral_five
    ),
    cnt_dist_fns = list(
         "euclidean" = euclidean_distance,
         "std_nrm_euc" = sn_euclidean_distance
    ),
    dsc_dist_fns = list(
         "euclidean" = euclidean_distance,
         "std_nrm_euc" = sn_euclidean_distance
    )
)
</code></pre>

<hr>
<h2 id='snf_scheme'>SNF schemes</h2><span id='topic+snf_scheme'></span><span id='topic+two_step_merge'></span><span id='topic+domain_merge'></span><span id='topic+individual'></span>

<h3>Description</h3>

<p>These functions manage the way in which input data frames are passed into
SNF to yield a final fused network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_step_merge(
  dl,
  k = 20,
  alpha = 0.5,
  t = 20,
  cnt_dist_fn,
  dsc_dist_fn,
  ord_dist_fn,
  cat_dist_fn,
  mix_dist_fn,
  weights_row
)

domain_merge(
  dl,
  cnt_dist_fn,
  dsc_dist_fn,
  ord_dist_fn,
  cat_dist_fn,
  mix_dist_fn,
  weights_row,
  k,
  alpha,
  t
)

individual(
  dl,
  k = 20,
  alpha = 0.5,
  t = 20,
  cnt_dist_fn,
  dsc_dist_fn,
  ord_dist_fn,
  cat_dist_fn,
  mix_dist_fn,
  weights_row
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snf_scheme_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_k">k</code></td>
<td>
<p>k hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_alpha">alpha</code></td>
<td>
<p>alpha/eta/sigma hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_t">t</code></td>
<td>
<p>SNF number of iterations hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_cnt_dist_fn">cnt_dist_fn</code></td>
<td>
<p>distance metric function for continuous data.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_dsc_dist_fn">dsc_dist_fn</code></td>
<td>
<p>distance metric function for discrete data.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_ord_dist_fn">ord_dist_fn</code></td>
<td>
<p>distance metric function for ordinal data.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_cat_dist_fn">cat_dist_fn</code></td>
<td>
<p>distance metric function for categorical data.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_mix_dist_fn">mix_dist_fn</code></td>
<td>
<p>distance metric function for mixed data.</p>
</td></tr>
<tr><td><code id="snf_scheme_+3A_weights_row">weights_row</code></td>
<td>
<p>data frame row containing feature weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>individual: The &quot;vanilla&quot; scheme - does distance matrix conversions of each input
data frame separately before a single call to SNF fuses them into the final
fused network.
</p>
<p>domain_merge: Given a data list, returns a new data list where all data objects of
a particlar domain have been concatenated.
</p>
<p>two_step_merge: Individual data frames into individual similarity matrices into one fused
network per domain into one final fused network.
</p>

<hr>
<h2 id='snf_step'>Helper function for using the correct SNF scheme</h2><span id='topic+snf_step'></span>

<h3>Description</h3>

<p>Helper function for using the correct SNF scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snf_step(
  dl,
  scheme,
  k = 20,
  alpha = 0.5,
  t = 20,
  cnt_dist_fn,
  dsc_dist_fn,
  ord_dist_fn,
  cat_dist_fn,
  mix_dist_fn,
  weights_row
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snf_step_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_scheme">scheme</code></td>
<td>
<p>Which SNF system to use to achieve the final fused network.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_k">k</code></td>
<td>
<p>k hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_alpha">alpha</code></td>
<td>
<p>alpha/eta/sigma hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_t">t</code></td>
<td>
<p>SNF number of iterations hyperparameter.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_cnt_dist_fn">cnt_dist_fn</code></td>
<td>
<p>distance metric function for continuous data.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_dsc_dist_fn">dsc_dist_fn</code></td>
<td>
<p>distance metric function for discrete data.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_ord_dist_fn">ord_dist_fn</code></td>
<td>
<p>distance metric function for ordinal data.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_cat_dist_fn">cat_dist_fn</code></td>
<td>
<p>distance metric function for categorical data.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_mix_dist_fn">mix_dist_fn</code></td>
<td>
<p>distance metric function for mixed data.</p>
</td></tr>
<tr><td><code id="snf_step_+3A_weights_row">weights_row</code></td>
<td>
<p>data frame row containing feature weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fused similarity network (matrix).
</p>

<hr>
<h2 id='sol_df_col_order'>Helper function for organizing solutions df-like column order</h2><span id='topic+sol_df_col_order'></span>

<h3>Description</h3>

<p>Reorders columns of a solutions data frame to &quot;solution&quot;, &quot;nclust&quot;, &quot;mc&quot;,
then all other column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol_df_col_order(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sol_df_col_order_+3A_x">x</code></td>
<td>
<p>Object with columns &quot;solution&quot;, &quot;nclust&quot;, and &quot;mc&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with column names reordered.
</p>

<hr>
<h2 id='solutions_df'>Constructor for <code>solutions_df</code> class object</h2><span id='topic+solutions_df'></span>

<h3>Description</h3>

<p>Constructor for <code>solutions_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solutions_df(sol_dfl, smll, sc, dl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solutions_df_+3A_sol_dfl">sol_dfl</code></td>
<td>
<p>A solutions data frame-like object to be validated and
converted into a solutions data frame.</p>
</td></tr>
<tr><td><code id="solutions_df_+3A_smll">smll</code></td>
<td>
<p>A similarity matrix list-like object to be validated and used
to construct a solutions data frame.</p>
</td></tr>
<tr><td><code id="solutions_df_+3A_sc">sc</code></td>
<td>
<p>An <code>snf_config</code> object used to construct a solutions data frame.</p>
</td></tr>
<tr><td><code id="solutions_df_+3A_dl">dl</code></td>
<td>
<p>An <code>data_list</code> object used to construct a solutions data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solutions data frame (<code>solutions_df</code> class object).
</p>

<hr>
<h2 id='split_parser'>Helper function to determine which row and columns to split on</h2><span id='topic+split_parser'></span>

<h3>Description</h3>

<p>Helper function to determine which row and columns to split on
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_parser(
  row_split_vector = NULL,
  column_split_vector = NULL,
  row_split = NULL,
  column_split = NULL,
  n_rows,
  n_columns
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_parser_+3A_row_split_vector">row_split_vector</code></td>
<td>
<p>A vector of row indices to split on.</p>
</td></tr>
<tr><td><code id="split_parser_+3A_column_split_vector">column_split_vector</code></td>
<td>
<p>A vector of column indices to split on.</p>
</td></tr>
<tr><td><code id="split_parser_+3A_row_split">row_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="split_parser_+3A_column_split">column_split</code></td>
<td>
<p>Standard parameter of <code>ComplexHeatmap::Heatmap</code>.</p>
</td></tr>
<tr><td><code id="split_parser_+3A_n_rows">n_rows</code></td>
<td>
<p>The number of rows in the data.</p>
</td></tr>
<tr><td><code id="split_parser_+3A_n_columns">n_columns</code></td>
<td>
<p>The number of columns in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;list&quot;-class object containing row_split and column_split character
vectors to pass into ComplexHeatmap::Heatmap.
</p>

<hr>
<h2 id='subc_v'>Mock ABCD subcortical volumes data</h2><span id='topic+subc_v'></span>

<h3>Description</h3>

<p>Like the mock data frame &quot;abcd_subc_v&quot;, but with &quot;unique_id&quot; as the &quot;uid&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subc_v
</code></pre>


<h3>Format</h3>



<h4><code>subc_v</code></h4>

<p>A data frame with 174 rows and 31 columns:
</p>

<dl>
<dt>unique_id</dt><dd><p>The unique identifier of the ABCD dataset</p>
</dd>
<dt>...</dt><dd><p>Subcortical volumes of various ROIs (mm^3, I think)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Though this data is no longer &quot;real&quot; ABCD data, the reference for using ABCD as a data source is below:
</p>
<p>Data used in the preparation of this article were obtained from the Adolescent Brain Cognitive DevelopmentSM (ABCD) Study (https://abcdstudy.org), held in the NIMH Data Archive (NDA). This is a multisite, longitudinal study designed to recruit more than 10,000 children age 9-10 and follow them over 10 years into early adulthood. The ABCD Study® is supported by the National Institutes of Health and additional federal partners under award numbers U01DA041048, U01DA050989, U01DA051016, U01DA041022, U01DA051018, U01DA051037, U01DA050987, U01DA041174, U01DA041106, U01DA041117, U01DA041028, U01DA041134, U01DA050988, U01DA051039, U01DA041156, U01DA041025, U01DA041120, U01DA051038, U01DA041148, U01DA041093, U01DA041089, U24DA041123, U24DA041147. A full list of supporters is available at https://abcdstudy.org/federal-partners.html. A listing of participating sites and a complete listing of the study investigators can be found at https://abcdstudy.org/consortium_members/. ABCD consortium investigators designed and implemented the study and/or provided data but did not necessarily participate in the analysis or writing of this report. This manuscript reflects the views of the authors and may not reflect the opinions or views of the NIH or ABCD consortium investigators.
</p>

<hr>
<h2 id='subsample_dl'>Create subsamples of a data list</h2><span id='topic+subsample_dl'></span>

<h3>Description</h3>

<p>Given a data list, return a list of smaller data lists that are generated
through random sampling (without replacement). The results of this function
can be passed into <code>batch_snf_subsamples()</code> to obtain a list of resampled
solutions data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample_dl(
  dl,
  n_subsamples,
  subsample_fraction = NULL,
  n_observations = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_dl_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="subsample_dl_+3A_n_subsamples">n_subsamples</code></td>
<td>
<p>Number of subsamples to create.</p>
</td></tr>
<tr><td><code id="subsample_dl_+3A_subsample_fraction">subsample_fraction</code></td>
<td>
<p>Percentage of patients to include per subsample.</p>
</td></tr>
<tr><td><code id="subsample_dl_+3A_n_observations">n_observations</code></td>
<td>
<p>Number of patients to include per subsample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;list&quot; class object containing <code>n_subsamples</code> number of
data lists. Each of those data lists contains a random <code>subsample_fraction</code>
fraction of the observations of the provided data list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
</code></pre>

<hr>
<h2 id='subsample_pairwise_aris'>Calculate pairwise adjusted Rand indices across subsamples of data</h2><span id='topic+subsample_pairwise_aris'></span>

<h3>Description</h3>

<p>Given a list of subsampled solutions data frames from
'<code>batch_snf_subsamples()</code>, this function calculates the adjusted Rand
indices across all the subsamples of each solution. ARI calculation between
two subsamples only factors in observations that were present in both
subsamples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample_pairwise_aris(subsample_solutions, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_pairwise_aris_+3A_subsample_solutions">subsample_solutions</code></td>
<td>
<p>A list of solutions data frames from
subsamples of the data. This object is generated by the function
<code>batch_snf_subsamples()</code>.</p>
</td></tr>
<tr><td><code id="subsample_pairwise_aris_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output progress to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-item list: &quot;raw_aris&quot;, a list of inter-subsample pairwise ARI
matrices (one for each full cluster solution) and &quot;ari_summary&quot;, a
data frame containing the mean and SD of the inter-subsample ARIs for each
original cluster solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my_dl &lt;- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc &lt;- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# my_dl_subsamples &lt;- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results &lt;- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
# 
# pairwise_aris &lt;- subsample_pairwise_aris(
#     batch_subsample_results
#     verbose = TRUE
# )
#
# # Visualize ARIs 
# ComplexHeatmap::Heatmap(
#     pairwise_aris[[1]],
#     heatmap_legend_param = list(
#         color_bar = "continuous",
#         title = "Inter-Subsample\nARI",
#         at = c(0, 0.5, 1)
#     ),
#     show_column_names = FALSE,
#     show_row_names = FALSE
# )
</code></pre>

<hr>
<h2 id='summarize_clust_fns_list'>Summarize a clust_fns_list object</h2><span id='topic+summarize_clust_fns_list'></span>

<h3>Description</h3>

<p>Summarize a clust_fns_list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_clust_fns_list(cfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_clust_fns_list_+3A_cfl">cfl</code></td>
<td>
<p>A <code>clust_fns_list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary_df &quot;data.frame&quot; class object containing the name and index
of each clustering algorithm in te provided <code>clust_fns_list</code>.
</p>

<hr>
<h2 id='summarize_dfl'>Summarize metrics contained in a dist_fns_list</h2><span id='topic+summarize_dfl'></span>

<h3>Description</h3>

<p>Summarize metrics contained in a dist_fns_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_dfl(dist_fns_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_dfl_+3A_dist_fns_list">dist_fns_list</code></td>
<td>
<p>A dist_fns_list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;data.frame&quot;-class object summarizing items in a distance metrics
list.
</p>

<hr>
<h2 id='summarize_dl'>Summarize a data list</h2><span id='topic+summarize_dl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Defunct function for summarizing a data list. Please
use <code>summary()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_dl(data_list, scope = "component")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_dl_+3A_data_list">data_list</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="summarize_dl_+3A_scope">scope</code></td>
<td>
<p>The level of detail for the summary. Options are:
</p>

<ul>
<li><p> &quot;component&quot; (default): One row per component (data frame) in the data list.
</p>
</li>
<li><p> &quot;feature&quot;: One row for each feature in the data list.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame class object summarizing all components (or features if
scope == &quot;component&quot;).
</p>

<hr>
<h2 id='summarize_pvals'>Summarize p-value columns of an extended solutions data frame</h2><span id='topic+summarize_pvals'></span>

<h3>Description</h3>

<p>Summarize p-value columns of an extended solutions data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_pvals(ext_sol_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_pvals_+3A_ext_sol_df">ext_sol_df</code></td>
<td>
<p>Result of <code>extend_solutions</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The provided extended solutions data frame along with columns for
the min, mean, and maximum across p-values for each row.
</p>

<hr>
<h2 id='summary_features'>Pull features used to calculate summary p-values from an object</h2><span id='topic+summary_features'></span>

<h3>Description</h3>

<p>Pull features used to calculate summary p-values from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_features(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_features_+3A_x">x</code></td>
<td>
<p>The object to extract summary features from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of summary features.
</p>

<hr>
<h2 id='summary.data_list'>Summary method for class <code>data_list</code></h2><span id='topic+summary.data_list'></span>

<h3>Description</h3>

<p>Returns a data list summary (<code>data.frame</code> class object) containing
information on components, features, variable types, domains, and component
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_list'
summary(object, scope = "component", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.data_list_+3A_object">object</code></td>
<td>
<p>A <code>data_list</code> class object.</p>
</td></tr>
<tr><td><code id="summary.data_list_+3A_scope">scope</code></td>
<td>
<p>The level of detail for the summary. By default, this is set to
&quot;component&quot;, which returns a summary of the data list at the component
level. Can also be set to &quot;feature&quot;, resulting in a summary at the feature
level.</p>
</td></tr>
<tr><td><code id="summary.data_list_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>summary</code> (not used in this function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> class object. If <code>scope</code> is &quot;component&quot;, each row
shows the name, variable type, domain, and dimensions of each component. If
<code>scope</code> is &quot;feature&quot;, each row shows the name, variable type, and domain of
each feature.
</p>

<hr>
<h2 id='train_test_assign'>Training and testing split</h2><span id='topic+train_test_assign'></span>

<h3>Description</h3>

<p>Given a vector of uid_id and a threshold, returns a list of which members
should be in the training set and which should be in the testing set. The
function relies on whether or not the absolute value of the Jenkins's
one_at_a_time hash function exceeds the maximum possible value
(2147483647) multiplied by the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_test_assign(train_frac, uids, seed = 42)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_test_assign_+3A_train_frac">train_frac</code></td>
<td>
<p>The fraction (0 to 1) of observations for training</p>
</td></tr>
<tr><td><code id="train_test_assign_+3A_uids">uids</code></td>
<td>
<p>A character vector of UIDs to be distributed into training and
test sets.</p>
</td></tr>
<tr><td><code id="train_test_assign_+3A_seed">seed</code></td>
<td>
<p>Seed used for Jenkins's one_at_a_time hash function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the training and testing uid_ids.
</p>

<hr>
<h2 id='uids'>Pull UIDs from an object</h2><span id='topic+uids'></span>

<h3>Description</h3>

<p>Pull UIDs from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uids(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uids_+3A_x">x</code></td>
<td>
<p>The object to extract UIDs from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of UIDs.
</p>

<hr>
<h2 id='validate_ari_matrix'>Validator for <code>ari_matrix</code> class object</h2><span id='topic+validate_ari_matrix'></span>

<h3>Description</h3>

<p>Validator for <code>ari_matrix</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_ari_matrix(aml)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_ari_matrix_+3A_aml">aml</code></td>
<td>
<p>An ari_matrix-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If aml has a valid structure for a <code>ari_matrix</code> class
object, returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_clust_fns_list'>Validator for <code>clust_fns_list</code> class object</h2><span id='topic+validate_clust_fns_list'></span>

<h3>Description</h3>

<p>Validator for <code>clust_fns_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_clust_fns_list(cfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_clust_fns_list_+3A_cfll">cfll</code></td>
<td>
<p>A clust_fns_list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If cfll has a valid structure for a <code>clust_fns_list</code> class object,
returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_data_list'>Validator for data_list class object</h2><span id='topic+validate_data_list'></span>

<h3>Description</h3>

<p>Validator for data_list class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data_list(dll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_data_list_+3A_dll">dll</code></td>
<td>
<p>A data list-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If dll has a valid structure for a <code>data_list</code> class object,
returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_dist_fns_list'>Validator for dist_fns_list class object</h2><span id='topic+validate_dist_fns_list'></span>

<h3>Description</h3>

<p>Validator for dist_fns_list class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_dist_fns_list(dfll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_dist_fns_list_+3A_dfll">dfll</code></td>
<td>
<p>A distance metrics list-like list object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If dfll has a valid structure for a <code>dist_fns_list</code> class
object, returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_ext_solutions_df'>Validator for <code>ext_solutions_df</code> class object</h2><span id='topic+validate_ext_solutions_df'></span>

<h3>Description</h3>

<p>Validator for <code>ext_solutions_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_ext_solutions_df(ext_sol_dfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_ext_solutions_df_+3A_ext_sol_dfl">ext_sol_dfl</code></td>
<td>
<p>An extended solutions data frame-like object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If ext_sol_dfl has a valid structure for an object of class
ext_solutions_df, returns ext_sol_dfl. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_settings_df'>Validator for <code>settings_df</code> class object</h2><span id='topic+validate_settings_df'></span>

<h3>Description</h3>

<p>Validator for <code>settings_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_settings_df(sdfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_settings_df_+3A_sdfl">sdfl</code></td>
<td>
<p>A settings data frame-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If sdfl has a valid structure for a <code>settings_df</code> class object,
returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_sim_mats_list'>Validator for <code>similarity_matrix_list</code> class object</h2><span id='topic+validate_sim_mats_list'></span>

<h3>Description</h3>

<p>Validator for <code>similarity_matrix_list</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_sim_mats_list(smll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_sim_mats_list_+3A_smll">smll</code></td>
<td>
<p>A similarity matrix list-like object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If smll has a valid structure for class <code>similarity_matrix_list</code>,
returns smll. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_snf_config'>Validator for snf_config class object</h2><span id='topic+validate_snf_config'></span>

<h3>Description</h3>

<p>Validator for snf_config class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_snf_config(scl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_snf_config_+3A_scl">scl</code></td>
<td>
<p>An SNF config-like <code>list</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If dll has a valid structure for a <code>data_list</code> class object,
returns input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_solutions_df'>Validator for <code>solutions_df</code> class object</h2><span id='topic+validate_solutions_df'></span>

<h3>Description</h3>

<p>Validator for <code>solutions_df</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_solutions_df(sol_dfl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_solutions_df_+3A_sol_dfl">sol_dfl</code></td>
<td>
<p>A solutions data frame-like object to be validated and
converted into a solutions data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If sol_dfl has a valid structure for a <code>solutions_df</code> class object,
returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='validate_weights_matrix'>Validator for <code>weights_matrix</code> class object</h2><span id='topic+validate_weights_matrix'></span>

<h3>Description</h3>

<p>Validator for <code>weights_matrix</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_weights_matrix(wml)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_weights_matrix_+3A_wml">wml</code></td>
<td>
<p>A weights_matrix-like matrix object to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If wml has a valid structure for a <code>weights_matrix</code> class
object, returns the input unchanged. Otherwise, raises an error.
</p>

<hr>
<h2 id='var_manhattan_plot'>Manhattan plot of feature-feature association p-values</h2><span id='topic+var_manhattan_plot'></span>

<h3>Description</h3>

<p>Manhattan plot of feature-feature association p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_manhattan_plot(
  dl,
  key_var,
  neg_log_pval_thresh = 5,
  threshold = NULL,
  point_size = 5,
  text_size = 20,
  plot_title = NULL,
  hide_x_labels = FALSE,
  bonferroni_line = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_manhattan_plot_+3A_dl">dl</code></td>
<td>
<p>List of data frames containing data information.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_key_var">key_var</code></td>
<td>
<p>Feature for which the association p-values of all other
features are plotted.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_neg_log_pval_thresh">neg_log_pval_thresh</code></td>
<td>
<p>Threshold for negative log p-values.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_threshold">threshold</code></td>
<td>
<p>p-value threshold to plot dashed line at.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_point_size">point_size</code></td>
<td>
<p>Size of points in the plot.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_text_size">text_size</code></td>
<td>
<p>Size of text in the plot.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_plot_title">plot_title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_hide_x_labels">hide_x_labels</code></td>
<td>
<p>If TRUE, hides x-axis labels.</p>
</td></tr>
<tr><td><code id="var_manhattan_plot_+3A_bonferroni_line">bonferroni_line</code></td>
<td>
<p>If TRUE, plots a dashed black line at the
Bonferroni-corrected equivalent of the p-value threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Manhattan plot (class &quot;gg&quot;, &quot;ggplot&quot;) showing the association
p-values of features against one key feature in a data list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dl &lt;- data_list(
    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
    list(income, "household_income", "demographics", "continuous"),
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    list(anxiety, "anxiety", "behaviour", "ordinal"),
    list(depress, "depressed", "behaviour", "ordinal"),
    uid = "unique_id"
)

var_manhattan &lt;- var_manhattan_plot(
    dl,
    key_var = "household_income",
    plot_title = "Correlation of Features with Household Income",
    text_size = 16,
    neg_log_pval_thresh = 3,
    threshold = 0.05
)
</code></pre>

<hr>
<h2 id='weights_matrix'>Generate a matrix to store feature weights</h2><span id='topic+weights_matrix'></span>

<h3>Description</h3>

<p>Function for building a weights matrix independently of an SNF config. The
weights matrix contains one row corresponding to each row of the settings
data frame in an SNF config (one row for each resulting cluster solution)
and one column for each feature in the data list used for clustering. Values
of the weights matrix are passed to distance metrics functions during the
conversion of input data frames to distance matrices. Typically, there is no
need to use this function directly. Instead, users should provide weights
matrix-building parameters to the <code>snf_config()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_matrix(dl = NULL, n_solutions = 1, weights_fill = "ones")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_matrix_+3A_dl">dl</code></td>
<td>
<p>A nested list of input data from <code>data_list()</code>.</p>
</td></tr>
<tr><td><code id="weights_matrix_+3A_n_solutions">n_solutions</code></td>
<td>
<p>Number of rows to generate the template weights matrix
for.</p>
</td></tr>
<tr><td><code id="weights_matrix_+3A_weights_fill">weights_fill</code></td>
<td>
<p>String indicating what to populate generate rows with.
Can be &quot;ones&quot; (default; fill matrix with 1), &quot;uniform&quot; (fill matrix with
uniformly distributed random values), or &quot;exponential&quot; (fill matrix with
exponentially distributed random values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wm A properly formatted matrix containing columns for
all the features that require weights and rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dl &lt;- data_list(
    list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
    list(income, "income", "demographics", "continuous"),
    list(pubertal, "pubertal_status", "demographics", "continuous"),
    uid = "unique_id"
)

sc &lt;- snf_config(input_dl, n_solutions = 5)

wm &lt;- weights_matrix(input_dl, n_solutions = 5, weights_fill = "uniform")

# updating an SNF config in parts
sc$"weights_matrix" &lt;- wm
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
