<!DOCTYPE html><html><head><title>Help for package saemix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {saemix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B'><p>Get/set methods for SaemixData object</p></a></li>
<li><a href='#+5B+2CSaemixModel-method'><p>Get/set methods for SaemixModel object</p></a></li>
<li><a href='#+5B+2CSaemixObject-method'><p>Get/set methods for SaemixObject object</p></a></li>
<li><a href='#+5B+2CSaemixRes-method'><p>Get/set methods for SaemixRes object</p></a></li>
<li><a href='#backward.procedure'><p>Backward procedure for joint selection of covariates and random effects</p></a></li>
<li><a href='#checkInitialFixedEffects'><p>Check initial fixed effects for an SaemixModel object applied to an SaemixData object</p></a></li>
<li><a href='#coef.saemix'><p>Extract coefficients from an saemix fit</p></a></li>
<li><a href='#compare.saemix'><p>Model comparison with information criteria (AIC, BIC).</p></a></li>
<li><a href='#conddist.saemix'><p>Estimate conditional mean and variance of individual parameters using the</p>
MCMC algorithm</a></li>
<li><a href='#cow.saemix'><p>Evolution of the weight of 560 cows, in SAEM format</p></a></li>
<li><a href='#createSaemixObject'><p>Create saemix objects with only data filled in</p></a></li>
<li><a href='#dataGen.case'><p>Bootstrap datasets</p></a></li>
<li><a href='#default.saemix.plots'><p>Wrapper functions to produce certain sets of default plots</p></a></li>
<li><a href='#discreteVPC'><p>VPC for non Gaussian data models</p></a></li>
<li><a href='#discreteVPCTTE'><p>VPC for time-to-event models</p></a></li>
<li><a href='#epilepsy.saemix'><p>Epilepsy count data</p></a></li>
<li><a href='#fim.saemix'><p>Computes the Fisher Information Matrix by linearisation</p></a></li>
<li><a href='#fitted.saemix'><p>Extract Model Predictions</p></a></li>
<li><a href='#forward.procedure'><p>Backward procedure for joint selection of covariates and random effects</p></a></li>
<li><a href='#initialize-methods'><p>Methods for Function initialize</p></a></li>
<li><a href='#knee.saemix'><p>Knee pain data</p></a></li>
<li><a href='#llgq.saemix'><p>Log-likelihood using Gaussian Quadrature</p></a></li>
<li><a href='#llis.saemix'><p>Log-likelihood using Importance Sampling</p></a></li>
<li><a href='#logLik'><p>Extract likelihood from an SaemixObject resulting from a call to saemix</p></a></li>
<li><a href='#lung.saemix'><p>NCCTG Lung Cancer Data, in SAEM format</p></a></li>
<li><a href='#map.saemix'><p>Estimates of the individual parameters (conditional mode)</p></a></li>
<li><a href='#mydiag'><p>Matrix diagonal</p></a></li>
<li><a href='#npdeSaemix'><p>Create an npdeObject from an saemixObject</p></a></li>
<li><a href='#oxboys.saemix'><p>Heights of Boys in Oxford</p></a></li>
<li><a href='#PD1.saemix'><p>Data simulated according to an Emax response model, in SAEM format</p></a></li>
<li><a href='#plot-methods'><p>Methods for Function plot</p></a></li>
<li><a href='#plot+2CSaemixModel+2CANY-method'><p>Plot model predictions using an SaemixModel object</p></a></li>
<li><a href='#plot+2CSaemixModel+2CSaemixData-method'><p>Plot model predictions for a new dataset. If the dataset is large, only the first 20 subjects (id's) will be shown.</p></a></li>
<li><a href='#plot+2CSaemixObject+2CANY-method'><p>General plot function from SAEM</p></a></li>
<li><a href='#plot.SaemixData'><p>Plot of longitudinal data</p></a></li>
<li><a href='#plotDiscreteData'><p>Plot non Gaussian data</p></a></li>
<li><a href='#predict-methods'><p>Methods for Function predict</p></a></li>
<li><a href='#predict.SaemixModel'><p>Predictions for a new dataset</p></a></li>
<li><a href='#print-methods'><p>Methods for Function print</p></a></li>
<li><a href='#psi-methods'><p>Functions to extract the individual estimates of the parameters and random</p>
effects</a></li>
<li><a href='#rapi.saemix'><p>Rutgers Alcohol Problem Index</p></a></li>
<li><a href='#readSaemix-methods'><p>Methods for Function read</p></a></li>
<li><a href='#readSaemix+2CSaemixData-method'><p>Create a longitudinal data structure from a file or a dataframe</p>
</p>
<p>Helper function not intended to be called by the user</p></a></li>
<li><a href='#replaceData'><p>Replace the data element in an SaemixObject object</p></a></li>
<li><a href='#resid.saemix'><p>Extract Model Residuals</p></a></li>
<li><a href='#saemix'><p>Stochastic Approximation Expectation Maximization (SAEM) algorithm</p></a></li>
<li><a href='#saemix.bootstrap'><p>Bootstrap for saemix fits</p></a></li>
<li><a href='#saemix.internal'><p>Internal saemix objects</p></a></li>
<li><a href='#saemix.plot.data'><p>Functions implementing each type of plot in SAEM</p></a></li>
<li><a href='#saemix.plot.select'><p>Plots of the results obtained by SAEM</p></a></li>
<li><a href='#saemix.plot.setoptions'><p>Function setting the default options for the plots in SAEM</p></a></li>
<li><a href='#saemix.predict'><p>Compute model predictions after an saemix fit</p></a></li>
<li><a href='#saemixControl'><p>List of options for running the algorithm SAEM</p></a></li>
<li><a href='#saemixData'><p>Function to create an SaemixData object</p></a></li>
<li><a href='#SaemixData-class'><p>Class &quot;SaemixData&quot;</p></a></li>
<li><a href='#saemixModel'><p>Function to create an SaemixModel object</p></a></li>
<li><a href='#SaemixModel-class'><p>Class &quot;SaemixModel&quot;</p></a></li>
<li><a href='#SaemixObject-class'><p>Class &quot;SaemixObject&quot;</p></a></li>
<li><a href='#saemixPredictNewdata'><p>Predictions for a new dataset</p></a></li>
<li><a href='#SaemixRes-class'><p>Class &quot;SaemixRes&quot;</p></a></li>
<li><a href='#show-methods'><p>Methods for Function show</p></a></li>
<li><a href='#showall-methods'><p>Methods for Function showall</p></a></li>
<li><a href='#simulate.SaemixObject'><p>Perform simulations under the model for an saemixObject object</p></a></li>
<li><a href='#simulateDiscreteSaemix'><p>Perform simulations under the model for an saemixObject object defined by its log-likelihood</p></a></li>
<li><a href='#step.saemix'><p>Stepwise procedure for joint selection of covariates and random effects</p></a></li>
<li><a href='#stepwise.procedure'><p>Stepwise procedure for joint selection of covariates and random effects</p></a></li>
<li><a href='#subset'><p>Data subsetting</p></a></li>
<li><a href='#summary-methods'><p>Methods for Function summary</p></a></li>
<li><a href='#testnpde'><p>Tests for normalised prediction distribution errors</p></a></li>
<li><a href='#theo.saemix'><p>Pharmacokinetics of theophylline</p></a></li>
<li><a href='#toenail.saemix'><p>Toenail data</p></a></li>
<li><a href='#transform'><p>Transform covariates</p></a></li>
<li><a href='#transformCatCov'><p>Transform covariates</p></a></li>
<li><a href='#transformContCov'><p>Transform covariates</p></a></li>
<li><a href='#validate.covariance.model'><p>Validate the structure of the covariance model</p></a></li>
<li><a href='#validate.names'><p>Name validation (## )Helper function not intended to be called by the user)</p></a></li>
<li><a href='#vcov'><p>Extracts the Variance-Covariance Matrix for a Fitted Model Object</p></a></li>
<li><a href='#xbinning'><p>Internal functions used to produce prediction intervals (from the npde package)</p></a></li>
<li><a href='#yield.saemix'><p>Wheat yield in crops treated with fertiliser, in SAEM format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stochastic Approximation Expectation Maximization (SAEM)
Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'saemix' package implements the Stochastic Approximation EM algorithm for parameter estimation in (non)linear mixed effects models. The SAEM algorithm (i) computes the maximum likelihood estimator of the population parameters, without any approximation of the model (linearisation, quadrature approximation,...), using the Stochastic Approximation Expectation Maximization (SAEM) algorithm, (ii) provides standard errors for the maximum likelihood estimator (iii) estimates the conditional modes, the conditional means and the conditional standard deviations of the individual parameters, using the Hastings-Metropolis algorithm (see Comets et al. (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i03">doi:10.18637/jss.v080.i03</a>&gt;). Many applications of SAEM in agronomy, animal breeding and PKPD analysis have been published by members of the Monolix group. The full PDF documentation for the package including references about the algorithm and examples can be downloaded on the github of the IAME research institute for 'saemix': <a href="https://github.com/iame-researchCenter/saemix/blob/7638e1b09ccb01cdff173068e01c266e906f76eb/docsaem.pdf">https://github.com/iame-researchCenter/saemix/blob/7638e1b09ccb01cdff173068e01c266e906f76eb/docsaem.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, methods, gridExtra, ggplot2, grid, rlang,
mclust, scales, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, survival</td>
</tr>
<tr>
<td>Depends:</td>
<td>npde (&ge; 3.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa_generics.R' 'SaemixData.R' 'SaemixModel.R' 'SaemixRes.R'
'SaemixObject.R' 'backward.R' 'compute_LL.R' 'forward.R'
'func_FIM.R' 'func_aux.R' 'func_bootstrap.R' 'func_compare.R'
'func_discreteVPC.R' 'func_distcond.R' 'func_estimParam.R'
'func_exploreData.R' 'func_npde.R' 'func_plots.R'
'func_simulations.R' 'func_stepwise.R' 'main.R' 'main_estep.R'
'main_initialiseMainAlgo.R' 'main_mstep.R' 'stepwise.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 21:29:34 UTC; eco</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuelle Comets [aut, cre],
  Audrey Lavenu [aut],
  Marc Lavielle [aut],
  Belhal Karimi [aut],
  Maud Delattre [ctb],
  Marilou Chanel [ctb],
  Johannes Ranke <a href="https://orcid.org/0000-0003-4371-6538"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sofia Kaisaridi [ctb],
  Lucie Fayette [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuelle Comets &lt;emmanuelle.comets@inserm.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B'>Get/set methods for SaemixData object</h2><span id='topic++5B'></span><span id='topic++5B+3C-+2CSaemixData-method'></span><span id='topic++5B+2CSaemixData-method'></span><span id='topic++5B+2CSaemixRepData-method'></span><span id='topic++5B+3C-+2CSaemixRepData-method'></span><span id='topic++5B+2CSaemixSimData-method'></span><span id='topic++5B+3C-+2CSaemixSimData-method'></span><span id='topic++5B+3C-+2CSaemixRes-method'></span>

<h3>Description</h3>

<p>Access slots of an SaemixData object using the object[&quot;slot&quot;] format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
x[i, j, drop]

## S4 method for signature 'SaemixRepData'
x[i, j, drop]

## S4 replacement method for signature 'SaemixRepData'
x[i, j] &lt;- value

## S4 method for signature 'SaemixSimData'
x[i, j, drop]

## S4 replacement method for signature 'SaemixSimData'
x[i, j] &lt;- value

## S4 replacement method for signature 'SaemixRes'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_i">i</code></td>
<td>
<p>element to be replaced</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_j">j</code></td>
<td>
<p>element to replace with</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_drop">drop</code></td>
<td>
<p>whether to drop unused dimensions</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_value">value</code></td>
<td>
<p>value to replace with</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSaemixModel-method'>Get/set methods for SaemixModel object</h2><span id='topic++5B+2CSaemixModel-method'></span>

<h3>Description</h3>

<p>Access slots of an SaemixModel object using the object[&quot;slot&quot;] format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixModel'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSaemixModel-method_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixModel-method_+3A_i">i</code></td>
<td>
<p>element to be replaced</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixModel-method_+3A_j">j</code></td>
<td>
<p>element to replace with</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixModel-method_+3A_drop">drop</code></td>
<td>
<p>whether to drop unused dimensions</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSaemixObject-method'>Get/set methods for SaemixObject object</h2><span id='topic++5B+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Access slots of an SaemixObject object using the object[&quot;slot&quot;] format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixObject'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSaemixObject-method_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixObject-method_+3A_i">i</code></td>
<td>
<p>element to be replaced</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixObject-method_+3A_j">j</code></td>
<td>
<p>element to replace with</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixObject-method_+3A_drop">drop</code></td>
<td>
<p>whether to drop unused dimensions</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSaemixRes-method'>Get/set methods for SaemixRes object</h2><span id='topic++5B+2CSaemixRes-method'></span>

<h3>Description</h3>

<p>Access slots of a SaemixRes object using the object[&quot;slot&quot;] format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixRes'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSaemixRes-method_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixRes-method_+3A_i">i</code></td>
<td>
<p>element to be replaced</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixRes-method_+3A_j">j</code></td>
<td>
<p>element to replace with</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSaemixRes-method_+3A_drop">drop</code></td>
<td>
<p>whether to drop unused dimensions</p>
</td></tr>
</table>

<hr>
<h2 id='backward.procedure'>Backward procedure for joint selection of covariates and random effects</h2><span id='topic+backward.procedure'></span>

<h3>Description</h3>

<p>Joint selection of covariates and random effects in a nonlinear mixed effects model by a backward-type
algorithm based on two different versions of BIC for covariate selection and random effects selection
respectively. Selection is made among the covariates as such specified in the SaemixData object.
Only uncorrelated random effects structures are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward.procedure(saemixObject, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backward.procedure_+3A_saemixobject">saemixObject</code></td>
<td>
<p>An object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="backward.procedure_+3A_trace">trace</code></td>
<td>
<p>If TRUE, a table summarizing the steps of the algorithm is printed. Default &quot;TRUE&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the SaemixObject class storing the covariate model and the covariance structure of
random effects of the final model.
</p>


<h3>Author(s)</h3>

<p>Maud Delattre
</p>


<h3>References</h3>

<p>M Delattre, M Lavielle, MA Poursat (2014) A note on BIC in mixed effects models.
Electronic Journal of Statistics 8(1) p. 456-475
M Delattre, MA Poursat (2017) BIC strategies for model choice in a population approach.
(arXiv:1612.02405)
</p>

<hr>
<h2 id='checkInitialFixedEffects'>Check initial fixed effects for an SaemixModel object applied to an SaemixData object</h2><span id='topic+checkInitialFixedEffects'></span>

<h3>Description</h3>

<p>Check initial fixed effects for an SaemixModel object applied to an SaemixData object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInitialFixedEffects(model, data, psi = c(), id = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkInitialFixedEffects_+3A_model">model</code></td>
<td>
<p>an SaemixModel object</p>
</td></tr>
<tr><td><code id="checkInitialFixedEffects_+3A_data">data</code></td>
<td>
<p>an SaemixData object (the predictors will then be extracted from the object using the name.predictors slot of the object)</p>
</td></tr>
<tr><td><code id="checkInitialFixedEffects_+3A_psi">psi</code></td>
<td>
<p>a vector or a dataframe giving the parameters for which predictions are to be computed (defaults to empty).
The number of columns in psi (or the number of elements of psi, if psi is given as a vector) should match the number of
parameters in the model, otherwise an error message will be shown and the function will return empty.
If psi is NA, the predictions are computed for the population parameters in the model (first line of the psi0 slot).
Covariates are not taken into account in the prediction.
If psi is a dataframe, each line will be used for a separate 'subject' in the predictors dataframe, as
indicated by the id argument; if id is not given, only the first line of psi will be used.</p>
</td></tr>
<tr><td><code id="checkInitialFixedEffects_+3A_id">id</code></td>
<td>
<p>the vector of subjects for which individual plots will be obtained. If empty, the first 12 subjects in the dataset will be used (subject id's are taken from the name.group slot in the data object). If id is given, individual plots will be shown for the matching subjects in the dataset (eg if id=c(1:6), the first 6 subjects in the dataframe will be used for the plots, retrieving their ID from the data object)</p>
</td></tr>
<tr><td><code id="checkInitialFixedEffects_+3A_...">...</code></td>
<td>
<p>unused argument, for consistency with the generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the model slot of the SaemixModel object to obtain predictions, using the predictors object. The
user is responsible for giving all the predictors needed by the model function.
if psi is not given, the predictions will be computed for the population parameters (first line of the psi0 slot) of the object.
</p>
<p>The predictions correspond to the structure of the model. For models defined as a structural model,
individual plots for the subjects in id overlaying the predictions for the parameters psi and the individual data
are shown, and the predictions correspond to f(t_ij, psi).
For models defined in terms of their likelihood, the predictions returned correspond to the log-likelihood.
No individual graphs are currently available for discrete data models.
</p>
<p>Warning: this function is currently under development and the output may change in future versions of the package
</p>


<h3>Value</h3>

<p>the predictions corresponding to the values for each observation in the predictors of either the model f or log-likelihood.
For Gaussian data models, the function also plots the data overlayed with the model predictions for each subject in id
(where id is the index in the N subjects).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

checkInitialFixedEffects(saemix.model, saemix.data, id=c(1:6))
checkInitialFixedEffects(saemix.model, saemix.data, id=c(1:6), psi=c(0.5, 30, 2)) # better fit

</code></pre>

<hr>
<h2 id='coef.saemix'>Extract coefficients from an saemix fit</h2><span id='topic+coef.saemix'></span><span id='topic+coef.SaemixObject'></span><span id='topic+coef'></span><span id='topic+coef+2CSaemixObject'></span><span id='topic+coef+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Extract coefficients from an saemix fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixObject'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.saemix_+3A_object">object</code></td>
<td>
<p>an SaemixObject object</p>
</td></tr>
<tr><td><code id="coef.saemix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 3 components:
</p>

<dl>
<dt>fixed</dt><dd><p>fixed effects</p>
</dd>
<dt>population</dt><dd><p>a list of population parameters with two elements, a matrix containing the untransformed parameters psi and a matrix containing the transformed parameters phi</p>
</dd>
<dt>individual</dt><dd><p>a list of individual parameters with two elements, a matrix containing the untransformed parameters psi and a matrix containing the transformed parameters phi</p>
</dd>
</dl>


<hr>
<h2 id='compare.saemix'>Model comparison with information criteria (AIC, BIC).</h2><span id='topic+compare.saemix'></span>

<h3>Description</h3>

<p>A specific penalty is used for BIC (BIC.cov) when the compared models have in common the
structural model and the covariance structure for the random effects (see Delattre et al., 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.saemix(..., method = c("is", "lin", "gq"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.saemix_+3A_...">...</code></td>
<td>
<p>Two or more objects returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="compare.saemix_+3A_method">method</code></td>
<td>
<p>The method used for computing the likelihood : &quot;is&quot; (Importance Sampling),
&quot;lin&quot; (Linearisation) or &quot;gq&quot; (Gaussian quadrature). The default is to use importance sampling &quot;is&quot;.
If the requested likelihood is not available in all model objects, the method stops with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the comparison between two or more models will only be valid if they are
fitted to the same dataset.
</p>


<h3>Value</h3>

<p>A matrix of information criteria is returned, with at least two columns containing respectively
AIC and BIC values for each of the compared models. When the models have in common the structural model
and the covariance structure for the random effects, the matrix includes an additional column with BIC.cov
values that are more appropriate when the comparison only concerns the covariates.
</p>


<h3>Author(s)</h3>

<p>Maud Delattre
</p>


<h3>References</h3>

<p>M Delattre, M Lavielle, MA Poursat (2014) A note on BIC in mixed effects models.
Electronic Journal of Statistics 8(1) p. 456-475
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

# Definition of models to be compared
model1cpt&lt;-function(psi,id,xidep) {
   dose&lt;-xidep[,1]
   tim&lt;-xidep[,2]
   ka&lt;-psi[id,1]
   V&lt;-psi[id,2]
   CL&lt;-psi[id,3]
   k&lt;-CL/V
   ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
   return(ypred)
}
# Model with one covariate
saemix.model1&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-compartment model, clearance dependent on weight",
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),
  transform.par=c(1,1,1),covariate.model=matrix(c(0,0,1,0,0,0),ncol=3,byrow=TRUE))
# Model with two covariates
saemix.model2&lt;-saemixModel(model=model1cpt,modeltype="structural",
   description="One-compartment model, clearance dependent on weight, volume dependent on sex",
   psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),
   transform.par=c(1,1,1),covariate.model=matrix(c(0,0,1,0,1,0),ncol=3,byrow=TRUE))
# Model with three covariates
saemix.model3&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-cpt model, clearance, absorption dependent on weight, volume dependent on sex",
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))),
  transform.par=c(1,1,1),covariate.model=matrix(c(1,0,1,0,1,0),ncol=3,byrow=TRUE))


# Running the main algorithm to estimate the population parameters
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)
saemix.fit1&lt;-saemix(saemix.model1,saemix.data,saemix.options)
saemix.fit2&lt;-saemix(saemix.model2,saemix.data,saemix.options)
saemix.fit3&lt;-saemix(saemix.model3,saemix.data,saemix.options)

compare.saemix(saemix.fit1, saemix.fit2, saemix.fit3)
compare.saemix(saemix.fit1, saemix.fit2, saemix.fit3, method = "lin")

# We need to explicitly run Gaussian Quadrature if we want to use it in
# the comparisons
saemix.fit1 &lt;- llgq.saemix(saemix.fit1)
saemix.fit2 &lt;- llgq.saemix(saemix.fit2)
saemix.fit3 &lt;- llgq.saemix(saemix.fit3)
compare.saemix(saemix.fit1, saemix.fit2, saemix.fit3, method = "gq")


</code></pre>

<hr>
<h2 id='conddist.saemix'>Estimate conditional mean and variance of individual parameters using the
MCMC algorithm</h2><span id='topic+conddist.saemix'></span>

<h3>Description</h3>

<p>When the parameters of the model have been estimated, we can estimate the
individual parameters (psi_i).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conddist.saemix(saemixObject, nsamp = 1, max.iter = NULL, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conddist.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="conddist.saemix_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of samples to be drawn in the conditional distribution
for each subject. Defaults to 1</p>
</td></tr>
<tr><td><code id="conddist.saemix_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations for the computation of the
conditional estimates. Defaults to twice the total number of iterations
(see above)</p>
</td></tr>
<tr><td><code id="conddist.saemix_+3A_plot">plot</code></td>
<td>
<p>a boolean indicating whether to display convergence plots (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="conddist.saemix_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plots. Plots will appear if
the argument plot is set to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let hattheta be the estimated value of theta computed with the SAEM
algorithm and let p(phi_i |y_i; hattheta) be the conditional distribution of
phi_i for 1&lt;=i&lt;=N . We use the MCMC procedure used in the SAEM algorithm to
estimate these conditional distributions. We empirically estimate the
conditional mean E(phi_i |y_i; hattheta) and the conditional standard
deviation sd(phi_i |y_i; hattheta).
</p>
<p>See PDF documentation for details of the computation. Briefly, the MCMC
algorithm is used to obtain samples from the individual conditional
distributions of the parameters. The algorithm is initialised for each
subject to the conditional estimate of the individual parameters obtained at
the end of the SAEMIX fit. A convergence criterion is used to ensure
convergence of the mean and variance of the conditional distributions. When
nsamp&gt;1, several chains of the MCMC algorithm are run in parallel to obtain
samples from the conditional distributions, and the convergence criterion
must be achieved for all chains. When nsamp&gt;1, the estimate of the
conditional mean is obtained by averaging over the different samples, and the
samples from the conditional distribution are output as an array of dimension
N x nb of parameters x nsamp in arrays phi.samp for the sampled phi_i and psi.samp
for the corresponding psi_i. The variance of the conditional phi_i for each
sample is given in a corresponding array phi.samp.var (the variance of the
conditional psi_i is not given but may be computed via the delta-method or by
transforming the confidence interval for phi_i).
</p>
<p>The shrinkage for any given parameter for the conditional estimate is
obtained as
</p>
<p>Sh=1-var(eta_i)/omega(eta)
</p>
<p>where var(eta_i) is the empirical variance of the estimates of the
individual random effects, and omega(eta) is the estimated variance.
</p>
<p>When the plot argument is set to TRUE, convergence graphs are produced
They can be used assess whether the mean of the individual estimates (on the scale of the parameters)
and the mean of the SD of the random effects have stabilised over the ipar.lmcmc (defaults to 50) iterations.
The evolution of these variables for each parameter is shown as a continuous line
while the shaded area represents the acceptable variation.
</p>
<p>The function adds or modifies the following elements in the results:
</p>

<dl>
<dt>cond.mean.phi</dt><dd><p>Conditional mean of the individual
distribution of the parameters (obtained as the mean of the samples)</p>
</dd>
<dt>cond.var.phi</dt><dd><p>Conditional variance of the individual distribution of
the parameters (obtained as the mean of the estimated variance of the samples)</p>
</dd>
<dt>cond.shrinkage</dt><dd><p>Estimate of the shrinkage for the conditional estimates</p>
</dd>
<dt>cond.mean.eta</dt><dd><p>Conditional mean of the individual distribution of the
parameters (obtained as the mean of the samples)</p>
</dd>
<dt>phi.samp</dt><dd><p>An array with 3 dimensions, giving nsamp samples
from the conditional distributions of the individual parameters</p>
</dd>
<dt>phi.samp.var</dt><dd><p>The estimated individual variances for the sampled
parameters phi.samp</p>
</dd>
</dl>

<p>A warning is output if the maximum number of iterations is reached
without convergence (the maximum number of iterations is the sum of the elements in
saemix.options$nbiter.saemix).
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>,
<code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemixControl">saemixControl</a></code>,<code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Not run (strict time constraints for CRAN)
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,dimnames=list(NULL, 
  c("ka","V","CL"))),transform.par=c(1,1,1), 
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE), 
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE), error.model="constant")

saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
saemix.fit&lt;-conddist.saemix(saemix.fit,nsamp=3, plot=TRUE)

# First sample from the conditional distribution 
# (a N (nb of subject) by nb.etas (nb of parameters) matrix)
print(head(saemix.fit["results"]["phi.samp"][,,1]))

# Second sample
print(head(saemix.fit["results"]["phi.samp"][,,2]))


</code></pre>

<hr>
<h2 id='cow.saemix'>Evolution of the weight of 560 cows, in SAEM format</h2><span id='topic+cow.saemix'></span>

<h3>Description</h3>

<p>The <code>cow.saemix</code> data contains records of the weight of 560 cows on 9 or 10 occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cow.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>cow</dt><dd><p>the unique identifier for each cow </p>
</dd>
<dt>time</dt><dd><p>time (days)</p>
</dd>
<dt>weight</dt><dd><p>a numeric vector giving the weight of the cow (kg)</p>
</dd>
<dt>birthyear</dt><dd><p>year of birth (between 1988 and 1998)</p>
</dd>
<dt>twin</dt><dd><p>existence of a twin (no=1, yes=2)</p>
</dd>
<dt>birthrank</dt><dd><p>the rank of birth (beetween 3 and 7)</p>
</dd>
</dl>



<h3>Details</h3>

<p>An exponential model was assumed to describe the weight gain with time:
y_ij = A_i (1- B_i exp( - K_i t_ij)) +epsilon_ij
</p>


<h3>References</h3>

<p>JC Pinheiro, DM Bates (2000) <em>Mixed-effects Models in S and S-PLUS</em>, Springer, New York (Appendix A.19)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cow.saemix)
saemix.data&lt;-saemixData(name.data=cow.saemix,header=TRUE,name.group=c("cow"), 
      name.predictors=c("time"),name.response=c("weight"), 
      name.covariates=c("birthyear","twin","birthrank"), 
      units=list(x="days",y="kg",covariates=c("yr","-","-")))

growthcow&lt;-function(psi,id,xidep) {
  x&lt;-xidep[,1]
  a&lt;-psi[id,1]
  b&lt;-psi[id,2]
  k&lt;-psi[id,3]
  f&lt;-a*(1-b*exp(-k*x))
  return(f)
}
saemix.model&lt;-saemixModel(model=growthcow,
      description="Exponential growth model", 
      psi0=matrix(c(700,0.9,0.02,0,0,0),ncol=3,byrow=TRUE, 
        dimnames=list(NULL,c("A","B","k"))),transform.par=c(1,1,1),fixed.estim=c(1,1,1), 
      covariate.model=matrix(c(0,0,0),ncol=3,byrow=TRUE), 
      covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE), 
      omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithms=c(1,1,1),nb.chains=1,nbiter.saemix=c(200,100), 
             seed=4526,save=FALSE,save.graphs=FALSE,displayProgress=FALSE)

# Plotting the data
plot(saemix.data,xlab="Time (day)",ylab="Weight of the cow (kg)")

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)


</code></pre>

<hr>
<h2 id='createSaemixObject'>Create saemix objects with only data filled in</h2><span id='topic+createSaemixObject'></span><span id='topic+createSaemixObject.empty'></span><span id='topic+createSaemixObject.initial'></span>

<h3>Description</h3>

<p>Create saemix objects either with empty results or with parameters set by the user.
This is an internal function used as a preliminary step to obtain predictions for new data
and is not intended to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSaemixObject.empty(model, data, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSaemixObject_+3A_model">model</code></td>
<td>
<p>an saemixModel object</p>
</td></tr>
<tr><td><code id="createSaemixObject_+3A_data">data</code></td>
<td>
<p>an saemixData object</p>
</td></tr>
<tr><td><code id="createSaemixObject_+3A_control">control</code></td>
<td>
<p>a list of options (if empty, will be set to the default values by <code>saemixControl</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>with createSaemixObject.empty, the data component is set to the data object, the model component is set to the model object, and the result component is empty
</p>
<p>with createSaemixObject.initial, the data and model are set as with createSaemixObject.empty,
but the population parameter estimates are used to initialise the result component
as in the initialisation step of the algorithm (initialiseMainAlgo)
</p>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+SaemixObject-class">SaemixObject</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='dataGen.case'>Bootstrap datasets</h2><span id='topic+dataGen.case'></span><span id='topic+dataGen.NP'></span><span id='topic+dataGen.Par'></span><span id='topic+sampDist.Par'></span><span id='topic+sampDist.NP'></span><span id='topic+sampDist.NPcond'></span>

<h3>Description</h3>

<p>These functions create bootstrapped datasets using the bootstrap methods described in <code><a href="#topic+saemix.bootstrap">saemix.bootstrap</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataGen.case(saemixObject)

dataGen.NP(saemixObject, nsamp = 0, eta.sampc = NULL, conditional = FALSE)

dataGen.Par(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataGen.case_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="dataGen.case_+3A_nsamp">nsamp</code></td>
<td>
<p>number of samples from the conditional distribution (for method=&quot;conditional&quot;)</p>
</td></tr>
<tr><td><code id="dataGen.case_+3A_eta.sampc">eta.sampc</code></td>
<td>
<p>if available, samples from the conditional distribution (otherwise, they are obtained within the function)</p>
</td></tr>
<tr><td><code id="dataGen.case_+3A_conditional">conditional</code></td>
<td>
<p>if TRUE, sample from the conditional distribution, if FALSE, sample within the
empirical Bayes estimates (EBE) as in the traditional non-parametric residual bootstrap</p>
</td></tr>
</table>

<hr>
<h2 id='default.saemix.plots'>Wrapper functions to produce certain sets of default plots</h2><span id='topic+default.saemix.plots'></span><span id='topic+basic.gof'></span><span id='topic+advanced.gof'></span><span id='topic+covariate.fits'></span><span id='topic+individual.fits'></span>

<h3>Description</h3>

<p>These functions produce default sets of plots, corresponding to diagnostic
or individual fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.saemix.plots(saemixObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.saemix.plots_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="default.saemix.plots_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrapper functions designed to produce default sets of
plots to help the user assess their model fits.
</p>


<h3>Value</h3>

<p>Depending on the type argument, the following plots are produced:
</p>

<ul>
<li><p> default.saemix.plots by default, the following plots are
produced: a plot of the data, convergence plots, plot of the likelihood by
importance sampling (if computed), plots of observations versus predictions,
scatterplots and distribution of residuals, boxplot of the random effects,
correlations between random effects, distribution of the parameters, VPC
</p>
</li>
<li><p> basic.gof basic goodness-of-fit plots: convergence plots, plot of
the likelihood by importance sampling (if computed), plots of observations
versus predictions
</p>
</li>
<li><p> advanced.gof advanced goodness-of-fit plots:
scatterplots and distribution of residuals, VPC,...
</p>
</li>
<li><p> covariate.fits
plots of all estimated parameters versus all covariates in the dataset
</p>
</li>
<li><p> individual.fits plots of individual predictions (line) overlayed on
individual observations (dots) for all subjects in the dataset
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemix">saemix</a></code>, <code><a href="#topic+saemix.plot.data">saemix.plot.data</a></code>,
<code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code>, <code><a href="#topic+plot.saemix">plot.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

# Reducing the number of iterations due to time constraints for CRAN
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE,nbiter.saemix=c(100,100))

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

default.saemix.plots(saemix.fit)

# Not run (time constraints for CRAN)
# basic.gof(saemix.fit)

# Not run (time constraints for CRAN)
# advanced.gof(saemix.fit)

individual.fits(saemix.fit)


</code></pre>

<hr>
<h2 id='discreteVPC'>VPC for non Gaussian data models</h2><span id='topic+discreteVPC'></span><span id='topic+discreteVPCcount'></span><span id='topic+discreteVPCcat'></span><span id='topic+discreteVPC.aux'></span>

<h3>Description</h3>

<p>This function provides VPC plots for non Gaussian data models (work in progress)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteVPC(object, outcome = "categorical", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteVPC_+3A_object">object</code></td>
<td>
<p>an saemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function.
The object must include simulated data under the empirical design, using the model and
estimated parameters from a fit, produced via the <code><a href="#topic+simulateDiscreteSaemix">simulateDiscreteSaemix</a></code> function.</p>
</td></tr>
<tr><td><code id="discreteVPC_+3A_outcome">outcome</code></td>
<td>
<p>type of outcome (valid types are &quot;TTE&quot;, &quot;binary&quot;, &quot;categorical&quot;, &quot;count&quot;)</p>
</td></tr>
<tr><td><code id="discreteVPC_+3A_verbose">verbose</code></td>
<td>
<p>whether to print messages (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="discreteVPC_+3A_...">...</code></td>
<td>
<p>additional arguments, used to pass graphical options (to be implemented, currently not available)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a very rough first attempt at automatically creating VPC plots for
models defined through their log-likelihood (categorical, count, or TTE data). It makes use of the
new element simulate.function in the model component of the object
</p>

<ul>
<li><p> for TTE data, a KM-VPC plot will be produced
</p>
</li>
<li><p> for count, categorical and binary data, a plot showing the proportion of each score/category across time will be shown
along with the corresponding prediction intervals from the model
These plots can be stratified over a covariate in the data set (currently only categorical covariates)
by passing an argument which.cov='name' to the call
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>References</h3>

<p>Brendel, K, Comets, E, Laffont, C, Laveille, C, Mentre, F.
Metrics for external model evaluation with an application to the population
pharmacokinetics of gliclazide, Pharmaceutical Research 23 (2006),
2036-2049.
</p>
<p>Holford, N. The Visual Predictive Check: superiority to standard diagnostic
(Rorschach) plots (Abstract 738), in: 14th Meeting of the Population
Approach Group in Europe, Pamplona, Spain, 2005.
</p>
<p>Ron Keizer, tutorials on VPC TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>, <code><a href="#topic+simulateDiscreteSaemix">simulateDiscreteSaemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.saemix)

saemix.data&lt;-saemixData(name.data=lung.saemix,header=TRUE,name.group=c("id"),
name.predictors=c("time","status","cens"),name.response=c("status"),
name.covariates=c("age", "sex", "ph.ecog", "ph.karno", "pat.karno", "wt.loss","meal.cal"),
units=list(x="days",y="",covariates=c("yr","","-","%","%","cal","pounds")))

weibulltte.model&lt;-function(psi,id,xidep) {
  T&lt;-xidep[,1]
  y&lt;-xidep[,2] # events (1=event, 0=no event)
  cens&lt;-which(xidep[,3]==1) # censoring times (subject specific)
  init &lt;- which(T==0)
  lambda &lt;- psi[id,1] # Parameters of the Weibull model
  beta &lt;- psi[id,2]
  Nj &lt;- length(T)
  ind &lt;- setdiff(1:Nj, append(init,cens)) # indices of events
  hazard &lt;- (beta/lambda)*(T/lambda)^(beta-1) # H'
  H &lt;- (T/lambda)^beta # H
  logpdf &lt;- rep(0,Nj) # ln(l(T=0))=0
  logpdf[cens] &lt;- -H[cens] + H[cens-1] # ln(l(T=censoring time))
  logpdf[ind] &lt;- -H[ind] + H[ind-1] + log(hazard[ind]) # ln(l(T=event time))
  return(logpdf)
}

simulateWeibullTTE &lt;- function(psi,id,xidep) {
  T&lt;-xidep[,1]
  y&lt;-xidep[,2] # events (1=event, 0=no event)
  cens&lt;-which(xidep[,3]==1) # censoring times (subject specific)
  init &lt;- which(T==0)
  lambda &lt;- psi[,1] # Parameters of the Weibull model
  beta &lt;- psi[,2]
  tevent&lt;-T
  Vj&lt;-runif(dim(psi)[1])
  tsim&lt;-lambda*(-log(Vj))^(1/beta) # nsuj events
  tevent[T&gt;0]&lt;-tsim
  tevent[tevent[cens]&gt;T[cens]] &lt;- T[tevent[cens]&gt;T[cens]]
  return(tevent)
  }
saemix.model&lt;-saemixModel(model=weibulltte.model,description="time model",modeltype="likelihood",
       simulate.function = simulateWeibullTTE,
                psi0=matrix(c(1,2),ncol=2,byrow=TRUE,dimnames=list(NULL,  c("lambda","beta"))),
                transform.par=c(1,1),covariance.model=matrix(c(1,0,0,0),ncol=2, byrow=TRUE))
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE, displayProgress=FALSE)


tte.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
simtte.fit &lt;- simulateDiscreteSaemix(tte.fit, nsim=100)
gpl &lt;- discreteVPC(simtte.fit, outcome="TTE")
plot(gpl)


</code></pre>

<hr>
<h2 id='discreteVPCTTE'>VPC for time-to-event models</h2><span id='topic+discreteVPCTTE'></span><span id='topic+interpol.locf'></span><span id='topic+interpol.lin'></span>

<h3>Description</h3>

<p>This function provides VPC plots for time-to-event data models (work in progress)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteVPCTTE(
  object,
  ngrid = 200,
  interpolation.method = "step",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteVPCTTE_+3A_object">object</code></td>
<td>
<p>an saemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function.
The object must include simulated data under the empirical design,
using the model and estimated parameters from a fit, produced via the
<code><a href="#topic+simulateDiscreteSaemix">simulateDiscreteSaemix</a></code> function</p>
</td></tr>
<tr><td><code id="discreteVPCTTE_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid points on the X-axis to extrapolate the KM-VPC</p>
</td></tr>
<tr><td><code id="discreteVPCTTE_+3A_interpolation.method">interpolation.method</code></td>
<td>
<p>method to use for the interpolation of the KM for the simulated datasets. Available methods are
&quot;step&quot;: the value of the survival function for a given grid point is set to the value of the last time
&quot;lin&quot;: a linear approximation is used between two consecutive times (defaults to &quot;step&quot;)</p>
</td></tr>
<tr><td><code id="discreteVPCTTE_+3A_verbose">verbose</code></td>
<td>
<p>whether to print messages (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="discreteVPCTTE_+3A_...">...</code></td>
<td>
<p>additional arguments, used to pass graphical options (to be implemented, currently not available)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>add details on TTE VPC, RTTE VPC, etc...
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>, <code><a href="#topic+simulateDiscreteSaemix">simulateDiscreteSaemix</a></code>
</p>
<p>Tutorials on TTE-VPC TODO
</p>

<hr>
<h2 id='epilepsy.saemix'>Epilepsy count data</h2><span id='topic+epilepsy.saemix'></span>

<h3>Description</h3>

<p>The epilepsy data from Thall and Vail (1990), available from the MASS package, records two-week seizure counts for 59 epileptics.
The number of seizures was recorded for a baseline period of 8 weeks, and then patients were randomly assigned to a treatment group
or a control group. Counts were then recorded for four successive two-week periods. The subject's age is the only covariate. See the
documentation for epil in the MASS package for details on the dataset.
</p>


<h3>Source</h3>

<p>MASS package in R
</p>


<h3>References</h3>

<p>P Thall, S Vail (1990). Some covariance models for longitudinal count data with overdispersion. Biometrics 46(3):657-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># You need to have MASS installed to successfully run this example
if (requireNamespace("MASS")) {
  
  epilepsy&lt;-MASS::epil
  saemix.data&lt;-saemixData(name.data=epilepsy, name.group=c("subject"),
     name.predictors=c("period","y"),name.response=c("y"),
     name.covariates=c("trt","base", "age"), units=list(x="2-week",y="",covariates=c("","","yr")))
  ## Poisson model with one parameter
  countPoi&lt;-function(psi,id,xidep) { 
    y&lt;-xidep[,2]
    lambda&lt;-psi[id,1]
    logp &lt;- -lambda + y*log(lambda) - log(factorial(y))
    return(logp)
    }
 saemix.model&lt;-saemixModel(model=countPoi,description="Count model Poisson",modeltype="likelihood", 
   psi0=matrix(c(0.5),ncol=1,byrow=TRUE,dimnames=list(NULL, c("lambda"))), transform.par=c(1))
 
  saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE, displayProgress=FALSE)
  poisson.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
  
}
  
</code></pre>

<hr>
<h2 id='fim.saemix'>Computes the Fisher Information Matrix by linearisation</h2><span id='topic+fim.saemix'></span>

<h3>Description</h3>

<p>Estimate by linearisation the Fisher Information Matrix and the standard
error of the estimated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fim.saemix(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fim.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse of the Fisher Information Matrix provides an estimate of the
variance of the estimated parameters theta. This matrix cannot be computed
in closed-form for nonlinear mixed-effect models; instead, an approximation
is obtained as the Fisher Information Matrix of the Gaussian model deduced
from the nonlinear mixed effects model after linearisation of the function f
around the conditional expectation of the individual Gaussian parameters.
This matrix is a block matrix (no correlations between the estimated fixed
effects and the estimated variances).
</p>


<h3>Value</h3>

<p>The function returns an updated version of the object saemix.fit in
which the following elements have been added: </p>

<dl>
<dt>se.fixed:</dt><dd><p>standard error of fixed effects, obtained as part of the
diagonal of the inverse of the Fisher Information Matrix (only when
fim.saemix has been run, or when saemix.options$algorithms[2] is 1)</p>
</dd>
<dt>se.omega:</dt><dd><p>standard error of the variance of random effects, obtained
as part of the diagonal of the inverse of the Fisher Information Matrix
(only when fim.saemix has been run, or when the saemix.options$algorithms[2]
is 1)</p>
</dd>
<dt>se.res:</dt><dd><p>standard error of the parameters of the residual error
model, obtained as part of the diagonal of the inverse of the Fisher
Information Matrix (only when fim.saemix has been run, or when the
saemix.options$algorithms[2] is 1)</p>
</dd>
<dt>fim:</dt><dd><p>Fisher Information Matrix</p>
</dd>
<dt>ll.lin:</dt><dd><p> likelihood calculated by linearisation</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Running the main algorithm to estimate the population parameters
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1), 
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE), error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Estimating the Fisher Information Matrix using the result of saemix 
# &amp; returning the result in the same object
# fim.saemix(saemix.fit)


</code></pre>

<hr>
<h2 id='fitted.saemix'>Extract Model Predictions</h2><span id='topic+fitted.saemix'></span><span id='topic+fitted.SaemixRes'></span><span id='topic+fitted'></span><span id='topic+fitted.SaemixObject'></span>

<h3>Description</h3>

<p>fitted is a generic function which extracts model predictions from objects returned by modelling functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixRes'
fitted(object, type = c("ipred", "ypred", "ppred", "icpred"), ...)

## S3 method for class 'SaemixObject'
fitted(object, type = c("ipred", "ypred", "ppred", "icpred"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.saemix_+3A_object">object</code></td>
<td>
<p>an object of type SaemixRes or SaemixObject</p>
</td></tr>
<tr><td><code id="fitted.saemix_+3A_type">type</code></td>
<td>
<p>string determining which predictions are extracted. Possible values are: &quot;ipred&quot; (individual predictions obtained using the mode of the individual distribution for each subject, default), &quot;ppred&quot; (population predictions obtained using the population parameters f(E(theta))), &quot;ypred&quot; (mean of the population predictions (E(f(theta)))) and &quot;icpred&quot; (individual predictions obtained using the conditional mean of the individual distribution). See user guide for details.</p>
</td></tr>
<tr><td><code id="fitted.saemix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model predictions
</p>

<hr>
<h2 id='forward.procedure'>Backward procedure for joint selection of covariates and random effects</h2><span id='topic+forward.procedure'></span>

<h3>Description</h3>

<p>Joint selection of covariates and random effects in a nonlinear mixed effects model by a forward-type
algorithm based on two different versions of BIC for covariate selection and random effects selection
respectively. Selection is made among the covariates as such specified in the SaemixData object.
Only uncorrelated random effects structures are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward.procedure(saemixObject, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward.procedure_+3A_saemixobject">saemixObject</code></td>
<td>
<p>An object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="forward.procedure_+3A_trace">trace</code></td>
<td>
<p>If TRUE, a table summarizing the steps of the algorithm is printed. Default &quot;TRUE&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the SaemixObject class storing the covariate model and the covariance structure of
random effects of the final model.
</p>


<h3>Author(s)</h3>

<p>Maud Delattre
</p>


<h3>References</h3>

<p>M Delattre, M Lavielle, MA Poursat (2014) A note on BIC in mixed effects models.
Electronic Journal of Statistics 8(1) p. 456-475
M Delattre, MA Poursat (2017) BIC strategies for model choice in a population approach.
(arXiv:1612.02405)
</p>

<hr>
<h2 id='initialize-methods'>Methods for Function initialize</h2><span id='topic+initialize-methods'></span><span id='topic+initialize+2CSaemixData-method'></span><span id='topic+initialize+2CSaemixRepData-method'></span><span id='topic+initialize+2CSaemixSimData-method'></span><span id='topic+initialize+2CSaemixModel-method'></span><span id='topic+initialize+2CSaemixRes-method'></span><span id='topic+initialize+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Constructor functions for Classes in the saemix package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
initialize(
  .Object,
  name.data,
  header,
  sep,
  na,
  name.group,
  name.predictors,
  name.response,
  name.covariates,
  name.X,
  units,
  name.mdv,
  name.cens,
  name.occ,
  name.ytype,
  verbose = TRUE,
  automatic = TRUE
)

## S4 method for signature 'SaemixRepData'
initialize(.Object, data = NULL, nb.chains = 1)

## S4 method for signature 'SaemixSimData'
initialize(.Object, data = NULL, datasim = NULL)

## S4 method for signature 'SaemixModel'
initialize(
  .Object,
  model,
  description,
  modeltype,
  psi0,
  name.response,
  name.sigma,
  transform.par,
  fixed.estim,
  error.model,
  covariate.model,
  covariance.model,
  omega.init,
  error.init,
  name.modpar,
  verbose = TRUE
)

## S4 method for signature 'SaemixRes'
initialize(
  .Object,
  status = "empty",
  modeltype,
  name.fixed,
  name.random,
  name.sigma,
  fixed.effects,
  fixed.psi,
  betaC,
  betas,
  omega,
  respar,
  cond.mean.phi,
  cond.var.phi,
  mean.phi,
  phi,
  phi.samp,
  parpop,
  allpar,
  MCOV
)

## S4 method for signature 'SaemixObject'
initialize(.Object, data, model, options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize-methods_+3A_.object">.Object</code></td>
<td>
<p>an SaemixObject, SaemixRes, SaemixData or SaemixModel object to initialise</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.data">name.data</code></td>
<td>
<p>name of the dataset (can be a character string giving the name of a file on disk or of a dataset in the R session, or the name of a dataset</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_header">header</code></td>
<td>
<p>whether the dataset/file contains a header. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Defaults to any number of blank spaces (&quot;&quot;)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_na">na</code></td>
<td>
<p>a character vector of the strings which are to be interpreted as NA values. Defaults to c(NA)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.group">name.group</code></td>
<td>
<p>name (or number) of the column containing the subject id</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.predictors">name.predictors</code></td>
<td>
<p>name (or number) of the column(s) containing the predictors (the algorithm requires at least one predictor x)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.response">name.response</code></td>
<td>
<p>name (or number) of the column containing the response variable y modelled by predictor(s) x</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.covariates">name.covariates</code></td>
<td>
<p>name (or number) of the column(s) containing the covariates, if present (otherwise missing)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.x">name.X</code></td>
<td>
<p>name of the column containing the regression variable to be used on the X axis in the plots (defaults to the first predictor)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_units">units</code></td>
<td>
<p>list with up to three elements, x, y and optionally covariates, containing the units for the X and Y variables respectively, as well as the units for the different covariates (defaults to empty)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.mdv">name.mdv</code></td>
<td>
<p>name of the column containing the indicator for missing variable</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.cens">name.cens</code></td>
<td>
<p>name of the column containing the indicator for censoring</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.occ">name.occ</code></td>
<td>
<p>name of the column containing the occasion</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.ytype">name.ytype</code></td>
<td>
<p>name of the column containing the index of the response</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating whether messages should be printed out during the creation of the object</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_automatic">automatic</code></td>
<td>
<p>a boolean indicating whether to attempt automatic name recognition when some colum names are missing or wrong (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_data">data</code></td>
<td>
<p>an SaemixData object</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_nb.chains">nb.chains</code></td>
<td>
<p>number of chains used in the algorithm</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_datasim">datasim</code></td>
<td>
<p>dataframe containing the simulated data</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_model">model</code></td>
<td>
<p>name of the function used to compute the structural model. The
function should return a vector of predicted values given a matrix of
individual parameters, a vector of indices specifying which records belong
to a given individual, and a matrix of dependent variables (see example
below).</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_description">description</code></td>
<td>
<p>a character string, giving a brief description of the
model or the analysis</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_modeltype">modeltype</code></td>
<td>
<p>a character string  giving the model used for analysis</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_psi0">psi0</code></td>
<td>
<p>a matrix with a number of columns equal to the number of
parameters in the model, and one (when no covariates are available) or two
(when covariates enter the model) giving the initial estimates for the fixed
effects. The column names of the matrix should be the names of the
parameters in the model, and will be used in the plots and the summaries.
When only the estimates of the mean parameters are given, psi0 may be a
named vector.</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.sigma">name.sigma</code></td>
<td>
<p>a vector of character string giving the names of the residual error parameters (defaults to &quot;a&quot; and &quot;b&quot;)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_transform.par">transform.par</code></td>
<td>
<p>the distribution for each parameter (0=normal,
1=log-normal, 2=probit, 3=logit). Defaults to a vector of 1s (all parameters
have a log-normal distribution)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_fixed.estim">fixed.estim</code></td>
<td>
<p>whether parameters should be estimated (1) or fixed to
their initial estimate (0). Defaults to a vector of 1s</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_error.model">error.model</code></td>
<td>
<p>type of residual error model (valid types are constant,
proportional, combined and exponential). Defaults to constant</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_covariate.model">covariate.model</code></td>
<td>
<p>a matrix giving the covariate model. Defaults to no
covariate in the model</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_covariance.model">covariance.model</code></td>
<td>
<p>a square matrix of size equal to the number of parameters in the model,
giving the variance-covariance matrix of the model: 1s correspond to estimated variances (in the diagonal)
or covariances (off-diagonal elements). Defaults to the identity matrix</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_omega.init">omega.init</code></td>
<td>
<p>a square matrix of size equal to the number of parameters
in the model, giving the initial estimate for the variance-covariance matrix
of the model. The current default is a diagonal matrix with ones for all
transformed parameters as well as for all untransformed parameters with an
absolute value smaller than one.  For untransformed parameters greater or
equal to one, their squared value is used as the corresponding diagonal
element.</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_error.init">error.init</code></td>
<td>
<p>a vector of size 2 giving the initial value of a and b in
the error model. Defaults to 1 for each estimated parameter in the error model</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.modpar">name.modpar</code></td>
<td>
<p>names of the model parameters, if they are not given as
the column names (or names) of psi0</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_status">status</code></td>
<td>
<p>string indicating whether a model has been run successfully; set to &quot;empty&quot; at initialisation, used to pass on error messages or fit status</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.fixed">name.fixed</code></td>
<td>
<p>a character string  giving the name of the fixed parameters</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_name.random">name.random</code></td>
<td>
<p>a character string  giving the name of the random parameters</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_fixed.effects">fixed.effects</code></td>
<td>
<p>vector with the estimates of h(mu) and betas in estimation order</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_fixed.psi">fixed.psi</code></td>
<td>
<p>vector with the estimates of h(mu)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_betac">betaC</code></td>
<td>
<p>vector with the estimates of betas (estimated fixed effects for covariates)</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_betas">betas</code></td>
<td>
<p>vector with the estimates of mu</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_omega">omega</code></td>
<td>
<p>estimated variance-covariance matrix</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_respar">respar</code></td>
<td>
<p>vector with the estimates of the parameters of the residual error</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_cond.mean.phi">cond.mean.phi</code></td>
<td>
<p>matrix of size (number of subjects) x (nb of parameters) containing the conditional mean estimates of the, defined as the mean of the conditional distribution</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_cond.var.phi">cond.var.phi</code></td>
<td>
<p>matrix of the variances on cond.mean.phi, defined as the variance of the conditional distribution</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_mean.phi">mean.phi</code></td>
<td>
<p>matrix of size (number of subjects) x (nb of parameters) giving for each subject the estimates of the population parameters including covariate effects</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_phi">phi</code></td>
<td>
<p>matrix of size (number of subjects) x (nb of parameters) giving for each subject</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_phi.samp">phi.samp</code></td>
<td>
<p>samples from the individual conditional distributions of the phi</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_parpop">parpop</code></td>
<td>
<p>population parameters at each iteration</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_allpar">allpar</code></td>
<td>
<p>all parameters (including covariate effects) at each iteration</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_mcov">MCOV</code></td>
<td>
<p>design matrix C</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_options">options</code></td>
<td>
<p>a list of options passed to the algorithm</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(.Object = \&quot;SaemixData\&quot;)&quot;)</dt><dd><p> create a SaemixData
object. Please use the <code><a href="#topic+saemixData">saemixData</a></code> function.</p>
</dd>
<dt>list(&quot;signature(.Object = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> create a SaemixModel
object Please use the <code><a href="#topic+saemixModel">saemixModel</a></code> function.</p>
</dd>
<dt>list(&quot;signature(.Object = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> create a SaemixObject
object. This object is obtained after a successful call to
<code><a href="#topic+saemix">saemix</a></code></p>
</dd>
<dt>list(&quot;signature(.Object = \&quot;SaemixRepData\&quot;)&quot;)</dt><dd><p> create a
SaemixRepData object</p>
</dd>
<dt>list(&quot;signature(.Object = \&quot;SaemixRes\&quot;)&quot;)</dt><dd><p> create a SaemixRes
object</p>
</dd>
<dt>list(&quot;signature(.Object = \&quot;SaemixSimData\&quot;)&quot;)</dt><dd><p> create a
SaemixSimData object</p>
</dd> </dl>


<hr>
<h2 id='knee.saemix'>Knee pain data</h2><span id='topic+knee.saemix'></span>

<h3>Description</h3>

<p>The <code>knee.saemix</code> data represents pain scores recorded in a clinical study
in 127 patients with sport related injuries treated with two different therapies.
After 3,7 and 10 days of treatment the pain occuring during knee movement was observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knee.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>subject index in file</p>
</dd>
<dt>time</dt><dd><p>time of measurement (in days)</p>
</dd>
<dt>y</dt><dd><p>knee pain (0=none to 4=severe)</p>
</dd>
<dt>Age</dt><dd><p>patient age (scaled and centered)</p>
</dd>
<dt>Sex</dt><dd><p>patient gender (0=male, 1=female)</p>
</dd>
<dt>RD</dt><dd><p>moderate knee pain (defined as pain score 2 or more)</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator (0=placebo, 1=treatment)</p>
</dd>
<dt>Age2</dt><dd><p>patient age, squared (Age^2)</p>
</dd>
</dl>

<p>#'
</p>


<h3>Details</h3>

<p>The data in the <code>knee.saemix</code> was reformatted from the knee dataset provided by the
catdata package (see data(knee, package=&quot;catdata&quot;)). A time column was added representing the day
of the measurement (with 0 being the baseline value) and each observation corresponds to a different
line in the dataset. Treatment was recoded as 0/1 (placebo/treatment), gender as 0/1 (male/female)
and Age2 represents the squared of centered Age.
</p>
<p>Please refer to the PDF documentation (chapter 4, section 4.6) for more details on the analysis,
including examples of diagnostic plots.
</p>


<h3>Source</h3>

<p>catdata package in R
</p>


<h3>References</h3>

<p>G Tutz (2012), Regression for Categorical Data, Cambridge University Press.
</p>
<p>#' @examples
data(knee.saemix)
</p>
<p>#' @keywords datasets
</p>

<hr>
<h2 id='llgq.saemix'>Log-likelihood using Gaussian Quadrature</h2><span id='topic+llgq.saemix'></span><span id='topic+llqg.saemix'></span><span id='topic+gqg.mlx'></span>

<h3>Description</h3>

<p>Estimate the log-likelihood using Gaussian Quadrature (multidimensional
grid)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llgq.saemix(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llgq.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood of the observations is estimated using Gaussian Quadrature
(see documentation).
</p>


<h3>Value</h3>

<p>the log-likelihood estimated by Gaussian Quadrature
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,<code><a href="#topic+llis.saemix">llis.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Running the main algorithm to estimate the population parameters
data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}
saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1), 
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE), error.model="constant")

saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Estimating the likelihood by Gaussian Quadrature using the result of saemix 
# &amp; returning the result in the same object
# saemix.fit&lt;-llgq.saemix(saemix.fit)


</code></pre>

<hr>
<h2 id='llis.saemix'>Log-likelihood using Importance Sampling</h2><span id='topic+llis.saemix'></span>

<h3>Description</h3>

<p>Estimate the log-likelihood using Importance Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llis.saemix(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llis.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood of the observations is estimated without any approximation
using a Monte-Carlo approach (see documentation).
</p>


<h3>Value</h3>

<p>the log-likelihood estimated by Importance Sampling
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,<code><a href="#topic+llgq.saemix">llgq.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Running the main algorithm to estimate the population parameters
data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}
saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", modeltype="structural",
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Estimating the likelihood by importance sampling using the result of saemix 
# &amp; returning the result in the same object
# saemix.fit&lt;-llis.saemix(saemix.fit)

</code></pre>

<hr>
<h2 id='logLik'>Extract likelihood from an SaemixObject resulting from a call to saemix</h2><span id='topic+logLik'></span><span id='topic+logLik.SaemixObject'></span><span id='topic+AIC.SaemixObject'></span><span id='topic+BIC.SaemixObject'></span><span id='topic+BIC.covariate'></span>

<h3>Description</h3>

<p>The likelihood in saemix can be computed by one of three methods: linearisation (linearisation of the model), importance sampling (stochastic integration) and gaussian quadrature (numerical integration). The linearised likelihood is obtained as a byproduct of the computation of the Fisher Information Matrix (argument FIM=TRUE in the options given to the saemix function).
If no method argument is given, this function will attempt to extract the likelihood computed by importance sampling (method=&quot;is&quot;), unless the object contains the likelihood computed by linearisation, in which case the function will extract this component instead.
If the requested likelihood is not present in the object, it will be computed and aded to the object before returning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixObject'
logLik(object, method = c("is", "lin", "gq"), ...)

## S3 method for class 'SaemixObject'
AIC(object, method = c("is", "lin", "gq"), ..., k = 2)

## S3 method for class 'SaemixObject'
BIC(object, method = c("is", "lin", "gq"), ...)

## S3 method for class 'covariate'
BIC(object, method = c("is", "lin", "gq"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>name of an SaemixObject object</p>
</td></tr>
<tr><td><code id="logLik_+3A_method">method</code></td>
<td>
<p>character string, one of c(&quot;is&quot;,&quot;lin&quot;,&quot;gq&quot;), to select one of the available approximations to the log-likelihood (is: Importance Sampling; lin: linearisation and gq: Gaussian Quadrature). See documentation for details</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="logLik_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default k = 2 is the classical AIC</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC.covariate implements the computation of the BIC from Delattre et al. 2014.
</p>


<h3>Value</h3>

<p>Returns the selected statistical criterion (log-likelihood, AIC, BIC) extracted from the SaemixObject, computed with the 'method' argument if given (defaults to IS).
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle
</p>
<p>Maud Delattre
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>,<code><a href="stats.html#topic+BIC">BIC</a></code>, <code><a href="#topic+saemixControl">saemixControl</a></code>, <code><a href="#topic+saemix">saemix</a></code>
</p>

<hr>
<h2 id='lung.saemix'>NCCTG Lung Cancer Data, in SAEM format</h2><span id='topic+lung.saemix'></span>

<h3>Description</h3>

<p>The <code>lung.saemix</code> contains survival data in patients with advanced lung cancer from the North Central Cancer Treatment Group.
Performance scores rate how well the patient can perform usual daily activities. This data is available in the survival library for R
and has been reformatted here for use in saemix (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lung.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>subject index in file</p>
</dd>
<dt>inst</dt><dd><p>institution code</p>
</dd>
<dt>time</dt><dd><p>observation time since the beginning of follow-up</p>
</dd>
<dt>status</dt><dd><p>0=alive, 1=dead</p>
</dd>
<dt>cens</dt><dd><p>0=observed, 1=censored</p>
</dd>
<dt>sex</dt><dd><p>patient gender (0=male, 1=female)</p>
</dd>
<dt>age</dt><dd><p>age in years</p>
</dd>
<dt>ph.ecog</dt><dd><p>ECOG performance score as rated by the physician. 0=asymptomatic,
1= symptomatic but completely ambulatory, 2= in bed &lt;50% of the day, 3= in bed &gt; 50% of the day but not bedbound,
4 = bedbound</p>
</dd>
<dt>ph.karno</dt><dd><p>Karnofsky performance score (bad=0-good=100) rated by physician (%)</p>
</dd>
<dt>pat.karno</dt><dd><p>Karnofsky performance score (bad=0-good=100) rated by patient (%)</p>
</dd>
<dt>meal.cal</dt><dd><p>calories consumed at meals (cal)</p>
</dd>
<dt>wt.loss</dt><dd><p>weight loss in last six months (pounds)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data in the <code>lung.saemix</code> was reformatted from the lung cancer dataset (see data(cancer, package=&quot;survival&quot;)).
Patients with missing age, sex, institution or physician assessments were removed from the dataset. Status was recoded as 1 for death
and 0 for a censored event, and a censoring column was added to denote whether the patient was dead or alive at the time of
the last observation. For saemix, a line at time=0 was added for all subjects. Finally, subjects were numbered consecutively from 0 to 1.
</p>


<h3>Source</h3>

<p>Terry Therneau from the survival package in R
</p>


<h3>References</h3>

<p>CL Loprinzi, JA Laurie, HS Wieand, JE Krook, PJ Novotny, JW Kugler, et al. (1994).
Prospective evaluation of prognostic variables from patient-completed questionnaires.
North Central Cancer Treatment Group. Journal of Clinical Oncology. 12(3):601-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.saemix)

saemix.data&lt;-saemixData(name.data=lung.saemix,header=TRUE,name.group=c("id"),
name.predictors=c("time","status","cens"),name.response=c("status"),
name.covariates=c("age", "sex", "ph.ecog", "ph.karno", "pat.karno", "wt.loss","meal.cal"),
units=list(x="days",y="",covariates=c("yr","","-","%","%","cal","pounds")))
weibulltte.model&lt;-function(psi,id,xidep) {
  T&lt;-xidep[,1]
  y&lt;-xidep[,2] # events (1=event, 0=no event)
  cens&lt;-which(xidep[,3]==1) # censoring times (subject specific)
  init &lt;- which(T==0)
  lambda &lt;- psi[id,1] # Parameters of the Weibull model
  beta &lt;- psi[id,2]
  Nj &lt;- length(T)
  ind &lt;- setdiff(1:Nj, append(init,cens)) # indices of events
  hazard &lt;- (beta/lambda)*(T/lambda)^(beta-1) # H'
  H &lt;- (T/lambda)^beta # H
  logpdf &lt;- rep(0,Nj) # ln(l(T=0))=0
  logpdf[cens] &lt;- -H[cens] + H[cens-1] # ln(l(T=censoring time))
  logpdf[ind] &lt;- -H[ind] + H[ind-1] + log(hazard[ind]) # ln(l(T=event time))
  return(logpdf)
}
saemix.model&lt;-saemixModel(model=weibulltte.model,description="time model",modeltype="likelihood",
                psi0=matrix(c(1,2),ncol=2,byrow=TRUE,dimnames=list(NULL,  c("lambda","beta"))),
                transform.par=c(1,1),covariance.model=matrix(c(1,0,0,0),ncol=2, byrow=TRUE))
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE, displayProgress=FALSE)

tte.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# The fit from saemix using the above Weibull model may be compared 
# to the non-parametric KM estimate
## Not run: 
library(survival)
  lung.surv&lt;-lung.saemix[lung.saemix$time&gt;0,]
  lung.surv$status&lt;-lung.surv$status+1
  Surv(lung.surv$time, lung.surv$status) # 1=censored, 2=dead
  f1 &lt;- survfit(Surv(time, status) ~ 1, data = lung.surv)
  xtim&lt;-seq(0,max(lung.saemix$time), length.out=200)
  estpar&lt;-tte.fit@results@fixed.effects
  ypred&lt;-exp(-(xtim/estpar[1])^(estpar[2]))
  plot(f1, xlab = "Days", ylab = "Overall survival probability")
  lines(xtim,ypred, col="red",lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='map.saemix'>Estimates of the individual parameters (conditional mode)</h2><span id='topic+map.saemix'></span>

<h3>Description</h3>

<p>Compute the estimates of the individual parameters PSI_i (conditional mode -
Maximum A Posteriori)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.saemix(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MCMC procedure is used to estimate the conditional mode (or Maximum A
Posteriori) m(phi_i |yi ; hattheta) = Argmax_phi_i p(phi_i |yi ; hattheta)
</p>


<h3>Value</h3>

<table>
<tr><td><code>saemixObject:</code></td>
<td>
<p>returns the object with the estimates of the
MAP parameters (see example for usage)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,
  save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Estimating the individual parameters using the result of saemix 
# &amp; returning the result in the same object
# saemix.fit&lt;-map.saemix(saemix.fit)


</code></pre>

<hr>
<h2 id='mydiag'>Matrix diagonal</h2><span id='topic+mydiag'></span>

<h3>Description</h3>

<p>Extract or replace the diagonal of a matrix, or construct a diagonal matrix (replace diag function from R-base)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mydiag(x = 1, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mydiag_+3A_x">x</code></td>
<td>
<p>a matrix, vector or 1D array, or missing.</p>
</td></tr>
<tr><td><code id="mydiag_+3A_nrow">nrow</code></td>
<td>
<p>Optional number of rows for the result when x is not a matrix.</p>
</td></tr>
<tr><td><code id="mydiag_+3A_ncol">ncol</code></td>
<td>
<p>Optional number of columns for the result when x is not a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is a matrix then diag(x) returns the diagonal of x. The resulting vector will have names if the matrix x has matching column and rownames.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>See Also</h3>

<p><code>diag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydiag(1)
mydiag(c(1,2))

</code></pre>

<hr>
<h2 id='npdeSaemix'>Create an npdeObject from an saemixObject</h2><span id='topic+npdeSaemix'></span>

<h3>Description</h3>

<p>This function uses the npde library to compute normalised prediction distribution errors (npde)
and normalised prediction discrepancies  (npd). The simulations can also be used to plot VPCs.
As of version 3.0, the plot functions for diagnostics involving VPC, npde or npd are deprecated and
the user will be redirected to the current proposed method (creating an NpdeObject and using the
plot functions from the library npde).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npdeSaemix(saemixObject, nsim = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npdeSaemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>a fitted object resulting from a call to saemix()</p>
</td></tr>
<tr><td><code id="npdeSaemix_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations used to compute npde (1000 by default, we suggest increasing
it for large datasets)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since version 3.0, the saemix package depends on the npde package, which computes the npd/npde and
produces graphs. See the documentation for <code><a href="npde.html#topic+npde">npde</a></code> for details on the computation methods
See the PDF documentation and the bookdown <a href="https://iame-researchcenter.github.io/npde_bookdown/">https://iame-researchcenter.github.io/npde_bookdown/</a>
for details on the different plots available.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="npde.html#topic+NpdeObject">NpdeObject</a></code>
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@bichat.inserm.fr">emmanuelle.comets@bichat.inserm.fr</a>
</p>


<h3>References</h3>

<p>E Comets, K Brendel, F Mentre (2008). Computing normalised prediction distribution errors
to evaluate nonlinear mixed-effect models: the npde add-on package for R.
Computer Methods and Programs in Biomedicine, 90:154-66.
</p>
<p>K Brendel, E Comets, C Laffont, C Laveille, F Mentre (2006). Metrics for external model evaluation
with an application to the population pharmacokinetics of gliclazide. Pharmaceutical Research,
23:2036&ndash;49
</p>
<p>PDF documentation for npde 3.0: <a href="https://github.com/ecomets/npde30/blob/main/userguide_npde_3.1.pdf">https://github.com/ecomets/npde30/blob/main/userguide_npde_3.1.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="npde.html#topic+npde.graphs">npde.graphs</a></code>, <code><a href="npde.html#topic+gof.test">gof.test</a></code>
</p>
<p><code><a href="npde.html#topic+NpdeObject">NpdeObject</a></code> <code><a href="npde.html#topic+npde.plot.select">npde.plot.select</a></code>  <code><a href="npde.html#topic+autonpde">autonpde</a></code>
</p>
<p><code><a href="npde.html#topic+npde.plot.scatterplot">npde.plot.scatterplot</a></code> <code><a href="npde.html#topic+npde.plot.dist">npde.plot.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,save=FALSE,save.graphs=FALSE, 
displayProgress=FALSE)
# Not run
# Works interactively but not in the contained environment of CRAN (it looks for a datafile 
# instesad of finding the dataset in the environment)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
# npde.obj&lt;-npdeSaemix(saemix.fit)
# plot(npde.obj)
# plot(npde.obj, plot.type="vpc")
# plot(npde.obj, plot.type="covariates")
# plot(npde.obj, plot.type="cov.x.scatter")
# plot(npde.obj, plot.type="cov.ecdf")

</code></pre>

<hr>
<h2 id='oxboys.saemix'>Heights of Boys in Oxford</h2><span id='topic+oxboys.saemix'></span>

<h3>Description</h3>

<p>The <code>oxboys.saemix</code> data collects the height and age of students in Oxford measured over time.
The data frame has 234 rows and 4 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxboys.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd><p>an ordered factor giving a unique identifier for each boy in the experiment </p>
</dd>
<dt>age</dt><dd><p>a numeric vector giving the standardized age (dimensionless)</p>
</dd>
<dt>height</dt><dd><p>a numeric vector giving the height of the boy (cm)</p>
</dd>
<dt>Occasion</dt><dd><p> an ordered factor - the result of converting 'age' from a continuous variable to a count so these slightly unbalanced data can be analyzed as balanced </p>
</dd> </dl>



<h3>Details</h3>

<p>These data are described in Goldstein (1987) as data on the height of a selection of boys from Oxford, England
versus a standardized age. The dataset can be found in the package <code>nlme</code>.
We use an linear model for this data:
y_ij = Base_i + slope_i x_ij +epsilon_ij
</p>


<h3>References</h3>

<p>JC Pinheiro, DM Bates (2000) <em>Mixed-effects Models in S and S-PLUS</em>, Springer, New York (Appendix A.19)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oxboys.saemix)
saemix.data&lt;-saemixData(name.data=oxboys.saemix,header=TRUE,
      name.group=c("Subject"),name.predictors=c("age"),name.response=c("height"),
      units=list(x="yr",y="cm"))

# plot the data
plot(saemix.data)

growth.linear&lt;-function(psi,id,xidep) {
  x&lt;-xidep[,1]
  base&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  f&lt;-base+slope*x
  return(f)
}
saemix.model&lt;-saemixModel(model=growth.linear,description="Linear model",
      psi0=matrix(c(140,1),ncol=2,byrow=TRUE,dimnames=list(NULL,c("base","slope"))),
      transform.par=c(1,0),covariance.model=matrix(c(1,1,1,1),ncol=2,byrow=TRUE), 
      error.model="constant")

saemix.options&lt;-list(algorithms=c(1,1,1),nb.chains=1,seed=201004,
      save=FALSE,save.graphs=FALSE,displayProgress=FALSE)

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)


</code></pre>

<hr>
<h2 id='PD1.saemix'>Data simulated according to an Emax response model, in SAEM format</h2><span id='topic+PD1.saemix'></span><span id='topic+PD2.saemix'></span>

<h3>Description</h3>

<p>The <code>PD1.saemix</code> and <code>PD2.saemix</code> data frames were simulated
according to an Emax dose-response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PD1.saemix

PD2.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>subject</dt><dd><p>an variable identifying the subject on whom the observation was made.
The ordering is by the dose at which the observation was made.  </p>
</dd>
<dt>dose</dt><dd><p> simulated dose.  </p>
</dd>
<dt>response</dt><dd><p>simulated response</p>
</dd>
<dt>gender</dt><dd><p> gender (0 for male, 1 for female) </p>
</dd> </dl>



<h3>Details</h3>

<p>These examples were used by P. Girard and F. Mentre for the symposium dedicated to Comparison of Algorithms Using Simulated Data Sets and Blind Analysis, that took place in Lyon, France, September 2004.
The datasets contain 100 individuals, each receiving 3 different doses:(0, 10, 90), (5, 25, 65) or (0, 20, 30).
It was assumed that doses were given in a cross-over study with sufficient wash out period to avoid carry over.
Responses (y_ij) were simulated with the following pharmacodynamic model:
y_ij = E0_i + D_ij Emax_i/(D_ij + ED50_i) +epsilon_ij
The individual parameters were simulated according to
log (E0_i) = log (E0) + eta_i1
log (Emax_i) = log (Emax) + eta_i2
log (E50_i) = log (E50) +  beta w_i + eta_i3
</p>
<p>PD1.saemix contains the data simulated with a gender effect, beta=0.3.
PD2.saemix contains the data simulated without a gender effect, beta=0.
</p>


<h3>References</h3>

<p>P Girard, F Mentre (2004). Comparison of Algorithms Using Simulated Data Sets and Blind Analysis workshop, Lyon, France.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PD1.saemix)
saemix.data&lt;-saemixData(name.data=PD1.saemix,header=TRUE,name.group=c("subject"),
      name.predictors=c("dose"),name.response=c("response"),
      name.covariates=c("gender"), units=list(x="mg",y="-",covariates=c("-")))

modelemax&lt;-function(psi,id,xidep) {
# input:
#   psi : matrix of parameters (3 columns, E0, Emax, EC50)
#   id : vector of indices 
#   xidep : dependent variables (same nb of rows as length of id)
# returns:
#   a vector of predictions of length equal to length of id
  dose&lt;-xidep[,1]
  e0&lt;-psi[id,1]
  emax&lt;-psi[id,2]
  e50&lt;-psi[id,3]
  f&lt;-e0+emax*dose/(e50+dose)
  return(f)
}

# Plotting the data
plot(saemix.data,main="Simulated data PD1")

# Compare models with and without covariates with LL by Importance Sampling
model1&lt;-saemixModel(model=modelemax,description="Emax growth model", 
       psi0=matrix(c(20,300,20,0,0,0),ncol=3,byrow=TRUE,dimnames=list(NULL,
       c("E0","Emax","EC50"))), transform.par=c(1,1,1),
       covariate.model=matrix(c(0,0,0), ncol=3,byrow=TRUE),fixed.estim=c(1,1,1))

model2&lt;-saemixModel(model=modelemax,description="Emax growth model", 
       psi0=matrix(c(20,300,20,0,0,0),ncol=3,byrow=TRUE,dimnames=list(NULL, 
       c("E0","Emax","EC50"))), transform.par=c(1,1,1),
       covariate.model=matrix(c(0,0,1), ncol=3,byrow=TRUE),fixed.estim=c(1,1,1))

# SE not computed as not needed for the test
saemix.options&lt;-list(algorithms=c(0,1,1),nb.chains=3,seed=765754, 
       nbiter.saemix=c(500,300),save=FALSE,save.graphs=FALSE,displayProgress=FALSE)

fit1&lt;-saemix(model1,saemix.data,saemix.options)
fit2&lt;-saemix(model2,saemix.data,saemix.options)
wstat&lt;-(-2)*(fit1["results"]["ll.is"]-fit2["results"]["ll.is"])

cat("LRT test for covariate effect on EC50: p-value=",1-pchisq(wstat,1),"\n")

</code></pre>

<hr>
<h2 id='plot-methods'>Methods for Function plot</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for function <code>plot</code>
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> default plot function ?</p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixData\&quot;)&quot;)</dt><dd><p> Plots the data. Defaults to a
spaghetti plot of response versus predictor, with lines joining the data for
one individual.</p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> Plots prediction of the model
</p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> This method gives access to
a number of plots that can be performed on a SaemixObject</p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixSimData\&quot;)&quot;)</dt><dd><p> Plots simulated datasets</p>
</dd> </dl>


<hr>
<h2 id='plot+2CSaemixModel+2CANY-method'>Plot model predictions using an SaemixModel object</h2><span id='topic+plot+2CSaemixModel+2CANY-method'></span><span id='topic+plot+2CSaemixModel-methods'></span><span id='topic+plot+2CSaemixModel'></span><span id='topic+plot-SaemixModel'></span>

<h3>Description</h3>

<p>This function will plot predictions obtained from an SaemixModel object over a given range of X. Additional predictors may be passed on to the function using the predictors argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixModel,ANY'
plot(x, y, range = c(0, 1), psi = NULL, predictors = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>an SaemixData object or an SaemixSimData object</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>unused, present for compatibility with base plot function</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_range">range</code></td>
<td>
<p>range of X over which the model is to be plotted. Important note: the <em>first</em> predictor will be used for the X-axis, the other
predictors when present need to be passed sequentially in the predictors argument, in the order in which they appear in the model
Less important note: please use explicitely range=XXX where XXX is of the form c(a,b) to pass the plotting range on the X-axis)</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_psi">psi</code></td>
<td>
<p>parameters of the model</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_predictors">predictors</code></td>
<td>
<p>additional predictors needed to pass on to the model</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to plot (titles, legends, ...). Use verbose=TRUE to print some messages
concerning the characteristics of the plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Note that we have written the PK model so that time is the first predictor (xidep[,1]) 
# and dose the second
model1cpt&lt;-function(psi,id,xidep) { 
     tim&lt;-xidep[,1]  
     dose&lt;-xidep[,2]
     ka&lt;-psi[id,1]
     V&lt;-psi[id,2]
     CL&lt;-psi[id,3]
     k&lt;-CL/V
     ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
     return(ypred)
     }
 x&lt;-saemixModel(model=model1cpt,description="One-compartment model with first-order absorption", 
               psi0=matrix(c(1.5,30,1), ncol=3,byrow=TRUE, dimnames=list(NULL, c("ka","V","CL"))))
 # Plot the model over 0-24h, using the parameters given in psi0 and a dose of 300
 plot(x, range=c(0,24), predictors=300, verbose=TRUE)
 # Plot the model over 0-24h, using another set of parameters and a dose of 350
 plot(x, range=c(0,24), psi=c(1.5,20,2), predictors=350, verbose=TRUE)
</code></pre>

<hr>
<h2 id='plot+2CSaemixModel+2CSaemixData-method'>Plot model predictions for a new dataset. If the dataset is large, only the first 20 subjects (id's) will be shown.</h2><span id='topic+plot+2CSaemixModel+2CSaemixData-method'></span><span id='topic+plot.SaemixModel'></span>

<h3>Description</h3>

<p>Plot model predictions for a new dataset. If the dataset is large, only the first 20 subjects (id's) will be shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixModel,SaemixData'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSaemixModel+2B2CSaemixData-method_+3A_x">x</code></td>
<td>
<p>an SaemixModel object</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CSaemixData-method_+3A_y">y</code></td>
<td>
<p>an SaemixData object</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixModel+2B2CSaemixData-method_+3A_...">...</code></td>
<td>
<p>additional arguments. Passing psi=X where X is a vector or a dataframe will allow
changing the parameters for which predictions are to be computed (defaults to the population parameters
defined by the psi element of x) (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the model slot of the SaemixModel object to obtain predictions, using the dataset contained in the
SaemixData object. The user is responsible for making sure data and model match.
If psi is not given, the predictions will be computed for the population parameters (first line of the psi0 slot) of the object.
If psi is given, the number of columns in psi (or the number of elements of psi, if psi is given as a vector) should match
the number of parameters in the model, otherwise an error message will be shown and the function will return empty.
If psi is a dataframe, each line will be used for a separate subject of the smx.data object. Elements of psi will be recycled
if psi has less lines than the number of subjects in the dataset.
</p>
<p>Currently this function only works for models defined as 'structural'.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
   name.group=c("Id"),name.predictors=c("Dose","Time"),
   name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
   units=list(x="hr",y="mg/L", covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

plot(saemix.model, saemix.data)
plot(saemix.model, saemix.data, psi=c(2, 40, 3))
indpsi&lt;-data.frame(ka=2, V=seq(25,47,2), CL=seq(2.5,4.7, 0.2))
plot(saemix.model, saemix.data, psi=indpsi)

</code></pre>

<hr>
<h2 id='plot+2CSaemixObject+2CANY-method'>General plot function from SAEM</h2><span id='topic+plot+2CSaemixObject+2CANY-method'></span><span id='topic+plot.saemix'></span><span id='topic+plot+2CSaemixObject'></span><span id='topic+plot'></span><span id='topic+plotnpde'></span>

<h3>Description</h3>

<p>Several plots (selectable by the type argument) are currently available:
convergence plot, individual plots, predictions versus observations,
distribution plots, VPC, residual plots, mirror.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixObject,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSaemixObject+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixObject+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>empty</p>
</td></tr>
<tr><td><code id="plot+2B2CSaemixObject+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the generic plot function for an SaemixObject object, which
implements different graphs related to the algorithm (convergence plots,
likelihood estimation) as well as diagnostic graphs. A description is
provided in the PDF documentation. Arguments such as main, xlab, etc... that
can be given to the generic plot function may be used, and will be
interpreted according to the type of plot that is to be drawn.
</p>
<p>A special argument plot.type can be set to determine the type of plot; it
can be one of:
</p>

<dl>
<dt>data:</dt><dd><p>A spaghetti plot of the data,displaying the observed data y
as a function of the regression variable (time for a PK application)</p>
</dd>
<dt>convergence:</dt><dd><p>For each parameter in the model, this plot shows the
evolution of the parameter estimate versus the iteration number</p>
</dd>
<dt>likelihood:</dt><dd><p>Graph showing the evolution of the
log-likelihood during the estimation by importance sampling</p>
</dd>
<dt>observations.vs.predictions:</dt><dd><p>Plot of the predictions computed with
the population parameters versus the observations (left), and plot of the
predictions computed with the individual parameters versus the observations (right)</p>
</dd>
<dt>residuals.scatter:</dt><dd><p>Scatterplot of the residuals versus the
predictor (top) and versus predictions (bottom), for weighted residuals
(population residuals, left), individual weighted residuals (middle) and npde (right).</p>
</dd>
<dt>residuals.distribution:</dt><dd><p>Distribution of the residuals,
plotted as histogram (top) and as a QQ-plot (bottom), for weighted residuals
(population residuals, left), individual weighted residuals (middle) and npde (right).</p>
</dd>
<dt>individual.fit:</dt><dd><p>Individual fits are obtained using the
individual parameters with the individual covariates</p>
</dd>
<dt>population.fit:</dt><dd><p>Population fits are obtained using the population
parameters with the individual covariates</p>
</dd>
<dt>both.fit:</dt><dd><p>Individual fits, superposing fits obtained using the population
parameters with the individual covariates (red) and using the individual parameters
with the individual covariates (green)</p>
</dd>
<dt>mirror:</dt><dd><p>Mirror plots assessing the compatibility of simulated data compared to the original</p>
</dd>
<dt>marginal.distribution:</dt><dd><p>Distribution of
the parameters (conditional on covariates when some are included in the
model). A histogram of individual parameter estimates can be overlayed on
the plot, but it should be noted that the histogram does not make sense when
there are covariates influencing the parameters and a warning will be
displayed</p>
</dd>
<dt>random.effects:</dt><dd><p>Boxplot of the random effects</p>
</dd>
<dt>correlations:</dt><dd><p>Correlation between the random effects</p>
</dd>
<dt>parameters.vs.covariates:</dt><dd><p>Plots of the estimates of the individual
parameters versus the covariates, using scatterplot for continuous
covariates, boxplot for categorical covariates</p>
</dd>
<dt>randeff.vs.covariates:</dt><dd><p>Plots of the estimates of the random effects
versus the covariates, using scatterplot for continuous covariates, boxplot
for categorical covariates</p>
</dd>
<dt>npde:</dt><dd><p>Plots 4 graphs to evaluate the shape of the distribution of the
normalised prediction distribution errors (npde)</p>
</dd>
<dt>vpc:</dt><dd><p>Visual Predictive Check, with options to include the
prediction intervals around the boundaries of the selected interval as well
as around the median (50th percentile of the simulated data).</p>
</dd>
</dl>

<p>In addition, the following values for plot.type produce a series of plots:
</p>

<dl>
<dt>reduced:</dt><dd><p> produces the following plots: plot of the data,
convergence plots, plot of the likelihood by importance sampling (if
computed), plots of observations versus predictions. This is the default
behaviour of the plot function applied to an SaemixObject object</p>
</dd>
<dt>full:</dt><dd><p> produces the following plots: plot of the data, convergence
plots, plot of the likelihood by importance sampling (if computed), plots of
observations versus predictions, scatterplots and distribution of residuals,
VPC, npde, boxplot of the random effects, distribution of the parameters,
correlations between random effects, plots of the relationships between
individually estimated parameters and covariates, plots of the relationships
between individually estimated random effects and covariates</p>
</dd>
</dl>
<p>Each plot can be customised by modifying options, either through a list of
options set by the <code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code> function, or on the
fly by passing an option in the call to the plot (see examples).

</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code>, <code><a href="#topic+saemix.plot.select">saemix.plot.select</a></code>,
<code><a href="#topic+saemix.plot.data">saemix.plot.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Set of default plots
# plot(saemix.fit)

# Data
# plot(saemix.fit,plot.type="data")

# Convergence
# plot(saemix.fit,plot.type="convergence")

# Individual plot for subject 1, smoothed
# plot(saemix.fit,plot.type="individual.fit",ilist=1,smooth=TRUE)

# Individual plot for subject 1 to 12, with ask set to TRUE 
# (the system will pause before a new graph is produced)
# plot(saemix.fit,plot.type="individual.fit",ilist=c(1:12),ask=TRUE)

# Diagnostic plot: observations versus population predictions
# par(mfrow=c(1,1))
# plot(saemix.fit,plot.type="observations.vs.predictions",level=0,new=FALSE)

# LL by Importance Sampling
# plot(saemix.fit,plot.type="likelihood")

# Scatter plot of residuals
# Data will be simulated to compute weighted residuals and npde
# the results shall be silently added to the object saemix.fit
# plot(saemix.fit,plot.type="residuals.scatter")

# Boxplot of random effects
# plot(saemix.fit,plot.type="random.effects")

# Relationships between parameters and covariates
# plot(saemix.fit,plot.type="parameters.vs.covariates")

# Relationships between parameters and covariates, on the same page
# par(mfrow=c(3,2))
# plot(saemix.fit,plot.type="parameters.vs.covariates",new=FALSE)

# VPC
# Not run (time constraints for CRAN)
# plot(saemix.fit,plot.type="vpc")

</code></pre>

<hr>
<h2 id='plot.SaemixData'>Plot of longitudinal data</h2><span id='topic+plot.SaemixData'></span><span id='topic+plot+2CSaemixData-methods'></span><span id='topic+plot-SaemixData'></span><span id='topic+plot+2CSaemixData'></span><span id='topic+plot+2CSaemixData+2CANY-method'></span><span id='topic+plot.SaemixSimData'></span><span id='topic+plot+2CSaemixSimData-method'></span><span id='topic+plot+2CSaemixSimData'></span><span id='topic+plot+2CSaemixSimData+2CANY-method'></span>

<h3>Description</h3>

<p>This function will plot a longitudinal dataframe contained in an SaemixData object. By default it produces a spaghetti plot, but arguments can be passed on to modify this behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixData'
plot(x, y, ...)

## S3 method for class 'SaemixSimData'
plot(x, y, irep = -1, prediction = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SaemixData_+3A_x">x</code></td>
<td>
<p>an SaemixData object or an SaemixSimData object</p>
</td></tr>
<tr><td><code id="plot.SaemixData_+3A_y">y</code></td>
<td>
<p>unused, present for compatibility with base plot function</p>
</td></tr>
<tr><td><code id="plot.SaemixData_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to plot (titles, legends, ...)</p>
</td></tr>
<tr><td><code id="plot.SaemixData_+3A_irep">irep</code></td>
<td>
<p>which replicate datasets to use in the mirror plot (defaults to -1, causing a random simulated dataset to be sampled from the nsim
simulated datasets)</p>
</td></tr>
<tr><td><code id="plot.SaemixData_+3A_prediction">prediction</code></td>
<td>
<p>if TRUE, plot the predictions without residual variability (ypred instead of ysim). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function can also be used to visualise the predictions for simulated values of the individual parameters,
using the ypred element instead of the ysim element normally used here
</p>

<hr>
<h2 id='plotDiscreteData'>Plot non Gaussian data</h2><span id='topic+plotDiscreteData'></span><span id='topic+exploreDataTTE'></span><span id='topic+exploreDataCat'></span><span id='topic+exploreDataCountHist'></span><span id='topic+plotDiscreteData.aux'></span><span id='topic+plotDiscreteDataElement'></span>

<h3>Description</h3>

<p>This function provides exploration plots for non Gaussian longitudinal data (work in progress, doesn't work yet for RTTE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiscreteData(object, outcome = "continuous", verbose = FALSE, ...)

plotDiscreteDataElement(
  object,
  outcome = "categorical",
  mirror = FALSE,
  irep = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiscreteData_+3A_object">object</code></td>
<td>
<p>an SaemixData object returned by the <code><a href="#topic+saemixData">saemixData</a></code> function.
For plotDiscreteDataElement, an SaemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="plotDiscreteData_+3A_outcome">outcome</code></td>
<td>
<p>type of outcome (valid types are &quot;TTE&quot;, &quot;binary&quot;, &quot;categorical&quot;, &quot;count&quot;)</p>
</td></tr>
<tr><td><code id="plotDiscreteData_+3A_verbose">verbose</code></td>
<td>
<p>whether to print messages (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="plotDiscreteData_+3A_...">...</code></td>
<td>
<p>additional arguments, used to pass graphical options (to be implemented, currently not available)</p>
</td></tr>
<tr><td><code id="plotDiscreteData_+3A_mirror">mirror</code></td>
<td>
<p>if TRUE, plots a mirror plot of the same type as the data (the object must include simulated data)</p>
</td></tr>
<tr><td><code id="plotDiscreteData_+3A_irep">irep</code></td>
<td>
<p>number of the replication to use in the mirror plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a very rough first attempt at automatically creating plots to explore
discrete longitudinal data.
</p>

<ul>
<li><p> for TTE data, a KM plot will be produced
</p>
</li>
<li><p> for count, categorical and binary data, a plot showing the proportion of each score/category across time will be shown
These plots can be stratified over a covariate in the data set (currently only categorical covariates)
by passing an argument which.cov='name' to the call
#'
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>References</h3>

<p>Brendel, K, Comets, E, Laffont, C, Laveille, C, Mentre, F.
Metrics for external model evaluation with an application to the population
pharmacokinetics of gliclazide, Pharmaceutical Research 23 (2006),
2036-2049.
</p>
<p>Holford, N. The Visual Predictive Check: superiority to standard diagnostic
(Rorschach) plots (Abstract 738), in: 14th Meeting of the Population
Approach Group in Europe, Pamplona, Spain, 2005.
</p>
<p>Ron Keizer, tutorials on VPC TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>, <code><a href="#topic+simulateDiscreteSaemix">simulateDiscreteSaemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time-to-event data
data(lung.saemix)

saemix.data&lt;-saemixData(name.data=lung.saemix,header=TRUE,name.group=c("id"),
name.predictors=c("time","status","cens"),name.response=c("status"),
name.covariates=c("age", "sex", "ph.ecog", "ph.karno", "pat.karno", "wt.loss","meal.cal"),
units=list(x="days",y="",covariates=c("yr","","-","%","%","cal","pounds")))

# Plots a KM survival plot
plotDiscreteData(saemix.data, outcome="TTE")
# Plots a KM survival plot, stratified by sex
plotDiscreteData(saemix.data, outcome="TTE", which.cov="sex")

# Count data
data(rapi.saemix)
saemix.data&lt;-saemixData(name.data=rapi.saemix, name.group=c("id"),
                 name.predictors=c("time","rapi"),name.response=c("rapi"),
                 name.covariates=c("gender"),units=list(x="months",y="",covariates=c("")))

# Plots a histogram of the counts
plotDiscreteData(saemix.data, outcome="count")

</code></pre>

<hr>
<h2 id='predict-methods'>Methods for Function predict</h2><span id='topic+predict-methods'></span><span id='topic+predict+2CANY-method'></span><span id='topic+predict+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Methods for function <code>predict</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixObject'
predict(
  object,
  newdata = NULL,
  type = c("ipred", "ypred", "ppred", "icpred"),
  se.fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>
<p>an SaemixObject</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_newdata">newdata</code></td>
<td>
<p>an optional dataframe for which predictions are desired. If newdata is given, it must contain the predictors needed for the model in object</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_type">type</code></td>
<td>
<p>the type of predictions (ipred= individual, ppred=population predictions obtained with the population estimates, ypred=mean of the population predictions, icpred=conditional predictions). With newdata, individual parameters can be estimated if the new data contains observations; otherwise, predictions correspond to the population predictions ppred, and type is ignored.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_se.fit">se.fit</code></td>
<td>
<p>whether the SE are to be taken into account in the model predictions</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to fitted()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a dataframe (if more than one type) with the corresponding predictions for each observation in the dataframe
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(object = \&quot;ANY\&quot;)&quot;)</dt><dd><p>Default predict functions</p>
</dd>
<dt>list(&quot;signature(object = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p>Computes predictions
using the results of an SAEM fit</p>
</dd> </dl>


<hr>
<h2 id='predict.SaemixModel'>Predictions for a new dataset</h2><span id='topic+predict.SaemixModel'></span>

<h3>Description</h3>

<p>Predictions for a new dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixModel'
predict(object, predictors, psi = c(), id = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SaemixModel_+3A_object">object</code></td>
<td>
<p>an SaemixModel object</p>
</td></tr>
<tr><td><code id="predict.SaemixModel_+3A_predictors">predictors</code></td>
<td>
<p>a dataframe with the predictors for the model (must correspond to the predictors used by the model function), or an SaemixData object (the predictors will then be extracted from the object).</p>
</td></tr>
<tr><td><code id="predict.SaemixModel_+3A_psi">psi</code></td>
<td>
<p>a vector or a dataframe giving the parameters for which predictions are to be computed (defaults to empty).
The number of columns in psi (or the number of elements of psi, if psi is given as a vector) should match the number of
parameters in the model, otherwise an error message will be shown and the function will return empty.
If psi is NA, the predictions are computed for the population parameters in the model (first line of the psi0 slot).
Covariates are not taken into account in the prediction.
If psi is a dataframe, each line will be used for a separate 'subject' in the predictors dataframe, as
indicated by the id argument; if id is not given, only the first line of psi will be used.</p>
</td></tr>
<tr><td><code id="predict.SaemixModel_+3A_id">id</code></td>
<td>
<p>a vector of indices of length equal to the number of lines in predictors, matching each line of predictors to the
corresponding line in psi, ie the parameters for this predictors (defaults to empty). If id is given, the unique values in id must be equal
to the number of lines in psi, otherwise id will be set to 1. If id is given and its values do not take the consecutive values 1:N, the
indices will be matched to 1:N to follow the lines in psi.</p>
</td></tr>
<tr><td><code id="predict.SaemixModel_+3A_...">...</code></td>
<td>
<p>unused argument, for consistency with the generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the model slot of the SaemixModel object to obtain predictions, using the predictors object. The
user is responsible for giving all the predictors needed by the model function.
if psi is not given, the predictions will be computed for the population parameters (first line of the psi0 slot) of the object.
</p>
<p>The predictions correspond to the structure of the model; for models defined in terms of their likelihood, the predictions
are the log-pdf of the model (see documentation for details).
</p>
<p>Warning: this function is currently under development and the output may change in future versions of the package
to conform to the usual predict functions.
</p>


<h3>Value</h3>

<p>a list with two components
</p>

<dl>
<dt>param</dt><dd><p>a dataframe with the estimated parameters</p>
</dd>
<dt>predictions</dt><dd><p>a dataframe with the population predictions</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)
xpred&lt;-theo.saemix[,c("Dose","Time")]

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

head(predict(saemix.model, xpred)$predictions)
head(predict(saemix.model, xpred, psi=c(2, 40, 0.5))$predictions)
indpsi&lt;-data.frame(ka=2, V=seq(25,47,2), CL=seq(2.5,4.7, 0.2))
head(predict(saemix.model, xpred, psi=indpsi)$predictions)

</code></pre>

<hr>
<h2 id='print-methods'>Methods for Function print</h2><span id='topic+print-methods'></span><span id='topic+print.saemix'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2CSaemixData-method'></span><span id='topic+print+2CSaemixModel-method'></span><span id='topic+print+2CSaemixRes-method'></span><span id='topic+print+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Prints a summary of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
print(x, nlines = 10, ...)

## S4 method for signature 'SaemixModel'
print(x, ...)

## S4 method for signature 'SaemixRes'
print(x, digits = 2, map = FALSE, ...)

## S4 method for signature 'SaemixObject'
print(x, nlines = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-methods_+3A_x">x</code></td>
<td>
<p>an object of type SaemixData, SaemixModel, SaemixRes or SaemixObject</p>
</td></tr>
<tr><td><code id="print-methods_+3A_nlines">nlines</code></td>
<td>
<p>maximum number of lines of data to print (defaults to 10)</p>
</td></tr>
<tr><td><code id="print-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed on the print function</p>
</td></tr>
<tr><td><code id="print-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits to use for pretty printing</p>
</td></tr>
<tr><td><code id="print-methods_+3A_map">map</code></td>
<td>
<p>when map is TRUE the individual parameter estimates are shown (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Default print function </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixData\&quot;)&quot;)</dt><dd><p> Prints a summary of a
SaemixData object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> Prints a summary of a
SaemixModel object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> Prints a summary of the
results from a SAEMIX fit </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixRes\&quot;)&quot;)</dt><dd><p> Not user-level </p>
</dd> </dl>


<hr>
<h2 id='psi-methods'>Functions to extract the individual estimates of the parameters and random
effects</h2><span id='topic+psi-methods'></span><span id='topic+phi-methods'></span><span id='topic+eta-methods'></span><span id='topic+phi+2CSaemixObject-method'></span><span id='topic+eta+2CSaemixObject-method'></span><span id='topic+psi+2CSaemixObject-method'></span><span id='topic+psi'></span><span id='topic+phi'></span><span id='topic+eta'></span><span id='topic+psi.SaemixObject'></span><span id='topic+psi.saemix'></span><span id='topic+phi.SaemixObject'></span><span id='topic+eta.SaemixObject'></span><span id='topic+phi.saemix'></span><span id='topic+eta.saemix'></span>

<h3>Description</h3>

<p>These three functions are used to access the estimates of individual
parameters and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi(object, type = c("mode", "mean"))

phi(object, type = c("mode", "mean"))

eta(object, type = c("mode", "mean"))

## S4 method for signature 'SaemixObject'
psi(object, type = c("mode", "mean"))

## S4 method for signature 'SaemixObject'
phi(object, type = c("mode", "mean"))

## S4 method for signature 'SaemixObject'
eta(object, type = c("mode", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi-methods_+3A_object">object</code></td>
<td>
<p>an SaemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="psi-methods_+3A_type">type</code></td>
<td>
<p>a string specifying whether to use the MAP (type=&quot;mode&quot;) or the mean (type=&quot;mean&quot;)
of the conditional distribution of the individual parameters. Defaults to mode</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The psi_i represent the individual parameter estimates. In the SAEM
algorithm, these parameters are assumed to be a transformation of a Gaussian
random vector phi_i, where the phi_i can be written as a function of the
individual random effects (eta_i), the covariate matrix (C_i) and the vector
of fixed effects (mu):
</p>
<p>phi_i = C_i mu + eta_i
</p>
<p>More details can be found in the PDF documentation.
</p>


<h3>Value</h3>

<p>a matrix with the individual parameters (psi/phi) or the random effects (eta).
These functions are used to access and output the estimates of
parameters and random effects. When the object passed to the function does
not contain these estimates, they are automatically computed. The object is
then returned (invisibly) with these estimates added to the results.
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(object = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> please refer to the PDF
documentation for the models</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>,
<code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemixControl">saemixControl</a></code>,
<code><a href="#topic+plot.saemix">plot.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,save=FALSE,save.graphs=FALSE, 
displayProgress=FALSE)

# Not run (strict time constraints for CRAN)

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
psi(saemix.fit)
phi(saemix.fit)
eta(saemix.fit,type="mean")


</code></pre>

<hr>
<h2 id='rapi.saemix'>Rutgers Alcohol Problem Index</h2><span id='topic+rapi.saemix'></span>

<h3>Description</h3>

<p>The RAPI data studies gender differences across two years in alcohol-related problems, as measured by the Rutgers
Alcohol Problem Index (RAPI; White &amp; Labouvie, 1989). The dataset includes 3,616 repeated measures of counts
representing the number of alcohol problems reported over six months period, across five time points from 818 individuals.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>subject identification number</p>
</dd>
<dt>time</dt><dd><p>time since the beginning of the study (months)</p>
</dd>
<dt>rapi</dt><dd><p>the number of reported alcohol problems during a six-months period</p>
</dd>
<dt>gender</dt><dd><p> gender (0=Men, 1=Women</p>
</dd> </dl>



<h3>Source</h3>

<p>David Atkins, University of Washington
</p>


<h3>References</h3>

<p>D Atkins, S Baldwin, C Zheng, R Gallop, C Neighbors C (2013).
A tutorial on count regression and zero-altered count models
for longitudinal substance use data. Psychology of Addictive Behaviors, 27(1):166177.
</p>
<p>C Neighbors, Lewis MA, Atkins D, Jensen MM, Walter T, Fossos N, Lee C, Larimer M (2010).
Efficacy of web-based personalized normative feedback: A two-year randomized controlled trial.
Journal of Consulting and Clinical Psychology 78(6):898-911.
</p>
<p>C Neighbors, N Barnett, D Rohsenow, S Colby, P Monti (2010). Cost-Effectiveness of a Motivational lntervention for
Alcohol-Involved Youth in a Hospital Emergency Department. Journal of Studies on Alcohol and Drugs 71(3):384-394.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(rapi.saemix)
 saemix.data&lt;-saemixData(name.data=rapi.saemix, name.group=c("id"),
                     name.predictors=c("time","rapi"),name.response=c("rapi"),
                     name.covariates=c("gender"),units=list(x="months",y="",covariates=c("")))
hist(rapi.saemix$rapi, main="", xlab="RAPI score", breaks=30)


# Fitting a Poisson model
count.poisson&lt;-function(psi,id,xidep) { 
  time&lt;-xidep[,1]
  y&lt;-xidep[,2]
  intercept&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  lambda&lt;- exp(intercept + slope*time)
  logp &lt;- -lambda + y*log(lambda) - log(factorial(y))
  return(logp)
}
countsimulate.poisson&lt;-function(psi, id, xidep) {
   time&lt;-xidep[,1]
   y&lt;-xidep[,2]
   ymax&lt;-max(y)
   intercept&lt;-psi[id,1]
   slope&lt;-psi[id,2]
   lambda&lt;- exp(intercept + slope*time)
   y&lt;-rpois(length(time), lambda=lambda)
   y[y&gt;ymax]&lt;-ymax+1 # truncate to maximum observed value to avoid simulating aberrant values
   return(y)
}
# Gender effect on intercept and slope
rapimod.poisson&lt;-saemixModel(model=count.poisson, simulate.function=countsimulate.poisson,
   description="Count model Poisson",modeltype="likelihood",   
   psi0=matrix(c(log(5),0.01),ncol=2,byrow=TRUE,dimnames=list(NULL, c("intercept","slope"))), 
   transform.par=c(0,0), omega.init=diag(c(0.5, 0.5)),
    covariance.model =matrix(data=1, ncol=2, nrow=2),
    covariate.model=matrix(c(1,1), ncol=2, byrow=TRUE))
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE, displayProgress=FALSE, fim=FALSE)
poisson.fit&lt;-saemix(rapimod.poisson,saemix.data,saemix.options)

# Fitting a ZIP model
count.poissonzip&lt;-function(psi,id,xidep) {
  time&lt;-xidep[,1]
  y&lt;-xidep[,2]
  intercept&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  p0&lt;-psi[id,3] # Probability of zero's
  lambda&lt;- exp(intercept + slope*time)
  logp &lt;- log(1-p0) -lambda + y*log(lambda) - log(factorial(y)) # Poisson
  logp0 &lt;- log(p0+(1-p0)*exp(-lambda)) # Zeroes
  logp[y==0]&lt;-logp0[y==0]
  return(logp)
}
countsimulate.poissonzip&lt;-function(psi, id, xidep) {
  time&lt;-xidep[,1]
  y&lt;-xidep[,2]
  ymax&lt;-max(y)
  intercept&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  p0&lt;-psi[id,3] # Probability of zero's
  lambda&lt;- exp(intercept + slope*time)
  prob0&lt;-rbinom(length(time), size=1, prob=p0)
  y&lt;-rpois(length(time), lambda=lambda)
  y[prob0==1]&lt;-0
  y[y&gt;ymax]&lt;-ymax+1 # truncate to maximum observed value to avoid simulating aberrant values
  return(y)
}
rapimod.zip&lt;-saemixModel(model=count.poissonzip, simulate.function=countsimulate.poissonzip,
   description="count model ZIP",modeltype="likelihood",   
   psi0=matrix(c(1.5, 0.01, 0.2),ncol=3,byrow=TRUE,
   dimnames=list(NULL, c("intercept", "slope","p0"))), 
   transform.par=c(0,0,3), covariance.model=diag(c(1,1,0)), omega.init=diag(c(0.5,0.3,0)),
   covariate.model = matrix(c(1,1,0),ncol=3, byrow=TRUE))
zippoisson.fit&lt;-saemix(rapimod.zip,saemix.data,saemix.options)

# Using simulations to compare the predicted proportion of 0's in the two models
nsim&lt;-100
yfit1&lt;-simulateDiscreteSaemix(poisson.fit,  nsim=nsim)
yfit2&lt;-simulateDiscreteSaemix(zippoisson.fit,  nsim=100)
{
nobssim&lt;-length(yfit1@sim.data@datasim$ysim)
cat("Observed proportion of 0's", 
   length(yfit1@data@data$rapi[yfit1@data@data$rapi==0])/yfit1@data@ntot.obs,"\n")
cat("      Poisson model, p=",
   length(yfit1@sim.data@datasim$ysim[yfit1@sim.data@datasim$ysim==0])/nobssim,"\n")
cat("          ZIP model, p=",
   length(yfit2@sim.data@datasim$ysim[yfit2@sim.data@datasim$ysim==0])/nobssim,"\n")
}
  
  
</code></pre>

<hr>
<h2 id='readSaemix-methods'>Methods for Function read</h2><span id='topic+readSaemix-methods'></span><span id='topic+readSaemix'></span>

<h3>Description</h3>

<p>Reads longitudinal data to create a SaemixData object (internal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSaemix(object, dat = NULL)
</code></pre>

<hr>
<h2 id='readSaemix+2CSaemixData-method'>Create a longitudinal data structure from a file or a dataframe
Helper function not intended to be called by the user</h2><span id='topic+readSaemix+2CSaemixData-method'></span><span id='topic+readSaemix+2CSaemixData'></span>

<h3>Description</h3>

<p>Create a longitudinal data structure from a file or a dataframe
</p>
<p>Helper function not intended to be called by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
readSaemix(object, dat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSaemix+2B2CSaemixData-method_+3A_object">object</code></td>
<td>
<p>an SaemixData object</p>
</td></tr>
<tr><td><code id="readSaemix+2B2CSaemixData-method_+3A_dat">dat</code></td>
<td>
<p>the name of a dataframe in the R environment, defaults to NULL; if NULL, the function will
attempt to read the file defined by the slot name.data.</p>
</td></tr>
</table>

<hr>
<h2 id='replaceData'>Replace the data element in an SaemixObject object</h2><span id='topic+replaceData'></span><span id='topic+replaceData.saemixObject'></span><span id='topic+replaceData-methods'></span>

<h3>Description</h3>

<p>Returns an SaemixObject object where the data object has been replaced by the data provided in a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceData.saemixObject(saemixObject, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceData_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an SaemixObject object</p>
</td></tr>
<tr><td><code id="replaceData_+3A_newdata">newdata</code></td>
<td>
<p>a dataframe containing data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+SaemixObject-class">SaemixObject</a>"</code>. The population parameters are retained but all the predictions, individual parameters and statistical criteria are removed. The function attempts to extract the elements entering the statistical model (subject id, predictors, covariates and response).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='resid.saemix'>Extract Model Residuals</h2><span id='topic+resid.saemix'></span><span id='topic+resid.SaemixRes'></span><span id='topic+residuals.SaemixRes'></span><span id='topic+residuals.saemix'></span><span id='topic+residuals'></span><span id='topic+resid'></span><span id='topic+resid.SaemixObject'></span><span id='topic+residuals.SaemixObject'></span>

<h3>Description</h3>

<p>residuals is a generic function which extracts model residuals from objects returned by modelling functions. The  abbreviated form resid is an alias for residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixRes'
resid(object, type = c("ires", "wres", "npde", "pd", "iwres", "icwres"), ...)

## S3 method for class 'SaemixObject'
resid(object, type = c("ires", "wres", "npde", "pd", "iwres", "icwres"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.saemix_+3A_object">object</code></td>
<td>
<p>an SaemixRes or an SaemixObject object</p>
</td></tr>
<tr><td><code id="resid.saemix_+3A_type">type</code></td>
<td>
<p>string determining which residuals are extracted. Possible values are: &quot;ires&quot; (individual residuals, default), &quot;wres&quot; (weighted population residuals), &quot;npde&quot; (normalised prediction distribution errors), &quot;pd&quot; (prediction discrepancies), &quot;iwres&quot; (individual weighted residuals) and &quot;icwres&quot; (conditional individual weighted residuals). See user guide for details.</p>
</td></tr>
<tr><td><code id="resid.saemix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, individual residuals are extracted from the model object
</p>

<hr>
<h2 id='saemix'>Stochastic Approximation Expectation Maximization (SAEM) algorithm</h2><span id='topic+saemix'></span><span id='topic+initialiseMainAlgo'></span><span id='topic+mstep'></span><span id='topic+estep'></span>

<h3>Description</h3>

<p>SAEM algorithm perform parameter estimation for nonlinear mixed effects
models without any approximation of the model (linearization, quadrature
approximation, . . . )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemix(model, data, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix_+3A_model">model</code></td>
<td>
<p>an object of class SaemixModel, created by a call to the
function <code><a href="#topic+saemixModel">saemixModel</a></code></p>
</td></tr>
<tr><td><code id="saemix_+3A_data">data</code></td>
<td>
<p>an object of class SaemixData, created by a call to the function
<code><a href="#topic+saemixData">saemixData</a></code></p>
</td></tr>
<tr><td><code id="saemix_+3A_control">control</code></td>
<td>
<p>a list of options, see <code><a href="#topic+saemixControl">saemixControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SAEM algorithm is a stochastic approximation version of the standard EM
algorithm proposed by Kuhn and Lavielle (see reference). Details of the
algorithm can be found in the pdf file accompanying the package.
</p>


<h3>Value</h3>

<p>An object of class SaemixObject containing the results of the fit of
the data by the non-linear mixed effect model. A summary of the results is
printed out to the terminal, and, provided the appropriate options have not
been changed, numerical and graphical outputs are saved in a directory.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>,
<code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemixControl">saemixControl</a></code>,
<code><a href="#topic+plot.saemix">plot.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
   name.group=c("Id"),name.predictors=c("Dose","Time"),
   name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
   units=list(x="hr",y="mg/L", covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,modeltype="structural",
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")


# Not run (strict time constraints for CRAN)
 saemix.fit&lt;-saemix(saemix.model,saemix.data,list(seed=632545,directory="newtheo",
 save=FALSE,save.graphs=FALSE, print=FALSE))
 
# Prints a summary of the results
print(saemix.fit)

# Outputs the estimates of individual parameters
psi(saemix.fit)

# Shows some diagnostic plots to evaluate the fit
plot(saemix.fit)

</code></pre>

<hr>
<h2 id='saemix.bootstrap'>Bootstrap for saemix fits</h2><span id='topic+saemix.bootstrap'></span>

<h3>Description</h3>

<p>This function provides bootstrap estimates for a saemixObject run. Different bootstrap approaches have been
implemented (see below for details), with the default method being the conditional non-parametric bootstrap ()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemix.bootstrap(
  saemixObject,
  method = "conditional",
  nboot = 200,
  nsamp = 100,
  saemix.options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix.bootstrap_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="saemix.bootstrap_+3A_method">method</code></td>
<td>
<p>the name of the bootstrap algorithm to use (one of: &quot;case&quot;, &quot;residual&quot;, &quot;parametric&quot; or &quot;conditional&quot;) (defaults to &quot;conditional&quot;)</p>
</td></tr>
<tr><td><code id="saemix.bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
<tr><td><code id="saemix.bootstrap_+3A_nsamp">nsamp</code></td>
<td>
<p>number of samples from the conditional distribution (for method=&quot;conditional&quot;)</p>
</td></tr>
<tr><td><code id="saemix.bootstrap_+3A_saemix.options">saemix.options</code></td>
<td>
<p>list of options to run the saemix algorithm. Defaults to the options in the object, but suppressing the estimation of individual parameters (map=FALSE) and likelihood (ll.is=FALSE), and the options to print out intermediate results and graphs (displayProgress=FALSE,save.graphs=FALSE,print=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different bootstrap algorithms have been proposed for non-linear mixed effect models,
to account for the hierarchical nature of these models (see review in Thai et al. 2013, 2014)
In saemix, we implemented the following bootstrap algorithms, which can be selected using the &quot;method&quot; argument:
</p>

<ul>
<li><p> case refers to case bootstrap, where resampling is performed at the level of the individual and the bootstrap sample consists in sampling with replacement from the observed individuals
</p>
</li>
<li><p> residual refers to non-parametric residual bootstrap, where for each individual the residuals for the random effects and for the residual error are resampled from the individual estimates after the fit
</p>
</li>
<li><p> parametric refers to parametric residual bootstrap, where these residuals are sampled from their theoretical distributions. In
saemix, random effects are drawn from a normal distribution using the estimated variance in saemixObject, and transformed
to the distribution specified by the transform.par component of the model, and the residual error is drawn from a normal distribution
using the estimated residual variance.
</p>
</li>
<li><p> conditional refers to the conditional non-parametric bootstrap, where the random effects are resampled from the individual
conditional distributions as in (Comets et al. 2021) and the residual errors resampled from the corresponding residuals
</p>
</li></ul>

<p><strong>Important note:</strong> for discrete data models, all residual-based bootstraps (residual, parametric and conditional) need
a simulate.function slot to be included in the model object, as the algorithm will need to generate predictions with the
resampled individual parameters in order to generate bootstrap samples. See <code><a href="#topic+SaemixModel">SaemixModel</a></code> and the examples
provided as notebooks for details.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>References</h3>

<p>Thai H, Mentr F, Holford NH, Veyrat-Follet C, Comets E.
A comparison of bootstrap approaches for estimating uncertainty of parameters in
linear mixed-effects models. Pharmaceutical Statistics, 2013 ;12:12940.
</p>
<p>Thai H, Mentr F, Holford NH, Veyrat-Follet C, Comets E.
Evaluation of bootstrap methods for estimating uncertainty of parameters in
nonlinear mixed-effects models : a simulation study in population pharmacokinetics.
Journal of Pharmacokinetics and Pharmacodynamics, 2014; 41:1533.
</p>
<p>Comets E, Rodrigues C, Jullien V, Moreno U. Conditional non-parametric bootstrap for
non-linear mixed effect models. Pharmaceutical Research, 2021; 38, 105766.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bootstrap for the theophylline data 
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithm=c(1,0,0),seed=632545,save=FALSE,save.graphs=FALSE, 
displayProgress=FALSE)

# Not run (strict time constraints for CRAN)

saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
# Only 10 bootstrap samples here for speed, please increase to at least 200
theo.case &lt;- saemix.bootstrap(saemix.fit, method="case", nboot=10)
theo.cond &lt;- saemix.bootstrap(saemix.fit, nboot=10)


# Bootstrap for the toenail data
data(toenail.saemix)
saemix.data&lt;-saemixData(name.data=toenail.saemix,name.group=c("id"), name.predictors=c("time","y"), 
 name.response="y", name.covariates=c("treatment"),name.X=c("time"))
 
binary.model&lt;-function(psi,id,xidep) {
  tim&lt;-xidep[,1]
  y&lt;-xidep[,2]
  inter&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  logit&lt;-inter+slope*tim
  pevent&lt;-exp(logit)/(1+exp(logit))
  pobs = (y==0)*(1-pevent)+(y==1)*pevent
  logpdf &lt;- log(pobs)
  return(logpdf)
}
simulBinary&lt;-function(psi,id,xidep) {
    tim&lt;-xidep[,1]
    y&lt;-xidep[,2]
    inter&lt;-psi[id,1]
    slope&lt;-psi[id,2]
    logit&lt;-inter+slope*tim
    pevent&lt;-1/(1+exp(-logit))
    ysim&lt;-rbinom(length(tim),size=1, prob=pevent)
    return(ysim)
    }

saemix.model&lt;-saemixModel(model=binary.model,description="Binary model",
     modeltype="likelihood", simulate.function=simulBinary,
     psi0=matrix(c(-5,-.1,0,0),ncol=2,byrow=TRUE,dimnames=list(NULL,c("inter","slope"))),
     transform.par=c(0,0))
     

saemix.options&lt;-list(seed=1234567,save=FALSE,save.graphs=FALSE, displayProgress=FALSE, 
   nb.chains=10, fim=FALSE)
binary.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
# Only 10 bootstrap samples here for speed, please increase to at least 200
toenail.case &lt;- saemix.bootstrap(binary.fit, method="case", nboot=10)
toenail.cond &lt;- saemix.bootstrap(binary.fit, nboot=10)


</code></pre>

<hr>
<h2 id='saemix.internal'>Internal saemix objects</h2><span id='topic+saemix.internal'></span><span id='topic+.First.lib'></span><span id='topic+cutoff'></span><span id='topic+cutoff.eps'></span><span id='topic+cutoff.max'></span><span id='topic+cutoff.res'></span><span id='topic+normcdf'></span><span id='topic+norminv'></span><span id='topic+error'></span><span id='topic+error.typ'></span><span id='topic+ssq'></span><span id='topic+transpsi'></span><span id='topic+transphi'></span><span id='topic+derivphi'></span><span id='topic+dtransphi'></span><span id='topic+compute.Uy'></span><span id='topic+compute.LLy'></span><span id='topic+conditional.distribution'></span><span id='topic+trnd.mlx'></span><span id='topic+gammarnd.mlx'></span><span id='topic+tpdf.mlx'></span><span id='topic+conditional.distribution_c'></span><span id='topic+conditional.distribution_d'></span><span id='topic+center.eps'></span><span id='topic+center.eta'></span><span id='topic+normalise.eta'></span><span id='topic+normalise.eta.svd'></span><span id='topic+centerDist.NPcond'></span>

<h3>Description</h3>

<p>Internal saemix objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff(x, seuil = .Machine$double.xmin)

center.eps(x)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='saemix.plot.data'>Functions implementing each type of plot in SAEM</h2><span id='topic+saemix.plot.data'></span><span id='topic+saemix.plot.convergence'></span><span id='topic+saemix.plot.llis'></span><span id='topic+saemix.plot.obsvspred'></span><span id='topic+saemix.plot.distribresiduals'></span><span id='topic+saemix.plot.scatterresiduals'></span><span id='topic+saemix.plot.fits'></span><span id='topic+saemix.plot.distpsi'></span><span id='topic+saemix.plot.randeff'></span><span id='topic+saemix.plot.correlations'></span><span id='topic+saemix.plot.parcov'></span><span id='topic+saemix.plot.randeffcov'></span><span id='topic+saemix.plot.npde'></span><span id='topic+saemix.plot.vpc'></span><span id='topic+saemix.plot.mirror'></span><span id='topic+saemix.plot.parcov.aux'></span><span id='topic+compute.sres'></span><span id='topic+compute.eta.map'></span>

<h3>Description</h3>

<p>Several plots (selectable by the type argument) are currently available:
convergence plot, individual plots, predictions versus observations,
distribution plots, VPC, residual plots, and mirror plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemix.plot.data(saemixObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix.plot.data_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="saemix.plot.data_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement plots different graphs related to the algorithm
(convergence plots, likelihood estimation) as well as diagnostic graphs. A
description is provided in the PDF documentation.
</p>
<p>saemix.plot.parcov.aux, compute.sres and compute.eta.map are helper
functions, not intended to be called by the user directly.
</p>
<p>By default, the following plots are produced:
</p>

<dl>
<dt>saemix.plot.data:</dt><dd><p>A spaghetti plot of the data, displaying the
observed data y as a function of the regression variable (time for a PK
application)</p>
</dd>
<dt>saemix.plot.convergence:</dt><dd><p>For each parameter in the
model, this plot shows the evolution of the parameter estimate versus the
iteration number</p>
</dd>
<dt>saemix.plot.llis:</dt><dd><p>Graph showing the evolution of
the log-likelihood during the estimation by importance sampling</p>
</dd>
<dt>saemix.plot.obsvspred:</dt><dd><p>Plot of the predictions computed with the
population parameters versus the observations (left), and plot of the
predictions computed with the individual parameters versus the observations
(right)</p>
</dd>
<dt>saemix.plot.scatterresiduals:</dt><dd><p>Scatterplot of the residuals
versus the predictor (top) and versus predictions (bottom), for weighted
residuals (population residuals, left), individual weighted residuals
(middle) and npde (right).</p>
</dd>
<dt>saemix.plot.distribresiduals:</dt><dd><p>Distribution of the residuals, plotted
as histogram (top) and as a QQ-plot (bottom), for weighted residuals
(population residuals, left), individual weighted residuals (middle) and
npde (right).</p>
</dd>
<dt>saemix.plot.fits:</dt><dd><p>Model fits. Individual fits are
obtained using the individual parameters with the individual covariates.
Population fits are obtained using the population parameters with the
individual covariates (red) and the individual parameters with the
individual covariates (green). By default the individual plots are
displayed.</p>
</dd>
<dt>saemix.plot.distpsi:</dt><dd><p>Distribution of the parameters
(conditional on covariates when some are included in the model). A histogram
of individual parameter estimates can be overlayed on the plot, but it
should be noted that the histogram does not make sense when there are
covariates influencing the parameters and a warning will be displayed</p>
</dd>
<dt>saemix.plot.randeff:</dt><dd><p>Boxplot of the random effects</p>
</dd>
<dt>saemix.plot.correlations:</dt><dd><p>Correlation between the random effects</p>
</dd>
<dt>saemix.plot.parcov:</dt><dd><p>Plots of the estimates of the individual
parameters versus the covariates, using scatterplot for continuous
covariates, boxplot for categorical covariates</p>
</dd>
<dt>saemix.plot.randeffcov:</dt><dd><p>Plots of the estimates of the random effects
versus the covariates, using scatterplot for continuous covariates, boxplot
for categorical covariates</p>
</dd>
<dt>saemix.plot.npde:</dt><dd><p>Plots 4 graphs to
evaluate the shape of the distribution of the normalised prediction
distribution errors (npde)</p>
</dd>
<dt>saemix.plot.vpc:</dt><dd><p>Visual Predictive Check,
with options to include the prediction intervals around the boundaries of
the selected interval as well as around the median (50th percentile of the
simulated data). Several methods are available to define binning on the
X-axis (see methods in the PDF guide).</p>
</dd>
<dt>saemix.plot.mirror:</dt><dd><p>When simulated data is available in the object (component
sim.dat, which can be filled by a call to <code><a href="stats.html#topic+simulate">simulate</a></code>), this function
plots the original data as spaghetti plot and compares it to several simulated
datasets under the fitted model.</p>
</dd>
</dl>

<p>Each plot can be customised by modifying options, either through a list of
options set by the <code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code> function, or on the
fly by passing an option in the call to the plot (see examples).
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code>, <code><a href="#topic+saemix.plot.select">saemix.plot.select</a></code>,
<code><a href="#topic+plot.saemix">plot.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Simulate data and compute weighted residuals and npde
saemix.fit&lt;-compute.sres(saemix.fit)

# Data
saemix.plot.data(saemix.fit)

# Convergence
saemix.plot.convergence(saemix.fit)

# Individual plot for subject 1, smoothed
saemix.plot.fits(saemix.fit,ilist=1,smooth=TRUE)

# Individual plot for subject 1 to 12, with ask set to TRUE 
# (the system will pause before a new graph is produced)
saemix.plot.fits(saemix.fit,ilist=c(1:12),ask=TRUE)

# Mirror plots (plots of simulated data compared to the original)
saemix.plot.mirror(saemix.fit)

# Diagnostic plot: observations versus population predictions
par(mfrow=c(1,1))
saemix.plot.obsvspred(saemix.fit,level=0,new=FALSE)

# LL by Importance Sampling
saemix.plot.llis(saemix.fit)

# Boxplot of random effects
saemix.plot.randeff(saemix.fit)

# Relationships between parameters and covariates
saemix.plot.parcov(saemix.fit)

# Relationships between parameters and covariates, on the same page
par(mfrow=c(3,2))
saemix.plot.parcov(saemix.fit,new=FALSE)

# Scatter plot of residuals
# Not run
# Works interactively but not in the contained environment of CRAN (it looks for a datafile 
# instesad of finding the dataset in the environment)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
# npde.obj&lt;-npdeSaemix(saemix.fit)
# plot(npde.obj)
# VPC, default options (10 bins, equal number of observations in each bin)
# plot(npde.obj, plot.type="vpc")
# plot(npde.obj, plot.type="covariates")
# plot(npde.obj, plot.type="cov.x.scatter")
# plot(npde.obj, plot.type="cov.ecdf")
# VPC, user-defined breaks for binning
# plot(npde.obj, plot.type="vpc", bin.method="user", bin.breaks=c(0.4,0.8,1.5,2.5,4,5.5,8,10,13))


</code></pre>

<hr>
<h2 id='saemix.plot.select'>Plots of the results obtained by SAEM</h2><span id='topic+saemix.plot.select'></span>

<h3>Description</h3>

<p>Several plots (selectable by the type argument) are currently available:
convergence plot, individual plots, predictions versus observations,
distribution plots, residual plots, VPC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemix.plot.select(
  saemixObject,
  data = FALSE,
  convergence = FALSE,
  likelihood = FALSE,
  individual.fit = FALSE,
  population.fit = FALSE,
  both.fit = FALSE,
  observations.vs.predictions = FALSE,
  residuals.scatter = FALSE,
  residuals.distribution = FALSE,
  random.effects = FALSE,
  correlations = FALSE,
  parameters.vs.covariates = FALSE,
  randeff.vs.covariates = FALSE,
  marginal.distribution = FALSE,
  vpc = FALSE,
  npde = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix.plot.select_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_data">data</code></td>
<td>
<p>if TRUE, produce a plot of the data. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_convergence">convergence</code></td>
<td>
<p>if TRUE, produce a convergence plot. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_likelihood">likelihood</code></td>
<td>
<p>if TRUE, produce a plot of the estimation of the LL by
importance sampling. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_individual.fit">individual.fit</code></td>
<td>
<p>if TRUE, produce individual fits with individual
estimates. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_population.fit">population.fit</code></td>
<td>
<p>if TRUE, produce individual fits with population
estimates. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_both.fit">both.fit</code></td>
<td>
<p>if TRUE, produce individual fits with both individual and
population estimates. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_observations.vs.predictions">observations.vs.predictions</code></td>
<td>
<p>if TRUE, produce a plot of observations
versus predictions. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_residuals.scatter">residuals.scatter</code></td>
<td>
<p>if TRUE, produce scatterplots of residuals versus
predictor and predictions. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_residuals.distribution">residuals.distribution</code></td>
<td>
<p>if TRUE, produce plots of the distribution of
residuals. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_random.effects">random.effects</code></td>
<td>
<p>if TRUE, produce boxplots of the random effects.
Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_correlations">correlations</code></td>
<td>
<p>if TRUE, produce a matrix plot showing the correlation
between random effects. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_parameters.vs.covariates">parameters.vs.covariates</code></td>
<td>
<p>if TRUE, produce plots of the relationships
between parameters and covariates, using the Empirical Bayes Estimates of
individual parameters. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_randeff.vs.covariates">randeff.vs.covariates</code></td>
<td>
<p>if TRUE, produce plots of the relationships
between random effects and covariates, using the Empirical Bayes Estimates
of individual random effects. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_marginal.distribution">marginal.distribution</code></td>
<td>
<p>if TRUE, produce plots of the marginal
distribution of the random effects. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_vpc">vpc</code></td>
<td>
<p>if TRUE, produce Visual Predictive Check plots. Defaults to FALSE (we suggest to use <code><a href="#topic+npdeSaemix">npdeSaemix</a></code> instead)</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_npde">npde</code></td>
<td>
<p>if TRUE, produce plots of the npde. Defaults to FALSE (deprecated in 3.0, please use <code><a href="#topic+npdeSaemix">npdeSaemix</a></code> instead)</p>
</td></tr>
<tr><td><code id="saemix.plot.select_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots different graphs related to the algorithm (convergence
plots, likelihood estimation) as well as diagnostic graphs. A description is
provided in the PDF documentation.
</p>

<dl>
<dt>data</dt><dd><p>A spaghetti plot of the data, displaying the observed data y as a function of the regression
variable (eg time for a PK application)</p>
</dd>
<dt>convergence</dt><dd><p>For each parameter in the model, this plot shows the evolution of the parameter
estimate versus the iteration number</p>
</dd>
<dt>likelihood</dt><dd><p>Estimation of the likelihood estimated by importance sampling, as a function of the number of
MCMC samples</p>
</dd>
<dt>individual.fit</dt><dd><p>Individual fits, using the individual parameters with the individual covariates</p>
</dd>
<dt>population.fit</dt><dd><p>Individual fits, using the population parameters with the individual covariates</p>
</dd>
<dt>both.fit</dt><dd><p>Individual fits, using the population parameters with the individual covariates and the individual parameters with the individual covariates</p>
</dd>
<dt>observations.vs.predictions</dt><dd><p>Plot of the predictions computed with the population parameters versus the observations (left), and plot of the predictions computed with the individual parameters versus the observations (right)</p>
</dd>
<dt>residuals.scatter</dt><dd><p>Scatterplot of standardised residuals versus the X predictor and versus predictions. These plots are shown for individual and population residuals, as well as for npde when they are available</p>
</dd>
<dt>residuals.distribution</dt><dd><p>Distribution of standardised residuals, using histograms and QQ-plot. These plots are shown for
individual and population residuals, as well as for npde when they are available</p>
</dd>
<dt>random.effects</dt><dd><p>Boxplot of the random effects</p>
</dd>
<dt>correlations</dt><dd><p>Correlation between the random effects, with a smoothing spline</p>
</dd>
<dt>parameters.versus.covariates</dt><dd><p>Plots of the estimate of the individual parameters versus the covariates, using scatterplot for continuous covariates, boxplot for categorical covariates</p>
</dd>
<dt>randeff.versus.covariates</dt><dd><p>Plots of the estimate of the individual random effects versus the covariates, using scatterplot for continuous covariates, boxplot for categorical covariates</p>
</dd>
<dt>marginal.distribution</dt><dd><p>Distribution of each parameter in the model (conditional on covariates when some are included in the model)</p>
</dd>
<dt>npde</dt><dd><p>Plot of npde as in package npde (deprecated in 3.0, please use <code><a href="#topic+npdeSaemix">npdeSaemix</a></code> instead)</p>
</dd>
<dt>vpc</dt><dd><p>Visual Predictive Check (we suggest to use <code><a href="#topic+npdeSaemix">npdeSaemix</a></code> instead)</p>
</dd>
</dl>



<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+default.saemix.plots">default.saemix.plots</a></code>, <code><a href="#topic+saemix.plot.setoptions">saemix.plot.setoptions</a></code>,
<code><a href="#topic+saemix.plot.data">saemix.plot.data</a></code>, <code><a href="#topic+saemix.plot.convergence">saemix.plot.convergence</a></code>,
<code><a href="#topic+saemix.plot.llis">saemix.plot.llis</a></code>, <code><a href="#topic+saemix.plot.randeff">saemix.plot.randeff</a></code>,
<code><a href="#topic+saemix.plot.obsvspred">saemix.plot.obsvspred</a></code>, <code><a href="#topic+saemix.plot.fits">saemix.plot.fits</a></code>,
<code><a href="#topic+saemix.plot.parcov">saemix.plot.parcov</a></code>, <code><a href="#topic+saemix.plot.randeffcov">saemix.plot.randeffcov</a></code>,
<code><a href="#topic+saemix.plot.distpsi">saemix.plot.distpsi</a></code>, <code><a href="#topic+npdeSaemix">npdeSaemix</a></code>
<code><a href="#topic+saemix.plot.scatterresiduals">saemix.plot.scatterresiduals</a></code>,
<code><a href="#topic+saemix.plot.distribresiduals">saemix.plot.distribresiduals</a></code>, <code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)

# Not run (strict time constraints for CRAN)
# saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# saemix.plot.select(saemix.fit,data=TRUE,main="Spaghetti plot of data")

# Putting several graphs on the same plot
# par(mfrow=c(2,2))
# saemix.plot.select(saemix.fit,data=TRUE,vpc=TRUE,observations.vs.predictions=TRUE, new=FALSE)

</code></pre>

<hr>
<h2 id='saemix.plot.setoptions'>Function setting the default options for the plots in SAEM</h2><span id='topic+saemix.plot.setoptions'></span><span id='topic+saemix.data.setoptions'></span><span id='topic+replace.plot.options'></span><span id='topic+replace.data.options'></span>

<h3>Description</h3>


<ul>
<li><p> ablinecol Color of the lines added to the plots (default: &quot;DarkRed&quot;)
</p>
</li>
<li><p> ablinelty Type of the lines added to the plots. Defaults to 2 (dashed line)
</p>
</li>
<li><p> ablinelwd Width of the lines added to the plots (default: 2)
</p>
</li>
<li><p> ask A logical value. If TRUE, users will be prompted before each new plot. Defaults to FALSE
</p>
</li>
<li><p> cex A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. Defaults to 1 (no magnification)
</p>
</li>
<li><p> cex.axis Magnification to be used for axis annotation relative to the current setting of 'cex'. Defaults to 1 (no magnification)
</p>
</li>
<li><p> cex.main Magnification to be used for main titles relative to the current setting of 'cex'. Defaults to 1 (no magnification)
</p>
</li>
<li><p> cex.lab Magnification to be used for x and y labels relative to the current setting of 'cex'. Defaults to 1 (no magnification)
</p>
</li>
<li><p> col.fillmed For the VPC plots: color filling the prediction interval for the median. Defaults to &quot;pink&quot;
</p>
</li>
<li><p> col.fillpi For the VPC plots: color filling the prediction interval for the limits of the prediction interval. Defaults to &quot;slategray1&quot;
</p>
</li>
<li><p> col.lmed For the VPC plots: color of the line showing the median of the simulated data. Defaults to &quot;indianred4&quot;
</p>
</li>
<li><p> col.lobs For the VPC plots: color of the lines showing the median, 2.5 and 97.5th percentiles (for a 95% prediction interval). Defaults to &quot;steelblue4&quot;
</p>
</li>
<li><p> col.lpi For the VPC plots: color of the line showing the boundaries of the prediction intervals. Defaults to &quot;slategray4&quot;
</p>
</li>
<li><p> col.obs For the VPC plots: color used to plot the observations. Defaults to &quot;steelblue4&quot;
</p>
</li>
<li><p> cov.name Name of the covariate to be used in the plots. Defaults to the first covariate in the model
</p>
</li>
<li><p> cov.value Value of the covariate to be used in the plots. Defaults to NA, indicating that the median value of the covariate (for continuous covariates) or the reference category (for categorical covariates) will be used
</p>
</li>
<li><p> ilist List of indices of subjects to be included in the individual plots (defaults to all subjects)
</p>
</li>
<li><p> indiv.par  a string, giving the type of the individual estimates (&quot;map&quot;= conditional mode, &quot;eap&quot;=conditional mean). Defaults to conditional mode
</p>
</li>
<li><p> lcol Main line color (default: black)
</p>
</li>
<li><p> line.smooth Type of smoothing when a smoothed line is used in the plot (&quot;m&quot;: mean value, &quot;l&quot;: linear regression; &quot;s&quot;: natural splines). Several options may be combined, for instance &quot;ls&quot; will add both a linear regression line and a line representing the fit of a natural spline. Defaults to &quot;s&quot;
</p>
</li>
<li><p> lty Line type. Defaults to 1, corresponding to a straight line
</p>
</li>
<li><p> lty.lmed For the VPC plots: type of the line showing the median of the simulated data. Defaults to 2 (dashed)
</p>
</li>
<li><p> lty.obs For the VPC plots: type of the line showing the observed data. Defaults to 1
</p>
</li>
<li><p> lty.lpi For the VPC plots: type of the line showing the boundaries of the simulated data. Defaults to 2 (dashed)
</p>
</li>
<li><p> lwd Line width (default: 1)
</p>
</li>
<li><p> lwd.lmed For the VPC plots: thickness of the line showing the median of the simulated data. Defaults to 2
</p>
</li>
<li><p> lwd.obs For the VPC plots: thickness of the line showing the median and boundaries of the observed data. Defaults to 2
</p>
</li>
<li><p> lwd.lpi For the VPC plots: thickness of the line showing the boundaries of the simulated data. Defaults to 1
</p>
</li>
<li><p> par.name Name of the parameter to be used in the plots. Defaults to the first parameter in the model
</p>
</li>
<li><p> pch Symbol type. Defaults to 20, corresponding to small dots
</p>
</li>
<li><p> pcol Main symbol color (default: black)
</p>
</li>
<li><p> range Range (expressed in number of SD) over which to plot the marginal distribution. Defaults to 4, so that the random effects for the marginal distribution is taken over the range [-4 SD; 4 SD]
</p>
</li>
<li><p> res.plot Type of residual plot (&quot;res.vs.x&quot;: scatterplot versus X, &quot;res.vs.pred&quot;: scatterplot versus predictions, &quot;hist&quot;: histogram, &quot;qqplot&quot;: QQ-plot) (default: &quot;res.vs.x&quot;)
</p>
</li>
<li><p> smooth When TRUE, smoothed lines are added in the plots of predictions versus observations (default: FALSE)
</p>
</li>
<li><p> tit Title of the graph (default: none)
</p>
</li>
<li><p> type Type of the plot (as in the <em>R</em> plot function. Defaults to &quot;b&quot;, so that both lines and symbols are shown
</p>
</li>
<li><p> units Name of the predictor used in the plots (X). Defaults to the name of the first predictor in the model (saemix.data$names$predictors[1])
</p>
</li>
<li><p> vpc.bin Number of binning intervals when plotting the VPC (the (vpc.bin-1) breakpoints are taken as the empirical quantiles of the X data). Defaults to 10
</p>
</li>
<li><p> vpc.interval Size of the prediction intervals.Defaults to 0.95 for the 95\
</p>
</li>
<li><p> vpc.obs Should the observations be overlayed on the VPC plot. Defaults to TRUE
</p>
</li>
<li><p> vpc.pi Should prediction bands be computed around the median and the bounds of the prediction intervals for the VPC. Defaults to TRUE
</p>
</li>
<li><p> xlab Label for the X-axis. Defaults to the name of the X predictor followed by the unit in bracket (eg &quot;Time (hr)&quot;)
</p>
</li>
<li><p> xlim Range for the X-axis. Defaults to NA, indicating that the range is to be set by the plot function
</p>
</li>
<li><p> xlog A logical value. If TRUE, a logarithmic scale is in use. Defaults to FALSE
</p>
</li>
<li><p> xname Name of the predictor used in the plots (X)
</p>
</li>
<li><p> ylab Label for the Y-axis. Defaults to the name of the response followed by the unit in bracket (eg &quot;Concentration (mg/L)&quot; (Default: none)
</p>
</li>
<li><p> ylim Range for the Y-axis. Defaults to NA, indicating that the range is to be set by the plot function
</p>
</li>
<li><p> ylog A logical value. If TRUE, a logarithmic scale is in use. Defaults to FALSE
</p>
</li></ul>

<p>Plotting a SaemixData object also allows the following options:
</p>

<dl>
<dt>individual</dt><dd><p> if TRUE, plots separate plots for each individual, otherwise plots a spaghetti plot of all the data. Defaults to FALSE</p>
</dd>
<dt>limit</dt><dd><p> for individual plots, plots only a limited number of subjets (nmax). Defaults to TRUE</p>
</dd>
<dt>nmax</dt><dd><p> for individual plots, when limit is TRUE, the maximum number of plots to produce. Defaults to 12</p>
</dd>
<dt>sample</dt><dd><p> for individual plots, if TRUE, randomly samples nmax different subjects to plot. Defaults to FALSE (the first nmax subjects are used in the plots)</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>saemix.plot.setoptions(saemixObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix.plot.setoptions_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to create a list containing the default options
and arguments used by the plot functions.
</p>
<p>A more detailed description of the options set via these lists is provided
in the PDF documentation. The &quot;replace&quot; functions are helper functions used
within the plot functions. saemix.plot.setoptions has more available options
than saemix.data.setoptions since it applies to all possible plots while the
latter only applies to data.
</p>


<h3>Value</h3>

<p>A list containing the options set at their default value. This list
can be stored in an object and its elements modified to provide suitable graphs.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu, Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.data">saemix.plot.data</a></code>, <code><a href="#topic+saemix.plot.convergence">saemix.plot.convergence</a></code>,
<code><a href="#topic+saemix.plot.llis">saemix.plot.llis</a></code>, <code><a href="#topic+saemix.plot.randeff">saemix.plot.randeff</a></code>,
<code><a href="#topic+saemix.plot.obsvspred">saemix.plot.obsvspred</a></code>, <code><a href="#topic+saemix.plot.fits">saemix.plot.fits</a></code>,
<code><a href="#topic+saemix.plot.parcov">saemix.plot.parcov</a></code>, <code><a href="#topic+saemix.plot.distpsi">saemix.plot.distpsi</a></code>,
<code><a href="#topic+saemix.plot.scatterresiduals">saemix.plot.scatterresiduals</a></code>, <code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>,
<code><a href="#topic+saemix.plot.mirror">saemix.plot.mirror</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Theophylline example, after a call to fit.saemix (see examples)
# Not run
# sopt&lt;-saemix.plot.setoptions(saemix.fit)
# sopt$ask&lt;-TRUE

</code></pre>

<hr>
<h2 id='saemix.predict'>Compute model predictions after an saemix fit</h2><span id='topic+saemix.predict'></span>

<h3>Description</h3>

<p>In nonlinear mixed effect models, different types of predictions may be obtained, including individual predictions and population predictions.
This function takes an SaemixObject and adds any missing predictions for maximum a posteriori and conditional mean estimations of the individual
parameters, and for the different types of individual and population predictions for the response variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemix.predict(object, type = c("ipred", "ypred", "ppred", "icpred"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemix.predict_+3A_object">object</code></td>
<td>
<p>an SaemixObject object</p>
</td></tr>
<tr><td><code id="saemix.predict_+3A_type">type</code></td>
<td>
<p>the type of predictions (ipred= individual, ppred=population predictions obtained with the population estimates,
ypred=mean of the population predictions, icpred=conditional predictions).
By default, computes all the predictions and residuals, along with the corresponding parameter estimates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by saemix to automatically compute a number of elements needed for diagnostic plots.
It is normally executed directly during a call to saemix() but can be called to add residuals
</p>


<h3>Value</h3>

<p>an updated SaemixObject object
</p>

<hr>
<h2 id='saemixControl'>List of options for running the algorithm SAEM</h2><span id='topic+saemixControl'></span>

<h3>Description</h3>

<p>List containing the variables relative to the optimisation algorithm. All
these elements are optional and will be set to default values when running
the algorithm if they are not specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemixControl(
  map = TRUE,
  fim = TRUE,
  ll.is = TRUE,
  ll.gq = FALSE,
  nbiter.saemix = c(300, 100),
  nbiter.sa = NA,
  nb.chains = 1,
  fix.seed = TRUE,
  seed = 23456,
  nmc.is = 5000,
  nu.is = 4,
  print.is = FALSE,
  nbdisplay = 100,
  displayProgress = FALSE,
  nbiter.burn = 5,
  nbiter.map = 5,
  nbiter.mcmc = c(2, 2, 2, 0),
  proba.mcmc = 0.4,
  stepsize.rw = 0.4,
  rw.init = 0.5,
  alpha.sa = 0.97,
  nnodes.gq = 12,
  nsd.gq = 4,
  maxim.maxiter = 100,
  nb.sim = 1000,
  nb.simpred = 100,
  ipar.lmcmc = 50,
  ipar.rmcmc = 0.05,
  print = TRUE,
  save = TRUE,
  save.graphs = TRUE,
  directory = "newdir",
  warnings = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemixControl_+3A_map">map</code></td>
<td>
<p>a boolean specifying whether to estimate the individual parameters (MAP estimates). Defaults to TRUE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_fim">fim</code></td>
<td>
<p>a boolean specifying whether to estimate the Fisher Information Matrix and derive the estimation errors
for the parameters. Defaults to TRUE. The linearised approximation to the log-likelihood is also computed in the process</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_ll.is">ll.is</code></td>
<td>
<p>a boolean specifying whether to estimate the log-likelihood by importance sampling. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_ll.gq">ll.gq</code></td>
<td>
<p>a boolean specifying whether to estimate the log-likelihood by Gaussian quadrature. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbiter.saemix">nbiter.saemix</code></td>
<td>
<p>nb of iterations in each step (a vector containing 2
elements, nbiter.saemix[1] for the exploration phase of the algorithm (K1) and nbiter.saemix[2]
for the smoothing phase (K2))</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbiter.sa">nbiter.sa</code></td>
<td>
<p>nb of iterations subject to simulated annealing (defaults to nbiter.saemix[1]/2,
will be cut down to K1=nbiter.saemix[1] if greater than that value). We recommend to stop
simulated annealing before the end of the exploration phase (nbiter.saemix[1]).</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nb.chains">nb.chains</code></td>
<td>
<p>nb of chains to be run in parallel in the MCMC algorithm
(defaults to 1)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_fix.seed">fix.seed</code></td>
<td>
<p>TRUE (default) to use a fixed seed for the random number
generator. When FALSE, the random number generator is initialised using a
new seed, created from the current time.  Hence, different sessions started
at (sufficiently) different times will give different simulation results.
The seed is stored in the element seed of the options list.</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator. Defaults to 123456</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nmc.is">nmc.is</code></td>
<td>
<p>nb of samples used when computing the likelihood through
importance sampling</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nu.is">nu.is</code></td>
<td>
<p>number of degrees of freedom of the Student distribution used
for the estimation of the log-likelihood by Importance Sampling. Defaults to
4</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_print.is">print.is</code></td>
<td>
<p>when TRUE, a plot of the likelihood as a function of the
number of MCMC samples when computing the likelihood through importance
sampling is produced and updated every 500 samples. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbdisplay">nbdisplay</code></td>
<td>
<p>nb of iterations after which to display progress</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_displayprogress">displayProgress</code></td>
<td>
<p>when TRUE, the convergence plots are plotted after
every nbdisplay iteration, and a dot is written in the terminal window to
indicate progress. When FALSE, plots are not shown and the algorithm runs
silently. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbiter.burn">nbiter.burn</code></td>
<td>
<p>nb of iterations for burning</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbiter.map">nbiter.map</code></td>
<td>
<p>nb of iterations of the MAP kernel (4th kernel) to run at the beginning
of the estimation process (defaults to nbiter.saemix[1]/10 if nbiter.mcmc[4] is more than 0)
(EXPERIMENTAL, see Karimi et al. 2019 for details)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nbiter.mcmc">nbiter.mcmc</code></td>
<td>
<p>nb of iterations in each kernel during the MCMC step</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_proba.mcmc">proba.mcmc</code></td>
<td>
<p>probability of acceptance</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_stepsize.rw">stepsize.rw</code></td>
<td>
<p>stepsize for kernels q2 and q3 (defaults to 0.4)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_rw.init">rw.init</code></td>
<td>
<p>initial variance parameters for kernels (defaults to 0.5)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_alpha.sa">alpha.sa</code></td>
<td>
<p>parameter controlling cooling in the Simulated Annealing
algorithm (defaults to 0.97)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nnodes.gq">nnodes.gq</code></td>
<td>
<p>number of nodes to use for the Gaussian quadrature when
computing the likelihood with this method (defaults to 12)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nsd.gq">nsd.gq</code></td>
<td>
<p>span (in SD) over which to integrate when computing the
likelihood by Gaussian quadrature. Defaults to 4 (eg 4 times the SD)</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_maxim.maxiter">maxim.maxiter</code></td>
<td>
<p>Maximum number of iterations to use when maximising the
fixed effects in the algorithm. Defaults to 100</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nb.sim">nb.sim</code></td>
<td>
<p>number of simulations to perform to produce the VPC plots or
compute npde. Defaults to 1000</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_nb.simpred">nb.simpred</code></td>
<td>
<p>number of simulations used to compute mean predictions
(ypred element), taken as a random sample within the nb.sim simulations used
for npde</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_ipar.lmcmc">ipar.lmcmc</code></td>
<td>
<p>number of iterations required to assume convergence for
the conditional estimates. Defaults to 50</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_ipar.rmcmc">ipar.rmcmc</code></td>
<td>
<p>confidence interval for the conditional mean and variance.
Defaults to 0.95</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_print">print</code></td>
<td>
<p>whether the results of the fit should be printed out. Defaults
to TRUE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_save">save</code></td>
<td>
<p>whether the results of the fit should be saved to a file.
Defaults to TRUE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_save.graphs">save.graphs</code></td>
<td>
<p>whether diagnostic graphs and individual graphs should be
saved to files. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_directory">directory</code></td>
<td>
<p>the directory in which to save the results. Defaults to
&quot;newdir&quot; in the current directory</p>
</td></tr>
<tr><td><code id="saemixControl_+3A_warnings">warnings</code></td>
<td>
<p>whether warnings should be output during the fit. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the variables are optional and will be set to their default value when
running <code><a href="#topic+saemix">saemix</a></code>.
</p>
<p>The function <code><a href="#topic+saemix">saemix</a></code> returns an object with an element options
containing the options used for the algorithm, with defaults set for
elements which have not been specified by the user.
</p>
<p>These elements are used in subsequent functions and are not meant to be used
directly.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>
<p>B Karimi, M Lavielle , E Moulines E  (2019). f-SAEM: A fast Stochastic Approximation of the EM algorithm for nonlinear mixed effects models.
Computational Statistics &amp; Data Analysis, 141:123-38
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>,
<code><a href="#topic+SaemixObject">SaemixObject</a></code>, <code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# All default options
saemix.options&lt;-saemixControl()

# All default options, changing seed
saemix.options&lt;-saemixControl(seed=632545)

</code></pre>

<hr>
<h2 id='saemixData'>Function to create an SaemixData object</h2><span id='topic+saemixData'></span>

<h3>Description</h3>

<p>This function creates an SaemixData object. The only mandatory argument is
the name of the dataset. If the dataset has a header (or named columns), the
program will attempt to detect which column correspond to ID, predictor(s)
and response. Warning messages will be printed during the object creation
and should be read for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemixData(
  name.data,
  header,
  sep,
  na,
  name.group,
  name.predictors,
  name.response,
  name.X,
  name.covariates = c(),
  name.genetic.covariates = c(),
  name.mdv = "",
  name.cens = "",
  name.occ = "",
  name.ytype = "",
  units = list(x = "", y = "", covariates = c()),
  verbose = TRUE,
  automatic = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemixData_+3A_name.data">name.data</code></td>
<td>
<p>name of the dataset (can be a character string giving the name of a file on disk or of a dataset in the R session, or the name of a dataset</p>
</td></tr>
<tr><td><code id="saemixData_+3A_header">header</code></td>
<td>
<p>whether the dataset/file contains a header. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="saemixData_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Defaults to any number of blank spaces (&quot;&quot;)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_na">na</code></td>
<td>
<p>a character vector of the strings which are to be interpreted as NA values. Defaults to c(NA)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.group">name.group</code></td>
<td>
<p>name (or number) of the column containing the subject id</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.predictors">name.predictors</code></td>
<td>
<p>name (or number) of the column(s) containing the predictors (the algorithm requires at least one predictor x)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.response">name.response</code></td>
<td>
<p>name (or number) of the column containing the response variable y modelled by predictor(s) x</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.x">name.X</code></td>
<td>
<p>name of the column containing the regression variable to be used on the X axis in the plots (defaults to the first predictor)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.covariates">name.covariates</code></td>
<td>
<p>name (or number) of the column(s) containing the covariates, if present (otherwise missing)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.genetic.covariates">name.genetic.covariates</code></td>
<td>
<p>name (or number) of the column(s) containing the covariates, if present (otherwise missing)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.mdv">name.mdv</code></td>
<td>
<p>name of the column containing the indicator for missing variable</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.cens">name.cens</code></td>
<td>
<p>name of the column containing the indicator for censoring</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.occ">name.occ</code></td>
<td>
<p>name of the column containing the occasion</p>
</td></tr>
<tr><td><code id="saemixData_+3A_name.ytype">name.ytype</code></td>
<td>
<p>name of the column containing the index of the response</p>
</td></tr>
<tr><td><code id="saemixData_+3A_units">units</code></td>
<td>
<p>list with up to three elements, x, y and optionally covariates, containing the units for the X and Y variables respectively, as well as the units for the different covariates (defaults to empty)</p>
</td></tr>
<tr><td><code id="saemixData_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating whether messages should be printed out during the creation of the object</p>
</td></tr>
<tr><td><code id="saemixData_+3A_automatic">automatic</code></td>
<td>
<p>a boolean indicating whether to attempt automatic name recognition when some colum names are missing or wrong (defaults to TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the user-friendly constructor for the SaemixData object
class. The read.saemixData is a helper function, used to read the dataset,
and is not intended to be called directly.
</p>
<p>This function is the user-friendly constructor for the SaemixData object class. The read is a helper function, used to read the dataset, and is not intended to be called directly.
</p>


<h3>Value</h3>

<p>An SaemixData object (see <code><a href="#topic+saemixData">saemixData</a></code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu, Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>, <code><a href="#topic+saemixControl">saemixControl</a></code>,<code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

print(saemix.data)

plot(saemix.data)
</code></pre>

<hr>
<h2 id='SaemixData-class'>Class &quot;SaemixData&quot;</h2><span id='topic+SaemixData-class'></span><span id='topic+SaemixData'></span><span id='topic+print+2CSaemixData'></span><span id='topic+showall+2CSaemixData'></span><span id='topic+show+2CSaemixData'></span><span id='topic+SaemixRepData-class'></span><span id='topic+SaemixRepData'></span><span id='topic+SaemixSimData-class'></span><span id='topic+SaemixSimData'></span>

<h3>Description</h3>

<p>An object of the SaemixData class, representing a longitudinal data structure, used by the SAEM algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name.data</code></dt><dd><p>Object of class <code>"character"</code>: name of the dataset</p>
</dd>
<dt><code>header</code></dt><dd><p>Object of class <code>"logical"</code>: whether the dataset/file contains a header. Defaults to TRUE</p>
</dd>
<dt><code>sep</code></dt><dd><p>Object of class <code>"character"</code>: the field separator character</p>
</dd>
<dt><code>na</code></dt><dd><p>Object of class <code>"character"</code>: a character vector of the strings which are to be interpreted as NA values</p>
</dd>
<dt><code>messages</code></dt><dd><p>Object of class <code>"logical"</code>: if TRUE, the program will display information about the creation of the data object</p>
</dd>
<dt><code>automatic</code></dt><dd><p>Object of class <code>"logical"</code>: if TRUE, automatic name recognition is on (used at the creation of the object)</p>
</dd>
<dt><code>name.group</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the subject id</p>
</dd>
<dt><code>name.predictors</code></dt><dd><p>Object of class <code>"character"</code>: name of the column(s) containing the predictors</p>
</dd>
<dt><code>name.response</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the response variable y modelled by predictor(s) x</p>
</dd>
<dt><code>name.covariates</code></dt><dd><p>Object of class <code>"character"</code>: name of the column(s) containing the covariates, if present (otherwise empty)</p>
</dd>
<dt><code>name.X</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the regression variable to be used on the X axis in the plots</p>
</dd>
<dt><code>name.mdv</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the indicator variable denoting missing data</p>
</dd>
<dt><code>name.cens</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the indicator variable denoting censored data (the value in the name.response column will be taken as the censoring value)</p>
</dd>
<dt><code>name.occ</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the value of the occasion</p>
</dd>
<dt><code>name.ytype</code></dt><dd><p>Object of class <code>"character"</code>: name of the column containing the response number</p>
</dd>
<dt><code>trans.cov</code></dt><dd><p>Object of class <code>"list"</code>: the list of transformation applied to the covariates (currently unused, TODO)</p>
</dd>
<dt><code>units</code></dt><dd><p>Object of class <code>"list"</code>: list with up to three elements, x, y and optionally covariates, containing the units for the X and Y variables respectively, as well as the units for the different covariates</p>
</dd>
<dt><code>data</code></dt><dd><p>Object of class <code>"data.frame"</code>: dataframe containing the data, with columns for id (name.group), predictors (name.predictors), response (name.response), and covariates if present in the dataset (name.covariates). A column &quot;index&quot; contains the subject index (used to map the subject id). The column names, except for the additional column index, correspond to the names in the original dataset.</p>
</dd>
<dt><code>N</code></dt><dd><p>Object of class <code>"numeric"</code>: number of subjects</p>
</dd>
<dt><code>yorig</code></dt><dd><p>Object of class <code>"numeric"</code>: response data, on the original scale. Used when the error model is exponential</p>
</dd>
<dt><code>ocov</code></dt><dd><p>Object of class <code>"data.frame"</code>: original covariate data (before transformation in the algorithm)</p>
</dd>
<dt><code>ind.gen</code></dt><dd><p>Object of class <code>"logical"</code>: indicator for genetic covariates (internal)</p>
</dd>
<dt><code>ntot.obs</code></dt><dd><p>Object of class <code>"numeric"</code>: total number of observations</p>
</dd>
<dt><code>nind.obs</code></dt><dd><p>Object of class <code>"numeric"</code>: vector containing the number of observations for each subject</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>An object of the SaemixData class can be created by using the function <code><a href="#topic+saemixData">saemixData</a></code> and contain the following slots:
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "SaemixData")</code>: replace elements of object</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SaemixData")</code>: access elements of object</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SaemixData")</code>: internal function to initialise object, not to be used</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SaemixData")</code>: plot the data</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "SaemixData")</code>: prints details about the object (more extensive than show)</p>
</dd>
<dt>read</dt><dd><p><code>signature(object = "SaemixData")</code>: internal function, not to be used </p>
</dd>
<dt>showall</dt><dd><p><code>signature(object = "SaemixData")</code>: shows all the elements in the object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SaemixData")</code>: prints details about the object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SaemixData")</code>: summary of the data. Returns a list with a number of elements extracted from the dataset (N: the number of subjects; nobs: the total number of observations; nind.obs: a vector giving the number of observations for each subject; id: subject ID; x: predictors; y: response, and, if present in the data, covariates: the covariates (as many lines as observations) and ind.covariates: the individual covariates (one line per individual).</p>
</dd>
<dt>subset</dt><dd><p><code>signature(object = "SaemixData")</code>: extract part of the data; this function will operate on the rows of the dataset (it can be used for instance to extract the data corresponding to the first ten subjects)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemixData">saemixData</a></code> <code><a href="#topic+SaemixModel">SaemixModel</a></code> <code><a href="#topic+saemixControl">saemixControl</a></code> <code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SaemixData")

# Specifying column names
data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

# Specifying column numbers
data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
  name.group=1,name.predictors=c(2,3),name.response=c(4), name.covariates=5:6, 
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

# No column names specified, using automatic recognition of column names
data(PD1.saemix)
saemix.data&lt;-saemixData(name.data=PD1.saemix,header=TRUE, 
  name.covariates=c("gender"),units=list(x="mg",y="-",covariates=c("-")))

</code></pre>

<hr>
<h2 id='saemixModel'>Function to create an SaemixModel object</h2><span id='topic+saemixModel'></span>

<h3>Description</h3>

<p>This function creates an SaemixModel object. The two mandatory arguments are
the name of a R function computing the model in the SAEMIX format (see
details and examples) and a matrix psi0 giving the initial estimates of the
fixed parameters in the model, with one row for the population mean
parameters and one row for the covariate effects (see documentation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemixModel(
  model,
  psi0,
  description = "",
  modeltype = "structural",
  name.response = "",
  name.sigma = character(),
  error.model = character(),
  transform.par = numeric(),
  fixed.estim = numeric(),
  covariate.model = matrix(nrow = 0, ncol = 0),
  covariance.model = matrix(nrow = 0, ncol = 0),
  omega.init = matrix(nrow = 0, ncol = 0),
  error.init = numeric(),
  name.modpar = character(),
  simulate.function = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemixModel_+3A_model">model</code></td>
<td>
<p>name of the function used to compute the structural model. The
function should return a vector of predicted values given a matrix of
individual parameters, a vector of indices specifying which records belong
to a given individual, and a matrix of dependent variables (see example
below).</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_psi0">psi0</code></td>
<td>
<p>a matrix with a number of columns equal to the number of
parameters in the model, and one (when no covariates are available) or two
(when covariates enter the model) giving the initial estimates for the fixed
effects. The column names of the matrix should be the names of the
parameters in the model, and will be used in the plots and the summaries.
When only the estimates of the mean parameters are given, psi0 may be a
named vector.</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_description">description</code></td>
<td>
<p>a character string, giving a brief description of the
model or the analysis</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_modeltype">modeltype</code></td>
<td>
<p>a character string, giving model type (structural or likelihood)</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_name.response">name.response</code></td>
<td>
<p>the name of the dependent variable</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_name.sigma">name.sigma</code></td>
<td>
<p>a vector of character string giving the names of the residual error parameters</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_error.model">error.model</code></td>
<td>
<p>type of residual error model (valid types are constant,
proportional, combined and exponential). Defaults to constant</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_transform.par">transform.par</code></td>
<td>
<p>the distribution for each parameter (0=normal,
1=log-normal, 2=probit, 3=logit). Defaults to a vector of 1s (all parameters
have a log-normal distribution)</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_fixed.estim">fixed.estim</code></td>
<td>
<p>whether parameters should be estimated (1) or fixed to
their initial estimate (0). Defaults to a vector of 1s</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_covariate.model">covariate.model</code></td>
<td>
<p>a matrix giving the covariate model. Defaults to no
covariate in the model</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_covariance.model">covariance.model</code></td>
<td>
<p>a square matrix of size equal to the number of
parameters in the model, giving the variance-covariance matrix of the model:
1s correspond to estimated variances (in the diagonal) or covariances
(off-diagonal elements). Defaults to the identity matrix</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_omega.init">omega.init</code></td>
<td>
<p>a square matrix of size equal to the number of parameters
in the model, giving the initial estimate for the variance-covariance matrix
of the model.</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_error.init">error.init</code></td>
<td>
<p>a vector of size 2 giving the initial value of a and b in
the error model. Defaults to 1 for each estimated parameter in the error
model</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_name.modpar">name.modpar</code></td>
<td>
<p>names of the model parameters, if they are not given as
the column names (or names) of psi0</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_simulate.function">simulate.function</code></td>
<td>
<p>for non-Gaussian data models, defined as modeltype='likelihood',
the name of the function used to simulate from the structural model. The
function should have the same header as the model function, and should return
a vector of simulated values given a matrix of individual parameters,
a vector of indices specifying which records belong to a given individual,
and a matrix of dependent variables (see example in the documentation, section
discrete data examples)</p>
</td></tr>
<tr><td><code id="saemixModel_+3A_verbose">verbose</code></td>
<td>
<p>a boolean, controlling whether information about the created should be printed out. Defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the user-friendly constructor for the SaemixModel object
class.
</p>


<h3>Value</h3>

<p>An SaemixModel object (see <code><a href="#topic+saemixModel">saemixModel</a></code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>,
<code><a href="#topic+saemixControl">saemixControl</a></code>,<code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")

</code></pre>

<hr>
<h2 id='SaemixModel-class'>Class &quot;SaemixModel&quot;</h2><span id='topic+SaemixModel-class'></span><span id='topic+SaemixModel'></span><span id='topic++5B+3C-+2CSaemixModel-method'></span><span id='topic+print+2CSaemixModel'></span><span id='topic+showall+2CSaemixModel'></span><span id='topic+show+2CSaemixModel'></span><span id='topic+summary+2CSaemixModel'></span>

<h3>Description</h3>

<p>An object of the SaemixModel class, representing a nonlinear mixed-effect
model structure, used by the SAEM algorithm.
</p>


<h3>Objects from the Class</h3>

<p>An object of the SaemixModel class can be created by using the function <code><a href="#topic+saemixModel">saemixModel</a></code> and contain the following slots:
</p>

<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"function"</code>: name of the function used to get predictions from the model (see the User Guide and the online examples for the format and what this function should return).</p>
</dd>
<dt><code>description</code>:</dt><dd><p>Object of class <code>"character"</code>: an optional text description of the model</p>
</dd>
<dt><code>psi0</code>:</dt><dd><p>Object of class <code>"matrix"</code>: a matrix with named columns containing the initial estimates for the parameters in the model (first line) and for the covariate effects (second and subsequent lines, optional). The number of columns should be equal to the number of parameters in the model.</p>
</dd>
<dt><code>simulate.function</code>:</dt><dd><p>Object of class <code>"function"</code>: for non-Gaussian data models, name of the function used to simulate from the model.</p>
</dd>
<dt><code>transform.par</code>:</dt><dd><p>Object of class <code>"numeric"</code>: vector giving the distribution for each model parameter (0: normal, 1: log-normal, 2: logit, 3: probit). Its length should be equal to the number of parameters in the model.</p>
</dd>
<dt><code>fixed.estim</code>:</dt><dd><p>Object of class <code>"numeric"</code>: for each parameter, 0 if the parameter is fixed and 1 if it should be estimated. Defaults to a vector of 1 (all parameters are estimated). Its length should be equal to the number of parameters in the model.</p>
</dd>
<dt><code>error.model</code>:</dt><dd><p>Object of class <code>"character"</code>: name of the error model. Valid choices are &quot;constant&quot; (default), &quot;proportional&quot; and &quot;combined&quot; (see equations in User Guide, except for combined which was changed to y = f + sqrt(a^2+b^2*f^2)*e )</p>
</dd>
<dt><code>covariate.model</code>:</dt><dd><p>Object of class <code>"matrix"</code>: a matrix of 0's and 1's, with a 1 indicating that a parameter-covariate relationship is included in the model (and an associated fixed effect will be estimated). The nmuber of columns should be equal to the number of parameters in the model and the number of rows to the number of covariates.</p>
</dd>
<dt><code>covariance.model</code>:</dt><dd><p>Object of class <code>"matrix"</code>: a matrix f 0's and 1's giving the structure of the variance-covariance matrix. Defaults to the Identity matrix (diagonal IIV, no correlations between parameters)</p>
</dd>
<dt><code>omega.init</code>:</dt><dd><p>Object of class <code>"matrix"</code>: a matrix giving the initial estimate for the variance-covariance matrix</p>
</dd>
<dt><code>error.init</code>:</dt><dd><p>Object of class <code>"numeric"</code>: a vector giving the initial estimate for the parameters of the residual error</p>
</dd>
</dl>

<p>Additional elements are added to the model object after a call to <code>saemix</code> and are used in the algorithm.
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "SaemixModel")</code>: replace elements of object</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SaemixModel")</code>: access elements of object</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SaemixModel")</code>: internal function to initialise object, not to be used</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SaemixModel")</code>: plot predictions from the model</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "SaemixModel")</code>: prints details about the object (more extensive than show)</p>
</dd>
<dt>showall</dt><dd><p><code>signature(object = "SaemixModel")</code>: shows all the elements in the object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SaemixModel")</code>: prints details about the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code> <code><a href="#topic+SaemixObject">SaemixObject</a></code> <code><a href="#topic+saemixControl">saemixControl</a></code> <code><a href="#topic+saemix">saemix</a></code>
<code><a href="#topic+plot.saemix">plot.saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("SaemixModel")

# Model function for continuous data 
## structural model: a one-compartment model with oral absorption
model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}

# Corresponding SaemixModel, assuming starting parameters ka=1, V=20, CL=0.5
# and log-normal distributions for the parameters
model1 &lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1,20,0.5),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))

# Model function for discrete data
## logistic regression for the probability of the observed outcome
binary.model&lt;-function(psi,id,xidep) {
  tim&lt;-xidep[,1]
  y&lt;-xidep[,2]
  inter&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  logit&lt;-inter+slope*tim
  pevent&lt;-exp(logit)/(1+exp(logit))
  pobs = (y==0)*(1-pevent)+(y==1)*pevent
  logpdf &lt;- log(pobs)
  return(logpdf)
}

## Corresponding SaemixModel, assuming starting parameters inter=-5, slope=-1
# and normal distributions for both parameters
# note that the modeltype argument is set to likelihood
saemix.model&lt;-saemixModel(model=binary.model,description="Binary model",
     modeltype="likelihood",
     psi0=matrix(c(-5,-.1,0,0),ncol=2,byrow=TRUE,dimnames=list(NULL,c("inter","slope"))),
     transform.par=c(0,0))
     
## saemix cannot infer the distribution of the outcome directly from the model
## Here we therefore define a simulation function, needed for diagnostics
### Note the similarity and differences with the model function
simulBinary&lt;-function(psi,id,xidep) {
    tim&lt;-xidep[,1]
    y&lt;-xidep[,2]
    inter&lt;-psi[id,1]
    slope&lt;-psi[id,2]
    logit&lt;-inter+slope*tim
    pevent&lt;-1/(1+exp(-logit))
    ysim&lt;-rbinom(length(tim),size=1, prob=pevent)
    return(ysim)
    }

saemix.model&lt;-saemixModel(model=binary.model,description="Binary model",
     modeltype="likelihood", simulate.function=simulBinary,
     psi0=matrix(c(-5,-.1,0,0),ncol=2,byrow=TRUE,dimnames=list(NULL,c("inter","slope"))),
     transform.par=c(0,0))
</code></pre>

<hr>
<h2 id='SaemixObject-class'>Class &quot;SaemixObject&quot;</h2><span id='topic+SaemixObject-class'></span><span id='topic+SaemixObject'></span><span id='topic++5B+3C-+2CSaemixObject-method'></span><span id='topic+print+2CSaemixObject'></span><span id='topic+predict+2CSaemixObject'></span><span id='topic+showall+2CSaemixObject'></span><span id='topic+show+2CSaemixObject'></span><span id='topic+summary+2CSaemixObject'></span>

<h3>Description</h3>

<p>An object of the SaemixObject class, storing the input to saemix, and the results obtained by a call
to the SAEM algorithm
</p>


<h3>Details</h3>

<p>Details of the algorithm can be found in the pdf file accompanying the package.
</p>


<h3>Objects from the Class</h3>

<p>An object of the SaemixObject class is created after a call to <code><a href="#topic+saemix">saemix</a></code> and contain the following slots:
</p>

<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"SaemixData"</code>: saemix dataset, created by a call to <code>saemixData</code></p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"SaemixModel"</code>: saemix model, created by a call to <code>saemixModel</code></p>
</dd>
<dt><code>results</code>:</dt><dd><p>Object of class <code>"SaemixData"</code>: saemix dataset, created by a call to <code>saemixData</code></p>
</dd>
<dt><code>rep.data</code>:</dt><dd><p>Object of class <code>"SaemixRepData"</code>: (internal) replicated saemix dataset, used the execution of the algorithm</p>
</dd>
<dt><code>sim.data</code>:</dt><dd><p>Object of class <code>"SaemixSimData"</code>: simulated saemix dataset</p>
</dd>
<dt><code>options</code>:</dt><dd><p>Object of class <code>"list"</code>: list of settings for the algorithm</p>
</dd>
<dt><code>prefs</code>:</dt><dd><p>Object of class <code>"list"</code>: list of graphical options for the graphs</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "SaemixObject")</code>: replace elements of object</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SaemixObject")</code>: access elements of object</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SaemixObject")</code>: internal function to initialise object, not to be used</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SaemixObject")</code>: plot the data</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "SaemixObject")</code>: prints details about the object (more extensive than show)</p>
</dd>
<dt>showall</dt><dd><p><code>signature(object = "SaemixObject")</code>: shows all the elements in the object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SaemixObject")</code>: prints details about the object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SaemixObject")</code>: summary of the object. Returns a list with a number of elements extracted from the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code> <code><a href="#topic+SaemixModel">SaemixModel</a></code> <code><a href="#topic+saemixControl">saemixControl</a></code> <code><a href="#topic+saemix">saemix</a></code>
<code><a href="#topic+plot.saemix">plot.saemix</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("SaemixObject")

</code></pre>

<hr>
<h2 id='saemixPredictNewdata'>Predictions for a new dataset</h2><span id='topic+saemixPredictNewdata'></span><span id='topic+estimateMeanParametersNewdata'></span><span id='topic+estimateIndividualParametersNewdata'></span>

<h3>Description</h3>

<p>Predictions for a new dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saemixPredictNewdata(
  saemixObject,
  newdata,
  type = c("ipred", "ypred", "ppred", "icpred"),
  nsamp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saemixPredictNewdata_+3A_saemixobject">saemixObject</code></td>
<td>
<p>an SaemixObject from a fitted run</p>
</td></tr>
<tr><td><code id="saemixPredictNewdata_+3A_newdata">newdata</code></td>
<td>
<p>a dataframe containing the new data. The dataframe must contain the same information as the original dataset (column names, etc...)</p>
</td></tr>
<tr><td><code id="saemixPredictNewdata_+3A_type">type</code></td>
<td>
<p>one or several of &quot;ipred&quot; (individual predictions using the MAP estimates), &quot;ppred&quot; (population predictions obtained using the population parameters f(E(theta))), &quot;ypred&quot; (mean of the population predictions (E(f(theta)))), &quot;icpred&quot;  (individual predictions using the conditional mean estimates). Defaults to &quot;ppred&quot;.</p>
</td></tr>
<tr><td><code id="saemixPredictNewdata_+3A_nsamp">nsamp</code></td>
<td>
<p>an integer, ignored for other types than icpred; if icpred, returns both the mean of the conditional distribution and nsamp samples, with the corresponding predictions. Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the workhorse behind the predict method for SaemixObject. It computes predictions for a new dataframe
based on the results of an saemix fit.
Since the predict function only returns predicted values, this function is provided so that users can access other elements,
for example the different types of parameter estimates (such as individual or population parameters) associated with the predictions
For other purposes such as simply obtaining model predictions, we suggest using the predict() method with or without newdata.
</p>
<p>The function uses estimateMeanParametersNewdata() to set the population estimates for the individual parameters
taking into account the individual covariates and doses, and estimateIndividualParametersNewdata() to derive individual estimates
by computing the mean of the conditional distributions (type=&quot;icpred&quot;) or the MAP estimate (type=&quot;ipred&quot;)
</p>


<h3>Value</h3>

<p>a list with three components (five if type includes &quot;icpred&quot; and nsamp&gt;1)
</p>

<dl>
<dt>param</dt><dd><p>a dataframe with the estimated parameters. The columns in the dataframe depend on which type of predictions were requested (argument type)</p>
</dd>
<dt>predictions</dt><dd><p>a dataframe with the predictions. The columns in the dataframe depend on which type of predictions were requested (argument type)</p>
</dd>
<dt>saemixObject</dt><dd><p>the SaemixObject with the data slot replaced by the new data. The elements of the results slot pertaining to individual (including population individual parameters) predictions and likelihood will have been removed, and only the elements computed within the function will have been replaced (eg individual estimated parameters and predictions for the new data)</p>
</dd>
<dt>parSample</dt><dd><p>a dataframe with parameters sampled from the conditional distribution of the individual parameters (only present if type includes 'icpred' and nsamp&gt;1)</p>
</dd>
<dt>predSample</dt><dd><p>a dataframe with the predictions corresponding to the parameters sampled from the conditional distribution of the individual parameters (only present if type includes 'icpred' and nsamp&gt;1)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='SaemixRes-class'>Class &quot;SaemixRes&quot;</h2><span id='topic+SaemixRes-class'></span><span id='topic+SaemixRes'></span><span id='topic+plot+2CSaemixRes'></span><span id='topic+print+2CSaemixRes'></span><span id='topic+showall+2CSaemixRes'></span><span id='topic+show+2CSaemixRes'></span>

<h3>Description</h3>

<p>An object of the SaemixRes class, representing the results of a fit through the SAEM algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modeltype</code></dt><dd><p>string giving the type of model used for analysis</p>
</dd>
<dt><code>status</code></dt><dd><p>string indicating whether a model has been run successfully; set to &quot;empty&quot; at initialisation, used to pass on error messages or fit status</p>
</dd>
<dt><code>name.fixed</code></dt><dd><p>a vector containing the names of the fixed parameters in the model</p>
</dd>
<dt><code>name.random</code></dt><dd><p>a vector containing the names of the random parameters in the model</p>
</dd>
<dt><code>name.sigma</code></dt><dd><p>a vector containing the names of the parameters of the residual error model</p>
</dd>
<dt><code>npar.est</code></dt><dd><p>the number of parameters estimated (fixed, random and residual)</p>
</dd>
<dt><code>nbeta.random</code></dt><dd><p>the number of estimated fixed effects for the random parameters in the model</p>
</dd>
<dt><code>nbeta.fixed</code></dt><dd><p>the number of estimated fixed effects for the non random parameters in the model</p>
</dd>
<dt><code>fixed.effects</code></dt><dd><p>a vector giving the estimated h(mu) and betas</p>
</dd>
<dt><code>fixed.psi</code></dt><dd><p>a vector giving the estimated h(mu)</p>
</dd>
<dt><code>betas</code></dt><dd><p>a vector giving the estimated mu</p>
</dd>
<dt><code>betaC</code></dt><dd><p>a vector with the estimates of the fixed effects for covariates</p>
</dd>
<dt><code>omega</code></dt><dd><p>the estimated variance-covariance matrix</p>
</dd>
<dt><code>respar</code></dt><dd><p>the estimated parameters of the residual error model</p>
</dd>
<dt><code>fim</code></dt><dd><p>the Fisher information matrix</p>
</dd>
<dt><code>se.fixed</code></dt><dd><p>a vector giving the estimated standard errors of estimation for the fixed effect parameters</p>
</dd>
<dt><code>se.omega</code></dt><dd><p>a vector giving the estimated standard errors of estimation for Omega</p>
</dd>
<dt><code>se.cov</code></dt><dd><p>a matrix giving the estimated SE for each term of the covariance matrix (diagonal elements represent the SE on the variances of the random effects and off-diagonal elements represent the SE on the covariance terms)</p>
</dd>
<dt><code>se.respar</code></dt><dd><p>a vector giving the estimated standard errors of estimation for the parameters of the residual variability</p>
</dd>
<dt><code>conf.int</code></dt><dd><p>a dataframe containing the estimated parameters, their estimation error (SE), coefficient of variation (CV), and the associated confidence intervals; the variabilities for the random effects are presented first as estimated (variances) then converted to standard deviations (SD), and the correlations are computed. For SD and correlations, the SE are estimated via the delta-method</p>
</dd>
<dt><code>parpop</code></dt><dd><p>a matrix tracking the estimates of the population parameters at each iteration</p>
</dd>
<dt><code>allpar</code></dt><dd><p>a matrix tracking the estimates of all the parameters (including covariate effects) at each iteration</p>
</dd>
<dt><code>indx.fix</code></dt><dd><p>the index of the fixed parameters (used in the estimation algorithm)</p>
</dd>
<dt><code>indx.cov</code></dt><dd><p>the index of the covariance parameters (used in the estimation algorithm)</p>
</dd>
<dt><code>indx.omega</code></dt><dd><p>the index of the random effect parameters (used in the estimation algorithm)</p>
</dd>
<dt><code>indx.res</code></dt><dd><p>the index of the residual error model parameters (used in the estimation algorithm)</p>
</dd>
<dt><code>MCOV</code></dt><dd><p>a matrix of covariates (used in the estimation algorithm)</p>
</dd>
<dt><code>cond.mean.phi</code></dt><dd><p>a matrix giving the conditional mean estimates of phi (estimated as the mean of the conditional distribution)</p>
</dd>
<dt><code>cond.mean.psi</code></dt><dd><p>a matrix giving the conditional mean estimates of psi (h(cond.mean.phi))</p>
</dd>
<dt><code>cond.var.phi</code></dt><dd><p>a matrix giving the variance on the conditional mean estimates of phi (estimated as the variance of the conditional distribution)</p>
</dd>
<dt><code>cond.mean.eta</code></dt><dd><p>a matrix giving the conditional mean estimates of the random effect eta</p>
</dd>
<dt><code>cond.shrinkage</code></dt><dd><p>a vector giving the shrinkage on the conditional mean estimates of eta</p>
</dd>
<dt><code>mean.phi</code></dt><dd><p>a matrix giving the population estimate (Ci*mu) including covariate effects, for each subject</p>
</dd>
<dt><code>map.psi</code></dt><dd><p>a dataframe giving the MAP estimates of individual parameters</p>
</dd>
<dt><code>map.phi</code></dt><dd><p>a dataframe giving the MAP estimates of individual phi</p>
</dd>
<dt><code>map.eta</code></dt><dd><p>a matrix giving the individual estimates of the random effects corresponding to the MAP estimates</p>
</dd>
<dt><code>map.shrinkage</code></dt><dd><p>a vector giving the shrinkage on the MAP estimates of eta</p>
</dd>
<dt><code>phi</code></dt><dd><p>individual parameters, estimated at the end of the estimation process as the average over the chains of the individual parameters sampled during the successive E-steps</p>
</dd>
<dt><code>psi.samp</code></dt><dd><p>a three-dimensional array with samples of psi from the conditional distribution</p>
</dd>
<dt><code>phi.samp</code></dt><dd><p>a three-dimensional array with samples of phi from the conditional distribution</p>
</dd>
<dt><code>phi.samp.var</code></dt><dd><p>a three-dimensional array with the variance of phi</p>
</dd>
<dt><code>ll.lin</code></dt><dd><p>log-likelihood computed by lineariation</p>
</dd>
<dt><code>aic.lin</code></dt><dd><p>Akaike Information Criterion computed by linearisation</p>
</dd>
<dt><code>bic.lin</code></dt><dd><p>Bayesian Information Criterion computed by linearisation</p>
</dd>
<dt><code>bic.covariate.lin</code></dt><dd><p>Specific Bayesian Information Criterion for covariate selection computed by linearisation</p>
</dd>
<dt><code>ll.is</code></dt><dd><p>log-likelihood computed by Importance Sampling</p>
</dd>
<dt><code>aic.is</code></dt><dd><p>Akaike Information Criterion computed by Importance Sampling</p>
</dd>
<dt><code>bic.is</code></dt><dd><p>Bayesian Information Criterion computed by Importance Sampling</p>
</dd>
<dt><code>bic.covariate.is</code></dt><dd><p>Specific Bayesian Information Criterion for covariate selection computed by Importance Sampling</p>
</dd>
<dt><code>LL</code></dt><dd><p>a vector giving the conditional log-likelihood at each iteration of the algorithm</p>
</dd>
<dt><code>ll.gq</code></dt><dd><p>log-likelihood computed by Gaussian Quadrature</p>
</dd>
<dt><code>aic.gq</code></dt><dd><p>Akaike Information Criterion computed by Gaussian Quadrature</p>
</dd>
<dt><code>bic.gq</code></dt><dd><p>Bayesian Information Criterion computed by Gaussian Quadrature</p>
</dd>
<dt><code>bic.covariate.gq</code></dt><dd><p>Specific Bayesian Information Criterion for covariate selection computed by Gaussian Quadrature</p>
</dd>
<dt><code>predictions</code></dt><dd><p>a data frame containing all the predictions and residuals in a table format</p>
</dd>
<dt><code>ppred</code></dt><dd><p>a vector giving the population predictions obtained with the population estimates</p>
</dd>
<dt><code>ypred</code></dt><dd><p>a vector giving the mean population predictions</p>
</dd>
<dt><code>ipred</code></dt><dd><p>a vector giving the individual predictions obtained with the MAP estimates</p>
</dd>
<dt><code>icpred</code></dt><dd><p>a vector giving the individual predictions obtained with the conditional estimates</p>
</dd>
<dt><code>ires</code></dt><dd><p>a vector giving the individual residuals obtained with the MAP estimates</p>
</dd>
<dt><code>iwres</code></dt><dd><p>a vector giving the individual weighted residuals obtained with the MAP estimates</p>
</dd>
<dt><code>icwres</code></dt><dd><p>a vector giving the individual weighted residuals obtained with the conditional estimates</p>
</dd>
<dt><code>wres</code></dt><dd><p>a vector giving the population weighted residuals</p>
</dd>
<dt><code>npde</code></dt><dd><p>a vector giving the normalised prediction distribution errors</p>
</dd>
<dt><code>pd</code></dt><dd><p>a vector giving the prediction discrepancies</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>An object of the SaemixData class can be created by using the function <code><a href="#topic+saemixData">saemixData</a></code> and contain the following slots:
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "SaemixRes")</code>: replace elements of object</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "SaemixRes")</code>: access elements of object</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SaemixRes")</code>: internal function to initialise object, not to be used</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "SaemixRes")</code>: prints details about the object (more extensive than show)</p>
</dd>
<dt>read</dt><dd><p><code>signature(object = "SaemixRes")</code>: internal function, not to be used </p>
</dd>
<dt>showall</dt><dd><p><code>signature(object = "SaemixRes")</code>: shows all the elements in the object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SaemixRes")</code>: prints details about the object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SaemixRes")</code>: summary of the results. Returns a list with a number of elements extracted from the results ().</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>
<p>Audrey Lavenu
</p>
<p>Marc Lavielle.
</p>


<h3>References</h3>

<p>E Comets, A Lavenu, M Lavielle M (2017). Parameter estimation in nonlinear mixed effect models using saemix,
an R implementation of the SAEM algorithm. Journal of Statistical Software, 80(3):1-41.
</p>
<p>E Kuhn, M Lavielle (2005). Maximum likelihood estimation in nonlinear mixed effects models.
Computational Statistics and Data Analysis, 49(4):1020-1038.
</p>
<p>E Comets, A Lavenu, M Lavielle (2011). SAEMIX, an R version of the SAEM algorithm. 20th meeting of the
Population Approach Group in Europe, Athens, Greece, Abstr 2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemixData">saemixData</a></code> <code><a href="#topic+SaemixModel">SaemixModel</a></code> <code><a href="#topic+saemixControl">saemixControl</a></code> <code><a href="#topic+saemix">saemix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>methods(class="SaemixRes")

showClass("SaemixRes")

</code></pre>

<hr>
<h2 id='show-methods'>Methods for Function show</h2><span id='topic+show-methods'></span><span id='topic+show+2CSaemixData-method'></span><span id='topic+show+2CSaemixRepData-method'></span><span id='topic+show+2CSaemixSimData-method'></span><span id='topic+show+2CSaemixModel-method'></span><span id='topic+show+2CSaemixRes-method'></span><span id='topic+show+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Prints a short summary of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
show(object)

## S4 method for signature 'SaemixRepData'
show(object)

## S4 method for signature 'SaemixSimData'
show(object)

## S4 method for signature 'SaemixModel'
show(object)

## S4 method for signature 'SaemixRes'
show(object)

## S4 method for signature 'SaemixObject'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p>an object of type SaemixData, SaemixModel, SaemixRes or SaemixObject</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Default show function </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixData\&quot;)&quot;)</dt><dd><p> Prints a short summary of a
SaemixData object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> Prints a short summary of a
SaemixModel object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> Prints a short summary of
the results from a SAEMIX fit </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixRes\&quot;)&quot;)</dt><dd><p> Not user-level </p>
</dd>
<dt>list(&quot;signature(object = \&quot;SaemixRepData\&quot;)&quot;)</dt><dd><p> Prints a short summary
of a SaemixRepData object </p>
</dd>
<dt>list(&quot;signature(object = \&quot;SaemixSimData\&quot;)&quot;)</dt><dd><p> Prints a short summary
of a SaemixSimData object </p>
</dd> </dl>


<hr>
<h2 id='showall-methods'>Methods for Function showall</h2><span id='topic+showall-methods'></span><span id='topic+showall+2CSaemixData-method'></span><span id='topic+showall'></span><span id='topic+showall+2CSaemixModel-method'></span><span id='topic+showall+2CSaemixRes-method'></span><span id='topic+showall+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>This function is used to visualise the majority of the elements of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showall(object)

## S4 method for signature 'SaemixData'
showall(object)

## S4 method for signature 'SaemixModel'
showall(object)

## S4 method for signature 'SaemixRes'
showall(object)

## S4 method for signature 'SaemixObject'
showall(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showall-methods_+3A_object">object</code></td>
<td>
<p>showall methods are available for objects of type SaemixData,
SaemixModel and SaemixObject</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;SaemixData\&quot;)&quot;)</dt><dd>
<p>Prints a extensive summary of a SaemixData object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> Prints a extensive summary of
a SaemixModel object </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> Prints a extensive summary
of the results from a SAEMIX fit </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixRes\&quot;)&quot;)</dt><dd><p> Not user-level </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+SaemixData">SaemixData</a></code>,<code><a href="#topic+SaemixModel">SaemixModel</a></code>, <code><a href="#topic+SaemixObject">SaemixObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A SaemixData object
data(theo.saemix)
saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
showall(saemix.data)

# A SaemixModel object
model1cpt&lt;-function(psi,id,xidep) { 
	  dose&lt;-xidep[,1]
	  tim&lt;-xidep[,2]  
	  ka&lt;-psi[id,1]
	  V&lt;-psi[id,2]
	  CL&lt;-psi[id,3]
	  k&lt;-CL/V
	  ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
	  return(ypred)
}
saemix.model&lt;-saemixModel(model=model1cpt,
  description="One-compartment model with first-order absorption", 
  psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3, byrow=TRUE,
  dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1),
  covariate.model=matrix(c(0,1,0,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
  covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),
  omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="constant")
showall(saemix.model)
</code></pre>

<hr>
<h2 id='simulate.SaemixObject'>Perform simulations under the model for an saemixObject object</h2><span id='topic+simulate.SaemixObject'></span><span id='topic+simul.saemix'></span><span id='topic+simulateContinuousSaemix'></span><span id='topic+simulateIndividualParameters'></span>

<h3>Description</h3>

<p>This function is used to simulate data under the empirical design,
using the model and estimated parameters from a fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixObject'
simulate(
  object,
  nsim,
  seed,
  predictions,
  outcome = "continuous",
  res.var = TRUE,
  uncertainty = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.SaemixObject_+3A_object">object</code></td>
<td>
<p>an saemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to perform. Defaults to the nb.sim
element in options</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_seed">seed</code></td>
<td>
<p>if non-null, seed used to initiate the random number generator (defaults to NULL)</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_predictions">predictions</code></td>
<td>
<p>Whether the simulated parameters should be used to compute predictions.
Defaults to TRUE for continuous data, and to FALSE for non-Gaussian data models.
If FALSE, only individual parameters are simulated.</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_outcome">outcome</code></td>
<td>
<p>the type of outcome (used to specify TTE or RTTE models)</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_res.var">res.var</code></td>
<td>
<p>Whether residual variability should be added to the
predictions. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Uses uncertainty (currently not implemented). Defaults to FALSE</p>
</td></tr>
<tr><td><code id="simulate.SaemixObject_+3A_...">...</code></td>
<td>
<p>additional arguments, unused (included for compatibility with the generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulated data can then be used to produce Visual Predictive Check graphs, as well as
to compute the normalised prediction distribution errors (npde).
</p>
<p>This function replaces the previous function (simul.saemix), which will be deprecated in future versions
but can still be called as previously for compatibility purposes.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Audrey Lavenu,
Marc Lavielle.
</p>


<h3>References</h3>

<p>Brendel, K, Comets, E, Laffont, C, Laveille, C, Mentre, F.
Metrics for external model evaluation with an application to the population
pharmacokinetics of gliclazide, Pharmaceutical Research 23 (2006),
2036-2049.
</p>
<p>Holford, N. The Visual Predictive Check: superiority to standard diagnostic
(Rorschach) plots (Abstract 738), in: 14th Meeting of the Population
Approach Group in Europe, Pamplona, Spain, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+saemix.plot.data">saemix.plot.data</a></code>, <code><a href="#topic+saemix.plot.convergence">saemix.plot.convergence</a></code>,
<code><a href="#topic+saemix.plot.llis">saemix.plot.llis</a></code>, <code><a href="#topic+saemix.plot.randeff">saemix.plot.randeff</a></code>,
<code><a href="#topic+saemix.plot.obsvspred">saemix.plot.obsvspred</a></code>, <code><a href="#topic+saemix.plot.fits">saemix.plot.fits</a></code>,
<code><a href="#topic+saemix.plot.parcov">saemix.plot.parcov</a></code>, <code><a href="#topic+saemix.plot.distpsi">saemix.plot.distpsi</a></code>,
<code><a href="#topic+saemix.plot.scatterresiduals">saemix.plot.scatterresiduals</a></code>, <code><a href="#topic+saemix.plot.vpc">saemix.plot.vpc</a></code>
</p>

<hr>
<h2 id='simulateDiscreteSaemix'>Perform simulations under the model for an saemixObject object defined by its log-likelihood</h2><span id='topic+simulateDiscreteSaemix'></span><span id='topic+simulateTTESaemix'></span>

<h3>Description</h3>

<p>This function is used to simulate from discrete response models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateDiscreteSaemix(
  object,
  nsim,
  seed,
  predictions = TRUE,
  uncertainty = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateDiscreteSaemix_+3A_object">object</code></td>
<td>
<p>an saemixObject object returned by the <code><a href="#topic+saemix">saemix</a></code> function.
The model must contain a slot simulate.function, containing a function with the same structure as the model functions
(arguments (psi, id, xidep)) which returns simulated responses when given a set of individual parameters (psi)
and the corresponding predictors (xidep)</p>
</td></tr>
<tr><td><code id="simulateDiscreteSaemix_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to perform. Defaults to the nb.simpred
element in options</p>
</td></tr>
<tr><td><code id="simulateDiscreteSaemix_+3A_seed">seed</code></td>
<td>
<p>if non-null, seed used to initiate the random number generator (defaults to NULL)</p>
</td></tr>
<tr><td><code id="simulateDiscreteSaemix_+3A_predictions">predictions</code></td>
<td>
<p>Whether the simulated parameters should be used to
compute predictions. Defaults to TRUE. If FALSE, only individual parameters are simulated.</p>
</td></tr>
<tr><td><code id="simulateDiscreteSaemix_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Uses uncertainty (currently not implemented). Defaults to FALSE</p>
</td></tr>
<tr><td><code id="simulateDiscreteSaemix_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, prints messages (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To call this function, the user needs to define a simulate.function matching the model function
in the object. The function will then be used to simulate data under the empirical design,
using the model and estimated parameters from a fit.
</p>
<p>This function calls simulate.SaemixObject with the prediction=FALSE option to
simulate individual parameters, then the simulate.function to obtain corresponding predictions.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SaemixObject">SaemixObject</a></code>,<code><a href="#topic+saemix">saemix</a></code>,
<code><a href="#topic+simulate.SaemixObject">simulate.SaemixObject</a></code>
</p>

<hr>
<h2 id='step.saemix'>Stepwise procedure for joint selection of covariates and random effects</h2><span id='topic+step.saemix'></span>

<h3>Description</h3>

<p>Joint selection of covariates and random effects in a nonlinear mixed effects model by a stepwise-type
algorithm based on two different versions of BIC for covariate selection and random effects selection
respectively. Selection is made among the covariates as such specified in the SaemixData object.
Only uncorrelated random effects structures are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.saemix(
  saemixObject,
  trace = TRUE,
  direction = "forward",
  covariate.init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.saemix_+3A_saemixobject">saemixObject</code></td>
<td>
<p>An object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="step.saemix_+3A_trace">trace</code></td>
<td>
<p>If TRUE, a table summarizing the steps of the algorithm is printed. Default &quot;TRUE&quot;</p>
</td></tr>
<tr><td><code id="step.saemix_+3A_direction">direction</code></td>
<td>
<p>The mode of stepwise search, can be one of &quot;both&quot;, &quot;backward&quot;, or &quot;forward&quot;,
with a default of &quot;forward&quot;.</p>
</td></tr>
<tr><td><code id="step.saemix_+3A_covariate.init">covariate.init</code></td>
<td>
<p>A matrix specifying the initial covariate structure to be considered in the algorithm.
covariate.init is only used if the direction argument is &quot;both&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the SaemixObject class storing the covariate model and the covariance structure of
random effects of the final model.
</p>


<h3>Author(s)</h3>

<p>Maud Delattre
</p>


<h3>References</h3>

<p>M Delattre, M Lavielle, MA Poursat (2014) A note on BIC in mixed effects models.
Electronic Journal of Statistics 8(1) p. 456-475
M Delattre, MA Poursat (2017) BIC strategies for model choice in a population approach.
(arXiv:1612.02405)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA,
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")

# Definition of models to be compared
model1cpt&lt;-function(psi,id,xidep) { 
   dose&lt;-xidep[,1]
   tim&lt;-xidep[,2]  
   ka&lt;-psi[id,1]
   V&lt;-psi[id,2]
   CL&lt;-psi[id,3]
   k&lt;-CL/V
   ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
   return(ypred)
}

saemix.model1&lt;-saemixModel(model=model1cpt,modeltype="structural", 
     description="One-compartment model with first-order absorption",
     psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, 
     dimnames=list(NULL, c("ka","V","CL"))), transform.par=c(1,1,1),
     covariate.model=matrix(c(0,0,1,0,0,0),ncol=3,byrow=TRUE))
                          
saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE)
saemix.fit1&lt;-saemix(saemix.model1,saemix.data,saemix.options)     

## Not run: 
res.forward &lt;- step.saemix(saemix.fit1, direction = "forward")
res.backward &lt;- step.saemix(saemix.fit1, direction = "backward")
covariate.init &lt;- matrix(c(1,0,0,0,1,0),ncol=3,nrow=2)
res.stepwise &lt;- step.saemix(saemix.fit1, direction="both")

## End(Not run)
</code></pre>

<hr>
<h2 id='stepwise.procedure'>Stepwise procedure for joint selection of covariates and random effects</h2><span id='topic+stepwise.procedure'></span>

<h3>Description</h3>

<p>Joint selection of covariates and random effects in a nonlinear mixed effects model by a stepwise-type
algorithm based on two different versions of BIC for covariate selection and random effects selection
respectively. Selection is made among the covariates as such specified in the SaemixData object.
Only uncorrelated random effects structures are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.procedure(saemixObject, covariate.init = NULL, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.procedure_+3A_saemixobject">saemixObject</code></td>
<td>
<p>An object returned by the <code><a href="#topic+saemix">saemix</a></code> function</p>
</td></tr>
<tr><td><code id="stepwise.procedure_+3A_covariate.init">covariate.init</code></td>
<td>
<p>A matrix specifying the initial covariate structure to be considered in the algorithm.</p>
</td></tr>
<tr><td><code id="stepwise.procedure_+3A_trace">trace</code></td>
<td>
<p>If TRUE, a table summarizing the steps of the algorithm is printed. Default &quot;TRUE&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the SaemixObject class storing the covariate model and the covariance structure of
random effects of the final model.
</p>


<h3>Author(s)</h3>

<p>Maud Delattre
</p>


<h3>References</h3>

<p>M Delattre, M Lavielle, MA Poursat (2014) A note on BIC in mixed effects models.
Electronic Journal of Statistics 8(1) p. 456-475
M Delattre, MA Poursat (2017) BIC strategies for model choice in a population approach.
(arXiv:1612.02405)
</p>

<hr>
<h2 id='subset'>Data subsetting</h2><span id='topic+subset'></span><span id='topic+subset.SaemixData'></span><span id='topic+subset-methods'></span>

<h3>Description</h3>

<p>Return an SaemixData object containing the subset of data which meets conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixData'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>saemixData object</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep: missing values are taken as false</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+SaemixData-class">SaemixData</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='summary-methods'>Methods for Function summary</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary'></span><span id='topic+summary+2CSaemixData'></span><span id='topic+summary+2CSaemixData-method'></span><span id='topic+summary+2CSaemixModel-method'></span><span id='topic+summary+2CSaemixRes-method'></span><span id='topic+summary+2CSaemixObject-method'></span>

<h3>Description</h3>

<p>Methods for function <code>summary</code>
</p>
<p>summary method for class SaemixData
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SaemixData'
summary(object, print = TRUE, ...)

## S4 method for signature 'SaemixModel'
summary(object, print = TRUE, ...)

## S4 method for signature 'SaemixRes'
summary(object, print = TRUE, ...)

## S4 method for signature 'SaemixObject'
summary(object, print = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>an object of class SaemixData</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_print">print</code></td>
<td>
<p>a boolean controlling whether to print the output or return it silently</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a number of elements extracted from the dataset
</p>

<dl>
<dt>N</dt><dd><p> number of subjects</p>
</dd>
<dt>nobs</dt><dd><p> the total number of observations</p>
</dd>
<dt>nind.obs</dt><dd><p>a vector giving the number of observations for each subject</p>
</dd>
<dt>id</dt><dd><p>subject ID; x: predictors; y: response, and, if present in the data, covariates: the covariates (as many lines as observations) and ind.covariates: the individual covariates (one</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> default summary function ?</p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixData\&quot;)&quot;)</dt><dd><p> summary of the data </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixModel\&quot;)&quot;)</dt><dd><p> summary of the model </p>
</dd>
<dt>list(&quot;signature(x = \&quot;SaemixObject\&quot;)&quot;)</dt><dd><p> summary of an SaemixObject</p>
</dd>
</dl>


<hr>
<h2 id='testnpde'>Tests for normalised prediction distribution errors</h2><span id='topic+testnpde'></span><span id='topic+kurtosis'></span><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Performs tests for the normalised prediction distribution errors returned by
<code>npde</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testnpde(npde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testnpde_+3A_npde">npde</code></td>
<td>
<p>the vector of prediction distribution errors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of normalised prediction distribution errors (npde), this
function compares the npde to the standardised normal distribution N(0,1)
using a Wilcoxon test of the mean, a Fisher test of the variance, and a
Shapiro-Wilks test for normality. A global test is also reported.
</p>
<p>The helper functions <code>kurtosis</code> and <code>skewness</code> are called to
compute the kurtosis and skewness of the distribution of the npde.
</p>


<h3>Value</h3>

<p>a list containing 4 components: </p>
<table>
<tr><td><code>Wilcoxon test of
mean=0</code></td>
<td>
<p>compares the mean of the npde to 0 using a Wilcoxon test</p>
</td></tr>
<tr><td><code>variance test</code></td>
<td>
<p>compares the variance of the npde to 1 using a Fisher
test</p>
</td></tr> <tr><td><code>SW test of normality</code></td>
<td>
<p>compares the npde to the normal
distribution using a Shapiro-Wilks test</p>
</td></tr> <tr><td><code>global test</code></td>
<td>
<p>an adjusted
p-value corresponding to the minimum of the 3 previous p-values multiplied
by the number of tests (3), or 1 if this p-value is larger than 1.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>
</p>


<h3>References</h3>

<p>K. Brendel, E. Comets, C. Laffont, C. Laveille, and F. Mentr\'e.
Metrics for external model evaluation with an application to the population
pharmacokinetics of gliclazide. <em>Pharmaceutical Research</em>, 23:2036&ndash;49,
2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saemix">saemix</a></code>, <code><a href="#topic+saemix.plot.npde">saemix.plot.npde</a></code>
</p>

<hr>
<h2 id='theo.saemix'>Pharmacokinetics of theophylline</h2><span id='topic+theo.saemix'></span>

<h3>Description</h3>

<p>The <code>theo.saemix</code> data frame has 132 rows and 6 columns of data from
an experiment on the pharmacokinetics of theophylline. A column with gender was
added to the original data for demo purposes, and contains simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theo.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Id</dt><dd><p>an ordered factor with levels <code>1</code>, ..., <code>12</code>
identifying the subject on whom the observation was made.  The ordering is
by time at which the observation was made.  </p>
</dd>
<dt>Dose</dt><dd><p>dose of theophylline administered orally to the subject (mg/kg).  </p>
</dd>
<dt>Time</dt><dd><p>time since drug administration when the sample was drawn (hr).  </p>
</dd>
<dt>Concentration</dt><dd><p>theophylline concentration in the sample (mg/L).  </p>
</dd>
<dt>Weight</dt><dd><p> weight of the subject (kg).  </p>
</dd>
<dt>Sex</dt><dd><p> gender (simulated, 0=male, 1=female</p>
</dd> </dl>



<h3>Details</h3>

<p>Boeckmann, Sheiner and Beal (1994) report data from a study by Dr. Robert
Upton of the kinetics of the anti-asthmatic drug theophylline.  Twelve
subjects were given oral doses of theophylline then serum concentrations
were measured at 11 time points over the next 25 hours.
</p>
<p>These data are analyzed in Davidian and Giltinan (1995) and Pinheiro and
Bates (2000) using a two-compartment open pharmacokinetic model.
</p>
<p>These data are also available in the library <code>datasets</code> under the name
<code>Theoph</code> in a slightly modified format and including the data at time
0.  Here, we use the file in the format provided in the <em>NONMEM</em>
installation path (see the User Guide for that software for details).
</p>


<h3>Source</h3>

<p>AJ Boeckmann, LB Sheiner, SL Beal (1994),
<em>NONMEM Users Guide: Part V</em>, NONMEM Project Group, University of
California, San Francisco.
</p>


<h3>References</h3>

<p>M Davidian, DM Giltinan (1995) <em>Nonlinear Models for Repeated
Measurement Data</em>, Chapman &amp; Hall (section 5.5, p. 145 and section 6.6, p.
176)
</p>
<p>JC Pinheiro, DM Bates (2000) <em>Mixed-effects Models in S and
S-PLUS</em>, Springer (Appendix A.29)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(theo.saemix)

#Plotting the theophylline data
plot(Concentration~Time,data=theo.saemix,xlab="Time after dose (hr)",
ylab="Theophylline concentration (mg/L)")

saemix.data&lt;-saemixData(name.data=theo.saemix,header=TRUE,sep=" ",na=NA, 
  name.group=c("Id"),name.predictors=c("Dose","Time"),
  name.response=c("Concentration"),name.covariates=c("Weight","Sex"),
  units=list(x="hr",y="mg/L",covariates=c("kg","-")), name.X="Time")
  model1cpt&lt;-function(psi,id,xidep) { 
    dose&lt;-xidep[,1]
    tim&lt;-xidep[,2]  
    ka&lt;-psi[id,1]
    V&lt;-psi[id,2]
    CL&lt;-psi[id,3]
    k&lt;-CL/V
    ypred&lt;-dose*ka/(V*(ka-k))*(exp(-k*tim)-exp(-ka*tim))
    return(ypred)
    }
# Default model, no covariate
saemix.model&lt;-saemixModel(model=model1cpt,
       description="One-compartment model with first-order absorption",
       psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, 
       dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1))
 # Note: remove the options save=FALSE and save.graphs=FALSE 
 # to save the results and graphs
 saemix.options&lt;-list(seed=632545,save=FALSE,save.graphs=FALSE, displayProgress=FALSE)
 
 # Not run (strict time constraints for CRAN)
 saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
 
 # Model with covariates
 saemix.model&lt;-saemixModel(model=model1cpt,
      description="One-compartment model with first-order absorption",
      psi0=matrix(c(1.,20,0.5,0.1,0,-0.01),ncol=3,byrow=TRUE, 
      dimnames=list(NULL, c("ka","V","CL"))),transform.par=c(1,1,1), 
      covariate.model=matrix(c(0,0,1,0,0,0),ncol=3,byrow=TRUE),fixed.estim=c(1,1,1),
      covariance.model=matrix(c(1,0,0,0,1,1,0,1,1),ncol=3,byrow=TRUE),
      omega.init=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3,byrow=TRUE),error.model="combined")
      
 saemix.options&lt;-list(seed=39546,save=FALSE,save.graphs=FALSE,displayProgress=FALSE)
 
 # Not run (strict time constraints for CRAN)
 saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
 
 
</code></pre>

<hr>
<h2 id='toenail.saemix'>Toenail data</h2><span id='topic+toenail.saemix'></span>

<h3>Description</h3>

<p>The <code>toenail.saemix</code> data are from a multicenter study comparing two oral treatments for toe-nail infection, including information for 294 patients measured at 7 weeks, comprising a total of 1908 measurements. The outcome binary variable &quot;onycholysis&quot; indicates the degree of separation of the nail plate from the nail-bed (none or mild versus moderate or severe). Patients were evaluated at baseline (week 0) and at weeks 4, 8, 12, 24, 36, and 48 thereafter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toenail.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd><p>subject index in file</p>
</dd>
<dt>time</dt><dd><p>time of measurement (in months)</p>
</dd>
<dt>y</dt><dd><p>degree of onycholysis (0 if none or mild, 1 if moderate or severe)</p>
</dd>
<dt>treatment</dt><dd><p>treatment indicator (1=Treatment A, 0= Treatment B)</p>
</dd>
<dt>visit</dt><dd><p>visit number (visit numbers 1-7 correspond to scheduled visits at 0, 4, 8, 12, 24, 36, and 48 weeks)</p>
</dd>
</dl>

<p>#'
</p>


<h3>Details</h3>

<p>The data in the <code>toenail.saemix</code> was copied from the Toenail dataset provided by the prLogistic package. Different models
and analyses have been performed to describe this dataset in Molenberg and Verbeke (2000).
Please refer to the PDF documentation (chapter 4, section 4.6) for more details on the analysis, including how to obtain diagnostic plots.
</p>


<h3>Source</h3>

<p>prLogistic package in R
</p>


<h3>References</h3>

<p>M De Backer, C De Vroey, E Lesaffre, I Scheys, P De Keyser (1998).
Twelve weeks of continuous oral therapy for toenail onychomycosis caused by dermatophytes:
A double-blind comparative trial of terbinafine 250 mg/day versus itraconazole 200 mg/day.
Journal of the American Academy of Dermatology, 38:57-63.
</p>
<p>E Lesaffre, B Spiessens (2001). On the effect of the number of quadrature points in a logistic random-effects model: An example.
Journal of the Royal Statistical Society, Series C, 50:325-335.
</p>
<p>G Verbeke, G Molenberghs (2000). Linear mixed models for longitudinal data, Springer, New York.
</p>
<p>S Rabe-Hesketh, A Skrondal (2008). Multilevel and Longitudinal Modeling Using Stata. Mahwah, NJ: Lawrence Erlbaum Associates. Second Edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(toenail.saemix)
saemix.data&lt;-saemixData(name.data=toenail.saemix,name.group=c("id"), name.predictors=c("time","y"), 
 name.response="y", name.covariates=c("treatment"),name.X=c("time"))
binary.model&lt;-function(psi,id,xidep) {
  tim&lt;-xidep[,1]
  y&lt;-xidep[,2]
  inter&lt;-psi[id,1]
  slope&lt;-psi[id,2]
  logit&lt;-inter+slope*tim
  pevent&lt;-exp(logit)/(1+exp(logit))
  pobs = (y==0)*(1-pevent)+(y==1)*pevent
  logpdf &lt;- log(pobs)
  return(logpdf)
}

saemix.model&lt;-saemixModel(model=binary.model,description="Binary model",
     modeltype="likelihood",
     psi0=matrix(c(-5,-.1,0,0),ncol=2,byrow=TRUE,dimnames=list(NULL,c("theta1","theta2"))),
     transform.par=c(0,0), covariate.model=c(0,1),
     covariance.model=matrix(c(1,0,0,1),ncol=2))

saemix.options&lt;-list(seed=1234567,save=FALSE,save.graphs=FALSE, displayProgress=FALSE, 
   nb.chains=10, fim=FALSE)
binary.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)
plot(binary.fit, plot.type="convergence")

 
</code></pre>

<hr>
<h2 id='transform'>Transform covariates</h2><span id='topic+transform'></span><span id='topic+transform.numeric'></span>

<h3>Description</h3>

<p>Transform and/or center a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
transform(
  `_data`,
  transformation = function(x) x,
  centering = "median",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_+3A__data">_data</code></td>
<td>
<p>a vector with values of type numeric</p>
</td></tr>
<tr><td><code id="transform_+3A_transformation">transformation</code></td>
<td>
<p>transformation function. Defaults to no transformation</p>
</td></tr>
<tr><td><code id="transform_+3A_centering">centering</code></td>
<td>
<p>string, giving the value used to center the covariate; can be &quot;mean&quot; or &quot;median&quot;, in which case this value will be computed from the data, 'none' or 0 for no centering, or a value given by the user. Defaults to the median value over the dataset.</p>
</td></tr>
<tr><td><code id="transform_+3A_verbose">verbose</code></td>
<td>
<p>a boolean, prints messages during the execution of the function if TRUE. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="transform_+3A_...">...</code></td>
<td>
<p>unused, for consistency with the generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='transformCatCov'>Transform covariates</h2><span id='topic+transformCatCov'></span>

<h3>Description</h3>

<p>Regroup categorical covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformCatCov(object, covariate, group, reference, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformCatCov_+3A_object">object</code></td>
<td>
<p>saemixData object</p>
</td></tr>
<tr><td><code id="transformCatCov_+3A_covariate">covariate</code></td>
<td>
<p>name of the covariate</p>
</td></tr>
<tr><td><code id="transformCatCov_+3A_group">group</code></td>
<td>
<p>a vector giving the categories to which the initial values of the covariates should be mapped. If the resulting covariate is binary, it will be stored as 0/1. If it has more than 2 categories, dummy covariates will be created for the analysis.</p>
</td></tr>
<tr><td><code id="transformCatCov_+3A_reference">reference</code></td>
<td>
<p>the reference group</p>
</td></tr>
<tr><td><code id="transformCatCov_+3A_verbose">verbose</code></td>
<td>
<p>a boolean, prints messages during the execution of the function if TRUE. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+SaemixData-class">SaemixData</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cow.saemix)
saemix.data&lt;-saemixData(name.data=cow.saemix,header=TRUE,name.group=c("cow"),
                   name.predictors=c("time"),name.response=c("weight"),
                   name.covariates=c("birthyear","twin","birthrank"),
                   units=list(x="days",y="kg",covariates=c("yr","-","-")))
unique(saemix.data@data$birthrank) # 5 categories, 3 4 5 6 7
# create 2 dummy variables regrouping 4 and 5, and 6 and 7
cowt &lt;- transformCatCov(saemix.data, covariate=birthrank, group=c(1,2,2,3,3), verbose=TRUE) 
head(saemix.data@data) # the original covariate is birthrank
head(cowt@data) 
# the new covariates are birthrank.G2 (regrouping 4 and 5) and birthrank.G3 (6 and 7)

</code></pre>

<hr>
<h2 id='transformContCov'>Transform covariates</h2><span id='topic+transformContCov'></span><span id='topic+transform.SaemixData'></span>

<h3>Description</h3>

<p>Transform and/or center continuous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformContCov(
  object,
  covariate,
  transformation = function(x) x,
  centering = "median",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformContCov_+3A_object">object</code></td>
<td>
<p>saemixData object</p>
</td></tr>
<tr><td><code id="transformContCov_+3A_covariate">covariate</code></td>
<td>
<p>name of the covariate</p>
</td></tr>
<tr><td><code id="transformContCov_+3A_transformation">transformation</code></td>
<td>
<p>transformation function. Defaults to no transformation</p>
</td></tr>
<tr><td><code id="transformContCov_+3A_centering">centering</code></td>
<td>
<p>string, giving the value used to center the covariate; can be &quot;mean&quot; or &quot;median&quot;, in which case this value will be computed from the data, 'none' or 0 for no centering, or a value given by the user. Defaults to the median value over the dataset.</p>
</td></tr>
<tr><td><code id="transformContCov_+3A_verbose">verbose</code></td>
<td>
<p>a boolean, prints messages during the execution of the function if TRUE. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+SaemixData-class">SaemixData</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='validate.covariance.model'>Validate the structure of the covariance model</h2><span id='topic+validate.covariance.model'></span>

<h3>Description</h3>

<p>Check that a matrix corresponds to a structure defining a covariance model for a non-linear mixed effect model.
Such a matrix should be composed of only 0s and 1s, with at least one element set to 1, and should be square and symmetrical.
1s on the diagonal indicate that the corresponding parameter has interindividual variability and that its variance will be estimated.
1s as off-diagonal elements indicate that a covariance between the two corresponding parameters will be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.covariance.model(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.covariance.model_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="validate.covariance.model_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating whether warnings should be output if x is not a valid covariance model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if x is an acceptable structure and FALSE if not. Messages will be output to describe why x isn't a valid covariance model if the argument verbose is TRUE.
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@inserm.fr">emmanuelle.comets@inserm.fr</a>, Belhal Karimi
</p>


<h3>See Also</h3>

<p><code>SaemixModel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
covarmodel&lt;-diag(c(1,1,0))
validate.covariance.model(covarmodel) # should return TRUE

</code></pre>

<hr>
<h2 id='validate.names'>Name validation (## )Helper function not intended to be called by the user)</h2><span id='topic+validate.names'></span>

<h3>Description</h3>

<p>Helper function, checks if the names given by the user match to the names in the dataset. If not, automatic recognition is attempted when automatic=TRUE.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.names_+3A_usernames">usernames</code></td>
<td>
<p>vector of strings</p>
</td></tr>
<tr><td><code id="validate.names_+3A_datanames">datanames</code></td>
<td>
<p>vector of strings</p>
</td></tr>
<tr><td><code id="validate.names_+3A_recognisednames">recognisednames</code></td>
<td>
<p>vector of strings, values for automatic recognition</p>
</td></tr>
<tr><td><code id="validate.names_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print warning messages</p>
</td></tr>
<tr><td><code id="validate.names_+3A_automatic">automatic</code></td>
<td>
<p>a boolean indicating whether to attempt automatic name recognition when some colum names are missing or wrong (defaults to TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with valid names
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='vcov'>Extracts the Variance-Covariance Matrix for a Fitted Model Object</h2><span id='topic+vcov'></span><span id='topic+vcov.SaemixRes'></span><span id='topic+vcov.SaemixObject'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of a fitted model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SaemixRes'
vcov(object, ...)

## S3 method for class 'SaemixObject'
vcov(object, ...)

## S3 method for class 'SaemixObject'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>a fitted object from a call to saemix</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the estimated covariances between the parameter estimates in model. In saemix, this matrix is obtained as the inverse of the Fisher Information Matrix computed by linearisation
</p>

<hr>
<h2 id='xbinning'>Internal functions used to produce prediction intervals (from the npde package)</h2><span id='topic+xbinning'></span>

<h3>Description</h3>

<p>Functions used by plot functions to define the boundaries of the bins on the X-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xbinning(xvec, plot.opt, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xbinning_+3A_xvec">xvec</code></td>
<td>
<p>a vector of values for the X-axis of the plot</p>
</td></tr>
<tr><td><code id="xbinning_+3A_plot.opt">plot.opt</code></td>
<td>
<p>graphical options</p>
</td></tr>
<tr><td><code id="xbinning_+3A_verbose">verbose</code></td>
<td>
<p>boolean (defaults to FALSE). If TRUE, a table showing how the binning was performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are normally not called by the end-user.
</p>


<h3>Value</h3>

<p>a list with 3 elements, xgrp (the number of the bin associated with each element of xvec), xcent (a named vector containing the mean of the elements of xvec contained in each bin; the name of the bin is the interval), and xgroup (a vector with the group associated to each element of xvec after binning)
If verbose is TRUE, a table showing the bins is shown, giving the interval of xvec associated with each bin, the mean value
of xvec in each bin, and the number of observations
</p>


<h3>Author(s)</h3>

<p>Emmanuelle Comets <a href="mailto:emmanuelle.comets@bichat.inserm.fr">emmanuelle.comets@bichat.inserm.fr</a>
</p>


<h3>References</h3>

<p>K. Brendel, E. Comets, C. Laffont, C. Laveille, and F.
Mentre. Metrics for external model evaluation with an application to the
population pharmacokinetics of gliclazide. <em>Pharmaceutical Research</em>,
23:2036&ndash;49, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="npde.html#topic+npde">npde</a></code>, <code><a href="npde.html#topic+autonpde">autonpde</a></code>
</p>

<hr>
<h2 id='yield.saemix'>Wheat yield in crops treated with fertiliser, in SAEM format</h2><span id='topic+yield.saemix'></span>

<h3>Description</h3>

<p>The<code>yield.saemix</code> contains data from winter wheat experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yield.saemix
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>site</dt><dd><p>the site number</p>
</dd>
<dt>dose</dt><dd><p>dose of nitrogen fertiliser (kg/ha)</p>
</dd>
<dt>yield</dt><dd><p>grain yield (kg/ha)</p>
</dd>
<dt>soil.nitrogen</dt><dd><p>end-of-winter mineral soil nitrogen (NO3- plus NH4+) in the 0 to 90 cm layer was measured on each site/year (kg/ha)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data in the <code>yield.saemix</code> comes from 37 winter wheat experiments carried out between 1990 and 1996
on commercial farms near Paris, France. Each experiment was from a different site.
Two soil types were represented, a loam soil and a chalky soil. Common winter wheat varieties were used.
Each experiment consisted of five to eight different nitrogen fertiliser rates, for a total of 224 nitrogen treatments.
Nitrogen fertilizer was applied in two applications during the growing season. For each nitrogen treatment,
grain yield (adjusted to 150 g.kg-1 grain moisture content) was measured. In addition,
end-of-winter mineral soil nitrogen (NO3- plus NH4+) in the 0 to 90 cm layer was measured on each site-year
during February when the crops were tillering. Yield and end-of-winter mineral soil nitrogen measurements
were in the ranges 3.44-11.54 t.ha-1 , and 40-180 kg.ha-1 respectively.
</p>


<h3>Source</h3>

<p>Makowski, D., Wallach, D., and Meynard, J.-M (1999). Models of yield, grain protein, and residual mineral
nitrogen responses to applied nitrogen for winter wheat. Agronomy Journal 91: 377-385.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yield.saemix)
saemix.data&lt;-saemixData(name.data=yield.saemix,header=TRUE,name.group=c("site"),
      name.predictors=c("dose"),name.response=c("yield"),
      name.covariates=c("soil.nitrogen"),units=list(x="kg/ha",y="t/ha",covariates=c("kg/ha")))

#  Model: linear + plateau
yield.LP&lt;-function(psi,id,xidep) {
  x&lt;-xidep[,1]
  ymax&lt;-psi[id,1]
  xmax&lt;-psi[id,2]
  slope&lt;-psi[id,3]
  f&lt;-ymax+slope*(x-xmax)
  #'  cat(length(f),"  ",length(ymax),"\n")
  f[x&gt;xmax]&lt;-ymax[x&gt;xmax]
  return(f)
}
saemix.model&lt;-saemixModel(model=yield.LP,description="Linear plus plateau model",   
        psi0=matrix(c(8,100,0.2,0,0,0),ncol=3,byrow=TRUE,dimnames=list(NULL,   
            c("Ymax","Xmax","slope"))),covariate.model=matrix(c(0,0,0),ncol=3,byrow=TRUE), 
        transform.par=c(0,0,0),covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3, 
            byrow=TRUE),error.model="constant")

saemix.options&lt;-list(algorithms=c(1,1,1),nb.chains=1,seed=666, 
       save=FALSE,save.graphs=FALSE,displayProgress=FALSE)

# Plotting the data
plot(saemix.data,xlab="Fertiliser dose (kg/ha)", ylab="Wheat yield (t/ha)")


saemix.fit&lt;-saemix(saemix.model,saemix.data,saemix.options)

# Comparing the likelihoods obtained by linearisation and importance sampling 
# to the likelihood obtained by Gaussian Quadrature
saemix.fit&lt;-llgq.saemix(saemix.fit)
{
   cat("LL by Importance sampling, LL_IS=",saemix.fit["results"]["ll.is"],"\n")
   cat("LL by linearisation, LL_lin=",saemix.fit["results"]["ll.lin"],"\n")
   cat("LL by Gaussian Quadrature, LL_GQ=",saemix.fit["results"]["ll.gq"],"\n")
}

# Testing for an effect of covariate soil.nitrogen on Xmax
saemix.model2&lt;-saemixModel(model=yield.LP,description="Linear plus plateau model", 
         psi0=matrix(c(8,100,0.2,0,0,0),ncol=3,byrow=TRUE,dimnames=list(NULL, 
            c("Ymax","Xmax","slope"))),covariate.model=matrix(c(0,1,0),ncol=3,byrow=TRUE), 
         transform.par=c(0,0,0),covariance.model=matrix(c(1,0,0,0,1,0,0,0,1),ncol=3, 
             byrow=TRUE),error.model="constant")

saemix.fit2&lt;-saemix(saemix.model2,saemix.data,saemix.options)
# BIC for the two models
{
  cat("Model without covariate, BIC=",saemix.fit["results"]["bic.is"],"\n")
  cat("Model with covariate, BIC=",saemix.fit2["results"]["bic.is"],"\n")
  pval&lt;-1-pchisq(-2*saemix.fit["results"]["ll.is"]+2*saemix.fit2["results"]["ll.is"],1)
  cat("        LRT: p=",pval,"\n")
}

#' @keywords datasets
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
