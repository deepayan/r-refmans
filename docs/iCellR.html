<!DOCTYPE html><html><head><title>Help for package iCellR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iCellR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.10x.image'><p>Add image data to iCellR object</p></a></li>
<li><a href='#add.adt'><p>Add CITE-seq antibody-derived tags (ADT)</p></a></li>
<li><a href='#add.vdj'><p>Add V(D)J recombination data</p></a></li>
<li><a href='#adt.rna.merge'><p>Merge RNA and ADT data</p></a></li>
<li><a href='#bubble.gg.plot'><p>Create bubble heatmaps for genes in clusters or conditions.</p></a></li>
<li><a href='#capture.image.10x'><p>Read 10X image data</p></a></li>
<li><a href='#cc'><p>Calculate Cell cycle phase prediction</p></a></li>
<li><a href='#cell.cycle'><p>Cell cycle phase prediction</p></a></li>
<li><a href='#cell.filter'><p>Filter cells</p></a></li>
<li><a href='#cell.gating'><p>Cell gating</p></a></li>
<li><a href='#cell.type.pred'><p>Create heatmaps or dot plots for genes in clusters to find thier cell types using ImmGen data.</p></a></li>
<li><a href='#change.clust'><p>Change the cluster number or re-name them</p></a></li>
<li><a href='#clono.plot'><p>Make 2D and 3D scatter plots for clonotypes.</p></a></li>
<li><a href='#clust.avg.exp'><p>Create a data frame of mean expression of genes per cluster</p></a></li>
<li><a href='#clust.cond.info'><p>Calculate cluster and conditions frequencies</p></a></li>
<li><a href='#clust.ord'><p>Sort and relabel the clusters randomly or based on pseudotime</p></a></li>
<li><a href='#clust.rm'><p>Remove the cells that are in a cluster</p></a></li>
<li><a href='#clust.stats.plot'><p>Plotting tSNE, PCA, UMAP, Diffmap and other dim reductions</p></a></li>
<li><a href='#cluster.plot'><p>Plot nGenes, UMIs and perecent mito</p></a></li>
<li><a href='#data.aggregation'><p>Merge multiple data frames and add the condition names to their cell ids</p></a></li>
<li><a href='#data.scale'><p>Scale data</p></a></li>
<li><a href='#down.sample'><p>Down sample conditions</p></a></li>
<li><a href='#find_neighbors'><p>K Nearest Neighbour Search</p></a></li>
<li><a href='#find.dim.genes'><p>Find model genes from PCA data</p></a></li>
<li><a href='#findMarkers'><p>Find marker genes for each cluster</p></a></li>
<li><a href='#g2m.phase'><p>A dataset of G2 and M phase genes</p></a></li>
<li><a href='#gate.to.clust'><p>Assign cluster number to cell ids</p></a></li>
<li><a href='#gene.plot'><p>Make scatter, box and bar plots for genes</p></a></li>
<li><a href='#gene.stats'><p>Make statistical information for each gene across all the cells (SD, mean, expression, etc.)</p></a></li>
<li><a href='#gg.cor'><p>Gene-gene correlation.</p>
This function helps to visulaize and calculate gene-gene correlations.</a></li>
<li><a href='#heatmap.gg.plot'><p>Create heatmaps for genes in clusters or conditions.</p></a></li>
<li><a href='#hto.anno'><p>Demultiplexing HTOs</p></a></li>
<li><a href='#i.score'><p>Cell cycle phase prediction</p></a></li>
<li><a href='#iba'><p>iCellR Batch Alignment (IBA)</p></a></li>
<li><a href='#iclust'><p>iCellR Clustering</p></a></li>
<li><a href='#load.h5'><p>Load h5 data as data.frame</p></a></li>
<li><a href='#load10x'><p>Load 10X data as data.frame</p></a></li>
<li><a href='#make.bed'><p>Make BED Files</p></a></li>
<li><a href='#make.gene.model'><p>Make a gene model for clustering</p></a></li>
<li><a href='#make.obj'><p>Create an object of class iCellR.</p></a></li>
<li><a href='#myImp'><p>Impute data</p></a></li>
<li><a href='#norm.adt'><p>Normalize ADT data.</p>
This function takes data frame and Normalizes ADT data.</a></li>
<li><a href='#norm.data'><p>Normalize data</p></a></li>
<li><a href='#opt.pcs.plot'><p>Find optimal number of PCs for clustering</p></a></li>
<li><a href='#prep.vdj'><p>Prepare VDJ data</p></a></li>
<li><a href='#pseudotime'><p>Pseudotime</p></a></li>
<li><a href='#pseudotime.knetl'><p>iCellR KNN Network</p></a></li>
<li><a href='#pseudotime.tree'><p>Pseudotime Tree</p></a></li>
<li><a href='#qc.stats'><p>Calculate the number of UMIs and genes per cell and percentage of mitochondrial genes per cell and cell cycle genes.</p></a></li>
<li><a href='#Rphenograph'><p>RphenoGraph clustering</p></a></li>
<li><a href='#run.anchor'><p>Run anchor alignment on the main data.</p></a></li>
<li><a href='#run.cca'><p>Run CCA on the main data</p></a></li>
<li><a href='#run.clustering'><p>Clustering the data</p></a></li>
<li><a href='#run.diff.exp'><p>Differential expression (DE) analysis</p></a></li>
<li><a href='#run.diffusion.map'><p>Run diffusion map on PCA data (PHATE - Potential of Heat-Diffusion for Affinity-Based Transition Embedding)</p></a></li>
<li><a href='#run.impute'><p>Impute the main data</p></a></li>
<li><a href='#run.knetl'><p>iCellR KNN Network</p></a></li>
<li><a href='#run.mnn'><p>Run MNN alignment on the main data.</p></a></li>
<li><a href='#run.pc.tsne'><p>Run tSNE on PCA Data. Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#run.pca'><p>Run PCA on the main data</p></a></li>
<li><a href='#run.phenograph'><p>Clustering the data</p></a></li>
<li><a href='#run.tsne'><p>Run tSNE on the Main Data. Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#run.umap'><p>Run UMAP on PCA Data (Computes a manifold approximation and projection)</p></a></li>
<li><a href='#s.phase'><p>A dataset of S phase genes</p></a></li>
<li><a href='#spatial.plot'><p>Plot nGenes, UMIs and perecent mito, genes, clusters and more on spatial image</p></a></li>
<li><a href='#stats.plot'><p>Plot nGenes, UMIs and percent mito</p></a></li>
<li><a href='#top.markers'><p>Choose top marker genes</p></a></li>
<li><a href='#vdj.stats'><p>VDJ stats</p></a></li>
<li><a href='#volcano.ma.plot'><p>Create MA and Volcano plots.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing High-Throughput Single Cell Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alireza Khodadadi-Jamayran &lt;alireza.khodadadi.j@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit that allows scientists to work with data from single cell sequencing technologies such as scRNA-seq, scVDJ-seq, scATAC-seq, CITE-Seq and Spatial Transcriptomics (ST). Single (i) Cell R package ('iCellR') provides unprecedented flexibility at every step of the analysis pipeline, including normalization, clustering, dimensionality reduction, imputation, visualization, and so on. Users can design both unsupervised and supervised models to best suit their research. In addition, the toolkit provides 2D and 3D interactive visualizations, differential expression analysis, filters based on cells, genes and clusters, data merging, normalizing for dropouts, data imputation methods, correcting for batch differences, pathway analysis, tools to find marker genes for clusters and conditions, predict cell types and pseudotime analysis. See Khodadadi-Jamayran, et al (2020) &lt;<a href="https://doi.org/10.1101%2F2020.05.05.078550">doi:10.1101/2020.05.05.078550</a>&gt;  and Khodadadi-Jamayran, et al (2020) &lt;<a href="https://doi.org/10.1101%2F2020.03.31.019109">doi:10.1101/2020.03.31.019109</a>&gt; for more details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), ggplot2, plotly</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, Rtsne, gridExtra, ggrepel, ggpubr, scatterplot3d,
RColorBrewer, knitr, NbClust, shiny, pheatmap, ape, ggdendro,
plyr, reshape, Hmisc, htmlwidgets, methods, uwot, hdf5r,
progress, igraph, data.table, Rcpp, RANN, jsonlite, png</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rezakj/iCellR/issues">https://github.com/rezakj/iCellR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rezakj/iCellR">https://github.com/rezakj/iCellR</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 20:00:21 UTC; khodaa01</td>
</tr>
<tr>
<td>Author:</td>
<td>Alireza Khodadadi-Jamayran
    <a href="https://orcid.org/0000-0003-2495-7504"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Joseph Pucella <a href="https://orcid.org/0000-0003-0875-8046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Hua Zhou <a href="https://orcid.org/0000-0003-1822-1306"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ctb],
  Nicole Doudican <a href="https://orcid.org/0000-0003-3827-9644"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  John Carucci <a href="https://orcid.org/0000-0001-6817-9439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Adriana Heguy [aut, ctb],
  Boris Reizis <a href="https://orcid.org/0000-0003-1140-7853"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Aristotelis Tsirigos
    <a href="https://orcid.org/0000-0002-7512-8477"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.10x.image'>Add image data to iCellR object</h2><span id='topic+add.10x.image'></span>

<h3>Description</h3>

<p>This function takes a list of image data adds it to the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.10x.image(x = NULL, image.data.list = NULL, condition.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.10x.image_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="add.10x.image_+3A_image.data.list">image.data.list</code></td>
<td>
<p>A character vector of list object names. Lists should be made using &quot;image.capture.10x&quot; function. .</p>
</td></tr>
<tr><td><code id="add.10x.image_+3A_condition.names">condition.names</code></td>
<td>
<p>A character vector of condition names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='add.adt'>Add CITE-seq antibody-derived tags (ADT)</h2><span id='topic+add.adt'></span>

<h3>Description</h3>

<p>This function takes a data frame of ADT values per cell and adds it to the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.adt(x = NULL, adt.data = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.adt_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="add.adt_+3A_adt.data">adt.data</code></td>
<td>
<p>A data frame containing ADT counts for cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='add.vdj'>Add V(D)J recombination data</h2><span id='topic+add.vdj'></span>

<h3>Description</h3>

<p>This function takes a data frame of VDJ information per cell and adds it to the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.vdj(x = NULL, vdj.data = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.vdj_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="add.vdj_+3A_vdj.data">vdj.data</code></td>
<td>
<p>A data frame containing VDJ information for cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='adt.rna.merge'>Merge RNA and ADT data</h2><span id='topic+adt.rna.merge'></span>

<h3>Description</h3>

<p>This function is to merge the RNA and ADT data to the main.data slot of the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adt.rna.merge(x = NULL, adt.data = "raw")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adt.rna.merge_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="adt.rna.merge_+3A_adt.data">adt.data</code></td>
<td>
<p>Choose from raw or main (normalized) ADT data, default = &quot;raw&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='bubble.gg.plot'>Create bubble heatmaps for genes in clusters or conditions.</h2><span id='topic+bubble.gg.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and genes and provides a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bubble.gg.plot(
  x = NULL,
  gene = "NULL",
  data.type = "main",
  conds.to.plot = NULL,
  min.scale = -2.5,
  max.scale = 2.5,
  interactive = TRUE,
  colour = "Expression",
  size = "Percent.Expressed",
  out.name = "plot",
  heat.colors = c("blue", "red")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bubble.gg.plot_+3A_x">x</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_gene">gene</code></td>
<td>
<p>A set of gene names to be heatmapped.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot;, &quot;atac&quot;, atac.imputed and &quot;imputed&quot;, default = &quot;main&quot;.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_min.scale">min.scale</code></td>
<td>
<p>Set a minimum color scale, default = -2.5.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_max.scale">max.scale</code></td>
<td>
<p>Set a maximum color scale, default = 2.5.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_interactive">interactive</code></td>
<td>
<p>If TRUE an html interactive file will be made, default = TRUE.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_colour">colour</code></td>
<td>
<p>Set color to &quot;Percent.Expressed&quot;, or &quot;Expression&quot;, , default = &quot;Expression&quot;.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_size">size</code></td>
<td>
<p>Set size to &quot;Percent.Expressed&quot;, or &quot;Expression&quot;, , default = &quot;Percent.Expressed&quot;.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_out.name">out.name</code></td>
<td>
<p>Output name for html file if interactive = TRUE, default = &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="bubble.gg.plot_+3A_heat.colors">heat.colors</code></td>
<td>
<p>Colors for heatmap, default = c(&quot;blue&quot; ,&quot;white&quot;, &quot;red&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='capture.image.10x'>Read 10X image data</h2><span id='topic+capture.image.10x'></span>

<h3>Description</h3>

<p>This function takes 10X image data files and converts them to proper file format for iCellR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture.image.10x(dir.10x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture.image.10x_+3A_dir.10x">dir.10x</code></td>
<td>
<p>A directory that includes the 10X image files (scalefactors_json.json, tissue_lowres_image.png and tissue_positions_list.csv).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object
</p>

<hr>
<h2 id='cc'>Calculate Cell cycle phase prediction</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and assignes cell cycle stage for the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(object = NULL, s.genes = s.phase, g2m.genes = g2m.phase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_+3A_object">object</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="cc_+3A_s.genes">s.genes</code></td>
<td>
<p>Genes that are used as a marker for S phase.</p>
</td></tr>
<tr><td><code id="cc_+3A_g2m.genes">g2m.genes</code></td>
<td>
<p>Genes that are used as a marker for G2 and M phase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>

<hr>
<h2 id='cell.cycle'>Cell cycle phase prediction</h2><span id='topic+cell.cycle'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and assignes cell cycle stage for the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.cycle(
  object = NULL,
  scoring.List = NULL,
  return.stats = FALSE,
  scoring.method = "tirosh"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.cycle_+3A_object">object</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="cell.cycle_+3A_scoring.list">scoring.List</code></td>
<td>
<p>Genes that are used as a marker for phases.</p>
</td></tr>
<tr><td><code id="cell.cycle_+3A_return.stats">return.stats</code></td>
<td>
<p>Return the data or object. If FALSE the object would be returned.</p>
</td></tr>
<tr><td><code id="cell.cycle_+3A_scoring.method">scoring.method</code></td>
<td>
<p>Choose from &quot;coverage&quot; or &quot;tirosh&quot; for scoring method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>

<hr>
<h2 id='cell.filter'>Filter cells</h2><span id='topic+cell.filter'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and filters the raw data based on the number of UMIs, genes per cell, percentage of mitochondrial genes per cell, genes, gene expression and cell ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.filter(
  x = NULL,
  min.mito = 0,
  max.mito = 1,
  min.genes = 0,
  max.genes = Inf,
  min.umis = 0,
  max.umis = Inf,
  filter.by.cell.id = "character",
  keep.cell.id = "character",
  filter.by.gene = "character",
  filter.by.gene.exp.min = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.filter_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_min.mito">min.mito</code></td>
<td>
<p>Min rate for mitochondrial gene expression per cell, default = 0.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_max.mito">max.mito</code></td>
<td>
<p>Max rate for mitochondrial gene expression per cell, default = 1.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_min.genes">min.genes</code></td>
<td>
<p>Min number genes per cell, default = 0.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_max.genes">max.genes</code></td>
<td>
<p>Max number genes per cell, default = Inf.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_min.umis">min.umis</code></td>
<td>
<p>Min number UMIs per cell, default = 0.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_max.umis">max.umis</code></td>
<td>
<p>Max number UMIs per cell, default = Inf.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_filter.by.cell.id">filter.by.cell.id</code></td>
<td>
<p>A character vector of cell ids to be filtered out.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_keep.cell.id">keep.cell.id</code></td>
<td>
<p>A character vector of cell ids to keep.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_filter.by.gene">filter.by.gene</code></td>
<td>
<p>A character vector of gene names to be filtered by thier expression. If more then one gene is defined it would be OR not AND.</p>
</td></tr>
<tr><td><code id="cell.filter_+3A_filter.by.gene.exp.min">filter.by.gene.exp.min</code></td>
<td>
<p>Minimum gene expression to be filtered by the genes set in filter.by.gene, default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='cell.gating'>Cell gating</h2><span id='topic+cell.gating'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and a 2D tSNE or UMAP plot and gates around cells to get their ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.gating(x = NULL, my.plot = NULL, plot.type = "tsne")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.gating_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="cell.gating_+3A_my.plot">my.plot</code></td>
<td>
<p>The plot to use for gating. Must be a 2D plot.</p>
</td></tr>
<tr><td><code id="cell.gating_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from knetl, umap and tsne, default = NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='cell.type.pred'>Create heatmaps or dot plots for genes in clusters to find thier cell types using ImmGen data.</h2><span id='topic+cell.type.pred'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and genes and provides a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.type.pred(
  immgen.data = "rna",
  gene = "NULL",
  top.cell.types = 50,
  plot.type = "heatmap",
  heat.colors = c("blue", "white", "red")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.type.pred_+3A_immgen.data">immgen.data</code></td>
<td>
<p>Choose from ,&quot;GSE109125&quot;,&quot;GSE122108&quot;,&quot;GSE122597&quot;,&quot;GSE124829&quot;,&quot;GSE15907&quot;,&quot;GSE37448&quot;, rna&quot;, &quot;uli.rna&quot; or &quot;mca&quot;, default = &quot;rna&quot;</p>
</td></tr>
<tr><td><code id="cell.type.pred_+3A_gene">gene</code></td>
<td>
<p>A set of gene names to used to predict cell type.</p>
</td></tr>
<tr><td><code id="cell.type.pred_+3A_top.cell.types">top.cell.types</code></td>
<td>
<p>Top cell types sorted by cumulative expression, default = 25.</p>
</td></tr>
<tr><td><code id="cell.type.pred_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from &quot;heatmap&quot; od &quot;point.plot&quot;, default = &quot;heatmap&quot;</p>
</td></tr>
<tr><td><code id="cell.type.pred_+3A_heat.colors">heat.colors</code></td>
<td>
<p>Colors for heatmap, default = c(&quot;blue&quot; ,&quot;white&quot;, &quot;red&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='change.clust'>Change the cluster number or re-name them</h2><span id='topic+change.clust'></span>

<h3>Description</h3>

<p>This function re-names the clusters in the best.clust slot of the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change.clust(x = NULL, change.clust = 0, to.clust = 0, clust.reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change.clust_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="change.clust_+3A_change.clust">change.clust</code></td>
<td>
<p>The name of the cluster to be changed.</p>
</td></tr>
<tr><td><code id="change.clust_+3A_to.clust">to.clust</code></td>
<td>
<p>The new name for the cluster.</p>
</td></tr>
<tr><td><code id="change.clust_+3A_clust.reset">clust.reset</code></td>
<td>
<p>Reset to the original clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='clono.plot'>Make 2D and 3D scatter plots for clonotypes.</h2><span id='topic+clono.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and provides plots for clonotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clono.plot(
  x = NULL,
  plot.data.type = "tsne",
  clonotype.column = 1,
  barcode.column = 2,
  clono = NULL,
  conds.to.plot = NULL,
  clust.dim = 2,
  cell.size = 1,
  cell.colors = c("red", "gray"),
  box.cell.col = "black",
  back.col = "white",
  cell.transparency = 1,
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clono.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_plot.data.type">plot.data.type</code></td>
<td>
<p>Choose from &quot;tsne&quot; and &quot;pca&quot;, default = &quot;tsne&quot;.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_clonotype.column">clonotype.column</code></td>
<td>
<p>The column which has the clonotype IDs, default =  2.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_barcode.column">barcode.column</code></td>
<td>
<p>The column which has the barcode IDs, default = 1.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_clono">clono</code></td>
<td>
<p>A clonotype name to be plotted, default = NULL.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose one condition you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_clust.dim">clust.dim</code></td>
<td>
<p>2 for 2D plots and 3 for 3D plots, default =  2.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_cell.colors">cell.colors</code></td>
<td>
<p>Colors for heat mapping the points in &quot;scatterplot&quot;, default = c(&quot;gray&quot;,&quot;red&quot;).</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_box.cell.col">box.cell.col</code></td>
<td>
<p>Choose a color for box default =  &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_back.col">back.col</code></td>
<td>
<p>A color for the plot background, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for points, default = 0.5.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an intractive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="clono.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='clust.avg.exp'>Create a data frame of mean expression of genes per cluster</h2><span id='topic+clust.avg.exp'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and creates an average gene expression for every cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust.avg.exp(
  x = NULL,
  data.type = "main",
  conds.to.avg = NULL,
  rounding.digits = 4,
  low.cell.filt = 5,
  round.num = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust.avg.exp_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="clust.avg.exp_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot;, &quot;atac&quot;, &quot;atac.imputed&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="clust.avg.exp_+3A_conds.to.avg">conds.to.avg</code></td>
<td>
<p>Choose the conditions you want to average, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="clust.avg.exp_+3A_rounding.digits">rounding.digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) or significant digits (signif) to be used.</p>
</td></tr>
<tr><td><code id="clust.avg.exp_+3A_low.cell.filt">low.cell.filt</code></td>
<td>
<p>filter out clusters with low number of cells, default = 5.</p>
</td></tr>
<tr><td><code id="clust.avg.exp_+3A_round.num">round.num</code></td>
<td>
<p>Rounding of Numbers, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='clust.cond.info'>Calculate cluster and conditions frequencies</h2><span id='topic+clust.cond.info'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and calculates cluster and conditions frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust.cond.info(
  x = NULL,
  plot.type = "pie",
  my.out.put = "data",
  normalize.ncell = TRUE,
  normalize.by = "percentage"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust.cond.info_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="clust.cond.info_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from pie/pie.cond or bar/bar.cond, defult = pie.</p>
</td></tr>
<tr><td><code id="clust.cond.info_+3A_my.out.put">my.out.put</code></td>
<td>
<p>Chose from &quot;data&quot; or &quot;plot&quot;, default = &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="clust.cond.info_+3A_normalize.ncell">normalize.ncell</code></td>
<td>
<p>If TRUE the values will be normalized to the number of cells by downsampling.</p>
</td></tr>
<tr><td><code id="clust.cond.info_+3A_normalize.by">normalize.by</code></td>
<td>
<p>Chose from &quot;sf&quot; (size factor) or &quot;percentage&quot;, default = &quot;percentage&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='clust.ord'>Sort and relabel the clusters randomly or based on pseudotime</h2><span id='topic+clust.ord'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and re-ordersthe clusters based on pseudotime (distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust.ord(
  x = NULL,
  top.rank = 500,
  dist.method = "euclidean",
  clust.method = "complete",
  how.to.order = "distance"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust.ord_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="clust.ord_+3A_top.rank">top.rank</code></td>
<td>
<p>A number. Taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="clust.ord_+3A_dist.method">dist.method</code></td>
<td>
<p>Choose from &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;, default = &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="clust.ord_+3A_clust.method">clust.method</code></td>
<td>
<p>Choose from &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot; or &quot;centroid&quot;, default = &quot;complete&quot;.</p>
</td></tr>
<tr><td><code id="clust.ord_+3A_how.to.order">how.to.order</code></td>
<td>
<p>Choose from &quot;distance&quot; and &quot;random&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='clust.rm'>Remove the cells that are in a cluster</h2><span id='topic+clust.rm'></span>

<h3>Description</h3>

<p>This function removes the cells from a designated cluster. Notice the cells will be removed from the main data (raw data would still have the original data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust.rm(x = NULL, clust.to.rm = "numeric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust.rm_+3A_x">x</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="clust.rm_+3A_clust.to.rm">clust.to.rm</code></td>
<td>
<p>The name of the cluster to be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='clust.stats.plot'>Plotting tSNE, PCA, UMAP, Diffmap and other dim reductions</h2><span id='topic+clust.stats.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and creates QC plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust.stats.plot(
  x = NULL,
  plot.type = "box.mito",
  conds.to.plot = NULL,
  cell.color = "slategray3",
  cell.size = 1,
  cell.transparency = 0.5,
  box.color = "red",
  box.line.col = "green",
  back.col = "white",
  notch = FALSE,
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust.stats.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from &quot;bar.cc&quot;, &quot;pie.cc&quot; , box.umi&quot;, &quot;box.mito&quot;, &quot;box.gene&quot;, default = &quot;box.mito&quot;.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_cell.color">cell.color</code></td>
<td>
<p>Choose a color for points in the plot.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for points in &quot;scatterplot&quot; and &quot;boxplot&quot;, default = 0.5.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_box.color">box.color</code></td>
<td>
<p>A color for the boxes in the &quot;boxplot&quot;, default = &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_box.line.col">box.line.col</code></td>
<td>
<p>A color for the lines around the &quot;boxplot&quot;, default = &quot;green&quot;.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_back.col">back.col</code></td>
<td>
<p>Background color, default = &quot;white&quot;</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_notch">notch</code></td>
<td>
<p>Notch the box plots, default = FALSE.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="clust.stats.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='cluster.plot'>Plot nGenes, UMIs and perecent mito</h2><span id='topic+cluster.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and creates plots to see the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.plot(
  x = NULL,
  cell.size = 0.5,
  plot.type = "tsne",
  cell.color = "black",
  back.col = "white",
  col.by = "clusters",
  cond.facet = FALSE,
  cond.shape = FALSE,
  anno.clust = FALSE,
  anno.size = 4,
  cell.transparency = 1,
  clust.dim = 2,
  angle = 20,
  clonotype.max = 10,
  density = FALSE,
  interactive = TRUE,
  static3D = FALSE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A numeric value for the size of the cells, default = 1.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, &quot;knetl&quot;, &quot;diffusion&quot;, default = &quot;tsne&quot;.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_cell.color">cell.color</code></td>
<td>
<p>Choose cell color if col.by = &quot;monochrome&quot;, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_back.col">back.col</code></td>
<td>
<p>Choose background color, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_col.by">col.by</code></td>
<td>
<p>Choose between &quot;clusters&quot;, &quot;conditions&quot;, &quot;cc&quot; (cell cycle) or &quot;monochrome&quot;, default = &quot;clusters&quot;.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_cond.facet">cond.facet</code></td>
<td>
<p>Show the conditions in separate plots.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_cond.shape">cond.shape</code></td>
<td>
<p>If TRUE the conditions will be shown in shapes.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_anno.clust">anno.clust</code></td>
<td>
<p>Annotate cluster names on the plot, default = TRUE.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_anno.size">anno.size</code></td>
<td>
<p>If anno.clust is TRUE set font size, default = 3.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>A numeric value between 0 to 1, default = 0.5.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_clust.dim">clust.dim</code></td>
<td>
<p>A numeric value for plot dimensions. Choose either 2 or 3, default = 2.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_angle">angle</code></td>
<td>
<p>A number to rotate the non-interactive 3D plot.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_clonotype.max">clonotype.max</code></td>
<td>
<p>Number of clonotype to plot, default = 10.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_density">density</code></td>
<td>
<p>If TRUE the density plots for PCA/tSNE second dimension will be created, default = FALSE.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_interactive">interactive</code></td>
<td>
<p>If TRUE an html interactive file will be made, default = TRUE.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_static3d">static3D</code></td>
<td>
<p>If TRUE a non-interactive 3D plot will be made.</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_out.name">out.name</code></td>
<td>
<p>Output name for html file if interactive = TRUE, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='data.aggregation'>Merge multiple data frames and add the condition names to their cell ids</h2><span id='topic+data.aggregation'></span>

<h3>Description</h3>

<p>This function takes data frame and merges them while also adding condition names to cell ids..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.aggregation(samples = NULL, condition.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.aggregation_+3A_samples">samples</code></td>
<td>
<p>A character vector of data.frame object names.</p>
</td></tr>
<tr><td><code id="data.aggregation_+3A_condition.names">condition.names</code></td>
<td>
<p>A character vector of data.frame condition names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo &lt;- read.table(
        file = system.file('extdata', 'demo_data.txt', package = 'iCellR'),
        as.is = TRUE)

# Lets divide your sample in to 3 samples as if you have 3 samples and want to merge them.
sample1 &lt;- demo[1:30]
sample2 &lt;- demo[31:60]
sample3 &lt;- demo[61:90]

# merge all 3 data and add condition names
demo &lt;- data.aggregation(samples =
        c("sample1","sample2","sample3"),
        condition.names = c("WT","ctrl","KO"))
head(demo)[1:4]

# make iCellR object
myDemo.obj &lt;- make.obj(demo)
</code></pre>

<hr>
<h2 id='data.scale'>Scale data</h2><span id='topic+data.scale'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and scales the normalized data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.scale(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.scale_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='down.sample'>Down sample conditions</h2><span id='topic+down.sample'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and down samples the condition to have equal number of cells in each condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>down.sample(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="down.sample_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='find_neighbors'>K Nearest Neighbour Search</h2><span id='topic+find_neighbors'></span>

<h3>Description</h3>

<p>Uses a kd-tree to find the p number of near neighbours for each point in an input/output dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_neighbors(data, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_neighbors_+3A_data">data</code></td>
<td>
<p>matrix; input data matrix</p>
</td></tr>
<tr><td><code id="find_neighbors_+3A_k">k</code></td>
<td>
<p>integer; number of nearest neighbours</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the nn2 function from the RANN package, utilizes the Approximate Near Neighbor (ANN) C++ library,
which can give the exact near neighbours or (as the name suggests) approximate near neighbours
to within a specified error bound. For more information on the ANN library please
visit http://www.cs.umd.edu/~mount/ANN/.
</p>

<hr>
<h2 id='find.dim.genes'>Find model genes from PCA data</h2><span id='topic+find.dim.genes'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR finds the model genes to run a second round of PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.dim.genes(x = NULL, dims = 1:10, top.pos = 15, top.neg = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.dim.genes_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="find.dim.genes_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used.</p>
</td></tr>
<tr><td><code id="find.dim.genes_+3A_top.pos">top.pos</code></td>
<td>
<p>Number of top positive marker genes to be taken from each PC, default = 15.</p>
</td></tr>
<tr><td><code id="find.dim.genes_+3A_top.neg">top.neg</code></td>
<td>
<p>Number of top negative marker genes to be taken from each PC, default = 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='findMarkers'>Find marker genes for each cluster</h2><span id='topic+findMarkers'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and performs differential expression (DE) analysis to find marker genes for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMarkers(
  x = NULL,
  data.type = "main",
  pval.test = "t.test",
  p.adjust.method = "hochberg",
  fold.change = 2,
  padjval = 0.1,
  low.cell.filt = 5,
  Inf.FCs = FALSE,
  uniq = FALSE,
  positive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMarkers_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot;, &quot;atac&quot;, &quot;atac.imputed&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_pval.test">pval.test</code></td>
<td>
<p>Choose from &quot;t.test&quot;, &quot;wilcox.test&quot;, default = &quot;t.test&quot;.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Correction method. Choose from &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;, default = &quot;hochberg&quot;.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_fold.change">fold.change</code></td>
<td>
<p>A number that designates the minimum fold change for out put, default = 2.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_padjval">padjval</code></td>
<td>
<p>Minimum adjusted p value for out put, default = 0.1.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_low.cell.filt">low.cell.filt</code></td>
<td>
<p>filter out clusters with low number of cells, default = 5.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_inf.fcs">Inf.FCs</code></td>
<td>
<p>If set to FALSE the infinite fold changes would be filtered from out put, default = FALSE.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_uniq">uniq</code></td>
<td>
<p>If set to TRUE only genes that are a marker for only one cluster would be in the out put, default = FALSE.</p>
</td></tr>
<tr><td><code id="findMarkers_+3A_positive">positive</code></td>
<td>
<p>If set to FALSE both the up regulated (positive) and down regulated (negative) markers would be in the out put, default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='g2m.phase'>A dataset of G2 and M phase genes</h2><span id='topic+g2m.phase'></span>

<h3>Description</h3>

<p>A dataset containing the genes for G2 and M phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g2m.phase
</code></pre>


<h3>Format</h3>

<p>A character with 54 genes
</p>


<h3>Source</h3>

<p><a href="https://www.science.org/doi/abs/10.1126/science.aad0501">https://www.science.org/doi/abs/10.1126/science.aad0501</a>
</p>

<hr>
<h2 id='gate.to.clust'>Assign cluster number to cell ids</h2><span id='topic+gate.to.clust'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and assigns cluster number to a vector of cell ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gate.to.clust(x = NULL, my.gate = NULL, to.clust = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gate.to.clust_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="gate.to.clust_+3A_my.gate">my.gate</code></td>
<td>
<p>A vector of cell ids.</p>
</td></tr>
<tr><td><code id="gate.to.clust_+3A_to.clust">to.clust</code></td>
<td>
<p>A cluster id to be assigned to the provided cell ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='gene.plot'>Make scatter, box and bar plots for genes</h2><span id='topic+gene.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and provides plots for genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene.plot(
  x = NULL,
  gene = NULL,
  cond.shape = FALSE,
  conds.to.plot = NULL,
  data.type = "main",
  box.to.test = 0,
  box.pval = "sig.signs",
  plot.data.type = "tsne",
  scaleValue = TRUE,
  min.scale = 0,
  max.scale = 2.5,
  clust.dim = 2,
  col.by = "clusters",
  plot.type = "scatterplot",
  cell.size = 1,
  cell.colors = c("gray", "red"),
  box.cell.col = "black",
  box.color = "red",
  box.line.col = "green",
  back.col = "white",
  cell.transparency = 1,
  box.transparency = 0.5,
  interactive = TRUE,
  out.name = "plot",
  write.data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_gene">gene</code></td>
<td>
<p>Gene name/names to be plotted.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_cond.shape">cond.shape</code></td>
<td>
<p>If TRUE the conditions will be shown in shapes.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot;, &quot;atac, &quot;atac.imputed&quot; and &quot;imputed&quot;, default = &quot;main&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.to.test">box.to.test</code></td>
<td>
<p>A cluster number so that all the boxes in the box plot would be compared to. If set to &quot;0&quot; the cluster with the highest avrage would be choosen, default = 0.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.pval">box.pval</code></td>
<td>
<p>Choose from &quot;sig.values&quot; and &quot;sig.signs&quot;. If set to &quot;sig.signs&quot; p values would be replaced with signs (&quot;na&quot;, &quot;*&quot;, &quot;**&quot;, &quot;***&quot;), default = &quot;sig.signs&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_plot.data.type">plot.data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, &quot;knetl&quot;, &quot;diffusion&quot;, &quot;pseudo.A&quot; and &quot;pseudo.B&quot;, default = &quot;tsne&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_scalevalue">scaleValue</code></td>
<td>
<p>Scale the colors, default = FALSE.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_min.scale">min.scale</code></td>
<td>
<p>If scaleValue = TRUE, set a number for min, default = -2.5.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_max.scale">max.scale</code></td>
<td>
<p>If scaleValue = TRUE, set a number for max, default = 2.5.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_clust.dim">clust.dim</code></td>
<td>
<p>2 for 2D plots and 3 for 3D plots, default = 2.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_col.by">col.by</code></td>
<td>
<p>Choose from &quot;clusters&quot; and &quot;conditions&quot;, default = &quot;clusters&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from &quot;scatterplot&quot;, &quot;boxplot&quot; and &quot;barplot&quot;, default = &quot;scatterplot&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_cell.colors">cell.colors</code></td>
<td>
<p>Colors for heat mapping the points in &quot;scatterplot&quot;, default = c(&quot;gray&quot;,&quot;red&quot;).</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.cell.col">box.cell.col</code></td>
<td>
<p>A color for the points in the box plot, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.color">box.color</code></td>
<td>
<p>A color for the boxes in the &quot;boxplot&quot;, default = &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.line.col">box.line.col</code></td>
<td>
<p>A color for the lines around the &quot;boxplot&quot;, default = &quot;green&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_back.col">back.col</code></td>
<td>
<p>A color for the plot background, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for points in &quot;scatterplot&quot; and &quot;boxplot&quot;, default = 1.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_box.transparency">box.transparency</code></td>
<td>
<p>Color transparency for box in &quot;boxplot&quot;, default = 0.5.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="gene.plot_+3A_write.data">write.data</code></td>
<td>
<p>Write export the data used for the plot plot, default = TFALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='gene.stats'>Make statistical information for each gene across all the cells (SD, mean, expression, etc.)</h2><span id='topic+gene.stats'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and provides some statistical information for the genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene.stats(x = NULL, which.data = "raw.data", each.cond = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene.stats_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="gene.stats_+3A_which.data">which.data</code></td>
<td>
<p>Choose from &quot;raw.data&quot; or &quot;main.data&quot;, default = &quot;raw.data&quot;.</p>
</td></tr>
<tr><td><code id="gene.stats_+3A_each.cond">each.cond</code></td>
<td>
<p>If TRUE each condition will be calculated, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='gg.cor'>Gene-gene correlation.
This function helps to visulaize and calculate gene-gene correlations.</h2><span id='topic+gg.cor'></span>

<h3>Description</h3>

<p>Gene-gene correlation.
This function helps to visulaize and calculate gene-gene correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.cor(
  x = NULL,
  data.type = "imputed",
  gene1 = NULL,
  gene2 = NULL,
  conds = NULL,
  clusts = NULL,
  cell.size = 1,
  cell.transparency = 0.5,
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.cor_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_data.type">data.type</code></td>
<td>
<p>Choose from imputed and main, default = &quot;imputed&quot;.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_gene1">gene1</code></td>
<td>
<p>First gene name.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_gene2">gene2</code></td>
<td>
<p>Second gene name.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_conds">conds</code></td>
<td>
<p>Filter only one condition (only one), default is all conditions.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_clusts">clusts</code></td>
<td>
<p>Choose clusters to plot.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_cell.size">cell.size</code></td>
<td>
<p>A numeric value for the size of the cells, default = 1.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>A numeric value between 0 to 1, default = 0.5.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_interactive">interactive</code></td>
<td>
<p>If TRUE an html interactive file will be made, default = TRUE.</p>
</td></tr>
<tr><td><code id="gg.cor_+3A_out.name">out.name</code></td>
<td>
<p>Output name for html file if interactive = TRUE, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='heatmap.gg.plot'>Create heatmaps for genes in clusters or conditions.</h2><span id='topic+heatmap.gg.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and genes and provides a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.gg.plot(
  x = NULL,
  gene = "NULL",
  cell.sort = FALSE,
  data.type = "main",
  cluster.by = "clusters",
  conds.to.plot = NULL,
  min.scale = -2.5,
  max.scale = 2.5,
  interactive = TRUE,
  cex.col = 10,
  cex.row = 10,
  no.key = FALSE,
  out.name = "plot",
  heat.colors = c("blue", "white", "red")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap.gg.plot_+3A_x">x</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_gene">gene</code></td>
<td>
<p>A set of gene names to be heatmapped.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_cell.sort">cell.sort</code></td>
<td>
<p>If FALSE the cells will not be sorted based on their distance, default = TRUE.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot;, &quot;atac&quot;, atac.imputed and &quot;imputed&quot;, default = &quot;main&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_cluster.by">cluster.by</code></td>
<td>
<p>Choose from &quot;clusters&quot; or &quot;none&quot;, default = &quot;clusters&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_min.scale">min.scale</code></td>
<td>
<p>Set a minimum color scale, default = -2.5.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_max.scale">max.scale</code></td>
<td>
<p>Set a maximum color scale, default = 2.5.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_interactive">interactive</code></td>
<td>
<p>If TRUE an html interactive file will be made, default = TRUE.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_cex.col">cex.col</code></td>
<td>
<p>Chhose a size, default = 10.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_cex.row">cex.row</code></td>
<td>
<p>Choose a size, default = 10.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_no.key">no.key</code></td>
<td>
<p>If you want a color legend key, default = FALSE.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_out.name">out.name</code></td>
<td>
<p>Output name for html file if interactive = TRUE, default = &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.gg.plot_+3A_heat.colors">heat.colors</code></td>
<td>
<p>Colors for heatmap, default = c(&quot;blue&quot; ,&quot;white&quot;, &quot;red&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='hto.anno'>Demultiplexing HTOs</h2><span id='topic+hto.anno'></span>

<h3>Description</h3>

<p>Demultiplexing HTOs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hto.anno(hto.data = "data.frame", cov.thr = 10, assignment.thr = 80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hto.anno_+3A_hto.data">hto.data</code></td>
<td>
<p>HTO raw data</p>
</td></tr>
<tr><td><code id="hto.anno_+3A_cov.thr">cov.thr</code></td>
<td>
<p>A number which average coverage is divided by to set a threshold for low coverage. For example 10 means it is 10 time less than the average. default = 10.</p>
</td></tr>
<tr><td><code id="hto.anno_+3A_assignment.thr">assignment.thr</code></td>
<td>
<p>A percent above which you decide to set as a good sample assignment/HTO, default = 80.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='i.score'>Cell cycle phase prediction</h2><span id='topic+i.score'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and assignes cell cycle stage for the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i.score(
  object = NULL,
  data.type = "main.data",
  scoring.List = NULL,
  return.stats = TRUE,
  scoring.method = "tirosh"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i.score_+3A_object">object</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="i.score_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;raw.data&quot; or &quot;main.data&quot;, &quot;imputed.data&quot;, default = &quot;main.data&quot;.</p>
</td></tr>
<tr><td><code id="i.score_+3A_scoring.list">scoring.List</code></td>
<td>
<p>Genes that are used as a marker for phases.</p>
</td></tr>
<tr><td><code id="i.score_+3A_return.stats">return.stats</code></td>
<td>
<p>Return the data or object. If FALSE the object would be returned.</p>
</td></tr>
<tr><td><code id="i.score_+3A_scoring.method">scoring.method</code></td>
<td>
<p>Choose from &quot;tirosh (Tirosh, et. al. 2016), mean, sum, gsva, ssgsea, zscore and plage. , default = &quot;tirosh&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>

<hr>
<h2 id='iba'>iCellR Batch Alignment (IBA)</h2><span id='topic+iba'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs CCCA or CPCA batch alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iba(
  x = NULL,
  dims = 1:30,
  k = 10,
  ba.method = "CPCA",
  method = "base.mean.rank",
  top.rank = 500,
  plus.log.value = 0.1,
  scale.data = TRUE,
  gene.list = "character"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iba_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="iba_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used</p>
</td></tr>
<tr><td><code id="iba_+3A_k">k</code></td>
<td>
<p>number of neighboring cells for KNN, default = 10.</p>
</td></tr>
<tr><td><code id="iba_+3A_ba.method">ba.method</code></td>
<td>
<p>Batch alignment method. Choose from &quot;CCCA&quot; and &quot;CPCA&quot;, default = &quot;CPCA&quot;.</p>
</td></tr>
<tr><td><code id="iba_+3A_method">method</code></td>
<td>
<p>Choose from &quot;base.mean.rank&quot; or &quot;gene.model&quot;, default is &quot;base.mean.rank&quot;. If gene.model is chosen you need to provide gene.list.</p>
</td></tr>
<tr><td><code id="iba_+3A_top.rank">top.rank</code></td>
<td>
<p>A number. Taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="iba_+3A_plus.log.value">plus.log.value</code></td>
<td>
<p>A number to add to each value in the matrix before log transformasion to aviond Inf numbers, default = 0.1.</p>
</td></tr>
<tr><td><code id="iba_+3A_scale.data">scale.data</code></td>
<td>
<p>If TRUE the data will be scaled (log2 + plus.log.value), default = TRUE.</p>
</td></tr>
<tr><td><code id="iba_+3A_gene.list">gene.list</code></td>
<td>
<p>A charactor vector of genes to be used for PCA. If &quot;clust.method&quot; is set to &quot;gene.model&quot;, default = &quot;my_model_genes.txt&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='iclust'>iCellR Clustering</h2><span id='topic+iclust'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and finds optimal number of clusters and clusters the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iclust(
  x = NULL,
  dist.method = "euclidean",
  sensitivity = 100,
  data.type = "pca",
  dims = 1:10,
  return.graph = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iclust_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="iclust_+3A_dist.method">dist.method</code></td>
<td>
<p>the distance measure to be used to compute the dissimilarity matrix. This must be one of: &quot;euclidean&quot;, &quot;maximum&quot;, &quot;mandatattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; or &quot;NULL&quot;. By default, distance=&quot;euclidean&quot;. If the distance is &quot;NULL&quot;, the dissimilarity matrix (diss) should be given by the user. If distance is not &quot;NULL&quot;, the dissimilarity matrix should be &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="iclust_+3A_sensitivity">sensitivity</code></td>
<td>
<p>The higher the number the less sensitivity, default = 100.</p>
</td></tr>
<tr><td><code id="iclust_+3A_data.type">data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, default = &quot;pca&quot;.</p>
</td></tr>
<tr><td><code id="iclust_+3A_dims">dims</code></td>
<td>
<p>PCA dimentions to be use for clustering, default = 1:10.</p>
</td></tr>
<tr><td><code id="iclust_+3A_return.graph">return.graph</code></td>
<td>
<p>return igraph object, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='load.h5'>Load h5 data as data.frame</h2><span id='topic+load.h5'></span>

<h3>Description</h3>

<p>This function reads hdf5 files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.h5(filename, feature.names = TRUE, uniq.rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.h5_+3A_filename">filename</code></td>
<td>
<p>path to the input (h5) file</p>
</td></tr>
<tr><td><code id="load.h5_+3A_feature.names">feature.names</code></td>
<td>
<p>row names to be feature names or ID numbers.</p>
</td></tr>
<tr><td><code id="load.h5_+3A_uniq.rows">uniq.rows</code></td>
<td>
<p>make row names unique.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>

<hr>
<h2 id='load10x'>Load 10X data as data.frame</h2><span id='topic+load10x'></span>

<h3>Description</h3>

<p>This function takes 10X data files barcodes.tsv, genes.tsv and matrix.mtx and converts them to proper matrix file for iCellR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load10x(dir.10x = NULL, gene.name = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load10x_+3A_dir.10x">dir.10x</code></td>
<td>
<p>A directory that includes the 10X barcodes.tsv, genes.tsv and matrix.mtx files.</p>
</td></tr>
<tr><td><code id="load10x_+3A_gene.name">gene.name</code></td>
<td>
<p>Gene names or ids column number, default = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.data &lt;- load10x(system.file("extdata", "filtered_gene_bc_matrices", package = "iCellR"))

# See first few rows and columns
head(my.data)[1:5]

</code></pre>

<hr>
<h2 id='make.bed'>Make BED Files</h2><span id='topic+make.bed'></span>

<h3>Description</h3>

<p>This function takes peak marker files and makes the bed files per cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bed(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bed_+3A_x">x</code></td>
<td>
<p>Peak marker file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bed files
</p>

<hr>
<h2 id='make.gene.model'>Make a gene model for clustering</h2><span id='topic+make.gene.model'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and provides a gene list for clustering based on the parameters set in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.gene.model(
  x = NULL,
  dispersion.limit = 1.5,
  base.mean.rank = 500,
  gene.num.max = 2000,
  non.sig.col = "darkgray",
  right.sig.col = "chartreuse3",
  left.sig.col = "cadetblue3",
  disp.line.col = "black",
  rank.line.col = "red",
  my.out.put = "data",
  cell.size = 1.75,
  cell.transparency = 0.5,
  no.mito.model = TRUE,
  no.cell.cycle = TRUE,
  mark.mito = TRUE,
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.gene.model_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_dispersion.limit">dispersion.limit</code></td>
<td>
<p>A number for taking the genes that have dispersion above this number, default = 1.5.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_base.mean.rank">base.mean.rank</code></td>
<td>
<p>A number taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_gene.num.max">gene.num.max</code></td>
<td>
<p>Maximum number of genes , default = 2000.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_non.sig.col">non.sig.col</code></td>
<td>
<p>Color for the genes not used for the model, default = &quot;darkgray&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_right.sig.col">right.sig.col</code></td>
<td>
<p>Color for the genes above the dispersion limit, default = &quot;chartreuse3&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_left.sig.col">left.sig.col</code></td>
<td>
<p>Color for the genes above the rank limit, default = &quot;cadetblue3&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_disp.line.col">disp.line.col</code></td>
<td>
<p>Color of the line for dispersion limit, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_rank.line.col">rank.line.col</code></td>
<td>
<p>Color of the line for rank limit, default = &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_my.out.put">my.out.put</code></td>
<td>
<p>Chose from &quot;data&quot; or &quot;plot&quot;, default = &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_cell.size">cell.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.75.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for the points in the plot, default = 0.5.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_no.mito.model">no.mito.model</code></td>
<td>
<p>If set to TRUE, mitochondrial genes would be excluded from the gene list made for clustering, default = TRUE.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_no.cell.cycle">no.cell.cycle</code></td>
<td>
<p>If TRUE the cell cycle genes will be removed (s.phase and g2m.phase), default = TRUE.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_mark.mito">mark.mito</code></td>
<td>
<p>Mark mitochondrial genes in the plot, default = TRUE.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="make.gene.model_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='make.obj'>Create an object of class iCellR.</h2><span id='topic+make.obj'></span>

<h3>Description</h3>

<p>This function takes data frame and makes an object of class iCellR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.obj(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.obj_+3A_x">x</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     demo &lt;- read.table(
     file = system.file('extdata', 'demo_data.txt', package = 'iCellR'),
     as.is = TRUE)
     myDemo.obj &lt;- make.obj(demo)
     myDemo.obj
</code></pre>

<hr>
<h2 id='myImp'>Impute data</h2><span id='topic+myImp'></span>

<h3>Description</h3>

<p>This function imputes data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myImp(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myImp_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='norm.adt'>Normalize ADT data.
This function takes data frame and Normalizes ADT data.</h2><span id='topic+norm.adt'></span>

<h3>Description</h3>

<p>Normalize ADT data.
This function takes data frame and Normalizes ADT data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.adt(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.adt_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='norm.data'>Normalize data</h2><span id='topic+norm.data'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and normalized the data based on &quot;global.glsf&quot;, &quot;ranked.glsf&quot; or &quot;spike.in&quot; methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.data(
  x = NULL,
  norm.method = "ranked.glsf",
  top.rank = 500,
  spike.in.factors = NULL,
  rpm.factor = 1000,
  rounding.digits = 3,
  round.num = TRUE,
  ATAC.data = FALSE,
  ATAC.filter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.data_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_norm.method">norm.method</code></td>
<td>
<p>Choose a normalization method, there are three option currently.
Choose from &quot;global.glsf&quot;, &quot;ranked.glsf&quot;,&quot;spike.in&quot; or no.norm, default = &quot;ranked.glsf&quot;.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_top.rank">top.rank</code></td>
<td>
<p>If the method is set to &quot;ranked.glsf&quot;, you need to set top number of genes sorted based on global base mean, default = 500.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_spike.in.factors">spike.in.factors</code></td>
<td>
<p>A numeric vector of spike-in values with the same cell id order as the main data.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_rpm.factor">rpm.factor</code></td>
<td>
<p>If the norm.method is set to &quot;rpm&quot; the library sizes would be divided by this number, default = 1000 (higher numbers recomanded for bulk RNA-Seq).</p>
</td></tr>
<tr><td><code id="norm.data_+3A_rounding.digits">rounding.digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) or significant digits (signif) to be used.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_round.num">round.num</code></td>
<td>
<p>Rounding of Numbers, default = FALSE.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_atac.data">ATAC.data</code></td>
<td>
<p>If TURE, it would normalize ATAC-Seq data and not RNA-Seq, default = FALSE.</p>
</td></tr>
<tr><td><code id="norm.data_+3A_atac.filter">ATAC.filter</code></td>
<td>
<p>If TURE, all the cells filtered in RNA-Seq will be filtered in ATAC-Seq. This needs to be done for both data to match,  default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='opt.pcs.plot'>Find optimal number of PCs for clustering</h2><span id='topic+opt.pcs.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and finds optimal number of PCs for clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.pcs.plot(x = NULL, pcs.in.plot = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.pcs.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="opt.pcs.plot_+3A_pcs.in.plot">pcs.in.plot</code></td>
<td>
<p>Number of PCs to show in plot, defult = 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='prep.vdj'>Prepare VDJ data</h2><span id='topic+prep.vdj'></span>

<h3>Description</h3>

<p>This function takes a data frame of VDJ data per cell and prepares it to adds it to the iCellR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.vdj(vdj.data = "data.frame", cond.name = "NULL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.vdj_+3A_vdj.data">vdj.data</code></td>
<td>
<p>A data frame containing vdj information.</p>
</td></tr>
<tr><td><code id="prep.vdj_+3A_cond.name">cond.name</code></td>
<td>
<p>Conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='pseudotime'>Pseudotime</h2><span id='topic+pseudotime'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and marker genes for clusters and performs pseudotime analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudotime(x = NULL, marker.genes = "NULL", dims = 1:10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudotime_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="pseudotime_+3A_marker.genes">marker.genes</code></td>
<td>
<p>A list of marker genes for clusters.</p>
</td></tr>
<tr><td><code id="pseudotime_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used, , default = 1:10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='pseudotime.knetl'>iCellR KNN Network</h2><span id='topic+pseudotime.knetl'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and and runs kNet for dimensionality reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudotime.knetl(
  x = NULL,
  dist.method = "euclidean",
  k = 5,
  abstract = TRUE,
  data.type = "pca",
  dims = 1:20,
  conds.to.plot = NULL,
  my.layout = "layout_with_fr",
  node.size = 10,
  cluster.membership = FALSE,
  interactive = TRUE,
  node.colors = NULL,
  edge.color = "gray",
  out.name = "Pseudotime.Abstract.KNetL",
  my.seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudotime.knetl_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_dist.method">dist.method</code></td>
<td>
<p>the distance measure to be used to compute the dissimilarity matrix. This must be one of: &quot;euclidean&quot;, &quot;maximum&quot;, &quot;mandatattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; or &quot;NULL&quot;. By default, distance=&quot;euclidean&quot;. If the distance is &quot;NULL&quot;, the dissimilarity matrix (diss) should be given by the user. If distance is not &quot;NULL&quot;, the dissimilarity matrix should be &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_k">k</code></td>
<td>
<p>KNN the higher the number the less sensitivity, default = 5.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_abstract">abstract</code></td>
<td>
<p>Draw all the cells or clusters, , default = TRUE.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_data.type">data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, default = &quot;pca&quot;. We highly recommend PCA.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_dims">dims</code></td>
<td>
<p>PCA dimentions to be use for clustering, default = 1:20.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_my.layout">my.layout</code></td>
<td>
<p>Choose a layout, default = &quot;layout_with_fr&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_node.size">node.size</code></td>
<td>
<p>Size of the nodes, , default = 10.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_cluster.membership">cluster.membership</code></td>
<td>
<p>Calculate memberships based on distance.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_node.colors">node.colors</code></td>
<td>
<p>Color of the nodes, default = random colors.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_edge.color">edge.color</code></td>
<td>
<p>Solor of the edges, default = &quot;gray&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;Abstract.KNetL&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.knetl_+3A_my.seed">my.seed</code></td>
<td>
<p>seed number, default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>

<hr>
<h2 id='pseudotime.tree'>Pseudotime Tree</h2><span id='topic+pseudotime.tree'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and marker genes for clusters and performs pseudotime for differentiation or time course analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudotime.tree(
  x = NULL,
  marker.genes = "NULL",
  clust.names = "NULL",
  dist.method = "euclidean",
  clust.method = "complete",
  label.offset = 0.5,
  type = "classic",
  hang = 1,
  cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudotime.tree_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_marker.genes">marker.genes</code></td>
<td>
<p>A list of marker genes for clusters.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_clust.names">clust.names</code></td>
<td>
<p>A list of names for clusters.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_dist.method">dist.method</code></td>
<td>
<p>Choose from &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;, default = &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_clust.method">clust.method</code></td>
<td>
<p>Choose from &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot; or &quot;centroid&quot;, default = &quot;complete&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_label.offset">label.offset</code></td>
<td>
<p>Space between names and tree, default = 0.5.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_type">type</code></td>
<td>
<p>Choose from &quot;classic&quot;, &quot;jitter&quot;, &quot;unrooted&quot;, &quot;fan&quot;, &quot;cladogram&quot;, &quot;radial&quot;, default = &quot;classic&quot;.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_hang">hang</code></td>
<td>
<p>Hang, default = 1.</p>
</td></tr>
<tr><td><code id="pseudotime.tree_+3A_cex">cex</code></td>
<td>
<p>Text size, default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='qc.stats'>Calculate the number of UMIs and genes per cell and percentage of mitochondrial genes per cell and cell cycle genes.</h2><span id='topic+qc.stats'></span>

<h3>Description</h3>

<p>This function takes data frame and calculates the number of UMIs, genes per cell and percentage of mitochondrial genes per cell and cell cycle genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.stats(
  x = NULL,
  which.data = "raw.data",
  mito.genes = NULL,
  s.phase.genes = s.phase,
  g2m.phase.genes = g2m.phase
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc.stats_+3A_x">x</code></td>
<td>
<p>A data frame containing gene counts for cells.</p>
</td></tr>
<tr><td><code id="qc.stats_+3A_which.data">which.data</code></td>
<td>
<p>Choose from &quot;raw.data&quot; or &quot;main.data&quot;, &quot;imputed.data&quot;, default = &quot;raw.data&quot;.</p>
</td></tr>
<tr><td><code id="qc.stats_+3A_mito.genes">mito.genes</code></td>
<td>
<p>A character vector of mitochondrial  genes names , default is the genes starting with mt.</p>
</td></tr>
<tr><td><code id="qc.stats_+3A_s.phase.genes">s.phase.genes</code></td>
<td>
<p>A character vector of gene names for S phase, default = s.phase.</p>
</td></tr>
<tr><td><code id="qc.stats_+3A_g2m.phase.genes">g2m.phase.genes</code></td>
<td>
<p>A character vector of gene names for G2 and M phase, default = g2m.phase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame object
</p>

<hr>
<h2 id='Rphenograph'>RphenoGraph clustering</h2><span id='topic+Rphenograph'></span>

<h3>Description</h3>

<p>R implementation of the PhenoGraph algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rphenograph(data, k = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rphenograph_+3A_data">data</code></td>
<td>
<p>matrix; input data matrix</p>
</td></tr>
<tr><td><code id="Rphenograph_+3A_k">k</code></td>
<td>
<p>integer; number of nearest neighbours (default:30)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple R implementation of the [PhenoGraph](http://www.cell.com/cell/abstract/S0092-8674(15)00637-6) algorithm,
which is a clustering method designed for high-dimensional single-cell data analysis. It works by creating a graph (&quot;network&quot;) representing
phenotypic similarities between cells by calclating the Jaccard coefficient between nearest-neighbor sets, and then identifying communities
using the well known [Louvain method](https://sites.google.com/site/findcommunities/) in this graph.
</p>


<h3>Value</h3>

<p>a list contains an igraph graph object for <code>graph_from_data_frame</code> and a communities object, the operations of this class contains:
</p>
<table>
<tr><td><code>print</code></td>
<td>
<p>returns the communities object itself, invisibly.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>returns an integer scalar.</p>
</td></tr>
<tr><td><code>sizes</code></td>
<td>
<p>returns a numeric vector.</p>
</td></tr>
<tr><td><code>membership</code></td>
<td>
<p>returns a numeric vector, one number for each vertex in the graph that was the input of the community detection.</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>
<p>returns a numeric scalar.</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>returns a character scalar.</p>
</td></tr>
<tr><td><code>crossing</code></td>
<td>
<p>returns a logical vector.</p>
</td></tr>
<tr><td><code>is_hierarchical</code></td>
<td>
<p>returns a logical scalar.</p>
</td></tr>
<tr><td><code>merges</code></td>
<td>
<p>returns a two-column numeric matrix.</p>
</td></tr>
<tr><td><code>cut_at</code></td>
<td>
<p>returns a numeric vector, the membership vector of the vertices.</p>
</td></tr>
<tr><td><code>as.dendrogram</code></td>
<td>
<p>returns a dendrogram object.</p>
</td></tr>
<tr><td><code>show_trace</code></td>
<td>
<p>returns a character vector.</p>
</td></tr>
<tr><td><code>code_len</code></td>
<td>
<p>returns a numeric scalar for communities found with the InfoMAP method and NULL for other methods.</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>for communities objects returns NULL, invisibly.</p>
</td></tr>
</table>


<h3>Source</h3>

<p><a href="https://github.com/JinmiaoChenLab/Rphenograph">https://github.com/JinmiaoChenLab/Rphenograph</a>
</p>


<h3>References</h3>

<p>Jacob H. Levine and et.al. Data-Driven Phenotypic Dissection of AML Reveals Progenitor-like Cells that Correlate with Prognosis. Cell, 2015.
</p>

<hr>
<h2 id='run.anchor'>Run anchor alignment on the main data.</h2><span id='topic+run.anchor'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs anchor alignment. It's a wrapper for Seurat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.anchor(
  x = NULL,
  method = "base.mean.rank",
  top.rank = 500,
  gene.list = "character",
  data.type = "main",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  block.size = NULL,
  selection.method = "vst",
  nfeatures = 2000,
  anchor.features = 2000,
  scale = TRUE,
  sct.clip.range = NULL,
  reduction = c("cca", "rpca"),
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "rann",
  eps = 0,
  k.weight = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.anchor_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_method">method</code></td>
<td>
<p>Choose from &quot;base.mean.rank&quot; or &quot;gene.model&quot;, default is &quot;base.mean.rank&quot;. If gene.model is chosen you need to provide gene.list.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_top.rank">top.rank</code></td>
<td>
<p>A number taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_gene.list">gene.list</code></td>
<td>
<p>A charactor vector of genes to be used for PCA. If &quot;clust.method&quot; is set to &quot;gene.model&quot;, default = &quot;my_model_genes.txt&quot;.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Choose from &quot;LogNormalize&quot;, &quot;CLR&quot; and &quot;RC&quot;. LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p. CLR: Applies a centered log ratio transformation. RC: Relative counts. Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. No log-transformation is applied. For counts per million (CPM) set scale.factor = 1e6</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Sets the scale factor for cell-level normalization.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_margin">margin</code></td>
<td>
<p>If performing CLR normalization, normalize across features (1) or cells (2)</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_block.size">block.size</code></td>
<td>
<p>How many cells should be run in each chunk, will try to split evenly across threads</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_selection.method">selection.method</code></td>
<td>
<p>Choose from &quot;vst&quot;,&quot;mean.var.plot (mvp)&quot;,&quot;dispersion (disp)&quot;.</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to select as top variable features; only used when selection.method is set to 'dispersion' or 'vst'</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_anchor.features">anchor.features</code></td>
<td>
<p>A numeric value. This will call SelectIntegrationFeatures to select the provided number of features to be used in anchor finding</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_scale">scale</code></td>
<td>
<p>Whether or not to scale the features provided. Only set to FALSE if you have previously scaled the features you want to use for each object in the object.list</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_sct.clip.range">sct.clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the Pearson residual will be clipped to</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_reduction">reduction</code></td>
<td>
<p>cca: Canonical correlation analysis. rpca: Reciprocal PCA</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Perform L2 normalization on the CCA cell embeddings after dimensional reduction</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use from the CCA to specify the neighbor search space</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_k.filter">k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_k.score">k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_max.features">max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the neighborhood search space in the anchor filtering</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_nn.method">nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann, annoy</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from RANN)</p>
</td></tr>
<tr><td><code id="run.anchor_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.cca'>Run CCA on the main data</h2><span id='topic+run.cca'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs CCA using Seurat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.cca(
  x = NULL,
  top.vari.genes = 1000,
  cc.number = 30,
  dims.align = 1:20,
  normalize.data = TRUE,
  scale.data = TRUE,
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  display.progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.cca_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_top.vari.genes">top.vari.genes</code></td>
<td>
<p>Chose top genes to use for CCA, default = 1000.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_cc.number">cc.number</code></td>
<td>
<p>Choose a number, default = 30.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_dims.align">dims.align</code></td>
<td>
<p>Choose the CCA dimentions to align, default = 1:20.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_normalize.data">normalize.data</code></td>
<td>
<p>TRUE or FALSE, default = TRUE.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_scale.data">scale.data</code></td>
<td>
<p>TRUE or FALSE, default = TRUE.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Choose a method, default = &quot;LogNormalize&quot;.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Scaling factor, default = 10000.</p>
</td></tr>
<tr><td><code id="run.cca_+3A_display.progress">display.progress</code></td>
<td>
<p>Show progress, default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.clustering'>Clustering the data</h2><span id='topic+run.clustering'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and finds optimal number of clusters and clusters the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.clustering(
  x = NULL,
  clust.method = "kmeans",
  dist.method = "euclidean",
  index.method = "silhouette",
  max.clust = 25,
  min.clust = 2,
  dims = 1:10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.clustering_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_clust.method">clust.method</code></td>
<td>
<p>the cluster analysis method to be used. This should be one of: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_dist.method">dist.method</code></td>
<td>
<p>the distance measure to be used to compute the dissimilarity matrix. This must be one of: &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; or &quot;NULL&quot;. By default, distance=&quot;euclidean&quot;. If the distance is &quot;NULL&quot;, the dissimilarity matrix (diss) should be given by the user. If distance is not &quot;NULL&quot;, the dissimilarity matrix should be &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_index.method">index.method</code></td>
<td>
<p>the index to be calculated. This should be one of : &quot;kl&quot;, &quot;ch&quot;, &quot;hartigan&quot;, &quot;ccc&quot;, &quot;scott&quot;, &quot;marriot&quot;, &quot;trcovw&quot;, &quot;tracew&quot;, &quot;friedman&quot;, &quot;rubin&quot;, &quot;cindex&quot;, &quot;db&quot;, &quot;silhouette&quot;, &quot;duda&quot;, &quot;pseudot2&quot;, &quot;beale&quot;, &quot;ratkowsky&quot;, &quot;ball&quot;, &quot;ptbiserial&quot;, &quot;gap&quot;, &quot;frey&quot;, &quot;mcclain&quot;, &quot;gamma&quot;, &quot;gplus&quot;, &quot;tau&quot;, &quot;dunn&quot;, &quot;hubert&quot;, &quot;sdindex&quot;, &quot;dindex&quot;, &quot;sdbw&quot;, &quot;all&quot; (all indices except GAP, Gamma, Gplus and Tau), &quot;alllong&quot; (all indices with Gap, Gamma, Gplus and Tau included).</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_max.clust">max.clust</code></td>
<td>
<p>maximal number of clusters, between 2 and (number of objects - 1), greater or equal to min.nc.</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_min.clust">min.clust</code></td>
<td>
<p>minimum number of clusters, default = 2.</p>
</td></tr>
<tr><td><code id="run.clustering_+3A_dims">dims</code></td>
<td>
<p>PCA dimentions to be use for clustering, default = 1:10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.diff.exp'>Differential expression (DE) analysis</h2><span id='topic+run.diff.exp'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and performs differential expression (DE) analysis for clusters and conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.diff.exp(
  x = NULL,
  data.type = "main",
  pval.test = "t.test",
  p.adjust.method = "hochberg",
  de.by = "clusters",
  cond.1 = "array",
  cond.2 = "array",
  base.cond = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.diff.exp_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_pval.test">pval.test</code></td>
<td>
<p>Choose from &quot;t.test&quot;, &quot;wilcox.test&quot;, default = &quot;t.test&quot;.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Correction method. Choose from &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;, default = &quot;hochberg&quot;.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_de.by">de.by</code></td>
<td>
<p>Choose from &quot;clusters&quot;, &quot;conditions&quot;, &quot;clustBase.condComp&quot; or &quot;condBase.clustComp&quot;.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_cond.1">cond.1</code></td>
<td>
<p>First condition to do DE analysis on.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_cond.2">cond.2</code></td>
<td>
<p>Second condition to do DE analysis on.</p>
</td></tr>
<tr><td><code id="run.diff.exp_+3A_base.cond">base.cond</code></td>
<td>
<p>A base condition or cluster if de.by is either cond.clust or clust.cond</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='run.diffusion.map'>Run diffusion map on PCA data (PHATE - Potential of Heat-Diffusion for Affinity-Based Transition Embedding)</h2><span id='topic+run.diffusion.map'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs diffusion map on PCA data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.diffusion.map(
  x = NULL,
  dims = 1:10,
  method = "destiny",
  ndim = 3,
  k = 5,
  alpha = 40,
  n.landmark = 2000,
  gamma = 1,
  t = "auto",
  knn.dist.method = "euclidean",
  init = NULL,
  mds.method = "metric",
  mds.dist.method = "euclidean",
  t.max = 100,
  npca = 100,
  plot.optimal.t = FALSE,
  verbose = 1,
  n.jobs = 1,
  seed = NULL,
  potential.method = NULL,
  use.alpha = NULL,
  n.svd = NULL,
  pca.method = NULL,
  g.kernel = NULL,
  diff.op = NULL,
  landmark.transitions = NULL,
  diff.op.t = NULL,
  dist.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.diffusion.map_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used for UMAP analysis.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_method">method</code></td>
<td>
<p>diffusion map method, default = &quot;phate&quot;.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_ndim">ndim</code></td>
<td>
<p>int, optional, default: 2 number of dimensions in which the data will be embedded</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_k">k</code></td>
<td>
<p>int, optional, default: 5 number of nearest neighbors on which to build kernel</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_alpha">alpha</code></td>
<td>
<p>int, optional, default: 40 sets decay rate of kernel tails. If NULL, alpha decaying kernel is not used</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_n.landmark">n.landmark</code></td>
<td>
<p>int, optional, default: 2000 number of landmarks to use in fast PHATE</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_gamma">gamma</code></td>
<td>
<p>float, optional, default: 1 Informational distance constant between -1 and 1. gamma=1 gives the PHATE log potential, gamma=0 gives a square root potential.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_t">t</code></td>
<td>
<p>int, optional, default: 'auto' power to which the diffusion operator is powered sets the level of diffusion</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_knn.dist.method">knn.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'. recommended values: 'euclidean', 'cosine', 'precomputed' Any metric from scipy.spatial.distance can be used distance metric for building kNN graph. If 'precomputed', data should be an n_samples x n_samples distance or affinity matrix. Distance matrices are assumed to have zeros down the diagonal, while affinity matrices are assumed to have non-zero values down the diagonal. This is detected automatically using data[0,0]. You can override this detection with knn.dist.method='precomputed_distance' or knn.dist.method='precomputed_affinity'.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_init">init</code></td>
<td>
<p>phate object, optional object to use for initialization. Avoids recomputing intermediate steps if parameters are the same.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_mds.method">mds.method</code></td>
<td>
<p>string, optional, default: 'metric' choose from 'classic', 'metric', and 'nonmetric' which MDS algorithm is used for dimensionality reduction</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_mds.dist.method">mds.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean' recommended values: 'euclidean' and 'cosine'</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_t.max">t.max</code></td>
<td>
<p>int, optional, default: 100. Maximum value of t to test for automatic t selection.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_npca">npca</code></td>
<td>
<p>int, optional, default: 100 Number of principal components to use for calculating neighborhoods. For extremely large datasets, using n_pca &lt; 20 allows neighborhoods to be calculated in log(n_samples) time.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_plot.optimal.t">plot.optimal.t</code></td>
<td>
<p>boolean, optional, if TRUE, produce a plot showing the Von Neumann Entropy curve for automatic t selection.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_verbose">verbose</code></td>
<td>
<p>int or boolean, optional (default : 1) If TRUE or &gt; 0, message verbose updates.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_n.jobs">n.jobs</code></td>
<td>
<p>int, optional (default: 1) The number of jobs to use for the computation. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n.cpus + 1 + n.jobs) are used. Thus for n_jobs = -2, all CPUs but one are used</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_seed">seed</code></td>
<td>
<p>int or NULL, random state (default: NULL)</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_potential.method">potential.method</code></td>
<td>
<p>Deprecated. For log potential, use gamma=1. For sqrt potential, use gamma=0.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_use.alpha">use.alpha</code></td>
<td>
<p>Deprecated To disable alpha decay, use alpha=NULL</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_n.svd">n.svd</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_pca.method">pca.method</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_g.kernel">g.kernel</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_diff.op">diff.op</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_landmark.transitions">landmark.transitions</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_diff.op.t">diff.op.t</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="run.diffusion.map_+3A_dist.method">dist.method</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.impute'>Impute the main data</h2><span id='topic+run.impute'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs imputation on the main data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.impute(
  x = NULL,
  imp.method = "iCellR.imp",
  dims = 1:10,
  nn = 10,
  ATAC.data = FALSE,
  rounding.digits = 4,
  round.num = TRUE,
  data.type = "pca",
  genes = "all_genes",
  k = 10,
  alpha = 15,
  t = "auto",
  npca = 100,
  init = NULL,
  t.max = 20,
  knn.dist.method = "euclidean",
  verbose = 1,
  n.jobs = 1,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.impute_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_imp.method">imp.method</code></td>
<td>
<p>Choose between &quot;iCellR.imp&quot; and &quot;magic&quot;, defualt = &quot;iCellR.imp&quot;.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used for the analysis, default = 10.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_nn">nn</code></td>
<td>
<p>Number of neighboring cells to find, default = 10.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_atac.data">ATAC.data</code></td>
<td>
<p>If TURE, it would normalize ATAC-Seq data and not RNA-Seq, default = FALSE.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_rounding.digits">rounding.digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) or significant digits (signif) to be used.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_round.num">round.num</code></td>
<td>
<p>Rounding of Numbers, default = FALSE.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_data.type">data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, &quot;diffusion&quot;, &quot;knetl&quot;, default = &quot;pca&quot;.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_genes">genes</code></td>
<td>
<p>character or integer vector, default: NULL vector of column names or column indices for which to return smoothed data If 'all_genes' or NULL, the entire smoothed matrix is returned</p>
</td></tr>
<tr><td><code id="run.impute_+3A_k">k</code></td>
<td>
<p>if imp.method is magic; int, optional, default: 10 number of nearest neighbors on which to build kernel</p>
</td></tr>
<tr><td><code id="run.impute_+3A_alpha">alpha</code></td>
<td>
<p>if imp.method is magic; int, optional, default: 15 sets decay rate of kernel tails. If NULL, alpha decaying kernel is not used</p>
</td></tr>
<tr><td><code id="run.impute_+3A_t">t</code></td>
<td>
<p>if imp.method is magic; int, optional, default: 'auto' power to which the diffusion operator is powered sets the level of diffusion. If 'auto', t is selected according to the Procrustes disparity of the diffused data.'</p>
</td></tr>
<tr><td><code id="run.impute_+3A_npca">npca</code></td>
<td>
<p>number of PCA components that should be used; default: 100.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_init">init</code></td>
<td>
<p>magic object, optional object to use for initialization. Avoids recomputing intermediate steps if parameters are the same.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_t.max">t.max</code></td>
<td>
<p>if imp.method is magic; int, optional, default: 20 Maximum value of t to test for automatic t selection.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_knn.dist.method">knn.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'. recommended values: 'euclidean', 'cosine' Any metric from 'scipy.spatial.distance' can be used distance metric for building kNN graph.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_verbose">verbose</code></td>
<td>
<p>'int' or 'boolean', optional (default : 1) If 'TRUE' or '&gt; 0', message verbose updates.</p>
</td></tr>
<tr><td><code id="run.impute_+3A_n.jobs">n.jobs</code></td>
<td>
<p>'int', optional (default: 1) The number of jobs to use for the computation. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n.cpus + 1 + n.jobs) are used. Thus for n_jobs = -2, all CPUs but one are used</p>
</td></tr>
<tr><td><code id="run.impute_+3A_seed">seed</code></td>
<td>
<p>int or 'NULL', random state (default: 'NULL')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.knetl'>iCellR KNN Network</h2><span id='topic+run.knetl'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and and runs kNet for dimensionality reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.knetl(
  x = NULL,
  dist.method = "euclidean",
  zoom = 300,
  data.type = "pca",
  dims = 1:20,
  joint = FALSE,
  col.by = "clusters",
  my.seed = 1,
  layout.2d = "layout_nicely",
  layout.3d = "layout_with_fr",
  add.3d = FALSE,
  dim.redux = "umap",
  do.redux = TRUE,
  run.iclust = FALSE,
  return.graph = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.knetl_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_dist.method">dist.method</code></td>
<td>
<p>the distance measure to be used to compute the dissimilarity matrix. This must be one of: &quot;euclidean&quot;, &quot;maximum&quot;, &quot;mandatattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; or &quot;NULL&quot;. By default, distance=&quot;euclidean&quot;. If the distance is &quot;NULL&quot;, the dissimilarity matrix (diss) should be given by the user. If distance is not &quot;NULL&quot;, the dissimilarity matrix should be &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_zoom">zoom</code></td>
<td>
<p>Adjusting zoom the higher the number the less sensitivity, default = 400.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_data.type">data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, default = &quot;pca&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_dims">dims</code></td>
<td>
<p>PCA dimentions to be use for clustering, default = 1:20.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_joint">joint</code></td>
<td>
<p>Run in Combined or joint fashion as in CCCA and CPCA, default = FALSE.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_col.by">col.by</code></td>
<td>
<p>If return.graph is TRUE the choose the cluster colors.  Choose between &quot;clusters&quot;, &quot;conditions&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_my.seed">my.seed</code></td>
<td>
<p>seed number, default = 1.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_layout.2d">layout.2d</code></td>
<td>
<p>Choose your 2D layout, default = &quot;layout_nicely&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_layout.3d">layout.3d</code></td>
<td>
<p>Choose your 3D layout, default = &quot;layout_with_fr&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_add.3d">add.3d</code></td>
<td>
<p>Add 3D KNetL as well, default = FALSE.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_dim.redux">dim.redux</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot; to unpack the nodes, default = &quot;umap&quot;.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_do.redux">do.redux</code></td>
<td>
<p>Perform dim reudx for unpaking the nodes, default = TRUE.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_run.iclust">run.iclust</code></td>
<td>
<p>Perform clustering as well (nor recomanded), default = FALSE.</p>
</td></tr>
<tr><td><code id="run.knetl_+3A_return.graph">return.graph</code></td>
<td>
<p>return igraph object, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.mnn'>Run MNN alignment on the main data.</h2><span id='topic+run.mnn'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs MNN alignment. It's a wrapper for scran.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.mnn(
  x = NULL,
  method = "base.mean.rank",
  top.rank = 500,
  gene.list = "character",
  data.type = "main",
  k = 20,
  cos.norm = TRUE,
  ndist = 3,
  d = 50,
  approximate = FALSE,
  irlba.args = list(),
  subset.row = NULL,
  auto.order = FALSE,
  pc.input = FALSE,
  compute.variances = FALSE,
  assay.type = "logcounts",
  get.spikes = FALSE,
  BNPARAM = NULL,
  BPPARAM = SerialParam()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.mnn_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_method">method</code></td>
<td>
<p>Choose from &quot;base.mean.rank&quot; or &quot;gene.model&quot;, default is &quot;base.mean.rank&quot;. If gene.model is chosen you need to provide gene.list.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_top.rank">top.rank</code></td>
<td>
<p>A number taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_gene.list">gene.list</code></td>
<td>
<p>A charactor vector of genes to be used for PCA. If &quot;clust.method&quot; is set to &quot;gene.model&quot;, default = &quot;my_model_genes.txt&quot;.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_k">k</code></td>
<td>
<p>An integer scalar specifying the number of nearest neighbors to consider when identifying MNNs.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_cos.norm">cos.norm</code></td>
<td>
<p>A logical scalar indicating whether cosine normalization should be performed on the input data prior to calculating distances between cells.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_ndist">ndist</code></td>
<td>
<p>A numeric scalar specifying the threshold beyond which neighbours are to be ignored when computing correction vectors. Each threshold is defined in terms of the number of median distances.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_d">d</code></td>
<td>
<p>Number of dimentions to pass to multiBatchPCA.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_approximate">approximate</code></td>
<td>
<p>Further arguments to pass to multiBatchPCA. Setting approximate=TRUE is recommended for large data sets with many cells.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_irlba.args">irlba.args</code></td>
<td>
<p>Further arguments to pass to multiBatchPCA. Setting approximate=TRUE is recommended for large data sets with many cells.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_subset.row">subset.row</code></td>
<td>
<p>See ?&quot;scran-gene-selection&quot;.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_auto.order">auto.order</code></td>
<td>
<p>Logical scalar indicating whether re-ordering of batches should be performed to maximize the number of MNN pairs at each step. Alternatively an integer vector containing a permutation of 1:N where N is the number of batches.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_pc.input">pc.input</code></td>
<td>
<p>Logical scalar indicating whether the values in ... are already low-dimensional, e.g., the output of multiBatchPCA.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Logical scalar indicating whether the percentage of variance lost due to non-orthogonality should be computed.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_assay.type">assay.type</code></td>
<td>
<p>A string or integer scalar specifying the assay containing the expression values, if SingleCellExperiment objects are present in ....</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_get.spikes">get.spikes</code></td>
<td>
<p>See ?&quot;scran-gene-selection&quot;. Only relevant if ... contains SingleCellExperiment objects.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_bnparam">BNPARAM</code></td>
<td>
<p>A BiocNeighborParam object specifying the nearest neighbor algorithm. Defaults to an exact algorithm if NULL, see ?findKNN for more details.</p>
</td></tr>
<tr><td><code id="run.mnn_+3A_bpparam">BPPARAM</code></td>
<td>
<p>A BiocParallelParam object specifying whether the PCA and nearest-neighbor searches should be parallelized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.pc.tsne'>Run tSNE on PCA Data. Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding</h2><span id='topic+run.pc.tsne'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs tSNE on PCA data. Wrapper for the C++ implementation of Barnes-Hut t-Distributed Stochastic Neighbor Embedding. t-SNE is a method for constructing a low dimensional embedding of high-dimensional data, distances or similarities. Exact t-SNE can be computed by setting theta=0.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.pc.tsne(
  x = NULL,
  dims = 1:10,
  my.seed = 0,
  add.3d = TRUE,
  initial_dims = 50,
  perplexity = 30,
  theta = 0.5,
  check_duplicates = FALSE,
  pca = TRUE,
  max_iter = 1000,
  verbose = FALSE,
  is_distance = FALSE,
  Y_init = NULL,
  pca_center = TRUE,
  pca_scale = FALSE,
  stop_lying_iter = ifelse(is.null(Y_init), 250L, 0L),
  mom_switch_iter = ifelse(is.null(Y_init), 250L, 0L),
  momentum = 0.5,
  final_momentum = 0.8,
  eta = 200,
  exaggeration_factor = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.pc.tsne_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used for tSNE analysis.</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_my.seed">my.seed</code></td>
<td>
<p>seed number, default = 0.</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_add.3d">add.3d</code></td>
<td>
<p>Add 3D tSNE as well, default = TRUE.</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_initial_dims">initial_dims</code></td>
<td>
<p>integer; the number of dimensions that should be retained in the initial PCA step (default: 50)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric; Perplexity parameter</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_theta">theta</code></td>
<td>
<p>numeric; Speed/accuracy trade-off (increase for less accuracy), set to 0.0 for exact TSNE (default: 0.5)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p>logical; Checks whether duplicates are present. It is best to make sure there are no duplicates present and set this option to FALSE, especially for large datasets (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_pca">pca</code></td>
<td>
<p>logical; Whether an initial PCA step should be performed (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_max_iter">max_iter</code></td>
<td>
<p>integer; Number of iterations (default: 1000)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_verbose">verbose</code></td>
<td>
<p>logical; Whether progress updates should be messageed (default: FALSE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_is_distance">is_distance</code></td>
<td>
<p>logical; Indicate whether X is a distance matrix (experimental, default: FALSE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_y_init">Y_init</code></td>
<td>
<p>matrix; Initial locations of the objects. If NULL, random initialization will be used (default: NULL). Note that when using this, the initial stage with exaggerated perplexity values and a larger momentum term will be skipped.</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_pca_center">pca_center</code></td>
<td>
<p>logical; Should data be centered before pca is applied? (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_pca_scale">pca_scale</code></td>
<td>
<p>logical; Should data be scaled before pca is applied? (default: FALSE)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_stop_lying_iter">stop_lying_iter</code></td>
<td>
<p>integer; Iteration after which the perplexities are no longer exaggerated (default: 250, except when Y_init is used, then 0)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_mom_switch_iter">mom_switch_iter</code></td>
<td>
<p>integer; Iteration after which the final momentum is used (default: 250, except when Y_init is used, then 0)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_momentum">momentum</code></td>
<td>
<p>numeric; Momentum used in the first part of the optimization (default: 0.5)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_final_momentum">final_momentum</code></td>
<td>
<p>numeric; Momentum used in the final part of the optimization (default: 0.8)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_eta">eta</code></td>
<td>
<p>numeric; Learning rate (default: 200.0)</p>
</td></tr>
<tr><td><code id="run.pc.tsne_+3A_exaggeration_factor">exaggeration_factor</code></td>
<td>
<p>numeric; Exaggeration factor used to multiply the P matrix in the first part of the optimization (default: 12.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.pca'>Run PCA on the main data</h2><span id='topic+run.pca'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs PCA on the main data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.pca(
  x = NULL,
  data.type = "main",
  method = "base.mean.rank",
  top.rank = 500,
  plus.log.value = 0.1,
  scale.data = TRUE,
  gene.list = "character"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.pca_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.pca_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot; and &quot;imputed&quot;, default = &quot;main&quot;</p>
</td></tr>
<tr><td><code id="run.pca_+3A_method">method</code></td>
<td>
<p>Choose from &quot;base.mean.rank&quot; or &quot;gene.model&quot;, default is &quot;base.mean.rank&quot;. If gene.model is chosen you need to provide gene.list.</p>
</td></tr>
<tr><td><code id="run.pca_+3A_top.rank">top.rank</code></td>
<td>
<p>A number. Taking the top genes ranked by base mean, default = 500.</p>
</td></tr>
<tr><td><code id="run.pca_+3A_plus.log.value">plus.log.value</code></td>
<td>
<p>A number to add to each value in the matrix before log transformasion to aviond Inf numbers, default = 0.1.</p>
</td></tr>
<tr><td><code id="run.pca_+3A_scale.data">scale.data</code></td>
<td>
<p>If TRUE the data will be scaled (log2 + plus.log.value), default = TRUE.</p>
</td></tr>
<tr><td><code id="run.pca_+3A_gene.list">gene.list</code></td>
<td>
<p>A charactor vector of genes to be used for PCA. If &quot;clust.method&quot; is set to &quot;gene.model&quot;, default = &quot;my_model_genes.txt&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.phenograph'>Clustering the data</h2><span id='topic+run.phenograph'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and finds optimal number of clusters and clusters the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.phenograph(x = NULL, k = 100, data.type = "pca", dims = 1:10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.phenograph_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.phenograph_+3A_k">k</code></td>
<td>
<p>integer; number of nearest neighbours (default:45)</p>
</td></tr>
<tr><td><code id="run.phenograph_+3A_data.type">data.type</code></td>
<td>
<p>Choose between &quot;tsne&quot;, &quot;pca&quot;, &quot;umap&quot;, default = &quot;pca&quot;.</p>
</td></tr>
<tr><td><code id="run.phenograph_+3A_dims">dims</code></td>
<td>
<p>PCA dimentions to be use for clustering, default = 1:10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.tsne'>Run tSNE on the Main Data. Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding</h2><span id='topic+run.tsne'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs tSNE on main data. Wrapper for the C++ implementation of Barnes-Hut t-Distributed Stochastic Neighbor Embedding. t-SNE is a method for constructing a low dimensional embedding of high-dimensional data, distances or similarities. Exact t-SNE can be computed by setting theta=0.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.tsne(
  x = NULL,
  clust.method = "base.mean.rank",
  top.rank = 500,
  gene.list = "character",
  add.3d = TRUE,
  initial_dims = 50,
  perplexity = 30,
  theta = 0.5,
  check_duplicates = TRUE,
  pca = TRUE,
  max_iter = 1000,
  verbose = FALSE,
  is_distance = FALSE,
  Y_init = NULL,
  pca_center = TRUE,
  pca_scale = FALSE,
  stop_lying_iter = ifelse(is.null(Y_init), 250L, 0L),
  mom_switch_iter = ifelse(is.null(Y_init), 250L, 0L),
  momentum = 0.5,
  final_momentum = 0.8,
  eta = 200,
  exaggeration_factor = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.tsne_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_clust.method">clust.method</code></td>
<td>
<p>Choose from &quot;base.mean.rank&quot; or &quot;gene.model&quot;, defult is &quot;base.mean.rank&quot;.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_top.rank">top.rank</code></td>
<td>
<p>A number taking the top genes ranked by base mean, defult = 500.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_gene.list">gene.list</code></td>
<td>
<p>A list of genes to be used for tSNE analysis. If &quot;clust.method&quot; is set to &quot;gene.model&quot;, defult = &quot;my_model_genes.txt&quot;.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_add.3d">add.3d</code></td>
<td>
<p>Add 3D tSNE as well, default = TRUE.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_initial_dims">initial_dims</code></td>
<td>
<p>integer; the number of dimensions that should be retained in the initial PCA step (default: 50)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric; Perplexity parameter</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_theta">theta</code></td>
<td>
<p>numeric; Speed/accuracy trade-off (increase for less accuracy), set to 0.0 for exact TSNE (default: 0.5)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p>logical; Checks whether duplicates are present. It is best to make sure there are no duplicates present and set this option to FALSE, especially for large datasets (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_pca">pca</code></td>
<td>
<p>logical; Whether an initial PCA step should be performed (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_max_iter">max_iter</code></td>
<td>
<p>integer; Number of iterations (default: 1000)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_verbose">verbose</code></td>
<td>
<p>logical; Whether progress updates should be messageed (default: FALSE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_is_distance">is_distance</code></td>
<td>
<p>logical; Indicate whether X is a distance matrix (experimental, default: FALSE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_y_init">Y_init</code></td>
<td>
<p>matrix; Initial locations of the objects. If NULL, random initialization will be used (default: NULL). Note that when using this, the initial stage with exaggerated perplexity values and a larger momentum term will be skipped.</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_pca_center">pca_center</code></td>
<td>
<p>logical; Should data be centered before pca is applied? (default: TRUE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_pca_scale">pca_scale</code></td>
<td>
<p>logical; Should data be scaled before pca is applied? (default: FALSE)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_stop_lying_iter">stop_lying_iter</code></td>
<td>
<p>integer; Iteration after which the perplexities are no longer exaggerated (default: 250, except when Y_init is used, then 0)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_mom_switch_iter">mom_switch_iter</code></td>
<td>
<p>integer; Iteration after which the final momentum is used (default: 250, except when Y_init is used, then 0)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_momentum">momentum</code></td>
<td>
<p>numeric; Momentum used in the first part of the optimization (default: 0.5)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_final_momentum">final_momentum</code></td>
<td>
<p>numeric; Momentum used in the final part of the optimization (default: 0.8)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_eta">eta</code></td>
<td>
<p>numeric; Learning rate (default: 200.0)</p>
</td></tr>
<tr><td><code id="run.tsne_+3A_exaggeration_factor">exaggeration_factor</code></td>
<td>
<p>numeric; Exaggeration factor used to multiply the P matrix in the first part of the optimization (default: 12.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='run.umap'>Run UMAP on PCA Data (Computes a manifold approximation and projection)</h2><span id='topic+run.umap'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs UMAP on PCA data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.umap(
  x = NULL,
  my.seed = 0,
  dims = 1:10,
  n_neighbors = 15,
  n_components = 2,
  metric = "euclidean",
  n_epochs = NULL,
  learning_rate = 1,
  scale = FALSE,
  init = "spectral",
  init_sdev = NULL,
  spread = 1,
  min_dist = 0.01,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  bandwidth = 1,
  repulsion_strength = 1,
  negative_sample_rate = 5,
  a = NULL,
  b = NULL,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  approx_pow = FALSE,
  y = NULL,
  target_n_neighbors = n_neighbors,
  target_metric = "euclidean",
  target_weight = 0.5,
  pca = NULL,
  pca_center = TRUE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  ret_model = FALSE,
  ret_nn = FALSE,
  n_threads = 1,
  n_sgd_threads = 0,
  grain_size = 1,
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.umap_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_my.seed">my.seed</code></td>
<td>
<p>seed number, default = 0.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_dims">dims</code></td>
<td>
<p>PC dimentions to be used for UMAP analysis.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. One
of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>Only applies if <code>nn_method = "annoy"</code> (for <code>nn_method = "fnn"</code>, the
distance metric is always &quot;euclidean&quot;).
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. By default, this value is set to <code>500</code> for datasets
containing 10,000 vertices or less, and <code>200</code> otherwise.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For UMAP, the default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap
(Belkin and Niyogi, 2002).
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE. This is an alias for <code>init = "pca", init_sdev =
   1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>), if more than one connected component is identified,
each connected component is initialized separately and the results are
merged. If <code>verbose = TRUE</code> the number of connected components are
logged to the console. The existence of multiple connected components
implies that a global view of the data cannot be attained with this
initialization. Either a PCA-based initialization or increasing the value of
<code>n_neighbors</code> may be more appropriate.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default no scaling is carried out, except when <code>init =
"spca"</code>, in which case the value is <code>0.0001</code>. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher).</p>
</td></tr>
<tr><td><code id="run.umap_+3A_spread">spread</code></td>
<td>
<p>The effective scale of embedded points. In combination with
<code>min_dist</code>, this determines how clustered/clumped the embedded points
are.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_min_dist">min_dist</code></td>
<td>
<p>The effective minimum distance between embedded points.
Smaller values will result in a more clustered/clumped embedding where
nearby points on the manifold are drawn closer together, while larger
values will result on a more even dispersal of points. The value should be
set relative to the <code>spread</code> value, which determines the scale at
which embedded points will be spread out.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_set_op_mix_ratio">set_op_mix_ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>The local connectivity required &ndash; i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The effective bandwidth of the kernel if we view the
algorithm as similar to Laplacian Eigenmaps. Larger values induce more
connectivity and a more global view of the data, smaller values concentrate
more locally.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_a">a</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_b">b</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass precalculated nearest neighbor data to this argument. It
must be a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>Multiple nearest neighbor data (e.g. from two different precomputed
metrics) can be passed by passing a list containing the nearest neighbor
data lists as items.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_approx_pow">approx_pow</code></td>
<td>
<p>If <code>TRUE</code>, use an approximation to the power function
in the UMAP gradient, from
<a href="https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/">https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/</a>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_y">y</code></td>
<td>
<p>Optional target data for supervised dimension reduction. Can be a
vector, matrix or data frame. Use the <code>target_metric</code> parameter to
specify the metrics to use, using the same syntax as <code>metric</code>. Usually
either a single numeric or factor column is used, but more complex formats
are possible. The following types are allowed:
</p>

<ul>
<li><p> Factor columns with the same length as <code>X</code>. <code>NA</code> is
allowed for any observation with an unknown level, in which case
UMAP operates as a form of semi-supervised learning. Each column is
treated separately.
</p>
</li>
<li><p> Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
parameter <code>target_n_neighbors</code> to set the number of neighbors used
with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
numeric columns are grouped into one block unless <code>target_metric</code>
specifies otherwise. For example, if you wish columns <code>a</code> and
<code>b</code> to be treated separately, specify
<code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
the data will be effectively treated as a matrix with two columns.
</p>
</li>
<li><p> Nearest neighbor data, consisting of a list of two matrices,
<code>idx</code> and <code>dist</code>. These represent the precalculated nearest
neighbor indices and distances, respectively. This
is the same format as that expected for precalculated data in
<code>nn_method</code>. This format assumes that the underlying data was a
numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
parameter is ignored in this case, because the the number of columns in
the matrices is used for the value. Multiple nearest neighbor data using
different metrics can be supplied by passing a list of these lists.
</p>
</li></ul>

<p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_target_n_neighbors">target_n_neighbors</code></td>
<td>
<p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_target_metric">target_metric</code></td>
<td>
<p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_target_weight">target_weight</code></td>
<td>
<p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code>, <code>n_sgd_threads = "auto"</code> and
<code>approx_pow = TRUE</code>. The default is <code>FALSE</code>. Setting this to
<code>TRUE</code> will speed up the stochastic optimization phase, but give a
potentially less accurate embedding, and which will not be exactly
reproducible even with a fixed seed. For visualization, <code>fast_sgd =
TRUE</code> will give perfectly good results. For more generic dimensionality
reduction, it's safer to leave <code>fast_sgd = FALSE</code>. If <code>fast_sgd =
TRUE</code>, then user-supplied values of <code>pcg_rand</code>, <code>n_sgd_threads</code>,
and <code>approx_pow</code> are ignored.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_ret_model">ret_model</code></td>
<td>
<p>If <code>TRUE</code>, then return extra data that can be used to
add new data to an existing embedding via <code>umap_transform</code>. The
embedded coordinates are returned as the list item <code>embedding</code>. If
<code>FALSE</code>, just return the coordinates. This parameter can be used in
conjunction with <code>ret_nn</code>. Note that some settings are incompatible
with the production of a UMAP model: external neighbor data (passed via a
list to <code>nn_method</code>), and factor columns that were included
via the <code>metric</code> parameter. In the latter case, the model produced is
based only on the numeric data. A transformation using new data is
possible, but the factor columns in the new data are ignored.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_ret_nn">ret_nn</code></td>
<td>
<p>If <code>TRUE</code>, then in addition to the embedding, also return
nearest neighbor data that can be used as input to <code>nn_method</code> to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. <code>min_dist</code>, <code>n_epochs</code>,
<code>init</code>). See the &quot;Value&quot; section for the names of the list items. If
<code>FALSE</code>, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the <code>scale</code> parameter. This parameter can be used in
conjunction with <code>ret_model</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then results will not be reproducible, even if
'set.seed' is called with a fixed seed before running. Set to
<code>"auto"</code> go use the same value as <code>n_threads</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_grain_size">grain_size</code></td>
<td>
<p>Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Used in conjunction with <code>n_threads</code> and
<code>n_sgd_threads</code>.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="run.umap_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='s.phase'>A dataset of S phase genes</h2><span id='topic+s.phase'></span>

<h3>Description</h3>

<p>A dataset containing the genes for S phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.phase
</code></pre>


<h3>Format</h3>

<p>A character with 43 genes
</p>


<h3>Source</h3>

<p><a href="https://www.science.org/doi/abs/10.1126/science.aad0501">https://www.science.org/doi/abs/10.1126/science.aad0501</a>
</p>

<hr>
<h2 id='spatial.plot'>Plot nGenes, UMIs and perecent mito, genes, clusters and more on spatial image</h2><span id='topic+spatial.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and creates spatial plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.plot(
  x = NULL,
  cell.size = 1,
  cell.colors = c("gray", "red"),
  back.col = "black",
  col.by = "clusters",
  conds.to.plot = NULL,
  gene = NULL,
  data.type = "main",
  scaleValue = TRUE,
  min.scale = 0,
  max.scale = 2.5,
  anno.clust = FALSE,
  anno.size = 4,
  anno.col = "white",
  cell.transparency = 1,
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A numeric value for the size of the cells, default = 1.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cell.colors">cell.colors</code></td>
<td>
<p>Colors for heat mapping the points in &quot;scatterplot&quot;, default = c(&quot;gray&quot;,&quot;red&quot;).</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_back.col">back.col</code></td>
<td>
<p>A color for the plot background, default = &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_col.by">col.by</code></td>
<td>
<p>Choose between &quot;clusters&quot;, &quot;mt&quot;,&quot;UMIs&quot;,&quot;nGenes&quot;, &quot;cc&quot; (cell cycle) or &quot;gene&quot;, default = &quot;clusters&quot;.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_conds.to.plot">conds.to.plot</code></td>
<td>
<p>Choose the conditions you want to see in the plot, default = NULL (all conditions).</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_gene">gene</code></td>
<td>
<p>Gene name/names to be plotted, if col.by = &quot;gene&quot;.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_data.type">data.type</code></td>
<td>
<p>Choose from &quot;main&quot; or &quot;imputed&quot;, default = &quot;main&quot;.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_scalevalue">scaleValue</code></td>
<td>
<p>Scale the colors, default = FALSE.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_min.scale">min.scale</code></td>
<td>
<p>If scaleValue = TRUE, set a number for min, default = -2.5.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_max.scale">max.scale</code></td>
<td>
<p>If scaleValue = TRUE, set a number for max, default = 2.5.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_anno.clust">anno.clust</code></td>
<td>
<p>Annotate cluster names on the plot, default = TRUE.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_anno.size">anno.size</code></td>
<td>
<p>If anno.clust is TRUE set font size, default = 3.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_anno.col">anno.col</code></td>
<td>
<p>If anno.clust is TRUE set color, default = &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for points in &quot;scatterplot&quot; and &quot;boxplot&quot;, default = 1.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='stats.plot'>Plot nGenes, UMIs and percent mito</h2><span id='topic+stats.plot'></span>

<h3>Description</h3>

<p>This function takes an object of class iCellR and creates QC plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats.plot(
  x = NULL,
  plot.type = "three.in.one",
  cell.color = "slategray3",
  cell.size = 1,
  cell.transparency = 0.5,
  box.color = "red",
  box.line.col = "green",
  back.col = "white",
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats.plot_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from &quot;box.umi&quot;, &quot;box.mito&quot;, &quot;box.gene&quot;, &quot;box.s.phase&quot;, &quot;box.g2m.phase&quot;,&quot;all.in.one&quot;,&quot;three.in.one&quot;, &quot;point.mito.umi&quot;, &quot;point.gene.umi&quot;.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_cell.color">cell.color</code></td>
<td>
<p>Choose a color for points in the plot.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_cell.size">cell.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_cell.transparency">cell.transparency</code></td>
<td>
<p>Color transparency for points in &quot;scatterplot&quot; and &quot;boxplot&quot;, default = 0.5.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_box.color">box.color</code></td>
<td>
<p>A color for the boxes in the &quot;boxplot&quot;, default = &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_box.line.col">box.line.col</code></td>
<td>
<p>A color for the lines around the &quot;boxplot&quot;, default = &quot;green&quot;.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_back.col">back.col</code></td>
<td>
<p>Background color, default = &quot;white&quot;</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="stats.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the out put name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR.
</p>

<hr>
<h2 id='top.markers'>Choose top marker genes</h2><span id='topic+top.markers'></span>

<h3>Description</h3>

<p>This function takes the marker genes info if chooses marker gene names for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.markers(
  x = NULL,
  topde = 10,
  min.base.mean = 0.2,
  filt.ambig = TRUE,
  cluster = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top.markers_+3A_x">x</code></td>
<td>
<p>An object of class iCellR.</p>
</td></tr>
<tr><td><code id="top.markers_+3A_topde">topde</code></td>
<td>
<p>Number of top differentially expressed genes to be choosen from each cluster, default = 10.</p>
</td></tr>
<tr><td><code id="top.markers_+3A_min.base.mean">min.base.mean</code></td>
<td>
<p>Minimum base mean of the genes to be chosen, default = 0.5.</p>
</td></tr>
<tr><td><code id="top.markers_+3A_filt.ambig">filt.ambig</code></td>
<td>
<p>Filter markers that are seen for more than one cluster, default = TRUE.</p>
</td></tr>
<tr><td><code id="top.markers_+3A_cluster">cluster</code></td>
<td>
<p>Choose a cluster to find markers for. If 0, it would find markers for all clusters, , default = 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of gene names
</p>

<hr>
<h2 id='vdj.stats'>VDJ stats</h2><span id='topic+vdj.stats'></span>

<h3>Description</h3>

<p>This function takes a data frame of VDJ info per cell and dose QC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdj.stats(my.vdj = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdj.stats_+3A_my.vdj">my.vdj</code></td>
<td>
<p>A data frame containing VDJ data for cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iCellR
</p>

<hr>
<h2 id='volcano.ma.plot'>Create MA and Volcano plots.</h2><span id='topic+volcano.ma.plot'></span>

<h3>Description</h3>

<p>This function takes the result of differential expression (DE) analysis and provides MA and volcano plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano.ma.plot(
  x = NULL,
  sig.value = "padj",
  sig.line = 0.1,
  plot.type = "volcano",
  x.limit = 2,
  y.limit = 2,
  limit.force = FALSE,
  scale.ax = TRUE,
  dot.size = 1.75,
  dot.transparency = 0.5,
  dot.col = c("#E64B35", "#3182bd", "#636363"),
  interactive = TRUE,
  out.name = "plot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volcano.ma.plot_+3A_x">x</code></td>
<td>
<p>A data frame containing differential expression (DE) analysis results.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_sig.value">sig.value</code></td>
<td>
<p>Choose from &quot;pval&quot; or &quot;padj&quot;, default = &quot;padj&quot;.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_sig.line">sig.line</code></td>
<td>
<p>A number to draw the line for the significant genes based on sig.value type, default = 0.1.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Choose from &quot;ma&quot; or &quot;volcano&quot;, default = &quot;volcano&quot;.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_x.limit">x.limit</code></td>
<td>
<p>A number to set a limit for the x axis.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_y.limit">y.limit</code></td>
<td>
<p>A number to set a limit for the y axis.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_limit.force">limit.force</code></td>
<td>
<p>If set to TRUE the x.limit and y.limit will be forced, default = FALSE.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_scale.ax">scale.ax</code></td>
<td>
<p>If set to TRUE the y axis will be scaled to include all the points, default = TRUE.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_dot.size">dot.size</code></td>
<td>
<p>A number for the size of the points in the plot, default = 1.75.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_dot.transparency">dot.transparency</code></td>
<td>
<p>Color transparency for points in &quot;scatterplot&quot; and &quot;boxplot&quot;, default = 0.5.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_dot.col">dot.col</code></td>
<td>
<p>A set of three colors for the points in the volcano plot, default = c(&quot;#E64B35&quot;,&quot;#3182bd&quot;,&quot;#636363&quot;).</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_interactive">interactive</code></td>
<td>
<p>If set to TRUE an interactive HTML file will be created, default = TRUE.</p>
</td></tr>
<tr><td><code id="volcano.ma.plot_+3A_out.name">out.name</code></td>
<td>
<p>If &quot;interactive&quot; is set to TRUE, the output name for HTML, default = &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
