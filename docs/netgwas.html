<!DOCTYPE html><html><head><title>Help for package netgwas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netgwas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildMap'><p> linkage group detection and ordering markers for class &quot;netgwasmap&quot;</p></a></li>
<li><a href='#cal.pos'><p>Estimate genetic map distances</p></a></li>
<li><a href='#cross2netgwas'><p><code>cross</code> object to <code>netgwas</code> data frame</p></a></li>
<li><a href='#cutoffs'>
<p>Cut-points</p></a></li>
<li><a href='#CviCol'><p>Arabidopsis thaliana genotype data</p></a></li>
<li><a href='#detect.err'><p>Identiying likely genotyping error</p></a></li>
<li><a href='#lower.upper'>
<p>Calculates lower band and upper band</p></a></li>
<li><a href='#netgwas-internal'><p>netgwas-internal</p></a></li>
<li><a href='#netgwas-package'>
<p>Network Based Genome Wide Association Studies</p></a></li>
<li><a href='#netgwas2cross'><p> netgwasmap object to cross object</p></a></li>
<li><a href='#netmap'><p>Constructing linkage map for diploids and polyploids</p></a></li>
<li><a href='#netphenogeno'><p>Reconstructs conditional dependence network among genetic loci and phenotypes</p></a></li>
<li><a href='#netsnp'><p>Reconstructs intra- and inter- chromosomal conditional interactions among genetic loci</p></a></li>
<li><a href='#plot.netgwas'><p> plot for S3 class &quot;netgwas&quot;</p></a></li>
<li><a href='#plot.netgwasmap'><p> plot for S3 class &quot;netgwasmap&quot;</p></a></li>
<li><a href='#plot.select'><p> Plot function for S3 class &quot;select&quot;</p></a></li>
<li><a href='#plot.simgeno'><p> Plot function for <code>S3</code> class <code>"simgeno"</code></p></a></li>
<li><a href='#print.netgwas'>
<p>Print function for S3 class &quot;netgwas&quot;</p></a></li>
<li><a href='#print.netgwasmap'>
<p>Print function for S3 class &quot;netgwasmap&quot;</p></a></li>
<li><a href='#print.select'>
<p>Print function for S3 class &quot;select&quot;</p></a></li>
<li><a href='#print.simgeno'>
<p>Print function for S3 class &quot;simgeno&quot;</p></a></li>
<li><a href='#R.approx'><p> The expectation of covariance using approximation method</p></a></li>
<li><a href='#R.gibbs'><p> The expectation of covariance matrix using Gibbs sampling</p></a></li>
<li><a href='#selectnet'><p> Model selection</p></a></li>
<li><a href='#simgeno'><p>Generate genotype data based on Gaussian copula</p></a></li>
<li><a href='#simRIL'><p>Generate genotype data of RIL</p></a></li>
<li><a href='#tetraPotato'><p>tetraploid potato genotype data</p></a></li>
<li><a href='#thaliana'><p>Arabidopsis thaliana phenotype and genotype data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Based Genome Wide Association Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>1.14.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix(&ge; 1.4-1), igraph, qtl, parallel, methods, glasso,
MASS, huge,tmvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>A multi-core R package that contains a set of tools based on copula graphical
             models for accomplishing the three interrelated goals in genetics and genomics in an
			 unified way: (1) linkage map construction, (2) constructing linkage disequilibrium
			 networks, and (3) exploring high-dimensional genotype-phenotype network and genotype-
			 phenotype-environment interactions networks. 
			 The 'netgwas' package can deal with biparental inbreeding and outbreeding species with
			 any ploidy level, namely diploid (2 sets of chromosomes), triploid (3 sets of chromosomes),
			 tetraploid (4 sets of chromosomes) and so on. We target on high-dimensional data where 
			 number of variables p is considerably larger than number of sample sizes (p &gt;&gt; n). 
			 The computations is memory-optimized using the sparse matrix output. The 'netgwas' 
			 implements the methodological developments in Behrouzi and Wit (2017)
             &lt;<a href="https://doi.org/10.1111%2Frssc.12287">doi:10.1111/rssc.12287</a>&gt; and Behrouzi and Wit (2017) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty777">doi:10.1093/bioinformatics/bty777</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 15:30:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 14:55:25 UTC; behro001</td>
</tr>
<tr>
<td>Author:</td>
<td>Pariya Behrouzi <a href="https://orcid.org/0000-0001-6762-5433"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ernst C. Wit [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='buildMap'> linkage group detection and ordering markers for class &quot;netgwasmap&quot;</h2><span id='topic+buildMap'></span>

<h3>Description</h3>

<p>Implements different algorithms for detecting linkage groups and ordering markers in each linkage group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMap( res, opt.index, min.m = NULL, use.comu = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildMap_+3A_res">res</code></td>
<td>
<p> An object with S3 class &quot;netgwasmap&quot;</p>
</td></tr>
<tr><td><code id="buildMap_+3A_opt.index">opt.index</code></td>
<td>
<p> An index of a desired regularization parameter.</p>
</td></tr>
<tr><td><code id="buildMap_+3A_min.m">min.m</code></td>
<td>
<p>Expected minimum number of markers in a chromosome. Optional</p>
</td></tr>
<tr><td><code id="buildMap_+3A_use.comu">use.comu</code></td>
<td>
<p>Using community detection algorithm to detect linkage groups. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines linkage groups and order markers within each linkage group for class &quot;netgwasmap&quot;.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"netgwasmap"</code> is returned:  
</p>
<table>
<tr><td><code>map</code></td>
<td>
<p> Constructed linkage map associated with <code>opt.index</code>.</p>
</td></tr>
<tr><td><code>opt.index</code></td>
<td>
<p> The index of a desired 3-D map to construct linkage map.</p>
</td></tr>
<tr><td><code>cross</code></td>
<td>
<p>The specified cross type by user. </p>
</td></tr>
<tr><td><code>allres</code></td>
<td>
<p> A list containing results for different regularization parameter. Belongs to class &quot;netgwas&quot;. To visualize a path of different 3D maps consider function <code><a href="#topic+plot.netgwas">plot.netgwas</a></code>. Note that the input data is reordered based on the estimated linkage map and is saved as data in this argument.</p>
</td></tr>
<tr><td><code>man</code></td>
<td>
<p>stays TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C.Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2018). De novo construction of polyploid linkage maps using discrete graphical models. Bioinformatics. <br />
2. Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CviCol)
#Randomly change the order of markers across the genome
cvicol &lt;- CviCol[ ,sample(ncol(CviCol))]

#Constructing linkage map for Cvi x Col genotype data
out &lt;- netmap(cvicol, cross= "inbred", ncores=1); out
plot(out)
map &lt;- out$map; map

#Visualization of other networks
plot(out$allres)  
#Constructing a linkage map for 5th network
bm &lt;- buildMap(out, opt.index=5); bm
plot(bm, vis= "summary")
#or
plot(bm, vis= "interactive", label.vertex="all")

## End(Not run)
</code></pre>

<hr>
<h2 id='cal.pos'>Estimate genetic map distances </h2><span id='topic+cal.pos'></span>

<h3>Description</h3>

<p>Calculation of genetic map distances for an estimated markers order from either <code>net.map</code> or <code>buildMap</code> functions. This function is only for diploid populations. We note that the output of <code>net.map</code> and <code>buildMap</code> functions include estimated linkage groups and estimated markers order within each linkage group. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.pos (netgwasmap, pop.type= NULL , map.func = "haldane", chr )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.pos_+3A_netgwasmap">netgwasmap</code></td>
<td>
<p>A <code>netgwasmap</code> object. The output of <code><a href="#topic+netmap">netmap</a></code> or <code><a href="#topic+buildMap">buildMap</a></code> functions.</p>
</td></tr>
<tr><td><code id="cal.pos_+3A_pop.type">pop.type</code></td>
<td>
<p>Character string specifying the population type of the genotype data. Accepted values are &quot;DH&quot; (doubled haploid), &quot;BC&quot; (backcross), &quot;RILn&quot; (non-advanced RIL population with n generations of selfing) and &quot;ARIL&quot; (advanced RIL) (see Details). </p>
</td></tr>
<tr><td><code id="cal.pos_+3A_map.func">map.func</code></td>
<td>
<p>Character string defining the distance function used for calculation of genetic
distances. Options are &quot;kosambi&quot;, &quot;haldane&quot;, and &quot;morgan&quot;. Default is &quot;haldane&quot;.</p>
</td></tr>
<tr><td><code id="cal.pos_+3A_chr">chr</code></td>
<td>
<p>A character string of linkage group names that require calculating of their genetic map distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <span class="pkg">qtl</span> package, the genotype data for a backcross is coded as NA = missing, 1 = AA, 2 = AB. For an F2 intercross, the coding is NA = missing, 1 = AA, 2 = AB, 3 = BB, 4 = not BB (i.e. AA or AB), 5 = not AA (i.e. AB or BB).
</p>
<p>If <code>pop.typ = "RILn"</code> the number of generations of selfing is limited to 20 to ensure sensible input. The constructed object is returned as a R/qtl <code>cross</code> object with the appropriate class structure. For <code>"RILn"</code> populations the constructed object is given the class <code>"bcsft"</code> by using the <span class="pkg">qtl</span> package conversion function <code>convert2bcsft</code> with arguments <code>F.gen = n</code> and <code>BC.gen = 0</code>. For <code>"ARIL"</code> populations the constructed object is given the class <code>"riself"</code>.
</p>
<p>This function uses the Viterbi algorithm implemented in <code>argmax.geno</code> of the <span class="pkg">qtl</span> package to estimate genetic distances. Initial conservative estimates of the map distances are calculated from inverting recombination fractions outputted from <code>est.rf</code>. These are then passed to <code>argmax.geno</code> and imputation of missing allele scores is performed along with re-estimation of map distances. This is an adapted version of <code>quickEst</code> function from <span class="pkg">ASMap</span> package.
</p>


<h3>Value</h3>

<p>The <code>netgwas</code> constructed linkage map is returned as a <code>R/qtl</code> cross object. The object is a list with usual components <code>"pheno"</code> and <code>"geno"</code>.
</p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>The <code>"geno"</code> element contains <code>data</code> and <code>map</code> for separated linkage groups which have been constructed using <code>net.map</code> function. </p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p>Character string containing the genotype names.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- simRIL(d=25, n=200, g=5, cM=100, selfing= 2)
 # to use the same genotyping coding as qtl package (See details)
sim$data &lt;- (sim$data) + 1 

 #Estimate linkage groups and order markers within each LG
out &lt;- netmap(sim$data, cross = "inbred")
map &lt;- out$map; map

plot(out)

 #Calculate map positions and convert the map to cross object from qtl package
pos.map &lt;- cal.pos(netgwasmap = out, pop.type= "RIL2", map.func = "haldane" )
plotMap(pos.map)

## End(Not run)
</code></pre>

<hr>
<h2 id='cross2netgwas'><code>cross</code> object to <code>netgwas</code> data frame</h2><span id='topic+cross2netgwas'></span>

<h3>Description</h3>

<p>Converts <code>cross</code> object from R/<span class="pkg">qtl</span> package to <code>netgwas</code> dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cross2netgwas (cross.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross2netgwas_+3A_cross.obj">cross.obj</code></td>
<td>
<p>An object of class <code>cross</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An (<code class="reqn">n \times p</code>) matrix corresponds to a genotype data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). This matrix can be as an input data for <code><a href="#topic+netmap">netmap</a></code>, and <code><a href="#topic+netsnp">netsnp</a></code> functions.
</p>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>

<hr>
<h2 id='cutoffs'>
Cut-points 
</h2><span id='topic+cutoffs'></span>

<h3>Description</h3>

<p>Calculates cut-points of ordinal variables with respect to the Gaussian copula. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoffs(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoffs_+3A_y">y</code></td>
<td>

<p>An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). It also could be an object of class <code>"simgeno"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The relationship between <code class="reqn">j</code>th variable and <code class="reqn">j</code>th latent variable is expressed through this set of cut-points.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cutoffs</code></td>
<td>
<p> A <code class="reqn">p</code> by <code class="reqn">(k + 1)</code> matrix representing the cut-point values under the Gaussian copula, where <code class="reqn">k</code> defines the number of categories in the dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
2. Behrouzi, P., and Wit, E. C. (2018). De novo construction of polyploid linkage maps using discrete graphical models. Bioinformatics. <br />
3. Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lower.upper">lower.upper</a></code>, <code><a href="#topic+simgeno">simgeno</a></code> and <code><a href="#topic+netgwas-package">netgwas-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	D &lt;- simgeno(p = 100, n = 50, k = 3)
	cutoffs(D$data)
</code></pre>

<hr>
<h2 id='CviCol'>Arabidopsis thaliana genotype data </h2><span id='topic+CviCol'></span>

<h3>Description</h3>

 
<p>The genotype data of the Cvi-0 <code class="reqn">\times</code> Col-0 Recombinant Inbred Line (RIL) population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CviCol)</code></pre>


<h3>Format</h3>

<p>The format is a matrix containing 90 single-nucleotide polymorphism (SNP) markers for 367 individuals.
</p>


<h3>Details</h3>

<p>The <em>Arabidopsis thaliana</em> genotype data is derived from a RIL cross between Columbia-0 (Col-0) and the Cape Verde Island (Cvi-0), where 367 individuals were genotyped for 90 genetic markers. This is a diploid population with three possible genotpe states <code>(k = 3)</code>, where the genotypes coded as <code>0, 1, 2</code>, where 0 and 2 represent the homozygous genotypes and 1 defines the heterozygous genotype. <br />
This data set can be used to detect epistatic selection, short- and long- range linkage disequilibrium between 90 SNP markers. 
</p>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>Source</h3>

<p>Simon, M., et al. &quot;QTL mapping in five new large RIL populations of Arabidopsis thaliana genotyped with consensus SNP markers.&quot; Genetics 178 (2008): 2253-2264.
It is publicly available at http://publiclines.versailles.inra.fr/page/8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CviCol)
dim(CviCol)
head(CviCol, n=3)
</code></pre>

<hr>
<h2 id='detect.err'>Identiying likely genotyping error</h2><span id='topic+detect.err'></span>

<h3>Description</h3>

<p> Calculates a LOD score for each genotype, measuring the evidence for genotyping errors. This uses <code>calc.errorlod</code> function from R/<span class="pkg">qtl</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.err(netgwas.map,  err.prob= 0.01, cutoff= 4, 
          pop.type= NULL, map.func= "haldane")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.err_+3A_netgwas.map">netgwas.map</code></td>
<td>
<p>An object of class <code>netgwasmap</code> object (The output of <code><a href="#topic+netmap">netmap</a></code> or <code><a href="#topic+netmap">netmap</a></code> functions).</p>
</td></tr>
<tr><td><code id="detect.err_+3A_err.prob">err.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation of the penetrance Pr(observed
genotype | true genotype).</p>
</td></tr>
<tr><td><code id="detect.err_+3A_cutoff">cutoff</code></td>
<td>
<p>Only those genotypes with error LOD scores above this cutoff will be listed.</p>
</td></tr>
<tr><td><code id="detect.err_+3A_pop.type">pop.type</code></td>
<td>
<p>Character string specifying the population type of the genotype data. Accepted values are &quot;DH&quot; (doubled haploid), &quot;BC&quot; (backcross), &quot;RILn&quot; (non-advanced RIL population with n generations of selfing) and &quot;ARIL&quot; (advanced RIL) (see Details).</p>
</td></tr>
<tr><td><code id="detect.err_+3A_map.func">map.func</code></td>
<td>
<p>Character string defining the distance function used for calculation of genetic
distances. Options are &quot;kosambi&quot;, &quot;haldane&quot;, and &quot;morgan&quot;. Default is &quot;haldane&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with 4 columns, whose rows correspond to the genotypes that are possibly in error.
The four columns give the chromosome number, individual number, marker name, and error LOD
score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- simRIL(d=25, n=200, g=5, cM=100, selfing= 2)
 # to use the same genotyping coding as R/qtl package (See details)
sim$data &lt;- (sim$data) + 1 

 #Estimate linkage groups and order markers within each LG
out &lt;- netmap(sim$data, cross = "inbred")
map &lt;- out$map; map
plot(out)

# A list of genotyoing error
detect.err(out, pop.type = "RIL2")

## End(Not run)
</code></pre>

<hr>
<h2 id='lower.upper'>
Calculates lower band and upper band
</h2><span id='topic+lower.upper'></span>

<h3>Description</h3>

<p>Calculates lower and upper bands for each data point, using a set of cut-points which is obtained from the Gaussian copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower.upper(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower.upper_+3A_y">y</code></td>
<td>
<p> An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). It also could be an object of class <code>"episim"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lower</code></td>
<td>

<p>A <code class="reqn">n</code> by <code class="reqn">p</code> matrix representing the lower band for each data point.
</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>

<p>A <code class="reqn">n</code> by <code class="reqn">p</code> matrix representing the upper band for each data point.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutoffs">cutoffs</a></code> and <code><a href="#topic+netgwas-package">netgwas-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- simgeno(p = 100, n = 50, k = 3)
lower.upper(D$data)
</code></pre>

<hr>
<h2 id='netgwas-internal'>netgwas-internal</h2><span id='topic+netgwas-internal'></span>

<h3>Description</h3>

<p>Internal netgwas functions. These are not intended to be called by the users.
</p>


<h3>Author(s)</h3>

<p>Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt; and Ernst C. Wit</p>

<hr>
<h2 id='netgwas-package'>
Network Based Genome Wide Association Studies
</h2><span id='topic+netgwas-package'></span>

<h3>Description</h3>

<p>The <code>R</code> package <span class="pkg">netgwas</span> provides a set of tools based
on undirected graphical models for accomplishing three important
and interrelated goals in genetics: (1) linkage map construction, 
(2) reconstructing intra- and inter-chromosomal conditional
interactions (linkage disequilibrium) networks, and (3) exploring 
high-dimensional genotype-phenotype network and genotype-phenotype- 
environment interactions network. The netgwas can deal with biparental 
species with any  ploidy level.
The package implemented the recent improvements both for construction 
of linkage maps in diploid and polyploid species in Behrouzi and Wit(2017b),
and in reconstructing networks for non-Gaussian data, ordinal data, and 
mixed continuous and discrete data in Behrouzi and Wit (2017a). One 
application is to uncover epistatic interactions network, where the network
captures the conditionally dependent short- and long-range linkage disequilibrium
structure of a genomes and reveals aberrant marker-marker associations.
In addition, Behrouzi and Wit(2017c) implemented their proposed method to explore 
genotype-phenotype networks where nodes are either phenotypes or genotypes, and each
phenotype is connected by an edge to a genotype or a group of genotypes if 
there is a direct association between them, given the rest of the variables. 
Different phenotypes may also interconnect. The conditionally dependent relationships
between markers on a genome and phenotypes is determined through Gaussian copula graphical model. 
We remark that environmental variables can also be included along with genotype-phenotype
input data to reconstruct networks between genotypes, phenotypes, and environment 
variables. Beside, the package contains functions for simulation and visualization,
as well as three multivariate datasets taken from literature.
</p>


<h3>Author(s)</h3>

<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainers: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
2. Behrouzi, P., and Wit, E. C. (2018). De novo construction of polyploid linkage maps using discrete graphical models. Bioinformatics. <br />
3. Behrouzi, P., Arends, D., and Wit, E. C. (2023). netgwas: An R Package for Network-Based Genome-Wide Association Studies. The R journal, 14(4), 18-37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
install.packages("netgwas")
library(netgwas)

## End(Not run)
</code></pre>

<hr>
<h2 id='netgwas2cross'> netgwasmap object to cross object</h2><span id='topic+netgwas2cross'></span>

<h3>Description</h3>

<p>Convertes <code>netgwasmap</code> object from  <code>net.map</code> or <code>buildMap</code> functions to <code>cross</code> object from R/<span class="pkg">qtl</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   netgwas2cross(netgwasmap, pop.type= NULL, map.func = "haldane")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netgwas2cross_+3A_netgwasmap">netgwasmap</code></td>
<td>
<p>A <code>netgwasmap</code> object. The output of <code><a href="#topic+netmap">netmap</a></code> or <code><a href="#topic+buildMap">buildMap</a></code> functions.</p>
</td></tr>
<tr><td><code id="netgwas2cross_+3A_pop.type">pop.type</code></td>
<td>
<p>Character string specifying the population type of the genotype data. Accepted values are &quot;DH&quot; (doubled haploid), &quot;BC&quot; (backcross), &quot;RILn&quot; (non-advanced RIL population with n generations of selfing) and &quot;ARIL&quot; (advanced RIL).</p>
</td></tr>
<tr><td><code id="netgwas2cross_+3A_map.func">map.func</code></td>
<td>
<p>Character string defining the distance function used for calculation of genetic distances. Options are &quot;kosambi&quot;, &quot;haldane&quot;, and &quot;morgan&quot;. Default is &quot;haldane&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pop.typ = "RILn"</code> the number of generations of selfing is limited to 20 to ensure sensible input. The constructed object is returned as a R/qtl <code>cross</code> object with the appropriate class structure. For <code>"RILn"</code> populations the constructed object is given the class <code>"bcsft"</code> by using the <span class="pkg">qtl</span> package conversion function <code>convert2bcsft</code> with arguments <code>F.gen = n</code> and <code>BC.gen = 0</code>. For <code>"ARIL"</code> populations the constructed object is given the class <code>"riself"</code>.
</p>
<p>In R/<span class="pkg">qtl</span> package, the genotype data for a backcross is coded as NA = missing, 1 = AA, 2 = AB. For an F2 intercross, the coding is NA = missing, 1 = AA, 2 = AB, 3 = BB, 4 = not BB (i.e. AA or AB), 5 = not AA (i.e. AB or BB).
</p>


<h3>Value</h3>

<p>The <code>netgwas.map</code> object is returned as a <code>cross</code> object form R/<span class="pkg">qtl</span>. The object is a list with usual components <code>"pheno"</code> and <code>"geno"</code>.
</p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>The <code>"geno"</code> element contains <code>data</code> and <code>map</code> for separated linkage groups which have been constructed using <code>net.map</code> function. </p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p>Character string containing the genotype names.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    sim &lt;- simRIL(d=25, n=200, g=5, cM=100, selfing= 2)
    # to use the same genotyping coding as R/qtl package (See details)
    sim$data &lt;- (sim$data) + 1 
    
    #Estimate linkage groups and order markers within each LG
    out &lt;- netmap(sim$data, cross = "inbred")
    map &lt;- out$map; map
    
    plot(out)
    
    #Calculate map positions and convert the map to cross object from qtl package
    map &lt;- netgwas2cross(netgwasmap = out, pop.type= "RIL2", map.func = "haldane" )
    plotMap(map)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='netmap'>Constructing linkage map for diploids and polyploids</h2><span id='topic+netmap'></span>

<h3>Description</h3>

<p>This is one of the main functions of <span class="pkg">netgwas</span> package. This function reconstructs linkage maps for biparental diploid and polyploid organisms using three methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netmap(data, method = "npn", cross= NULL, rho = NULL, n.rho = NULL, 
      rho.ratio = NULL, min.m= NULL, use.comu= FALSE, ncores = "all",
		  em.iter = 5, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netmap_+3A_data">data</code></td>
<td>
<p> An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to a genotype data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). Input data can contain missing values.</p>
</td></tr>
<tr><td><code id="netmap_+3A_method">method</code></td>
<td>
<p>Three available methods to construct linkage map: &quot;gibbs&quot;, &quot;approx&quot;, and &quot;npn&quot;. Default is &quot;npn&quot;</p>
</td></tr>
<tr><td><code id="netmap_+3A_rho">rho</code></td>
<td>
<p> A decreasing sequence of non-negative numbers that control the sparsity level. Leaving the input as <code>rho = NULL</code>, the program automatically computes a sequence of <code>rho</code> based on <code>n.rho</code> and <code>rho.ratio</code>. Users can also supply a decreasing sequence values to override this.</p>
</td></tr>
<tr><td><code id="netmap_+3A_n.rho">n.rho</code></td>
<td>
<p> The number of regularization parameters. The default value is <code>6</code>.</p>
</td></tr>
<tr><td><code id="netmap_+3A_rho.ratio">rho.ratio</code></td>
<td>
<p> Determines distance between the elements of <code>rho</code> sequence. A small value of <code>rho.ratio</code> results in a large distance between the elements of <code>rho</code> sequence. And a large value of <code>rho.ratio</code> results into a small distance between elements of <code>rho</code>. If keep it as NULL the program internally chooses a value.</p>
</td></tr>
<tr><td><code id="netmap_+3A_cross">cross</code></td>
<td>
<p>To be specified either &quot;inbred&quot; or &quot;outbred&quot;.</p>
</td></tr>
<tr><td><code id="netmap_+3A_min.m">min.m</code></td>
<td>
<p> Expected minimum number of markers in a chromosome. Optional</p>
</td></tr>
<tr><td><code id="netmap_+3A_use.comu">use.comu</code></td>
<td>
<p>Use community detection algorithm to detect linkage groups. Default is FALSE.</p>
</td></tr>
<tr><td><code id="netmap_+3A_ncores">ncores</code></td>
<td>
<p> The number of cores to use for the calculations. Using <code>ncores = "all"</code> automatically detects number of available cores and runs the computations in parallel on (available cores - 1).</p>
</td></tr>
<tr><td><code id="netmap_+3A_em.iter">em.iter</code></td>
<td>
<p>The number of EM iterations. The default value is 5.</p>
</td></tr>
<tr><td><code id="netmap_+3A_verbose">verbose</code></td>
<td>
<p>Providing a detail message for tracing output. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructing linkage maps for diploid and polyploid organisms. Diploid organisms contain two sets of chromosomes, one from each parent, whereas polyploids contain more than two sets of chromosomes. Inbreeding is mating between two parental lines where they have recent common biological ancestors. If they have no common ancestors up to roughly e.g. 4-6 generations, this is called outcrossing. In both cases the genomes of the derived progenies are random mosaics of the genome of the parents. However, in the case of inbreeding parental alleles are distinguishable in the genome of the progeny; in outcrossing this does not hold.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"netgwasmap"</code> is returned:  
</p>
<table>
<tr><td><code>map</code></td>
<td>
<p>Constructed linkage map.</p>
</td></tr>
<tr><td><code>opt.index</code></td>
<td>
<p> The index of selected graph using model selection.</p>
</td></tr>
<tr><td><code>cross</code></td>
<td>
<p>The pre-specified cross type. </p>
</td></tr>
<tr><td><code>allres</code></td>
<td>
<p> A list containing results for different regularization parameter. Belongs to class &quot;netgwas&quot;. To visualize a path of different 3D maps consider function <code><a href="#topic+plot.netgwas">plot.netgwas</a></code>. Note that the input data is reordered based on the estimated linkage map and is saved as data in this argument.</p>
</td></tr>
<tr><td><code>man</code></td>
<td>
<p>Stays FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainers: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2018). De novo construction of polyploid linkage maps using discrete graphical models. Bioinformatics. <br />
2. Behrouzi, Pariya, and Ernst C. Wit. &quot;netgwas: An R Package for Network-Based Genome-Wide Association Studies.&quot; arXiv preprint arXiv:1710.01236 (2017). <br />
3. Guo, Jian, Elizaveta Levina, George Michailidis, and Ji Zhu. &quot;Graphical models for ordinal data.&quot; Journal of Computational and Graphical Statistics 24, no. 1 (2015): 183-204. <br />
4. Liu, Han, Fang Han, Ming Yuan, John Lafferty, and Larry Wasserman. &quot;High-dimensional semiparametric Gaussian copula graphical models.&quot; The Annals of Statistics 40, no. 4 (2012): 2293-2326. <br /> 
5. Witten, Daniela M., Jerome H. Friedman, and Noah Simon. &quot;New insights and faster computations for the graphical lasso.&quot; Journal of Computational and Graphical Statistics 20, no. 4 (2011): 892-900.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CviCol)
#Randomly change the order of markers across the genome
cvicol &lt;- CviCol[ ,sample(ncol(CviCol))]
 
#Constructing linkage map using gibbs method
out &lt;- netmap(cvicol, cross= "inbred", ncores=1); out
#Estimated linkage map
map &lt;- out$map; map
#Plot the associated network
plot(out)
#Visualizing the path networks
plot(out$allres)
#Build a linkage map for 5th networks
bm &lt;- buildMap(out, opt.index=5); bm
####################

#Constructing linkage map using approx method
out2 &lt;- netmap(cvicol, method="approx", cross= "inbred", ncores=1); out2
#Estimated linkage map
map2 &lt;- out2$map; map2
#Plot the related network
plot(out2)
#Visualize other networks
plot(out2$allres)
#Build a linkage map for 5th network
bm2 &lt;- buildMap(out2, opt.index=5); bm2

#Constructing linkage map using npn method
out3 &lt;- netmap(cvicol, method="npn", cross= "inbred", ncores=1); out3
#Estimated linkage map
map3 &lt;- out3$map; map3
#Plot the related network
plot(out3)

## End(Not run)
</code></pre>

<hr>
<h2 id='netphenogeno'>Reconstructs conditional dependence network among genetic loci and phenotypes</h2><span id='topic+netphenogeno'></span>

<h3>Description</h3>

<p>This is one of the main functions of the <span class="pkg">netgwas</span> package. This function reconstructs a conditional independence network between genotypes and phenotypes for diploids and polyploids. Three methods are available to reconstruct networks, namely (i) Gibbs sampling, (ii) approximation method, and (iii) nonparanormal approach within the Gaussian copula graphical model. The first two methods are able to deal with missing genotypes. The last one is computationally faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netphenogeno(data, method = "gibbs", rho = NULL, n.rho = NULL, rho.ratio = NULL,
		ncores = 1, em.iter = 5, em.tol=.001, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netphenogeno_+3A_data">data</code></td>
<td>
<p> An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). The <code class="reqn">p</code> columns include either a marker or trait(s) information. Input data can contain missing values.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_method">method</code></td>
<td>
<p>Reconstructing both genotype-phenotype interactions network and genotype-phenotype-environment interactions network with three methods: &quot;gibbs&quot;, &quot;approx&quot;, and &quot;npn&quot;. For a medium (~500) and a large number of variables we recommend to choose &quot;gibbs&quot; and &quot;approx&quot;, respectively. Choosing &quot;npn&quot; for a very large number of variables (&gt; 2000) is computationally efficient. The default method is &quot;gibbs&quot;.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_rho">rho</code></td>
<td>
<p> A decreasing sequence of non-negative numbers that control the sparsity level. Leaving the input as <code>rho = NULL</code>, the program automatically computes a sequence of <code>rho</code> based on <code>n.rho</code> and <code>rho.ratio</code>. Users can also supply a decreasing sequence values to override this.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_n.rho">n.rho</code></td>
<td>
<p> The number of regularization parameters. The default value is <code>10</code>.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_rho.ratio">rho.ratio</code></td>
<td>
<p> Determines distance between the elements of <code>rho</code> sequence. A small value of <code>rho.ratio</code> results in a large distance between the elements of <code>rho</code> sequence. And a large value of <code>rho.ratio</code> results into a small distance between elements of <code>rho</code>. The default value is <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_ncores">ncores</code></td>
<td>
<p> The number of cores to use for the calculations. Using <code>ncores = "all"</code> automatically detects number of available cores and runs the computations in parallel on (available cores - 1).</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_em.iter">em.iter</code></td>
<td>
<p> The number of EM iterations. The default value is 5.</p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_em.tol">em.tol</code></td>
<td>
<p> A criteria to stop the EM iterations. The default value is .001. </p>
</td></tr>
<tr><td><code id="netphenogeno_+3A_verbose">verbose</code></td>
<td>
<p>Providing a detail message for tracing output. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reconstructs both genotype-phenotype network and genotype-phenotype-environment interactions network. In genotype-phenotype networks nodes are either markers or phenotypes; each phenotype is connected by an edge to a marker if there is a direct association between them given the rest of the variables. Different phenotypes may also interconnect.  In addition to markers and phenotypes information, the input data can include environmental variables. Then, the interactions network shows the conditional dependence relationships between markers, phenotypes and environmental factors.</p>


<h3>Value</h3>

<p>An object with S3 class <code>"netgwas"</code> is returned:  
</p>
<table>
<tr><td><code>Theta</code></td>
<td>
<p> A list of estimated p by p precision matrices that show the conditional independence relationships patterns among measured items.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p> A list of estimated p by p adjacency matrices. This is the graph path corresponding to <code>Theta</code>.</p>
</td></tr>
<tr><td><code>ES</code></td>
<td>
<p> A list of estimated p by p conditional expectation corresponding to <code>rho</code>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p> A list of n by p transformed data based on Gaussian copula. </p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p> A <code>n.rho</code> dimensional vector containing the penalty terms.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p> A <code>n.rho</code> dimensional vector containing the maximized log-likelihood values along the graph path. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> The <code class="reqn">n</code> by <code class="reqn">p</code> input data matrix. The <code class="reqn">n</code> by <code class="reqn">p</code> transformed data in case of using &quot;npn&quot;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function estimates a graph path . To select an optimal graph please refer to <code><a href="#topic+selectnet">selectnet</a></code>.</p>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainers: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
2. Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236. <br />
3. D. Witten and J. Friedman. New insights and faster computations for the graphical lasso. <em>Journal of Computational and Graphical Statistics</em>, to appear, 2011. <br />
4. Guo, Jian, et al. &quot;Graphical models for ordinal data.&quot; Journal of Computational and Graphical Statistics 24.1 (2015): 183-204. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectnet">selectnet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    
		data(thaliana)
		head(thaliana, n=3)
		#Construct a path for genotype-phenotype interactions network in thaliana data
		res &lt;-  netphenogeno(data = thaliana); res
		plot(res)
		#Select an optimal network
		sel &lt;- selectnet(res)
		#Plot selected network and the conditional correlation (CI) relationships 
		plot(sel, vis="CI")
		plot(sel, vis="CI", n.mem = c(8, 56, 31, 33, 31, 30), w.btw =50, w.within= 1)
		
		#Visualize interactive plot for the selected network
		#Color "red" for 8 phenotypes, and different colors for each chromosome.
		cl &lt;- c(rep("red", 8), rep("white",56), rep("tan1",31), 
		      rep("gray",33), rep("lightblue2",31), rep("salmon2",30))
		      
		#The IDs of phenotypes and SNPs to be shown in the network       
    id &lt;- c("DTF_LD","CLN_LD","RLN_LD","TLN_LD","DTF_SD","CLN_SD","RLN_SD", 
        "TLN_SD","snp15","snp16","snp17","snp49","snp50","snp60","snp75",
        "snp76","snp81","snp83","snp84","snp86","snp82", "snp113","snp150",
        "snp155","snp159","snp156","snp161","snp158","snp160","snp162","snp181")
		
		plot(sel, vis="interactive", n.mem = c(8, 56, 31, 33, 31, 30), vertex.color= cl,
		    label.vertex= "some", sel.nod.label= id, edge.color= "gray", w.btw= 50,
		    w.within= 1)
		
		#Partial correlations between genotypes and phenotypes in the thaliana dataset.
		library(Matrix)
		image(sel$par.cor, xlab="geno-pheno", ylab="geno-pheno", sub="")
	
</code></pre>

<hr>
<h2 id='netsnp'>Reconstructs intra- and inter- chromosomal conditional interactions among genetic loci</h2><span id='topic+netsnp'></span>

<h3>Description</h3>

<p>This is one of the main functions of the <span class="pkg">netgwas</span> package. This function can be used to reconstruct the intra- and inter-chromosomal interactions among genetic loci in diploids and polyploids. The input data can be belong to any biparental genotype data which contains at least two genotype states. Two methods are available to reconstruct the network, namely (1) approximation method, and (2) gibbs sampling within the Gaussian copula graphical model. Both methods are able to deal with missing genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsnp(data, method = "gibbs", rho = NULL, n.rho = NULL, rho.ratio = NULL, 
		ncores = 1, em.iter = 5, em.tol = .001, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netsnp_+3A_data">data</code></td>
<td>
<p> An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to a genotype data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). It also could be an object of class <code>"simgeno"</code>. Input data can contain missing values.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_method">method</code></td>
<td>
<p> Reconstructs intra- and inter- chromosomal conditional interactions (epistatic selection) network with three methods: &quot;gibbs&quot;, &quot;approx&quot;, and &quot;npn&quot;. For a medium (~500) and a large number of variables we would recommend to choose &quot;gibbs&quot; and &quot;approx&quot;, respectively. For a very large number of variables (&gt; 2000) choose &quot;npn&quot;. The default method is &quot;gibbs&quot;.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_rho">rho</code></td>
<td>
<p> A decreasing sequence of non-negative numbers that control the sparsity level. Leaving the input as <code>rho = NULL</code>, the program automatically computes a sequence of <code>rho</code> based on <code>n.rho</code> and <code>rho.ratio</code>. Users can also supply a decreasing sequence values to override this.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_n.rho">n.rho</code></td>
<td>
<p> The number of regularization parameters. The default value is <code>10</code>.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_rho.ratio">rho.ratio</code></td>
<td>
<p>Determines the distance between the elements of <code>rho</code> sequence. A small value of <code>rho.ratio</code> results in a large distance between the elements of <code>rho</code> sequence. And a large value of <code>rho.ratio</code> results into a small distance between elements of <code>rho</code>. If keep it as NULL the program internally chooses a value.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_ncores">ncores</code></td>
<td>
<p> The number of cores to use for the calculations. Using <code>ncores = "all"</code> automatically detects number of available cores and runs the computations in parallel on (available cores - 1).</p>
</td></tr>
<tr><td><code id="netsnp_+3A_em.iter">em.iter</code></td>
<td>
<p> The number of EM iterations. The default value is 5.</p>
</td></tr>
<tr><td><code id="netsnp_+3A_em.tol">em.tol</code></td>
<td>
<p> A criteria to stop the EM iterations. The default value is .001. </p>
</td></tr>
<tr><td><code id="netsnp_+3A_verbose">verbose</code></td>
<td>
<p>Providing a detail message for tracing output. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Viability is a phenotype that can be considered. This function detects the conditional dependent short- and long-range linkage disequilibrium structure of genomes and thus reveals aberrant marker-marker associations that are due to epistatic selection.
This function can be used to estimate conditional independence relationships between partially observed data that not follow Gaussianity assumption (e.g. continuous non-Gaussian, discrete, or mixed dataset).
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"netgwas"</code> is returned:  
</p>
<table>
<tr><td><code>Theta</code></td>
<td>
<p> A list of estimated p by p precision matrices that show the conditional independence relationships patterns among genetic loci.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p> A list of estimated p by p adjacency matrices. This is the graph path corresponding to <code>Theta</code>.</p>
</td></tr>
<tr><td><code>ES</code></td>
<td>
<p> A list of estimated p by p conditional expectation corresponding to <code>rho</code>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p> A list of n by p transformed data based on Gaussian copula. </p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p> A <code>n.rho</code> dimensional vector containing the penalty terms.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p> A <code>n.rho</code> dimensional vector containing the maximized log-likelihood values along the graph path. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> The <code class="reqn">n</code> by <code class="reqn">p</code> input data matrix. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function estimates a graph path . To select an optimal graph please refer to <code><a href="#topic+selectnet">selectnet</a></code>.</p>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainers: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
2. Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
3. D. Witten and J. Friedman. New insights and faster computations for the graphical lasso. <em>Journal of Computational and Graphical Statistics</em>, to appear, 2011. <br />
4. Guo, Jian, et al. &quot;Graphical models for ordinal data.&quot; Journal of Computational and Graphical Statistics 24.1 (2015): 183-204. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectnet">selectnet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    
	
		data(CviCol)
		out &lt;- netsnp(CviCol); out
		plot(out)
		
		#select optimal graph
		epi &lt;- selectnet(out)
		plot(epi, vis="CI", xlab="markers", ylab="markers", 
		    n.mem = c(24,14,17,16,19), vertex.size=4)
		    
		#Visualize interactive plot of the selected network
		#Different colors for each chromosome
		cl &lt;- c(rep("red", 24), rep("white",14), rep("tan1",17), 
		      rep("gray",16), rep("lightblue2",19))
		plot(epi, vis="interactive", vertex.color= cl)
		
		#Partial correlations between markers on genome
		image(as.matrix(epi$par.cor), xlab="markers", ylab="markers", sub="")
		
</code></pre>

<hr>
<h2 id='plot.netgwas'> plot for S3 class &quot;netgwas&quot; </h2><span id='topic+plot.netgwas'></span>

<h3>Description</h3>

<p>Plot the graph path which is the output of two functions <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netgwas'
plot( x, n.markers=NULL , ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netgwas_+3A_x">x</code></td>
<td>
<p>An object from &quot;netgwas&quot; class.</p>
</td></tr>
<tr><td><code id="plot.netgwas_+3A_n.markers">n.markers</code></td>
<td>
<p>A vector containing number of variables/markers in each group/chromosome. For example, the CviCol dataset that is provided in the package contains 5 chromosomes/ groups which the total number of markers is <code class="reqn">p = 90</code>, where the first 24 markers belong into chromosome 1, the next 14 markers into chromosome 2, ..., and chromosome 5 contains 19 markers. Thus, n.mrkr = c(24,14,17,16,19). If <code>n.mrkr = NULL</code>, in the graph visualization all markers are represented same colour.</p>
</td></tr>
<tr><td><code id="plot.netgwas_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a>
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code>.</p>

<hr>
<h2 id='plot.netgwasmap'> plot for S3 class &quot;netgwasmap&quot; </h2><span id='topic+plot.netgwasmap'></span>

<h3>Description</h3>

<p>Plot the graph associated with constructed linkage map via function <code><a href="#topic+netmap">netmap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netgwasmap'
plot(x, vis= NULL, layout= NULL, vertex.size= NULL, label.vertex =
		"none", label.size= NULL, vertex.color= NULL, edge.color = "gray29",
		sel.ID = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netgwasmap_+3A_x">x</code></td>
<td>
<p>An object from &quot;netgwasmap&quot; class.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_vis">vis</code></td>
<td>
<p>Visualizing in four options: (i) &quot;summary&quot; plots the related network, conditional dependence relationships between markers before and after ordering markers; (ii) &quot;interactive&quot; plots the associated network, where it opens a new windows with interactive graph drawing facility; (iii) &quot;unordered markers&quot; plots the conditional dependence relationships between markers before ordering markers; (iv) &quot;ordered markers&quot; plots conditional dependence relationships between markers after ordering markers. Default is &quot;summary&quot;.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_layout">layout</code></td>
<td>
<p>The vertex placement algorithm which is according to <span class="pkg">igraph</span> package. The default layout is Fruchterman-Reingold layout. Other possible layouts are, for example, layout_with_kk, circle, and Reingold-Tilford graph in <span class="pkg">igraph</span> package. </p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_vertex.size">vertex.size</code></td>
<td>
<p> Optional integer to adjust vertex size in graph G. Default is 5.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_label.vertex">label.vertex</code></td>
<td>
<p>Assign names to the vertices. There are three options: &quot;none&quot;, &quot;some&quot;, &quot;all&quot;. (i) Specifying &quot;none&quot; omits vertex labels in the graph, (ii) using <code>label.vertex</code> = &quot;some&quot; you need to provide a vector of vertex IDs or a single vertex ID to the <code>sel.ID</code> argument, which you would like to be shown in the graph. <code>label.vertex</code> = &quot;some&quot; is only applicable for <code>vis</code> = &quot;interactive&quot;, (iii) Specifying &quot;all&quot; includes all vertex labels in the graph. Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_label.size">label.size</code></td>
<td>
<p>Optional integer to adjust the size of node's label in graph G. Applicable when vertex.label is TRUE. Default is 0.8.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Optional integer vectors giving colors to the vertices. </p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_edge.color">edge.color</code></td>
<td>
<p>Optional integer vectors giving colors to edges. </p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_sel.id">sel.ID</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot;. A vector of vertex IDs or a single vertex ID, which you would like to be shown in the graph. ONLY applicable when <code>label.vertex</code>=&quot;some&quot;.</p>
</td></tr>
<tr><td><code id="plot.netgwasmap_+3A_...">...</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;CI&quot;. System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Behrouzi, P., and Wit, E. C. (2018). De novo construction of polyploid linkage maps using discrete graphical models. Bioinformatics. <br />
2. Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+buildMap">buildMap</a></code>.</p>

<hr>
<h2 id='plot.select'> Plot function for S3 class &quot;select&quot; </h2><span id='topic+plot.select'></span>

<h3>Description</h3>

<p>Plot the optimal graph by model selection  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
plot(x, vis= NULL, xlab= NULL, ylab= NULL, n.mem= NULL, vertex.label= FALSE
, ..., layout= NULL, label.vertex= "all", vertex.size= NULL, vertex.color= NULL,
edge.color= "gray29", sel.nod.label= NULL, label.size = NULL, w.btw= 800,
 w.within = 10, sign.edg= TRUE, edge.width= NULL, edge.label= NULL,
max.degree= NULL, layout.tree= NULL, root.node= NULL, degree.node= NULL,  
curve= FALSE, delet.v =TRUE, pos.legend= "bottomleft", cex.legend= 0.8, 
iterl = NULL, temp = NULL, tk.width = NULL, tk.height= NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.select_+3A_x">x</code></td>
<td>
<p>An object with S3 class &quot;select&quot; </p>
</td></tr>
<tr><td><code id="plot.select_+3A_vis">vis</code></td>
<td>
<p>Visualizing the results as a graph (network) or as a matrix. There are 4 options to visulize the selected graph: (i) &quot;CI&quot;: plotting conditional independence (CI) relationships between variables, (ii) &quot;interactive&quot;: plotting the conditional independence network, where opens a new windows with interactive graph drawing facility, and (iii) &quot;parcor.network&quot;: plots the estimated graph based on partial correlation values. (iv) &quot;parcor.interactive&quot;: plots the estimated graph based on partial correlation matrix with an interactive graph drawing facility. Default is &quot;CI&quot;. <br />
Also, there are 3 options to visulaze the selected graph as a matrix: (i) <code>vis</code>= &quot;image.parcorMatrix&quot; plots the image of partial correlation matrix, (ii)  <code>vis</code> = &quot;image.adj&quot; draws the adjacency matrix (only presence and absence of links), (iii) <code>vis</code> = &quot;image.precision&quot; plots the selected precision matrix.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_xlab">xlab</code></td>
<td>
<p>ONLY applicable when <code>vis = "CI"</code>, &quot;image.parcorMatrix&quot;, &quot;image.adj&quot;, or &quot;image.precision&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_ylab">ylab</code></td>
<td>
<p>ONLY applicable when <code>vis = "CI"</code>, &quot;image.parcorMatrix&quot;, &quot;image.adj&quot;, or &quot;image.precision&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_n.mem">n.mem</code></td>
<td>
<p>A vector of memberships. For example, the CviCol dataset, which is provided in the package, contain 5 chromosomes which the total number of markers is <code class="reqn">p = 90</code>, where the first 24 markers belong into chromosome 1, the next 14 markers into chromosome 2, ..., and chromosome 5 contains 19 markers. Thus, n.mem = c(24,14,17,16,19). If <code>n.mem = NULL</code> and <code>vis = "CI"</code> all vertices are coloured the same.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_vertex.label">vertex.label</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;CI&quot;. Assign names to the vertices. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_...">...</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;CI&quot;. System reserved (No specific usage)</p>
</td></tr>
<tr><td><code id="plot.select_+3A_layout">layout</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot; or &quot;parcor.network&quot;. The layout specification. Some graph layouts examples: layout_with_fr, layout_in_circle, layout_as_tree, and layout.fruchterman.reingold. The default layout is layout_with_fr.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_label.vertex">label.vertex</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot;. Assign names to the vertices. There are three options: &quot;none&quot;, &quot;some&quot;, &quot;all&quot;. Specify &quot;none&quot; to omit vertex labels in the graph; using <code>label.vertex</code> = &quot;some&quot; you must provide a vector of vertex IDs or a single vertex ID to the <code>sel.label</code> argument, which you would like to be shown in the graph. Specify &quot;all&quot; to include all vertex labels in the graph. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_vertex.size">vertex.size</code></td>
<td>
<p> Optional. The size of vertices in the graph visualization. The default value is 7.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_vertex.color">vertex.color</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot; or &quot;parcor.network&quot;. Optional vector (or a color name) giving the colors of the vertices. The default is &quot;red&quot; </p>
</td></tr>
<tr><td><code id="plot.select_+3A_edge.color">edge.color</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot;. Optional. The default is &quot;gray&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_sel.nod.label">sel.nod.label</code></td>
<td>
<p>ONLY applicable when <code>vis</code>= &quot;interactive&quot; or &quot;parcor.network&quot;. A vector of vertex IDs or a single vertex ID, which you would like to be shown in the graph. ONLY applicable when <code>label.vertex</code>=&quot;some&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_label.size">label.size</code></td>
<td>
<p>ONLY applicable for <code>vis</code>= &quot;interactive&quot; or <code>vis</code>= &quot;parcor.network&quot;. The font size of the vertex labels.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_w.btw">w.btw</code></td>
<td>
<p>Distance between nodes from different memberships of <code>n.mem</code> in layout.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_w.within">w.within</code></td>
<td>
<p>Distance of nodes within one membership of <code>n.mem</code> in layout.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_sign.edg">sign.edg</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. If <code>TRUE</code> then edges are colored as red and blue, where red stands for positive and blue negative partial correlation values. If <code>FASLE</code> all edeges are colored as gray. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_edge.width">edge.width</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. Based on the strength of partial correlation values, edges will shown with different line type. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_edge.label">edge.label</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. If TRUE then the partial correlation values will be shown on top of each edge. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_max.degree">max.degree</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. A number showing degree of a node. This can be used to print those vertex labels that the correspondence vertex have at least e.g. 1 degree.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_layout.tree">layout.tree</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. If TRUE then it uses <code>layout_as_tree</code> from <code>igraph</code> package. Default is FALSE.</p>
</td></tr> 
<tr><td><code id="plot.select_+3A_root.node">root.node</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. The index of the root vertex or root vertices. If this is a non-empty vector then the supplied vertex ids are used as the roots of the trees . If it is an empty vector, then the root vertices are automatically calculated based on topological sorting, performed with the opposite mode than the mode argument. After the vertices have been sorted, one is selected from each component.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_degree.node">degree.node</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. It is related to the vertex label degree. It controls the position of the labels with respect to the vertices. Value are for example -pi/2, 0, pi/2, pi sets above, to the right, below, to the left of a node, respectively.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_curve">curve</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.network&quot;. Edge curvature, range between 0 and 1 (FALSE sets it to 0, TRUE to 0.5). Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_delet.v">delet.v</code></td>
<td>
<p> Delete vertices with no edges. Default is &quot;TRUE&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_pos.legend">pos.legend</code></td>
<td>
<p>Applicable when <code>vis</code>= &quot;parcor.network&quot; or <code>vis</code>= &quot;CI&quot;. The x and y co-ordinates to be used to position the legend. They can be specified by keywords like &quot;topright&quot;, &quot;topleft&quot;, and etc. Default is &quot;bottomleft&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Applicable when <code>vis</code>= &quot;parcor.network&quot; or <code>vis</code>= &quot;CI&quot;.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_iterl">iterl</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.interactive&quot;. integer scalar, the number of iterations to perform for layout_with_fr layout.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_temp">temp</code></td>
<td>
<p>Optional. ONLY applicable when <code>vis</code>= &quot;parcor.interactive&quot;. Real scalar, the start temperature for layout_with_fr layout.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_tk.width">tk.width</code></td>
<td>
<p>Optional. The size of the drawing area of interactive plot.</p>
</td></tr>
<tr><td><code id="plot.select_+3A_tk.height">tk.height</code></td>
<td>
<p>Optional. The size of the drawing area of interactive plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"select"</code> is returned:  
</p>
<table>
<tr><td><code>network</code></td>
<td>
<p> Plot of a selected graph,  when <code>vis</code>= &quot;CI&quot;.</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p> Conditional independence (CI) relationships between variables, when <code>vis</code>= &quot;CI&quot;</p>
</td></tr>
<tr><td><code>network</code></td>
<td>
<p>Interactive plot of a selected graph with .eps format, when <code>vis</code>= &quot;interactive&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+select">select</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>		   
		#simulate data
		data(CviCol)
		out &lt;- netsnp(CviCol)
		sel &lt;- selectnet(out)
		
		cl &lt;- c(rep("palegoldenrod", 24), rep("white",14), rep("tan1",17), 
            rep("gray",16), rep("lightblue2",19))
    plot(sel, vis= "parcor.network", sign.edg = TRUE, layout = NULL, vertex.color = cl)    
	
</code></pre>

<hr>
<h2 id='plot.simgeno'> Plot function for <code>S3</code> class <code>"simgeno"</code> </h2><span id='topic+plot.simgeno'></span>

<h3>Description</h3>

<p> Visualizes the pattern of the true graph, the adjacency matrix, precison matrix and the covariance matrix of the simulated data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simgeno'
plot(x, layout = layout.fruchterman.reingold, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simgeno_+3A_x">x</code></td>
<td>
<p>An object of <code>S3</code> class <code>"simgeno"</code>, from function <code><a href="#topic+simgeno">simgeno</a></code>. </p>
</td></tr>
<tr><td><code id="plot.simgeno_+3A_layout">layout</code></td>
<td>
<p>The default is <code>"layout.fruchterman.reingold"</code>.</p>
</td></tr>
<tr><td><code id="plot.simgeno_+3A_...">...</code></td>
<td>
<p> System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simgeno">simgeno</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generating discrete ordinal data with "genome-like" graph structure
data.sim &lt;- simgeno(alpha = 0.01, beta = 0.02)
plot( data.sim )

## End(Not run)
</code></pre>

<hr>
<h2 id='print.netgwas'>
Print function for S3 class &quot;netgwas&quot;
</h2><span id='topic+print.netgwas'></span>

<h3>Description</h3>

<p>Print a summary of results from function <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netgwas'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netgwas_+3A_x">x</code></td>
<td>

<p>An object with S3 class &quot;netgwas&quot;
</p>
</td></tr>
<tr><td><code id="print.netgwas_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code>
</p>

<hr>
<h2 id='print.netgwasmap'>
Print function for S3 class &quot;netgwasmap&quot;
</h2><span id='topic+print.netgwasmap'></span>

<h3>Description</h3>

<p>Print a summary of results from function <code><a href="#topic+netmap">netmap</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netgwasmap'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netgwasmap_+3A_x">x</code></td>
<td>

<p>An object with S3 class &quot;netgwasmap&quot;
</p>
</td></tr>
<tr><td><code id="print.netgwasmap_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>
</p>

<hr>
<h2 id='print.select'>
Print function for S3 class &quot;select&quot;
</h2><span id='topic+print.select'></span>

<h3>Description</h3>

<p>Print function for <code><a href="#topic+selectnet">selectnet</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.select_+3A_x">x</code></td>
<td>

<p>An object with S3 class &quot;select&quot;
</p>
</td></tr>
<tr><td><code id="print.select_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectnet">selectnet</a></code>
</p>

<hr>
<h2 id='print.simgeno'>
Print function for S3 class &quot;simgeno&quot;
</h2><span id='topic+print.simgeno'></span>

<h3>Description</h3>

<p>Print a summary of simulated data from function <code><a href="#topic+simgeno">simgeno</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simgeno'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.simgeno_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"simgeno"</code>
</p>
</td></tr>
<tr><td><code id="print.simgeno_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simgeno">simgeno</a></code> 
</p>

<hr>
<h2 id='R.approx'> The expectation of covariance using approximation method </h2><span id='topic+R.approx'></span>

<h3>Description</h3>

<p>This function implements the approximation method within the Gaussian copula graphical model to estimate the conditional expectation for the data that not follow Gaussianity assumption (e.g. ordinal, discrete, continuous non-Gaussian, or mixed dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.approx(y, Z = NULL, Sigma=NULL, rho = NULL, ncores = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R.approx_+3A_y">y</code></td>
<td>
<p>An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). 
It also could be an object of class <code>"simgeno"</code>.</p>
</td></tr>
<tr><td><code id="R.approx_+3A_z">Z</code></td>
<td>
<p> A (<code class="reqn">n \times p</code>) matrix which is a transformation of the data via the Gaussian copula. If <code>Z = NULL</code> internally calculates an initial value for <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="R.approx_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of the latent variable given the data. If <code>Sigma = NULL</code> the Sigma matrix is calculated internally with a desired penalty term, <code>rho</code>.</p>
</td></tr>
<tr><td><code id="R.approx_+3A_rho">rho</code></td>
<td>
<p>A (non-negative) regularization parameter to calculate <code>Sigma</code>. rho=0 means no regularization.</p>
</td></tr>
<tr><td><code id="R.approx_+3A_ncores">ncores</code></td>
<td>
<p>If <code>ncores = NULL</code>, the algorithm internally detects number of available cores and run the calculations in parallel on (available cores - 1). Typical usage is to fix <code>ncores = 1</code> when <code class="reqn">p</code> is small <code class="reqn">( p &lt; 500 )</code>, and <code>ncores = NULL</code> when <code class="reqn">p</code> is large.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ES</code></td>
<td>
<p>Expectation of covariance matrix( diagonal scaled to 1) of the Gaussian copula graphical model.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p> New transformation of the data based on given or default <code>Sigma</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Behrouzi, P., Arends, D., and Wit, E. C. (2023). netgwas: An R Package for Network-Based Genome-Wide Association Studies. The R journal, 14(4), 18-37.<br />
2. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
D &lt;- simgeno(p = 90, n = 50, k = 3)
R.approx(D$data)

## End(Not run) 
</code></pre>

<hr>
<h2 id='R.gibbs'> The expectation of covariance matrix using Gibbs sampling</h2><span id='topic+R.gibbs'></span>

<h3>Description</h3>

<p>This function implements the Gibbs sampling method within Gaussian copula graphical model to estimate the conditional expectation for the data that not follow Gaussianity assumption (e.g. ordinal, discrete, continuous non-Gaussian, or mixed dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.gibbs(y, theta, gibbs.iter = 1000, mc.iter = 500, 
                   ncores = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R.gibbs_+3A_y">y</code></td>
<td>

<p>An (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data matrix (<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). 
It also could be an object of class <code>"simgeno"</code>.</p>
</td></tr>
<tr><td><code id="R.gibbs_+3A_theta">theta</code></td>
<td>
<p> A <code class="reqn">p \times p</code> precision matrix. Default is a diagonal matrix.</p>
</td></tr>
<tr><td><code id="R.gibbs_+3A_gibbs.iter">gibbs.iter</code></td>
<td>
<p> The number of burn-in for the Gibbs sampling. The default value is 1000.</p>
</td></tr>
<tr><td><code id="R.gibbs_+3A_mc.iter">mc.iter</code></td>
<td>
<p> The number of Monte Carlo samples to calculate the conditional expectation. The default value is 500. </p>
</td></tr>
<tr><td><code id="R.gibbs_+3A_ncores">ncores</code></td>
<td>
<p>If <code>ncores = NULL</code>, the algorithm internally detects number of available cores and run the calculations in parallel on (available cores - 1). Typical usage is to fix <code>ncores = 1</code> when <code class="reqn">p</code> is small <code class="reqn">( p &lt; 500 )</code>, and <code>ncores = NULL</code> when <code class="reqn">p</code> is very large.</p>
</td></tr>
<tr><td><code id="R.gibbs_+3A_verbose">verbose</code></td>
<td>
<p> If <code>verbose = FALSE</code>, printing information is disabled. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates <code class="reqn">\bar{R}</code> using Gibbs sampling method within the E-step of EM algorithm, where 
</p>
<p style="text-align: center;"><code class="reqn"> \bar{R} = n ^ {-1} \sum_{i=1}^{n} E( Z^{(i)} Z^{(i)t} | y^{(i)}, \hat{\Theta}^{(m)})</code>
</p>

<p>which <code class="reqn">n</code> is the number of sample size and <code class="reqn">Z</code> is the latent variable which is obtained from Gaussian copula graphical model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ES</code></td>
<td>
<p>Expectation of covariance matrix ( diagonal scaled to 1) of the Gaussian copula graphical model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi, Danny Arends and Ernst C. Wit <br />
Maintainers: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a><br />
</p>


<h3>References</h3>

<p>1. Behrouzi, P., Arends, D., and Wit, E. C. (2023). netgwas: An R Package for Network-Based Genome-Wide Association Studies. The R journal, 14(4), 18-37.<br />
2. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- simgeno(p = 100, n = 50, k = 3)
R.gibbs(D$data, ncores=1)
</code></pre>

<hr>
<h2 id='selectnet'> Model selection </h2><span id='topic+selectnet'></span>

<h3>Description</h3>

<p>Estimate the optimal regularization parameter at EM convergence based on different information criteria . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectnet(netgwas.obj, opt.index= NULL, criteria= NULL, ebic.gamma=0.5, 
		   ncores= NULL, verbose= TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectnet_+3A_netgwas.obj">netgwas.obj</code></td>
<td>
<p>An object with S3 class &quot;netgwas&quot;</p>
</td></tr>
<tr><td><code id="selectnet_+3A_opt.index">opt.index</code></td>
<td>
<p>The program internally determines an optimal graph using <code>opt.index= NULL</code>. Otherwise, to manually choose an optimal graph from the graph path.</p>
</td></tr>
<tr><td><code id="selectnet_+3A_criteria">criteria</code></td>
<td>
<p>Model selection criteria. &quot;ebic&quot; and &quot;aic&quot; are available. BIC model selection can be calculated by fixing <code>ebic.gamma = 0</code>. Applicable only if <code>opt.index= NULL</code>.</p>
</td></tr>
<tr><td><code id="selectnet_+3A_ebic.gamma">ebic.gamma</code></td>
<td>
<p>The tuning parameter for ebic. The<code>ebic.gamma = 0</code> results in bic model selection. The default value is 0.5. Applicable only <code>opt.index= NULL</code>.</p>
</td></tr>
<tr><td><code id="selectnet_+3A_ncores">ncores</code></td>
<td>
<p> The number of cores to use for the calculations. Using <code>ncores = "all"</code> automatically detects number of available cores and runs the computations in parallel.</p>
</td></tr>
<tr><td><code id="selectnet_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, printing information is disabled. The default value is <code>TRUE</code>. Applicable only <code>opt.index= NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes extended Bayesian information criteria (ebic), Bayesian information criteria, Akaike information criterion (aic) at EM convergence based on observed or joint log-likelihood.
The observed log-likelihood can be obtained through  
</p>
<p style="text-align: center;"><code class="reqn">\ell_Y(\widehat{\Theta}_\lambda) = Q(\widehat{\Theta}_\lambda | \widehat{\Theta}^{(m)}) - H (\widehat{\Theta}_\lambda | \widehat{\Theta}^{(m)}),</code>
</p>

<p>Where <code class="reqn">Q</code> can be calculated from <code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code> function and H function is 
</p>
<p style="text-align: center;"><code class="reqn">H(\widehat{\Theta}_\lambda | \widehat{\Theta}^{(m)}_\lambda) = E_z[\ell_{Z | Y}(\widehat{\Theta}_\lambda) | Y; \widehat{\Theta}_\lambda] = E_z[\log f(z)| Y ;\widehat{\Theta}_\lambda ] - \log p(y).</code>
</p>

<p>The &quot;ebic&quot; and &quot;aic&quot; model selection criteria can be obtained as follow
</p>
<p style="text-align: center;"><code class="reqn">ebic(\lambda) = -2 \ell(\widehat{\Theta}_\lambda) +  ( \log n + 4 \gamma \log p) df(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">aic(\lambda) = -2 \ell(\widehat{\Theta}_\lambda) +  2 df(\lambda)</code>
</p>

<p>where <code class="reqn">df</code> refers to the number of non-zeros offdiagonal elements of <code class="reqn">\hat{\Theta}_\lambda</code>, and <code class="reqn">\gamma \in [0, 1]</code>. Typical value for for <code>ebic.gamma</code> is 1/2, but it can also be tuned by experience. Fixing <code>ebic.gamma = 0 </code> results in bic model selection.
</p>


<h3>Value</h3>

<p>An obj with S3 class &quot;selectnet&quot; is returned:
</p>
<table>
<tr><td><code>opt.adj</code></td>
<td>
<p> The optimal graph selected from the graph path</p>
</td></tr>
<tr><td><code>opt.theta</code></td>
<td>
<p>The optimal precision matrix from the graph path</p>
</td></tr>
<tr><td><code>opt.sigma</code></td>
<td>
<p> The optimal covariance matrix from the graph path</p>
</td></tr>
<tr><td><code>ebic.scores</code></td>
<td>
<p> Extended BIC scores for regularization parameter selection at the EM convergence. Applicable if <code>opt.index = NULL</code>.</p>
</td></tr>
<tr><td><code>opt.index</code></td>
<td>
<p> The index of optimal regularization parameter. </p>
</td></tr>
<tr><td><code>opt.rho</code></td>
<td>
<p> The selected regularization parameter. </p>
</td></tr>
<tr><td><code>par.cor</code></td>
<td>
<p> A partial correlation matrix. </p>
</td></tr>
<tr><td><code>V.names</code></td>
<td>
<p> Variables name whose are not isolated. </p>
</td></tr>
</table>
<p>and anything else that is included in the input <code>netgwas.obj</code>.
</p>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C.Wit <br />
Maintainer: Pariya Behrouzi <a href="mailto:pariya.behrouzi@gmail.com">pariya.behrouzi@gmail.com</a> <br />
</p>


<h3>References</h3>

<p>1. BBehrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
2. Behrouzi, P., Arends, D., and Wit, E. C. (2023). netgwas: An R Package for Network-Based Genome-Wide Association Studies. The R journal, 14(4), 18-37. <br />
3. Ibrahim, Joseph G., Hongtu Zhu, and Niansheng Tang. (2012). Model selection criteria for missing-data problems using the EM algorithm. Journal of the American Statistical Association.
4. D. Witten and J. Friedman. (2011). New insights and faster computations for the graphical lasso. <em>Journal of Computational and Graphical Statistics</em>, to appear. <br />
5. J. Friedman, T. Hastie and R. Tibshirani. (2007). Sparse inverse covariance estimation with the lasso, <em>Biostatistics</em>.<br />
6. Foygel, R. and M. Drton. (2010). Extended bayesian information criteria for Gaussian graphical models. In Advances in Neural Information Processing Systems, pp. 604-612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+netsnp">netsnp</a></code>, <code><a href="#topic+netphenogeno">netphenogeno</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	
		   
		#simulate data
		D &lt;- simgeno(p=50, n=100, k= 3, adjacent = 3, alpha = 0.06 , beta = 0.06)
		plot(D)

		#explore intra- and inter-chromosomal interactions
		out  &lt;-  netsnp(D$data, n.rho= 5, ncores= 1)
		plot(out)

		#different graph selection methods
		sel.ebic1 &lt;- selectnet(out, criteria = "ebic")
		plot(sel.ebic1, vis = "CI")

		sel.aic &lt;- selectnet(out, criteria = "aic")
		plot(sel.aic, vis = "CI")

		sel.bic &lt;- selectnet(out, criteria = "ebic", ebic.gamma = 0)
		plot(sel.bic, vis = "CI")
	
</code></pre>

<hr>
<h2 id='simgeno'>Generate genotype data based on Gaussian copula</h2><span id='topic+simgeno'></span>

<h3>Description</h3>

<p>Generating discrete ordinal data based on underlying &quot;genome-like&quot; graph structure. The procedure of simulating data relies on a continues variable, which can be simulated from either multivariate normal distribution, or multivariate t-distribution with <code>d</code> degrees of freedom.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simgeno( p = 90, n = 200, k = NULL, g = NULL, adjacent = NULL, alpha =
              NULL , beta = NULL, con.dist = "Mnorm", d = NULL, vis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simgeno_+3A_p">p</code></td>
<td>
<p>The number of variables. The default value is 90.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_n">n</code></td>
<td>
<p>The number of sample size (observations). The default value is 200.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_k">k</code></td>
<td>
<p>The number of states (categories). The default value is 3.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_g">g</code></td>
<td>
<p>The number of groups (chromosomes) in the graph. The default value is about <code class="reqn">p/20</code> if <code class="reqn">p &gt;= 40</code> and 2 if <code class="reqn">p &lt; 40</code>.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_adjacent">adjacent</code></td>
<td>
<p> The number of adjacent variable(s) to be linked to a variable. For example, if <code>adjacent = 1</code> indicates a variable is linked via an edge with its adjacent variable on the left hand side, and its adjacent variable on the right hand side. The <code>adjacent = 2</code> defines a variable is linked via an edge with its 2 adjacent variables on its left hand side, and 2 adjacent variables on its right hand side. The default value is 1.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_alpha">alpha</code></td>
<td>
<p> A probability that a pair of non-adjacent variables in the same group is given an edge. The default value is 0.01.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_beta">beta</code></td>
<td>
<p> A probability that variables in different groups are linked with an edge. The default value is 0.02.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_con.dist">con.dist</code></td>
<td>
<p> The distribution of underlying continuous variable. If <code>con.dist = "Mnorm"</code>, a multivariate normal distribution with mean 0 is applied. If <code>con.dist = "Mt"</code>, the t-distribution with <code>a</code> degrees of freedom is applied. 
The default distribution is <code>con.dist = "Mnorm"</code>.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_d">d</code></td>
<td>
<p>The degrees of freedom of the continuous variable, only applicable when 
<code>con.dist = "Mt"</code>. The default value is 3.</p>
</td></tr>
<tr><td><code id="simgeno_+3A_vis">vis</code></td>
<td>
<p> Visualize the graph pattern and the adjacency matrix of the true graph structure. The default value is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph pattern is generated as below: <br /><br />
genome-like: <code>p</code> variables are evenly partitions variables into <code>g</code> disjoint groups; the adjacent variables within each group are linked via an edge. With a probability <code>alpha</code> a pair of non-adjacent variables in the same group is given an edge. Variables in different groups are linked with an edge with a probability of <code>beta</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;simgeno&quot; is returned: <br /> <br />
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The generated data as an <code>n</code> by <code>p</code> matrix.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>A <code>p</code> by <code>p</code> matrix corresponding to the inverse of covariance.</p>
</td></tr>
<tr><td><code>adj</code></td>
<td>
<p> A <code>p</code> by <code>p</code> matrix corresponding to the adjacency matrix of the true graph structure.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p> A <code>p</code> by <code>p</code> covariance matrix for the generated data.</p>
</td></tr>
<tr><td><code>n.groups</code></td>
<td>
<p> The number of groups.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>A vector that indicates each variable belongs to which group.</p>
</td></tr>
<tr><td><code>sparsity</code></td>
<td>
<p>The sparsity levels of the true graph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi and Ernst C. Wit <br />
Maintainer: Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. Behrouzi, P., Arends, D., and Wit, E. C. (2023). netgwas: An R Package for Network-Based Genome-Wide Association Studies. The R journal, 14(4), 18-37.<br />
2. Behrouzi, P., and Wit, E. C. (2019). Detecting epistatic selection with partially observed genotype data by using copula graphical models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 68(1), 141-160. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netsnp">netsnp</a></code>, and <code><a href="#topic+netgwas-package">netgwas-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#genome-like graph structure
sim1 &lt;- simgeno(alpha = 0.01, beta = 0.02)
plot(sim1)

#genome-like graph structure with more edges between variables in a same or different groups
sim2 &lt;- simgeno(adjacent = 3, alpha = 0.02 , beta = 0.03)
plot(sim2)

		#simulate data
		D &lt;- simgeno(p=50, n=100, g=5, k= 3, adjacent = 3, alpha = 0.06 , beta = 0.08)
		plot(D)

		#Reconstructing intra- and inter-chromosomal conditional interactions (LD) network
		out &lt;- netsnp(data = D$data, n.rho= 4, ncores= 1)
		plot(out)
		#Select an optimal graph
		sel &lt;- selectnet(out)
		plot(sel, vis= "CI" )
	
</code></pre>

<hr>
<h2 id='simRIL'>Generate genotype data of RIL</h2><span id='topic+simRIL'></span>

<h3>Description</h3>

<p>Generating genotype data from a recombinant inbred line (RIL) population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRIL( d = 25, n = 200, g = 5, cM = 100, selfing=2 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRIL_+3A_d">d</code></td>
<td>
<p>The number of markers per chromosome. The default value is 25.</p>
</td></tr>
<tr><td><code id="simRIL_+3A_n">n</code></td>
<td>
<p>The number of sample size (observations). The default value is 200.</p>
</td></tr>
<tr><td><code id="simRIL_+3A_g">g</code></td>
<td>
<p>The number of linkage groups (chromosomes). The default value is 5.</p>
</td></tr>
<tr><td><code id="simRIL_+3A_cm">cM</code></td>
<td>
<p>The length of each chromosome based on centiMorgan.</p>
</td></tr>
<tr><td><code id="simRIL_+3A_selfing">selfing</code></td>
<td>
<p> The number of selfing in RIL population.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>The generated RIL genotype data as an <code>n</code> by <code>(d x g)</code> matrix.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>The genetic map of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Pariya Behrouzi <br />
Maintainer: Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netmap">netmap</a></code>, <code><a href="#topic+netsnp">netsnp</a></code>, and <code><a href="#topic+netgwas-package">netgwas-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#genome-like graph structure
ril &lt;- simRIL(g = 5, d = 25, cM = 100, n = 200, selfing = 2)
geno &lt;- ril$data; image(geno, xlab= "individuals", ylab="markers")
map &lt;- ril$map 
</code></pre>

<hr>
<h2 id='tetraPotato'>tetraploid potato genotype data </h2><span id='topic+tetraPotato'></span>

<h3>Description</h3>

 
<p>Tetraploid potato (<em>Solanum tuberosum L.</em>) genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tetraPotato)</code></pre>


<h3>Format</h3>

<p>The format is a matrix containing 1972 single-nucleotide polymorphism (SNP) markers for 156 individuals.
</p>


<h3>Details</h3>

<p>The full-sib mapping population MSL603 consists of 156 F1 plants resulting from a cross
between female parent &quot;Jacqueline Lee&quot; and male parent &quot;MSG227-2&quot;. The obtained genotype
data contain 1972 SNP markers with five allele dosages. This genotype data can be used to construct linkage map for tetraploid potato (see below example).
</p>


<h3>Source</h3>

<p>Massa, Alicia N., Norma C. Manrique-Carpintero, Joseph J. Coombs, Daniel G. Zarka, Anne E. Boone, William W. Kirk, Christine A. Hackett, Glenn J. Bryan, and David S. Douches. &quot;Genetic linkage mapping of economically important traits in cultivated tetraploid potato (Solanum tuberosum L.).&quot; G3: Genes, Genomes, Genetics 5, no. 11 (2015): 2357-2364.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tetraPotato)
#Shuffle the order of markers
potato &lt;- tetraPotato[ , sample(ncol(tetraPotato))]
#Constructing linkage map for tetraploid potato
out &lt;- netmap(potato, cross = "outbred"); out
potato.map &lt;- out$map; potato.map
#plot(out)

</code></pre>

<hr>
<h2 id='thaliana'>Arabidopsis thaliana phenotype and genotype data </h2><span id='topic+thaliana'></span>

<h3>Description</h3>

 
<p>The genotype data of the Kend-L x Col Recombinant Inbred Line (RIL) population along with flowering time and leaf numbers phenotype information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(thaliana)</code></pre>


<h3>Format</h3>

<p>The format is a matrix containing 181 single-nucleotide polymorphism (SNP) markers and 8 phenotypes information for 197 individuals. 
</p>


<h3>Details</h3>

<p>The accession Kend-L (Kendalville-Lehle; Lehle-WT-16-03) is crossed to the common lab strain Col (Co\-lum\-bi\-a).
The resulting lines were taken through six rounds of selfing without any intentional selection. The resulting 282 KendC (Kend-L <code class="reqn">\times</code> Col) 
lines were genotyped at 181 markers.  The flowering time was measured for 197 lines of this population in both long days, which promote rapid 
flowering in many A. <em>thaliana</em> strains, and in short days. Flowering time was measured using days to flowering (DTF) as well as the 
total number of leaves (TLN), partitioned into rosette and cauline leaves. In total eight phenotypes have been measured, namely days to 
flowering (DTF), cauline leaf number (CLN), rosette leaf number (RLN), and total leaf number (TLN) in long days (LD), and DTF, CLN, RLN, 
and TLN in short days (SD). Thus, the final dataset consist of 197 observations for 189 variables (8 phenotypes and 181 genotypes - SNP markers) <br />
This data set can be used to reconstruct network among SNP markers and the measured phenotypes.
</p>


<h3>Source</h3>

<p>Balasubramanian, Sureshkumar, et al. (2009). &quot;QTL mapping in new Arabidopsis thaliana advanced intercross-recombinant inbred lines.&quot; PLoS One 4.2: e4318.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(thaliana)

# Graph path
out &lt;- netphenogeno(thaliana, ncores=1)
plot(out)

sel &lt;- selectnet(out)
plot(sel, vis= "interactive")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
