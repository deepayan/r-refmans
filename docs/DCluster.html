<!DOCTYPE html><html lang="en"><head><title>Help for package DCluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DCluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#achisq'><p>Another Implementation of Pearson's Chi-square Statistic</p></a></li>
<li><a href='#achisq.boot'><p>Bootstrap Replicates of Pearson's Chi-square Statistic</p></a></li>
<li><a href='#achisq.stat'><p>Another Implementation of Pearson's Chi-square Statistic</p></a></li>
<li><a href='#besagnewell'><p>Besag and Newell's Statistic for Spatial Clustering</p></a></li>
<li><a href='#besagnewell.boot'><p>Generate Boostrap Replicates of Besag and Newell's Statistic</p></a></li>
<li><a href='#besagnewell.stat'><p>Besag and Newell's Statistic for Spatial Clustering</p></a></li>
<li><a href='#bn.iscluster'><p>Clustering Function for Besag and Newell's Method</p></a></li>
<li><a href='#calculate.mle'><p>Calculate Parameters Involved in Sampling Procedures</p></a></li>
<li><a href='#dcluster'><p>Class for Results from a Test for the Detection of Disease Clusters</p></a></li>
<li><a href='#DCluster'><p>A Package for the Detection of Spatial Clusters of Diseases</p>
for Count Data</a></li>
<li><a href='#DCluster-internal'><p>Internal Functions in the DCluster Package.</p></a></li>
<li><a href='#empbaysmooth'><p>Empirical Bayes Smoothing</p></a></li>
<li><a href='#gearyc'><p>Geary's C Autocorrelation Statistic</p></a></li>
<li><a href='#gearyc.boot'><p>Generate Bootstrap Replicates of Geary's C Autocorrelation Statistic</p></a></li>
<li><a href='#gearyc.stat'><p>Compute Geary's C Autocorrelation Statistic</p></a></li>
<li><a href='#get.knclusters'><p>Get Areas in a Cluster Detected with Kulldorff's Statistic</p></a></li>
<li><a href='#iscluster'><p>Local Clustering Test Function</p></a></li>
<li><a href='#kn.iscluster'><p>Clustering Function for Kulldorff and Nagarwalla's Statistic</p></a></li>
<li><a href='#kullnagar'><p>Kulldorff and Nagarwalla's Statistic for Spatial Clustering.</p></a></li>
<li><a href='#kullnagar.boot'><p>Generate Bootstrap Replicates of Kulldorff and Nagarwalla's Statistic</p></a></li>
<li><a href='#kullnagar.stat'><p>Kulldorff and Nagarwalla's Statistic for Spatial Clustering.</p></a></li>
<li><a href='#lognormalEB'><p>Empirical Bayes Smoothing Using a log-Normal Model</p></a></li>
<li><a href='#moranI'><p>Moran's I Autocorrelation Statistic</p></a></li>
<li><a href='#moranI.boot'><p>Generate Bootstrap Replicates of Moran's I Autocorrelation Statistic</p></a></li>
<li><a href='#moranI.stat'><p>Compute Moran's I Autocorrelation Statistic</p></a></li>
<li><a href='#observed.sim'><p>Randomly Generate Observed Cases from Different Statistical Distributions</p></a></li>
<li><a href='#opgam'><p>Openshaw's GAM</p></a></li>
<li><a href='#pottwhitt'><p>Potthoff-Whittinghill's Statistic for Overdispersion</p></a></li>
<li><a href='#pottwhitt.boot'><p>Bootstrap Replicates of Potthoff-Whittinghill's Statistic</p></a></li>
<li><a href='#pottwhitt.stat'><p>Compute Potthoff-Whittinghill's Statistic</p></a></li>
<li><a href='#readSplus'><p>Read exported WinBUGS maps</p></a></li>
<li><a href='#rmultin'><p>Generate Random Observations from a Multinomial Distribution</p></a></li>
<li><a href='#sp2WB'><p>Export SpatialPolygons object as S-Plus map for WinBUGS</p></a></li>
<li><a href='#stone'><p>Stone's Test</p></a></li>
<li><a href='#stone.boot'><p>Generate Boostrap Replicates of Stone's Statistic</p></a></li>
<li><a href='#stone.stat'><p>Compute Stone's Statistic</p></a></li>
<li><a href='#tango'><p>Tango's Statistic for General Clustering</p></a></li>
<li><a href='#tango.boot'><p>Generate Bootstrap Replicated of Tango's Statistic</p></a></li>
<li><a href='#tango.stat'><p>Compute Tango's Statistic for General Clustering</p></a></li>
<li><a href='#Tests+20for+20Overdispertion'><p>Likelihood Ratio Test and Dean's Tests for Overdispertion</p></a></li>
<li><a href='#whittermore'><p>Whittermore's Statistic</p></a></li>
<li><a href='#whittermore.boot'><p>Generate Bootstrap Replicates of Whittermore's Statistic</p></a></li>
<li><a href='#whittermore.stat'><p>Compute Whittermore's Statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for the Detection of Spatial Clusters of Diseases</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Virgilio Gómez-Rubio, Juan Ferrándiz-Ferragud and Antonio
        López-Quílez, with contributions by Roger Bivand.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Virgilio Gómez-Rubio &lt;Virgilio.Gomez@uclm.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.6.2), boot, spdep, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sp, sf</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions for the detection of spatial clusters
        of disease using count data. Bootstrap is used to estimate
        sampling distributions of statistics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 15:32:51 UTC; virgil</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 17:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='achisq'>Another Implementation of Pearson's Chi-square Statistic</h2><span id='topic+achisq'></span>

<h3>Description</h3>

<p>Another implementation of Pearson's Chi-square has been written
to fit the needs in package <em>DCLuster</em>.
</p>
<p><em>achisq.stat</em> is the function that calculates the value of the statistic
for the data.
</p>
<p><em>achisq.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>achisq.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Details</h3>

<p>This statistic can be used to detect whether observed data
depart (over or above) expected number of cases significantly.
The test considered stands for relative risks among areas
to be equal to an (unknown) constant <code class="reqn">\lambda</code>, while
the alternative hypotheses is that not all relative risks are equal.
</p>
<p>The actual value of the statistic depends on null hypotheses.
If we consider that all the relative risks are equal to 1, the 
value is
</p>
<p>T=</p>
<p style="text-align: center;"><code class="reqn">\sum_i\frac{(O_i-E_i)^2}{E_i}</code>
</p>

<p>and the degrees of freedom are equal to the number of regions.
</p>
<p>On the other hand, if we just consider relative risks to be equal, without
specifying their value (i.e., <code class="reqn">\lambda</code> is unknown),
<code class="reqn">E_i</code> must be substituted by <code class="reqn">E_i\frac{O_+}{E_+}</code>
and the number of degrees of freedom is the number of regions minus one.
</p>
<p>When internal standardization is used, null hypotheses must 
be all relative risks equal to 1 and the number of degrees
of freedom is the number of regions minus one. This is due to the
fact that, in this case, <code class="reqn">O_+=E_+</code>.
</p>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster, achiq.stat, achisq.boot, achisq.pboot
</p>

<hr>
<h2 id='achisq.boot'>Bootstrap Replicates of Pearson's Chi-square Statistic</h2><span id='topic+achisq.boot'></span><span id='topic+achisq.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of the Pearson's Chi-square statistic (function
<em>achisq.stat</em>), by means of function <em>boot</em> from <em>boot</em>
library. Notice that these functions should not  be used separately but as
argument <em>statistic</em> when calling function <em>boot</em>.
</p>
<p><em>achisq.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>achisq.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>achisq.boot(data, i, ...)
achisq.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="achisq.boot_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in
<em>DCluster</em> manpage.</p>
</td></tr>
<tr><td><code id="achisq.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the non-parametric bootstrap procedure.</p>
</td></tr>
<tr><td><code id="achisq.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster, boot, achisq, achisq.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))

niter&lt;-100

#Permutation  model
chq.perboot&lt;-boot(sids, statistic=achisq.boot, R=niter)
plot(chq.perboot)#Display results

#Multinomial model
chq.mboot&lt;-boot(sids, statistic=achisq.pboot, sim="parametric", ran.gen=multinom.sim,  R=niter)
plot(chq.mboot)#Display results

#Poisson model
chq.pboot&lt;-boot(sids, statistic=achisq.pboot, sim="parametric", ran.gen=poisson.sim,  R=niter)
plot(chq.pboot)#Display results

#Poisson-Gamma model
chq.pgboot&lt;-boot(sids, statistic=achisq.pboot, sim="parametric", ran.gen=negbin.sim, R=niter)
plot(chq.pgboot)#Display results
</code></pre>

<hr>
<h2 id='achisq.stat'>Another Implementation of Pearson's Chi-square Statistic</h2><span id='topic+achisq.stat'></span><span id='topic+achisq.test'></span>

<h3>Description</h3>

<p>Compute Pearson's Chi-square statistic. See <em>achisq</em> manual page
for more details.
</p>
<p>achisq.stat computes the test statistic and the test using a hi-square
distribution whilst achisq.test performs a bootstrap test. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>achisq.stat(data, lambda=NULL)
achisq.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="achisq.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other 
names can be used to specify the observed and expected cases.
</p>
</td></tr>
<tr><td><code id="achisq.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="achisq.stat_+3A_...">...</code></td>
<td>
<p>The remaining arguments in 'achisq.stat' not included in
'achisq.test'. This is done so because achisq.test calls achisq.stat in order to perform the test.</p>
</td></tr>
<tr><td><code id="achisq.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="achisq.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the 
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="achisq.stat_+3A_lambda">lambda</code></td>
<td>
<p>The value of the relative risks under the null hypotheses.
If its NULL, the second hypotheses commented above is considered
and the expected number of cases will automatically be corrected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components
</p>
<table role = "presentation">
<tr><td><code>T</code></td>
<td>
<p>The value of the statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom of the asinthotic Chi-square distribution.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>Related pvalue.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster, achisq, achisq.boot, achisq.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))

#Compute the statistic under the assumption that lambda = 1.
achisq.stat(sids, lambda=1)

#Perform test
achisq.test(Observed~offset(log(Expected)), sids, model="poisson", R=99)
</code></pre>

<hr>
<h2 id='besagnewell'>Besag and Newell's Statistic for Spatial Clustering</h2><span id='topic+besagnewell'></span>

<h3>Description</h3>

<p>Besag &amp; Newell's statistic looks for clusters of size <em>k</em>, i. e., where
the number of observed cases is <em>k</em>. At every area where a case has
appeared, the number of neighbouring regions needed to reach $k$ cases is
calculated.  If this number is too small, that is, too many observed cases in
just a few regions with low expected cases, then it is marked as a cluster.
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.(1991). The detection of clusters in rare diseases. 
Journal of the Royal Statistical Society A  154, 143-155.
</p>


<h3>See Also</h3>

<p>DCluster, besagnewell.stat, besagnewell.boot, besagnewell.pboot, bn.iscluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#B&amp;N must use the centroids as grid.
#The size of teh cluster is 20.
#100  bootstrap simulations are performed
#Poisson is the model used in the bootstrap simulations to generate the
#observations.
#Signifiance level is 0'05, even though multiple tests are made.

library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

bnresults&lt;-opgam(sids, thegrid=sids[,c("x","y")], alpha=.05, 
	iscluster=bn.iscluster, set.idxorder=TRUE, k=20, model="poisson", 
	R=100, mle=calculate.mle(sids) )

#Plot all the centroids
plot(sids$x, sids$y)

#Plot signifiant centroids in red
points(bnresults$x, bnresults$y, col="red", pch=19)
</code></pre>

<hr>
<h2 id='besagnewell.boot'>Generate Boostrap Replicates of Besag and Newell's Statistic</h2><span id='topic+besagnewell.boot'></span><span id='topic+besagnewell.pboot'></span>

<h3>Description</h3>

<p>Generate boostrap replicates of Besag and Newell's statistic, by means of
function <em>boot</em> from <em>boot</em> library.  Notice that these functions
should not  be used separately but as argument <em>statistic</em> when calling
function <em>boot</em>.
</p>
<p><em>besagnewell.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p>When sampling models are <em>Multinomial</em> or <em>Poisson</em> it is quite
straightforwad to obtain the actual p-value as shown in the examples. When
<em>Permutation</em> or <em>Negative Binomial</em> are used, simulation must be
used to estimate significance.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>besagnewell.boot(data, i, ...)
besagnewell.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="besagnewell.boot_+3A_data">data</code></td>
<td>
<p>A dataframe with the data, as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="besagnewell.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the non-parametric bootstrap.</p>
</td></tr>
<tr><td><code id="besagnewell.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.(1991). The detection of clusters in rare diseases. 
Journal of the Royal Statistical Society A  154, 143-155.
</p>


<h3>See Also</h3>

<p>DCluster, boot, besagnewell, besagnewell.stat, bn.iscluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

niter&lt;-100

#Permutation  model
besn.perboot&lt;-boot(sids, statistic=besagnewell.boot, R=niter, k=20)
plot(besn.perboot)#Display results
</code></pre>

<hr>
<h2 id='besagnewell.stat'>Besag and Newell's Statistic for Spatial Clustering</h2><span id='topic+besagnewell.stat'></span>

<h3>Description</h3>

<p><em>besagnewell.stat</em> computes the statistic around a single location.
Data passed must be sorted according to distance to central region,
which is supposed to be the first row in the dataframe. Notice that the
size of the cluster is <em>k+1</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besagnewell.stat(data, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="besagnewell.stat_+3A_data">data</code></td>
<td>
<p>A dataframe with the data, as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="besagnewell.stat_+3A_k">k</code></td>
<td>
<p>Cluster size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two elements: the value of the statistic and the size of the
cluster (which is equal to the value of the statistic).
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.(1991). The detection of clusters in rare diseases. 
Journal of the Royal Statistical Society A  154, 143-155.
</p>


<h3>See Also</h3>

<p>DCluster, besagnewell, besagnewell.boot, besagnewell.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

besagnewell.stat(sids, k=20)
</code></pre>

<hr>
<h2 id='bn.iscluster'>Clustering Function for Besag and Newell's Method</h2><span id='topic+bn.iscluster'></span>

<h3>Description</h3>

<p>This function is used to calculate the significance of the agregation
of cases around the current area when scanning the whole
area by means of function <em>opgam</em>.
</p>
<p>When data sampling distribution is  <em>multinomial</em> or <em>poisson</em> 
the exact p-value is computed. In the other cases (i.e.,
permutation and negative binomial) it is aproximated by bootstrap.
</p>
<p>This function must be passed to function <em>opgam</em> as argument
<em>iscluster</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn.iscluster(data, idx, idxorder, alpha, k, model="poisson", R=999, mle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bn.iscluster_+3A_data">data</code></td>
<td>
<p>A dataframe with the data as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_idx">idx</code></td>
<td>
<p>A boolean vector to know the areas in the current circle.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_idxorder">idxorder</code></td>
<td>
<p>A permutation of the rows of data to order the regions
according to their distance to the current centre.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_alpha">alpha</code></td>
<td>
<p>Test significance.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_k">k</code></td>
<td>
<p>Size of the cluster.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_model">model</code></td>
<td>
<p>Thge model used to generate random observations. It can be
'permutation', 'multinomial', 'poisson' or 'negbin'.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_r">R</code></td>
<td>
<p>Number of bootstrap replicates made to compute pvalue if
the local test.</p>
</td></tr>
<tr><td><code id="bn.iscluster_+3A_mle">mle</code></td>
<td>
<p>Parameters needed to compute the Negative Binomial distribution (if used). See <em>negbin.sim</em> manual page for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of four elements, as described in <em>iscluster</em> manual page.
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.(1991). The detection of clusters in rare diseases.
Journal of the Royal Statistical Society A  154, 143-155.
</p>


<h3>See Also</h3>

<p>DCluster, besagnewell, besagnewell.boot, besagnewell.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#B&amp;N's method
bnresults&lt;-opgam(data=sids, thegrid=sids[,c("x","y")], alpha=.05, 
	iscluster=bn.iscluster, k=20, R=100, model="poisson", 
	mle=calculate.mle(sids))

#Plot all centroids and significant ones in red
plot(sids$x, sids$y, main="Besag &amp; Newell's method")
points(bnresults$x, bnresults$y, col="red", pch=19)
</code></pre>

<hr>
<h2 id='calculate.mle'>Calculate Parameters Involved in Sampling Procedures</h2><span id='topic+calculate.mle'></span>

<h3>Description</h3>

<p>When boostrap is used to sample values of the statistic under study,
it is possible to use argument <em>mle</em> to pass the values of
the parameters involved in the sampling procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.mle(d, model="poisson")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.mle_+3A_d">d</code></td>
<td>
<p>A dataframe as described in the <em>DCluster</em> manual page.</p>
</td></tr>
<tr><td><code id="calculate.mle_+3A_model">model</code></td>
<td>
<p>Model used to sample data. It can be either &quot;multinomial&quot;,
&quot;poisson&quot; or &quot;negbin&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the estimates of the parameters involved in the model:
</p>
<table role = "presentation">
<tr><td><code>Multimonial</code></td>
<td>
<p>Total observed cases (<em>n</em>) and vector of probabilities
(<em>p</em>).</p>
</td></tr>
<tr><td><code>Poisson</code></td>
<td>
<p>Total number of regions (<em>n</em>) and vector of means 
(<em>lambda</em>).</p>
</td></tr>
<tr><td><code>Negative Binomial (Poisson-Gamma)</code></td>
<td>
<p>Total number of regions (<em>n</em>), 
size and probabilites, calculated after estimating parameters parameters 
<em>nu</em> and <em>alpha</em> of the Gamma distribution following equations 
proposed by Clayton and Kaldor (1989).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>DCluster, observed.sim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)


#Carry out simulations
datasim&lt;-multinom.sim(sids, mle=calculate.mle(sids, model="multinomal") )

#Estimators for Poisson distribution
datasim&lt;-poisson.sim(sids, mle=calculate.mle(sids, model="poisson") )

#Estimators for Negative Binomial distribution
datasim&lt;-negbin.sim(sids, mle=calculate.mle(sids, model="negbin") )

</code></pre>

<hr>
<h2 id='dcluster'>Class for Results from a Test for the Detection of Disease Clusters</h2><span id='topic+plot.dcluster'></span><span id='topic+print.dcluster'></span><span id='topic+summary.dcluster'></span>

<h3>Description</h3>

<p>Class 'dcluster' is used to store the main information when a (boostrap) test
is performed to detect clusters of disease. Essentially, this class has the
same structure and contents as class 'boot' (see in package 'boot') plus
some additional information on the test performed.
</p>
<p>Additional functions to plot and summarise the results of the test are 
supplied as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcluster'
plot(x, ...)
## S3 method for class 'dcluster'
print(x, ...)
## S3 method for class 'dcluster'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcluster_+3A_x">x</code></td>
<td>
<p>A 'dcluster' object.</p>
</td></tr>
<tr><td><code id="dcluster_+3A_object">object</code></td>
<td>
<p>A 'dcluster' object.</p>
</td></tr>
<tr><td><code id="dcluster_+3A_...">...</code></td>
<td>
<p>Any other additional arguments needed (for example, to pass
additional arguments to the plot function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions do not return anything but produce some plots or print
asummary of the test.
</p>

<hr>
<h2 id='DCluster'>A Package for the Detection of Spatial Clusters of Diseases
for Count Data</h2><span id='topic+DCluster'></span>

<h3>Description</h3>

<p>DCluster is a collection of several methods related to the detection
of spatial clusters of diseases. Many widely used methods, such as Openshaw's
GAM, Besag and Newell, Kulldorff and Nagarwalla, and others
have been implemented.
</p>
<p>Besides the calculation of these statistic, bootstrap can be used
to test its departure from the null hypotheses, which will be
no clustering in the study area. For possible sampling methods can be used to perform the
simulations: permutation, Multinomial, Poisson and Poisson-Gamma.
</p>
<p>Minor modifications have been made to the methods to use standardized expected
number of cases instead of population, since it provides a better approach to
the expected number of cases.
</p>


<h3>Introduction</h3>

<p>We'll always suppose that we are working on a study region which is divided
into <em>n</em> non-overlaping smaller areas where data are measured. Data
measured are usually people suffering from a disease or even deaths. This will
be refered as <em>Observed number of cases</em>. For a given area, its observed
number of cases will be denoted by <code class="reqn">O_i</code> and the sum of these
quantities over the whole study region will be <code class="reqn">O_+</code>.
</p>
<p>In the same way can be defined <em>Population</em> and <em>Standardized
Expected number of cases</em>, which will be denoted by <code class="reqn">P_i</code> and
<code class="reqn">E_i</code>, respectively. The sum of all these quantities 
are represented by <code class="reqn">P_+</code> and <code class="reqn">E_+</code>.
</p>
<p>The basic assumption for the data is that they are independant
observations from a Poisson distribution, whose mean is 
<code class="reqn">\theta_iE_i</code>, where <code class="reqn">\theta_i</code>
is the relative risk. That is,
</p>
<p style="text-align: center;"><code class="reqn">O_i \sim Po(\theta_i E_i); \ i=1, \ldots , n</code>
</p>



<h3>Null hypotheses</h3>

<p>Null hypotheses is usually equal relative risks, that is
</p>
<p style="text-align: center;"><code class="reqn">H_0: \theta_1= \ldots = \theta_n = \lambda</code>
</p>

<p><code class="reqn">\lambda</code> may be considered to be known (one, which means standard
risk) or unknown. In the last case, <code class="reqn">E_i</code> must slightly be corrected
by multiplying it by the overall relative risk <code class="reqn">\frac{O_+}{E_+}</code>.
</p>


<h3>Code structure</h3>

<p>Function names follow a common format, which is a follows:
</p>

<dl>
<dt><em>method name</em>.stat</dt><dd><p>Calculate the statistic itself.</p>
</dd>
<dt><em>method name</em>.boot</dt><dd><p>Perform a non-parametric bootstrap.</p>
</dd>
<dt><em>method name</em>.pboot</dt><dd><p>Perform a parametric bootstrap.</p>
</dd>
</dl>

<p>Openshaw's G.A.M. has generally been implemented in a function called
<em>gam</em>, which some methods ( Kulldorff &amp; Nagarwalla, Besag &amp; Newell) also
use, since they are based on a window scan of the whole region. At every point
of the grid, a function is called to determine whether that point is a cluster
or not. The name of this function is <em>shorten method name.iscluster</em>.
</p>
<p>This function calculates the local value of the statistic involved and
its signifiance by means of bootstrap. The interface provided, through
function <em>gam</em>, is quite straightforward to use and it can handle the 
three methods mentioned and other supplied by the users.
</p>


<h3>Bootstrap procedures</h3>

<p>Four possible bootstrap models have been provided in order to estimate
sampling distributions of the statistics provided. The first one is a
non-parametric bootstrap, which performs permutations over the observed number
of cases, while the three others are parametric bootstrap based on
Multinomial, Poisson and Poisson-Gamma distributions.
</p>
<p>Permutation method just takes observed number of cases and permute them among
all regions, to know whether risk in uniform across the whole study area.
It just should be used with care since we'll face the problem of having
more observed cases than population in very small populated areas.
</p>
<p>Multinomial sampling is based on conditioning the Poisson framework
to <code class="reqn">O_+</code>. THis way <code class="reqn">(O_1, \ldots, O_n)</code>
follows a multinomial distribution of size <code class="reqn">O_+</code> and 
probabilities <code class="reqn">(\frac{E_1}{E_+}, \ldots, \frac{E_n}{E_+})</code>.
</p>
<p>Poisson sampling just generates observed number of cases from a Poisson
distribution whose mean is <code class="reqn">E_i</code>.
</p>
<p>Poisson-Gamma sampling is based on the Poisson-Gamma model proposed
by <em>Clayton and Kaldor</em> (1984):
</p>
<p style="text-align: center;"><code class="reqn">O_i|\theta_i \sim Po(\theta_i E_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i \sim Ga(\nu, \alpha)</code>
</p>

<p>The distribution of <code class="reqn">O_i</code> unconditioned to <code class="reqn">\theta_i</code> is
Negative Binomial with size <code class="reqn">\nu</code> and probability
<code class="reqn">\frac{\alpha}{\alpha+E_i}</code>. The two parameters can be
estimated using an Empirical Bayes approach from the Expected and Observed
number of cases. Function <em>empbaysmooth</em> is provided for this purpose.
</p>


<h3>Data</h3>

<p>One of the parameters, which is usually called <em>data</em>, passed to many of
the functions in this package is a dataframe which contains the data for each
of the regions used in the analysis. Besides, its columns must be labeled:
</p>

<dl>
<dt><b>Observed</b></dt><dd><p>Observed number of cases.</p>
</dd>
<dt><b>Expected</b></dt><dd><p>Standardised expected number of cases.</p>
</dd>
<dt><b>Population</b></dt><dd><p>Population at risk.</p>
</dd>
<dt><b>x</b></dt><dd><p>Easting coordinate of the region centroid.</p>
</dd>
<dt><b>y</b></dt><dd><p>Northing coordinate of the region centroid.</p>
</dd>
</dl>



<h3>References</h3>

<p>Clayton, David and Kaldor, John (1987). Empirical Bayes Estimates of Age-standardized Relative Risks for Use in Disease Mapping. Biometrics 43, 671-681.
</p>
<p>Lawson et al (eds.) (1999). Disease Mapping and Risk Assessment for Public
Health. John Wiley and Sons, Inc.
</p>
<p>Lawson, A. B. (2001). Statistical Methods in Spatial Epidemiology. John Wiley and Sons, Inc.
</p>

<hr>
<h2 id='DCluster-internal'>Internal Functions in the DCluster Package.</h2><span id='topic+dotest'></span>

<h3>Description</h3>

<p>These functions are used by the package internally and they are
not intended to be used by the final user. You can check the
source code if you need more details or contact the maintainer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotest(formula, stat, data, model, R, ..., alternative=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCluster-internal_+3A_formula">formula</code></td>
<td>
<p>Formula that relates the observed cases (response)
to the expected cases (as an offset in the logscale, i.e., 
offset(log(expected))</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_stat">stat</code></td>
<td>
<p>Name of the statistic to be computed.</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_data">data</code></td>
<td>
<p>Data frame with the data.</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_model">model</code></td>
<td>
<p>Model to be used when resampling in the test.</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_r">R</code></td>
<td>
<p>Number of simulations used in the test.</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_...">...</code></td>
<td>
<p>Any other argument needed by the test statistic. Check its
particular manual page for the list of extra arguments and examples.</p>
</td></tr>
<tr><td><code id="DCluster-internal_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hipotesis. This will depend on the test
statistic being used.</p>
</td></tr>
</table>

<hr>
<h2 id='empbaysmooth'>Empirical Bayes Smoothing</h2><span id='topic+empbaysmooth'></span>

<h3>Description</h3>

<p>Smooth  relative risks from a set of expected and observed number of cases
using a Poisson-Gamma model as proposed by <em>Clayton and Kaldor</em> (1987) .
</p>
<p>If <code class="reqn">\nu</code> and <code class="reqn">\alpha</code> are the two parameters of the 
prior Gamma distribution, smoothed relative risks are
<code class="reqn">\frac{O_i+\nu}{E_i+\alpha}</code>.
</p>
<p><code class="reqn">\nu</code> and <code class="reqn">\alpha</code> are estimated via Empirical Bayes,
by using mean and variance, as described by <em>Clayton and Kaldor</em>(1987).
</p>
<p>Size and probabilities for a Negative Binomial model are also calculated (see
below).
</p>
<p>See <em>Details</em> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empbaysmooth(Observed, Expected, maxiter=20, tol=1e-5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empbaysmooth_+3A_observed">Observed</code></td>
<td>
<p>Vector of observed cases.</p>
</td></tr>
<tr><td><code id="empbaysmooth_+3A_expected">Expected</code></td>
<td>
<p>Vector of expected cases.</p>
</td></tr>
<tr><td><code id="empbaysmooth_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="empbaysmooth_+3A_tol">tol</code></td>
<td>
<p>Tolerance used to stop the iterative procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson-Gamma model, as described by <em>Clayton and Kaldor</em>,
is a two-layers Bayesian Hierarchical model:
</p>
<p style="text-align: center;"><code class="reqn">O_i|\theta_i \sim Po(\theta_i E_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i \sim Ga(\nu, \alpha)</code>
</p>

<p>The posterior distribution of <code class="reqn">O_i</code>,unconditioned to
<code class="reqn">\theta_i</code>, is Negative Binomial with size <code class="reqn">\nu</code> and
probability <code class="reqn">\alpha/(\alpha+E_i)</code>.
</p>
<p>The estimators of relative risks are
<code class="reqn">\widehat{\theta}_i=\frac{O_i+\nu}{E_i+\alpha}</code>.
Estimators of <code class="reqn">\nu</code> and <code class="reqn">\alpha</code>
(<code class="reqn">\widehat{\nu}</code> and <code class="reqn">\widehat{\alpha}</code>,respectively)
are calculated by means of an iterative procedure using these two equations
(based on mean and variance estimations):
</p>
<p style="text-align: center;"><code class="reqn">\frac{\widehat{\nu}}{\widehat{\alpha}}=\frac{1}{n}\sum_{i=1}^n
\widehat{\theta}_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{\widehat{\nu}}{\widehat{\alpha}^2}=\frac{1}{n-1}\sum_{i=1}^n(1+\frac{\widehat{\alpha}}{E_i})(\widehat{\theta}_i-\frac{\widehat{\nu}}{\widehat{\alpha}})^2</code>
</p>



<h3>Value</h3>

<p>A list of four elements:
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>Number of regions.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Estimation of parameter <code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimation of parameter <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code>smthrr</code></td>
<td>
<p>Vector of smoothed relative risks.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Size parameter of the Negative Binomial. It is equal to 
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\nu}</code>
</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>It is a vector of probabilities of the Negative Binomial,
calculated as
</p>
<p style="text-align: center;"><code class="reqn">\frac{\widehat{\alpha}}{\widehat{\alpha}+E_i}</code>
</p>
<p> .</p>
</td></tr>
</table>


<h3>References</h3>

<p>Clayton, David and Kaldor, John (1987). Empirical Bayes Estimates of Age-standardized Relative Risks for Use in Disease Mapping. Biometrics 43, 671-681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))

smth&lt;-empbaysmooth(sids$Observed, sids$Expected)
</code></pre>

<hr>
<h2 id='gearyc'>Geary's C Autocorrelation Statistic</h2><span id='topic+gearyc'></span>

<h3>Description</h3>

<p>Geary's c statistic is used to measure autocorrelation between areas within
a region, as follows:
</p>
<p style="text-align: center;"><code class="reqn">
c=\frac{(n-1)\sum_i \sum_j W_{ij}(Z_i-Z_j)^2}{2(\sum_i\sum_jW_{ij})\sum_k (Z_k-\overline{Z})^2}
</code>
</p>

<p><code class="reqn">W</code> is a squared matrix which represents the relationship between each
pair of regions. An usual approach is set <code class="reqn">w_{ij}</code> to 1 if regions
<code class="reqn">i</code> and <code class="reqn">j</code> have a common boundary and 0 otherwise, or it may
represent the inverse distance between the centroids of that two regions.
</p>
<p>Small values of this statistic may indicate the presence of highly 
correlated areas, which may be a cluster.
</p>


<h3>References</h3>

<p>Geary, R. C. (1954). The contiguity ratio and statistical mapping. The Incorporated Statistician 5, 115-145.
</p>


<h3>See Also</h3>

<p>DCluster, gearyc.stat, gearyc.boot, gearyc.pboot
</p>

<hr>
<h2 id='gearyc.boot'>Generate Bootstrap Replicates of Geary's C Autocorrelation Statistic</h2><span id='topic+gearyc.boot'></span><span id='topic+gearyc.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Geary's C autocorrelation statistic, by means
of function <em>boot</em> form <em>boot</em> library. Notice that these functions
should not  be used separately but as argument <em>statistic</em> when calling
function <em>boot</em>.
</p>
<p><em>gearyc.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>gearyc.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gearyc.boot(data, i, ...)
gearyc.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gearyc.boot_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the 
<b>DCluster</b>manpage.</p>
</td></tr>
<tr><td><code id="gearyc.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the bootstrap procedure</p>
</td></tr>
<tr><td><code id="gearyc.boot_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Geary, R. C. (1954). The contiguity ratio and statistical mapping. The Incorporated Statistician 5, 115-145.
</p>


<h3>See Also</h3>

<p>DCluster, boot, gearyc, gearyc.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)
col.W &lt;- nb2listw(ncCR85.nb, zero.policy=TRUE)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))


niter&lt;-100

#Permutation model
gc.perboot&lt;-boot(sids, statistic=gearyc.boot, R=niter, listw=col.W,
	n=length(ncCR85.nb), n1=length(ncCR85.nb)-1, S0=Szero(col.W) )
plot(gc.perboot)#Display results

#Multinomial model
gc.mboot&lt;-boot(sids, statistic=gearyc.pboot, sim="parametric", 
	ran.gen=multinom.sim, R=niter, listw=col.W,
        n=length(ncCR85.nb), n1=length(ncCR85.nb)-1, S0=Szero(col.W) )
plot(gc.mboot)#Display results

#Poisson model
gc.pboot&lt;-boot(sids, statistic=gearyc.pboot, sim="parametric", 
	ran.gen=poisson.sim, R=niter, listw=col.W,
	n=length(ncCR85.nb), n1=length(ncCR85.nb)-1, S0=Szero(col.W) )
plot(gc.pboot)#Display results

#Poisson-Gamma model
gc.pgboot&lt;-boot(sids, statistic=gearyc.pboot, sim="parametric", 
	ran.gen=negbin.sim, R=niter, listw=col.W,
	n=length(ncCR85.nb), n1=length(ncCR85.nb)-1, S0=Szero(col.W) )
plot(gc.pgboot)#Display results

</code></pre>

<hr>
<h2 id='gearyc.stat'>Compute Geary's C Autocorrelation Statistic</h2><span id='topic+gearyc.stat'></span><span id='topic+gearyc.test'></span>

<h3>Description</h3>

<p>Compute Geary's C autocorrelation statistic using either <b>residuals</b>
or <b>SMRs</b> by means of cuntion <em>geary</em> from package <em>spdep</em>.
</p>
<p>gearyc.stat computes the test statistic and the test using a hi-square
distribution whilst gearyc.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gearyc.stat(data, applyto="SMR", ...)
gearyc.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gearyc.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other 
names can be used to specify the observed and expected cases.</p>
</td></tr>
<tr><td><code id="gearyc.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="gearyc.stat_+3A_...">...</code></td>
<td>
<p>Arguments needed by
function <em>moran</em> from package <em>spdep</em>. In addition, when calling
'gearyc.test' the remaining arguments in 'gearyc.stat' not included in
'gearyc.test'. This is done so because gearyc.test calls gearyc.stat in order
to perform the test.</p>
</td></tr>
<tr><td><code id="gearyc.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="gearyc.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="gearyc.stat_+3A_applyto">applyto</code></td>
<td>
<p>A string with the name of the statistic with
which calculate Geary's Index. It may be either <em>residulas</em>
or <em>SMR</em>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Geary, R. C. (1954). The contiguity ratio and statistical mapping. The Incorporated Statistician 5, 115-145.
</p>


<h3>See Also</h3>

<p>DCluster, geary, gearyc, gearyc.boot, gearyc.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(nc.sids)
col.W &lt;- nb2listw(ncCR85.nb, zero.policy=TRUE)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))

gearyc.stat(data=sids, listw=col.W, n=length(ncCR85.nb), n1=length(ncCR85.nb)-1,
	S0=Szero(col.W) )

gearyc.stat(data=sids, applyto="SMR", listw=col.W, n=length(ncCR85.nb), 
	n1=length(ncCR85.nb)-1,S0=Szero(col.W) )

gearyc.test(Observed~offset(log(Expected)), data=sids, model="poisson", R=99,
   applyto="SMR", listw=col.W, n=length(ncCR85.nb), 
	n1=length(ncCR85.nb)-1,S0=Szero(col.W) )
</code></pre>

<hr>
<h2 id='get.knclusters'>Get Areas in a Cluster Detected with Kulldorff's Statistic</h2><span id='topic+get.knclusters'></span>

<h3>Description</h3>

<p>When <em>kn.iscluster</em> is called from <em>opgam</em> to use Kulldorff's scan
statistic for the detection of clusters of disease, <em>get.knclusters</em> can
be used to get the areas included in each cluster. <em>opgam</em> only returns
the cluster centres, size and related information but not the areas in the
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.knclusters(d, knresults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.knclusters_+3A_d">d</code></td>
<td>
<p>Data frame with the data, used in the call to <em>opgam</em>.</p>
</td></tr>
<tr><td><code id="get.knclusters_+3A_knresults">knresults</code></td>
<td>
<p>Data frame returned by a call to <em>opgam</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the same length as the number of rows in 'knresults'.  Each
element in the list is a vector of integers with the row indices of 'd' of the
areas in the cluster. The order of the indices reflects the distance to the
cluster centre.
</p>


<h3>References</h3>

<p>Kulldorff, Martin and Nagarwalla, Neville (1995). Spatial Disease Clusters: Detection and Inference. Statistics in Medicine 14, 799-810.
</p>


<h3>See Also</h3>

<p>DCluster, kullnagar, kullnagar.stat, kullnagar.boot, kullnagar.pboot, opgam
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, Population=nc.sids$BIR74, x=nc.sids$x, y=nc.sids$y)

#K&amp;N's method over the centroids
mle&lt;-calculate.mle(sids, model="poisson")
knresults&lt;-opgam(data=sids, thegrid=sids[,c("x","y")], alpha=.05, 
	iscluster=kn.iscluster, fractpop=.15, R=99, model="poisson", mle=mle)

#Plot all centroids and significant ones in red
plot(sids$x, sids$y, main="Kulldorff and Nagarwalla's method")
points(knresults$x, knresults$y, col="red", pch=19)

#Plot first cluster with the highest likelihood ratio test in green
clusters&lt;-get.knclusters(sids, knresults)
idx&lt;-which.max(knresults$statistic)
points(sids$x[clusters[[idx]]], sids$y[clusters[[idx]]], col="green", pch=19)
</code></pre>

<hr>
<h2 id='iscluster'>Local Clustering Test Function</h2><span id='topic+opgam.iscluster.default'></span><span id='topic+opgam.iscluster.negbin'></span>

<h3>Description</h3>

<p>This function is passed to function <em>gam</em> as argument <em>iscluster</em>
to decide whether the current circle must be marked as a cluster or not.
</p>
<p><em>opgam.iscluster.default</em> is the function used by default, based on 
quantiles of the Poisson distribution.
</p>
<p><em>opgam.iscluster.negbin</em> is similar to the previous one but based
on the Negative Binomial distribution. Local significance
is estimated using bootstrap since it involves the sum of Negative Binomial
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opgam.iscluster.default(data, idx, idxorder, alpha,  ...)
opgam.iscluster.negbin(data, idx, idxorder, alpha, mle, R=999, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iscluster_+3A_data">data</code></td>
<td>
<p>A dataframe with the data, as explained in <em>DCluster</em> manual page.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_idx">idx</code></td>
<td>
<p>A boolean vector to know the areas in the current circle.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_idxorder">idxorder</code></td>
<td>
<p>A permutation of the rows of data to order the regions
according to their distance to the current center.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_alpha">alpha</code></td>
<td>
<p>Test signifiance.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_mle">mle</code></td>
<td>
<p>Estimators of some parameters needed by the Negative Binomial
distribution. See <em>negbin.sim</em> manual page for details.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_r">R</code></td>
<td>
<p>Number of simulations made used to estimate local pvalues.</p>
</td></tr>
<tr><td><code id="iscluster_+3A_...">...</code></td>
<td>
<p>Any other arguments required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take a number of arguments to be able to assess
whether the current ball is a cluster or not. We have follow this 
approarch to create a common framework for all scan methods.
</p>
<p>The vector returned by this functions can be of size higher than four,
but the first four elements must be those stated in this manual
page (and in the same order).
</p>
<p>More example can be found in the implementations of other scan methods,
such as Besag and Newell's, and Kulldorff and Nagarwalla's.
</p>


<h3>Value</h3>

<p>A vector with four values:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the statistic computed.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>A boolean value, which is <em>TRUE</em> for clusters.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue obtained for the test performed.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Size of the cluster in inumber of regions from the centre.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>opgam, besagnewell, bn.iscluster, kullnagar, kn.iscluster, turnbull, tb.iscluster</p>

<hr>
<h2 id='kn.iscluster'>Clustering Function for Kulldorff and Nagarwalla's Statistic</h2><span id='topic+kn.iscluster'></span><span id='topic+kn.gumbel.iscluster'></span>

<h3>Description</h3>

<p><em>kn.iscluster</em> is called from <em>opgam</em> when studying the whole
area. At every point of the grid, which may be all the centroids, this
function is called to determine whether it is a cluster or not by
calculating Kulldorff and Nagarwalla's statistic.
</p>
<p>See <em>opgam.iscluster.default</em> for more details. <em>kn.gumbel.iscluster</em>
uses a Gumbel distribution to compute the p-values ofr each possible
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kn.iscluster(data, idx, idxorder, alpha, fractpop, use.poisson=TRUE,
 model="poisson", R, mle, ...)
kn.gumbel.iscluster(data, idx, idxorder, alpha, fractpop, use.poisson=TRUE,
 model="poisson", R, mle)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kn.iscluster_+3A_data">data</code></td>
<td>
<p>A dataframe with the data as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_idx">idx</code></td>
<td>
<p>A boolean vector to know the areas in the current circle.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_idxorder">idxorder</code></td>
<td>
<p>A permutation of the rows of data to order the regions
according to their distance to the current center.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_alpha">alpha</code></td>
<td>
<p>Test signifiance.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_fractpop">fractpop</code></td>
<td>
<p>Maximum fraction of the total population used when
creating the balls.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_use.poisson">use.poisson</code></td>
<td>
<p>Use the statistic for Poisson (default) or Bernouilli case.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_model">model</code></td>
<td>
<p>Thge model used to generate random observations. It can be
'permutation', 'multinomial', 'poisson' or 'negbin'. See <em>observed.sim</em> manual page for details.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates to generate.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_mle">mle</code></td>
<td>
<p>Parameters need by the bootstrap procedure.</p>
</td></tr>
<tr><td><code id="kn.iscluster_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to kullnagar.stat().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of four elements, as describe in <em>iscluster</em> manual page.
</p>


<h3>References</h3>

<p>Kulldorff, Martin and Nagarwalla, Neville (1995). Spatial Disease Clusters: 
Detection and Inference. Statistics in Medicine 14, 799-810.
Abrams A, Kleinman K, Kulldorff M (2010). Gumbel based p-value approximations
for spatial scan statistics. International Journal of Health Geographics, 9:61.
</p>


<h3>See Also</h3>

<p>DCluster, kullnagar, kullnagar.stat, kullnagar.boot, kullnagar.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, Population=nc.sids$BIR74, x=nc.sids$x, y=nc.sids$y)

#K&amp;N's method over the centroids
mle&lt;-calculate.mle(sids, model="poisson")
knresults&lt;-opgam(data=sids, thegrid=sids[,c("x","y")], alpha=.05, 
  iscluster=kn.iscluster, fractpop=.5, R=100, model="poisson", mle=mle)

kngumbelres&lt;-opgam(data=sids, thegrid=sids[,c("x","y")], alpha=.05, 
  iscluster=kn.gumbel.iscluster, fractpop=.5, R=100, model="poisson", 
  mle=mle)

#Plot all centroids and significant ones in red
plot(sids$x, sids$y, main="Kulldorff and Nagarwalla's method")
points(knresults$x, knresults$y, col="red", pch=19)
points(knresults$x, knresults$y, col="blue", pch=20)
</code></pre>

<hr>
<h2 id='kullnagar'>Kulldorff and Nagarwalla's Statistic for Spatial Clustering.</h2><span id='topic+kullnagar'></span>

<h3>Description</h3>

<p>This method is based on creating a grid over the study area. Each point of
the grid is taken to be the centre of all circles that contain up to a
fraction of the total population. This is calculated by suming all the
population of the regions whose centroids fall inside the circle. For each one
of these balls, the likelihood ratio of the next test hypotheses is computed:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">H_0</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">p=q</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">H_1</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">p&gt;q</code>
</td>
</tr>

</table>

<p>where <em>p</em> is the probability of being a case inside the ball and
<em>q</em> the probability of being a case outside it. Then, the ball
where the maximum of the likelihood ratio is achieved is selected and its
value is tested to assess whether it is significant or not.
</p>
<p>There are two possible statistics, depending on the model assumed for the
data, which can be Bernouilli or Poisson. The value of the likelihood ratio 
statistic is
</p>
<p style="text-align: center;"><code class="reqn">\max_{z \in Z}\frac{L(z)}{L_0}</code>
</p>

<p>where <em>Z</em> is the set of ball at a given point, <em>z</em> an element of
this set, <code class="reqn">L_0</code> is the likelihood under the null hypotheses and
<code class="reqn">L(z)</code> is the likelihood under the alternative hypotheses. The
actual formulae involved in the calculation can be found in the reference
given below.
</p>


<h3>References</h3>

<p>Kulldorff, Martin and Nagarwalla, Neville (1995). Spatial Disease Clusters: Detection and Inference. Statistics in Medicine 14, 799-810.
</p>


<h3>See Also</h3>

<p>DCluster, kullnagar.stat, kullnagar.boot, kullnagar.pboot
</p>

<hr>
<h2 id='kullnagar.boot'>Generate Bootstrap Replicates of Kulldorff and Nagarwalla's Statistic</h2><span id='topic+kullnagar.boot'></span><span id='topic+kullnagar.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Kulldorff and Nagarwalla's statistic,
by calling functions <em>boot</em> and <em>kullnagar.stat</em>.
</p>
<p><em>kullnagar.boot</em> is used when using non-parametric bootstrap to estimate
the distribution of the statistic.
</p>
<p><em>kullnagar.pboot</em> is used when performing parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullnagar.boot(data, i, ...)
kullnagar.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kullnagar.boot_+3A_data">data</code></td>
<td>
<p>A dataframe with the data as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="kullnagar.boot_+3A_i">i</code></td>
<td>
<p>Permutation created in non-parametric bootstrap.</p>
</td></tr>
<tr><td><code id="kullnagar.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Kulldorff, Martin and Nagarwalla, Neville (1995). Spatial Disease Clusters: Detection and Inference. Statistics in Medicine 14, 799-810.
</p>


<h3>See Also</h3>

<p>DCluster, boot, kullnagar, kullnagar.stat, kn.iscluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, Population=nc.sids$BIR74, x=nc.sids$x, y=nc.sids$y)

niter&lt;-100

#Permutation  model
kn.perboot&lt;-boot(sids, statistic=kullnagar.boot, R=niter, fractpop=.2)
plot(kn.perboot)#Display results

#Multinomial model
kn.mboot&lt;-boot(sids, statistic=kullnagar.pboot, sim="parametric", 
	ran.gen=multinom.sim,  R=niter, fractpop=.2)
plot(kn.mboot)#Display results

#Poisson model
kn.pboot&lt;-boot(sids, statistic=kullnagar.pboot, sim="parametric", 
	ran.gen=poisson.sim,  R=niter, fractpop=.2)
plot(kn.pboot)#Display results

#Poisson-Gamma model
kn.pgboot&lt;-boot(sids, statistic=kullnagar.pboot, sim="parametric", 
	ran.gen=negbin.sim, R=niter, fractpop=.2)
plot(kn.pgboot)#Display results


</code></pre>

<hr>
<h2 id='kullnagar.stat'>Kulldorff and Nagarwalla's Statistic for Spatial Clustering.</h2><span id='topic+kullnagar.stat'></span><span id='topic+kullnagar.stat.poisson'></span><span id='topic+kullnagar.stat.bern'></span>

<h3>Description</h3>

<p>Compute Kulldorff and Nagarwalla's spatial statistic for cluster detection
around a single region, which is supposed to be the first row of the
dataframe. The other regions are supposed to be sorted by distance to 
the centre in the data frame.
</p>
<p>Two possible function are provided: <em>kullnagar.stat.poisson</em>, for th
Poisson case, and <em>kullnagar.stat.bern</em>, for the Bernouilli case.
</p>
<p>See <em>kullnagar</em> manual page for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullnagar.stat(data, fractpop, use.poisson=TRUE, log.v=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kullnagar.stat_+3A_data">data</code></td>
<td>
<p>A dataframe with the data as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="kullnagar.stat_+3A_fractpop">fractpop</code></td>
<td>
<p>Maximum fraction of the total population used when
creating the balls.</p>
</td></tr>
<tr><td><code id="kullnagar.stat_+3A_use.poisson">use.poisson</code></td>
<td>
<p>Use the statistic for Poisson (default) or Bernouilli case.</p>
</td></tr>
<tr><td><code id="kullnagar.stat_+3A_log.v">log.v</code></td>
<td>
<p>Whether the logarithm of the statistic is returned or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of two elements:  the value of the statistic and the
size (in number of regions) of the cluster.
</p>


<h3>References</h3>

<p>Kulldorff, Martin and Nagarwalla, Neville (1995). Spatial Disease Clusters: Detection and Inference. Statistics in Medicine 14, 799-810.
</p>


<h3>See Also</h3>

<p>DCluster, kullnagar, kullnagar.stat, kullnagar.boot, kullnagar.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, Population=nc.sids$BIR74, x=nc.sids$x, y=nc.sids$y)


dist&lt;-(sids$x-sids$x[1])^2+(sids$y-sids$y[1])^2
index&lt;-order(dist)
#Compute the statistic around the first county
kullnagar.stat(sids[index,], fractpop=.5)
</code></pre>

<hr>
<h2 id='lognormalEB'>Empirical Bayes Smoothing Using a log-Normal Model</h2><span id='topic+lognormalEB'></span>

<h3>Description</h3>

<p>Smooth  relative risks from a set of expected and observed number of cases
using a log-Normal model as proposed by <em>Clayton and Kaldor</em> (1987).
There are estimated by 
<code class="reqn">\tilde{\beta}_i =\log((O_i+1/2)/E_i)</code>
in order to prevent taking the logarithm of zero.
</p>
<p>If this case, the log-relative risks are assumed be independant and to have a
normal distribution with mean <code class="reqn">\varphi</code> and variance
<code class="reqn">\sigma^2</code>.  Clayton y Kaldor (1987) use the EM algorithm to
develop estimates of these two parameters which are used to compute the
Empirical Bayes estimate of <code class="reqn">b_i</code>. The formula is not listed here, but
it can be consulted in Clayton and Kaldor (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormalEB(Observed, Expected, maxiter = 20, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lognormalEB_+3A_observed">Observed</code></td>
<td>
<p>Vector of observed cases.</p>
</td></tr>
<tr><td><code id="lognormalEB_+3A_expected">Expected</code></td>
<td>
<p>Vector of expected cases.</p>
</td></tr>
<tr><td><code id="lognormalEB_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lognormalEB_+3A_tol">tol</code></td>
<td>
<p>Tolerance used to stop the iterative procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four elements:
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>Number of regions.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Estimate of <code class="reqn">\varphi</code>.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimate of <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>smthrr</code></td>
<td>
<p>Vector of smoothed relative risks.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Clayton, David and Kaldor, John (1987). Empirical Bayes Estimates of Age-standardized Relative Risks for Use in Disease Mapping. Biometrics 43, 671-681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))

smth&lt;-lognormalEB(sids$Observed, sids$Expected)
</code></pre>

<hr>
<h2 id='moranI'>Moran's I Autocorrelation Statistic</h2><span id='topic+moranI'></span>

<h3>Description</h3>

<p>Moran's I statistic measures autocorrelation between areas within
a region. It is similar to the correlation coefficient:
</p>
<p style="text-align: center;"><code class="reqn">
I=\frac{n\sum_i\sum_j W_{ij}(Z_i-\overline{Z})(Z_j-\overline{Z})}{2(\sum_i\sum_jW_{ij})\sum_k (Z_k-\overline{Z})^2}
</code>
</p>

<p><code class="reqn">W</code> is a squared matrix which represents the relationship between each
pair of regions. An usual approach is set <code class="reqn">w_{ij}</code> to 1 if regions
<code class="reqn">i</code> and <code class="reqn">j</code> have a common boundary and 0 otherwise, or it may
represent the inverse distance between the centroids of these two regions.
</p>
<p>High values of this statistic may indicate the presence of groups of zones
where values are unusually high. On the other hand, low values
of the Moran's statistic will indicate no correlation between neighbouring
areas, which may lead to indipendance in the observations. 
</p>
<p><em>moranI.stat</em> is the function to calculate the value of the statistic for
residuals or SMRs of the data.
</p>
<p><em>moranI.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>moranI.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>References</h3>

<p>Moran, P. A. P. (1948). The interpretation os statistical maps. Journal of the Royal Statistical Society, Series B 10, 243-251.
</p>


<h3>See Also</h3>

<p>DCluster, moranI.stat, moranI.boot, moranI.pboot
</p>

<hr>
<h2 id='moranI.boot'>Generate Bootstrap Replicates of Moran's I Autocorrelation Statistic</h2><span id='topic+moranI.boot'></span><span id='topic+moranI.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Moran's I autocorrelation statistic, by means
of function <em>boot</em> form <em>boot</em> library. Notice that these functions
should not  be used separately but as argument <em>statistic</em> when calling
function <em>boot</em>.
</p>
<p><em>moranI.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>moranI.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranI.boot(data, i, ...)
moranI.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moranI.boot_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the 
<b>DCluster</b>manpage.</p>
</td></tr>
<tr><td><code id="moranI.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the bootstrap procedure</p>
</td></tr>
<tr><td><code id="moranI.boot_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Moran, P. A. P. (1948). The interpretation os statistical maps. Journal of the Royal Statistical Society, Series B 10, 243-251.
</p>


<h3>See Also</h3>

<p>DCluster, boot, moranI, moranI.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(nc.sids)
col.W &lt;- nb2listw(ncCR85.nb, zero.policy=TRUE)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74)) 

niter&lt;-100

#Permutation model
moran.boot&lt;-boot(sids, statistic=moranI.boot, R=niter, listw=col.W, 
	n=length(ncCR85.nb), S0=Szero(col.W) )
plot(moran.boot)#Display results

#Multinomial model
moran.mboot&lt;-boot(sids, statistic=moranI.pboot, sim="parametric", 
	ran.gen=multinom.sim,  R=niter, listw=col.W,n=length(ncCR85.nb), 
	S0=Szero(col.W) )
plot(moran.mboot)#Display results

#Poisson model
moran.pboot&lt;-boot(sids, statistic=moranI.pboot, sim="parametric", 
	ran.gen=poisson.sim,  R=niter, listw=col.W,n=length(ncCR85.nb),
	S0=Szero(col.W) )
		
plot(moran.pboot)#Display results

#Poisson-Gamma model
moran.pgboot&lt;-boot(sids, statistic=moranI.pboot, sim="parametric", 
	ran.gen=negbin.sim, R=niter,  listw=col.W,n=length(ncCR85.nb),
	S0=Szero(col.W) )
		
plot(moran.pgboot)#Display results
</code></pre>

<hr>
<h2 id='moranI.stat'>Compute Moran's I Autocorrelation Statistic</h2><span id='topic+moranI.stat'></span><span id='topic+moranI.test'></span>

<h3>Description</h3>

<p>Compute Moran's I autocorrelation statistic using <b>residuals</b>
or <b>SMRs</b> by means of function <em>moran</em> from package 
<em>spdep</em>.
</p>
<p>moranI.stat computes the test statistic and the test using a hi-square
distribution whilst moranI.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranI.stat(data, applyto="SMR", ...)
moranI.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moranI.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other
names can be used to specify the observed and expected cases.</p>
</td></tr>
<tr><td><code id="moranI.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="moranI.stat_+3A_...">...</code></td>
<td>
<p>Arguments needed by
function <em>moran</em> from package <em>spdep</em>. In addition, when calling 
'moranI.test' the remaining arguments in 'moranI.stat' not included in
'moranI.test'. This is done so because moranI.test calls moranI.stat in order
to perform the test.</p>
</td></tr>
<tr><td><code id="moranI.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="moranI.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="moranI.stat_+3A_applyto">applyto</code></td>
<td>
<p>A string with the name of the statistic with
which calculate Moran's Index. It may be either <em>residulas</em>
or <em>SMR</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the statistic computed.
</p>


<h3>References</h3>

<p>Moran, P. A. P. (1948). The interpretation os statistical maps. Journal of the Royal Statistical Society, Series B 10, 243-251.
</p>


<h3>See Also</h3>

<p>DCluster, moran, moranI, moranI.boot, MoranI.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(nc.sids)
col.W &lt;- nb2listw(ncCR85.nb, zero.policy=TRUE)


sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74) )

moranI.stat(data=sids, listw=col.W, n=length(ncCR85.nb), S0=Szero(col.W) )

moranI.stat(data=sids, applyto="residuals", listw=col.W, n=length(ncCR85.nb), 
	S0=Szero(col.W) )

moranI.test(Observed~offset(log(Expected)), sids, model="poisson", R=99,
   listw=col.W, n=length(ncCR85.nb), S0=Szero(col.W) )

</code></pre>

<hr>
<h2 id='observed.sim'>Randomly Generate Observed Cases from Different Statistical Distributions</h2><span id='topic+multinom.sim'></span><span id='topic+poisson.sim'></span><span id='topic+negbin.sim'></span>

<h3>Description</h3>

<p>Simulate Observed number of cases according to a Multinomial, Poisson or
Negative Binomial distribution.
</p>
<p>These functions are used when performing a parametric bootstrap and
they must be passed as argument <em>ran.gen</em> when calling function <em>boot</em>.
</p>
<p><em>multinom.sim</em> generates observations from a Multinomial distribution.
</p>
<p><em>poisson.sim</em> generates observations from a Poisson distribution.
</p>
<p><em>negbin.sim</em> generates observations from a Negative Binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom.sim(data, mle=NULL)

poisson.sim(data, mle=NULL)

negbin.sim(data, mle=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observed.sim_+3A_data">data</code></td>
<td>
<p>A dataframe as described in the <em>DCluster</em> manual page.</p>
</td></tr>
<tr><td><code id="observed.sim_+3A_mle">mle</code></td>
<td>

<p>List containing the parameters of the distributions to be used.  If
they are not provided, then they are calculated from the data. Its value 
argument <em>mle</em> in function <em>boot</em>. 
</p>
<p>The elements in the list depend on the distribution to be used:
</p>

<ul>
<li><p> Multimonial
</p>
<p>Total observed cases (<em>n</em>) and vector of probabilities (<em>p</em>).
</p>
</li>
<li><p> Poisson
</p>
<p>Total number of regions (<em>n</em>) and vector of means (<em>lambda</em>).
</p>
</li>
<li><p> Negative Binomial
</p>
<p>Total number of regions (<em>n</em>) and parameters <em>nu</em> and <em>alpha</em>
of the Gamma distribution.
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe equal to the argument <em>data</em>, but in which the Observed
column has been substituted by sampled observations. See <em>DCluster</em>
manual page for more details.
</p>


<h3>See Also</h3>

<p>DCluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#Carry out simulations
datasim&lt;-multinom.sim(sids, mle=calculate.mle(sids, model="multinomal") )

#Estimators for Poisson distribution
datasim&lt;-poisson.sim(sids, mle=calculate.mle(sids, model="poisson") )

#Estimators for Negative Binomial distribution
datasim&lt;-negbin.sim(sids, mle=calculate.mle(sids, model="negbin") )

</code></pre>

<hr>
<h2 id='opgam'>Openshaw's GAM</h2><span id='topic+opgam'></span><span id='topic+opgam.intern'></span>

<h3>Description</h3>

<p>Scan an area with Openshaw's Geographical Analysis Machine to look
for clusters.
</p>
<p><em>opgam</em> is the main function, while <em>gam.intern</em> is called
from there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opgam(data, thegrid=NULL, radius=Inf, step=NULL, alpha,
 iscluster=opgam.iscluster.default, set.idxorder=TRUE, ...)
opgam.intern(point, data, rr, set.idxorder, iscluster, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opgam_+3A_data">data</code></td>
<td>
<p>A dataframe with the data, as described in <em>DCluster</em> manual
page.</p>
</td></tr>
<tr><td><code id="opgam_+3A_thegrid">thegrid</code></td>
<td>
<p>A two-columns matrix containing
the points of the grid to be used. If it is null, a rectangular grid of step 
<em>step</em> is built.</p>
</td></tr>
<tr><td><code id="opgam_+3A_radius">radius</code></td>
<td>
<p>The radius of the circles used in the computations.</p>
</td></tr>
<tr><td><code id="opgam_+3A_step">step</code></td>
<td>
<p>The step of the grid.</p>
</td></tr>
<tr><td><code id="opgam_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the tests performed.</p>
</td></tr>
<tr><td><code id="opgam_+3A_iscluster">iscluster</code></td>
<td>
<p>Function used to decide whether the current circle
is a possible cluster or not. It must have the same arguments
and return the same object than <em>gam.iscluster.default</em></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="opgam_+3A_set.idxorder">set.idxorder</code></td>
<td>
<p>Whether an index for the ordering by distance
to the center of the current ball is calculated or not.</p>
</td></tr>
<tr><td><code id="opgam_+3A_point">point</code></td>
<td>
<p>Point where the curent ball is centred.</p>
</td></tr>
<tr><td><code id="opgam_+3A_rr">rr</code></td>
<td>
<p>rr=radius*radius .</p>
</td></tr>
<tr><td><code id="opgam_+3A_...">...</code></td>
<td>
<p>Aditional arguments to be passed to <em>iscluster</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>Geographical Analysis Machine</em> was developed by Openshaw
et al. to perform geographical studies of the relationship between
different types of cancer and their proximity to nuclear plants.
</p>
<p>In this method, a grid of a fixed step is built along the study region, and
small balls of a given radius are created at each point of the grid. Local
observed and expected number of cases and population are calculated and a
function is used to assess whether the current ball is a cluster or not.  For
more information about this function see <em>opgam.iscluster.default</em>, which
is the default function used.
</p>
<p>If the obverved number of cases excess a critical value, which is calculated
by a function passed as an argument, then that circle is marked as a possible
cluster. At the end, all possible clusters are drawn on a map. Clusters may be
easily identified then.
</p>
<p>Notice that we have follow a pretty flexible approach, since user-implemented
functions can be used to detect clusters, such as those related to
ovedispersion (Pearson's Chi square statistic, Potthoff-Whittinghill's
statistic) or autocorrelation (Moran's I statistic and Geary's c statistic),
or a bootstrap procedure, although it is not recommended because it can
be VERY slow.
</p>


<h3>Value</h3>

<p>A dataframe with five columns:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Easting coordinate of the center of the cluster.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Northing coordinate of the center of the cluster.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Value of the statistic computed.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Is it a cluster (according to the criteria used)? It should
be always TRUE.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>Significance of the cluster.</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Openshaw, S. and Charlton, M. and Wymer, C. and Craft, A. W. (1987). A mark I geographical analysis machine for the automated analysis of point data sets. International Journal of Geographical Information Systems 1, 335-358.
</p>
<p>Waller, Lance A. and Turnbull, Bruce W. and Clarck, Larry C. and Nasca, Philip (1994). Spatial Pattern Analyses to Detect Rare Disease Clusters. In 'Case Studies in Biometry'. Chapter 1, 3-23.
</p>


<h3>See Also</h3>

<p>DCluster, opgam.iscluster.default
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)


#GAM using the centroids of the areas in data
sidsgam&lt;-opgam(data=sids,  radius=30, step=10, alpha=.002)

#Plot centroids
plot(sids$x, sids$y, xlab="Easting", ylab="Northing")
#Plot points marked as clusters
points(sidsgam$x, sidsgam$y, col="red", pch="*")

</code></pre>

<hr>
<h2 id='pottwhitt'>Potthoff-Whittinghill's Statistic for Overdispersion</h2><span id='topic+pottwhitt'></span>

<h3>Description</h3>

<p>This statistic can be used to test for homogeinity among all
the relative risks. The test statistic is:
</p>
<p style="text-align: center;"><code class="reqn">E_+ \sum_{i=1}^n \frac{O_i(O_i-1)}{E_i}</code>
</p>

<p>If we supposse that the data are generated from a multinomial model,
this is the locally U.M.P. when considering the next hypotheses:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code class="reqn">H_0</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">\theta_1 = \ldots = \theta_n=\lambda</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">H_1</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">\theta_i \sim Ga(\lambda^2/\sigma^2, \lambda/\sigma^2)</code>
</td>
</tr>

</table>

<p>Notice that in this case, <code class="reqn">\lambda</code> is supposed to be unknown.
The alternative hypotheses means that relative risks come all from a Gamma
distribution with mean <code class="reqn">\lambda</code> and variance
<code class="reqn">\sigma^2</code>.
</p>
<p><em>pottwhitt.stat</em> is the function to calculates the value of the statistic
for the data.
</p>
<p><em>pottwhitt.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>pottwhitt.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster, pottwhitt.stat, pottwhitt.boot, pottwhitt.pboot
</p>

<hr>
<h2 id='pottwhitt.boot'>Bootstrap Replicates of Potthoff-Whittinghill's Statistic</h2><span id='topic+pottwhitt.boot'></span><span id='topic+pottwhitt.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Potthoff-Whittinghill's statistic (function
<em>pottwhitt.stat</em>), by means of function <em>boot</em> from the <em>boot</em>
library. Notice that these functions should not  be used separately but as
argument <em>statistic</em> when calling function <em>boot</em>.
</p>
<p><em>pottwhitt.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>pottwhitt.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pottwhitt.boot(data, i)
pottwhitt.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pottwhitt.boot_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the 
<b>DCluster</b>  manual page.</p>
</td></tr>
<tr><td><code id="pottwhitt.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the bootstrap procedure</p>
</td></tr>
<tr><td><code id="pottwhitt.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster, pottwhitt, pottwhitt.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

niter&lt;-100


#Permutation model
pw.boot&lt;-boot(sids, statistic=pottwhitt.boot, R=niter)
plot(pw.boot)#Plot results


#Multinomial model
pw.mboot&lt;-boot(sids, statistic=pottwhitt.pboot, sim="parametric", ran.gen=multinom.sim,  R=niter)
plot(pw.mboot)#Plot results

#Poisson model
pw.pboot&lt;-boot(sids, statistic=pottwhitt.pboot, sim="parametric", ran.gen=poisson.sim,  R=niter)
plot(pw.pboot)#Plot results

#Poisson-Gamma model
pw.pgboot&lt;-boot(sids, statistic=pottwhitt.pboot, sim="parametric", ran.gen=negbin.sim, R=niter)
plot(pw.pgboot)#Plot results

</code></pre>

<hr>
<h2 id='pottwhitt.stat'>Compute Potthoff-Whittinghill's Statistic</h2><span id='topic+pottwhitt.stat'></span><span id='topic+pottwhitt.test'></span>

<h3>Description</h3>

<p>Compute Pottwhoff-Whittinghill's statistic.
</p>
<p>pottwhitt.stat computes the test statistic and the test using a hi-square
distribution whilst pottwhitt.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pottwhitt.stat(data)
pottwhitt.test(formula, data, model, R, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pottwhitt.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below). Note that now it
is not necessary to use Observed and Expected and that any other 
names can be used to specify the observed and expected cases.
</p>
</td></tr>
<tr><td><code id="pottwhitt.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for details.</p>
</td></tr>
<tr><td><code id="pottwhitt.stat_+3A_...">...</code></td>
<td>
<p>The remaining arguments in 'achisq.stat' not included in
'achisq.test'. This is done so because achisq.test calls achisq.stat in order to perform the test.</p>
</td></tr>
<tr><td><code id="pottwhitt.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="pottwhitt.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>T</code></td>
<td>
<p>The value of the statistic.</p>
</td></tr>
<tr><td><code>asintmean</code></td>
<td>
<p>Mean of the asymptotical Normal distribution.</p>
</td></tr>
<tr><td><code>asintvar</code></td>
<td>
<p>Variance of the asymptotical Normal distribution.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>Significance of the statistic.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: I. The Binomial and Multinomial Distributions. Biometrika 53, 167-182.
</p>
<p>Potthoff, R. F. and Whittinghill, M.(1966). Testing for Homogeneity: The Poisson Distribution. Biometrika 53, 183-190.
</p>


<h3>See Also</h3>

<p>DCluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

pottwhitt.stat(sids)

pottwhitt.test(Observed~offset(log(Expected)),sids, model="poisson", R=99)
</code></pre>

<hr>
<h2 id='readSplus'>Read exported WinBUGS maps</h2><span id='topic+readSplus'></span>

<h3>Description</h3>

<p>The function permits an exported WinBUGS map to be read into an <span class="pkg">sp</span> package class <code>SpatialPolygons</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSplus(file, proj4string = as.character(NA))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readSplus_+3A_file">file</code></td>
<td>
<p>name of file</p>
</td></tr>
<tr><td><code id="readSplus_+3A_proj4string">proj4string</code></td>
<td>
<p>Object of class '&quot;CRS&quot;'; holding a valid proj4 string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readSplus</code> returns a SpatialPolygons object
</p>


<h3>Note</h3>

<p>In the example, taken from the GeoBUGS manual, the smaller part of area1 has a counter-clockwise ring direction in the data, while other rings are clockwise. This implies that it is a hole, and does not get filled. The region labels are stored in the <code>ID</code> slots of the <code>Polygons</code> objects.</p>


<h3>Author(s)</h3>

<p>Virgilio Gomez Rubio &lt;Virgilio.Gomez@uclm.es&gt;</p>


<h3>References</h3>

<p><a href="https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf">https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("sp", quietly=TRUE)) run &lt;- TRUE
if (run) {
geobugs &lt;- readSplus(system.file("share/Splus.map", package="DCluster"))
plot(geobugs, axes=TRUE, col=1:3)
row.names(geobugs)
}
if (run) {
pls &lt;- slot(geobugs, "polygons")
sapply(pls, function(i) sapply(slot(i, "Polygons"), slot, "hole"))
}
if (run &amp;&amp; require("sf", quietly=TRUE)) {
geobugs_sf &lt;- st_make_valid(st_as_sf(geobugs))
pls1 &lt;- slot(as(st_geometry(geobugs_sf), "Spatial"), "polygons")
#pls1 &lt;- lapply(pls, checkPolygonsHoles)
print(sapply(pls1, function(i) sapply(slot(i, "Polygons"), slot, "hole")))
plot(SpatialPolygons(pls1), axes=TRUE, col=1:3)
}
</code></pre>

<hr>
<h2 id='rmultin'>Generate Random Observations from a Multinomial Distribution</h2><span id='topic+rmultin'></span>

<h3>Description</h3>

<p>This function generates a random observation from a multinomial
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultin(n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmultin_+3A_n">n</code></td>
<td>
<p>Total size (and NOT the number of variables involved in the multinomial distribution).</p>
</td></tr>
<tr><td><code id="rmultin_+3A_p">p</code></td>
<td>
<p>Vector of probabilities. The sum of all its elements must be one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the sample which has been generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>for(i in 1:10)
	print(rmultin(10, c(1/3, 1/3, 1/3) ))
</code></pre>

<hr>
<h2 id='sp2WB'>Export SpatialPolygons object as S-Plus map for WinBUGS</h2><span id='topic+sp2WB'></span>

<h3>Description</h3>

<p>The function exports an sp SpatialPolygons object into a S-Plus map
format to be import by WinBUGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2WB(map, filename, Xscale = 1, Yscale = Xscale, plotorder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp2WB_+3A_map">map</code></td>
<td>
<p>a SpatialPolygons object</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_filename">filename</code></td>
<td>
<p>file where output is written</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_xscale">Xscale</code>, <code id="sp2WB_+3A_yscale">Yscale</code></td>
<td>
<p>scales to be written in the output file</p>
</td></tr>
<tr><td><code id="sp2WB_+3A_plotorder">plotorder</code></td>
<td>
<p>default=FALSE, if TRUE, export polygons in plotting order</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Virgilio Gómez Rubio, partly derived from earlier code by Thomas Jagger</p>


<h3>References</h3>

<p><a href="https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf">https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/geobugs12manual.pdf</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (require("sp", quietly=TRUE) &amp;&amp; require("sf", quietly=TRUE)) run &lt;- TRUE
if (run) {
xx &lt;- as(st_read(system.file("shape/nc.shp", package="sf")[1], quiet=TRUE), "Spatial")
plot(xx, border="blue", axes=TRUE, las=1)
}
if (run) {
tf &lt;- tempfile()
sp2WB(as(xx, "SpatialPolygons"), filename=tf)
xxx &lt;- readSplus(tf, proj4string="+proj=longlat +ellps=clrk66")
all.equal(xxx, as(xx, "SpatialPolygons"), tolerance=.Machine$double.eps^(1/4),
 check.attributes=FALSE)
}
if (run) {
x &lt;- GridTopology(c(178420, 329420), c(40, 40), c(80, 115))
xp &lt;- as(SpatialGrid(x), "SpatialPixels")
pp &lt;- as(xp, "SpatialPolygons")
td &lt;- tempdir()
sp2WB(pp, filename=file.path(td, "test.map"))
xxx &lt;- readSplus(file.path(td, "test.map"))
all.equal(xxx, pp, tolerance=.Machine$double.eps^(1/4),
 check.attributes=FALSE)
}
</code></pre>

<hr>
<h2 id='stone'>Stone's Test</h2><span id='topic+stone'></span>

<h3>Description</h3>

<p>Stone's Test is used to assess risk around given locations (i. e., a putative
pollution source). The null hypotheses is that relative risks are constant
across areas, while the alternative is that there is descending trend in
relative risks as distance to the focus increases. That is
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">H_0</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">\theta_1 = \ldots = \theta_n = \lambda</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">H_1</code> </td><td style="text-align: center;"> : </td><td style="text-align: left;"> <code class="reqn">\theta_1 \geq \ldots \geq \theta_n</code>

</td>
</tr>

</table>

<p>Supposing data sorted by distance to the putative pollution source, Stone's
statistic is as follows:
</p>
<p style="text-align: center;"><code class="reqn">\max_{j}(\frac{\sum _{i=1}^j O_i}{\sum _{i=1}^j E_i)}</code>
</p>

<p>Depending on whether <code class="reqn">\lambda</code> is known (usually 1) or not,
<code class="reqn">E_i</code> may need a minor correction, which are not done automatically.
See <em>achisq</em> manual page for details.
</p>


<h3>References</h3>

<p>Stone, R. A. (1988). Investigating of excess environmental risks around putative sources: Statistical problems and a proposed test. Statistics in Medicine 7,649-660.
</p>


<h3>See Also</h3>

<p>DCluster, stone.stat, stone.boot, stone.pboot
</p>

<hr>
<h2 id='stone.boot'>Generate Boostrap Replicates of Stone's Statistic</h2><span id='topic+stone.boot'></span><span id='topic+stone.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Stone's statictic, by means of function
<em>boot</em> from <em>boot</em> package. Notice that these functions should not
be used separately but as argument <em>statistic</em> when calling function
<em>boot</em>.
</p>
<p><em>stone.boot</em> is used when performing a non-parametric bootstrap.
</p>
<p><em>stone.pboot</em> is used when performing a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stone.boot(data, i, ...)
stone.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stone.boot_+3A_data">data</code></td>
<td>
<p> A dataframe with all the data, as explained in the <em>DCluster</em>
manual page.</p>
</td></tr>
<tr><td><code id="stone.boot_+3A_i">i</code></td>
<td>
<p>Permutation created in non-parametric bootstrap.</p>
</td></tr>
<tr><td><code id="stone.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Stone, R. A. (1988). Investigating of excess environmental risks around putative sources: Statistical problems and a proposed test. Statistics in Medicine 7,649-660.
</p>


<h3>See Also</h3>

<p>DCluster, boot, stone.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

niter&lt;-100

#All Tests are performed around county 78.


#Permutation  model
st.perboot&lt;-boot(sids, statistic=stone.boot, R=niter, region=78)
plot(st.perboot)#Display results

#Multinomial model
st.mboot&lt;-boot(sids, statistic=stone.pboot, sim="parametric",
  ran.gen=multinom.sim,  R=niter, region=78)
plot(st.mboot)#Display results

#Poisson model
st.pboot&lt;-boot(sids, statistic=stone.pboot, sim="parametric",
  ran.gen=poisson.sim,  R=niter, region=78)
plot(st.pboot)#Display results

#Poisson-Gamma model
st.pgboot&lt;-boot(sids, statistic=stone.pboot, sim="parametric",
  ran.gen=negbin.sim, R=niter, region=78)
plot(st.pgboot)#Display results


</code></pre>

<hr>
<h2 id='stone.stat'>Compute Stone's Statistic</h2><span id='topic+stone.stat'></span><span id='topic+stone.test'></span>

<h3>Description</h3>

<p>Calculate Stone's statistic. See <em>stone</em> manual page for details.
</p>
<p>stone.stat computes the test statistic and the test using a hi-square
distribution whilst stone.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stone.stat(data, region, sorted=FALSE, lambda)
stone.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stone.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other
names can be used to specify the observed and expected cases.
</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_...">...</code></td>
<td>
<p>The remaining arguments in 'stone.stat' not included in
'stone.test'. This is done so because stone.test calls stone.stat in order to perform the test.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_region">region</code></td>
<td>
<p>Region where around which we want to test for a cluster. It must
a row number of <em>data</em>.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_sorted">sorted</code></td>
<td>
<p>Whether the data are already sorted by distance to <em>region</em>.</p>
</td></tr>
<tr><td><code id="stone.stat_+3A_lambda">lambda</code></td>
<td>
<p>Value of the null hypotheses. It may NULL (i. e., not known) or a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two elements with the value of the statistic and the region
(counting from the centre) where it was achieved.
</p>


<h3>References</h3>

<p>Stone, R. A. (1988). Investigating of excess environmental risks around putative sources: Statistical problems and a proposed test. Statistics in Medicine 7,649-660.
</p>


<h3>See Also</h3>

<p>DCluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#Compute Stone's statistic around Anson county
region&lt;-which(row.names(nc.sids)=="Robeson")
stone.stat(sids, region=region, lambda=1)


stone.test(Observed~offset(log(Expected)), sids, model="poisson", R=99, 
   region=region, lambda=1)
</code></pre>

<hr>
<h2 id='tango'>Tango's Statistic for General Clustering</h2><span id='topic+tango'></span>

<h3>Description</h3>

<p>Tango's statistic to perform a general clustering test is expressed as
follows:
</p>
<p style="text-align: center;"><code class="reqn">T = (r-p)^{'} A (r-p)</code>
</p>

<p>where <code class="reqn">r^{'} = [O_1/O_+, \ldots, O_n/O_+]</code>, 
<code class="reqn">p^{'}=[E_1/E_+, \ldots, E_n/E_+]</code> 
and <code class="reqn">A</code> is a matrix of closeness which measures
the cloneness between two zones (the higher the closer).
</p>
<p>Tango proposes to take <code class="reqn">A_{ij}=\exp\{-D_{ij}/\phi\}</code>,
where <code class="reqn">D_{ij}</code> is the distance between centroids of regions <em>i</em>
and <em>j</em>, and <code class="reqn">\phi</code> is a constant that measures how strong is the
relationship between regions in a general way.
</p>


<h3>References</h3>

<p>Tango, Toshiro (1995). A Class of Tests for Detecting 'General' and 'Focused' Clustering of Rare Diseases. Statistics in Medicine 14, 2323-2334.
</p>


<h3>See Also</h3>

<p>DCluster, tango.stat, tango.boot, tango.pboot
</p>

<hr>
<h2 id='tango.boot'>Generate Bootstrap Replicated of Tango's Statistic</h2><span id='topic+tango.boot'></span><span id='topic+tango.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicated of Tango's statistic for general clustering, by
means of function <em>boot</em> from <em>boot</em> library. Notice that these
functions should not be used separately but as argument <em>statistic</em> when
calling function <em>boot</em>.
</p>
<p><em>tango.boot</em> is used when performing non-parametric bootstrap.
</p>
<p><em>tango.pboot</em> must be used for parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tango.boot(data, i, ...)
tango.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tango.boot_+3A_data">data</code></td>
<td>
<p>Dataframe with the data as described in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="tango.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the non-parametric boostrap procedure.</p>
</td></tr>
<tr><td><code id="tango.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Tango, Toshiro (1995). A Class of Tests for Detecting 'General' and 'Focused' Clustering of Rare Diseases. Statistics in Medicine 14, 2323-2334.
</p>


<h3>See Also</h3>

<p>DCluster, boot, tango, tango.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74) )
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)


#Calculate neighbours based on distance
coords&lt;-as.matrix(sids[,c("x", "y")])

dlist&lt;-dnearneigh(coords, 0, Inf)
dlist&lt;-include.self(dlist)
dlist.d&lt;-nbdists(dlist, coords)

#Calculate weights. They are globally standardised but it doesn't
#change significance.
col.W.tango&lt;-nb2listw(dlist, glist=lapply(dlist.d, function(x) {exp(-x)}),
        style="C")
	
niter&lt;-100


#Permutation model
tn.boot&lt;-boot(sids, statistic=tango.boot, R=niter, listw=col.W.tango, 
	zero.policy=TRUE)
plot(tn.boot)#Display results

#Multinomial model
tn.mboot&lt;-boot(sids, statistic=tango.pboot, sim="parametric", 
	ran.gen=multinom.sim,  R=niter, listw=col.W.tango, zero.policy=TRUE)
		
plot(tn.mboot)#Display results

#Poisson model
tn.pboot&lt;-boot(sids, statistic=tango.pboot, sim="parametric", 
	ran.gen=poisson.sim,  R=niter, listw=col.W.tango, zero.policy=TRUE)
		
plot(tn.pboot)#Display results

#Poisson-Gamma model
tn.pgboot&lt;-boot(sids, statistic=tango.pboot, sim="parametric", 
	ran.gen=negbin.sim, R=niter, listw=col.W.tango, zero.policy=TRUE)
plot(tn.pgboot)#Display results
</code></pre>

<hr>
<h2 id='tango.stat'>Compute Tango's Statistic for General Clustering</h2><span id='topic+tango.stat'></span><span id='topic+tango.test'></span>

<h3>Description</h3>

<p>Compute Tango's statistic for general clustering. See <em>tango</em> manual
page for details.
</p>
<p>tango.stat computes the test statistic and the test using a hi-square
distribution whilst tango.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tango.stat(data, listw, zero.policy)
tango.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tango.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other
names can be used to specify the observed and expected cases.
</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_...">...</code></td>
<td>
<p>The remaining arguments in 'tango.stat' not included in
'tango.test'. This is done so because tango.test calls tango.stat in order to perform the test.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_listw">listw</code></td>
<td>
<p>Neighbours list with spatial weights created, for example,
by 'nb2listw' (package <em>spdep</em>).</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_zero.policy">zero.policy</code></td>
<td>
<p>See <em>nb2listw</em> in package <em>spdep</em>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tango, Toshiro (1995). A Class of Tests for Detecting 'General' and 'Focused' Clustering of Rare Diseases. Statistics in Medicine 14, 2323-2334.
</p>


<h3>See Also</h3>

<p>DCluster, tango, tango.boot, tango.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74) )
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#Calculate neighbours based on distance
coords&lt;-as.matrix(sids[,c("x", "y")])

dlist&lt;-dnearneigh(coords, 0, Inf)
dlist&lt;-include.self(dlist)
dlist.d&lt;-nbdists(dlist, coords)

#Calculate weights. They are globally standardised but it doesn't
#change significance.
col.W.tango&lt;-nb2listw(dlist, glist=lapply(dlist.d, function(x) {exp(-x)}),
        style="C")

#use exp(-D) as closeness matrix
tango.stat(sids, col.W.tango, zero.policy=TRUE)

tango.test(Observed~offset(log(Expected)), sids, model="poisson", R=99, 
   list=col.W.tango, zero.policy=TRUE)
</code></pre>

<hr>
<h2 id='Tests+20for+20Overdispertion'>Likelihood Ratio Test and Dean's Tests for Overdispertion</h2><span id='topic+test.nb.pois'></span><span id='topic+DeanB'></span><span id='topic+DeanB2'></span>

<h3>Description</h3>

<p>When working with count data,  the assumption of a Poisson model is 
common. However, sometimes the variance of the data is significantly 
higher that their mean which means that the assumption of that data have
been drawn from a Poisson distribution is wrong. 
</p>
<p>In that case is is usually said that data are overdispersed and a better
model must be proposed. A good choice is a Negative Binomial distribution
(see, for example, <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code>.
</p>
<p>Tests for overdispersion available in this package are the Likelihood Ratio
Test (LRT) and Dean's <code class="reqn">P_B</code> and  <code class="reqn">P'_B</code> tests.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.nb.pois(x.nb, x.glm)
DeanB(x.glm, alternative="greater")
DeanB2(x.glm, alternative="greater")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tests+2B20for+2B20Overdispertion_+3A_x.nb">x.nb</code></td>
<td>
<p>Fitted Negative Binomial.</p>
</td></tr>
<tr><td><code id="Tests+2B20for+2B20Overdispertion_+3A_x.glm">x.glm</code></td>
<td>
<p>Fitted Poisson model.</p>
</td></tr>
<tr><td><code id="Tests+2B20for+2B20Overdispertion_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hipothesis to be tested. It can be
&quot;less&quot;, &quot;greater&quot; or &quot;two.sided&quot;, although the usual choice will
often be &quot;greater&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LRT is computed to compare a fitted Poisson model against a fitted
Negative Binomial model.
</p>
<p>Dean's <code class="reqn">P_B</code> and  <code class="reqn">P'_B</code> tests are score tests. These
two tests were proposed for the case in which we look for overdispersion
of the form 
<code class="reqn">var(Y_i)=\mu_i(1+\tau \mu_i)</code>, where 
<code class="reqn">E(Y_i)=\mu_i</code>.
See Dean (1992) for more details.
</p>


<h3>Value</h3>

<p>An object of type <em>htest</em> with the results (p-value, etc.).
</p>


<h3>References</h3>

<p>Dean, C.B. (1992), Testing for overdispersion in Poisson and binomial regression models, <em>J. Amer. Statist. Assoc.</em> 87, 451-457.
</p>


<h3>See Also</h3>

<p>DCluster, achisq.stat, pottwhit.stat, negative.binomial (MASS), glm.nb (MASS)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
library(MASS)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74))
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

x.glm&lt;-glm(Observed~1+offset(log(sids$Expected)), data=sids, family=poisson())
x.nb&lt;-glm.nb(Observed~1+offset(log(Expected)), data=sids)

print(test.nb.pois(x.nb, x.glm))
print(DeanB(x.glm))
print(DeanB2(x.glm))

</code></pre>

<hr>
<h2 id='whittermore'>Whittermore's Statistic</h2><span id='topic+whittermore'></span>

<h3>Description</h3>

<p>Whittermore's statistic is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">W=\frac{n-1}{n}r^{'} D r</code>
</p>

<p>where <code class="reqn">r^{'}=[O_1/O_+, \ldots, O_n/O_+]</code>
and <code class="reqn">D</code> is a distance matrix between the centroids of the areas.
</p>
<p>It can be used to assess whether the region under study tends to cluster
or not.
</p>


<h3>References</h3>

<p>Whittermore, A. S. and Friend, N. and Byron, W. and Brown, J. R. and Holly, E. A. (1987). A test to detect clusters of disease. Biometrika 74, 631-635.
</p>


<h3>See Also</h3>

<p>DCluster, whittermore.stat, whittermore.boot, whittermore.pboot
</p>

<hr>
<h2 id='whittermore.boot'>Generate Bootstrap Replicates of Whittermore's Statistic</h2><span id='topic+whittermore.boot'></span><span id='topic+whittermore.pboot'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates of Whittermore's statistic by means of function
<em>boot</em> from <em>boot</em> library. Notice that these functions should not
be used separately but as argument <em>statistic</em> when calling function
<em>boot</em>.
</p>
<p><em>whittermore.boot</em> is used to perform a non-parametric bootstrap
</p>
<p><em>whittermore.pboot</em> is used when using parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whittermore.boot(data, i, ...)
whittermore.pboot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whittermore.boot_+3A_data">data</code></td>
<td>
<p>A dataframe with the data as explained in <em>DCluster</em>.</p>
</td></tr>
<tr><td><code id="whittermore.boot_+3A_i">i</code></td>
<td>
<p>Permutation generated by the non-parametric bootstrap procedure.</p>
</td></tr>
<tr><td><code id="whittermore.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed when performing a bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the value of the statistic.
</p>


<h3>References</h3>

<p>Whittermore, A. S. and Friend, N. and Byron, W. and Brown, J. R. and Holly, E. A. (1987). A test to detect clusters of disease. Biometrika 74, 631-635.
</p>


<h3>See Also</h3>

<p>DCluster, boot, whittermore, whittermore.stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(boot)
library(spdep)

data(nc.sids)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74) )
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#Calculate neighbours based on distance
coords&lt;-as.matrix(sids[,c("x", "y")])

dlist&lt;-dnearneigh(coords, 0, Inf)
dlist&lt;-include.self(dlist)
dlist.d&lt;-nbdists(dlist, coords)

#Calculate weights. They are globally standardised but it doesn't
#change significance.
col.W.whitt&lt;-nb2listw(dlist, glist=dlist.d, style="C")

niter&lt;-100

#Permutation model
wt.boot&lt;-boot(sids, statistic=whittermore.boot, R=niter, listw=col.W.whitt,
	zero.policy=TRUE)
plot(wt.boot)#Display results

#Multinomial model
wt.mboot&lt;-boot(sids, statistic=whittermore.pboot, sim="parametric", 
	ran.gen=multinom.sim,  R=niter,  listw=col.W.whitt, zero.policy=TRUE)
		
plot(wt.mboot)#Display results

#Poisson model
wt.pboot&lt;-boot(sids, statistic=whittermore.pboot, sim="parametric", 
	ran.gen=poisson.sim,  R=niter,  listw=col.W.whitt, zero.policy=TRUE)
		
plot(wt.pboot)#Display results

#Poisson-Gamma model
wt.pgboot&lt;-boot(sids, statistic=whittermore.pboot, sim="parametric", 
	ran.gen=negbin.sim, R=niter, listw=col.W.whitt, zero.policy=TRUE)
plot(wt.pgboot)#Display results
</code></pre>

<hr>
<h2 id='whittermore.stat'>Compute Whittermore's Statistic</h2><span id='topic+whittermore.stat'></span><span id='topic+whittermore.test'></span>

<h3>Description</h3>

<p>Compute Whittermore's statistic. See <em>whittermore</em> manual page
for more details.
</p>
<p>whittermore.stat computes the test statistic and the test using a hi-square
distribution whilst whittermore.test performs a bootstrap test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whittermore.stat(data, listw, zero.policy=FALSE)
whittermore.test(formula, data, model, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whittermore.stat_+3A_formula">formula</code></td>
<td>
<p>Formula that specifies the underlying model. The observed
cases are the response and the expected number of cases must be specified
as an offset in the log scale (see example below).  Note that now it
is not necessary to use Observed and Expected and that any other
names can be used to specify the observed and expected cases.
</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_model">model</code></td>
<td>
<p>Parametric model to be used in the bootstrap test. One of
&quot;param&quot;, &quot;multinom&quot;, &quot;poisson&quot; or &quot;negbin&quot;. See the <b>DCluster</b> manpage for
details.</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_...">...</code></td>
<td>
<p>The remaining arguments in 'whittermore.stat' not included in
'whittermore.test'. This is done so because whittermore.test calls whittermore.stat in order to perform the test.</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_r">R</code></td>
<td>
<p>Number of replicates used in the test to compute the significance of
the observed value of the test statistic.</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data, as specified in the
<b>DCluster</b> manpage.</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_listw">listw</code></td>
<td>
<p>Neighbours list with spatial weights created, for example,
by 'nb2listw' (package <em>spdep</em>).</p>
</td></tr>
<tr><td><code id="whittermore.stat_+3A_zero.policy">zero.policy</code></td>
<td>
<p>See <em>nb2listw</em> in package <em>spdep</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the statistic.
</p>


<h3>References</h3>

<p>Whittermore, A. S. and Friend, N. and Byron, W. and Brown, J. R. and Holly, E. A. (1987). A test to detect clusters of disease. Biometrika 74, 631-635.
</p>


<h3>See Also</h3>

<p>DCluster, whittermore, whittermore.boot, whittermore.pboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(nc.sids)
col.W &lt;- nb2listw(ncCR85.nb, zero.policy=TRUE)

sids&lt;-data.frame(Observed=nc.sids$SID74)
sids&lt;-cbind(sids, Expected=nc.sids$BIR74*sum(nc.sids$SID74)/sum(nc.sids$BIR74) )
sids&lt;-cbind(sids, x=nc.sids$x, y=nc.sids$y)

#Calculate neighbours based on distance
coords&lt;-as.matrix(sids[,c("x", "y")])

dlist&lt;-dnearneigh(coords, 0, Inf)
dlist&lt;-include.self(dlist)
dlist.d&lt;-nbdists(dlist, coords)

#Calculate weights. They are globally standardised but it doesn't
#change significance.
col.W.whitt&lt;-nb2listw(dlist, glist=dlist.d, style="C")


whittermore.stat(sids, col.W.whitt, zero.policy=TRUE)

whittermore.test(Observed~offset(log(Expected)), sids, model="poisson", R=99, 
   listw=col.W.whitt, zero.policy=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
