<!DOCTYPE html><html><head><title>Help for package lgarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lgarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lgarch-package'><p>Simulation and estimation of log-GARCH models</p></a></li>
<li><a href='#coef.lgarch'><p> Extraction methods for 'lgarch' objects</p></a></li>
<li><a href='#coef.mlgarch'><p> Extraction methods for 'mlgarch' objects</p></a></li>
<li><a href='#gdiff'><p> Difference a vector or a matrix, with special treatment of zoo objects</p></a></li>
<li><a href='#glag'><p> Lag a vector or a matrix, with special treatment of zoo objects</p></a></li>
<li><a href='#lgarch'><p> Estimate a log-GARCH model</p></a></li>
<li><a href='#lgarchObjective'><p>Auxiliary functions</p></a></li>
<li><a href='#lgarchSim'><p> Simulate from a univariate log-GARCH model</p></a></li>
<li><a href='#mlgarch'><p> Estimate a multivariate CCC-log-GARCH(1,1) model</p></a></li>
<li><a href='#mlgarchObjective'><p>Auxiliary functions</p></a></li>
<li><a href='#mlgarchSim'><p> Simulate from a multivariate log-GARCH(1,1) model</p></a></li>
<li><a href='#rmnorm'>
<p>Random number generation from the multivariate normal distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Estimation of Log-GARCH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), zoo</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-09-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Genaro Sucarrat</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Genaro Sucarrat &lt;genaro.sucarrat@bi.no&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and estimation of univariate and multivariate log-GARCH models. The main functions of the package are: lgarchSim(), mlgarchSim(), lgarch() and mlgarch(). The first two functions simulate from a univariate and a multivariate log-GARCH model, respectively, whereas the latter two estimate a univariate and multivariate log-GARCH model, respectively.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-15 14:53:03 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-15 19:46:40</td>
</tr>
</table>
<hr>
<h2 id='lgarch-package'>Simulation and estimation of log-GARCH models</h2><span id='topic+lgarch-package'></span>

<h3>Description</h3>

<p>This package provides facilities for the simulation and estimation of univariate log-GARCH models, and for the multivariate CCC-log-GARCH(1,1) model, see Sucarrat, Gronneberg and Escribano (2013), Sucarrat and Escribano (2013), and Francq and Sucarrat (2013).<br />
</p>
<p>Let y[t] denote a financial return or the error of a regression at time t such that
</p>
<p>y[t] = sigma[t]*z[t],
</p>
<p>where sigma[t] &gt; 0 is the conditional standard deviation or volatility at t, and where z[t] is an IID innovation with mean zero and unit variance. The log-volatility specifiction of the log-GARCH-X model is given by
</p>
<p>ln sigma[t]^2 = intercept + Sum_i alpha_i * ln y[t-i]^2 + Sum_j beta_j *ln sigma[t-1]^2 + Sum_k lambda_k * x[t]_k,<br />
</p>
<p>where the conditioning x-variables can be contemporaneous and/or lagged. The lgarch package estimates this model via its ARMA-X representation, see Sucarrat, Gronneberg and Escribano (2013), and treats zeros on y as missing values, see Sucarrat and Escribano (2013).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lgarch</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-09-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main functions of the package are: <code><a href="#topic+lgarchSim">lgarchSim</a></code>, <code><a href="#topic+mlgarchSim">mlgarchSim</a></code>, <code><a href="#topic+lgarch">lgarch</a></code> and <code><a href="#topic+mlgarch">mlgarch</a></code>. The first two functions simulate from a univariate and a multivariate log-GARCH model, respectively, whereas the latter two estimate a univariate and a multivariate log-GARCH model, respectively.
</p>
<p>The lgarch and mlgarch functions return an object (a list) of class 'lgarch' and 'mlgarch', respectively. In both cases a collection of methods can be applied to each of them: coef, fitted, logLik, print, residuals, summary and vcov. In addition, the function <code><a href="#topic+rss">rss</a></code> can be used to extract the Residual Sum of Squares of the estimated ARMA representation from an lgarch object.
</p>
<p>The output produced by the <code><a href="#topic+lgarchSim">lgarchSim</a></code> and <code><a href="#topic+mlgarchSim">mlgarchSim</a></code> functions, and by the fitted and residuals methods, are of the Z's ordered observations (<code><a href="zoo.html#topic+zoo">zoo</a></code>) class, see Zeileis and Grothendieck (2005), and Zeileis, Grothendieck and Ryan (2014). This means a range of time-series and plotting methods are available for these objects.
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Francq, C. and G. Sucarrat (2013), 'An Exponential Chi-Squared QMLE for Log-GARCH Models via the ARMA Representation', MPRA Paper 51783: <a href="http://mpra.ub.uni-muenchen.de/51783/">http://mpra.ub.uni-muenchen.de/51783/</a> <br />
</p>
<p>Sucarrat, G. and A. Escribano (2013), 'Unbiased QML Estimation of Log-GARCH Models in the Presence of Zero Returns', MPRA Paper 50699: <a href="http://mpra.ub.uni-muenchen.de/50699/">http://mpra.ub.uni-muenchen.de/50699/</a> <br />
</p>
<p>Sucarrat, G., S. Gronneberg and A. Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a> <br />
</p>
<p>Zeileis, A. and G. Grothendieck (2005), 'zoo: S3 Infrastructure for Regular and Irregular Time Series', Journal of Statistical Software 14, pp. 1-27 <br />
</p>
<p>Zeileis, A., G. Grothendieck, J.A. Ryan and F. Andrews(2014), 'zoo: S3 Infrastructure for Regular and Irregular Time Series (Z's ordered observations)', R package version 1.7-11, http://CRAN.R-project.org/package=zoo/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgarchSim">lgarchSim</a></code>, <code><a href="#topic+mlgarchSim">mlgarchSim</a></code>, <code><a href="#topic+lgarch">lgarch</a></code>, <code><a href="#topic+mlgarch">mlgarch</a></code>, <code><a href="#topic+coef.lgarch">coef.lgarch</a></code>, <code><a href="#topic+coef.mlgarch">coef.mlgarch</a></code>, <code><a href="#topic+fitted.lgarch">fitted.lgarch</a></code>, <br />
<code><a href="#topic+fitted.mlgarch">fitted.mlgarch</a></code>, <code><a href="#topic+logLik.lgarch">logLik.lgarch</a></code>, <code><a href="#topic+logLik.mlgarch">logLik.mlgarch</a></code>, <code><a href="#topic+print.lgarch">print.lgarch</a></code>, <code><a href="#topic+print.mlgarch">print.mlgarch</a></code>, <br />
<code><a href="#topic+residuals.lgarch">residuals.lgarch</a></code>, <code><a href="#topic+residuals.mlgarch">residuals.mlgarch</a></code>, <code><a href="#topic+rss">rss</a></code>, <code><a href="#topic+summary.mlgarch">summary.mlgarch</a></code>, <code><a href="#topic+summary.mlgarch">summary.mlgarch</a></code>, <code><a href="#topic+vcov.lgarch">vcov.lgarch</a></code>, <br />
<code><a href="#topic+vcov.mlgarch">vcov.mlgarch</a></code> and <code><a href="zoo.html#topic+zoo">zoo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 500 observations w/default parameter values from
##a univariate log-garch(1,1):
set.seed(123)
y &lt;- lgarchSim(500)

##estimate a log-garch(1,1):
mymod &lt;- lgarch(y)

##print results:
print(mymod)

##extract coefficients:
coef(mymod)

##extract Gaussian log-likelihood (zeros excluded, if any) of the log-garch model:
logLik(mymod)

##extract Gaussian log-likelihood (zeros excluded, if any) of the arma representation:
logLik(mymod, arma=TRUE)

##extract variance-covariance matrix:
vcov(mymod)

##extract and plot the fitted conditional standard deviation:
sdhat &lt;- fitted(mymod)
plot(sdhat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod)
plot(zhat)

##extract and plot all the fitted series:
myhat &lt;- fitted(mymod, verbose=TRUE)
plot(myhat)

##simulate 1000 observations from a two-dimensional
##ccc-log-garch(1,1) w/default parameter values:
set.seed(123)
yy &lt;- mlgarchSim(1000)

##estimate a 2-dimensional ccc-log-garch(1,1):
myymod &lt;- mlgarch(yy)

##print results:
print(myymod)

</code></pre>

<hr>
<h2 id='coef.lgarch'> Extraction methods for 'lgarch' objects </h2><span id='topic+coef.lgarch'></span><span id='topic+fitted.lgarch'></span><span id='topic+logLik.lgarch'></span><span id='topic+print.lgarch'></span><span id='topic+rss'></span><span id='topic+residuals.lgarch'></span><span id='topic+summary.lgarch'></span><span id='topic+vcov.lgarch'></span>

<h3>Description</h3>

<p>Extraction methods for objects of class 'lgarch' (i.e. the result of estimating a log-GARCH model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgarch'
coef(object, arma = FALSE, ...)
## S3 method for class 'lgarch'
fitted(object, verbose = FALSE, ...)
## S3 method for class 'lgarch'
logLik(object, arma = FALSE, ...)
## S3 method for class 'lgarch'
print(x, arma = FALSE, ...)
## informal method for class 'lgarch'
rss(object, ...)
## S3 method for class 'lgarch'
residuals(object, arma = FALSE, ...)
## S3 method for class 'lgarch'
summary(object, ...)
## S3 method for class 'lgarch'
vcov(object, arma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lgarch_+3A_object">object</code></td>
<td>
<p>an object of class 'lgarch'</p>
</td></tr>
<tr><td><code id="coef.lgarch_+3A_x">x</code></td>
<td>
<p>an object of class 'lgarch'</p>
</td></tr>
<tr><td><code id="coef.lgarch_+3A_verbose">verbose</code></td>
<td>
<p>logical. If FALSE (default), then only basic information is returned</p>
</td></tr>
<tr><td><code id="coef.lgarch_+3A_arma">arma</code></td>
<td>
<p>logical. If FALSE (default), then information relating to the log-garch model is returned. If TRUE, then information relating to the ARMA representation is returned</p>
</td></tr>
<tr><td><code id="coef.lgarch_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The rss function is not a formal S3 method.</p>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>A numeric vector containing the parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> object. If verbose = FALSE (default), then the zoo object is a vector containing the fitted conditional standard deviations. If verbose = TRUE, then the zoo object is a matrix containing the conditional standard deviations and additional information</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>The value of the log-likelihood (contributions at zeros excluded) at the maximum</p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>Prints the most important parts of the estimation results</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> object with the residuals. If arma = FALSE (default), then the standardised residuals are returned. If arma = TRUE, then the residuals of the ARMA representation is returned</p>
</td></tr>
<tr><td><code>rss:</code></td>
<td>
<p>A numeric; the Residual Sum of Squares of the ARMA representation</p>
</td></tr>
<tr><td><code>summary:</code></td>
<td>
<p>A print of the items in the <code><a href="#topic+lgarch">lgarch</a></code> object</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>The variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+lgarch">lgarch</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 500 observations w/default parameter values:
set.seed(123)
y &lt;- lgarchSim(500)

##estimate a log-garch(1,1):
mymod &lt;- lgarch(y)

##print results:
print(mymod)

##extract coefficients:
coef(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the log-garch model:
logLik(mymod)

##extract the Residual Sum of Squares of the ARMA representation:
rss(mymod)

##extract log-likelihood (zeros excluded) of the ARMA representation:
logLik(mymod, arma=TRUE)

##extract variance-covariance matrix:
vcov(mymod)

##extract and plot the fitted conditional standard deviation:
sdhat &lt;- fitted(mymod)
plot(sdhat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod)
plot(zhat)

##extract and plot all the fitted series:
myhat &lt;- fitted(mymod, verbose=TRUE)
plot(myhat)

</code></pre>

<hr>
<h2 id='coef.mlgarch'> Extraction methods for 'mlgarch' objects </h2><span id='topic+coef.mlgarch'></span><span id='topic+fitted.mlgarch'></span><span id='topic+logLik.mlgarch'></span><span id='topic+print.mlgarch'></span><span id='topic+residuals.mlgarch'></span><span id='topic+summary.mlgarch'></span><span id='topic+vcov.mlgarch'></span>

<h3>Description</h3>

<p>Extraction methods for objects of class 'mlgarch' (i.e. the result of estimating a multivariate CCC-log-GARCH model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlgarch'
coef(object, varma = FALSE, ...)
## S3 method for class 'mlgarch'
fitted(object, varma = FALSE, verbose = FALSE, ...)
## S3 method for class 'mlgarch'
logLik(object, varma = FALSE, ...)
## S3 method for class 'mlgarch'
print(x, varma = FALSE, ...)
## S3 method for class 'mlgarch'
residuals(object, varma = FALSE, ...)
## S3 method for class 'mlgarch'
summary(object, ...)
## S3 method for class 'mlgarch'
vcov(object, varma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mlgarch_+3A_object">object</code></td>
<td>
<p>an object of class 'mlgarch'</p>
</td></tr>
<tr><td><code id="coef.mlgarch_+3A_x">x</code></td>
<td>
<p>an object of class 'mlgarch'</p>
</td></tr>
<tr><td><code id="coef.mlgarch_+3A_verbose">verbose</code></td>
<td>
<p>logical. If FALSE (default), then only basic information is returned</p>
</td></tr>
<tr><td><code id="coef.mlgarch_+3A_varma">varma</code></td>
<td>
<p>logical. If FALSE (default), then information relating to the multivariate CCC-log-GARCH model is returned. If TRUE, then information relating to the VARMA representation is returned</p>
</td></tr>
<tr><td><code id="coef.mlgarch_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empty</p>


<h3>Value</h3>

<table>
<tr><td><code>coef:</code></td>
<td>
<p>A numeric vector containing the parameter estimates</p>
</td></tr>
<tr><td><code>fitted:</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> object (a matrix). If verbose = FALSE (default), then the zoo object contains the fitted conditional standard deviations of each equation. If verbose = TRUE, then the zoo object also contains additional information</p>
</td></tr>
<tr><td><code>logLik:</code></td>
<td>
<p>The value of the log-likelihood (contributions at zeros excluded) at the maximum</p>
</td></tr>
<tr><td><code>print:</code></td>
<td>
<p>Prints the most important parts of the estimation results</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> object (a matrix) with the residuals. If varma = FALSE (default), then the standardised residuals are returned. If varma = TRUE, then the residuals of the VARMA representation is returned</p>
</td></tr>
<tr><td><code>summary:</code></td>
<td>
<p>A print of the items in the <code><a href="#topic+mlgarch">mlgarch</a></code> object</p>
</td></tr>
<tr><td><code>vcov:</code></td>
<td>
<p>The variance-covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlgarch">mlgarch</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 1000 observations from 2-dimensional model w/default parameter values:
set.seed(123)
y &lt;- mlgarchSim(1000)

##estimate a 2-dimensional ccc-log-garch(1,1):
mymod &lt;- mlgarch(y)

##print results:
print(mymod)

##extract ccc-log-garch coefficients:
coef(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the ccc-log-garch model:
logLik(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the varma representation:
logLik(mymod, varma=TRUE)

##extract variance-covariance matrix:
vcov(mymod)

##extract and plot the fitted conditional standard deviations:
sdhat &lt;- fitted(mymod)
plot(sdhat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod)
plot(zhat)

</code></pre>

<hr>
<h2 id='gdiff'> Difference a vector or a matrix, with special treatment of zoo objects</h2><span id='topic+gdiff'></span>

<h3>Description</h3>

<p>Similar to the <code><a href="base.html#topic+diff">diff</a></code> function from the base package, but gdiff enables padding (e.g. NAs or 0s) of the lost entries. Contrary to the <code><a href="base.html#topic+diff">diff</a></code> function in the base package, however, the default in gdiff is to pad (with NAs). The gdiff function is particularly suited for zoo objects, since their indexing is retained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdiff(x, lag = 1, pad = TRUE, pad.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdiff_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="gdiff_+3A_lag">lag</code></td>
<td>
<p>integer equal to the difference-length (the default is 1)</p>
</td></tr>
<tr><td><code id="gdiff_+3A_pad">pad</code></td>
<td>
<p>logical. If TRUE (default), then the lost entries are padded with pad.value. If FALSE, then no padding is undertaken</p>
</td></tr>
<tr><td><code id="gdiff_+3A_pad.value">pad.value</code></td>
<td>
<p>numeric. The pad-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the differenced values</p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code>, <code><a href="#topic+glag">glag</a></code>, <code><a href="stats.html#topic+lag">lag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##1st difference of a series:
x &lt;- rnorm(5)
gdiff(x)

##1st difference with no padding:
gdiff(x, pad=FALSE)

##1st difference retaining the original zoo-index ordering:
gdiff(as.zoo(x))

##1st difference of a matrix:
y &lt;- matrix(rnorm(8),4,2)
gdiff(y)

##2nd difference of the same matrix:
gdiff(y, lag=2)

</code></pre>

<hr>
<h2 id='glag'> Lag a vector or a matrix, with special treatment of zoo objects</h2><span id='topic+glag'></span>

<h3>Description</h3>

<p>Similar to the <code><a href="stats.html#topic+lag">lag</a></code> function from the stats package, but glag enables padding (e.g. NAs or 0s) of the lost entries. Contrary to the <code><a href="stats.html#topic+lag">lag</a></code> function in the stats package, however, the default in glag is to pad (with NAs). The glag is particularly suited for zoo objects, since their indexing is retained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glag(x, k = 1, pad = TRUE, pad.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glag_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="glag_+3A_k">k</code></td>
<td>
<p>integer equal to the lag (the default is 1)</p>
</td></tr>
<tr><td><code id="glag_+3A_pad">pad</code></td>
<td>
<p>logical. If TRUE (default), then the lost entries are padded with pad.value. If FALSE, then no padding is undertaken</p>
</td></tr>
<tr><td><code id="glag_+3A_pad.value">pad.value</code></td>
<td>
<p>the pad-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the lagged values</p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lag">lag</a></code>, <code><a href="#topic+gdiff">gdiff</a></code>, <code><a href="base.html#topic+diff">diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##lag series with NA for the missing entries:
x &lt;- rnorm(5)
glag(x)

##lag series with no padding:
x &lt;- rnorm(5)
glag(x, pad=FALSE)

##lag series and retain the original zoo-index ordering:
x &lt;- as.zoo(rnorm(5))
glag(x)

##lag two periods:
glag(x, k=2)

</code></pre>

<hr>
<h2 id='lgarch'> Estimate a log-GARCH model </h2><span id='topic+lgarch'></span>

<h3>Description</h3>

<p>Fit a log-GARCH model by either (nonlinear) Least Squares (LS) or Quasi Maximum Likelihood (QML) via the ARMA representation. For QML either the Gaussian or centred exponential chi-squared distribution can be used as instrumental density, see Sucarrat, Gronneberg and Escribano (2013), and Francq and Sucarrat (2013). Zero-values on the dependent variable y are treated as missing values, as suggested in Sucarrat and Escribano (2013). Estimation is via the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function, whereas a numerical estimate of the Hessian is obtained with <code><a href="stats.html#topic+optimHess">optimHess</a></code> for the computation of the variance-covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgarch(y, arch = 1, garch = 1, xreg = NULL, initial.values = NULL,
  lower = NULL, upper = NULL, nlminb.control = list(), vcov = TRUE,
  method=c("ls","ml","cex2"), mean.correction=FALSE,
  objective.penalty = NULL, solve.tol = .Machine$double.eps,
  c.code = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgarch_+3A_y">y</code></td>
<td>
<p>numeric vector, typically a financial return series or the error of a regression</p>
</td></tr>
<tr><td><code id="lgarch_+3A_arch">arch</code></td>
<td>
<p>the arch order (i.e. an integer equal to or greater than 0). The default is 1. NOTE: in the current version the order canno be greater than 1</p>
</td></tr>
<tr><td><code id="lgarch_+3A_garch">garch</code></td>
<td>
<p>the garch order (i.e. an integer equal to or greater than 0). The default is 1. NOTE: in the current version the order canno be greater than 1</p>
</td></tr>
<tr><td><code id="lgarch_+3A_xreg">xreg</code></td>
<td>
<p>vector or matrix with conditioning variables</p>
</td></tr>
<tr><td><code id="lgarch_+3A_initial.values">initial.values</code></td>
<td>
<p>NULL (default) or a vector with the initial values of the ARMA-representation</p>
</td></tr>
<tr><td><code id="lgarch_+3A_lower">lower</code></td>
<td>
<p>NULL (default) or a vector with the lower bounds of the parameter space (of the ARMA-representation). If NULL, then the values are automatically chosen</p>
</td></tr>
<tr><td><code id="lgarch_+3A_upper">upper</code></td>
<td>
<p>NULL (default) or a vector with the upper bounds of the parameter space (of the ARMA-representation). If NULL, then the values are automatically chosen</p>
</td></tr>
<tr><td><code id="lgarch_+3A_nlminb.control">nlminb.control</code></td>
<td>
<p>list of control options passed on to the <code><a href="stats.html#topic+nlminb">nlminb</a></code> optimiser</p>
</td></tr>
<tr><td><code id="lgarch_+3A_vcov">vcov</code></td>
<td>
<p>logical. If TRUE (default), then the variance-covariance matrix is computed. The FALSE options makes estimation faster, but the variance-covariance matrix cannot be extracted subsequently</p>
</td></tr>
<tr><td><code id="lgarch_+3A_method">method</code></td>
<td>
<p>Estimation method to use. Either &quot;ls&quot;, i.e. Nonlinear Least Squares (default), &quot;ml&quot;, i.e. Gaussian QML or &quot;cex2&quot;, i.e. Centred exponential Chi-squared QML, see Francq and Sucarrat (2013). Note: For the cex2 method mean-correction = FALSE is not available</p>
</td></tr>
<tr><td><code id="lgarch_+3A_mean.correction">mean.correction</code></td>
<td>
<p>Whether to mean-correct the ARMA representation. Mean-correction is usually faster, but not always recommended if covariates are added (i.e. if xreg is not NULL)</p>
</td></tr>
<tr><td><code id="lgarch_+3A_objective.penalty">objective.penalty</code></td>
<td>
<p>NULL (default) or a numeric value. If NULL, then the log-likelihood value associated with the initial values is used. Sometimes estimation can result in NA and/or +/-Inf values (this can be fatal for simulations). The value objective.penalty is the value returned by the objective function <code><a href="#topic+lgarchObjective">lgarchObjective</a></code> in the presence of NA or +/-Inf values</p>
</td></tr>
<tr><td><code id="lgarch_+3A_solve.tol">solve.tol</code></td>
<td>
<p>The function <code><a href="Matrix.html#topic+solve">solve</a></code> is used for the inversion of the negative of the Hessian in computing the variance-covariance matrix. The value solve.tol is passed on to <code><a href="Matrix.html#topic+solve">solve</a></code>, and is the tolerance for detecting linear dependencies in the columns</p>
</td></tr>
<tr><td><code id="lgarch_+3A_c.code">c.code</code></td>
<td>
<p>logical. TRUE (default) is (much) faster, since it makes use of compiled C-code in the recursions</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list of class 'lgarch' </p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Francq, C. and G. Sucarrat (2013), 'An Exponential Chi-Squared QMLE for Log-GARCH Models via the ARMA Representation', MPRA Paper 51783: <a href="http://mpra.ub.uni-muenchen.de/51783/">http://mpra.ub.uni-muenchen.de/51783/</a> <br />
</p>
<p>Sucarrat and Escribano (2013), 'Unbiased QML Estimation of Log-GARCH Models in the Presence of Zero Returns', MPRA Paper 50699: <a href="http://mpra.ub.uni-muenchen.de/50699/">http://mpra.ub.uni-muenchen.de/50699/</a> <br />
</p>
<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgarchSim">lgarchSim</a></code>, <code><a href="#topic+coef.lgarch">coef.lgarch</a></code>, <code><a href="#topic+fitted.lgarch">fitted.lgarch</a></code>, <code><a href="#topic+logLik.lgarch">logLik.lgarch</a></code>, <code><a href="#topic+print.lgarch">print.lgarch</a></code>, <code><a href="#topic+residuals.lgarch">residuals.lgarch</a></code> and <code><a href="#topic+vcov.lgarch">vcov.lgarch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 500 observations w/default parameter values:
set.seed(123)
y &lt;- lgarchSim(500)

##estimate a log-garch(1,1) w/least squares:
mymod &lt;- lgarch(y)

##estimate the same model, but w/cex2 method:
mymod2 &lt;- lgarch(y, method="cex2")

##print results:
print(mymod); print(mymod2)

##extract coefficients:
coef(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the log-garch model:
logLik(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the arma representation:
logLik(mymod, arma=TRUE)

##extract variance-covariance matrix:
vcov(mymod)

##extract and plot the fitted conditional standard deviation:
sdhat &lt;- fitted(mymod)
plot(sdhat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod)
plot(zhat)

##extract and plot all the fitted series:
myhat &lt;- fitted(mymod, verbose=TRUE)
plot(myhat)
</code></pre>

<hr>
<h2 id='lgarchObjective'>Auxiliary functions</h2><span id='topic+lgarchObjective'></span><span id='topic+lgarchRecursion1'></span>

<h3>Description</h3>

<p>lgarchObjective and lgarchRecursion1 are auxiliary functions called by <code><a href="#topic+lgarch">lgarch</a></code>. The functions are not intended for the average user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgarchObjective(pars, aux)
lgarchRecursion1(pars, aux)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgarchObjective_+3A_pars">pars</code></td>
<td>
<p>numeric vector with the parameters of the ARMA representation</p>
</td></tr>
<tr><td><code id="lgarchObjective_+3A_aux">aux</code></td>
<td>
<p>auxiliary list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To understand the structure and content of pars and aux, see the source code of the <code><a href="#topic+lgarch">lgarch</a></code> function</p>


<h3>Value</h3>

<p>lgarchObjective returns the value of the objective function (either the log-likelihood or the residual sum of squares) used in estimating the ARMA representation. lgarchRecursion1 returns the residuals of the ARMA representation associated with the ARMA parameters pars
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Francq, C. and G. Sucarrat (2013), 'An Exponential Chi-Squared QMLE for Log-GARCH Models via the ARMA Representation', MPRA Paper 51783: <a href="http://mpra.ub.uni-muenchen.de/51783/">http://mpra.ub.uni-muenchen.de/51783/</a> <br />
</p>
<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+lgarch">lgarch</a></code> </p>

<hr>
<h2 id='lgarchSim'> Simulate from a univariate log-GARCH model </h2><span id='topic+lgarchSim'></span>

<h3>Description</h3>

<p>Simulate the y series (typically a financial return or the error in a regression) from a log-GARCH model. Optionally, the conditional standard deviation, the standardised error (z) and their logarithmic transformations are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgarchSim(n, constant = 0, arch = 0.05, garch = 0.9, xreg = NULL,
  backcast.values = list(lnsigma2 = NULL, lnz2 = NULL, xreg = NULL),
  check.stability = TRUE, innovations = NULL, verbose = FALSE,
  c.code=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgarchSim_+3A_n">n</code></td>
<td>
<p>integer, length of y (i.e. number of observations)</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_constant">constant</code></td>
<td>
<p>the value of the intercept in the log-volatility specification</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_arch">arch</code></td>
<td>
<p>numeric vector with the arch coefficients</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_garch">garch</code></td>
<td>
<p>numeric vector with the garch coefficients</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_xreg">xreg</code></td>
<td>
<p>numeric vector (of length n) with the conditioning values</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_backcast.values">backcast.values</code></td>
<td>
<p>backcast values for the recursion (chosen automatically if NULL)</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_check.stability">check.stability</code></td>
<td>
<p>logical. If TRUE (default), then the roots of arch+garch are checked for stability</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_innovations">innovations</code></td>
<td>
<p>Etiher NULL (default) or a vector of length n with the standardised errors (i.e. z). If NULL, then the innovations are normal with mean zero and unit variance</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_verbose">verbose</code></td>
<td>
<p>logical. If FALSE (default), then only the vector y is returned. If TRUE, then a matrix with all the output is returned</p>
</td></tr>
<tr><td><code id="lgarchSim_+3A_c.code">c.code</code></td>
<td>
<p>logical. If TRUE (default), then compiled C-code is used for the recursion (faster)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empty</p>


<h3>Value</h3>

<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> vector of length n if verbose = FALSE (default), or a <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix with n rows if verbose = TRUE.
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a> <br />
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlgarchSim">mlgarchSim</a></code>, <code><a href="#topic+lgarch">lgarch</a></code>, <code><a href="#topic+mlgarch">mlgarch</a></code> and <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 500 observations w/default parameter values:
set.seed(123)
y &lt;- lgarchSim(500)

##simulate the same series, but with more output:
set.seed(123)
y &lt;- lgarchSim(500, verbose=TRUE)
head(y)

##plot the simulated values:
plot(y)

##simulate w/conditioning variable:
x &lt;- rnorm(500)
y &lt;- lgarchSim(500, xreg=0.05*x)

##simulate from a log-GARCH with a simple form of leverage:
z &lt;- rnorm(500)
zneg &lt;- as.numeric(z &lt; 0)
zneglagged &lt;- glag(zneg, pad=TRUE, pad.value=0)
y &lt;- lgarchSim(500, xreg=0.05*zneglagged, innovations=z)

##simulate from a log-GARCH w/standardised t-innovations:
set.seed(123)
n &lt;- 500
df &lt;- 5
z &lt;- rt(n, df=df)/sqrt(df/(df-2))
y &lt;- lgarchSim(n, innovations=z)

</code></pre>

<hr>
<h2 id='mlgarch'> Estimate a multivariate CCC-log-GARCH(1,1) model </h2><span id='topic+mlgarch'></span>

<h3>Description</h3>

<p>Fit a multivariate Constant Conditional Correlation (CCC) log-GARCH(1,1) model with multivariate Gaussian Quasi Maximum Likelihood (QML) via the VARMA representation, see Sucarrat, Gronneberg and Escribano (2013). Zero-values on y are treated as missing values, as suggested in Sucarrat and Escribano (2013). Estimation is via the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function, whereas a numerical estimate of the Hessian is obtained with <code><a href="stats.html#topic+optimHess">optimHess</a></code> for the computation of the variance-covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlgarch(y, arch = 1, garch = 1, xreg = NULL, initial.values = NULL,
  lower = NULL, upper = NULL, nlminb.control = list(), vcov = TRUE,
  objective.penalty = NULL, solve.tol = .Machine$double.eps, c.code = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlgarch_+3A_y">y</code></td>
<td>
<p>a numeric matrix, typically financial returns or regression errors</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_arch">arch</code></td>
<td>
<p>the arch order (i.e. an integer equal to or greater than 0). The default is 1. NOTE: in the current version the order cannot be greater than 1</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_garch">garch</code></td>
<td>
<p>the garch order (i.e. an integer equal to or greater than 0). The default is 1. NOTE: in the current version the order cannot be greater than 1</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_xreg">xreg</code></td>
<td>
<p>a vector or a matrix with the conditioning variables. The x-variables enter in each of the equations</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_initial.values">initial.values</code></td>
<td>
<p>NULL (default) or a vector with the initial values of the VARMA representation</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_lower">lower</code></td>
<td>
<p>NULL (default) or a vector with the lower bounds of the parameter space (of the VARMA representation). If NULL, then the values are automatically chosen</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_upper">upper</code></td>
<td>
<p>NULL (default) or a vector with the upper bounds of the parameter space (of the VARMA representation). If NULL, then the values are automatically chosen</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_nlminb.control">nlminb.control</code></td>
<td>
<p>list of control options passed on to the <code><a href="stats.html#topic+nlminb">nlminb</a></code> optimiser</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_vcov">vcov</code></td>
<td>
<p>logical. If TRUE (default), then the variance-covariance matrix is computed. The FALSE options makes estimation faster, but the variance-covariance matrix cannot be extracted subsequently</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_objective.penalty">objective.penalty</code></td>
<td>
<p>NULL (default) or a numeric value. If NULL, then the log-likelihood value associated with the initial values is used. Sometimes estimation can result in NA and/or +/-Inf values (this can be fatal for simulations). The value objective.penalty is the value returned by the log-likelihood function <code><a href="#topic+lgarchObjective">lgarchObjective</a></code> in the presence of NA or +/-Inf values</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_solve.tol">solve.tol</code></td>
<td>
<p>The function <code><a href="Matrix.html#topic+solve">solve</a></code> is used for the inversion of the Hessian in computing the variance-covariance matrix. The value solve.tol is passed on to <code><a href="Matrix.html#topic+solve">solve</a></code>, and is the tolerance for detecting linear dependencies in the columns</p>
</td></tr>
<tr><td><code id="mlgarch_+3A_c.code">c.code</code></td>
<td>
<p>logical. TRUE (default) is (much) faster, since it makes use of compiled C-code</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list of class 'mlgarch' </p>


<h3>Note</h3>

<p>Empty</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Sucarrat and Escribano (2013), 'Unbiased QML Estimation of Log-GARCH Models in the Presence of Zero Returns', MPRA Paper 50699: <a href="http://mpra.ub.uni-muenchen.de/50699/">http://mpra.ub.uni-muenchen.de/50699/</a> <br />
</p>
<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgarchSim">lgarchSim</a></code>, <code><a href="#topic+coef.lgarch">coef.lgarch</a></code>, <code><a href="#topic+fitted.lgarch">fitted.lgarch</a></code>, <code><a href="#topic+logLik.lgarch">logLik.lgarch</a></code>, <code><a href="#topic+print.lgarch">print.lgarch</a></code>, <code><a href="#topic+residuals.lgarch">residuals.lgarch</a></code> and <code><a href="#topic+vcov.lgarch">vcov.lgarch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 1000 observations from a 2-dimensional
##ccc-log-garch(1,1) w/default parameter values:
set.seed(123)
y &lt;- mlgarchSim(1000)

##estimate a 2-dimensional ccc-log-garch(1,1):
mymod &lt;- mlgarch(y)

##print results:
print(mymod)

##extract ccc-log-garch coefficients:
coef(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the ccc-log-garch model:
logLik(mymod)

##extract Gaussian log-likelihood (zeros excluded) of the varma representation:
logLik(mymod, varma=TRUE)

##extract variance-covariance matrix:
vcov(mymod)

##extract and plot the fitted conditional standard deviations:
sdhat &lt;- fitted(mymod)
plot(sdhat)

##extract and plot standardised residuals:
zhat &lt;- residuals(mymod)
plot(zhat)
</code></pre>

<hr>
<h2 id='mlgarchObjective'>Auxiliary functions</h2><span id='topic+mlgarchObjective'></span><span id='topic+mlgarchRecursion1'></span>

<h3>Description</h3>

<p>mlgarchObjective and mlgarchRecursion1 are auxiliary functions called by <code><a href="#topic+mlgarch">mlgarch</a></code>. The functions are not intended for the average user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlgarchObjective(pars, aux)
mlgarchRecursion1(pars, aux)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlgarchObjective_+3A_pars">pars</code></td>
<td>
<p>numeric vector of VARMA parameters</p>
</td></tr>
<tr><td><code id="mlgarchObjective_+3A_aux">aux</code></td>
<td>
<p>auxiliary list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To understand the structure and content of pars and aux, see the source code of the <code><a href="#topic+mlgarch">mlgarch</a></code> function</p>


<h3>Value</h3>

<p>mlgarchObjective returns the log-likelihood of the VARMA representation, whereas mlgarchRecursion1 returns the residuals of the VARMA representation associated with the VARMA parameters pars
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlgarch">mlgarch</a></code> and <code><a href="#topic+lgarchObjective">lgarchObjective</a></code> </p>

<hr>
<h2 id='mlgarchSim'> Simulate from a multivariate log-GARCH(1,1) model </h2><span id='topic+mlgarchSim'></span>

<h3>Description</h3>

<p>Simulate the y series (typically a collection of financial returns or regression errors) from a log-GARCH model. Optionally, the conditional standard deviation and the standardised error, together with their logarithmic transformations, are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlgarchSim(n, constant = c(0,0), arch = diag(c(0.1, 0.05)),
  garch = diag(c(0.7, 0.8)), xreg = NULL,
  backcast.values = list(lnsigma2 = NULL, lnz2 = NULL, xreg = NULL),
  innovations = NULL, innovations.vcov = diag(rep(1,
  length(constant))), check.stability = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlgarchSim_+3A_n">n</code></td>
<td>
<p>integer, i.e. number of observations</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_constant">constant</code></td>
<td>
<p>vector with the values of the intercepts in the log-volatility specification</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_arch">arch</code></td>
<td>
<p>matrix with the arch coefficients</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_garch">garch</code></td>
<td>
<p>matrix with the garch coefficients</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_xreg">xreg</code></td>
<td>
<p>a vector (of length n) or matrix (with rows n) with the values of the conditioning variables. The first column enters the first equation, the second enters the second equation, and so on</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_backcast.values">backcast.values</code></td>
<td>
<p>backcast values for the recursion (chosen automatically if NULL)</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_check.stability">check.stability</code></td>
<td>
<p>logical. If TRUE (default), then the system is checked for stability</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_innovations">innovations</code></td>
<td>
<p>Either NULL (default) or a vector or matrix of length n with the standardised errors. If NULL, then the innovations are multivariate N(0,1) with correlations equal to zero</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_innovations.vcov">innovations.vcov</code></td>
<td>
<p>numeric matrix, the variance-covariance matrix of the standardised multivariate normal innovations. Only applicable if innovations = NULL</p>
</td></tr>
<tr><td><code id="mlgarchSim_+3A_verbose">verbose</code></td>
<td>
<p>logical. If FALSE (default), then only the matrix with the y series is returned. If TRUE, then also additional information is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empty</p>


<h3>Value</h3>

<p>A <code><a href="zoo.html#topic+zoo">zoo</a></code> matrix with n rows.
</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Sucarrat, Gronneberg and Escribano (2013), 'Estimation and Inference in Univariate and Multivariate Log-GARCH-X Models When the Conditional Density is Unknown', MPRA Paper 49344: <a href="http://mpra.ub.uni-muenchen.de/49344/">http://mpra.ub.uni-muenchen.de/49344/</a> <br />
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+lgarchSim">lgarchSim</a></code>, <code><a href="#topic+mlgarch">mlgarch</a></code> and <code><a href="zoo.html#topic+zoo">zoo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate 1000 observations from a multivariate
##ccc-log-garch(1,1) w/default parameter values:
set.seed(123)
y &lt;- mlgarchSim(1000)

##simulate the same series, but with more output:
set.seed(123)
y &lt;- mlgarchSim(1000, verbose=TRUE)
head(y)

##plot the simulated values:
plot(y)

</code></pre>

<hr>
<h2 id='rmnorm'>
Random number generation from the multivariate normal distribution
</h2><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p>This function is a speed-optimised version of the <code><a href="#topic+rmnorm">rmnorm</a></code> function from the mnormt package of Adelchi Azzalini (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm(n, mean = NULL, vcov = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_+3A_n">n</code></td>
<td>
<p>integer, the number of observations to generate</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_mean">mean</code></td>
<td>
<p>numeric vector, i.e. the mean values</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_vcov">vcov</code></td>
<td>
<p>numeric matrix, i.e. the variance-covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empty</p>


<h3>Value</h3>

<p>A matrix of n rows</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Adelchi Azzalini (2013): 'mnormt: The multivariate normal and t distributions', R package version 1.4-7, <a href="http://CRAN.R-project.org/package=mnormt">http://CRAN.R-project.org/package=mnormt</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generate from univariate standardised normal:
z1 &lt;- rmnorm(100)

##generate from bivariate, independent standardised normal:
z2 &lt;- rmnorm(100, vcov=diag(c(1,1)))

##generate from bivariate, dependent standardised normal:
z3 &lt;- rmnorm(100, vcov=cbind(c(1,0.3),c(0.3,1)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
