<!DOCTYPE html><html><head><title>Help for package supportR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supportR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array_melt'><p>Melt an Array into a Dataframe</p></a></li>
<li><a href='#crop_tri'><p>Crop a Triangle from Data Object</p></a></li>
<li><a href='#date_check'><p>Check Columns for Non-Dates</p></a></li>
<li><a href='#date_format_guess'><p>Identify Probable Format for Ambiguous Date Formats</p></a></li>
<li><a href='#diff_check'><p>Compare Difference Between Two Vectors</p></a></li>
<li><a href='#github_ls'><p>List Objects in a GitHub Repository</p></a></li>
<li><a href='#github_ls_single'><p>List Objects in a Single Folder of a GitHub Repository</p></a></li>
<li><a href='#github_tree'><p>Create File Tree of a GitHub Repository</p></a></li>
<li><a href='#multi_date_check'><p>Check Multiple Columns for Non-Dates</p></a></li>
<li><a href='#multi_num_check'><p>Check Multiple Columns for Non-Numbers</p></a></li>
<li><a href='#name_vec'><p>Create Named Vector</p></a></li>
<li><a href='#nms_ord'><p>Publication-Quality Non-metric Multi-dimensional Scaling (NMS) Ordinations</p></a></li>
<li><a href='#num_check'><p>Check Columns for Non-Numbers</p></a></li>
<li><a href='#pcoa_ord'><p>Publication-Quality Principal Coordinates Analysis (PCoA) Ordinations</p></a></li>
<li><a href='#rmd_export'><p>Knit an R Markdown File and Export to Google Drive</p></a></li>
<li><a href='#summary_table'><p>Generate Summary Table for Supplied Response and Grouping Variables</p></a></li>
<li><a href='#supportR-package'><p>supportR: Support Functions for Wrangling and Visualization</p></a></li>
<li><a href='#theme_lyon'><p>Complete <code>ggplot2</code> Theme for Non-Data Aesthetics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Support Functions for Wrangling and Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J Lyon &lt;njlyon@alumni.iastate.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Suite of helper functions for data wrangling and visualization.
    The only theme for these functions is that they tend towards simple, short, and narrowly-scoped.
    These functions are built for tasks that often recur but are not large enough in scope to warrant an ecosystem of interdependent functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.tree, dplyr, ggplot2, gh, googledrive, graphics,
lifecycle, magrittr, methods, purrr, rlang, rmarkdown, scales,
stringr, tidyr, vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, knitr, palmerpenguins</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 16:03:29 UTC; nick.lyon</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J Lyon <a href="https://orcid.org/0000-0003-3905-1078"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='array_melt'>Melt an Array into a Dataframe</h2><span id='topic+array_melt'></span>

<h3>Description</h3>

<p>Melts an array of dimensions x, y, and z into a dataframe containing columns <code>x</code>, <code>y</code>, <code>z</code>, and <code>value</code> where <code>value</code> is whatever was stored in the array at those coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_melt(array = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_melt_+3A_array">array</code></td>
<td>
<p>(array) array object to melt into a dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) object containing the &quot;flattened&quot; array in dataframe format
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First we need to create an array to melt
## Make data to fill the array
vec1 &lt;- c(5, 9, 3)
vec2 &lt;- c(10:15)

## Create dimension names (x = col, y = row, z = which matrix)
x_vals &lt;- c("Col_1","Col_2","Col_3")
y_vals &lt;- c("Row_1","Row_2","Row_3")
z_vals &lt;- c("Mat_1","Mat_2")

## Make an array from these components
g &lt;- array(data = c(vec1, vec2), dim = c(3, 3, 2),
           dimnames = list(x_vals, y_vals, z_vals))

## "Melt" the array into a dataframe
array_melt(array = g)

</code></pre>

<hr>
<h2 id='crop_tri'>Crop a Triangle from Data Object</h2><span id='topic+crop_tri'></span>

<h3>Description</h3>

<p>Accepts a symmetric data object and replaces the chosen triangle with NAs. Also allows user to choose whether to keep or drop the diagonal of the data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_tri(data = NULL, drop_tri = "upper", drop_diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_tri_+3A_data">data</code></td>
<td>
<p>(dataframe, dataframe-like, or matrix) symmetric data object to remove one of the triangles from</p>
</td></tr>
<tr><td><code id="crop_tri_+3A_drop_tri">drop_tri</code></td>
<td>
<p>(character) which triangle to replace with NAs, either &quot;upper&quot; or &quot;lower&quot;</p>
</td></tr>
<tr><td><code id="crop_tri_+3A_drop_diag">drop_diag</code></td>
<td>
<p>(logical) whether to drop the diagonal of the data object (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe or dataframe-like) data object with desired triangle removed and either with or without the diagonal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple matrix wtih symmetric dimensions
mat &lt;- matrix(data = c(1:2, 2:1), nrow = 2, ncol = 2)

# Crop off it's lower triangle
supportR::crop_tri(data = mat, drop_tri = "lower", drop_diag = FALSE)

</code></pre>

<hr>
<h2 id='date_check'>Check Columns for Non-Dates</h2><span id='topic+date_check'></span>

<h3>Description</h3>

<p>Identifies any elements in the column(s) that would be changed to NA if <code>as.Date</code> is used on the column(s). This is useful for quickly identifying only the &quot;problem&quot; entries of ostensibly date column(s) that is/are read in as a character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_check(data = NULL, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_check_+3A_data">data</code></td>
<td>
<p>(dataframe) object containing at least one column of supposed dates</p>
</td></tr>
<tr><td><code id="date_check_+3A_col">col</code></td>
<td>
<p>(character or numeric) name(s) or column number(s) of the column(s) containing putative dates in the data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) malformed dates from each supplied column in separate list elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loc &lt;- c("LTR", "GIL", "PYN", "RIN")
time &lt;- c('2021-01-01', '2021-01-0w', '1990', '2020-10-xx')
time2 &lt;- c('1880-08-08', '2021-01-02', '1992', '2049-11-01')
time3 &lt;- c('2022-10-31', 'tomorrow', '1993', NA)

# Assemble our vectors into a dataframe
sites &lt;- data.frame('site' = loc, 'first_visit' = time, "second" = time2, "third" = time3)

# Use `date_check()` to return only the entries that would be lost
date_check(data = sites, col = c("first_visit", "second", "third"))
</code></pre>

<hr>
<h2 id='date_format_guess'>Identify Probable Format for Ambiguous Date Formats</h2><span id='topic+date_format_guess'></span>

<h3>Description</h3>

<p>In a column containing multiple date formats (e.g., MM/DD/YYYY, &quot;YYYY/MM/DD, etc.) identifies probable format of each date. Provision of a grouping column improves inference. Any formats that cannot be determined are flagged as &quot;FORMAT UNCERTAIN&quot; for human double-checking. This is useful for quickly sorting the bulk of ambiguous dates into clear categories for later conditional wrangling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_format_guess(
  data = NULL,
  date_col = NULL,
  groups = TRUE,
  group_col = NULL,
  return = "dataframe",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_format_guess_+3A_data">data</code></td>
<td>
<p>(dataframe) object containing at least one column of ambiguous dates</p>
</td></tr>
<tr><td><code id="date_format_guess_+3A_date_col">date_col</code></td>
<td>
<p>(character) name of column containing ambiguous dates</p>
</td></tr>
<tr><td><code id="date_format_guess_+3A_groups">groups</code></td>
<td>
<p>(logical) whether groups exist in the dataframe / should be used (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="date_format_guess_+3A_group_col">group_col</code></td>
<td>
<p>(character) name of column containing grouping variable</p>
</td></tr>
<tr><td><code id="date_format_guess_+3A_return">return</code></td>
<td>
<p>(character) either &quot;dataframe&quot; or &quot;vector&quot; depending on whether the user wants the date format &quot;guesses&quot; returned as a new column on the dataframe or a vector</p>
</td></tr>
<tr><td><code id="date_format_guess_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether certain optional messages should be displayed (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe or character) object containing date format guesses
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dataframe of example ambiguous dates &amp; grouping variable
my_df &lt;- data.frame('data_enterer' = c('person A', 'person B',
                                       'person B', 'person B',
                                       'person C', 'person D',
                                       'person E', 'person F',
                                       'person G'),
                    'bad_dates' = c('2022.13.08', '2021/2/02',
                                    '2021/2/03', '2021/2/04',
                                    '1899/1/15', '10-31-1901',
                                    '26/11/1901', '08.11.2004',
                                    '6/10/02'))

# Now we can invoke the function!
date_format_guess(data = my_df, date_col = "bad_dates",
group_col = "data_enterer", return = "dataframe")

# If preferred, do it without groups and return a vector
date_format_guess(data = my_df, date_col = "bad_dates",
groups = FALSE, return = "vector")

</code></pre>

<hr>
<h2 id='diff_check'>Compare Difference Between Two Vectors</h2><span id='topic+diff_check'></span>

<h3>Description</h3>

<p>Reflexively compares two vectors and identifies (1) elements that are found in the first but not the second (i.e., &quot;lost&quot; components) and (2) elements that are found in the second but not the first (i.e., &quot;gained&quot; components). This is particularly helpful when manipulating a dataframe and comparing what columns are lost or gained between wrangling steps. Alternately it can compare the contents of two columns to see how two dataframes differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_check(old = NULL, new = NULL, sort = TRUE, return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_check_+3A_old">old</code></td>
<td>
<p>(vector) starting / original object</p>
</td></tr>
<tr><td><code id="diff_check_+3A_new">new</code></td>
<td>
<p>(vector) ending / modified object</p>
</td></tr>
<tr><td><code id="diff_check_+3A_sort">sort</code></td>
<td>
<p>(logical) whether to sort the difference between the two vectors</p>
</td></tr>
<tr><td><code id="diff_check_+3A_return">return</code></td>
<td>
<p>(logical) whether to return the two vectors as a 2-element list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value (unless <code>return = T</code>), called for side effects. If <code>return = T</code>, returns a two-element list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make two vectors
vec1 &lt;- c("x", "a", "b")
vec2 &lt;- c("y", "z", "a")

# Compare them!
diff_check(old = vec1, new = vec2, return = FALSE)

# Return the difference for later use
diff_out &lt;- diff_check(old = vec1, new = vec2, return = TRUE)
diff_out

</code></pre>

<hr>
<h2 id='github_ls'>List Objects in a GitHub Repository</h2><span id='topic+github_ls'></span>

<h3>Description</h3>

<p>Accepts a GitHub repository URL and identifies all files in the specified folder. If no folder is specified, lists top-level repository contents. Recursive listing of sub-folders is supported by an additional argument. This function only works on repositories (public or private) to which you have access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>github_ls(repo = NULL, folder = NULL, recursive = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="github_ls_+3A_repo">repo</code></td>
<td>
<p>(character) full URL for a GitHub repository (including &quot;github.com&quot;)</p>
</td></tr>
<tr><td><code id="github_ls_+3A_folder">folder</code></td>
<td>
<p>(NULL/character) either <code>NULL</code> or the name of the folder to list. If <code>NULL</code>, the top-level contents of the repository will be listed</p>
</td></tr>
<tr><td><code id="github_ls_+3A_recursive">recursive</code></td>
<td>
<p>(logical) whether to recursively list contents (i.e., list contents of sub-folders identified within previously identified sub-folders)</p>
</td></tr>
<tr><td><code id="github_ls_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether to print an informative message as the contents of each folder is being listed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) three-column dataframe including (1) the names of the contents, (2) the type of each content item (e.g., file/directory/etc.), and (3) the full path from the starting folder to each item
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# List complete contents of the `supportR` package repository
github_ls(repo = "https://github.com/njlyon0/supportR", recursive = TRUE, quiet = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='github_ls_single'>List Objects in a Single Folder of a GitHub Repository</h2><span id='topic+github_ls_single'></span>

<h3>Description</h3>

<p>Accepts a GitHub repository URL and identifies all files in the specified folder. If no folder is specified, lists top-level repository contents. This function only works on repositories (public or private) to which you have access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>github_ls_single(repo = NULL, folder = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="github_ls_single_+3A_repo">repo</code></td>
<td>
<p>(character) full URL for a GitHub repository (including &quot;github.com&quot;)</p>
</td></tr>
<tr><td><code id="github_ls_single_+3A_folder">folder</code></td>
<td>
<p>(NULL/character) either <code>NULL</code> or the name of the folder to list. If <code>NULL</code>, the top-level contents of the repository will be listed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) two-column dataframe including (1) the names of the contents and (2) the type of each content item (e.g., file/directory/etc.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# List contents of the top-level of the `supportR` package repository
github_ls_single(repo = "https://github.com/njlyon0/supportR")

## End(Not run)

</code></pre>

<hr>
<h2 id='github_tree'>Create File Tree of a GitHub Repository</h2><span id='topic+github_tree'></span>

<h3>Description</h3>

<p>Recursively identifies all files in a GitHub repository and creates a file tree using the <code>data.tree</code> package to create a simple, human-readable visualization of the folder hierarchy. Folders can be specified for exclusion in which case the number of elements within them is listed but not the names of those objects. This function only works on repositories (public or private) to which you have access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>github_tree(repo = NULL, exclude = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="github_tree_+3A_repo">repo</code></td>
<td>
<p>(character) full URL for a github repository (including &quot;github.com&quot;)</p>
</td></tr>
<tr><td><code id="github_tree_+3A_exclude">exclude</code></td>
<td>
<p>(character) vector of folder names to exclude from the file tree. If <code>NULL</code> (the default) no folders are excluded</p>
</td></tr>
<tr><td><code id="github_tree_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether to print an informative message as the contents of each folder is being listed and as the tree is prepared from that information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(node / R6) <code>data.tree</code> package object class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a file tree for the `supportR` package GitHub repository
github_tree(repo = "github.com/njlyon0/supportR", exclude = c("man", "docs", ".github"))

## End(Not run)

</code></pre>

<hr>
<h2 id='multi_date_check'>Check Multiple Columns for Non-Dates</h2><span id='topic+multi_date_check'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated because I realized that it is just a special case of the <code><a href="#topic+date_check">date_check()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_date_check(data = NULL, col_vec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_date_check_+3A_data">data</code></td>
<td>
<p>(dataframe) object containing at least one column of supposed dates</p>
</td></tr>
<tr><td><code id="multi_date_check_+3A_col_vec">col_vec</code></td>
<td>
<p>(character or numeric) vector of names or column numbers of the columns containing putative dates in the data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of same length as <code>col_vec</code> with malformed dates from each column in their respective element
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a dataframe to test the function
loc &lt;- c("LTR", "GIL", "PYN", "RIN")
time &lt;- c('2021-01-01', '2021-01-0w', '1990', '2020-10-xx')
time2 &lt;- c('1880-08-08', '2021-01-02', '1992', '2049-11-01')
time3 &lt;- c('2022-10-31', 'tomorrow', '1993', NA)

# Assemble our vectors into a dataframe
sites &lt;- data.frame('site' = loc, 'first_visit' = time, "second" = time2, "third" = time3)

# Use `multi_date_check()` to return only the entries that would be lost
multi_date_check(data = sites, col_vec = c("first_visit", "second", "third"))
</code></pre>

<hr>
<h2 id='multi_num_check'>Check Multiple Columns for Non-Numbers</h2><span id='topic+multi_num_check'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated because I realized that it is just a special case of the <code><a href="#topic+num_check">num_check()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_num_check(data = NULL, col_vec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_num_check_+3A_data">data</code></td>
<td>
<p>(dataframe) object containing at least one column of supposed numbers</p>
</td></tr>
<tr><td><code id="multi_num_check_+3A_col_vec">col_vec</code></td>
<td>
<p>(character or numeric) vector of names or column numbers of the columns containing putative numbers in the data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of same length as <code>col_vec</code> with malformed numbers from each column in their respective element
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dataframe with a numeric column where some entries would be coerced into NA
spp &lt;- c('salmon', 'bass', 'halibut', 'eel')
ct &lt;- c(1, '14x', '_23', 12)
ct2 &lt;- c('a', '2', '4', '0')
ct3 &lt;- c(NA, 'Y', 'typo', '2')
fish &lt;- data.frame('species' = spp, 'count' = ct, 'num_col2' = ct2, 'third_count' = ct3)

# Use `multi_num_check()` to return only the entries that would be lost
multi_num_check(data = fish, col_vec = c("count", "num_col2", "third_count"))
</code></pre>

<hr>
<h2 id='name_vec'>Create Named Vector</h2><span id='topic+name_vec'></span>

<h3>Description</h3>

<p>Create a named vector in a single line without either manually defining names at the outset (e.g., <code style="white-space: pre;">&#8288;c("name_1" = 1, "name_2" = 2, ...&#8288;</code>) or spending a second line to assign names to an existing vector (e.g., <code>names(vec) &lt;- c("name_1", "name_2", ...)</code>). Useful in cases where you need a named vector within a pipe and don't want to break into two pipes just to define a named vector (see <code>tidyr::separate_wider_position</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_vec(content, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_vec_+3A_content">content</code></td>
<td>
<p>(vector) content of vector</p>
</td></tr>
<tr><td><code id="name_vec_+3A_name">name</code></td>
<td>
<p>(vector) names to assign to vector (must be in same order )</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named vector) vector with contents from the <code>content</code> argument and names from the <code>name</code> argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a named vector
name_vec(content = 1:10, name = paste0("text_", 1:10))

</code></pre>

<hr>
<h2 id='nms_ord'>Publication-Quality Non-metric Multi-dimensional Scaling (NMS) Ordinations</h2><span id='topic+nms_ord'></span>

<h3>Description</h3>

<p>Produces Non-Metric Multi-dimensional Scaling (NMS) ordinations for up to 10 groups. Assigns a unique color for each group and draws an ellipse around the standard deviation of the points. Automatically adds stress (see <code>vegan::metaMDS</code> for explanation of &quot;stress&quot;) as legend title. Because there are only five hollow shapes (see <code>?graphics::pch()</code>) all shapes are re-used a maximum of 2 times when more than 5 groups are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nms_ord(
  mod = NULL,
  groupcol = NULL,
  title = NA,
  colors = c("#41b6c4", "#c51b7d", "#7fbc41", "#d73027", "#4575b4", "#e08214", "#8073ac",
    "#f1b6da", "#b8e186", "#8c96c6"),
  shapes = rep(x = 21:25, times = 2),
  lines = rep(x = 1, times = 10),
  pt_size = 1.5,
  pt_alpha = 1,
  leg_pos = "bottomleft",
  leg_cont = unique(groupcol)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nms_ord_+3A_mod">mod</code></td>
<td>
<p>Object returned by <code>vegan::metaMDS</code></p>
</td></tr>
<tr><td><code id="nms_ord_+3A_groupcol">groupcol</code></td>
<td>
<p>(dataframe) column specification in the data that includes the groups (accepts either bracket or $ notation)</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_title">title</code></td>
<td>
<p>(character) string to use as title for plot</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_colors">colors</code></td>
<td>
<p>(character) vector of colors (as hexadecimal codes) of length &gt;= group levels (default <em>not</em> colorblind safe because of need for 10 built-in unique colors)</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_shapes">shapes</code></td>
<td>
<p>(numeric) vector of shapes (as values accepted by <code>pch</code>) of length &gt;= group levels</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_lines">lines</code></td>
<td>
<p>(numeric) vector of line types (as integers) of length &gt;= group levels</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_pt_size">pt_size</code></td>
<td>
<p>(numeric) value for point size (controlled by character expansion i.e., <code>cex</code>)</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_pt_alpha">pt_alpha</code></td>
<td>
<p>(numeric) value for transparency of points (ranges from 0 to 1)</p>
</td></tr>
<tr><td><code id="nms_ord_+3A_leg_pos">leg_pos</code></td>
<td>
<p>(character or numeric) legend position, either numeric vector of x/y coordinates or shorthand accepted by <code>graphics::legend</code></p>
</td></tr>
<tr><td><code id="nms_ord_+3A_leg_cont">leg_cont</code></td>
<td>
<p>(character) vector of desired legend entries. Defaults to <code>unique</code> entries in <code>groupcol</code> argument (this argument provided in case syntax of legend contents should differ from data contents)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(base R plot) base R plot with ellipses for each group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use data from the vegan package
utils::data("varespec", package = 'vegan')
resp &lt;- varespec

# Make some columns of known number of groups
factor_4lvl &lt;- c(rep.int("Trt1", (nrow(resp)/4)),
                 rep.int("Trt2", (nrow(resp)/4)),
                 rep.int("Trt3", (nrow(resp)/4)),
                 rep.int("Trt4", (nrow(resp)/4)))

# And combine them into a single data object
data &lt;- cbind(factor_4lvl, resp)

# Actually perform multidimensional scaling
mds &lt;- vegan::metaMDS(data[-1], autotransform = FALSE, expand = FALSE, k = 2, try = 50)

# With the scaled object and original dataframe we can use this function
nms_ord(mod = mds, groupcol = data$factor_4lvl,
                title = '4-Level NMS', leg_pos = 'topright',
                leg_cont = as.character(1:4))

</code></pre>

<hr>
<h2 id='num_check'>Check Columns for Non-Numbers</h2><span id='topic+num_check'></span>

<h3>Description</h3>

<p>Identifies any elements in the column(s) that would be changed to NA if <code>as.numeric</code> is used on the column(s). This is useful for quickly identifying only the &quot;problem&quot; entries of ostensibly numeric column(s) that is/are read in as a character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_check(data = NULL, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_check_+3A_data">data</code></td>
<td>
<p>(dataframe) object containing at least one column of supposed dates</p>
</td></tr>
<tr><td><code id="num_check_+3A_col">col</code></td>
<td>
<p>(character or numeric) name(s) or column number(s) of the column(s) containing putative dates in the data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) malformed numbers from each supplied column in separate list elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dataframe with a numeric column where some entries would be coerced into NA
spp &lt;- c('salmon', 'bass', 'halibut', 'eel')
ct &lt;- c(1, '14x', '_23', 12)
ct2 &lt;- c('a', '2', '4', '0')
ct3 &lt;- c(NA, 'Y', 'typo', '2')
fish &lt;- data.frame('species' = spp, 'count' = ct, 'num_col2' = ct2, 'third_count' = ct3)

# Use `num_check()` to return only the entries that would be lost
num_check(data = fish, col = c("count", "num_col2", "third_count"))
</code></pre>

<hr>
<h2 id='pcoa_ord'>Publication-Quality Principal Coordinates Analysis (PCoA) Ordinations</h2><span id='topic+pcoa_ord'></span>

<h3>Description</h3>

<p>Produces Principal Coordinates Analysis (PCoA) ordinations for up to 10 groups. Assigns a unique color for each group and draws an ellipse around the standard deviation of the points. Automatically adds percent of variation explained by first two principal component axes parenthetically to axis labels. Because there are only five hollow shapes (see <code>?graphics::pch</code>) all shapes are re-used a maximum of 2 times when more than 5 groups are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa_ord(
  mod = NULL,
  groupcol = NULL,
  title = NA,
  colors = c("#41b6c4", "#c51b7d", "#7fbc41", "#d73027", "#4575b4", "#e08214", "#8073ac",
    "#f1b6da", "#b8e186", "#8c96c6"),
  shapes = rep(x = 21:25, times = 2),
  lines = rep(x = 1, times = 10),
  pt_size = 1.5,
  pt_alpha = 1,
  leg_pos = "bottomleft",
  leg_cont = unique(groupcol)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa_ord_+3A_mod">mod</code></td>
<td>
<p>Object returned by <code>ape::pcoa</code></p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_groupcol">groupcol</code></td>
<td>
<p>(dataframe) column specification in the data that includes the groups (accepts either bracket or $ notation)</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_title">title</code></td>
<td>
<p>(character) string to use as title for plot</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_colors">colors</code></td>
<td>
<p>(character) vector of colors (as hexadecimal codes) of length &gt;= group levels (default <em>not</em> colorblind safe because of need for 10 built-in unique colors)</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_shapes">shapes</code></td>
<td>
<p>(numeric) vector of shapes (as values accepted by <code>pch</code>) of length &gt;= group levels</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_lines">lines</code></td>
<td>
<p>(numeric) vector of line types (as integers) of length &gt;= group levels</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_pt_size">pt_size</code></td>
<td>
<p>(numeric) value for point size (controlled by character expansion i.e., <code>cex</code>)</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_pt_alpha">pt_alpha</code></td>
<td>
<p>(numeric) value for transparency of points (ranges from 0 to 1)</p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_leg_pos">leg_pos</code></td>
<td>
<p>(character or numeric) legend position, either numeric vector of x/y coordinates or shorthand accepted by <code>graphics::legend</code></p>
</td></tr>
<tr><td><code id="pcoa_ord_+3A_leg_cont">leg_cont</code></td>
<td>
<p>(character) vector of desired legend entries. Defaults to <code>unique</code> entries in <code>groupcol</code> argument (this argument provided in case syntax of legend contents should differ from data contents)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(base R plot) base R plot with ellipses for each group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use data from the vegan package
data("varespec", package = 'vegan')
resp &lt;- varespec

# Make some columns of known number of groups
factor_4lvl &lt;- c(rep.int("Trt1", (nrow(resp)/4)),
                 rep.int("Trt2", (nrow(resp)/4)),
                 rep.int("Trt3", (nrow(resp)/4)),
                 rep.int("Trt4", (nrow(resp)/4)))

# And combine them into a single data object
data &lt;- cbind(factor_4lvl, resp)

# Get a distance matrix from the data
dist &lt;- vegan::vegdist(resp, method = 'kulczynski')

# Perform a PCoA on the distance matrix to get points for an ordination
pnts &lt;- ape::pcoa(dist)

# Test the function for 4 groups
pcoa_ord(mod = pnts, groupcol = data$factor_4lvl)

</code></pre>

<hr>
<h2 id='rmd_export'>Knit an R Markdown File and Export to Google Drive</h2><span id='topic+rmd_export'></span>

<h3>Description</h3>

<p>This function allows you to knit a specified R Markdown file locally and export it to the Google Drive folder for which you provided a link. NOTE that if you have not used <code>googledrive::drive_auth</code> this will prompt you to authorize a Google account in a new browser tab. If you do not check the box in that screen before continuing you will not be able to use this function until you clear your browser cache and re-authenticate. I recommend invoking <code>drive_auth</code> beforehand to reduce the chances of this error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmd_export(
  rmd = NULL,
  out_path = getwd(),
  out_name = NULL,
  out_type = "html",
  drive_link
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmd_export_+3A_rmd">rmd</code></td>
<td>
<p>(character) name and path to R markdown file to knit</p>
</td></tr>
<tr><td><code id="rmd_export_+3A_out_path">out_path</code></td>
<td>
<p>(character) path to the knit file's destination (defaults to path returned by <code>getwd</code>)</p>
</td></tr>
<tr><td><code id="rmd_export_+3A_out_name">out_name</code></td>
<td>
<p>(character) desired name for knit file (with or without file suffix)</p>
</td></tr>
<tr><td><code id="rmd_export_+3A_out_type">out_type</code></td>
<td>
<p>(character) either &quot;html&quot; or &quot;pdf&quot; depending on what YML entry you have in the <code style="white-space: pre;">&#8288;output: &#8288;</code> field of your R Markdown file</p>
</td></tr>
<tr><td><code id="rmd_export_+3A_drive_link">drive_link</code></td>
<td>
<p>(character) full URL of drive folder to upload the knit document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to knit R Markdown file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Authorize R to interact with GoogleDrive
googledrive::drive_auth()
## NOTE: See warning about possible misstep at this stage

# Use `rmd_export()` to knit and export an .Rmd file
rmd_export(rmd = "my_markdown.Rmd",  in_path = getwd(), out_path = getwd(),
           out_name = "my_markdown", out_type = "html",
           drive_link = "&lt;Google Drive folder URL&gt;")

## End(Not run)

</code></pre>

<hr>
<h2 id='summary_table'>Generate Summary Table for Supplied Response and Grouping Variables</h2><span id='topic+summary_table'></span>

<h3>Description</h3>

<p>Calculates mean, standard deviation, sample size, and standard error of a given response variable within user-defined grouping variables. This is meant as a convenience instead of doing <code>dplyr::group_by</code> followed by <code>dplyr::summarize</code> iteratively themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_table(
  data = NULL,
  groups = NULL,
  response = NULL,
  drop_na = FALSE,
  round_digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_table_+3A_data">data</code></td>
<td>
<p>(dataframe or dataframe-like) object with column names that match the values passed to the <code>groups</code> and <code>response</code> arguments</p>
</td></tr>
<tr><td><code id="summary_table_+3A_groups">groups</code></td>
<td>
<p>(character) vector of column names to group by</p>
</td></tr>
<tr><td><code id="summary_table_+3A_response">response</code></td>
<td>
<p>(character) name of the column name to calculate summary statistics for (the column must be numeric)</p>
</td></tr>
<tr><td><code id="summary_table_+3A_drop_na">drop_na</code></td>
<td>
<p>(logical) whether to drop NAs in grouping variables. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="summary_table_+3A_round_digits">round_digits</code></td>
<td>
<p>(numeric) number of digits to which mean, standard deviation, and standard error should be rounded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) summary table containing the mean, standard deviation, sample size, and standard error of the supplied response variable)
</p>

<hr>
<h2 id='supportR-package'>supportR: Support Functions for Wrangling and Visualization</h2><span id='topic+supportR'></span><span id='topic+supportR-package'></span>

<h3>Description</h3>

<p>Suite of helper functions for data wrangling and visualization. The only theme for these functions is that they tend towards simple, short, and narrowly-scoped. These functions are built for tasks that often recur but are not large enough in scope to warrant an ecosystem of interdependent functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicholas J Lyon <a href="mailto:njlyon@alumni.iastate.edu">njlyon@alumni.iastate.edu</a> (<a href="https://orcid.org/0000-0003-3905-1078">ORCID</a>) [copyright holder]
</p>

<hr>
<h2 id='theme_lyon'>Complete <code>ggplot2</code> Theme for Non-Data Aesthetics</h2><span id='topic+theme_lyon'></span>

<h3>Description</h3>

<p>Custom alternative to the <code>ggtheme</code> options built into <code>ggplot2</code>. Removes gray boxes and grid lines from plot background. Increases font size of tick marks and axis labels. Removes gray box from legend background and legend key. Removes legend title.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_lyon(title_size = 16, text_size = 13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_lyon_+3A_title_size">title_size</code></td>
<td>
<p>(numeric) size of font in axis titles</p>
</td></tr>
<tr><td><code id="theme_lyon_+3A_text_size">text_size</code></td>
<td>
<p>(numeric) size of font in tick labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(ggplot theme) list of ggplot2 theme elements
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
