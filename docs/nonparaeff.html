<!DOCTYPE html><html><head><title>Help for package nonparaeff</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nonparaeff}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#additive'><p>Linear Programming for the Additive Model</p></a></li>
<li><a href='#ar.dual.dea'><p>Assurance Region Data Envelopment Aanlysis (AR-DEA)</p></a></li>
<li><a href='#cost.dea'><p>Linear Programming for Cost Minimization</p></a></li>
<li><a href='#ddf'><p>Linear Programming for the Directional Distance Function</p></a></li>
<li><a href='#dea'><p>Linear Programming for the Data Envelopment Analysis</p></a></li>
<li><a href='#direc.dea'><p>Linear Programming for the Directional Distance Function with</p>
Undesirable Outputs</a></li>
<li><a href='#dual.dea'><p>Linear Programming for the Dual Data Envelopment Analysis</p></a></li>
<li><a href='#effdea.b.f'><p>Linear Programming for the Data Envelopment Analysis</p></a></li>
<li><a href='#faremalm2'><p>Linear Programming for the Malmquist Productivity Growth Index</p></a></li>
<li><a href='#fdh'><p>Linear Programming for the Free Disposable Hull</p></a></li>
<li><a href='#int.dea'><p>Linear Programming for the Data Envelopment Analysis with</p>
Integer-valued Inputs.</a></li>
<li><a href='#lp2'><p>Linear Programming with Free Variables</p></a></li>
<li><a href='#orderm'><p>Efficiency Measures with the order-m Method.</p></a></li>
<li><a href='#revenue.dea'><p>Linear Programming for Revenue Maximization</p></a></li>
<li><a href='#sbm.tone'><p>Linear Programming for the Slacks-based Model under the CRS</p></a></li>
<li><a href='#sbm.vrs'><p>Linear Programming for the Slacks-based Model under the VRS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5-13</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Methods for Measuring Efficiency and Productivity</td>
</tr>
<tr>
<td>Author:</td>
<td>Dong-hyun Oh &lt;oh.donghyun77@gmail.com&gt;,
	Dukrok Suh &lt;dukrok@kist.re.kr&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dong-hyun Oh &lt;oh.donghyun77@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficiency and productivity indices are measured using this package. This package contains functions for measuring efficiency and productivity of decision making units (DMUs) under the framework of Data Envelopment Analysis (DEA) and its variations.</td>
</tr>
<tr>
<td>Imports:</td>
<td>geometry, Hmisc, lpSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pwt, psych</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-21 00:47:51 UTC; arecibo</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-21 02:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='additive'>Linear Programming for the Additive Model</h2><span id='topic+additive'></span>

<h3>Description</h3>

<p>Solve the Additive Model under the VRS assumption</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive(base = NULL, frontier = NULL, noutput = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="additive_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="additive_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="additive_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additive model under the VRS assumption is as follows:
</p>
<p><code class="reqn">
    \theta^{k*}_{ADD} = \max_{\lambda, s^+, s^-} \left( \sum_{m=1}^M
    s^-_m + \sum_{n=1}^N s^+_n \right)</code>
</p>
<p><code class="reqn">s.t.~~ x^k_m = \sum_{j=1}^J x_m^j \lambda^j + s^-_n ~ (m = 1, 2,
    \cdots, M);</code>
</p>
<p><code class="reqn">~~~~~~ y^k_n = \sum_{j=1}^J y_n^j \lambda^j + s^-_n ~ (n = 1, 2,
    \cdots, N);</code>
</p>
<p><code class="reqn">~~~~~~\sum_{j=1}^J \lambda^j = 1;</code>
<code class="reqn">~~~~~~\lambda^j \geq 0~ (j = 1, 2, \cdots, J);~ s^-_m \geq 0~ (m = 1, 2, \cdots, M);~ s^+_n \geq 0~ (n = 1, 2, \cdots, N).
  </code>
</p>


<h3>Value</h3>

<p>A data frame with J1*(J1+M+N), which has efficiency scores, optimal
weightes and optimal slacks. Take a look at the example below.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbm.tone">sbm.tone</a></code>, <code><a href="#topic+sbm.vrs">sbm.vrs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple Example
my.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9),
                     x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- additive(my.dat, noutput = 1))

## Property of the Additive Model
dat1 &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                        x1 = c(2, 3, 6, 3, 6, 6),
                        x2 = c(5, 3, 1, 8, 4, 2))
dat2 &lt;- dat1 
dat2$x1 &lt;- dat2$x1 * 10 
dat3 &lt;- dat1 
dat3$x1 &lt;- dat3$x1 + 10 
(re1 &lt;- additive(dat1, noutput = 1))
(re2 &lt;- additive(dat2, noutput = 1))
(re3 &lt;- additive(dat3, noutput = 1))

</code></pre>

<hr>
<h2 id='ar.dual.dea'>Assurance Region Data Envelopment Aanlysis (AR-DEA)</h2><span id='topic+ar.dual.dea'></span>

<h3>Description</h3>

<p>Solve the AR-DEA</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar.dual.dea(base = NULL, frontier = NULL,
           noutput = 1, orientation=1, rts = 1, ar.l = NULL,
           ar.r = NULL, ar.dir = NULL, dual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar.dual.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale. 1 for the CRS assumption, and 2 for the
VRS assumption.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_ar.l">ar.l</code></td>
<td>
<p>A data frame for the assurance region of which is the
left-hand.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_ar.r">ar.r</code></td>
<td>
<p>A vector for the assurance region of which is the
right-hand.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_ar.dir">ar.dir</code></td>
<td>
<p>A vector for the assurance region of which is the
direction.</p>
</td></tr>
<tr><td><code id="ar.dual.dea_+3A_dual">dual</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model under the CRS assumption is calculated. For model
specification, take a look at Cooper et al. (2007).
</p>


<h3>Value</h3>

<p>A data frame with J1*(M+N), which has efficiency scores, optimal
virtual prices. Take a look at the example below.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>, <code><a href="#topic+dual.dea">dual.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## AR constraint of 0.25 &lt;= v2/v1 &lt;= 1.
library(Hmisc)
library(lpSolve)
ar.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                     x1 = c(2, 3, 6, 3, 6, 6),
                     x2 = c(5, 3, 1, 8, 4, 2))
(re &lt;-
ar.dual.dea(ar.dat, noutput = 1, orientation = 1, rts = 1, ar.l =
matrix(c(0, 0, 0.25, -1, -1, 1), nrow = 2, ncol = 3), ar.r = c(0, 0),
ar.dir = c("&lt;=", "&lt;=")))

</code></pre>

<hr>
<h2 id='cost.dea'>Linear Programming for Cost Minimization</h2><span id='topic+cost.dea'></span>

<h3>Description</h3>

<p>Solve the Cost Minimization Probem with Given Input Prices</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost.dea(base = NULL, frontier = NULL, noutput = 1, input.price = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cost.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="cost.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="cost.dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (M).</p>
</td></tr>
<tr><td><code id="cost.dea_+3A_input.price">input.price</code></td>
<td>
<p>A vector for market prices of input factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cost minimization problem under the CRS assumption is
calculated. For model specification, take a look at Cooper et al. (2007).
</p>


<h3>Value</h3>

<p>A data frame with J1*(M+6), which has optimal M input factors,
minimized cost when overally efficient, minimized cost when
technically-efficient, revealed cost, overall efficiency, allocative
efficiency, and technical efficiency. 
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+revenue.dea">revenue.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat.io &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1, 1),
                          x1 = c(2, 3, 5, 9, 6, 3, 8),
                          x2 = c(8, 6, 3, 2, 7, 9, 4))
dat.wm&lt;- c(w1 = 1, w2 = 2)      ## market prices of input factors
(re &lt;- cost.dea(base = dat.io, noutput = 1, input.price = dat.wm))

</code></pre>

<hr>
<h2 id='ddf'>Linear Programming for the Directional Distance Function</h2><span id='topic+ddf'></span>

<h3>Description</h3>

<p>Solve the Additive Model under the VRS assumption</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddf(base = NULL, frontier = NULL, noutput = 1, direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddf_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="ddf_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="ddf_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="ddf_+3A_direction">direction</code></td>
<td>
<p>A directional vector for inputs and outputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DDF under the VRS assumption is calculated. For model
specification, take a look at Cooper et al. (2007).
</p>


<h3>Value</h3>

<p>A data frame with J1*(J1+M+N), of which has efficiency scores, optimal
weightes and optimal slacks. Take a look at the example below.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direc.dea">direc.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Example of one input and one output.
my.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9),
                     x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- ddf(my.dat, noutput = 1, direction = c(1, 1)))
</code></pre>

<hr>
<h2 id='dea'>Linear Programming for the Data Envelopment Analysis</h2><span id='topic+dea'></span>

<h3>Description</h3>

<p>Solve input(output)-oriented DEA under the CRS (VRS)</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea(base = NULL, frontier = NULL, noutput = 1, orientation=1, rts = 1, onlytheta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
<tr><td><code id="dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale. 1 for the CRS assumption, and 2 for the
VRS assumption.</p>
</td></tr>
<tr><td><code id="dea_+3A_onlytheta">onlytheta</code></td>
<td>
<p>Logical. If onlytheta is TRUE, then only efficiency
scores are obtained. If it is FALSE, then optimal lambda's and
slacks are also obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input (output) -oriented DEA under the CRS (VRS) assumption are
calcuated. For model specification, take a look at Cooper et al. (2007).
</p>


<h3>Value</h3>

<p>If onlytheta is TRUE, then a (J1*1) data.frame is obtained. If
onlytheta if FALSE, then a data frame with a J1*(J1+M+N) dimension is
obtained, in which optimal weights, input slacks and output slacks are
presented.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dual.dea">dual.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## input-oriented DEA under the CRS assumption (1 input and 1 output)
tab3.1.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9), 
                         x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- dea(base = tab3.1.dat, noutput = 1, orientation = 1, rts = 1,
onlytheta = FALSE))

## input-oriented DEA under the CRS assumption (2 inputs and 1 output)
tab3.3.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                              x1 = c(1, 3, 6, 2, 5, 9),
                              x2 = c(4, 1, 1, 8, 5, 2))
re &lt;- dea(base=tab3.3.dat, noutput = 1, orientation = 1, rts = 1)
## finding references points
(ref &lt;- data.frame(y = c(tab3.3.dat$y + re$slack.y1),
x1 = c(tab3.3.dat$x1 * re$eff - re$slack.x1),
x2 = c(tab3.3.dat$x2 * re$eff - re$slack.x2)))


## output-oriented DEA under the CRS assumption (1 input and 2 outputs)
tab5.1.dat &lt;- data.frame(y1 = c(4, 8, 8, 4, 3, 1),
                         y2 = c(9, 6, 4, 3, 5, 6),
                         x = c(1, 1, 1, 1, 1, 1))
(re &lt;- dea(tab5.1.dat, noutput = 2, orientation = 2, rts = 1))

## input-oriented DEA under the VRS assumption (1 input and 1 output)
tab6.1.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9),
                              x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- dea(tab6.1.dat, noutput = 1, orientation = 1, rts = 2))

## output-oriented DEA under the VRS assumtion (1 input and 1 output)
(re &lt;- dea(tab6.1.dat, noutput = 1, orientation = 2, rts = 2))

## scale efficiency
re.crs &lt;-
    dea(tab6.1.dat, noutput = 1, orientation = 1, rts = 1,onlytheta = TRUE)
re.vrs&lt;-
    dea(tab6.1.dat, noutput = 1, orientation = 1, rts = 2,
         onlytheta = TRUE)
scale.eff &lt;- re.crs/re.vrs

## finding DRS, IRS, CRS
dat6.1 &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9),
     x = c(3, 2, 6, 4, 8, 8, 10))
re &lt;- dea(dat6.1, noutput = 1, rts = 1)
lambdas &lt;- re[, 2:8]
apply(lambdas, 1, sum) 
</code></pre>

<hr>
<h2 id='direc.dea'>Linear Programming for the Directional Distance Function with
Undesirable Outputs</h2><span id='topic+direc.dea'></span>

<h3>Description</h3>

<p>Solve the DDF with undesirable outputs. The directional
vecor is (y's, b's).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  direc.dea(base = NULL, frontier = NULL, ngood = 1, nbad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direc.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+P+Q) dimention, where J1 is the number of DMUs, M for the number
of inputs, P for the number of good outputs, and Q for the
undesirable outputs.</p>
</td></tr>
<tr><td><code id="direc.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+P+Q)
dimention, where J2 is the number of DMUs, M for the number of
inputs, P for the number of good outputs, and Q for the
undesirable outputs</p>
</td></tr>
<tr><td><code id="direc.dea_+3A_ngood">ngood</code></td>
<td>
<p>The number of good outputs (P).</p>
</td></tr>
<tr><td><code id="direc.dea_+3A_nbad">nbad</code></td>
<td>
<p>The number of bad outputs (Q).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DDF with undesirable outputs under the CRS assumption is
calculated. For model specification, take a look at Chung et al. (1997).
</p>


<h3>Value</h3>

<p>A J1 vector of which is inefficiency score.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Chung, Y. Fare, R. and Grosskopf, S. (1997). Productivity and
undesirable outputs: A directional distance function
approach. <em>Journal of Environmental Management</em> 51(3):229-240.
</p>
<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddf">ddf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Example of one input, one good output, and one bad output.
my.dat &lt;- data.frame(yg = c(2, 5, 7, 8, 3, 4, 6),
                     yb = c(1, 2, 4, 7, 4, 5, 6),
                     x = c(1, 1, 1, 1, 1, 1, 1))
direc.dea(my.dat, ngood = 1, nbad = 1)
</code></pre>

<hr>
<h2 id='dual.dea'>Linear Programming for the Dual Data Envelopment Analysis</h2><span id='topic+dual.dea'></span>

<h3>Description</h3>

<p>Solve the Dual DEA</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual.dea(base = NULL, frontier = NULL, noutput = 1, orientation=1, rts = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="dual.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="dual.dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="dual.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
<tr><td><code id="dual.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale. 1 for the CRS assumption, and 2 for the
VRS assumption.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input-oriented dual DEA under the CRS assumption is
calculated. For model specification, take a look at Cooper et
al. (2007).
</p>


<h3>Value</h3>

<p>A data frame with J1*(1+M+N) dimension, of which has efficiency scores, optimal
virtual prices for inputs and outputs.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## An output-oriented primal problem with 1 input and 2 outputs
tab5.1.dat &lt;- data.frame(y1 = c(4, 8, 8, 4, 3, 1),
                               y2 = c(9, 6, 4, 3, 5, 6),
                               x = c(1, 1, 1, 1, 1, 1))
(re &lt;- dea(tab5.1.dat, noutput = 2, orientation = 2, rts = 1))

## An output-oriented dual problem with 1 input and 2 outputs
re &lt;- dual.dea(tab5.1.dat, noutput = 2, orientation = 2, rts = 1)
</code></pre>

<hr>
<h2 id='effdea.b.f'>Linear Programming for the Data Envelopment Analysis</h2><span id='topic+effdea.b.f'></span>

<h3>Description</h3>

<p>Solve input(output)-oriented DEA under the CRS (VRS) with
convexhull. Do not use when the total number of inputs and outputs are
greater than eight. If used, it may take more than hundreds day to get
results.</p>


<h3>Usage</h3>

<pre><code class='language-R'>effdea.b.f(base = NULL, frontier = NULL, noutput = 1,
                       orientation=1, rts = 1, convhull = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effdea.b.f_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="effdea.b.f_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="effdea.b.f_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="effdea.b.f_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
<tr><td><code id="effdea.b.f_+3A_rts">rts</code></td>
<td>
<p>Returns to scale. 1 for the CRS assumption, and 2 for the
VRS assumption.</p>
</td></tr>
<tr><td><code id="effdea.b.f_+3A_convhull">convhull</code></td>
<td>
<p>Logical. If this is TRUE, very efficient calculation of
efficiency score is used. However, when the total number of inputs and
outputs is larger than eight, it is very slow for this option. In cases
when the total number of inputs and outputs is larger than eight, use
FALSE for this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the convhull function in geometry package. After
finding convex hull of <em>frontier</em> by using the convhull
function. points on the convex hull are used in constructing
the second production possibility set (PPS). Then efficiency scores in
<em>base</em> are calculated based on the second PPS.
</p>


<h3>Value</h3>

<p>A data frame with J1*1 dimension, which shows efficiency scores. 
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dual.dea">dual.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## input-oriented DEA under the CRS assumption (1 input and 1 output)
tab3.1.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9), 
                         x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- effdea.b.f(base = tab3.1.dat, noutput = 1, orientation = 1, rts =
1, convhull = TRUE))
</code></pre>

<hr>
<h2 id='faremalm2'>Linear Programming for the Malmquist Productivity Growth Index</h2><span id='topic+faremalm2'></span>

<h3>Description</h3>

<p>Calculate productivity growth index under the DEA framework.</p>


<h3>Usage</h3>

<pre><code class='language-R'>faremalm2(dat = NULL, noutput = 1, id = "id", year = "year")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faremalm2_+3A_dat">dat</code></td>
<td>
<p>A data frame to be evaluated. The format of this data frame
is data.frame(id, year, outputs, inputs). This data frame should have a
balanced panel data form.</p>
</td></tr>
<tr><td><code id="faremalm2_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs.</p>
</td></tr>
<tr><td><code id="faremalm2_+3A_id">id</code></td>
<td>
<p>A column name for the producer index.</p>
</td></tr>
<tr><td><code id="faremalm2_+3A_year">year</code></td>
<td>
<p>A column name for the time index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Malmquist productivity growth index is calculated. For model
specification, take a look at Fare et al. (1994).
</p>


<h3>Value</h3>

<p>A data frame with (
id: the id index of the original data.
time: the time index of the original data.
y's: original outputs
x's: original inputs
Dt2t2: <code class="reqn">D^{t+1} (x^{t+1}, y^{t+1})</code>
Dtt2: <code class="reqn">D^{t} (x^{t+1}, y^{t+1})</code>
Dt2t: <code class="reqn">D^{t+1} (x^t, y^t)</code>
ec: efficiency change
tc: technical change
pc: productivity change
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Fare, R., Grosskopf, S., Norris, M. and Zhang, Z. (1994). Productivity
growth, technical progress and efficiency change in industrialized
countries. <em>American Economic Review</em>, 84(1):66-83.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>malm.dat &lt;- data.frame(id = rep(LETTERS[1:3], 3),
       time = rep(1:3, each = 3),
                       y = c(1, 2, 2, 3, 2, 8, 3, 2, 5),
                       x = c(2, 3, 7, 3, 5, 6, 8, 9, 6))

malm.re1 &lt;- faremalm2(malm.dat, noutput = 1, id = "id", year = "time")


## Malmquist productivity growth index of OECD countries
library(pwt)       ## Use Penn World Table
library(psych)
my.dat &lt;- pwt5.6    
head(my.dat)        
my.oecd.ctry &lt;- c("AUS", "AUT", "BEL", "CAN", "CHE", "DNK", "ESP",
                    "FIN", "FRA", "GBR", "GER", "GRC", "IRL", "ISL",
                    "ITA", "JPN", "KOR", "LUX", "MEX", "NLD", "NOR",
                    "NZL", "PRT", "SWE", "TUR", "USA", "DEU")
my.dat &lt;- my.dat[my.dat$wbcode %in% my.oecd.ctry,]
my.dat &lt;- my.dat[my.dat$year %in% 1980:1990,]
my.dat$rgdpl &lt;- as.numeric(my.dat$rgdpl) ## GDP per capita
my.dat$pop &lt;- as.numeric(my.dat$pop) ## total population (1000)
my.dat$rgdpwok &lt;- as.numeric(my.dat$rgdpwok) ## GDP per labor
my.dat$kapw &lt;- as.numeric(my.dat$kapw)  ## Capital stock per labor
my.dat$gdp &lt;- my.dat$rgdpl * my.dat$pop ## Total GDP of a country
my.dat$labor &lt;- with(my.dat, gdp/rgdpwok) ## Total labor force
my.dat$capital &lt;- with(my.dat, kapw * labor) ## Toal capital stock
oecd &lt;- my.dat[, c("wbcode", "year", "gdp", "labor", "capital")] 
re.oecd &lt;- faremalm2(dat = oecd, noutput = 1, id = "wbcode", year =
"year")
## productivity growth for each country
pc.c &lt;- tapply(re.oecd$pc, re.oecd$wbcode, geometric.mean)
## a trend of productivity growth of OECD countries
pc.y &lt;- tapply(re.oecd$pc, re.oecd$year, geometric.mean)
## efficiency change for each country
ec.c &lt;- tapply(re.oecd$ec, re.oecd$wbcode, geometric.mean)
## a trend of efficiency change of OECD countries
ec.y &lt;- tapply(re.oecd$ec, re.oecd$year, geometric.mean)
</code></pre>

<hr>
<h2 id='fdh'>Linear Programming for the Free Disposable Hull</h2><span id='topic+fdh'></span>

<h3>Description</h3>

<p>Solve input(output)-oriented FDH</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdh(base = NULL, frontier = NULL, noutput = 1, orientation=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdh_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="fdh_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="fdh_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="fdh_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input (output) -oriented FDH is calculated. 
</p>


<h3>Value</h3>

<p>A data frame of J1*1 dimention which shows efficiency scores.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>, <code><a href="#topic+orderm">orderm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## input-oriented FDH with 1 input and 1 output.
tab7.1.dat &lt;- data.frame(y = c(1, 2, 4, 6, 7, 9, 9),
                              x = c(3, 2, 6, 4, 8, 8, 10))
(re &lt;- fdh(tab7.1.dat, noutput = 1, orientation = 1))

## input-oriented FDH with 2 input and 1 output.
tab7.10.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                               x1 = c(2, 3, 6, 3, 6, 6),
                               x2 = c(5, 3, 1, 8, 4, 2))
(re &lt;- fdh(tab7.10.dat, noutput = 1, orientation = 1))
</code></pre>

<hr>
<h2 id='int.dea'>Linear Programming for the Data Envelopment Analysis with
Integer-valued Inputs.</h2><span id='topic+int.dea'></span>

<h3>Description</h3>

<p>Solve input-oriented DEA under the CRS</p>


<h3>Usage</h3>

<pre><code class='language-R'>int.dea(base = NULL, frontier = NULL, noutput = 1, intinput = 1,
orientation=1, epsilon = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="int.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="int.dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="int.dea_+3A_intinput">intinput</code></td>
<td>
<p>The number of integer inputs.</p>
</td></tr>
<tr><td><code id="int.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure. This argument is ignored.</p>
</td></tr>
<tr><td><code id="int.dea_+3A_epsilon">epsilon</code></td>
<td>
<p>Non-Armechidean number. Use the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input-oriented IDEA under the CRS assumption is calcualted. See
Kuosmanen and Matin (2009). 
</p>


<h3>Value</h3>

<p>A data frame of J1*(1+J1+N+M+Q+Q), which shows efficiency scores,
optimal weightes, optimal slacks for outputs and inputs, optiaml
slacks for integer-valued inputs, and optimal integer inputs.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Kuomanen, T. and Matin, R. (2009). Theory of integer-valued data
envelopment analysis. <em>European Journal of Operational Research</em>
192(2):658-667
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>int.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1),
                      x1 = c(2, 7, 3, 7, 9),
                      x2 = c(4, 1, 4, 2, 4))
int.dea(int.dat, noutput = 1, intinput = 1)
</code></pre>

<hr>
<h2 id='lp2'>Linear Programming with Free Variables</h2><span id='topic+lp2'></span>

<h3>Description</h3>

<p>Solve LP with free variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp2(direction = "min", objective.in, const.mat, const.dir, 
    const.rhs, free.var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp2_+3A_direction">direction</code></td>
<td>
<p>Character string giving direction of optimization: &quot;min&quot;
(default) or &quot;max.&quot;</p>
</td></tr>
<tr><td><code id="lp2_+3A_objective.in">objective.in</code></td>
<td>
<p>Numeric vector of coefficients of objective
function</p>
</td></tr>
<tr><td><code id="lp2_+3A_const.mat">const.mat</code></td>
<td>
<p>Matrix of numeric constraint coefficients, one row per
constraint, one column per variable (unless
transpose.constraints = FALSE; see below).</p>
</td></tr>
<tr><td><code id="lp2_+3A_const.dir">const.dir</code></td>
<td>
<p>Vector of character strings giving the direction of the
constraint: each value should be one of &quot;&lt;,&quot; &quot;&lt;=,&quot; &quot;=,&quot; &quot;==,&quot;
&quot;&gt;,&quot; or &quot;&gt;=&quot;. (In each pair the two values are identical.)</p>
</td></tr>
<tr><td><code id="lp2_+3A_const.rhs">const.rhs</code></td>
<td>
<p>Vector of numeric values for the right-hand sides of the
constraints.</p>
</td></tr>
<tr><td><code id="lp2_+3A_free.var">free.var</code></td>
<td>
<p>Vector of numeric values for indicating free
variables. If this argument is NULL, no free variables is included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lp2 extends lpSolve::lp() to incorporate free variables easily.
</p>


<h3>Value</h3>

<p>An lp object. See 'lp.object' for details.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="gamlss.html#topic+lp">lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Set up problem: maximize
     #   x1 + 9 x2 +   x3 subject to
     #   x1 + 2 x2 + 3 x3  &lt;= 9
     # 3 x1 + 2 x2 + 2 x3 &lt;= 15
     #
     f.obj &lt;- c(1, 9, 3)
     f.con &lt;- matrix (c(1, 2, 3, 3, 2, 2), nrow=2, byrow=TRUE)
     f.dir &lt;- c("&lt;=", "&lt;=")
     f.rhs &lt;- c(9, 15)
     #
     # Now run.
     #
     lp2("max", f.obj, f.con, f.dir, f.rhs)
     lp2("max", f.obj, f.con, f.dir, f.rhs, free.var = c(0, 1, 0))
</code></pre>

<hr>
<h2 id='orderm'>Efficiency Measures with the order-m Method.</h2><span id='topic+orderm'></span>

<h3>Description</h3>

<p>Calculate order-m efficiency scores</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderm(base = NULL, frontier = NULL, noutput = 1, orientation=1, M = 25, B = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderm_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="orderm_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="orderm_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
<tr><td><code id="orderm_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of measurement. 1 for the input-oriented
measure, and 2 for the output-oriented measure.</p>
</td></tr>
<tr><td><code id="orderm_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="orderm_+3A_b">B</code></td>
<td>
<p>The number of bootstap replicates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Simar (2003).
</p>


<h3>Value</h3>

<p>A data frame with J1*1 dimention, which shows efficiency scores. 
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>
<p>Simar, L. (2003). Detecting outliers in frontier models: A simple
approach. <em>Journal of Productivity Analysis</em>, 20(3):391-424.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdh">fdh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(runif(200, min = 0.1, max = 4)) 
y &lt;- 3*x*abs(rnorm(200))
dat.orderm &lt;- data.frame(y = y, x = x)  
dat.orderm.out &lt;- rbind(dat.orderm, c(4, 0.1)) ## add one outlier.
(eff &lt;- orderm(dat.orderm.out, noutput = 1, M = 25, B = 20))
</code></pre>

<hr>
<h2 id='revenue.dea'>Linear Programming for Revenue Maximization</h2><span id='topic+revenue.dea'></span>

<h3>Description</h3>

<p>Solve the Revenue Maximization Probem with Given Output Prices</p>


<h3>Usage</h3>

<pre><code class='language-R'>revenue.dea(base = NULL, frontier = NULL, noutput = 1, output.price = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revenue.dea_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="revenue.dea_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to be used in constructing a
production possibility set (PPS). A data frame with J2*(M+N)
dimention, where J2 is the number of DMUs, M for the number of
inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="revenue.dea_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (M).</p>
</td></tr>
<tr><td><code id="revenue.dea_+3A_output.price">output.price</code></td>
<td>
<p>A vector for market prices of outputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The revenue maximization problem under the CRS assumption is
calculated. See Cooper et al. (2007).
</p>


<h3>Value</h3>

<p>A data frame with J1*(N+6), which has optimal N output factors,
maximized revenue when overally efficient, maximized revenue when
technically-efficient, revealed revenue, overall efficiency, allocative
efficiency, and technical efficiency. 
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cost.dea">cost.dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tab8.3 &lt;- data.frame(y1 = c(1, 3, 6, 6, 3, 9),
                          y2 = c(6, 6, 3, 5, 4, 1),
                          x = c(1, 1, 1, 1, 1, 1))
tab8.3.ps.f &lt;- c(p1 = 2, p2 = 2)
(ex8.3 &lt;- revenue.dea(base = tab8.3,
                    noutput = 2, output.price = tab8.3.ps.f))
</code></pre>

<hr>
<h2 id='sbm.tone'>Linear Programming for the Slacks-based Model under the CRS</h2><span id='topic+sbm.tone'></span>

<h3>Description</h3>

<p>Solve Slacks-based Model under the CRS (Tone, 2001)</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbm.tone(base= NULL, frontier = NULL, noutput = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbm.tone_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="sbm.tone_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to construct a production
possibility set (PPS). A data frame with
J2*(M+N) dimention, where J2 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="sbm.tone_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SBM under the CRS assumption is calculated. See Tone (2001).
</p>


<h3>Value</h3>

<p>A data frame with (1+J1+M+N), which shows efficiency scores, optimal
weights, and optiaml input and output slacks.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>
<p>Tone, K. (2001). A slacks-based measure of efficiency in data
envelopment analysis. <em>European Journal of Operational Research</em>,
130(3):498-509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbm.vrs">sbm.vrs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tab7.6.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                              x1 = c(1, 3, 6, 2, 5, 9),
                              x2 = c(4, 1, 1, 8, 5, 2))
(re &lt;- sbm.tone(tab7.6.dat, noutput = 1))
</code></pre>

<hr>
<h2 id='sbm.vrs'>Linear Programming for the Slacks-based Model under the VRS</h2><span id='topic+sbm.vrs'></span>

<h3>Description</h3>

<p>Solve Slacks-based Model under the VRS (Tone, 2001)</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbm.vrs(base= NULL, frontier = NULL, noutput = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbm.vrs_+3A_base">base</code></td>
<td>
<p>A data set for DMUs to be evaluated. A data frame with
J1*(M+N) dimention, where J1 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="sbm.vrs_+3A_frontier">frontier</code></td>
<td>
<p>A data set for DMUs to construct a production
possibility set (PPS). A data frame with
J2*(M+N) dimention, where J2 is the number of DMUs, M for the number
of inputs, and N for the number of outputs.</p>
</td></tr>
<tr><td><code id="sbm.vrs_+3A_noutput">noutput</code></td>
<td>
<p>The number of outputs (N).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SBM under the VRS assumption is calculated. See Tone (2001).
</p>


<h3>Value</h3>

<p>A data frame with (1+J1+M+N), which shows efficiency scores, optimal
weights, and optiaml input and output slacks.
</p>


<h3>Author(s)</h3>

<p>Dong-hyun Oh, <a href="mailto:oh.donghyun77@gmail.com">oh.donghyun77@gmail.com</a></p>


<h3>References</h3>

<p>Cooper, W., Seiford, L. and Tone, K. (2007). <em>Data envelopment
analysis: a comprehensive text with models, applications, references
and DEA-solver software</em> (2nd ed.). Springer Verlag, New York.
</p>
<p>Lee, J. and Oh, D. (forthcoming). <em>Efficiency Analysis: Data
Envelopment Analysis</em>. Press (in Korean).
</p>
<p>Tone, K. (2001). A slacks-based measure of efficiency in data
envelopment analysis. <em>European Journal of Operational Research</em>,
130(3):498-509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbm.tone">sbm.tone</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tab7.6.dat &lt;- data.frame(y = c(1, 1, 1, 1, 1, 1),
                              x1 = c(1, 3, 6, 2, 5, 9),
                              x2 = c(4, 1, 1, 8, 5, 2))
(re &lt;- sbm.vrs(tab7.6.dat, noutput = 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
