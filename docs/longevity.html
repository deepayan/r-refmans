<!DOCTYPE html><html><head><title>Help for package longevity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longevity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.censTruncLimits'><p>Identification sets</p></a></li>
<li><a href='#.check_surv'><p>Check survival output</p></a></li>
<li><a href='#.turnbull_em'><p>Turnbull EM algorithm (low storage implementation)</p></a></li>
<li><a href='#.turnbull_intervals'><p>Turnbull's sets</p></a></li>
<li><a href='#.wecdf'><p>Weighted empirical distribution function</p></a></li>
<li><a href='#boxcox_transfo'><p>Box-Cox transformation function</p></a></li>
<li><a href='#check_arguments'><p>Check default arguments</p></a></li>
<li><a href='#check_elife_dist'><p>Check parameters of extended lifetime distributions</p></a></li>
<li><a href='#conf_interv'><p>Confidence intervals for profile likelihoods</p></a></li>
<li><a href='#dextgp'><p>Density function of the extended generalized Pareto distribution</p></a></li>
<li><a href='#dutch'><p>Dutch survival data</p></a></li>
<li><a href='#elife'><p>Excess lifetime distributions</p></a></li>
<li><a href='#ewsim'><p>England and Wales simulated supercentenarian data</p></a></li>
<li><a href='#fit_ditrunc_elife'><p>Fit excess lifetime models for doubly interval truncated data</p></a></li>
<li><a href='#fit_elife'><p>Fit excess lifetime models by maximum likelihood</p></a></li>
<li><a href='#gppiece'><p>Piece-wise generalized Pareto distribution</p></a></li>
<li><a href='#hazard_elife'><p>Profile likelihood for hazard</p></a></li>
<li><a href='#hazard_fn_elife'><p>Hazard function for various parametric models</p></a></li>
<li><a href='#hexp'><p>Hazard function of the exponential distribution</p></a></li>
<li><a href='#hperks'><p>Hazard function of the Perks distribution</p></a></li>
<li><a href='#hweibull'><p>Hazard function of the Weibull distribution</p></a></li>
<li><a href='#idlmetadata'><p>IDL metadata</p></a></li>
<li><a href='#japanese'><p>Japanese survival data</p></a></li>
<li><a href='#japanese2'><p>Japanese survival data (2)</p></a></li>
<li><a href='#ks_test'><p>Goodness-of-fit diagnostics</p></a></li>
<li><a href='#lpost_elife'><p>Log posterior distribution with MDI priors</p></a></li>
<li><a href='#nc_score_test'><p>Score test of Northrop and Coleman</p></a></li>
<li><a href='#nc_test'><p>Score test of Northrop and Coleman</p></a></li>
<li><a href='#nll_ditrunc_elife'><p>Likelihood for doubly interval truncated data</p></a></li>
<li><a href='#nll_elife'><p>Likelihood for arbitrary censored and truncated data</p></a></li>
<li><a href='#np_elife'><p>Nonparametric estimation of the survival function</p></a></li>
<li><a href='#np_nll'><p>Marginal log likelihood function of the nonparametric multinomial with censoring and truncation</p></a></li>
<li><a href='#npsurv'><p>Nonparametric maximum likelihood estimation for arbitrary truncation</p></a></li>
<li><a href='#pbeard'><p>Distribution function of the Beard distribution</p></a></li>
<li><a href='#pbeardmake'><p>Distribution function of the Beard-Makeham distribution</p></a></li>
<li><a href='#pextgp'><p>Distribution function of the extended generalized Pareto distribution</p></a></li>
<li><a href='#pextweibull'><p>Distribution function of the extended Weibull distribution</p></a></li>
<li><a href='#pgomp'><p>Distribution function of the Gompertz distribution</p></a></li>
<li><a href='#pgompmake'><p>Distribution function of the Gompertz-Makeham distribution</p></a></li>
<li><a href='#pgpd'><p>Distribution function of the generalized Pareto distribution</p></a></li>
<li><a href='#plot.elife_ecdf'><p>Plot empirical distribution function</p></a></li>
<li><a href='#plot.elife_northropcoleman'><p>P-value plot</p></a></li>
<li><a href='#plot.elife_par'><p>Goodness-of-fit plots for parametric models</p></a></li>
<li><a href='#plot.elife_profile'><p>Plot profile of endpoint</p></a></li>
<li><a href='#pperksmake'><p>Distribution function of the Perks-Makeham distribution</p></a></li>
<li><a href='#prof_exp_scale'><p>Profile log likelihood for the scale parameter of the exponential distribution</p></a></li>
<li><a href='#prof_gp_endpt'><p>Profile likelihood for the endpoint of the generalized Pareto distribution</p></a></li>
<li><a href='#prof_gp_scalet'><p>Profile log likelihood for the transformed scale parameter of the generalized Pareto distribution</p></a></li>
<li><a href='#prof_gp_shape'><p>Profile log likelihood for the shape parameter of the generalized Pareto distribution</p></a></li>
<li><a href='#r_ditrunc_elife'><p>Sample observations from an interval truncated excess lifetime distribution</p></a></li>
<li><a href='#r_dtrunc_elife'><p>Sample observations from an interval truncated excess lifetime distribution</p></a></li>
<li><a href='#r_ltrc_elife'><p>Sample observations from a left-truncated right-censored excess lifetime distribution</p></a></li>
<li><a href='#samp_elife'><p>Simulate excess lifetime with truncation or right-censoring</p></a></li>
<li><a href='#samp2_elife'><p>Sample lifetime from excess lifetime model</p></a></li>
<li><a href='#test_ditrunc_elife'><p>Likelihood ratio test for doubly interval truncated data</p></a></li>
<li><a href='#test_elife'><p>Likelihood ratio test for covariates</p></a></li>
<li><a href='#tstab'><p>Threshold stability plots</p></a></li>
<li><a href='#turnbull_intervals'><p>Turnbull's sets</p></a></li>
<li><a href='#uq1_qqplot_elife'><p>Uncertainty quantification for quantile-quantile plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for the Analysis of Excess Lifetimes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lbelzile/longevity/issues">https://github.com/lbelzile/longevity/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lbelzile.github.io/longevity/">https://lbelzile.github.io/longevity/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, Rcpp (&ge; 1.0.6), rlang, Rsolnp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2 (&ge; 3.0.0), tinytest, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of parametric and nonparametric methods for the analysis of survival data. Parametric families implemented include Gompertz-Makeham, exponential and generalized Pareto models and extended models. The package includes an implementation of the nonparametric maximum likelihood estimator for arbitrary truncation and censoring pattern based on Turnbull (1976) &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1976.tb01597.x">doi:10.1111/j.2517-6161.1976.tb01597.x</a>&gt;, along with graphical goodness-of-fit diagnostics. Parametric models for positive random variables and peaks over threshold models based on extreme value theory are described in Rootz√©n and Zholud (2017) &lt;<a href="https://doi.org/10.1007%2Fs10687-017-0305-5">doi:10.1007/s10687-017-0305-5</a>&gt;; Belzile et al. (2021) &lt;<a href="https://doi.org/10.1098%2Frsos.202097">doi:10.1098/rsos.202097</a>&gt; and Belzile et al. (2022) &lt;<a href="https://doi.org/10.1146%2Fannurev-statistics-040120-025426">doi:10.1146/annurev-statistics-040120-025426</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-11 15:40:50 UTC; lbelzile</td>
</tr>
<tr>
<td>Author:</td>
<td>Leo Belzile <a href="https://orcid.org/0000-0002-9135-014X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leo Belzile &lt;belzilel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-12 11:43:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='.censTruncLimits'>Identification sets</h2><span id='topic+.censTruncLimits'></span>

<h3>Description</h3>

<p>Identification sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.censTruncLimits(tsets, lcens, rcens, ltrunc, rtrunc, trunc, cens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".censTruncLimits_+3A_tsets">tsets</code></td>
<td>
<p>Turnbull's sets</p>
</td></tr>
<tr><td><code id=".censTruncLimits_+3A_lcens">lcens</code></td>
<td>
<p>numeric vector of left censoring</p>
</td></tr>
<tr><td><code id=".censTruncLimits_+3A_rcens">rcens</code></td>
<td>
<p>numeric vector of right censoring</p>
</td></tr>
<tr><td><code id=".censTruncLimits_+3A_ltrunc">ltrunc</code></td>
<td>
<p>numeric vector of left truncation</p>
</td></tr>
<tr><td><code id=".censTruncLimits_+3A_rtrunc">rtrunc</code></td>
<td>
<p>numeric vector of right truncation</p>
</td></tr>
<tr><td><code id=".censTruncLimits_+3A_trunc">trunc</code></td>
<td>
<p>logical are observation truncated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the bounds of the intervals for Turnbull sets
</p>

<hr>
<h2 id='.check_surv'>Check survival output</h2><span id='topic+.check_surv'></span>

<h3>Description</h3>

<p>Check survival output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_surv(
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_surv_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id=".check_surv_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id=".check_surv_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id=".check_surv_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with transformed inputs or an error
</p>

<hr>
<h2 id='.turnbull_em'>Turnbull EM algorithm (low storage implementation)</h2><span id='topic+.turnbull_em'></span>

<h3>Description</h3>

<p>Turnbull EM algorithm (low storage implementation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.turnbull_em(
  tsets,
  lcens,
  rcens,
  ltrunc,
  rtrunc,
  weights,
  cens = TRUE,
  trunc = TRUE,
  tol = 1e-12,
  zerotol = 1e-10,
  maxiter = 100000L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".turnbull_em_+3A_tsets">tsets</code></td>
<td>
<p>Turnbull's sets</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_lcens">lcens</code></td>
<td>
<p>numeric vector of left censoring</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_rcens">rcens</code></td>
<td>
<p>numeric vector of right censoring</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_ltrunc">ltrunc</code></td>
<td>
<p>numeric vector of left truncation</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_rtrunc">rtrunc</code></td>
<td>
<p>numeric vector of right truncation</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_weights">weights</code></td>
<td>
<p>vector of weights for observations</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_cens">cens</code></td>
<td>
<p>logical; if <code>FALSE</code>, then <code>censUpp = censLow</code> and a particular update can be avoided in the EM algorithm</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_tol">tol</code></td>
<td>
<p>tolerance level for terminating the EM algorithm</p>
</td></tr>
<tr><td><code id=".turnbull_em_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration for the EM algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the probabilities and the standard errors
</p>

<hr>
<h2 id='.turnbull_intervals'>Turnbull's sets</h2><span id='topic+.turnbull_intervals'></span>

<h3>Description</h3>

<p>Given truncation and censoring sets,
construct disjoint increasing intervals whose
left and right endpoints lie in L and R
and which contain no other members of L and R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.turnbull_intervals(Lcens, Rcens, Ltrunc, Rtrunc, status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".turnbull_intervals_+3A_lcens">Lcens</code></td>
<td>
<p>set of left censoring limits</p>
</td></tr>
<tr><td><code id=".turnbull_intervals_+3A_rcens">Rcens</code></td>
<td>
<p>vector of right censoring limits</p>
</td></tr>
<tr><td><code id=".turnbull_intervals_+3A_ltrunc">Ltrunc</code></td>
<td>
<p>vector of left truncation limits</p>
</td></tr>
<tr><td><code id=".turnbull_intervals_+3A_rtrunc">Rtrunc</code></td>
<td>
<p>vector of right truncation limits</p>
</td></tr>
<tr><td><code id=".turnbull_intervals_+3A_status">status</code></td>
<td>
<p>integer vector giving status of censoring set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing limits of intervals for EM
</p>

<hr>
<h2 id='.wecdf'>Weighted empirical distribution function</h2><span id='topic+.wecdf'></span>

<h3>Description</h3>

<p>Weighted empirical distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.wecdf(x, w, type = c("dist", "surv"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".wecdf_+3A_x">x</code></td>
<td>
<p>vector of length <code>n</code> of values</p>
</td></tr>
<tr><td><code id=".wecdf_+3A_w">w</code></td>
<td>
<p>vector of weights of length <code>n</code></p>
</td></tr>
<tr><td><code id=".wecdf_+3A_type">type</code></td>
<td>
<p>string, one of distribution function (<code>dist</code>) or survival function (<code>surv</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adapted from spatstat (c) Adrian Baddeley and Rolf Turner
</p>

<hr>
<h2 id='boxcox_transfo'>Box-Cox transformation function</h2><span id='topic+boxcox_transfo'></span>

<h3>Description</h3>

<p>Given a vector of parameters, apply the Box-Cox transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox_transfo(x, lambda = rep(1, length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_transfo_+3A_x">x</code></td>
<td>
<p>vector of arguments</p>
</td></tr>
<tr><td><code id="boxcox_transfo_+3A_lambda">lambda</code></td>
<td>
<p>vector of Box-Cox parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as <code>x</code>
</p>

<hr>
<h2 id='check_arguments'>Check default arguments</h2><span id='topic+check_arguments'></span>

<h3>Description</h3>

<p>Check arguments and override default values.
If a named list, <code>arguments</code>, is provided by the user,
it will override any default value.
If one of the argument is provided directly,
it will take precedence over the values in <code>arguments</code>, provided it is not a default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arguments(func, call, arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arguments_+3A_func">func</code></td>
<td>
<p>function whose parameters are to be superseded</p>
</td></tr>
<tr><td><code id="check_arguments_+3A_call">call</code></td>
<td>
<p>user call, obtained from <code>match.call(expand.dots = FALSE)</code></p>
</td></tr>
<tr><td><code id="check_arguments_+3A_arguments">arguments</code></td>
<td>
<p>named list with arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with all arguments
</p>

<hr>
<h2 id='check_elife_dist'>Check parameters of extended lifetime distributions</h2><span id='topic+check_elife_dist'></span>

<h3>Description</h3>

<p>Check parameters of extended lifetime distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_elife_dist(
  rate,
  scale,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "beard", "perksmake", "beardmake")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_elife_dist_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s); for models with Makeham component, the last entry should be part of the rate vector</p>
</td></tr>
<tr><td><code id="check_elife_dist_+3A_scale">scale</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="check_elife_dist_+3A_shape">shape</code></td>
<td>
<p>vector of shape parameter(s).</p>
</td></tr>
<tr><td><code id="check_elife_dist_+3A_family">family</code></td>
<td>
<p>string indicating the parametric model, one of <code>exp</code>, <code>gp</code>, <code>gomp</code>, <code>gompmake</code>, <code>weibull</code>, <code>extgp</code>, <code>extweibull</code>, <code>perks</code>, <code>perksmake</code>, <code>beard</code> and <code>beardmake</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function has no return value and is only used to throw error for invalid arguments.
</p>

<hr>
<h2 id='conf_interv'>Confidence intervals for profile likelihoods</h2><span id='topic+conf_interv'></span>

<h3>Description</h3>

<p>This code is adapted from the <code>mev</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_interv(
  object,
  level = 0.95,
  prob = c((1 - level)/2, 1 - (1 - level)/2),
  print = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_interv_+3A_object">object</code></td>
<td>
<p>a list containing information about the profile likelihood in the same format as the <code>hoa</code> package</p>
</td></tr>
<tr><td><code id="conf_interv_+3A_level">level</code></td>
<td>
<p>probability level of the confidence interval</p>
</td></tr>
<tr><td><code id="conf_interv_+3A_prob">prob</code></td>
<td>
<p>vector of length 2 containing the bounds, by default double-sided</p>
</td></tr>
<tr><td><code id="conf_interv_+3A_print">print</code></td>
<td>
<p>logical indicating whether the intervals are printed to the console</p>
</td></tr>
<tr><td><code id="conf_interv_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table with confidence intervals.
</p>

<hr>
<h2 id='dextgp'>Density function of the extended generalized Pareto distribution</h2><span id='topic+dextgp'></span><span id='topic+hextgp'></span><span id='topic+qextgp'></span>

<h3>Description</h3>

<p>Density function of the extended generalized Pareto distribution
</p>
<p>Hazard function of the extended generalized Pareto distribution
</p>
<p>Quantile function of the extended generalized Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dextgp(x, scale = 1, shape1 = 0, shape2 = 0, log = FALSE)

hextgp(x, scale = 1, shape1 = 0, shape2 = 0, log = FALSE)

qextgp(p, scale = 1, shape1 = 0, shape2 = 0, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dextgp_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dextgp_+3A_scale">scale</code></td>
<td>
<p>scale parameter, strictly positive.</p>
</td></tr>
<tr><td><code id="dextgp_+3A_shape1">shape1</code></td>
<td>
<p>positive shape parameter <code class="reqn">\beta</code>; model defaults to generalized Pareto when it equals zero.</p>
</td></tr>
<tr><td><code id="dextgp_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter <code class="reqn">\gamma</code>; model reduces to Gompertz when <code>shape2=0</code>.</p>
</td></tr>
<tr><td><code id="dextgp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, return the log hazard</p>
</td></tr>
<tr><td><code id="dextgp_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dextgp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-density of the same length as <code>x</code>
</p>
<p>a vector of (log)-hazard of the same length as <code>x</code>
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='dutch'>Dutch survival data</h2><span id='topic+dutch'></span>

<h3>Description</h3>

<p>This data frame contains information about all Dutch who died
above age 92 years between 1986 and 2015. Observations are
doubly truncated and such bounds are calculated based on the
range of plausible values for these variables.
There are 226 records that are interval-censored and interval-truncated
for which <code>bdate</code>, <code>ddate</code> and <code>ndays</code> is missing (<code>NA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dutch
</code></pre>


<h3>Format</h3>

<p>A data frame with 305143 rows and 11 variables:
</p>

<dl>
<dt>ndays</dt><dd><p>survival time (in days)</p>
</dd>
<dt>bdate</dt><dd><p>the smallest plausible birth date given information
about month of birth and death and survival (<code>Date</code>)</p>
</dd>
<dt>bmonth</dt><dd><p>month of birth</p>
</dd>
<dt>byear</dt><dd><p>year of birth</p>
</dd>
<dt>ddate</dt><dd><p>the largest plausible death date given information
about month of birth and death and survival (<code>Date</code>)</p>
</dd>
<dt>dmonth</dt><dd><p>month of death</p>
</dd>
<dt>dyear</dt><dd><p>year of death</p>
</dd>
<dt>ltrunc</dt><dd><p>minimum age (in days); the maximum of either 92
years or the number of days reached in 1986</p>
</dd>
<dt>rtrunc</dt><dd><p>maximum age (in days) an individual could have
reached by the end of 2015</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender of individual, either
<code>female</code> or <code>male</code></p>
</dd>
<dt>valid</dt><dd><p>quality flag; <code>A</code> for individuals born in
the Netherlands, <code>B</code> for individuals born abroad who died
in the Netherlands</p>
</dd>
</dl>



<h3>Source</h3>

<p>Statistics Netherlands (CBS). Accessed via the Supplemental material of Einmahl, Einmahl and de Haan (2019)
</p>


<h3>References</h3>

<p>Einmahl, J.J., J.H.J. Einmahl and L. de Haan (2019). <em>Limits to Human Life Span Through Extreme Value Theory</em>, Journal of the American Statistical Association, <b>114</b>(527), 1075-1080. <a href="https://doi.org/10.1080/01621459.2018.1537912">doi:10.1080/01621459.2018.1537912</a>
</p>

<hr>
<h2 id='elife'>Excess lifetime distributions</h2><span id='topic+elife'></span><span id='topic+qelife'></span><span id='topic+pelife'></span><span id='topic+relife'></span><span id='topic+delife'></span><span id='topic+helife'></span>

<h3>Description</h3>

<p>Quantile, distribution, density and hazard functions of excess lifetime distribution
for threshold exceedances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qelife(
  p,
  rate,
  scale,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake"),
  lower.tail = TRUE
)

pelife(
  q,
  rate,
  scale,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake"),
  lower.tail = TRUE,
  log.p = FALSE
)

relife(
  n,
  scale = 1,
  rate,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake")
)

delife(
  x,
  scale = 1,
  rate,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake"),
  log = FALSE
)

helife(
  x,
  scale = 1,
  rate,
  shape,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake"),
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elife_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="elife_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s); for models with Makeham component, the last entry should be part of the rate vector</p>
</td></tr>
<tr><td><code id="elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="elife_+3A_shape">shape</code></td>
<td>
<p>vector of shape parameter(s).</p>
</td></tr>
<tr><td><code id="elife_+3A_family">family</code></td>
<td>
<p>string indicating the parametric model, one of <code>exp</code>, <code>gp</code>, <code>gomp</code>, <code>gompmake</code>, <code>weibull</code>, <code>extgp</code>, <code>extweibull</code>, <code>perks</code>, <code>perksmake</code>, <code>beard</code> and <code>beardmake</code></p>
</td></tr>
<tr><td><code id="elife_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="elife_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="elife_+3A_log">log</code>, <code id="elife_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, values are returned on the logarithmic scale (default to <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on the function type, a vector of probabilities (<code>pelife</code>), quantiles (<code>qelife</code>), density (<code>delife</code>), or hazard (<code>helife</code>). The function <code>relife</code> returns a random sample of size <code>n</code> from the distribution.
</p>

<hr>
<h2 id='ewsim'>England and Wales simulated supercentenarian data</h2><span id='topic+ewsim'></span>

<h3>Description</h3>

<p>This data frame contains information about 179 fake records mimicking
Welsh and English who died age 110 and above
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewsim
</code></pre>


<h3>Format</h3>

<p>A data frame with 179 rows and 3 variables:
</p>

<dl>
<dt>time</dt><dd><p>survival time above 110 (in years)</p>
</dd>
<dt>ltrunc</dt><dd><p>minimum age above 110 (in years), or zero</p>
</dd></dl>
<p>;
</p>
<dl>
<dt>rtrunc</dt><dd><p>maximum age (in years) an individual could have reached by the end of the time frame</p>
</dd>
</dl>


<hr>
<h2 id='fit_ditrunc_elife'>Fit excess lifetime models for doubly interval truncated data</h2><span id='topic+fit_ditrunc_elife'></span>

<h3>Description</h3>

<p>This function is a wrapper around constrained optimization
routines for different models with non-informative
censoring and truncation patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ditrunc_elife(
  time,
  ltrunc1 = NULL,
  rtrunc1 = NULL,
  ltrunc2 = NULL,
  rtrunc2 = NULL,
  thresh = 0,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  weights = NULL,
  export = FALSE,
  start = NULL,
  restart = FALSE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ditrunc_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_ltrunc1">ltrunc1</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_rtrunc1">rtrunc1</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_ltrunc2">ltrunc2</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_rtrunc2">rtrunc2</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family, either exponential (<code>exp</code>), Weibull (<code>weibull</code>), generalized Pareto (<code>gp</code>), Gompertz (<code>gomp</code>), Gompertz-Makeham (<code>gompmake</code>) or extended generalized Pareto (<code>extgp</code>).</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_export">export</code></td>
<td>
<p>logical; should data be included in the returned object to produce diagnostic plots? Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_start">start</code></td>
<td>
<p>vector of starting values for the optimization routine. If <code>NULL</code>, the algorithm attempts to find default values and returns a warning with
false convergence diagnostic if it cannot.</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_restart">restart</code></td>
<td>
<p>logical; should multiple starting values be attempted? Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="fit_ditrunc_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>elife_par</code>
</p>


<h3>Note</h3>

<p>The extended generalized Pareto model is constrained
to avoid regions where the likelihood is flat so <code class="reqn">\xi \in [-1, 10]</code> in
the optimization algorithm.
</p>
<p>The standard errors are obtained via the observed information matrix, calculated
using the hessian. In many instances, such as when the shape parameter is zero
or negative, the hessian is singular and no estimates are returned.
</p>

<hr>
<h2 id='fit_elife'>Fit excess lifetime models by maximum likelihood</h2><span id='topic+fit_elife'></span>

<h3>Description</h3>

<p>This function is a wrapper around constrained optimization
routines for different models with non-informative
censoring and truncation patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_elife(
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2"),
  ltrunc = NULL,
  rtrunc = NULL,
  thresh = 0,
  status = NULL,
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "gppiece",
    "extweibull", "perks", "perksmake", "beard", "beardmake"),
  weights = NULL,
  export = FALSE,
  start = NULL,
  restart = FALSE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_status">status</code></td>
<td>
<p>integer vector giving status of an observation. If <code>NULL</code> (default), this argument is computed internally based on <code>type</code>.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_export">export</code></td>
<td>
<p>logical; should data be included in the returned object to produce diagnostic plots? Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_start">start</code></td>
<td>
<p>vector of starting values for the optimization routine. If <code>NULL</code>, the algorithm attempts to find default values and returns a warning with
false convergence diagnostic if it cannot.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_restart">restart</code></td>
<td>
<p>logical; should multiple starting values be attempted? Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="fit_elife_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>elife_par</code>
</p>


<h3>Note</h3>

<p>The extended generalized Pareto model is constrained
to avoid regions where the likelihood is flat so <code class="reqn">\xi \in [-1, 10]</code> in
the optimization algorithm.
</p>
<p>The standard errors are obtained via the observed information matrix, calculated
using the hessian. In many instances, such as when the shape parameter is zero
or negative, the hessian is singular and no estimates are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ewsim, package = "longevity")
fit1 &lt;- fit_elife(
   arguments = ewsim,
   export = TRUE,
   family = "exp")
fit2 &lt;- fit_elife(
   arguments = ewsim,
   export = TRUE,
   family = "gp")
plot(fit1)
summary(fit1)
anova(fit2, fit1)
</code></pre>

<hr>
<h2 id='gppiece'>Piece-wise generalized Pareto distribution</h2><span id='topic+gppiece'></span><span id='topic+dgppiece'></span><span id='topic+pgppiece'></span><span id='topic+qgppiece'></span><span id='topic+rgppiece'></span>

<h3>Description</h3>

<p>Density, distribution, quantile functions and random number generation from the
mixture model of Northrop and Coleman (2014), which consists of <code>m</code>
different generalized Pareto distributions over non-overlapping intervals
with <code>m</code> shape parameters and one scale parameter; the other scale parameters are
constrained so that the resulting distribution is continuous over the domain
and reduces to a generalized Pareto distribution if all of the shape parameters are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgppiece(x, scale, shape, thresh, log = FALSE)

pgppiece(q, scale, shape, thresh, lower.tail = TRUE, log.p = FALSE)

qgppiece(p, scale, shape, thresh, lower.tail = TRUE, log.p = FALSE)

rgppiece(n, scale, shape, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gppiece_+3A_x">x</code>, <code id="gppiece_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="gppiece_+3A_scale">scale</code></td>
<td>
<p>positive value for the first scale parameter</p>
</td></tr>
<tr><td><code id="gppiece_+3A_shape">shape</code></td>
<td>
<p>vector of <code>m</code> shape parameters</p>
</td></tr>
<tr><td><code id="gppiece_+3A_thresh">thresh</code></td>
<td>
<p>vector of <code>m</code> thresholds</p>
</td></tr>
<tr><td><code id="gppiece_+3A_log">log</code>, <code id="gppiece_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, the values are returned on the log scale</p>
</td></tr>
<tr><td><code id="gppiece_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">\Pr[X \leq x]</code> otherwise, <code class="reqn">\Pr[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="gppiece_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="gppiece_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of quantiles (<code>qgppiece</code>), probabilities (<code>pgppiece</code>), density (<code>dgppiece</code>) or random number generated from the model (<code>rgppiece</code>)
</p>


<h3>References</h3>

<p>Northrop &amp; Coleman (2014). Improved threshold diagnostic plots for extreme value
analyses, <em>Extremes</em>, <b>17</b>(2), 289&ndash;303.
</p>

<hr>
<h2 id='hazard_elife'>Profile likelihood for hazard</h2><span id='topic+hazard_elife'></span>

<h3>Description</h3>

<p>This function computes the hazard for different <code>elife</code> parametric
models with profile-likelihood based confidence intervals.
It is also used to provide local hazard plots at varying thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard_elife(
  x,
  time,
  time2 = NULL,
  event = NULL,
  status = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  family = c("exp", "gp", "gomp", "weibull", "extgp"),
  weights = rep(1, length(time)),
  level = 0.95,
  psi = NULL,
  plot = FALSE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard_elife_+3A_x">x</code></td>
<td>
<p>value of the threshold exceedance at which to estimate the hazard</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_status">status</code></td>
<td>
<p>integer vector giving status of an observation. If <code>NULL</code> (default), this argument is computed internally based on <code>type</code>.</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_level">level</code></td>
<td>
<p>numeric; the level for the confidence intervals. Default to 0.95</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_psi">psi</code></td>
<td>
<p>optional vector of hazard at which to compute the profile log likelihood</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_plot">plot</code></td>
<td>
<p>logical; if true, display the profile log-likelihood. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="hazard_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible object of class <code>elife_hazard</code> containing information about the profile likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2500
time &lt;- samp_elife(n = n, scale = 2,
family = "gp", shape = 0.1,
lower = ltrunc &lt;- runif(n),
upper = rtrunc &lt;- (5 + runif(n)), type2 = "ltrt")
hazard_elife(x = 2, time = time,
 ltrunc = ltrunc, rtrunc = rtrunc, family = "exp")
</code></pre>

<hr>
<h2 id='hazard_fn_elife'>Hazard function for various parametric models</h2><span id='topic+hazard_fn_elife'></span>

<h3>Description</h3>

<p>Hazard function for various parametric models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard_fn_elife(
  x,
  par,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard_fn_elife_+3A_x">x</code></td>
<td>
<p>vector of points at which to evaluate the hazard function</p>
</td></tr>
<tr><td><code id="hazard_fn_elife_+3A_par">par</code></td>
<td>
<p>vector of scale and shape parameters</p>
</td></tr>
<tr><td><code id="hazard_fn_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the value of the hazard function at <code>x</code>
</p>

<hr>
<h2 id='hexp'>Hazard function of the exponential distribution</h2><span id='topic+hexp'></span>

<h3>Description</h3>

<p>Hazard function of the exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexp(x, rate = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexp_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="hexp_+3A_rate">rate</code></td>
<td>
<p>rate vector of rates</p>
</td></tr>
<tr><td><code id="hexp_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the log hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-hazard.
</p>

<hr>
<h2 id='hperks'>Hazard function of the Perks distribution</h2><span id='topic+hperks'></span><span id='topic+pperks'></span><span id='topic+dperks'></span><span id='topic+qperks'></span>

<h3>Description</h3>

<p>Hazard function of the Perks distribution
</p>
<p>Distribution function of the Perks distribution
</p>
<p>Density function of the Perks distribution
</p>
<p>Quantile function of the Perks distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hperks(x, rate = 1, shape = 1, log = FALSE)

pperks(q, rate = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)

dperks(x, rate = 1, shape = 1, log = FALSE)

qperks(p, rate = 1, shape = 1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hperks_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="hperks_+3A_rate">rate</code></td>
<td>
<p>rate parameter (<code class="reqn">\nu</code>)</p>
</td></tr>
<tr><td><code id="hperks_+3A_shape">shape</code></td>
<td>
<p>shape parameter (<code class="reqn">\alpha</code>)</p>
</td></tr>
<tr><td><code id="hperks_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the density, else the log likelihood of the individual observations.</p>
</td></tr>
<tr><td><code id="hperks_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="hperks_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="hperks_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="hperks_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-hazard.
</p>
<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='hweibull'>Hazard function of the Weibull distribution</h2><span id='topic+hweibull'></span>

<h3>Description</h3>

<p>Hazard function of the Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hweibull(x, shape, scale = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hweibull_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="hweibull_+3A_shape">shape</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="hweibull_+3A_scale">scale</code></td>
<td>
<p>scale parameter, default to 1</p>
</td></tr>
<tr><td><code id="hweibull_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns the log hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-hazard
</p>

<hr>
<h2 id='idlmetadata'>IDL metadata</h2><span id='topic+idlmetadata'></span>

<h3>Description</h3>

<p>This data frame contains country codes
and the associated data collection period
corresponding to the range for age at death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idlmetadata
</code></pre>


<h3>Format</h3>

<p>A data frame with 21 rows and 4 variables:
</p>

<dl>
<dt>country</dt><dd><p>factor, one of <code>AUT</code> (Austria), <code>BEL</code> (Belgium), <code>CAN</code> (Quebec), <code>DEU</code> (Germany), <code>DNK</code> (Denmark), <code>ESP</code> (Spain), <code>FIN</code> (Finland), <code>FRA</code> (France), <code>JPN</code> (Japan), <code>NOR</code> (Norway), <code>SWE</code> (Sweden), <code>EAW</code> (England and Wales) and <code>USA</code> (United States of America)</p>
</dd>
<dt>group</dt><dd><p>factor, either <code>105-109</code> for semi-supercentenarians or <code>110+</code> for supercentenarians&quot;</p>
</dd>
<dt>ldate</dt><dd><p>Date, smallest death date</p>
</dd>
<dt>rdate</dt><dd><p>Date, latest death date</p>
</dd>
</dl>



<h3>Details</h3>

<p>Due to confidentiality restrictions, some data that were available in previous versions of the IDL for Switzerland, Italy and some entries for Japan and Belgium have been removed.
As the IDL metadata are updated somewhat regularly and former versions of the database are not preserved, results from published analyses are replicable but not reproducible.
</p>


<h3>References</h3>

<p>International Database on Longevity, extracted on February 13th, 2023
</p>

<hr>
<h2 id='japanese'>Japanese survival data</h2><span id='topic+japanese'></span>

<h3>Description</h3>

<p>This data frame contains information about the counts
of dead Japanese by gender and year of birth (cohort), categorized
by the whole part of age attained at death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>japanese
</code></pre>


<h3>Format</h3>

<p>A data frame with 1038 rows and 4 variables:
</p>

<dl>
<dt>age</dt><dd><p>integer, age (to the smallest year) at death (in years)</p>
</dd>
<dt>byear</dt><dd><p>integer, birth year</p>
</dd>
<dt>count</dt><dd><p>integer, number of death for cohort at given age</p>
</dd>
<dt>gender</dt><dd><p>factor, the gender of the individuals; either <code>male</code> or <code>female</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>These data were obtained from the Annual Vital Statistics Report of Japan, released by the
Japanese government every year since 1947. The authors note that
&quot;All the members of that cohort have died by the end of the observation period,
a procedure referred to as the extinct cohort method&quot;.
The data were obtained from the Human Mortality Database by the authors.
Only positive counts are reported and two records (Misao Okawa and Jiroemon Kimura) are
excluded because they do not correspond to the same selection mechanism.
</p>


<h3>Source</h3>

<p>Table extracted from Hanayama &amp; Sibuya (2016).
</p>


<h3>References</h3>

<p>Hanayama, N. and M. Sibuya (2016). Estimating the Upper Limit of Lifetime Probability Distribution, Based on Data of Japanese Centenarians, <em>The Journals of Gerontology: Series A</em>, 71(<b>8</b>), 1014‚Äì1021. <a href="https://doi.org/10.1093/gerona/glv113">doi:10.1093/gerona/glv113</a>
</p>

<hr>
<h2 id='japanese2'>Japanese survival data (2)</h2><span id='topic+japanese2'></span>

<h3>Description</h3>

<p>This data frame is extracted from Table 10.3 from Chapter 10, &quot;Centenarians and Supercentenarians in Japan&quot;, in the Monograph Exceptional lifespans. The data were constructed by the extinct cohort method and are stratified by age cohort (five year group, except 1899-1900) and by sex. Note that the family registry system (KOSEKI), introduced in 1872, was standardized in 1886.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>japanese2
</code></pre>


<h3>Format</h3>

<p>A data frame with 216 rows and 4 variables:
</p>

<dl>
<dt>age</dt><dd><p>integer, age (to the smallest year) at death (in years)</p>
</dd>
<dt>bcohort</dt><dd><p>factor, birth cohort</p>
</dd>
<dt>count</dt><dd><p>integer, number of death for cohort at given age</p>
</dd>
<dt>gender</dt><dd><p>factor, the gender of the individuals; either <code>male</code> or <code>female</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Table 10.3
</p>


<h3>References</h3>

<p>Saito, Yasuhiko and Futoshi Ishii, and Jean-Marie Robine (2021). <em>Centenarians and Supercentenarians in Japan</em>. In <em>Exceptional lifespans</em>, Maier, H., Jeune, B., Vaupel, J. W. (Eds.), Demographic research monographs 17 VII, pp. 125-145. Cham, Springer.
</p>

<hr>
<h2 id='ks_test'>Goodness-of-fit diagnostics</h2><span id='topic+ks_test'></span>

<h3>Description</h3>

<p>Warning: EXPERIMENTAL
Compute the Kolmogorov-Smirnov
test statistic and compare it with a simulated null
distribution obtained via a parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks_test(
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  B = 999L,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks_test_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="ks_test_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="ks_test_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="ks_test_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="ks_test_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="ks_test_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="ks_test_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="ks_test_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="ks_test_+3A_b">B</code></td>
<td>
<p>number of bootstrap simulations</p>
</td></tr>
<tr><td><code id="ks_test_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="ks_test_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements
</p>

<ul>
<li> <p><code>stat</code> the value of the test statistic
</p>
</li>
<li> <p><code>pval</code> p-value obtained via simulation
</p>
</li></ul>



<h3>Note</h3>

<p>The bootstrap scheme requires simulating new data,
fitting a parametric model and estimating the nonparametric
maximum likelihood estimate for each new sample.
This is computationally intensive in large samples.
</p>

<hr>
<h2 id='lpost_elife'>Log posterior distribution with MDI priors</h2><span id='topic+lpost_elife'></span>

<h3>Description</h3>

<p>Log of the posterior distribution for excess lifetime
distribution with maximal data information priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpost_elife(
  par,
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2"),
  ltrunc = NULL,
  rtrunc = NULL,
  family = c("exp", "gp", "gomp"),
  thresh = 0,
  weights = rep(1, length(time)),
  status = NULL,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpost_elife_+3A_par">par</code></td>
<td>
<p>vector of parameters, in the following order: scale, rate and shape</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_status">status</code></td>
<td>
<p>integer vector giving status of an observation. If <code>NULL</code> (default), this argument is computed internally based on <code>type</code>.</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="lpost_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector proportional to the log posterior (the sum of the log likelihood and log prior)
</p>

<hr>
<h2 id='nc_score_test'>Score test of Northrop and Coleman</h2><span id='topic+nc_score_test'></span>

<h3>Description</h3>

<p>This function computes the score test
with the piecewise generalized Pareto distribution
under the null hypothesis that the generalized Pareto
with a single shape parameter is an adequate simplification.
The score test statistic is calculated using the observed information
matrix; both hessian and score vector are obtained through numerical differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_score_test(
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  weights = rep(1, length(time))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_score_test_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_thresh">thresh</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="nc_score_test_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The score test is much faster and perhaps less fragile than the likelihood ratio test:
fitting the piece-wise generalized Pareto model is difficult due to the large number of
parameters and multimodal likelihood surface.
</p>
<p>The reference distribution is chi-square
</p>


<h3>Value</h3>

<p>the value of a call to <code>nc_test</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n &lt;- 100L
x &lt;- samp_elife(n = n,
                scale = 2,
                shape = -0.2,
                lower = low &lt;- runif(n),
                upper = upp &lt;- runif(n, min = 3, max = 20),
                type2 = "ltrt",
                family = "gp")
test &lt;- nc_test(
  time = x,
  ltrunc = low,
  rtrunc = upp,
  thresh = quantile(x, seq(0, 0.5, by = 0.1)))
print(test)
plot(test)

</code></pre>

<hr>
<h2 id='nc_test'>Score test of Northrop and Coleman</h2><span id='topic+nc_test'></span>

<h3>Description</h3>

<p>This function computes the score test
with the piecewise generalized Pareto distribution
under the null hypothesis that the generalized Pareto
with a single shape parameter is an adequate simplification.
The score test statistic is calculated using the observed information
matrix; both hessian and score vector are obtained through numerical differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_test(
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  weights = rep(1, length(time)),
  test = c("score", "lrt"),
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_test_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="nc_test_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="nc_test_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="nc_test_+3A_thresh">thresh</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="nc_test_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nc_test_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nc_test_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="nc_test_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="nc_test_+3A_test">test</code></td>
<td>
<p>string, either <code>"score"</code> for the score test or <code>"lrt"</code> for the likelihood ratio test.</p>
</td></tr>
<tr><td><code id="nc_test_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="nc_test_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The score test is much faster and perhaps less fragile than the likelihood ratio test:
fitting the piece-wise generalized Pareto model is difficult due to the large number of
parameters and multimodal likelihood surface.
</p>
<p>The reference distribution is chi-square
</p>


<h3>Value</h3>

<p>a data frame with the following variables:
</p>

<ul>
<li> <p><code>thresh</code>: threshold for the generalized Pareto distribution
</p>
</li>
<li> <p><code>nexc</code>: number of exceedances
</p>
</li>
<li> <p><code>score</code>: score statistic
</p>
</li>
<li> <p><code>df</code>: degrees of freedom
</p>
</li>
<li> <p><code>pval</code>: the p-value obtained from the asymptotic chi-square approximation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n &lt;- 100L
x &lt;- samp_elife(n = n,
                scale = 2,
                shape = -0.2,
                lower = low &lt;- runif(n),
                upper = upp &lt;- runif(n, min = 3, max = 20),
                type2 = "ltrt",
                family = "gp")
test &lt;- nc_test(
  time = x,
  ltrunc = low,
  rtrunc = upp,
  thresh = quantile(x, seq(0, 0.5, by = 0.1)))
print(test)
plot(test)

</code></pre>

<hr>
<h2 id='nll_ditrunc_elife'>Likelihood for doubly interval truncated data</h2><span id='topic+nll_ditrunc_elife'></span>

<h3>Description</h3>

<p>Computes the log-likelihood for various parametric models suitable for threshold
exceedances. If threshold is non-zero, then only right-censored, observed event time and interval censored
data whose timing exceeds the thresholds are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nll_ditrunc_elife(
  par,
  time,
  ltrunc1 = NULL,
  rtrunc1 = NULL,
  ltrunc2 = NULL,
  rtrunc2 = NULL,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  thresh = 0,
  weights = rep(1, length(time)),
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nll_ditrunc_elife_+3A_par">par</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_ltrunc1">ltrunc1</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_rtrunc1">rtrunc1</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_ltrunc2">ltrunc2</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_rtrunc2">rtrunc2</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family, either exponential (<code>exp</code>), Weibull (<code>weibull</code>), generalized Pareto (<code>gp</code>), Gompertz (<code>gomp</code>), Gompertz-Makeham (<code>gompmake</code>) or extended generalized Pareto (<code>extgp</code>).</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="nll_ditrunc_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='nll_elife'>Likelihood for arbitrary censored and truncated data</h2><span id='topic+nll_elife'></span>

<h3>Description</h3>

<p>Computes the log-likelihood for various parametric models suitable for threshold
exceedances. If threshold is non-zero, then only right-censored, observed event time and interval censored
data whose timing exceeds the thresholds are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nll_elife(
  par,
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2"),
  ltrunc = NULL,
  rtrunc = NULL,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  thresh = 0,
  weights = NULL,
  status = NULL,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nll_elife_+3A_par">par</code></td>
<td>
<p>vector of parameters, in the following order: scale, rate and shape</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="nll_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_status">status</code></td>
<td>
<p>integer vector giving status of an observation. If <code>NULL</code> (default), this argument is computed internally based on <code>type</code>.</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="nll_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ewsim, package = "longevity")
nll_elife(par = c(5, 0.3),
          family = "gp",
          arguments = ewsim)
</code></pre>

<hr>
<h2 id='np_elife'>Nonparametric estimation of the survival function</h2><span id='topic+np_elife'></span>

<h3>Description</h3>

<p>The survival function is obtained through the EM algorithm
described in Turnbull (1976); censoring and truncation are
assumed to be non-informative.
The survival function changes only at the <code>J</code> distinct
exceedances <code class="reqn">y_i-u</code> and truncation points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np_elife(
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2"),
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  tol = 1e-12,
  weights = NULL,
  method = c("em", "sqp"),
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="np_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="np_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="np_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="np_elife_+3A_thresh">thresh</code></td>
<td>
<p>double thresh</p>
</td></tr>
<tr><td><code id="np_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="np_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="np_elife_+3A_tol">tol</code></td>
<td>
<p>double, relative tolerance for convergence of the EM algorithm</p>
</td></tr>
<tr><td><code id="np_elife_+3A_weights">weights</code></td>
<td>
<p>double, vector of weights for the observations</p>
</td></tr>
<tr><td><code id="np_elife_+3A_method">method</code></td>
<td>
<p>string, one of <code>"em"</code> for expectation-maximization (EM) algorithm or <code>"sqp"</code> for sequential quadratic programming with augmented Lagrange multiplie method.</p>
</td></tr>
<tr><td><code id="np_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="np_elife_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unknown parameters of the model are <code class="reqn">p_j (j=1, \ldots, J)</code>
subject to the constraint that <code class="reqn">\sum_{j=1}^J p_j=1</code>.
</p>


<h3>Value</h3>

<p>a list with elements
</p>

<ul>
<li> <p><code>cdf</code>: right-continuous <code>stepfun</code> object defined by probabilities
</p>
</li>
<li> <p><code>time</code>: matrix of unique values for the Turnbull intervals defining equivalence classes; only those with non-zero probabilities are returned
</p>
</li>
<li> <p><code>prob</code>: <code>J</code> vector of non-zero probabilities
</p>
</li>
<li> <p><code>niter</code>: number of iterations
</p>
</li></ul>



<h3>References</h3>

<p>Turnbull, B. W. (1976). <em>The Empirical Distribution Function with Arbitrarily Grouped, Censored and Truncated Data.</em> Journal of the Royal Statistical Society. Series B (Methodological) 38(<b>3</b>), 290‚Äì295.
</p>
<p>Gentleman, R. and C. J. Geyer (1994). <em>Maximum likelihood for interval censored data: Consistency and computation</em>, Biometrika, 81(<b>3</b>), 618‚Äì623.
</p>
<p>Frydman, H. (1994). <em>A Note on Nonparametric Estimation of the Distribution Function from Interval-Censored and Truncated Observations</em>, Journal of the Royal Statistical Society. Series B (Methodological) <b>56</b>(1), 71-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
n &lt;- 20L
# Create fake data
ltrunc &lt;- pmax(0, runif(n, -0.5, 1))
rtrunc &lt;- runif(n, 6, 10)
dat &lt;- samp_elife(n = n,
                  scale = 1,
                  shape = -0.1,
                  lower = ltrunc,
                  upper = rtrunc,
                  family = "gp",
                  type2 = "ltrt")
npi &lt;- np_elife(time = dat,
                rtrunc = rtrunc,
                ltrunc = ltrunc)
print(npi)
summary(npi)
plot(npi)
</code></pre>

<hr>
<h2 id='np_nll'>Marginal log likelihood function of the nonparametric multinomial with censoring and truncation</h2><span id='topic+np_nll'></span>

<h3>Description</h3>

<p>Marginal log likelihood function of the nonparametric multinomial with censoring and truncation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np_nll(par, cens_lb, cens_ub, trunc_lb, trunc_ub, cens, trunc, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np_nll_+3A_par">par</code></td>
<td>
<p>vector of <code>D-1</code> parameters</p>
</td></tr>
<tr><td><code id="np_nll_+3A_cens_lb">cens_lb</code></td>
<td>
<p>index of interval in which death occurs</p>
</td></tr>
<tr><td><code id="np_nll_+3A_cens_ub">cens_ub</code></td>
<td>
<p>index of interval in which death occurs (if death is observed), or else the largest interval.</p>
</td></tr>
<tr><td><code id="np_nll_+3A_trunc_lb">trunc_lb</code></td>
<td>
<p>vector of largest index for the lower truncation</p>
</td></tr>
<tr><td><code id="np_nll_+3A_trunc_ub">trunc_ub</code></td>
<td>
<p>vector of smallest index for the upper truncation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the negative log likelihood value
</p>

<hr>
<h2 id='npsurv'>Nonparametric maximum likelihood estimation for arbitrary truncation</h2><span id='topic+npsurv'></span>

<h3>Description</h3>

<p>The syntax is reminiscent of the <a href="survival.html#topic+Surv">Surv</a> function, with
additional vectors for left-truncation and right-truncation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npsurv(
  time,
  time2 = NULL,
  event = NULL,
  type = c("right", "left", "interval", "interval2"),
  ltrunc = NULL,
  rtrunc = NULL,
  weights = NULL,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npsurv_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="npsurv_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="npsurv_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="npsurv_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="npsurv_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="npsurv_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="npsurv_+3A_weights">weights</code></td>
<td>
<p>vector of weights, default to <code>NULL</code> for equiweighted</p>
</td></tr>
<tr><td><code id="npsurv_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="npsurv_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li> <p><code>xval</code>: unique ordered values of sets on which the distribution function is defined
</p>
</li>
<li> <p><code>prob</code>: estimated probability of failure on intervals
</p>
</li>
<li> <p><code>convergence</code>: logical; <code>TRUE</code> if the EM algorithm iterated until convergence
</p>
</li>
<li> <p><code>niter</code>: logical; number of iterations for the EM algorithm
</p>
</li>
<li> <p><code>cdf</code>: nonparametric maximum likelihood estimator of the distribution function
</p>
</li></ul>



<h3>Note</h3>

<p>Contrary to the Kaplan-Meier estimator, the mass is placed in the interval
[<code>max(time), Inf</code>) so the resulting distribution function is not deficient.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+Surv">Surv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Toy example with interval censoring and right censoring
# Two observations: A1: [1,3], A2: 4
# Probability of 0.5

test_simple2 &lt;- npsurv(
  time = c(1,4),
  time2 = c(3,4),
  event = c(3,1),
  type = "interval"
)
</code></pre>

<hr>
<h2 id='pbeard'>Distribution function of the Beard distribution</h2><span id='topic+pbeard'></span><span id='topic+dbeard'></span><span id='topic+hbeard'></span><span id='topic+qbeard'></span>

<h3>Description</h3>

<p>Distribution function of the Beard distribution
</p>
<p>Density function of the Beard distribution
</p>
<p>Hazard function of the Beard distribution
</p>
<p>Quantile function of the Beard distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbeard(q, rate = 1, shape1 = 1, shape2 = 1, lower.tail = TRUE, log.p = FALSE)

dbeard(x, rate = 1, shape1 = 1, shape2 = 1, log = FALSE)

hbeard(x, rate = 1, shape1 = 1, shape2 = 1, log = FALSE)

qbeard(p, rate = 1, shape1 = 1, shape2 = 1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbeard_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pbeard_+3A_rate">rate</code></td>
<td>
<p>rate parameter (<code class="reqn">\nu</code>)</p>
</td></tr>
<tr><td><code id="pbeard_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter (<code class="reqn">\alpha</code>)</p>
</td></tr>
<tr><td><code id="pbeard_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter (<code class="reqn">\beta</code>)</p>
</td></tr>
<tr><td><code id="pbeard_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pbeard_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pbeard_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pbeard_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the hazard</p>
</td></tr>
<tr><td><code id="pbeard_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard.
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='pbeardmake'>Distribution function of the Beard-Makeham distribution</h2><span id='topic+pbeardmake'></span><span id='topic+dbeardmake'></span><span id='topic+hbeardmake'></span><span id='topic+qbeardmake'></span>

<h3>Description</h3>

<p>Distribution function of the Beard-Makeham distribution
</p>
<p>Density function of the Beard-Makeham distribution
</p>
<p>Hazard function of the Beard-Makeham distribution
</p>
<p>Quantile function of the Beard-Makeham distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbeardmake(
  q,
  rate = 1,
  shape1 = 1,
  shape2 = 1,
  lambda = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

dbeardmake(x, rate = rate, shape1 = 1, shape2 = 1, lambda = 0, log = FALSE)

hbeardmake(x, rate = rate, shape1 = 1, shape2 = 1, lambda = 0, log = FALSE)

qbeardmake(p, rate = 1, shape1 = 1, shape2 = 1, lambda = 0, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbeardmake_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_rate">rate</code></td>
<td>
<p>shape parameter (<code class="reqn">\nu</code>)</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter (<code class="reqn">\alpha</code>)</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter (<code class="reqn">\beta</code>)</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_lambda">lambda</code></td>
<td>
<p>exponential rate of the Makeham component</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the hazard</p>
</td></tr>
<tr><td><code id="pbeardmake_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard.
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='pextgp'>Distribution function of the extended generalized Pareto distribution</h2><span id='topic+pextgp'></span>

<h3>Description</h3>

<p>Distribution function of the extended generalized Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pextgp(q, scale = 1, shape1 = 0, shape2 = 0, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pextgp_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pextgp_+3A_scale">scale</code></td>
<td>
<p>scale parameter, strictly positive.</p>
</td></tr>
<tr><td><code id="pextgp_+3A_shape1">shape1</code></td>
<td>
<p>positive shape parameter <code class="reqn">\beta</code>; model defaults to generalized Pareto when it equals zero.</p>
</td></tr>
<tr><td><code id="pextgp_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter <code class="reqn">\gamma</code>; model reduces to Gompertz when <code>shape2=0</code>.</p>
</td></tr>
<tr><td><code id="pextgp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pextgp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>

<hr>
<h2 id='pextweibull'>Distribution function of the extended Weibull distribution</h2><span id='topic+pextweibull'></span><span id='topic+dextweibull'></span><span id='topic+hextweibull'></span><span id='topic+qextweibull'></span>

<h3>Description</h3>

<p>Distribution function of the extended Weibull distribution
</p>
<p>Density function of the extended Weibull distribution
</p>
<p>Hazard function of the extended Weibull distribution
</p>
<p>Quantile function of the extended Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pextweibull(
  q,
  scale = 1,
  shape1 = 0,
  shape2 = 1,
  lower.tail = TRUE,
  log.p = FALSE
)

dextweibull(x, scale = 1, shape1 = 0, shape2 = 1, log = FALSE)

hextweibull(x, scale = 1, shape1 = 0, shape2 = 1, log = FALSE)

qextweibull(p, scale = 1, shape1 = 0, shape2 = 1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pextweibull_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_scale">scale</code></td>
<td>
<p>scale parameter, strictly positive.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter of the generalized Pareto component.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter of the Weibull component.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the hazard, else the log hazard.</p>
</td></tr>
<tr><td><code id="pextweibull_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard
</p>
<p>vector of quantiles
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='pgomp'>Distribution function of the Gompertz distribution</h2><span id='topic+pgomp'></span><span id='topic+qgomp'></span><span id='topic+dgomp'></span><span id='topic+hgomp'></span>

<h3>Description</h3>

<p>Distribution function of the Gompertz distribution
</p>
<p>Quantile function of the Gompertz distribution
</p>
<p>Density function of the Gompertz distribution
</p>
<p>Hazard function of the Gompertz distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgomp(q, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE)

qgomp(p, scale = 1, shape = 0, lower.tail = TRUE)

dgomp(x, scale = 1, shape = 0, log = FALSE)

hgomp(x, scale = 1, shape = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgomp_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pgomp_+3A_scale">scale</code></td>
<td>
<p>positive scale parameter</p>
</td></tr>
<tr><td><code id="pgomp_+3A_shape">shape</code></td>
<td>
<p>non-negative shape parameter</p>
</td></tr>
<tr><td><code id="pgomp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pgomp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pgomp_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="pgomp_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="pgomp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, return the log hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of quantiles
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard.
</p>

<hr>
<h2 id='pgompmake'>Distribution function of the Gompertz-Makeham distribution</h2><span id='topic+pgompmake'></span><span id='topic+qgompmake'></span><span id='topic+dgompmake'></span><span id='topic+hgompmake'></span>

<h3>Description</h3>

<p>Distribution function of the Gompertz-Makeham distribution
</p>
<p>Quantile function of the Gompertz-Makeham distribution
</p>
<p>Density function of the Gompertz-Makeham distribution
</p>
<p>Hazard function of the Gompertz-Makeham distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgompmake(
  q,
  scale = 1,
  shape = 0,
  lambda = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qgompmake(p, scale = 1, shape = 0, lambda = 0, lower.tail = TRUE)

dgompmake(x, scale = 1, shape = 0, lambda = 0, log = FALSE)

hgompmake(x, scale = 1, shape = 0, lambda = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgompmake_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_scale">scale</code></td>
<td>
<p>scale parameter, strictly positive.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_shape">shape</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_lambda">lambda</code></td>
<td>
<p>exponential rate</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pgompmake_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, return the log hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of quantiles
</p>
<p>a vector of density
</p>
<p>a vector of (log)-hazard.
</p>


<h3>Note</h3>

<p>The quantile function is defined in terms of Lambert's W function. Particular parameter combinations (small values of <code>lambda</code> lead to numerical overflow; the function throws a warning when this happens.
</p>

<hr>
<h2 id='pgpd'>Distribution function of the generalized Pareto distribution</h2><span id='topic+pgpd'></span><span id='topic+dgpd'></span><span id='topic+hgpd'></span><span id='topic+qgpd'></span>

<h3>Description</h3>

<p>Distribution function of the generalized Pareto distribution
</p>
<p>Density function of the generalized Pareto distribution
</p>
<p>Hazard function of the generalized Pareto distribution
</p>
<p>Quantile function of the generalized Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgpd(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE)

dgpd(x, loc = 0, scale = 1, shape = 0, log = FALSE)

hgpd(x, loc = 0, scale = 1, shape = 0, log = FALSE)

qgpd(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgpd_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_loc">loc</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_scale">scale</code></td>
<td>
<p>scale parameter, strictly positive.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_shape">shape</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the log hazard</p>
</td></tr>
<tr><td><code id="pgpd_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard.
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='plot.elife_ecdf'>Plot empirical distribution function</h2><span id='topic+plot.elife_ecdf'></span>

<h3>Description</h3>

<p>Plot empirical distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elife_ecdf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elife_ecdf_+3A_x">x</code></td>
<td>
<p>argument of class <code>elife_ecdf</code></p>
</td></tr>
<tr><td><code id="plot.elife_ecdf_+3A_...">...</code></td>
<td>
<p>additional arguments for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base R plot of the empirical distribution function
</p>

<hr>
<h2 id='plot.elife_northropcoleman'>P-value plot</h2><span id='topic+plot.elife_northropcoleman'></span>

<h3>Description</h3>

<p>The Northrop-Coleman tests for penultimate models are
comparing the piece-wise generalized Pareto distribution
to the generalized Pareto above the lower threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elife_northropcoleman'
plot(x, plot.type = c("base", "ggplot"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elife_northropcoleman_+3A_x">x</code></td>
<td>
<p>an object of class <code>elife_northropcoleman</code></p>
</td></tr>
<tr><td><code id="plot.elife_northropcoleman_+3A_plot.type">plot.type</code></td>
<td>
<p>string indicating the type of plot</p>
</td></tr>
<tr><td><code id="plot.elife_northropcoleman_+3A_plot">plot</code></td>
<td>
<p>logical; should the routine print the graph if <code>plot.type</code> equals <code>"ggplot"</code>? Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.elife_northropcoleman_+3A_...">...</code></td>
<td>
<p>additional arguments for base <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a base R or ggplot object with p-values for the Northrop-Coleman test against thresholds.
</p>

<hr>
<h2 id='plot.elife_par'>Goodness-of-fit plots for parametric models</h2><span id='topic+plot.elife_par'></span>

<h3>Description</h3>

<p>Because of censoring and truncation, the plotting
positions must be adjusted accordingly.
For right-censored data, the methodology is described
in Waller &amp; Turnbull (1992). Only non-censored observations are
displayed, which can create distortion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elife_par'
plot(
  x,
  plot.type = c("base", "ggplot"),
  which.plot = c("pp", "qq"),
  confint = c("none", "pointwise", "simultaneous"),
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elife_par_+3A_x">x</code></td>
<td>
<p>a parametric model of class <code>elife_par</code></p>
</td></tr>
<tr><td><code id="plot.elife_par_+3A_plot.type">plot.type</code></td>
<td>
<p>string, one of <code>base</code> for base R or <code>ggplot</code></p>
</td></tr>
<tr><td><code id="plot.elife_par_+3A_which.plot">which.plot</code></td>
<td>
<p>vector of string indicating the plots, among <code>pp</code> for probability-probability plot, <code>qq</code> for quantile-quantile plot, <code>erp</code> for empirically rescaled plot (only for censored data), <code>exp</code> for standard exponential quantile-quantile plot or <code>tmd</code> for Tukey's mean difference plot, which is a variant of the Q-Q plot in which we map the pair <code class="reqn">(x,y)</code> is mapped to <code>((x+y)/2,y-x)</code> are detrended</p>
</td></tr>
<tr><td><code id="plot.elife_par_+3A_confint">confint</code></td>
<td>
<p>logical; if <code>TRUE</code>, creates uncertainty diagnostic via a parametric bootstrap</p>
</td></tr>
<tr><td><code id="plot.elife_par_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, creates a plot when <code>plot.type="ggplot"</code>. Useful for returning <code>ggplot</code> objects without printing the graphs</p>
</td></tr>
<tr><td><code id="plot.elife_par_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For truncated data, we first estimate the distribution function
nonparametrically, <code class="reqn">F_n</code>. The uniform plotting positions of the data
</p>
<p style="text-align: center;"><code class="reqn">v_i = [F_n(y_i) - F_n(a_i)]/[F_n(b_i) - F_n(a_i)].</code>
</p>

<p>For probability-probability plots, the empirical quantiles are transformed
using the same transformation, with <code class="reqn">F_n</code> replaced by the postulated or estimated
distribution function <code class="reqn">F_0</code>.
For quantile-quantile plots, the plotting positions <code class="reqn">v_i</code> are mapped back
to the data scale viz. </p>
<p style="text-align: center;"><code class="reqn">F_0^{-1}\{F_0(a_i) + v_i[F_0(b_i) - F_0(a_i)]\}</code>
</p>

<p>When data are truncated and observations are mapped back to the untruncated scale (with, e.g., <code>exp</code>), the plotting positions need not be in the same order as the order statistics of the data.
</p>


<h3>Value</h3>

<p>The function produces graphical goodness-of-fit plots using base R or ggplot objects (returned as an invisible list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
samp &lt;- samp_elife(
 n = 200,
 scale = 2,
 shape = 0.3,
 family = "gomp",
 lower = 0, upper = runif(200, 0, 10),
 type2 = "ltrc")
fitted &lt;- fit_elife(
 time = samp$dat,
 thresh = 0,
 event = ifelse(samp$rcens, 0L, 1L),
 type = "right",
 family = "exp",
 export = TRUE)
plot(fitted, plot.type = "ggplot")
# Left- and right-truncated data
n &lt;- 40L
samp &lt;- samp_elife(
 n = n,
 scale = 2,
 shape = 0.3,
 family = "gp",
 lower = ltrunc &lt;- runif(n),
 upper = rtrunc &lt;- ltrunc + runif(n, 0, 15),
 type2 = "ltrt")
fitted &lt;- fit_elife(
 time = samp,
 thresh = 0,
 ltrunc = ltrunc,
 rtrunc = rtrunc,
 family = "gp",
 export = TRUE)
plot(fitted,  which.plot = "tmd")
</code></pre>

<hr>
<h2 id='plot.elife_profile'>Plot profile of endpoint</h2><span id='topic+plot.elife_profile'></span>

<h3>Description</h3>

<p>Plot profile of endpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elife_profile'
plot(x, plot.type = c("base", "ggplot"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elife_profile_+3A_x">x</code></td>
<td>
<p>an object of class <code>elife_profile</code> containing information about the profile likelihood, maximum likelihood and grid of values for the endpoint</p>
</td></tr>
<tr><td><code id="plot.elife_profile_+3A_plot.type">plot.type</code></td>
<td>
<p>string indicating whether to use base R for plots or <code>ggplot2</code></p>
</td></tr>
<tr><td><code id="plot.elife_profile_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, creates a plot when <code>plot.type="ggplot"</code>. Useful for returning <code>ggplot</code> objects without printing the graphs</p>
</td></tr>
<tr><td><code id="plot.elife_profile_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>plot</code>, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base R or ggplot object for a plot of the profile log likelihood of the endpoint of the generalized Pareto distribution
</p>

<hr>
<h2 id='pperksmake'>Distribution function of the Perks-Makeham distribution</h2><span id='topic+pperksmake'></span><span id='topic+dperksmake'></span><span id='topic+hperksmake'></span><span id='topic+qperksmake'></span>

<h3>Description</h3>

<p>Distribution function of the Perks-Makeham distribution
</p>
<p>Density function of the Perks-Makeham distribution
</p>
<p>Hazard function of the Perks-Makeham distribution
</p>
<p>Quantile function of the Perks-Makeham distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pperksmake(
  q,
  rate = 1,
  shape = 1,
  lambda = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

dperksmake(x, rate = 1, shape = 1, lambda = 0, log = FALSE)

hperksmake(x, rate = 1, shape = 1, lambda = 0, log = FALSE)

qperksmake(p, rate = 1, shape = 1, lambda = 0, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pperksmake_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_rate">rate</code></td>
<td>
<p>rate parameter (<code class="reqn">\nu</code>)</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_shape">shape</code></td>
<td>
<p>shape parameter (<code class="reqn">\alpha</code>)</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_lambda">lambda</code></td>
<td>
<p>exponential rate of the Makeham component</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the lower tail probability <code class="reqn">\Pr(X \leq x)</code> is returned.</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), values are returned on the probability scale.</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_log">log</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), return the hazard</p>
</td></tr>
<tr><td><code id="pperksmake_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (log)-probabilities of the same length as <code>q</code>
</p>
<p>a vector of (log)-density.
</p>
<p>a vector of (log)-hazard.
</p>
<p>vector of quantiles
</p>
<p>a vector of quantiles
</p>

<hr>
<h2 id='prof_exp_scale'>Profile log likelihood for the scale parameter of the exponential distribution</h2><span id='topic+prof_exp_scale'></span>

<h3>Description</h3>

<p>This internal function is used to produce threshold stability plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof_exp_scale(
  mle = NULL,
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  level = 0.95,
  psi = NULL,
  weights = NULL,
  confint = TRUE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_exp_scale_+3A_mle">mle</code></td>
<td>
<p>an object of class <code>elife_par</code></p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_level">level</code></td>
<td>
<p>level of the confidence interval</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_confint">confint</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), return confidence intervals rather than list</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="prof_exp_scale_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length three with the maximum likelihood of the scale and profile-based confidence interval
</p>

<hr>
<h2 id='prof_gp_endpt'>Profile likelihood for the endpoint of the generalized Pareto distribution</h2><span id='topic+prof_gp_endpt'></span>

<h3>Description</h3>

<p>This function returns the profile log likelihood over a grid of values of <code>psi</code>, the endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof_gp_endpt(
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  type = c("right", "left", "interval", "interval2"),
  ltrunc = NULL,
  rtrunc = NULL,
  weights = rep(1, length(time)),
  psi = NULL,
  confint = FALSE,
  level = 0.95,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_gp_endpt_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_psi">psi</code></td>
<td>
<p>mandatory vector of endpoints at which to compute the profile</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_confint">confint</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a <code>level</code> confidence interval instead of a list with the profile log-likelihood components</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_level">level</code></td>
<td>
<p>numeric; the level for the confidence intervals</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="prof_gp_endpt_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the maximum likelihood estimate of the endpoint and the profile log-likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2023)
time &lt;- relife(n = 100, scale = 3, shape = -0.3, family = "gp")
endpt &lt;- prof_gp_endpt(
  time = time,
  psi = seq(max(time) + 1e-4, max(time) + 40, length.out = 51L))
print(endpt)
plot(endpt)
confint(endpt)
</code></pre>

<hr>
<h2 id='prof_gp_scalet'>Profile log likelihood for the transformed scale parameter of the generalized Pareto distribution</h2><span id='topic+prof_gp_scalet'></span>

<h3>Description</h3>

<p>This internal function is used to produce threshold stability plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof_gp_scalet(
  mle = NULL,
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  level = 0.95,
  psi = NULL,
  weights = NULL,
  confint = TRUE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_gp_scalet_+3A_mle">mle</code></td>
<td>
<p>an object of class <code>elife_par</code></p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_level">level</code></td>
<td>
<p>level of the confidence interval</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_confint">confint</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), return confidence intervals rather than list</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="prof_gp_scalet_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a confidence interval or a list with profile values
</p>

<hr>
<h2 id='prof_gp_shape'>Profile log likelihood for the shape parameter of the generalized Pareto distribution</h2><span id='topic+prof_gp_shape'></span>

<h3>Description</h3>

<p>This internal function is used to produce threshold stability plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof_gp_shape(
  mle = NULL,
  time,
  time2 = NULL,
  event = NULL,
  thresh,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  level = 0.95,
  psi = NULL,
  weights = NULL,
  confint = TRUE,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_gp_shape_+3A_mle">mle</code></td>
<td>
<p>an object of class <code>elife_par</code></p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_level">level</code></td>
<td>
<p>level of the confidence interval</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_confint">confint</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), return confidence intervals rather than list</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="prof_gp_shape_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>confint=TRUE</code>, a vector of length three with the maximum likelihood of the shape and profile-based confidence interval
</p>

<hr>
<h2 id='r_ditrunc_elife'>Sample observations from an interval truncated excess lifetime distribution</h2><span id='topic+r_ditrunc_elife'></span>

<h3>Description</h3>

<p>Sample observations from an interval truncated excess lifetime distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_ditrunc_elife(
  n,
  rate,
  scale,
  shape,
  lower,
  upper,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_ditrunc_elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s)</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter(s)</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s)</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds</p>
</td></tr>
<tr><td><code id="r_ditrunc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code>n</code> observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100L
# the lower and upper bound are either scalar,
# or else vectors of length n
r_dtrunc_elife(n = n, scale = 1, shape = -0.1,
               lower = pmax(0, runif(n, -0.5, 1)),
               upper = runif(n, 6, 10),
               family = "gp")
</code></pre>

<hr>
<h2 id='r_dtrunc_elife'>Sample observations from an interval truncated excess lifetime distribution</h2><span id='topic+r_dtrunc_elife'></span>

<h3>Description</h3>

<p>Sample observations from an interval truncated excess lifetime distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_dtrunc_elife(
  n,
  scale,
  rate,
  shape,
  lower,
  upper,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_dtrunc_elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter(s)</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s)</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s)</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds</p>
</td></tr>
<tr><td><code id="r_dtrunc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code>n</code> observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100L
# the lower and upper bound are either scalar,
# or else vectors of length n
r_dtrunc_elife(n = n, scale = 1, shape = -0.1,
               lower = pmax(0, runif(n, -0.5, 1)),
               upper = runif(n, 6, 10),
               family = "gp")
</code></pre>

<hr>
<h2 id='r_ltrc_elife'>Sample observations from a left-truncated right-censored excess lifetime distribution</h2><span id='topic+r_ltrc_elife'></span>

<h3>Description</h3>

<p>Sample observations from a left-truncated right-censored excess lifetime distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_ltrc_elife(
  n,
  scale,
  rate,
  shape,
  lower,
  upper,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_ltrc_elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="r_ltrc_elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="r_ltrc_elife_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s)</p>
</td></tr>
<tr><td><code id="r_ltrc_elife_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds</p>
</td></tr>
<tr><td><code id="r_ltrc_elife_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds above which data are right-truncated</p>
</td></tr>
<tr><td><code id="r_ltrc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family, either exponential (<code>exp</code>), Weibull (<code>weibull</code>), generalized Pareto (<code>gp</code>), Gompertz (<code>gomp</code>) or extended generalized Pareto (<code>extgp</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with <code>n</code> observations <code>dat</code> and a logical vector of the same length with <code>TRUE</code> for right-censored observations and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100L
# the lower and upper bound are either scalar,
# or else vectors of length n
r_ltrc_elife(n = n, scale = 5, shape = -0.1,
               lower = pmax(0, runif(n, -0.5, 1)),
               upper = 5,
               family = "gp")
</code></pre>

<hr>
<h2 id='samp_elife'>Simulate excess lifetime with truncation or right-censoring</h2><span id='topic+samp_elife'></span>

<h3>Description</h3>

<p>This function dispatches simulations accounting for potential left-truncation (remove by setting lower to zero).
If <code>type2=ltrt</code>, simulated observations will be lower than the upper bounds <code>upper</code>.
If <code>type2=ltrc</code>, simulated observations are capped at <code>upper</code> and the observation is right-censored (<code>rcens=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp_elife(
  n,
  scale,
  rate,
  shape = NULL,
  lower = 0,
  upper = Inf,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  type2 = c("none", "ltrt", "ltrc", "ditrunc")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter(s)</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_rate">rate</code></td>
<td>
<p>rate parameter(s)</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s)</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="samp_elife_+3A_type2">type2</code></td>
<td>
<p>string, either <code>none</code>, <code>ltrt</code> for left- and right-truncated data or <code>ltrc</code> for left-truncated right-censored data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a vector of observations or, if <code>type2=ltrc</code>, a list with <code>n</code> observations <code>dat</code> and a logical vector of the same length with <code>TRUE</code> for right-censored observations and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 500L
# Simulate interval truncated data
x &lt;- samp_elife(n = n,
                scale = 2,
                shape = 1.5,
                lower = low &lt;- runif(n),
                upper = upp &lt;- runif(n, min = 3, max = 15),
                type2 = "ltrt",
                family = "weibull")
coef(fit_elife(
   time = x,
   ltrunc = low,
   rtrunc = upp,
   family = "weibull"))
# Simulate left-truncated right-censored data
x &lt;- samp_elife(n = n,
                scale = 2,
                shape = 1.5,
                lower = low &lt;- runif(n),
                upper = upp &lt;- runif(n, min = 3, max = 15),
                type2 = "ltrc",
                family = "gomp")
#note that the return value is a list...
coef(fit_elife(
   time = x$dat,
   ltrunc = low,
   event = !x$rcens,
   family = "gomp"))
</code></pre>

<hr>
<h2 id='samp2_elife'>Sample lifetime from excess lifetime model</h2><span id='topic+samp2_elife'></span>

<h3>Description</h3>

<p>Given parameters of a <code>elife</code> distribution, sampling window and
birth dates with excess lifetimes, sample new observations; excess lifetime
at <code>c1</code> are sampled from an exponential distribution, whereas
the birth dates are sampled from a jittered histogram-based distribution
The new excess lifetime above the threshold are right-censored if they exceed
<code>c2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp2_elife(
  n,
  scale,
  shape,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "gppiece",
    "extweibull", "perks", "beard", "perksmake", "beardmake"),
  xcal,
  c1,
  c2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp2_elife_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_scale">scale</code></td>
<td>
<p>scale parameter(s)</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_shape">shape</code></td>
<td>
<p>shape parameter(s)</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_xcal">xcal</code></td>
<td>
<p>date at which individual reaches <code>u</code> years</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_c1">c1</code></td>
<td>
<p>date, first day of the sampling frame</p>
</td></tr>
<tr><td><code id="samp2_elife_+3A_c2">c2</code></td>
<td>
<p>date, last day of the sampling frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with new birthdates (<code>xcal</code>), excess lifetime at <code>c1</code> (<code>ltrunc</code>),
excess lifetime above <code>u</code> (<code>dat</code>) and right-censoring indicator (<code>rightcens</code>).
</p>

<hr>
<h2 id='test_ditrunc_elife'>Likelihood ratio test for doubly interval truncated data</h2><span id='topic+test_ditrunc_elife'></span>

<h3>Description</h3>

<p>This function fits separate models for each distinct
value of covariates and computes a likelihood ratio test
to test whether there are significant differences between
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_ditrunc_elife(
  time,
  covariate,
  thresh = 0,
  ltrunc1 = NULL,
  rtrunc1 = NULL,
  ltrunc2 = NULL,
  rtrunc2 = NULL,
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp", "extweibull", "perks",
    "beard", "perksmake", "beardmake"),
  weights = rep(1, length(time)),
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_ditrunc_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_covariate">covariate</code></td>
<td>
<p>vector of factors, logical or integer whose distinct values are</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="test_ditrunc_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements
</p>

<ul>
<li> <p><code>stat</code>: likelihood ratio statistic
</p>
</li>
<li> <p><code>df</code>: degrees of freedom
</p>
</li>
<li> <p><code>pval</code>: the p-value obtained from the asymptotic chi-square approximation.
</p>
</li></ul>


<hr>
<h2 id='test_elife'>Likelihood ratio test for covariates</h2><span id='topic+test_elife'></span>

<h3>Description</h3>

<p>This function fits separate models for each distinct
value of the factor <code>covariate</code> and computes a likelihood ratio test
to test whether there are significant differences between
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_elife(
  time,
  time2 = NULL,
  event = NULL,
  covariate,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  family = c("exp", "gp", "weibull", "gomp", "gompmake", "extgp", "extweibull", "perks",
    "perksmake", "beard", "beardmake"),
  weights = rep(1, length(time)),
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_elife_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="test_elife_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="test_elife_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="test_elife_+3A_covariate">covariate</code></td>
<td>
<p>vector of factors, logical or integer whose distinct values define groups</p>
</td></tr>
<tr><td><code id="test_elife_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="test_elife_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="test_elife_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="test_elife_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="test_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
<tr><td><code id="test_elife_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="test_elife_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="test_elife_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements
</p>

<ul>
<li> <p><code>stat</code> likelihood ratio statistic
</p>
</li>
<li> <p><code>df</code> degrees of freedom
</p>
</li>
<li> <p><code>pval</code> the p-value obtained from the asymptotic chi-square approximation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- with(subset(dutch, ndays &gt; 39082),
 test_elife(
 time = ndays,
 thresh = 39082L,
 covariate = gender,
 ltrunc = ltrunc,
 rtrunc = rtrunc,
 family = "exp"))
 test
</code></pre>

<hr>
<h2 id='tstab'>Threshold stability plots</h2><span id='topic+tstab'></span>

<h3>Description</h3>

<p>The generalized Pareto and exponential distribution
are threshold stable. This property, which is used
for extrapolation purposes, can also be used to diagnose
goodness-of-fit: we expect the parameters <code class="reqn">\xi</code> and <code class="reqn">\tilde{\sigma} = \sigma + \xi u</code>
to be constant over a range of thresholds. The threshold stability
plot consists in plotting maximum likelihood estimates with pointwise confidence interval.
This function handles interval truncation and right-censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tstab(
  time,
  time2 = NULL,
  event = NULL,
  thresh = 0,
  ltrunc = NULL,
  rtrunc = NULL,
  type = c("right", "left", "interval", "interval2"),
  family = c("gp", "exp"),
  method = c("wald", "profile"),
  level = 0.95,
  plot = TRUE,
  plot.type = c("base", "ggplot"),
  which.plot = c("scale", "shape"),
  weights = NULL,
  arguments = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tstab_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="tstab_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="tstab_+3A_event">event</code></td>
<td>
<p>status indicator, normally 0=alive, 1=dead. Other choices are <code>TRUE</code>/<code>FALSE</code> (<code>TRUE</code> for death).
For interval censored data, the status indicator is 0=right censored, 1=event at time, 2=left censored, 3=interval censored.
Although unusual, the event indicator can be omitted, in which case all subjects are assumed to have experienced an event.</p>
</td></tr>
<tr><td><code id="tstab_+3A_thresh">thresh</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="tstab_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="tstab_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="tstab_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible values are &quot;<code>right</code>&quot;, &quot;<code>left</code>&quot;, &quot;<code>interval</code>&quot;, &quot;<code>interval2</code>&quot;.</p>
</td></tr>
<tr><td><code id="tstab_+3A_family">family</code></td>
<td>
<p>string; distribution, either generalized Pareto (<code>gp</code>) or exponential (<code>exp</code>)</p>
</td></tr>
<tr><td><code id="tstab_+3A_method">method</code></td>
<td>
<p>string; the type of pointwise confidence interval, either Wald (<code>wald</code>) or profile likelihood (<code>profile</code>)</p>
</td></tr>
<tr><td><code id="tstab_+3A_level">level</code></td>
<td>
<p>probability level for the pointwise confidence intervals</p>
</td></tr>
<tr><td><code id="tstab_+3A_plot">plot</code></td>
<td>
<p>logical; should a plot be returned alongside with the estimates? Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="tstab_+3A_plot.type">plot.type</code></td>
<td>
<p>string; either <code>base</code> for base R plots or <code>ggplot</code> for <code>ggplot2</code> plots</p>
</td></tr>
<tr><td><code id="tstab_+3A_which.plot">which.plot</code></td>
<td>
<p>string; which parameters to plot;</p>
</td></tr>
<tr><td><code id="tstab_+3A_weights">weights</code></td>
<td>
<p>weights for observations</p>
</td></tr>
<tr><td><code id="tstab_+3A_arguments">arguments</code></td>
<td>
<p>a named list specifying default arguments of the function that are common to all <code>elife</code> calls</p>
</td></tr>
<tr><td><code id="tstab_+3A_...">...</code></td>
<td>
<p>additional arguments for optimization, currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape estimates are constrained
</p>


<h3>Value</h3>

<p>an invisible list with pointwise estimates and confidence intervals for the scale and shape parameters
</p>


<h3>See Also</h3>

<p><code>tstab.gpd</code> from package <code>mev</code>, <code>gpd.fitrange</code> from package <code>ismev</code> or <code>tcplot</code> from package <code>evd</code>, among others.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 100L
x &lt;- samp_elife(n = n,
                scale = 2,
                shape = -0.2,
                lower = low &lt;- runif(n),
                upper = upp &lt;- runif(n, min = 3, max = 20),
                type2 = "ltrt",
                family = "gp")
tstab_plot &lt;- tstab(time = x,
                    ltrunc = low,
                   rtrunc = upp,
                   thresh = quantile(x, seq(0, 0.5, length.out = 4)))
plot(tstab_plot, plot.type = "ggplot")
</code></pre>

<hr>
<h2 id='turnbull_intervals'>Turnbull's sets</h2><span id='topic+turnbull_intervals'></span>

<h3>Description</h3>

<p>Given censoring and truncation set,
compute the regions of the real line that
get positive mass and over which the distribution
function is well-defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnbull_intervals(time, time2 = NULL, status, ltrunc = NULL, rtrunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turnbull_intervals_+3A_time">time</code></td>
<td>
<p>excess time of the event of follow-up time, depending on the value of event</p>
</td></tr>
<tr><td><code id="turnbull_intervals_+3A_time2">time2</code></td>
<td>
<p>ending excess time of the interval for interval censored data only.</p>
</td></tr>
<tr><td><code id="turnbull_intervals_+3A_ltrunc">ltrunc</code></td>
<td>
<p>lower truncation limit, default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="turnbull_intervals_+3A_rtrunc">rtrunc</code></td>
<td>
<p>upper truncation limit, default to <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with two columns containing the <code>left</code> and <code>right</code> bounds Of Turnbull sets
</p>


<h3>Note</h3>

<p>The function adds the square root of the machine tolerance to left bounds of interval censored data
so they are open.
</p>


<h3>References</h3>

<p>Frydman, H. (1994). <em>A Note on Nonparametric Estimation of the Distribution Function from Interval-Censored and Truncated Observations</em>, Journal of the Royal Statistical Society. Series B (Methodological) <b>56</b>(1), 71-74.
</p>
<p>Turnbull, B. W. (1976). <em>The Empirical Distribution Function with Arbitrarily Grouped, Censored and Truncated Data.</em> Journal of the Royal Statistical Society, Series B <b>38</b>, 290-295.
</p>

<hr>
<h2 id='uq1_qqplot_elife'>Uncertainty quantification for quantile-quantile plots</h2><span id='topic+uq1_qqplot_elife'></span>

<h3>Description</h3>

<p>Uncertainty quantification for quantile-quantile plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uq1_qqplot_elife(
  B = 9999L,
  dat,
  par,
  lower,
  upper,
  level = 0.95,
  type2 = c("none", "ltrt", "ltrc"),
  family = c("exp", "gp", "gomp", "gompmake", "weibull", "extgp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uq1_qqplot_elife_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_dat">dat</code></td>
<td>
<p>vector of data</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_par">par</code></td>
<td>
<p>parameter estimates of the model</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_lower">lower</code></td>
<td>
<p>lower bounds (truncation or lowest possible value)</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_upper">upper</code></td>
<td>
<p>upper bound for right-censoring or right-truncation</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_level">level</code></td>
<td>
<p>level of the confidence intervals</p>
</td></tr>
<tr><td><code id="uq1_qqplot_elife_+3A_family">family</code></td>
<td>
<p>string; choice of parametric family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with plotting positions for confidence intervals of quantile-quantile plots
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
