<!DOCTYPE html><html lang="en"><head><title>Help for package spate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spate-package'>
<p>Spatio-temporal modeling of large data with the spectral SPDE approach</p></a></li>
<li><a href='#cols'>
<p>Function that returns the color scale for 'image()'.</p></a></li>
<li><a href='#ffbs'>
<p>Forward Filtering Backward Sampling algorithm.</p></a></li>
<li><a href='#ffbs.spectral'>
<p>Forward Filtering Backward Sampling algorithm in the spectral space of</p>
the SPDE.</a></li>
<li><a href='#get.propagator'>
<p>Propagator matrix G.</p></a></li>
<li><a href='#get.propagator.vec'>
<p>Propagator matrix G in vector form.</p></a></li>
<li><a href='#get.real.dft.mat'>
<p>Matrix applying the two-dimensional real Fourier transform.</p></a></li>
<li><a href='#index.complex.to.real.dft'>
<p>Auxilary function for the real Fourier transform.</p></a></li>
<li><a href='#innov.spec'>
<p>Spectrum of the innovation term epsilon.</p></a></li>
<li><a href='#lin.pred'>
<p>Linear predictor.</p></a></li>
<li><a href='#loglike'>
<p>Log-likelihood of the hyperparameters.</p></a></li>
<li><a href='#map.obs.to.grid'>
<p>Maps non-gridded data to a grid.</p></a></li>
<li><a href='#matern.spec'>
<p>Spectrum of the Matern covariance function.</p></a></li>
<li><a href='#mcmc.summary'>
<p>Summary function for MCMC output.</p></a></li>
<li><a href='#Palpha'>
<p>Prior for direction of anisotropy in diffusion parameter alpha.</p></a></li>
<li><a href='#Pgamma'>
<p>Prior for amount of anisotropy in diffusion parameter gamma.</p></a></li>
<li><a href='#Plambda'>
<p>Prior for transformation parameter of the Tobit model.</p></a></li>
<li><a href='#plot.spateMCMC'>
<p>Plot fitted spateMCMC objects.</p></a></li>
<li><a href='#plot.spateSim'>
<p>Plotting function for 'spateSim' objects.</p></a></li>
<li><a href='#Pmux'>
<p>Prior for y-component of drift.</p></a></li>
<li><a href='#Pmuy'>
<p>Prior for y-component of drift.</p></a></li>
<li><a href='#post.dist.hist'>
<p>Histogram of posterior distributions.</p></a></li>
<li><a href='#Prho0'>
<p>Prior for range parameter rho0 of innovation epsilon.</p></a></li>
<li><a href='#Prho1'>
<p>Prior for range parameter rho1 of diffusion.</p></a></li>
<li><a href='#print.spateMCMC'>
<p>Print function for spateMCMC objects.</p></a></li>
<li><a href='#print.spateSim'>
<p>Print function for 'spateSim' objects.</p></a></li>
<li><a href='#propagate.spectral'>
<p>Function that propagates a state (spectral coefficients).</p></a></li>
<li><a href='#Psigma2'>
<p>Prior for for variance parameter sigma2 of innovation epsilon.</p>
</p>
<p>hyperparameter.</p></a></li>
<li><a href='#Ptau2'>
<p>Prior for nugget effect parameter tau2.</p></a></li>
<li><a href='#Pzeta'>
<p>Prior for damping parameter zeta.</p></a></li>
<li><a href='#real.fft'>
<p>Fast calculation of the two-dimensional real Fourier transform.</p></a></li>
<li><a href='#real.fft.TS'>
<p>Fast calculation of the two-dimensional real Fourier transform of a space-time field. For</p>
each time point, the spatial field is transformed.</a></li>
<li><a href='#sample.four.coef'>
<p>Sample from the full conditional of the Fourier coefficients.</p></a></li>
<li><a href='#spate.init'>
<p>Constructor for 'spateFT' object which are used for the two-dimensional</p>
Fourier transform.</a></li>
<li><a href='#spate.mcmc'>
<p>MCMC algorithm for fitting the model.</p></a></li>
<li><a href='#spate.plot'>
<p>Plot a spatio-temporal field.</p></a></li>
<li><a href='#spate.predict'>
<p>Obtain samples from predictive distribution in space and time.</p></a></li>
<li><a href='#spate.sim'>
<p>Simulate from the SPDE.</p></a></li>
<li><a href='#spateMCMC.RData'><p>'spateMCMC' object output obtained from 'spate.mcmc'.</p></a></li>
<li><a href='#spateMLE.RData'><p>Maximum likelihood estimate for SPDE model with Gaussian observations.</p></a></li>
<li><a href='#summary.spateSim'>
<p>Summary function for 'spateSim' objects.</p></a></li>
<li><a href='#tobit.lambda.log.full.cond'>
<p>Full conditional for transformation parameter lambda.</p></a></li>
<li><a href='#trace.plot'>
<p>Trace plots for MCMC output analysis.</p></a></li>
<li><a href='#TSmat.to.vect'>
<p>Converts a matrix stacked vector.</p></a></li>
<li><a href='#vect.to.TSmat'>
<p>Converts a stacked vector into matrix.</p></a></li>
<li><a href='#vnorm'>
<p>Eucledian norm of a vector</p></a></li>
<li><a href='#wave.numbers'>
<p>Wave numbers.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatio-Temporal Modeling of Large Data Using a Spectral SPDE
Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabio Sigrist, Hans R. Kuensch, Werner A. Stahel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabio Sigrist &lt;fabiosigrist@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), mvtnorm, truncnorm</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw3 (&gt;= 3.1.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for spatio-temporal modeling of large data sets is provided. A Gaussian process in space and time is defined through a stochastic partial differential equation (SPDE). The SPDE is solved in the spectral space, and after discretizing in time and space, a linear Gaussian state space model is obtained. When doing inference, the main computational difficulty consists in evaluating the likelihood and in sampling from the full conditional of the spectral coefficients, or equivalently, the latent space-time process. In comparison to the traditional approach of using a spatio-temporal covariance function, the spectral SPDE approach is computationally advantageous. See Sigrist, Kuensch, and Stahel (2015) &lt;<a href="https://doi.org/10.1111%2Frssb.12061">doi:10.1111/rssb.12061</a>&gt; for more information on the methodology. This package aims at providing tools for two different modeling approaches. First, the SPDE based spatio-temporal model can be used as a component in a customized hierarchical Bayesian model (HBM). The functions of the package then provide parameterizations of the process part of the model as well as computationally efficient algorithms needed for doing inference with the HBM. Alternatively, the adaptive MCMC algorithm implemented in the package can be used as an algorithm for doing inference without any additional modeling. The MCMC algorithm supports data that follow a Gaussian or a censored distribution with point mass at zero. Covariates can be included in the model through a regression term.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-03 07:12:28 UTC; fabiosigrist</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-03 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spate-package'>
Spatio-temporal modeling of large data with the spectral SPDE approach
</h2><span id='topic+spate-package'></span><span id='topic+spate'></span>

<h3>Description</h3>

<p>This is an R package for spatio-temporal modeling of large data sets. It provides tools for modeling of Gaussian processes in space and time defined through a stochastic partial differential equation (SPDE). The SPDE is solved in the spectral space, and after discretizing in time and space, a linear Gaussian state space model is obtained. When doing inference, the main computational difficulty consists in evaluating the likelihood and in sampling from the full conditional of the spectral coefficients, or equivalently, the latent space-time process. In comparison to the traditional approach of using a spatio-temporal covariance function, the spectral SPDE approach is computationally advantageous. This package aims at providing tools for two different modeling approaches. First, the SPDE based spatio-temporal model can be used as a component in a customized hierarchical Bayesian model (HBM). The functions of the package then provide parametrizations of the process part of the model as well as computationally efficient algorithms needed for doing inference with the HBM. Alternatively, the adaptive MCMC algorithm implemented in the package can be used as an algorithm for doing inference without any additional modeling. The MCMC algorithm supports data that follow a Gaussian or a censored distribution with point mass at zero. Covariates can be included in the model through a regression term.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist, Hans R. Kuensch, Werner A. Stahel
</p>
<p>Maintainer: Fabio Sigrist &lt;sigrist@stat.math.ethz.ch&gt; 
</p>


<h3>References</h3>

<p>Fabio Sigrist, Hans R. K\&quot;unsch, and Werner A. Stahel, &quot;Stochastic Partial Differential Equation Based Modeling of Large Space-Time Data Sets&quot;, Journal of the Royal Statistical Society: Series B, Volume 77, Issue 1, 2015, pages 3-33
</p>
<p>Fabio Sigrist, Hans R. Kuensch, Werner A. Stahel, &quot;spate: An R Package for Spatio-Temporal Modeling with a Stochastic Advection-Diffusion Process.&quot;, Journal of Statistical Software, Volume 63, Number 14, 2015, pages 1-23, URL http://www.jstatsoft.org/v63/i14/
</p>

<hr>
<h2 id='cols'>
Function that returns the color scale for 'image()'.
</h2><span id='topic+cols'></span>

<h3>Description</h3>

<p>Function that returns the color scale for 'image()'. This function is a
simplification of the function 'tim.colors()' from the 'fields' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cols()
</code></pre>


<h3>Value</h3>

<p>A vector with colors.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>References</h3>

<p>Fields Development Team (2006). fields: Tools for Spatial Data. National Center for Atmospheric Research, Boulder, CO. URL http://www.cgd.ucar.edu/Software/Fields. 
</p>

<hr>
<h2 id='ffbs'>
Forward Filtering Backward Sampling algorithm.
</h2><span id='topic+ffbs'></span>

<h3>Description</h3>

<p>Forward Filtering Backward Sampling algorithm for sampling from the
joint full conditional of the hidden state of a linear, Gaussian state
space model. To be more specific, one samples from <code class="reqn">P[\alpha|.]</code> where
<code class="reqn">\alpha</code> is specified through
</p>
<p style="text-align: center;"><code class="reqn">y_t = lp_t + H xi_t + nu_t,  \nu_t ~ N(0,\Omega)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\alpha_t = G \alpha_{t-1} + \epsilon_t,  \epsilon_t ~
  N(0,\Sigma).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ffbs(y, lp, G, Sigma, H, Omega, N = dim(y)[2],T = dim(y)[1],
      NF = dim(G)[1], lglk = FALSE, BwSp = TRUE, filt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffbs_+3A_y">y</code></td>
<td>
<p>Observed data in an T x N matrix with columns and rows corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_lp">lp</code></td>
<td>

<p>Mean (linear predictor) in an T x N matrix with columns and rows corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_g">G</code></td>
<td>

<p>Propagator matrix of the latent process <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_sigma">Sigma</code></td>
<td>

<p>Innovation covariance matrix of the latent process <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_h">H</code></td>
<td>

<p>Observation matrix relating y to <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_omega">Omega</code></td>
<td>

<p>Covariance matrix of the observation error <code class="reqn">\nu</code>.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_n">N</code></td>
<td>

<p>Number of points in space.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_t">T</code></td>
<td>

<p>Number of points in time.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_nf">NF</code></td>
<td>

<p>Dimension of the latent process <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_lglk">lglk</code></td>
<td>

<p>Logical; if 'TRUE' the value of the log-likelihood is returned as well.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_bwsp">BwSp</code></td>
<td>

<p>Logical; if 'TRUE' a sample from the full conditional of <code class="reqn">\alpha</code> is returned.
</p>
</td></tr>
<tr><td><code id="ffbs_+3A_filt">filt</code></td>
<td>

<p>Logical; if 'TRUE' the filtered values for <code class="reqn">\alpha</code> are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the context of the SPDE, <code class="reqn">\alpha</code> are the Fourier coefficients.</p>


<h3>Value</h3>

<p>A list with entries (depending on whether 'lglk', 'BwSp', 'filt' are
'TRUE' or 'FALSE'):
</p>
<table role = "presentation">
<tr><td><code>simAlpha</code></td>
<td>
<p>A T x N matrix with a sample from the full conditional
of latent process <code class="reqn">\alpha</code>,</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>The evaluated log-likelihood,</p>
</td></tr>
<tr><td><code>mtt</code></td>
<td>
<p>A T x N matrix with the mean of the full conditional of latent process <code class="reqn">\alpha</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='ffbs.spectral'>
Forward Filtering Backward Sampling algorithm in the spectral space of
the SPDE.
</h2><span id='topic+ffbs.spectral'></span>

<h3>Description</h3>

<p>Forward Filtering Backward Sampling algorithm for sampling from the
joint full conditional of the coefficients <code class="reqn">\alpha</code> and for
evaluation of the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffbs.spectral(w=NULL,wFT=NULL,spec=NULL,Gvec=NULL,tau2=NULL,par=NULL,n,T,lglk=FALSE,
              BwSp=TRUE,NF=n*n,indCos=(1:((n*n-4)/2)*2+3),ns=4,nu=1,dt=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffbs.spectral_+3A_w">w</code></td>
<td>
<p>Observed data or latent process w (depending on which data
model is used) in an T x n*n matrix with columns and rows (points on a
grid stacked into a vector) corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_wft">wFT</code></td>
<td>

<p>Vector of length T*n*n containing the real Fourier transform of 'w'.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_spec">spec</code></td>
<td>

<p>Spectrum of the innovations <code class="reqn">\hat{\epsilon}</code> in a vector of length
n*n. If 'spec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_gvec">Gvec</code></td>
<td>

<p>The propagator matrix G in vector format obtained from 'get.G.vec'. If 'Gvec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_tau2">tau2</code></td>
<td>

<p>Measurement error variance tau2. If 'NULL'; tau2=par[9].
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_par">par</code></td>
<td>
<p> Vector of parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2. If 'spec' and 'Gvec' are
given, 'par' will not be used.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_n">n</code></td>
<td>
<p>Number of grid points on each axis. n*n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_t">T</code></td>
<td>

<p>Number of points in time.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_lglk">lglk</code></td>
<td>

<p>Logical; if 'TRUE' the value of the log-likelihood is returned as well.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_bwsp">BwSp</code></td>
<td>

<p>Logical; if 'TRUE' a sample from the full conditional of <code class="reqn">\alpha</code> is returned.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_nf">NF</code></td>
<td>

<p>Number of Fourier functions used.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_indcos">indCos</code></td>
<td>
<p>Vector of integers indicating the position cosine terms in
the 1:NF real Fourier functions. The first 'ns' cosine wavenumbers in 'wave' are not included in 'indCos'.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_ns">ns</code></td>
<td>

<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_nu">nu</code></td>
<td>
<p> Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.</p>
</td></tr>
<tr><td><code id="ffbs.spectral_+3A_dt">dt</code></td>
<td>
<p> Temporal lag between two time points. By default, this equals 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries (depending on whether 'lglk' are 'BwSp' are
'TRUE' or 'FALSE'):
</p>
<table role = "presentation">
<tr><td><code>simAlpha</code></td>
<td>
<p>A T x n*n matrix with a sample from the full conditional
of latent process <code class="reqn">\alpha</code>,</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>The evaluated log-likelihood,</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='get.propagator'>
Propagator matrix G.
</h2><span id='topic+get.propagator'></span>

<h3>Description</h3>

<p>Function for obtaining the spectral propagator matrix G of the vector autoregressive model
for the Fourier coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.propagator(wave, indCos, zeta, rho1, gamma, alpha, muX, muY, dt = 1, ns=4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.propagator_+3A_wave">wave</code></td>
<td>

<p>Spatial wavenumbers.
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_indcos">indCos</code></td>
<td>

<p>Vector of integers indicating the position of columns in 'wave' of wavenumbers of cosine terms.
</p>
</td></tr> 
<tr><td><code id="get.propagator_+3A_zeta">zeta</code></td>
<td>

<p>Damping parameter
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_rho1">rho1</code></td>
<td>

<p>Range parameter of the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_gamma">gamma</code></td>
<td>

<p>Parameter that determines the amount of anisotropy in the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_alpha">alpha</code></td>
<td>

<p>Parameter that determines the direction of anisotropy in the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_mux">muX</code></td>
<td>

<p>X component of the drift vector.
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_muy">muY</code></td>
<td>

<p>Y component of the drift vector.
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_dt">dt</code></td>
<td>

<p>Temporal lag between two time points. By default, this equals 1.
</p>
</td></tr>
<tr><td><code id="get.propagator_+3A_ns">ns</code></td>
<td>
<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Propagator matrix G.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##For illustration, four grid points on each axis
n &lt;- 4
wave &lt;- wave.numbers(n)
G &lt;- get.propagator(wave=wave$wave,indCos=wave$indCos,zeta=0.5, rho1=0.1, gamma=2,
           alpha=pi/4, muX=0.2, muY=-0.15,dt=1,ns=4)
round(G,digits=2)
## View(round(G,digits=2))

##An example
n &lt;- 50
spec &lt;- matern.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
alphat &lt;- sqrt(spec)*rnorm(n*n)
##Propagate initial state
wave &lt;- wave.numbers(n)
G &lt;- get.propagator(wave=wave$wave,indCos=wave$indCos,zeta=0.5, rho1=0.02, gamma=2,
            alpha=pi/4, muX=0.2, muY=0.2,dt=1,ns=4)
alphat1 &lt;- G%*%alphat

opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
image(1:n,1:n,matrix(real.fft(alphat,n=n,inv=FALSE),nrow=n),main="Whittle
field",xlab="",ylab="",col=cols())
image(1:n,1:n,matrix(real.fft(alphat1,n=n,inv=FALSE),nrow=n),main="Propagated
field",xlab="",ylab="",col=cols())
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='get.propagator.vec'>
Propagator matrix G in vector form.
</h2><span id='topic+get.propagator.vec'></span>

<h3>Description</h3>

<p>Function for obtaining the spectral propagator matrix G of the vector autoregressive model
for the Fourier coefficients in vector form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.propagator.vec(wave, indCos, zeta, rho1, gamma, alpha, muX, muY, dt = 1,ns=4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.propagator.vec_+3A_wave">wave</code></td>
<td>

<p>Spatial wavenumbers.
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_indcos">indCos</code></td>
<td>

<p>Vector of integers indicating the position of columns in 'wave' of wavenumbers of cosine terms.
</p>
</td></tr> 
<tr><td><code id="get.propagator.vec_+3A_zeta">zeta</code></td>
<td>

<p>Damping parameter
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_rho1">rho1</code></td>
<td>

<p>Range parameter of the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_gamma">gamma</code></td>
<td>

<p>Parameter that determines the amount of anisotropy in the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_alpha">alpha</code></td>
<td>

<p>Parameter that determines the direction of anisotropy in the diffusion term
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_mux">muX</code></td>
<td>

<p>X component of the drift vector.
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_muy">muY</code></td>
<td>

<p>Y component of the drift vector.
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_dt">dt</code></td>
<td>

<p>Temporal lag between two time points. By default, this equals 1.
</p>
</td></tr>
<tr><td><code id="get.propagator.vec_+3A_ns">ns</code></td>
<td>
<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements 'G11C', 'G11', and 'G12'. The first element contains a vector of
length 'ns' which corresponds to the diagonal propagator of the
cosin-only terms. The second element contains the remaining diagonal
entries of G, i.e., the diagonal entries of the propagator for the
cosine / sine pairs. Note that for each pair, only one value is taken
since the diagonal elements for both the cosin and sine terms are equal. The third element is a vector with the off-diagonal
terms of the propagator for the cosine / sine pairs.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##For illustration, four grid points on each axis
n &lt;- 4
wave &lt;- wave.numbers(n)
G &lt;- get.propagator(wave=wave$wave,indCos=wave$indCos,zeta=0.5, rho1=0.1,
           gamma=2,alpha=pi/4, muX=0.2, muY=-0.15,dt=1,ns=4)
diag(G)[1:4]
diag(G[wave$indCos,wave$indCos])
diag(G[wave$indCos,wave$indCos+1])
get.propagator.vec(wave=wave$wave,indCos=wave$indCos,zeta=0.5, rho1=0.1,
gamma=2,alpha=pi/4, muX=0.2, muY=-0.15,dt=1,ns=4)
</code></pre>

<hr>
<h2 id='get.real.dft.mat'>
Matrix applying the two-dimensional real Fourier transform.
</h2><span id='topic+get.real.dft.mat'></span>

<h3>Description</h3>

<p>Returns the matrix that applies the two-dimensional real Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.real.dft.mat(wave, indCos, ns = 4, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.real.dft.mat_+3A_wave">wave</code></td>
<td>

<p>Matrix of size 2 x NF with spatial wavenumbers. NF is the number of
Fourier functions. 
</p>
</td></tr>
<tr><td><code id="get.real.dft.mat_+3A_indcos">indCos</code></td>
<td>

<p>Vector of integers indicating the position of columns in 'wave' of wavenumbers of cosine terms.
</p>
</td></tr> 
<tr><td><code id="get.real.dft.mat_+3A_ns">ns</code></td>
<td>
<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
<tr><td><code id="get.real.dft.mat_+3A_n">n</code></td>
<td>
<p> Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that applies the two-dimensional real Fourier transform.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example nr. 1: sampling from a Matern field
n &lt;- 50
spateFT &lt;- spate.init(n=n,T=1)
spec &lt;- matern.spec(wave=spateFT$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
Phi &lt;- get.real.dft.mat(wave=spateFT$wave, indCos=spateFT$indCos, n=n)
sim &lt;- Phi %*% (sqrt(spec)*rnorm(n*n))
image(1:n,1:n,matrix(sim,nrow=n),main="Sample from Matern field",xlab="",ylab="")

##Example nr. 2: image reconstruction
n &lt;- 50##Number of points on each axis
##Low-dimensional: only 41 Fourier functions
spateFT &lt;- spate.init(n=n,T=17,NF=45)
Phi.LD &lt;- get.real.dft.mat(wave=spateFT$wave, indCos=spateFT$indCos, ns=spateFT$ns, n=n)
##Mid-dimensional: 545 (of potentially 2500) Fourier functions
spateFT &lt;- spate.init(n=n,T=17,NF=101)
Phi.MD &lt;- get.real.dft.mat(wave=spateFT$wave, indCos=spateFT$indCos, ns=spateFT$ns, n=n)
##High-dimensional: all 2500 Fourier functions
spateFT &lt;- spate.init(n=n,T=17,NF=2500)
Phi.HD &lt;- get.real.dft.mat(wave=spateFT$wave, indCos=spateFT$indCos, ns=spateFT$ns, n=n)
##Define image
image &lt;- rep(0,n*n)
for(i in 1:n){
  for(j in 1:n){    
    image[(i-1)*n+j] &lt;- cos(5*(i-n/2)/n*pi)*sin(5*(j)/n*pi)*(1-abs(i/n-1/2)-abs(j/n-1/2))
  }
}
opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2),mar=c(2,3,2,1))
image(1:n, 1:n, matrix(image, nrow = n),col = cols(),xlab="",ylab="",main="Original image")
##Aply inverse Fourier transform, dimension reduction, and Fourier transform
spec.LD &lt;- t(Phi.LD) %*% image
image.LD &lt;- Phi.LD %*% spec.LD
spec.MD &lt;- t(Phi.MD) %*% image
image.MD &lt;- Phi.MD %*% spec.MD
spec.HD &lt;- t(Phi.HD) %*% image
image.HD &lt;- Phi.HD %*% spec.HD
image(1:n, 1:n, matrix(image.LD, nrow = n),col = cols(),
      xlab="",ylab="",main="45 of 2500 Fourier terms")
image(1:n, 1:n, matrix(image.MD, nrow = n),col = cols(),
      xlab="",ylab="",main="101 of 2500 Fourier terms")
image(1:n, 1:n, matrix(image.HD, nrow = n),col = cols(),
      xlab="",ylab="",main="All 2500 Fourier terms")
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='index.complex.to.real.dft'>
Auxilary function for the real Fourier transform.
</h2><span id='topic+index.complex.to.real.dft'></span>

<h3>Description</h3>

<p>Auxilary function for the conversion between the complex FFT and the real Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.complex.to.real.dft(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.complex.to.real.dft_+3A_n">n</code></td>
<td>

<p>Number of points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A a list of indices used for the conversion between the complex FFT and the real Fourier transform.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='innov.spec'>
Spectrum of the innovation term epsilon.
</h2><span id='topic+innov.spec'></span>

<h3>Description</h3>

<p>Spectrum of the innovation term epsilon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innov.spec(wave,n,ns=4,rho0,sigma2,zeta,rho1,alpha,gamma,nu=1,dt=1,norm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="innov.spec_+3A_wave">wave</code></td>
<td>

<p>Spatial wavenumbers.
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_ns">ns</code></td>
<td>
<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_rho0">rho0</code></td>
<td>

<p>Range of the Matern covariance funtion for the innovation term epsilon
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_sigma2">sigma2</code></td>
<td>

<p>Marginal variance of the Matern covariance funtion for the innovation term epsilon
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_zeta">zeta</code></td>
<td>

<p>Damping parameter
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_rho1">rho1</code></td>
<td>

<p>Range parameter of the diffusion term
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_alpha">alpha</code></td>
<td>

<p>Parameter that determines the direction of anisotropy in the diffusion term
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_gamma">gamma</code></td>
<td>

<p>Parameter that determines the amount of anisotropy in the
diffusion term
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_nu">nu</code></td>
<td>

<p>Smoothness parameter of the Matern covariance function for the innovations. By
default, this equals 1 corresponding to the Whittle covariance function.
</p>
</td></tr>  
<tr><td><code id="innov.spec_+3A_dt">dt</code></td>
<td>

<p>Temporal lag between two time points. By default, this equals 1.
</p>
</td></tr>
<tr><td><code id="innov.spec_+3A_norm">norm</code></td>
<td>
<p>logical; if 'TRUE' the spectrum is multiplied by n*n so that after
applying the real Fourier transform 'real.FFT' one has the correct normalization.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the spectrum of the integrated innovation term epsilon hat.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
spec &lt;- innov.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=0.5,zeta=0.5,
                   rho1=0.05,alpha=pi/4,gamma=2,norm=TRUE)
sim &lt;- real.fft(sqrt(spec)*rnorm(n*n),n=n,inv=FALSE)
image(1:n,1:n,matrix(sim,nrow=n),main="Sample from the integrated
stochastic innovation",xlab="",ylab="",col=cols())
</code></pre>

<hr>
<h2 id='lin.pred'>
Linear predictor.
</h2><span id='topic+lin.pred'></span>

<h3>Description</h3>

<p>Calculates the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.pred(x, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin.pred_+3A_x">x</code></td>
<td>
<p>Covariates in an array of dimensions p x T X N, where p denotes the
number of covariates, T the number of time points, and N the number of
spatial points.
</p>
</td></tr>
<tr><td><code id="lin.pred_+3A_beta">beta</code></td>
<td>

<p>Coefficients of covariates in a vector of length p.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension T x N with linear predictors.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='loglike'>
Log-likelihood of the hyperparameters.
</h2><span id='topic+loglike'></span>

<h3>Description</h3>

<p>Evaluates the log-likelihood of the hyperparameters given the data (Gaussian case) or
given the latent variable w (in the Tobit case).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike(par=NULL,w=NULL,wFT=NULL,x=NULL,spec=NULL,Gvec=NULL,tau2=NULL,n,T,
         NF=n*n,indCos=(1:((n*n-4)/2)*2+3),ns=4,nu=1,dt=1,logScale=FALSE,
         logInd=c(1,2,3,4,5,9),negative=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglike_+3A_par">par</code></td>
<td>
<p> Vector of parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2, regression coefficients beta. rho_0 and sigma^2 are the range
and marginal variance of the Whittle covariance funtion for the
innovation term epsilon. zeta is the damping parameter. rho_1, gamma,
and alpha parametrize the diffusion matrix with rho_1 being a range
parameter, gamma and alpha determining the amount and the direction,
respectively, of anisotropy. mu_x and mu_y are the two components of
the drift vector. tau^2 denotes the variance of nugget effect or
measurment error. Subsequently in par are the
regression coefficients beta, if there are covariates.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_w">w</code></td>
<td>

<p>Matrix of size T x N, where T and N denote the number of points in time
and space. In the case of a Gaussian data model, w contains the
observed values, with the Tobit model, w denotes the latent normal variable.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_wft">wFT</code></td>
<td>
<p> A vector with the (discrete) Fourier transform of the observed or latent w, depending
on which data model is used. Note that, in contrast to w, this needs to
be in stacked vector format. Use 'TSmat.to.vect'.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_x">x</code></td>
<td>
<p> Covariates in an array of dimensions p x T X N, where p denotes the
number of covariates, T the number of time points, and n the number of
spatial points.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_spec">spec</code></td>
<td>

<p>A vector containing the spectrum of the innovation term epsilon. If 'spec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_gvec">Gvec</code></td>
<td>

<p>The propagator matrix G in vector format obtained from 'get.G.vec'. If 'Gvec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_tau2">tau2</code></td>
<td>

<p>Measurement error variance tau2. If 'NULL'; tau2=par[9].
</p>
</td></tr>
<tr><td><code id="loglike_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_t">T</code></td>
<td>

<p>Number of points in time.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_nf">NF</code></td>
<td>
<p>Number of Fourier functions.</p>
</td></tr>
<tr><td><code id="loglike_+3A_indcos">indCos</code></td>
<td>
<p> Vector of integers indicating the position of wavenumbers of cosine-only terms. </p>
</td></tr>
<tr><td><code id="loglike_+3A_ns">ns</code></td>
<td>
<p> Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.</p>
</td></tr>
<tr><td><code id="loglike_+3A_nu">nu</code></td>
<td>
<p> Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.</p>
</td></tr>
<tr><td><code id="loglike_+3A_dt">dt</code></td>
<td>
<p> Temporal lag between two time points. By default, this equals 1.</p>
</td></tr>
<tr><td><code id="loglike_+3A_logscale">logScale</code></td>
<td>

<p>logical; if 'TRUE' the parameters specified in 'logInd' are on the
logarithmic scale. This is used for constraining parameters to be positive.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_logind">logInd</code></td>
<td>

<p>Vector of integers indicating which parameters are on the log-scale.
</p>
</td></tr>
<tr><td><code id="loglike_+3A_negative">negative</code></td>
<td>

<p>logical; if 'TRUE' the negative log-likelihood is returned otherwise the
positive log-likelihood is returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the log-likelihood evaluated at 'par'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
T &lt;- 20
##Specify hyper-parameters
par &lt;- c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01)
##Simulate data
spateSim &lt;- spate.sim(par=par,n=n,T=T,seed=4)
w &lt;- spateSim$w

##Initial values for optim. This takes a couple of seconds.
parI &lt;- c(rho0=0.2,sigma2=0.1,zeta=0.25,rho1=0.01,gamma=1,alpha=0.3,muX=0,muY=0,tau2=0.005)
logInd=c(1,2,3,4,5,9)
##Transform to log-scale
parI[logInd] &lt;- log(parI[logInd])

##Fourier transform needs to be done only once
wFT &lt;- real.fft.TS(w,n=n,T=T)
##ML estimation using optim, takes a couple of seconds
##Load the precomputed object a line below to save time
##spateMLE &lt;- optim(par=parI,loglike,control=list(trace=TRUE,maxit=1000),wFT=wFT,method="L-BFGS-B",
##     lower=c(-10,-10,-10,-10,-10,0,-0.5,-0.5,-10),
##     upper=c(10,10,10,10,10,pi/2,0.5,0.5,10),negative=TRUE,
##     logScale=TRUE,hessian=TRUE,n=n,T=T)
data("spateMLE")

mle &lt;- spateMLE$par
mle[logInd] &lt;- exp(mle[logInd])
sd=sqrt(diag(solve(spateMLE$hessian)))

MleConfInt &lt;- data.frame(array(0,c(4,9)))
colnames(MleConfInt) &lt;- names(par)
rownames(MleConfInt) &lt;- c("True","Estimate","Lower","Upper")
MleConfInt[1,] &lt;- par
MleConfInt[2,] &lt;- mle
MleConfInt[3,] &lt;- spateMLE$par-2*sd
MleConfInt[4,] &lt;- spateMLE$par+2*sd
MleConfInt[c(3,4),logInd] &lt;- exp(MleConfInt[c(3,4),logInd])
cat("\n")
round(MleConfInt,digits=4)

</code></pre>

<hr>
<h2 id='map.obs.to.grid'>
Maps non-gridded data to a grid.
</h2><span id='topic+map.obs.to.grid'></span>

<h3>Description</h3>

<p>Maps non-gridded data to a grid based on the coordinates supplied. Cells with no data are NA. For cells with more than one data point, the average is taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.obs.to.grid(n,y.non.grid,coord,lengthx=NULL,lengthy=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map.obs.to.grid_+3A_y.non.grid">y.non.grid</code></td>
<td>

<p>Observed data in an T x N matrix with columns and rows corresponding to
time and space, respectively. The coordinates of each observation point need to be specified in 'coord'. 
</p>
</td></tr>  
<tr><td><code id="map.obs.to.grid_+3A_coord">coord</code></td>
<td>

<p>Matrix of dimension N x 2 with coordinates of the N observation points. Based on to these coordinates, each observation location is then mapped to a grid cell.
</p>
</td></tr>
<tr><td><code id="map.obs.to.grid_+3A_lengthx">lengthx</code></td>
<td>

<p>Use together with 'coord' to specify the length of the x-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
x-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="map.obs.to.grid_+3A_lengthy">lengthy</code></td>
<td>

<p>Use together with 'coord' to specify the length of the y-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
y-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="map.obs.to.grid_+3A_n">n</code></td>
<td>

<p>Number of point per axis of the square into which the points are
mapped. In total, the process is modeled on a grid of size n*n.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns data in an T x n^2 matrix with columns and rows corresponding to time and space, respectively. Cells with no data are NA. For cells with more than one data point, the average is taken.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See code of 'spate.mcmc'.

</code></pre>

<hr>
<h2 id='matern.spec'>
Spectrum of the Matern covariance function.
</h2><span id='topic+matern.spec'></span>

<h3>Description</h3>

<p>Spectrum of the Matern covariance function. Note that the spectrum is
renormalized, by dividing with the sum over all frequencies so that
they sum to one, so that
<code class="reqn">\sigma^2</code> is the marginal variance no matter how many
wavenumbers are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern.spec(wave, n, ns=4, rho0, sigma2, nu = 1, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.spec_+3A_wave">wave</code></td>
<td>

<p>Spatial wavenumbers.
</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_ns">ns</code></td>
<td>
<p>Integer indicating the number of cosine-only terms. Maximally
this is 4.</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_rho0">rho0</code></td>
<td>

<p>Range parameter.
</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_sigma2">sigma2</code></td>
<td>

<p>Marginal variance parameter.
</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_nu">nu</code></td>
<td>

<p>Smoothness parameter of the Matern covariance function. By default this equals 1 corresponding to the Whittle covariance function.
</p>
</td></tr>
<tr><td><code id="matern.spec_+3A_norm">norm</code></td>
<td>

<p>logical; if 'TRUE' the spectrum is multiplied by n*n so that after
applying the real Fourier transform 'real.FFT' one has the correct normalization.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matern covariance function is of the form
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2 2^(1-\nu) \Gamma(\nu)^{-1} (d/\rho_0)^{\nu} K_{\nu}(d/\rho_0)</code>
</p>

<p>with 'd' being the  Euclidean distance between two points and K_nu(.)
a modified Bessel function. Its spectrum is given by
</p>
<p style="text-align: center;"><code class="reqn">2^{\nu-1} \nu ((1/\rho_0)^(2\nu)) (\pi*((1/\rho_0)^2 + w)^(\nu + 1))^{-1}</code>
</p>
  
<p>where 'w' is a spatial wavenumber.
</p>


<h3>Value</h3>

<p>Vector with the spectrum of the Matern covariance function.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
spec &lt;- matern.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
sim &lt;- real.fft(sqrt(spec)*rnorm(n*n),n=n,inv=FALSE)
image(1:n,1:n,matrix(sim,nrow=n),main="Sample from a Gaussian process
with Matern covariance function",xlab="",ylab="",col=cols())
</code></pre>

<hr>
<h2 id='mcmc.summary'>
Summary function for MCMC output.
</h2><span id='topic+mcmc.summary'></span>

<h3>Description</h3>

<p>Auxilary function for summarizing MCMC output and illustrating the posterior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.summary(data, probs = c(0.025, 0.5, 0.975), mean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.summary_+3A_data">data</code></td>
<td>

<p>Matrix of size p x Nmc where p denotes the number of parameters and Nmc
the number of MCMC samples.
</p>
</td></tr>
<tr><td><code id="mcmc.summary_+3A_probs">probs</code></td>
<td>

<p>Vector of quantiles that should be computed for each parameter.
</p>
</td></tr>
<tr><td><code id="mcmc.summary_+3A_mean">mean</code></td>
<td>

<p>logical; if 'TRUE' the mean of the posterior distributions is computed
as well.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with quantiles and the mean of the posterior distributions.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("spateMCMC")
mcmc.summary(spateMCMC$Post,mean=TRUE)
</code></pre>

<hr>
<h2 id='Palpha'>
Prior for direction of anisotropy in diffusion parameter alpha.
</h2><span id='topic+Palpha'></span>

<h3>Description</h3>

<p>Default prior for direction of anisotropy in diffusion parameter alpha. A uniform
prior on [0,pi/4] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Palpha(alpha, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Palpha_+3A_alpha">alpha</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Palpha_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'alpha'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Pgamma'>
Prior for amount of anisotropy in diffusion parameter gamma.
</h2><span id='topic+Pgamma'></span>

<h3>Description</h3>

<p>Default prior for amount of anisotropy in diffusion parameter gamma. A uniform
prior on log(gamma) over the interval [1/100,100] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pgamma(gamma, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pgamma_+3A_gamma">gamma</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Pgamma_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'gamma'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Plambda'>
Prior for transformation parameter of the Tobit model.
</h2><span id='topic+Plambda'></span>

<h3>Description</h3>

<p>Default prior for transformation parameter of the Tobit model. A locally constant, improper prior on
the positive real line is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plambda(lambda, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plambda_+3A_lambda">lambda</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Plambda_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'lambda'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='plot.spateMCMC'>
Plot fitted spateMCMC objects.
</h2><span id='topic+plot.spateMCMC'></span>

<h3>Description</h3>

<p>Plots trace plots, pair plots, the posterior of the hyperparameters and the posterior of the latent spatio-temporal process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spateMCMC'
plot(x,..., trace = TRUE, hist = TRUE,
              medianHist=TRUE, pairs = FALSE,ask = TRUE, ToFile = FALSE,
              path = NULL,file = NULL,true=NULL,BurnInAdaptive=NULL,
              postProcess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spateMCMC_+3A_x">x</code></td>
<td>

<p>A 'spateMCMC' object obtained from 'spate.mcmc'.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'spate.plot' in case
'postProcess=TRUE' is selected.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_trace">trace</code></td>
<td>

<p>logical; if 'TRUE' trace plots are made
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_hist">hist</code></td>
<td>

<p>logical; if 'TRUE' histograms of the posterior distributions for the hyper-parameters are plotted
</p>
</td></tr>  <tr><td><code id="plot.spateMCMC_+3A_medianhist">medianHist</code></td>
<td>

<p>logical; if 'TRUE' medians are added to the histograms.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_pairs">pairs</code></td>
<td>

<p>logical; if 'TRUE' trace plots are made
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_ask">ask</code></td>
<td>
<p>logical;  if 'TRUE' (and the R session is interactive) the user is asked for input, before a new figure is drawn. 
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_tofile">ToFile</code></td>
<td>

<p>logical; if 'TRUE' the plots are save to a file.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_path">path</code></td>
<td>

<p>The path.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_file">file</code></td>
<td>

<p>The file name.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_true">true</code></td>
<td>

<p>The true value of the parameters (for simulation only).
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_burninadaptive">BurnInAdaptive</code></td>
<td>

<p>The number of samples used as burn-in before starting the adaptive
estimation of Metropolis-Hastings
proposal covariance for the hyper-parameters.
</p>
</td></tr>
<tr><td><code id="plot.spateMCMC_+3A_postprocess">postProcess</code></td>
<td>

<p>logical; if 'TRUE' the posterior of the spatio-temporal process xi is plotted as well.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots illustrating a fitted model saved in a 'spateMCMC' object.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("spateMCMC")
plot(spateMCMC,medianHist=TRUE,pairs=TRUE)
</code></pre>

<hr>
<h2 id='plot.spateSim'>
Plotting function for 'spateSim' objects.
</h2><span id='topic+plot.spateSim'></span>

<h3>Description</h3>

<p>This is the plotting function for 'spateSim' objects. It calles the
function 'spate.plot()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spateSim'
plot(x,..., plotXi =TRUE,plotW = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spateSim_+3A_x">x</code></td>
<td>

<p>'spateSim' object obtained from 'spate.sim'.
</p>
</td></tr>
<tr><td><code id="plot.spateSim_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'spate.plot'</p>
</td></tr>
<tr><td><code id="plot.spateSim_+3A_plotxi">plotXi</code></td>
<td>

<p>Logical; if 'TRUE' the latent process 'xi' is plotted.
</p>
</td></tr>
<tr><td><code id="plot.spateSim_+3A_plotw">plotW</code></td>
<td>

<p>Logical; if 'TRUE' the observed process 'w' is plotted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots illustrating the simulated space-time field.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spateSim &lt;-spate.sim(par=c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,
                     alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01),n=50,T=9)
plot(spateSim)
</code></pre>

<hr>
<h2 id='Pmux'>
Prior for y-component of drift.
</h2><span id='topic+Pmux'></span>

<h3>Description</h3>

<p>Default prior for x-component of drift vector mu. A uniform prior on the
interval [-0.5,0.5] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pmux(mux, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pmux_+3A_mux">mux</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Pmux_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'mux'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Pmuy'>
Prior for y-component of drift.
</h2><span id='topic+Pmuy'></span>

<h3>Description</h3>

<p>Default prior for y-component of drift vector mu. A uniform prior on the
interval [-0.5,0.5] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pmuy(muy, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pmuy_+3A_muy">muy</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Pmuy_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'muy'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='post.dist.hist'>
Histogram of posterior distributions.
</h2><span id='topic+post.dist.hist'></span>

<h3>Description</h3>

<p>Histogram of posterior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.dist.hist(data, true=NULL, breaks = 20, mean = FALSE, median = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post.dist.hist_+3A_data">data</code></td>
<td>
<p>Matrix of size p x Nmc where p denotes the number of
parameters and Nmc the number of MCMC samples.
</p>
</td></tr>
<tr><td><code id="post.dist.hist_+3A_true">true</code></td>
<td>

<p>The true value of the parameters (for simulation only).
</p>
</td></tr>
<tr><td><code id="post.dist.hist_+3A_breaks">breaks</code></td>
<td>

<p>Parameter for 'hist()' function.
</p>
</td></tr>
<tr><td><code id="post.dist.hist_+3A_mean">mean</code></td>
<td>

<p>logical; if 'TRUE' the mean is added to the histogram.
</p>
</td></tr>
<tr><td><code id="post.dist.hist_+3A_median">median</code></td>
<td>

<p>logical; if 'TRUE' the median is added to the histogram.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histograms illustrating posterior distributions.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Prho0'>
Prior for range parameter rho0 of innovation epsilon.
</h2><span id='topic+Prho0'></span>

<h3>Description</h3>

<p>Default prior for range parameter rho0 of stochastic source-sink term epsilon. A uniform prior on [0,100] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prho0(rho0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Prho0_+3A_rho0">rho0</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Prho0_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'rho0'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Prho1'>
Prior for range parameter rho1 of diffusion.
</h2><span id='topic+Prho1'></span>

<h3>Description</h3>

<p>Default prior for range parameter rho1 of diffusive term. A uniform prior on
[0,100] is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prho1(rho1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Prho1_+3A_rho1">rho1</code></td>
<td>

<p>A quantile.
</p>
</td></tr>
<tr><td><code id="Prho1_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'rho1'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='print.spateMCMC'>
Print function for spateMCMC objects.
</h2><span id='topic+print.spateMCMC'></span>

<h3>Description</h3>

<p>Print function for spateMCMC objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spateMCMC'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.spateMCMC_+3A_x">x</code></td>
<td>

<p>A 'spateMCMC' object obtained from 'spate.mcmc'.
</p>
</td></tr>
<tr><td><code id="print.spateMCMC_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='print.spateSim'>
Print function for 'spateSim' objects.
</h2><span id='topic+print.spateSim'></span>

<h3>Description</h3>

<p>Print function for 'spateSim' objects.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spateSim'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.spateSim_+3A_x">x</code></td>
<td>

<p>'spateSim' object obtained from 'spate.sim'.
</p>
</td></tr>
<tr><td><code id="print.spateSim_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'spate.plot'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spateSim &lt;-spate.sim(par=c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,
                     alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01),n=50,T=9)
spateSim
</code></pre>

<hr>
<h2 id='propagate.spectral'>
Function that propagates a state (spectral coefficients). 
</h2><span id='topic+propagate.spectral'></span>

<h3>Description</h3>

<p>Function that propagates the vector 'alphat'. This is
equivalent to multiplying 'alphat' with the propagator matrix G. It is a
lot faster though, due to the block-diagonal structure of G. This is a
wrapper function of a C function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagate.spectral(alphat,spateFT=NULL,n=NULL,Gvec=NULL,par=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="propagate.spectral_+3A_alphat">alphat</code></td>
<td>

<p>A vector of spectral coefficients.
</p>
</td></tr>
<tr><td><code id="propagate.spectral_+3A_spateft">spateFT</code></td>
<td>

<p>A 'spateFT' obtained from 'spate.init'. Either this or 'n' needs to
be given.
</p>
</td></tr>
<tr><td><code id="propagate.spectral_+3A_n">n</code></td>
<td>

<p>Number of points on each axis. n x n is the total number of spatial
points. Either this or 'spateFT' needs to be given.
</p>
</td></tr>
<tr><td><code id="propagate.spectral_+3A_gvec">Gvec</code></td>
<td>

<p>The propagator matrix G in vector format obtained from
'get.propagator.vec'. If 'Gvec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="propagate.spectral_+3A_par">par</code></td>
<td>

<p>Parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2. If 'Gvec' is not given, 'par'
needs to be given.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of propagated coefficients G*alphat.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
spec &lt;- matern.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
alphat &lt;- sqrt(spec)*rnorm(n*n)
##Propagate initial state
wave &lt;- wave.numbers(n)
Gvec &lt;- get.propagator.vec(wave=wave$wave,indCos=wave$indCos,zeta=0.1,rho1=0.02,gamma=2,
                  alpha=pi/4,muX=0.2,muY=0.2,dt=1,ns=4)
alphat1 &lt;- propagate.spectral(alphat,n=n,Gvec=Gvec)

opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
image(1:n,1:n,matrix(real.fft(alphat,n=n,inv=FALSE),nrow=n),main="Whittle
field",xlab="",ylab="",col=cols())
image(1:n,1:n,matrix(real.fft(alphat1,n=n,inv=FALSE),nrow=n),main="Propagated
field",xlab="",ylab="",col=cols())
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='Psigma2'>
Prior for for variance parameter sigma2 of innovation epsilon.
hyperparameter.
</h2><span id='topic+Psigma2'></span>

<h3>Description</h3>

<p>Default prior for marginal variance parameter sigma2 (=sigma^2) of the stochastic source-sink term epsilon. A uniform, improper prior on sigma (P[sigma] propto 1 or P[sigma2] propto 1/tau) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psigma2(sigma2, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Psigma2_+3A_sigma2">sigma2</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Psigma2_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'sigma2'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Ptau2'>
Prior for nugget effect parameter tau2.
</h2><span id='topic+Ptau2'></span>

<h3>Description</h3>

<p>Default prior for measurment error or small scale variation tau2 (nugget effect). A uniform, improper prior on tau (P[tau] propto 1 or P[tau2] propto 1/tau) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ptau2(tau2, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ptau2_+3A_tau2">tau2</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Ptau2_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at tau2.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='Pzeta'>
Prior for damping parameter zeta.
</h2><span id='topic+Pzeta'></span>

<h3>Description</h3>

<p>Default prior for damping parameter zeta. A uniform, improper prior on
the positive real line (P[zeta] propto 1) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pzeta(zeta, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pzeta_+3A_zeta">zeta</code></td>
<td>

<p>A quantile
</p>
</td></tr>
<tr><td><code id="Pzeta_+3A_log">log</code></td>
<td>

<p>Indicates whether the logarithm should be calculated or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of (log) prior at 'zeta'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='real.fft'>
Fast calculation of the two-dimensional real Fourier transform.
</h2><span id='topic+real.fft'></span>

<h3>Description</h3>

<p>Fast calculation of the real Fourier transform. This is a wrapper
function for a C function which uses the complex FFT function from the 'fftw3' library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real.fft(w,n,inv=TRUE,indFFT=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="real.fft_+3A_w">w</code></td>
<td>

<p>A spatial field in a stacked vector of length N=n^2.
</p>
</td></tr>
<tr><td><code id="real.fft_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="real.fft_+3A_inv">inv</code></td>
<td>

<p>Indicates whether the inverse Fourier transform should be calculated or not.
</p>
</td></tr>
<tr><td><code id="real.fft_+3A_indfft">indFFT</code></td>
<td>

<p>A list of containing vectors of natural numbers representing indices
used to transform between the real and the complex Fourier transform.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length n*n containing the real (inverse) Fourier transformation of 'w'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
spec &lt;- matern.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
sim &lt;- real.fft(sqrt(spec)*rnorm(n*n),n=n,inv=FALSE)
image(1:n,1:n,matrix(sim,nrow=n),main="Sample from Matern field",xlab="",ylab="")
</code></pre>

<hr>
<h2 id='real.fft.TS'>
Fast calculation of the two-dimensional real Fourier transform of a space-time field. For
each time point, the spatial field is transformed.
</h2><span id='topic+real.fft.TS'></span>

<h3>Description</h3>

<p>This function calculates the two-dimensional real Fourier transform of
a space-time field. This is a wrapper
function for a C function which uses the complex FFT function from the
'fftw3' library. In contrast to using T times the function 'real.FFT',
R needs to communicate with C only once and not T times which saves
computational time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real.fft.TS(w,n,T,inv=TRUE,indFFT=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="real.fft.TS_+3A_w">w</code></td>
<td>

<p>Spatio-temporal field in a stacked vector of length T x N. Stacking is done
first over space and then time. E.g., the first N=n^2 entries contain
the spatial field at time t=1. Note that the spatial field itself is
stacked as well, i.e., each spatial field is in a vector of length N=n^2.
</p>
</td></tr>
<tr><td><code id="real.fft.TS_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="real.fft.TS_+3A_t">T</code></td>
<td>

<p>Number of time points.
</p>
</td></tr>
<tr><td><code id="real.fft.TS_+3A_inv">inv</code></td>
<td>

<p>Indicates whether the inverse Fourier transform should be calculated or not.
</p>
</td></tr>
<tr><td><code id="real.fft.TS_+3A_indfft">indFFT</code></td>
<td>

<p>A list of containing vectors of natural numbers representing indices
used to transform between the real and the complex Fourier transform.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length T x N containing the (inverse) Fourier transform of 'w'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
T &lt;- 4
spec &lt;- matern.spec(wave=spate.init(n=n,T=1)$wave,n=n,rho0=0.05,sigma2=1,norm=TRUE)
specsim &lt;- matrix(0,nrow=T,ncol=n*n)
for(t in 1:T) specsim[t,] &lt;- rnorm(n*n)*sqrt(spec)
maternsim &lt;- vect.to.TSmat(real.fft.TS(TSmat.to.vect(specsim),n=n,T=T,inv=FALSE),T=T)
opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2))
for(t in 1:T) image(1:n,1:n,matrix(maternsim[t,],nrow=n),
                    main="Sample from Matern field",xlab="",ylab="")
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='sample.four.coef'>
Sample from the full conditional of the Fourier coefficients.
</h2><span id='topic+sample.four.coef'></span>

<h3>Description</h3>

<p>Sample from the full conditional of the Fourier coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.four.coef(w=NULL,wFT=NULL,spec=NULL,Gvec=NULL,tau2=NULL,par=NULL,n,T,
                 NF=n*n,indCos=(1:((n*n-4)/2)*2+3),ns=4,nu=1,dt=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.four.coef_+3A_w">w</code></td>
<td>
<p>Observed data or latent process w (depending on which data
model is used) in an T x n*n matrix with columns and rows (points on a
grid stacked into a vector) corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_wft">wFT</code></td>
<td>

<p>Vector of length T*n*n containing the real Fourier transform of 'w'.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_spec">spec</code></td>
<td>

<p>Spectrum of the innovations <code class="reqn">\hat{\epsilon}</code> in a vector of length
n*n. If 'spec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_gvec">Gvec</code></td>
<td>

<p>The propagator matrix G in vector format obtained from 'get.G.vec'. If 'Gvec' is not given, it is constructed based on 'par'.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_tau2">tau2</code></td>
<td>

<p>Measurement error variance tau2. If 'NULL'; tau2=par[9].
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_par">par</code></td>
<td>
<p> Vector of parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2. If 'spec' and 'Gvec' are
given, 'par' will not be used.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_n">n</code></td>
<td>
<p>Number of grid points on each axis. n*n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_t">T</code></td>
<td>

<p>Number of points in time.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_nf">NF</code></td>
<td>

<p>Number of Fourier functions used.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_indcos">indCos</code></td>
<td>
<p>Vector of integers indicating the position cosine terms in
the 1:NF real Fourier functions. The first 'ns' cosine wavenumbers in 'wave' are not included in 'indCos'.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_ns">ns</code></td>
<td>

<p>Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.
</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_nu">nu</code></td>
<td>
<p> Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.</p>
</td></tr>
<tr><td><code id="sample.four.coef_+3A_dt">dt</code></td>
<td>
<p> Temporal lag between two time points. By default, this equals 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A T x n*n matrix with a sample from the full conditional
of latent process <code class="reqn">\alpha</code>.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Specifications for simulated example
n &lt;- 50
T &lt;- 4
par &lt;- c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01)
spateSim &lt;- spate.sim(par=par,n=n,T=T,seed=4)
w &lt;- spateSim$w
##Sample from full conditional
Nmc &lt;- 50
alphaS &lt;- array(0,c(T,n*n,Nmc))
wFT &lt;- real.fft.TS(w,n=n,T=T)
for(i in 1:Nmc){
  alphaS[,,i] &lt;- sample.four.coef(wFT=wFT,par=par,n=n,T=T,NF=n*n)
}
##Mean from full conditional
alphaMean &lt;- apply(alphaS,c(1,2),mean)
xiMean &lt;- real.fft.TS(alphaMean,n=n,T=T,inv=FALSE)

opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,4),mar=c(1,1,1,1))
for(t in 1:4) image(1:n,1:n,matrix(w[t,],nrow=n),xlab="",ylab="",col=cols(),
                    main=paste("w(",t,")",sep=""),xaxt='n',yaxt='n')
for(t in 1:4) image(1:n,1:n,matrix(xiMean[t,],nrow=n),xlab="",ylab="",col=cols(),
                    main=paste("xiPost(",t,")",sep=""),xaxt='n',yaxt='n')
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='spate.init'>
Constructor for 'spateFT' object which are used for the two-dimensional
Fourier transform.
</h2><span id='topic+spate.init'></span>

<h3>Description</h3>

<p>Auxilary function for constructing 'spateFT' objects which are used for the two-dimensional
Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spate.init(n,T,NF=n*n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spate.init_+3A_n">n</code></td>
<td>

<p>Number of points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="spate.init_+3A_t">T</code></td>
<td>

<p>Number of temporal points.
</p>
</td></tr>
<tr><td><code id="spate.init_+3A_nf">NF</code></td>
<td>

<p>This integer specifies the number of Fourier functions. If NF&lt;n*n,
dimension reduction is obtained. In this case, Fourier functions with
wavenumbers closest to the origin (0,0) are first included. If a given
'NF' implies a basis with anisotropy, i.e., higher frequencies in one
direction than in another, this is automatically corrected by using the
next higher integer NF' such that the basis has the same resolution in
all directions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'spateFT' object. This is a list with
</p>
<table role = "presentation">
<tr><td><code>wave</code></td>
<td>
<p>a matrix containing the wavenumbers</p>
</td></tr>
<tr><td><code>indCos</code></td>
<td>
<p>a vector indicating the position of the cosine terms (excluding the frist 'ns')</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>an integer indicating the number of cosine-only terms</p>
</td></tr>
<tr><td><code>indFFT</code></td>
<td>
<p>a list of indices used for the conversion between the complex FFT and the real Fourier transform.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of points on each axis</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>number of points in time</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='spate.mcmc'>
MCMC algorithm for fitting the model.
</h2><span id='topic+spate.mcmc'></span>

<h3>Description</h3>

<p>MCMC algorithm for fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spate.mcmc(y,coord=NULL,lengthx=NULL,lengthy=NULL,Sind=NULL,n=NULL,
          IncidenceMat=FALSE,x=NULL,SV=c(rho0=0.2,sigma2=0.1,
          zeta=0.25,rho1=0.2,gamma=1,alpha=0.3,muX=0,muY=0,tau2=0.005),
          betaSV=rep(0,dim(x)[1]),RWCov=NULL,parh=NULL,tPred=NULL,
          sPred=NULL,P.rho0=Prho0,P.sigma2=Psigma2,P.zeta=Pzeta,P.rho1=Prho1,
          P.gamma=Pgamma,P.alpha=Palpha,P.mux=Pmux,P.muy=Pmuy,P.tau2=Ptau2,
          lambdaSV=1,sdlambda=0.01,P.lambda=Plambda,DataModel="Normal",
          DimRed=FALSE,NFour=NULL,indEst=1:9,Nmc=10000,BurnIn =1000,
          path=NULL,file=NULL,SaveToFile=FALSE,PlotToFile=FALSE,
          FixEffMetrop=TRUE,saveProcess=FALSE,Nsave=200,seed=NULL,
          Padding=FALSE,adaptive=TRUE,NCovEst=500,BurnInCovEst=500,
          MultCov=0.5,printRWCov=FALSE,MultStdDevLambda=0.75,
          Separable=FALSE,Drift=!Separable,Diffusion=!Separable,
          logInd=c(1,2,3,4,5,9),nu=1,plotTrace=TRUE,
          plotHist=FALSE,plotPairs=FALSE,trueVal=NULL,
          plotObsLocations=FALSE,trace=TRUE,monitorProcess=FALSE,
          tProcess=NULL,sProcess=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spate.mcmc_+3A_y">y</code></td>
<td>

<p>Observed data in an T x N matrix with columns and rows corresponding to
time and space (observations on a grid stacked into a vector),
respectively. By default, at each time point, the observations are
assumed to lie on a square grid with each axis scaled so that it has unit length.
</p>
</td></tr>  
<tr><td><code id="spate.mcmc_+3A_coord">coord</code></td>
<td>

<p>If specified, this needs to be a matrix of dimension N x 2 with coordinates of the N observation points. Observations in 'y' can either be on a square grid or not. If not, the coordinates of each observation point need to be specified in 'coord'. According to these coordinates, each observation location is then mapped to a grid cell. If 'coord' is not specified, the observations in 'y' are assumed to lie on a square grid with each axis scaled so that it has unit length.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_lengthx">lengthx</code></td>
<td>

<p>Use together with 'coord' to specify the length of the x-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
x-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_lengthy">lengthy</code></td>
<td>

<p>Use together with 'coord' to specify the length of the y-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
y-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_sind">Sind</code></td>
<td>

<p>Vector of indices of grid cells where observations are made, in case,
the observation are not made at every grid cell. Alternatively, the
coordinates of the observation locations can be specfied in 'coord'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_n">n</code></td>
<td>

<p>Number of point per axis of the square into which the points are
mapped. In total, the process is modeled on a grid of size n*n.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_incidencemat">IncidenceMat</code></td>
<td>

<p>Logical; if 'TRUE' an incidence matrix relating the latent process to
observation locations is used. This is only recommended to use when the
observations are relatively low-dimensional and when the latent process
is modeled in a reduced dimensional space as well.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_x">x</code></td>
<td>

<p>Covariates in an array of dimensions p x T X N, where p denotes the
number of covariates, T the number of time points, and N the number of
spatial points.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_sv">SV</code></td>
<td>

<p>Starting values for parameters. Parameters for the SPDE in the following
order: rho_0, sigma^2, zeta, rho_1, gamma, alpha, mu_x, mu_y, tau^2. rho_0 and sigma^2 are the range
and marginal variance of the Matern covariance funtion for the
innovation term epsilon. zeta is the damping parameter. rho_1, gamma,
and alpha parametrize the diffusion matrix with rho_1 being a range
parameter, gamma and alpha determining the amount and the direction,
respectively, of anisotropy. mu_x and mu_y are the two components of
the drift vector. tau^2 denotes the nugget effect or measurment error.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_betasv">betaSV</code></td>
<td>

<p>Starting values for regression coefficients.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_rwcov">RWCov</code></td>
<td>

<p>Covariance matrix of the proposal distribution used in the random walk
Metropolis-Hastings step for the hyper-parameters.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_parh">parh</code></td>
<td>
<p>Only used in prediction mode. If 'parh'
is not 'NULL', this indicates that 'spate.mcmc' is used for making
predictions at locations (tPred,sPred) instead of applying the traditional MCMC
algorithm. In case 'parh' is not 'NULL', it is a Npar x Nsim
matrix containing Nsim samples from the posterior of the Npar
parameters. This argument is used by the wrapper function 'spate.predict'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_tpred">tPred</code></td>
<td>

<p>Time points where predictions are made.This needs to be a vector if
predictions are made at multiple times.  For instance, if T is the number
of time points in the data 'y', then tPred=c(T+1, T+2) means that
predictions are made at time 'T+1' and 'T+2'. This argument is used by
the wrapper function 'spate.predict'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_spred">sPred</code></td>
<td>

<p>Vector of indices of grid cells (positions of locations in the stacked
spatial vector) where predictions are made. This argument is used by
the wrapper function 'spate.predict'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.rho0">P.rho0</code></td>
<td>

<p>Function specifying the prior for rho0.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.sigma2">P.sigma2</code></td>
<td>

<p>Function specifying the prior for sigma2.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.zeta">P.zeta</code></td>
<td>

<p>Function specifying the prior for zeta.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.rho1">P.rho1</code></td>
<td>

<p>Function specifying the prior for rho1.
</p>
</td></tr> 
<tr><td><code id="spate.mcmc_+3A_p.gamma">P.gamma</code></td>
<td>

<p>Function specifying the prior for gamma.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.alpha">P.alpha</code></td>
<td>

<p>Function specifying the prior for alpha.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.mux">P.mux</code></td>
<td>

<p>Function specifying the prior for mux.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.muy">P.muy</code></td>
<td>

<p>Function specifying the prior for muy.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.tau2">P.tau2</code></td>
<td>

<p>Function specifying the prior for tau2.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_lambdasv">lambdaSV</code></td>
<td>

<p>Starting value for transformation parameter lambda in the Tobit model.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_sdlambda">sdlambda</code></td>
<td>

<p>Standard deviation of the proposal distribution used in the random walk
Metropolis-Hastings step for lambda.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_p.lambda">P.lambda</code></td>
<td>

<p>Function specifying the prior for lambda.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_datamodel">DataModel</code></td>
<td>

<p>Specifies the data model. &quot;Normal&quot; or &quot;SkewTobit&quot; are available options.
</p>
</td></tr>  
<tr><td><code id="spate.mcmc_+3A_dimred">DimRed</code></td>
<td>

<p>Logical; if 'TRUE' dimension reduction is applied. This means that not
the full number (n*n) of Fourier functions is used but rather only a
reduced dimensional basis of dimension 'NFour'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_nfour">NFour</code></td>
<td>

<p>If 'DimRed' is 'TRUE', this specifies the number of Fourier functions.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_indest">indEst</code></td>
<td>

<p>A vector of numbers specifying which for which parameters the posterior
should be computed and which should be held fix (at their starting
value). If the corresponding to the index of rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2 is present in the vector, the
parameter will be estimated otherwise not. Default is indEst=1:9 which
means that one samples from the posterior for all parameters.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_nmc">Nmc</code></td>
<td>

<p>Number of MCMC samples.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_burnin">BurnIn</code></td>
<td>

<p>Length of the burn-in period.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_path">path</code></td>
<td>

<p>Path, in case plots and / or the spateMCMC object should be save in a file.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_file">file</code></td>
<td>

<p>File name, in case plots and / or the spateMCMC object should be save in a file.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_savetofile">SaveToFile</code></td>
<td>

<p>Indicates whether the spateMCMC object should be save in a file.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_plottofile">PlotToFile</code></td>
<td>

<p>Indicates whether the MCMC output analysis plots should be save in a file.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_fixeffmetrop">FixEffMetrop</code></td>
<td>

<p>The fixed effects, i.e., the regression coefficients, can either be
sampled in a Gibbs step or updated together with the hyperparameters in
the Metropolis-Hastings step. The latter is the default and recommended
option since correlations between fixed effects and the random process
can result in slow mixing.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_saveprocess">saveProcess</code></td>
<td>

<p>Logical; if 'TRUE' samples from the posterior of the latent
spatio-temporal process xi are saved.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_nsave">Nsave</code></td>
<td>

<p>Number of samples from the posterior of the latent
spatio-temporal process xi that should be save.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_seed">seed</code></td>
<td>

<p>Seed for random generator.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_padding">Padding</code></td>
<td>

<p>Indicates whether padding is applied or not. If the range parameters are
large relative to the domain, this is recommended since otherwise
spurious periodicity can occur.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_adaptive">adaptive</code></td>
<td>

<p>Indicates whether an adaptive Metropolis-Hastings algorithm is used or
not. If yes, the proposal covariance matrix 'RWCov' is adaptively
estimated during the algorithm and tuning does not need to be done by hand.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_ncovest">NCovEst</code></td>
<td>

<p>Minimal number of samples to be used for estimating the proposal matrix.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_burnincovest">BurnInCovEst</code></td>
<td>

<p>Burn-in period for estimating the proposal matrix.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_multcov">MultCov</code></td>
<td>
<p>Numeric used as multiplier for the adaptively estimated
proposal cocariance matrix 'RWCov' of the hyper-parameters. I.e., the estimated covariance
matrix is multiplied by 'MultCov'.</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_printrwcov">printRWCov</code></td>
<td>
<p>Logical, if 'TRUE' the estimated
proposal cocariance matrix is printed each time.</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_multstddevlambda">MultStdDevLambda</code></td>
<td>
<p>Numeric used as multiplier for the adaptively
estimated proposal
standard deviation of the Tobit transformation parameter lambda. I.e.,
the estimated standard deviation is multiplied by 'MultStdDevLambda'.</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_separable">Separable</code></td>
<td>

<p>Indicates whether a separable model, i.e., no transport / drift and no
diffusion, should be estimated.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_drift">Drift</code></td>
<td>

<p>Indicates whether a drift term should be included.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_diffusion">Diffusion</code></td>
<td>

<p>Indicates whether a diffusion term should be included.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_logind">logInd</code></td>
<td>

<p>Indicates which parameters are sampled on the log-scale. Default is
logInd=c(1, 2, 3, 4, 5, 9) corresponding to rho_0, sigma2,  zeta,
rho_1, gamma, and tau^2.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_nu">nu</code></td>
<td>

<p>Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.
</p>
</td></tr> 
<tr><td><code id="spate.mcmc_+3A_plottrace">plotTrace</code></td>
<td>

<p>Indicates whether trace plots are made.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_plothist">plotHist</code></td>
<td>

<p>Indicates whether histograms of the posterior distributions are made.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_plotpairs">plotPairs</code></td>
<td>

<p>Indicates whether scatter plots of the hyper-parameters and the
regression coefficients are made.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_trueval">trueVal</code></td>
<td>

<p>In simulations, true values can be supplied for comparison with the MCMC output.
</p>
</td></tr>  
<tr><td><code id="spate.mcmc_+3A_plotobslocations">plotObsLocations</code></td>
<td>

<p>Logical; if 'TRUE' the observations locations are ploted together with
the grid cells.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_trace">trace</code></td>
<td>

<p>Logical; if 'TRUE' tracing information on the progress of the MCMC algorithm is produced.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_monitorprocess">monitorProcess</code></td>
<td>

<p>Logical; if 'TRUE' in addition to the trace plots of the hyper-parameters, the mixing
properties of the latent process xi=Phi*alpha is monitored.  This is
done by plotting the current sample of the process. More specifically,
the time series at locations 'sProcess' and the spatial fieldd at time points 'tProcess'.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_tprocess">tProcess</code></td>
<td>

<p>To be secified if 'monitorProcess=TRUE'. Time points at which
spatial fields of the sampled process should be plotted.
</p>
</td></tr>
<tr><td><code id="spate.mcmc_+3A_sprocess">sProcess</code></td>
<td>

<p>To be secified if 'monitorProcess=TRUE'. Locations at which time
series of the sampled process should be plotted. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a 'spateMCMC' object with, amongst others, the following entries
</p>
<table role = "presentation">
<tr><td><code>Post</code></td>
<td>
<p>Matrix containing samples from the posterior of the hyper-parameters and the regression coefficient</p>
</td></tr>
<tr><td><code>xiPost</code></td>
<td>
<p>Array with samples from the posterior of the spatio-temporal process</p>
</td></tr>
<tr><td><code>RWCov</code></td>
<td>
<p>(Estimated) proposal covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Specify hyper-parameters
par &lt;- c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01)
##Simulate data
spateSim &lt;- spate.sim(par=par,n=20,T=20,seed=4)
w &lt;- spateSim$w

##Below is an example to illustrate the use of the MCMC algorithm.
##In practice, more samples are needed for a sufficiently large effective sample size.

##The following takes a couple of minutes.
##Load the precomputed object some lines below to save time.
##spateMCMC &lt;- spate.mcmc(y=w,x=NULL,SV=c(rho0=0.2,sigma2=0.1,
##              zeta=0.25,rho1=0.2,gamma=1,alpha=0.3,muX=0,muY=0,tau2=0.005),
##              RWCov=diag(c(0.005,0.005,0.05,0.005,0.005,0.001,0.0002,0.0002,0.0002)),
##              Nmc=10000,BurnIn=2000,seed=4,Padding=FALSE,plotTrace=TRUE,NCovEst=500,
##              BurnInCovEst=500,trueVal=par,saveProcess=TRUE)
##spateMCMC
##plot(spateMCMC.fit,true=par,postProcess=TRUE)

##Instead of waiting, you can also use this precomputed object
data("spateMCMC")
spateMCMC
plot(spateMCMC,true=par,medianHist=FALSE)

</code></pre>

<hr>
<h2 id='spate.plot'>
Plot a spatio-temporal field.
</h2><span id='topic+spate.plot'></span>

<h3>Description</h3>

<p>Generates a figure or an animation of a spatio-temporal field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spate.plot(xi,nx=NULL,whichT=NULL,format="ImgTogether",ToFile=FALSE,path=NULL,
           file=NULL,indScale=FALSE,main=NULL,mfrow=NULL,
           imagesize=c(1000,1000),zlim=NULL,breaks=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spate.plot_+3A_xi">xi</code></td>
<td>

<p>A spatio-temporal field stored in an T x N matrix with columns and rows corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_nx">nx</code></td>
<td>
<p>Integer specifying the number of points on the x-axis. If 'NULL',
a quadratic grid is assumed.</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_whicht">whichT</code></td>
<td>
<p>Vector of integers specifying the time points that
are plotted. If 'NULL', all time points are plotted.</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_format">format</code></td>
<td>

<p>A string specifying how the spatio-temporal field should be ploted. &quot;ImgTogether&quot; produces one single plot containing all spatial fields at all time
points. With &quot;ImgSeparate&quot;, the spatial fields at each
time point are plotted in separate plots.
</p>
</td></tr>  
<tr><td><code id="spate.plot_+3A_tofile">ToFile</code></td>
<td>

<p>Indicates whether the output should be saved to a file.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_path">path</code></td>
<td>

<p>Path indicating where to save the file.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_file">file</code></td>
<td>

<p>File name.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_indscale">indScale</code></td>
<td>

<p>Indicates whether the color scale for the spatial plots is the same
for all time points (indScale=FALSE) or separate for each time point (indScale=TRUE).
</p>
</td></tr>  
<tr><td><code id="spate.plot_+3A_main">main</code></td>
<td>
<p>Titles for the plots. Can be either be NULL or a character vector of length equal to the number of time points or 1.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_mfrow">mfrow</code></td>
<td>
<p>See 'par'. Can be either NULL or an integer vector of length two. If
it is NULL, the functions determines mfrow automatically.</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_imagesize">imagesize</code></td>
<td>

<p>The size of the .jpeg image if ToFile=TRUE.
</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_zlim">zlim</code></td>
<td>
<p>Graphical parameter to be passed to 'image'. Determines the scale on the z-axis
of the plots. If 'indScale=FALSE' one can specify the common scale on
the z-axis of the plots through this argument.</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_breaks">breaks</code></td>
<td>
<p>Graphical parameter to be passed to 'image'.</p>
</td></tr>
<tr><td><code id="spate.plot_+3A_...">...</code></td>
<td>

<p>Other graphical parameters that are passed to 'image' and 'par'.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots illustrating a space-time field.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spateSim &lt;- spate.sim(par=c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,
                      alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01),n=50,T=9)
spate.plot(spateSim$xi)
</code></pre>

<hr>
<h2 id='spate.predict'>
Obtain samples from predictive distribution in space and time.
</h2><span id='topic+spate.predict'></span>

<h3>Description</h3>

<p>Obtain samples from predictive distribution in space and time given the
posterior of the hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spate.predict(y,tPred,sPred=NULL,xPred=NULL,yPred=NULL,spateMCMC,Nsim=200,
              BurnIn=5,coord=NULL,lengthx=NULL,lengthy=NULL,Sind=NULL,
              n=NULL,IncidenceMat=FALSE,x=NULL,DataModel="Normal",
              DimRed=FALSE,NFour=NULL,seed=NULL,nu =1,trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spate.predict_+3A_y">y</code></td>
<td>

<p>Observed data in an T x N matrix with columns and rows corresponding to time and space, respectively.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_x">x</code></td>
<td>

<p>Covariates in an array of dimensions p x T X N, where p denotes the
number of covariates, T the number of time points, and N the number of
spatial points.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_tpred">tPred</code></td>
<td>

<p>Time points where predictions are made.This needs to be a vector if
predictions are made at multiple times.  For instance, if T is the number
of time points in the data 'y', then tPred=c(T+1, T+2) means that
predictions are made at time 'T+1' and 'T+2'.  If 'xPred' and 'yPred' are empty, then
predictions are made at all spatial points for each time point in
'tPred'. Otherwise 'xPred' and 'yPred', or 'sPred, need to have the same length as 'tPred', and
predictions are made at the points (tPred,xPred,yPred), ore (tPred,
sPred), respectively.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_spred">sPred</code></td>
<td>

<p>Vector of indices of grid cells (positions of locations in the stacked
spatial vector) where predictions are made. This is an alternative to
specifying the coordinates 'xPred' and 'yPred'.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_xpred">xPred</code></td>
<td>

<p>Vector of x-coordinates of spatial points where predictions are made. This is an alternative to
specifying the grid cell in 'sPred'.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_ypred">yPred</code></td>
<td>

<p>Vector of y-coordinates of spatial points where predictions are made. This is an alternative to
specifying the grid cell in 'sPred'.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_spatemcmc">spateMCMC</code></td>
<td>

<p>'spateMCMC' object obtained from 'spate.mcmc' containing the posterior of the hyper-parameters and
information on the model used.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_nsim">Nsim</code></td>
<td>

<p>Number of samples used to characterize the predictive distribution.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_burnin">BurnIn</code></td>
<td>

<p>Length of burn-in period.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_coord">coord</code></td>
<td>

<p>If specified, this needs to be a matrix of dimension N x 2 with coordinates of the N observation points. Observations in 'y' can either be on a square grid or not. If not, the coordinates of each observation point need to be specified in 'coord'. According to these coordinates, each observation location is then mapped to a grid cell. If 'coord' is not specified, the observations in 'y' are assumed to lie on a square grid with each axis scaled so that it has unit length.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_lengthx">lengthx</code></td>
<td>

<p>Use together with 'coord' to specify the length of the x-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
x-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_lengthy">lengthy</code></td>
<td>

<p>Use together with 'coord' to specify the length of the y-axis. This is
usefull if the observations lie in a rectangular area instead of a
square. The length needs to be at least as large as the largest
y-distance in 'coord.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_sind">Sind</code></td>
<td>

<p>Vector of indices of grid cells where observations are made, in case,
the observation are not made at every grid cell. Alternatively, the
coordinates of the observation locations can be specfied in 'coord'.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_n">n</code></td>
<td>

<p>Number of point per axis of the square into which the points are
mapped. In total, the process is modeled on a grid of size n*n.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_incidencemat">IncidenceMat</code></td>
<td>

<p>Logical; if 'TRUE' and incidence matrix relating the latent process to
observation locations. This is only recommended to use when the
observations are relatively low-dimensional and when the latent process
is modeled in a reduced dimensional spaceas well.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_datamodel">DataModel</code></td>
<td>

<p>Specifies the data model. &quot;Normal&quot; or &quot;SkewTobit&quot;.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_dimred">DimRed</code></td>
<td>

<p>Logical; if 'TRUE' dimension reduction is applied. This means that not
the full number (n*n) of Fourier functions is used but rather only a
reduced dimensional basis of dimension 'NFour'.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_nfour">NFour</code></td>
<td>

<p>If 'DimRed' is 'TRUE', this specifies the number of Fourier functions.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_seed">seed</code></td>
<td>

<p>Seed for random generator.
</p>
</td></tr>
<tr><td><code id="spate.predict_+3A_nu">nu</code></td>
<td>

<p>Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.
</p>
</td></tr> 
<tr><td><code id="spate.predict_+3A_trace">trace</code></td>
<td>

<p>Logical; if 'TRUE' tracing information on the progress of the MCMC algorithm is produced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on whether 'xPred' and 'yPred' are empty or not, either
</p>
<table role = "presentation">
<tr><td><code>(i)</code></td>
<td>
<p>an array of size t x s x Nsim where the first index is for time, the second
for space, and the third for the number of samples 'Nsim'</p>
</td></tr>
</table>
<p>or
</p>
<table role = "presentation">
<tr><td><code>(ii)</code></td>
<td>
<p>a matrix of size length(tPred) x Nsim</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par &lt;- c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01)
##Simulate data
spateSim &lt;- spate.sim(par=par,n=20,T=20,seed=4)
w &lt;- spateSim$w
data("spateMCMC")
##Make predictions. Takes a couple of seconds
predict &lt;- spate.predict(y=w,tPred=(17:25),spateMCMC=spateMCMC,Nsim =200,
                      BurnIn=10,DataModel="Normal")

Pmean &lt;- apply(predict,c(1,2),mean)
Psd &lt;- apply(predict,c(1,2),sd)

opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2))
image(1:20,1:20,matrix(w[19,],nrow=20),main="Observed field at t=19",xlab="x",ylab="y")
image(1:20,1:20,matrix(Pmean[3,],nrow=20),main="Fitted field at t=19",xlab="x",ylab="y")
image(1:20,1:20,matrix(w[20,],nrow=20),main="Observed field at t=20",xlab="x",ylab="y")
image(1:20,1:20,matrix(Pmean[4,],nrow=20),main="Fitted field at t=20",xlab="x",ylab="y")

par(mfrow=c(3,3))
zlim=c(min(Pmean),max(Pmean))
for(i in 1:9){
  image(1:20,1:20,matrix(Pmean[i,],nrow=20),zlim=zlim,
        main=paste("Mean t=",i+16,sep=""),xlab="x",ylab="y")
}

par(mfrow=c(3,3))
zlim=c(min(Psd),max(Psd))
for(i in 1:9){
  image(1:20,1:20,matrix(Psd[i,],nrow=20),zlim=zlim,
        main=paste("Std.dev. t=",i+16,sep=""),xlab="x",ylab="y")
par(opar) # Reset par() settings
}
</code></pre>

<hr>
<h2 id='spate.sim'>
Simulate from the SPDE.
</h2><span id='topic+spate.sim'></span>

<h3>Description</h3>

<p>Generates one sample from the Gaussian process specified through the SPDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spate.sim(par,n,T,seed=NULL,StartVal=NULL,nu=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spate.sim_+3A_par">par</code></td>
<td>

<p>Vector of parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2. rho_0 and sigma^2 are the range
and marginal variance of the Matern covariance funtion for the
innovation term epsilon. zeta is the damping parameter. rho_1, gamma,
and alpha parametrize the diffusion matrix with rho_1 being a range
parameter, gamma and alpha determining the amount and the direction,
respectively, of anisotropy. mu_x and mu_y are the two components of
the drift vector. tau^2 denotes the variance of nugget effect or measurment error.
</p>
</td></tr>
<tr><td><code id="spate.sim_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
<tr><td><code id="spate.sim_+3A_t">T</code></td>
<td>

<p>Number of points in time.
</p>
</td></tr>
<tr><td><code id="spate.sim_+3A_seed">seed</code></td>
<td>

<p>Seed for random number generator.
</p>
</td></tr>
<tr><td><code id="spate.sim_+3A_startval">StartVal</code></td>
<td>

<p>A starting value (field) for the SPDE can be defined. This is the
spatial field at the initial time that get propagated forward by the
SPDE. The starting fields needs to be a stacked vector of lengths n x n (number
of spatial points). Use 'as.vector()' to convert a spatial matrix to a vector.
</p>
</td></tr>
<tr><td><code id="spate.sim_+3A_nu">nu</code></td>
<td>

<p>Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a simulated spatio-temporal field xi with covariance structure as defined
through the SPDE, a simulated observation field w obtained by adding a
measurement error, and the simulated Fourier coefficients. The last two
are returned only on demand.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>StartVal &lt;- rep(0,100^2)
StartVal[75*100+75] &lt;- 1000
par &lt;- c(rho0=0.05,sigma2=0.7^2,zeta=-log(0.99),rho1=0.06,
         gamma=3,alpha=pi/4,muX=-0.1,muY=-0.1,tau2=0.00001)
spateSim &lt;- spate.sim(par=par,n=100,T=6,StartVal=StartVal,seed=1)
plot(spateSim,mfrow=c(2,3),mar=c(2,2,2,2),indScale=TRUE,
     cex.axis=1.5,cex.main=2)
</code></pre>

<hr>
<h2 id='spateMCMC.RData'>'spateMCMC' object output obtained from 'spate.mcmc'.</h2><span id='topic+spateMCMC'></span>

<h3>Description</h3>

<p>Precalculated 'spateMCMC' object containing a fitted model (MCMC output) obtained from 'spate.mcmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spateMCMC</code></pre>

<hr>
<h2 id='spateMLE.RData'>Maximum likelihood estimate for SPDE model with Gaussian observations.</h2><span id='topic+spateMLE'></span>

<h3>Description</h3>

<p>Precalculated maximum likelihood estimate using 'optim' and the function 'loglike'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spateMLE</code></pre>

<hr>
<h2 id='summary.spateSim'>
Summary function for 'spateSim' objects.
</h2><span id='topic+summary.spateSim'></span>

<h3>Description</h3>

<p>Summary function for 'spateSim' objects.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spateSim'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spateSim_+3A_object">object</code></td>
<td>

<p>'spateSim' object obtained from 'spate.sim()'.
</p>
</td></tr>
<tr><td><code id="summary.spateSim_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spateSim &lt;- spate.sim(par=c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,
                      alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01),n=50,T=9)
summary(spateSim)
</code></pre>

<hr>
<h2 id='tobit.lambda.log.full.cond'>
Full conditional for transformation parameter lambda.
</h2><span id='topic+tobit.lambda.log.full.cond'></span>

<h3>Description</h3>

<p>Full conditional for transformation parameter lambda of the Tobit
model. This is used in the Metropolis-Hastings step of the MCMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobit.lambda.log.full.cond(y, z, tau2, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tobit.lambda.log.full.cond_+3A_y">y</code></td>
<td>

<p>Observed data.
</p>
</td></tr>
<tr><td><code id="tobit.lambda.log.full.cond_+3A_z">z</code></td>
<td>

<p>Latent Gaussian variable.
</p>
</td></tr>
<tr><td><code id="tobit.lambda.log.full.cond_+3A_tau2">tau2</code></td>
<td>

<p>Value of variance (corresponds to nugget effect).
</p>
</td></tr>
<tr><td><code id="tobit.lambda.log.full.cond_+3A_lambda">lambda</code></td>
<td>

<p>Value of transformation parameter lambda.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of evaluated full conditional for transformation parameter lambda.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

<hr>
<h2 id='trace.plot'>
Trace plots for MCMC output analysis.
</h2><span id='topic+trace.plot'></span>

<h3>Description</h3>

<p>Trace plots for MCMC output analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.plot(data, true = NULL, BurnIn = NULL,BurnInAdaptive=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.plot_+3A_data">data</code></td>
<td>

<p>A p x Nmc data.frame of matrix where p denotes the number of parameters
and Nmc the number of Monte Carlo samples.
</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_true">true</code></td>
<td>

<p>The true value of the parameters (for simulation only).
</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_burnin">BurnIn</code></td>
<td>

<p>The number of samples used as burn-in if the burn-in has not yet been
removed from the sample.
</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_burninadaptive">BurnInAdaptive</code></td>
<td>

<p>The number of samples used as burn-in before starting the adaptive
estimation of Metropolis-Hastings
proposal covariance for the hyper-parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trace plots.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(rnorm(1200),nrow=6)
opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,3))
trace.plot(data,true=rep(0,6))
par(opar) # Reset par() settings
</code></pre>

<hr>
<h2 id='TSmat.to.vect'>
Converts a matrix stacked vector.
</h2><span id='topic+TSmat.to.vect'></span>

<h3>Description</h3>

<p>Converts a time-space matrix with columns and rows
corresponding to time and space into a stacked N*T vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSmat.to.vect(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TSmat.to.vect_+3A_mat">mat</code></td>
<td>

<p>A T x N matrix with columns and rows corresponding to time and space, respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of stacked values. Stacking is done first over space and then time.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vect &lt;- 1:12
mat &lt;- vect.to.TSmat(vect,T=3)##Convert vector to matrix
TSmat.to.vect(mat)##Convert matrix to vector.
</code></pre>

<hr>
<h2 id='vect.to.TSmat'>
Converts a stacked vector into matrix.
</h2><span id='topic+vect.to.TSmat'></span>

<h3>Description</h3>

<p>Converts a stacked N*T vector into a time-space matrix with columns and rows
corresponding to time and space, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vect.to.TSmat(vect, T = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vect.to.TSmat_+3A_vect">vect</code></td>
<td>

<p>A vector of stacked values. Stacking is done first over space and then time.
</p>
</td></tr>
<tr><td><code id="vect.to.TSmat_+3A_t">T</code></td>
<td>

<p>Number of time points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A T x N matrix with columns and rows corresponding to time and space, respectively.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vect &lt;- 1:12
vect
vect.to.TSmat(vect,T=3)
</code></pre>

<hr>
<h2 id='vnorm'>
Eucledian norm of a vector
</h2><span id='topic+vnorm'></span>

<h3>Description</h3>

<p>Calculates the Eucledian norm of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vnorm(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vnorm_+3A_v">v</code></td>
<td>

<p>Vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Eucledian norm of the vector 'v'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(1,2)
vnorm(v)
</code></pre>

<hr>
<h2 id='wave.numbers'>
Wave numbers.
</h2><span id='topic+wave.numbers'></span>

<h3>Description</h3>

<p>Returns wave numbers used in real Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.numbers(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wave.numbers_+3A_n">n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with
</p>
<table role = "presentation">
<tr><td><code>wave</code></td>
<td>
<p>A 2 x n^2 matrix with wavenumbers used in the real Fourier
transform. The first four columns contain the wavenumbers that are only used by cosine terms and not by sine terms. Subsequent columns alternate between wavenumbers of cosine and sine terms.</p>
</td></tr>
<tr><td><code>indCos</code></td>
<td>
<p>Vector of integers indicating the position of columns in
'wave' of wavenumbers of cosine terms. The first four cosine wavenumbers in 'wave' are not included in 'indCos'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
