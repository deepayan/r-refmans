<!DOCTYPE html><html><head><title>Help for package siplab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {siplab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#siplab-package'>
<p>Spatial Individual-Plant Simulation</p></a></li>
<li><a href='#assimilation'>
<p>Compute Assimilation Indices</p></a></li>
<li><a href='#boreas'>
<p>Marked Point Pattern Tree Data from BOREAS</p></a></li>
<li><a href='#edges'>
<p>Adjust for Edge Effects</p></a></li>
<li><a href='#efficiency'>
<p>Efficiency Functions</p></a></li>
<li><a href='#influence'>
<p>Influence Functions</p></a></li>
<li><a href='#kernel'>
<p>Competition Kernel Functions</p></a></li>
<li><a href='#pairwise'>
<p>Compute Pairwise Competition Indices</p></a></li>
<li><a href='#select'>
<p>Competitor Selection Rules</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Individual-Plant Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Oscar Garcia &lt;https://orcid.org/0000-0002-8995-1341&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oscar Garcia &lt;garcia@dasometrics.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A platform for computing competition indices and experimenting
    with spatially explicit individual-based vegetation models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>spatstat (&ge; 2.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ogarciav/siplab/">https://github.com/ogarciav/siplab/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ogarciav/siplab/issues">https://github.com/ogarciav/siplab/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-07 14:35:31 UTC; oscar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-07 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='siplab-package'>
Spatial Individual-Plant Simulation
</h2><span id='topic+siplab-package'></span><span id='topic+siplab'></span>

<h3>Description</h3>

<p>A platform for experimenting with spatially explicit individual-based plant modelling
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> siplab</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main top level functions are <code><a href="#topic+pairwise">pairwise</a>()</code>, and <code><a href="#topic+assimilation">assimilation</a>()</code>.
</p>
<p><code><a href="#topic+pairwise">pairwise</a>()</code> computes the competition indices most commonly used in individual-tree distance-dependent (or spatially explicit) forest growth models. These indices are based on a sum of functions of size and distance between the subject plant and each of its competitors. They represent an aggregate of pairwise interactions, the angular configuration of competitors and any higher-order interactions are ignored. Each index is characterized by a specific interaction function, here called a <a href="#topic+kernel">kernel</a>, and by a definition of competitors.
</p>
<p><code><a href="#topic+assimilation">assimilation</a>()</code> deals with &ldquo;fully spatial&rdquo; models, computing &ldquo;assimilation indices&rdquo; that aim at a mechanistic approximation of effective resource capture. One starts with a spatial resource distribution that is typically assumed to be uniform, Plants exert competitive pressure depending on size and distance, described by <a href="#topic+influence">influence</a> functions. The resource available at each point is allocated to plants according to their local influence and to a partition rule. Finally, the resource uptake may be weighted by an <a href="#topic+efficiency">efficiency</a> function that depends on size and distance, and is spatially integrated to obtain the plant's assimilation index.
Several examples of influence and efficiency functions are pre-programmed, and others can be easily produced.
</p>
<p>The <code><a href="#topic+edges">edges</a>()</code> function is useful for handling edge effects.
</p>
<p>Some sample data sets are included, see links below.
</p>
<p>The package is built on top of the <span class="pkg">spatstat</span> library (<a href="http://spatstat.org/">http://spatstat.org/</a>), which needs to be installed first.
</p>


<h3>Author(s)</h3>

<p>Oscar García
</p>
<p>Maintainer: O. Garcia &lt;garcia@dasometrics.net&gt;
</p>


<h3>References</h3>

<p>García, O. &ldquo;Siplab, a spatial individual-based plant modelling system&rdquo;. Computational Ecology and Software 4(4), 215-222. 2014.
(<a href="http://www.iaees.org/publications/journals/ces/articles/2014-4(4)/2014-4(4).asp">http://www.iaees.org/publications/journals/ces/articles/2014-4(4)/2014-4(4).asp</a>).
</p>
<p>García, O. &ldquo;A generic approach to spatial individual-based modelling and simulation of plant communities&rdquo;. Mathematical and Computational Forestry and Nat.-Res. Sci. (MCFNS) 6(1), 36-47. 2014.
(<a href="http://mcfns.net/index.php/Journal/article/view/6_36">http://mcfns.net/index.php/Journal/article/view/6_36</a>).
</p>
<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>.
</p>
<p><a href="http://forestgrowth.unbc.ca/siplab/">http://forestgrowth.unbc.ca/siplab/</a> (no longer maintained).
</p>


<h3>See Also</h3>

<p>Example <span class="pkg">siplab</span> data sets: <code><a href="#topic+boreasNP">boreasNP</a></code>, <code><a href="#topic+boreasNS">boreasNS</a></code>, <code><a href="#topic+boreasSA">boreasSA</a></code>, <code><a href="#topic+boreasSP">boreasSP</a></code>.
</p>
<p>Some <span class="pkg">spatstat</span> standard data sets may also be of interest: <code>finpines</code>, <code>longleaf</code>, <code>spruces</code>, <code>waka</code>.
</p>
<p>For tutorials try the vignettes. E. g., in R type <code>help.start()</code> to open the help browser, and navigate to Packages &gt; siplab &gt; Vignettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pretend that the data is given as a simple data frame
data &lt;- as.data.frame(spruces) #  from a spatstat data set
head(data) # x-y coordinates in a 56x38 m plot, marks are dbh in meters
data$marks = data$marks * 100  # dbh in cm
# Convert to a point pattern object
datap &lt;- as.ppp(data, c(0, 56, 0, 38))  # plot limits (minx, maxx, miny, maxy)
# or datap &lt;- ppp(data$x, data$y, c(0, 56), c(0, 38), marks = data$marks)
# Hegyi (1974) index (as usual without his original 1-foot distance offset)
hegyi &lt;- pairwise(datap, maxR = 6, kernel = powers_ker, kerpar = list(pi=1,
    pj=1, pr=1, smark=1))
head(marks(hegyi))
# ZOI model
zoi &lt;- assimilation(datap, influence=zoi_inf, infpar=c(k=0.2, smark=1),
    asym=1)
</code></pre>

<hr>
<h2 id='assimilation'>
Compute Assimilation Indices
</h2><span id='topic+assimilation'></span><span id='topic+assimilation_pix'></span>

<h3>Description</h3>

<p>This is the main function in <span class="pkg">siplab</span> for computing assimilation indices. Optionally, it computes also a free-growing index, and/or the assimilation centroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assimilation(plants, pixsize = 0.2, resource = 1, influence =
    gnomon_inf, infpar = NULL, asym = Inf, efficiency = flat_eff,
    effpar = NULL, plot = TRUE, afree = FALSE, centroid = FALSE)

assimilation_pix(plants, pixsize = 0.2, resource = 1, influence =
    gnomon_inf, infpar = NULL, asym = Inf, efficiency = flat_eff,
    effpar = NULL, plot = TRUE, afree = FALSE, centroid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assimilation_+3A_plants">plants</code></td>
<td>

<p>A <span class="pkg">spatstat</span> point pattern object (class <code>ppp</code>). It contains the plants coordinates, and marks with the plant size and possibly other attributes.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_pixsize">pixsize</code></td>
<td>

<p>Resolution, approximate step size in the pixel grid. Default 0.2.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_resource">resource</code></td>
<td>

<p>Either a pixel image (class <code>im</code>), or a function, or other object that can be converted to a pixel image, specifying the spatial distribution of resource availability. If an image, it should cover the <code>plants</code> window. It is adjusted to the <code>plants</code> window size and specified resolution if necessary. Default is 1, a uniform distribution with 1 unit of resource per unit area.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_influence">influence</code></td>
<td>

<p>Function for computing influence values. Must take arguments <code>(dx, dy, marks, par)</code>, where <code>dx</code> is a vector of points-to plant x-distances, <code>dy</code> is a vector of points-to plant y-distances, <code>marks</code> are the plant marks, and <code>par</code> receives the value of the <code>infpar</code> argument. Examples are provided in the functions <code><a href="#topic+tass_inf">tass_inf</a>()</code>, etc. (see <a href="#topic+influence">influence</a>). Default: <code><a href="#topic+gnomon_inf">gnomon_inf</a></code>.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_infpar">infpar</code></td>
<td>

<p>Parameter(s) for <code>influence</code>, a list or vector. Default: <code>list(a=1, b=4, smark=1)</code>. Here <code>smark=1</code> indicates that the plant size variable is the first or only item in <code>marks</code>.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_asym">asym</code></td>
<td>

<p>Asymmetry parameter <code class="reqn">\alpha</code> in the allotment function. Default is <code>Inf</code>, which corresponds to one-sided competition (tesselation models). In old versions of <span class="pkg">siplab</span> this parameter was called <code>partpar</code>.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_efficiency">efficiency</code></td>
<td>

<p>Efficiency function for weighting the point-wise resource uptake. Must take arguments <code>(dx, dy, marks)</code> or <code>(dx, dy, marks, par)</code>, where <code>dx</code> is a vector of points-to plant x-distances, <code>dy</code> is a vector of points-to plant y-distances, <code>marks</code> are the plant marks, and <code>par</code> receives the value of the <code>effpar</code> argument if not <code>NULL</code>. Examples are provided in the functions <code><a href="#topic+tass_eff">tass_eff</a>()</code>, etc. (see <a href="#topic+efficiency">efficiency</a>). The default is <code><a href="#topic+flat_eff">flat_eff</a></code>, no weighting.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_effpar">effpar</code></td>
<td>

<p>Parameter(s) for <code>efficiency</code>, usually a list or vector. Default: <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code>, the denominator of the allotment function is graphed as a pixel image, to visualize competition pressure (default).
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_afree">afree</code></td>
<td>

<p>If <code>TRUE</code>, the free-growing assimilation is also computed. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="assimilation_+3A_centroid">centroid</code></td>
<td>

<p>If <code>TRUE</code>, the centroid of the plant assimilation distribution is also computed. Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>assimilation()</code> and <code>assimilation_pix()</code> are functionally equivalent, but the code in <code>assimilation_pix()</code> is somewhat clearer and slower. It may be useful for documentation purposes, and as a basis for user modification.
</p>
<p>Computation starts with a resource intensity map at a spatial resolution given by <code>pixsize</code>. Typically the resource distribution is assumed to be uniform (the default). Plants exert competitive pressure depending on size and distance, described by the <code><a href="#topic+influence">influence</a></code> function. The resource available at each pixel is allotted to plants according to their influence and to an allotment rule parametrized by <code>asym</code>. Finally, the resource uptake is weighted by the <code><a href="#topic+efficiency">efficiency</a></code> function, and is spatially integrated to obtain the plant's assimilation index. Besides size, influence and efficiency functions can include other plant attributes, such as species.
</p>


<h3>Value</h3>

<p>Returns the input point pattern <code>plants</code>, with the marks replaced by a data frame containing the original marks followed by one or more columns containing the computed results. The additional column are the assimilation indices in column <code>aindex</code>, and optionally the free-growing index in <code>afree</code>, and/or the x and y centroid coordinates in <code>cx</code> and <code>cy</code>. 
</p>


<h3>Note</h3>

<p>Requires the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>.
</p>
<p>García, O. (2013) &ldquo;A generic approach to spatial individual-based modelling and simulation of plant communities&rdquo;. Mathematical and Computational Forestry and Nat.-Res. Sci. (MCFNS) 6(1), 36-47. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence">influence</a></code>, <code><a href="#topic+efficiency">efficiency</a></code>, <code><a href="#topic+edges">edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- assimilation(finpines, infpar=list(a=1, b=4,
     smark="height"), afree=TRUE)
summary(a)
system.time(assimilation_pix(finpines))
system.time(assimilation(finpines))
</code></pre>

<hr>
<h2 id='boreas'>
Marked Point Pattern Tree Data from BOREAS
</h2><span id='topic+boreasNP'></span><span id='topic+boreasNS'></span><span id='topic+boreasSA'></span><span id='topic+boreasSP'></span>

<h3>Description</h3>

<p>Four data sets from the Boreal Ecosystem–Atmosphere Study (BOREAS, Rich and Fournier 1999), as used by García (2006). These are approximately evenaged and single-species unmanaged natural forests, from a northern study area in Manitoba and a southern study area in Saskatchewan,  central Canada. Tree coordinates and diameters at breast height (dbh) were measured for all trees taller than 2 m on areas of 50 m <code class="reqn">\times</code> 60 m, subdivided into subplots on a 10 m grid. Tree heights were estimated from height-dbh regressions based on a sample of height measurements. The data here excludes dead trees, and also excludes some trees with coordinates just outside the observation window.
</p>
<p>The 4 data sets are:
</p>

<dl>
<dt><code>boreasNP</code>:</dt><dd><p>Northern study area, Jack pine</p>
</dd>
<dt><code>boreasNS</code>:</dt><dd><p>Northern study area, black spruce</p>
</dd>
<dt><code>boreasSA</code>:</dt><dd><p>Southern study area, trembling aspen</p>
</dd>
<dt><code>boreasSP</code>:</dt><dd><p>Southern study area, Jack pine</p>
</dd>
</dl>



<h3>Format</h3>

<p>Each data set is a <span class="pkg">spatstat</span> marked point pattern object (class <code>ppp</code>). The marks are a data frame with <code>dbh</code> (cm), <code>height</code> (m), <code>species</code>, a <code>dominance</code> classification, and a subplot id.
</p>


<h3>Source</h3>

<p>doi: <a href="https://doi.org/10.3334/ORNLDAAC/359">10.3334/ORNLDAAC/359</a>
</p>


<h3>References</h3>

<p>Rich, P.M., and Fournier, R. (1999) BOREAS TE-23 map plot
data [online]. Oak Ridge National Laboratory Distributed Active
Archive Center, Oak Ridge, Tennessee. Available from
<a href="http://daac.ornl.gov">http://daac.ornl.gov</a>.
</p>
<p>García, O. (2006) Scale and spatial structure effects on tree size distributions: Implications for growth and yield modelling. <em>Canadian Journal of Forest Research</em> <b>36</b>(11), 2983&ndash;2993. doi: <a href="https://doi.org/10.1139/x06-116">10.1139/x06-116</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(boreasNP)
plot(boreasNP)
## Not run: aNP &lt;- assimilation(boreasNP)
# this may take a few minutes!
</code></pre>

<hr>
<h2 id='edges'>
Adjust for Edge Effects
</h2><span id='topic+edges'></span><span id='topic+core'></span>

<h3>Description</h3>

<p>Shrink a point pattern, or expand it through replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(plants, width)

core(plants, distance)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_plants">plants</code></td>
<td>

<p>A <span class="pkg">spatstat</span> point pattern object (class <code>ppp</code>). It normally contains the plants coordinates, and marks with the plant size and possibly other attributes.
</p>
</td></tr>
<tr><td><code id="edges_+3A_width">width</code></td>
<td>

<p>Distance from the edges to shrink, if negative, or to expand, if positive.
</p>
</td></tr>
<tr><td><code id="edges_+3A_distance">distance</code></td>
<td>

<p>Distance from the edges.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing assimilation or competition indices, those near the edges of the study region are distorted because the outside is empty. Common solutions to this problem are not to use indices computed for plants near the edges, or (with rectangular regions) to attach translated copies, thus changing the topology intothat of a torus. This function implements both strategies. When expanding, the extentt of the copies to be used can be specified to avoid unnecessary computation.
</p>
<p>Typically, in the first case the indices are computed for the full pattern, and then the edges are discarded using <code>edges()</code> with a negative <code>width</code>. In the second case, the point pattern is first expanded with <code>edges(plants, width)</code>, the indices are computed for the expanded pattern, and then the resulta are restricted to the original size with <code>edges(result, -width)</code>. 
</p>
<p><code>core()</code> returns a logical vector indicating which plants are at more than the given distance from the edges. Thus, <code>plants[core(plants, width)]</code> is equivalent to <code>edges(plants, -width)</code>.
</p>


<h3>Value</h3>

<p><code>edges()</code> returns a point pattern with the same structure as <code>plants</code>.
</p>
<p>If <code>width</code> is negative, the parts of the pattern that are at a distance less than <code>-width</code> from an edge are discarded.
</p>
<p>If <code>width</code> is positive, the pattern is first expanded by surrounding it with 8 shifted copies (the window must be rectangular). Then, the parts of the pattern that are at a distance greater than <code>width</code> from an edge of the original pattern are discarded.
</p>
<p>If <code>width</code> = 0, <code>plants</code> is returned unchanged.
</p>
<p><code>core()</code> returns a logical vector with <code>TRUE</code> for the plants that are at more than the given distance from the edges, and <code>FALSE</code> for the rest.
</p>


<h3>Note</h3>

<p>Requires the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assimilation">assimilation</a></code>, <code><a href="#topic+pairwise">pairwise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>finpines
edges(finpines, 3)
edges(finpines, -3)
</code></pre>

<hr>
<h2 id='efficiency'>
Efficiency Functions
</h2><span id='topic+efficiency'></span><span id='topic+flat_eff'></span><span id='topic+tass_eff'></span><span id='topic+gates_eff'></span><span id='topic+gnomon_eff'></span><span id='topic+power_eff'></span>

<h3>Description</h3>

<p>Compute efficiency values depending on distance and plant marks, for use in <code><a href="#topic+assimilation">assimilation</a>()</code>.
</p>
<p>Note: In previous versions of <span class="pkg">siplab</span> the function names had
<code>.eff</code> in place of <code>_eff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_eff(dx, dy, marks)

tass_eff(dx, dy, marks, par = list(b = 3.52 * 0.975, c = 6.1,
    smark = 1))

gates_eff(dx, dy, marks, par = list(a = 1, b = 4, smark = 1))

gnomon_eff(dx, dy, marks, par = list(a = 1, b = 4, smark = 1))

power_eff(dx, dy, marks = NULL, par = list(a = 1, b = 0.25, smark = NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency_+3A_dx">dx</code></td>
<td>

<p>Vector of x-distances. Coordinates x for a number of points minus coordinate x of the subject plant.
</p>
</td></tr>
<tr><td><code id="efficiency_+3A_dy">dy</code></td>
<td>

<p>Vector of y-distances. Coordinates y for a number of points minus coordinate y of the subject plant.
</p>
</td></tr>
<tr><td><code id="efficiency_+3A_marks">marks</code></td>
<td>

<p>Mark data for the subject plant.
</p>
</td></tr>
<tr><td><code id="efficiency_+3A_par">par</code></td>
<td>

<p>Optional vector or list of parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can program her/his own efficiency function. It must take the arguments <code>dx</code>, <code>dy</code>, <code>marks</code>, and optionally <code>par</code>.
</p>
<p>Efficiency function values are normally non-negative. Otherwise, they are set to 0 in <code>assimilation()</code>.
</p>
<p>The values of <code>par</code> are taken from the argument <code>effpar</code> of <code>assimilation()</code>, if not <code>NULL</code>. Otherwise the default is used.
</p>
<p><code>smark</code> in <code>par</code> must be 1 or &ldquo;mark&rdquo; if there is only one mark. If the marks are a data frame, <code>smark</code> must be the number or name of the column with the plant size variable.
</p>
<p><code>flat_eff()</code> returns 1, independently of plant size or distance.
</p>
<p><code>tass_eff()</code>, <code>gates_eff()</code>, and <code>gnomon_eff()</code> are proportional to their influence function counterparts (see <code><a href="#topic+influence">influence</a></code>), scaled to be 1 at the origin.
</p>
<p><code>power_eff()</code> is <code class="reqn">\max\{0, \, 1 - b R^a\}</code>, where <code class="reqn">R = \sqrt{\mathrm{dx}^2 + \mathrm{dy}^2}</code> is the plant-to-point distance. It does not depend on plant size, as in Garcia (2022). On second thoughts, this might make more sense than the functions above. Parameters <code>marks</code> and <code>smarks</code> are ignored.
</p>


<h3>Value</h3>

<p>Vector of efficiency values, of length equal to the length of dx and dy.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>García, O. &ldquo;A generic approach to spatial individual-based modelling and simulation of plant communities&rdquo;. Mathematical and Computational Forestry and Nat.-Res. Sci. (MCFNS) 6(1), 36-47. 2014.
</p>
<p>García, O. &ldquo;Plasticity as a link between spatially explicit, distance-independent, and whole-stand forest growth models&rdquo;. Forest Science 68(1), 1-7. 2022.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assimilation">assimilation</a></code>, <code><a href="#topic+influence">influence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example multi-species efficiency function (spruce/hardwoods)
multi_eff &lt;- function (dx, dy, marks, par) {
    out &lt;- numeric(length(dx))
    s &lt;- marks$SPECIES == "Spruce"
    out[s] &lt;- gnomon_eff(dx[s], dy[s], marks[s, ], par=list(a=par$aS,
        b=par$bS, smark=par$smark))
    out[!s] &lt;- gnomon_eff(dx[!s], dy[!s], marks[!s, ], par=list(a=par$aH,
        b=par$bH, smark=par$smark)) # Hardwoods
    return(out)
}
</code></pre>

<hr>
<h2 id='influence'>
Influence Functions
</h2><span id='topic+influence'></span><span id='topic+zoi_inf'></span><span id='topic+tass_inf'></span><span id='topic+gates_inf'></span><span id='topic+gnomon_inf'></span>

<h3>Description</h3>

<p>Compute influence values depending on distance and plant marks, for use in <code><a href="#topic+assimilation">assimilation</a>()</code>.
</p>
<p>Note: In previous versions of <span class="pkg">siplab</span> the function names had
<code>.inf</code> in place of <code>_inf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoi_inf(dx, dy, marks, par = list(k = 0.2, smark = 1))

tass_inf(dx, dy, marks, par = list(b = 3.52 * 0.975, c = 6.1,
    smark = 1))

gates_inf(dx, dy, marks, par = list(a = 1, b = 4, smark = 1))

gnomon_inf(dx, dy, marks, par = list(a = 1, b = 4, smark = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence_+3A_dx">dx</code></td>
<td>

<p>Vector of x-distances. Coordinates x for a number of points minus coordinate x of the subjectt plant.
</p>
</td></tr>
<tr><td><code id="influence_+3A_dy">dy</code></td>
<td>

<p>Vector of y-distances. Coordinates y for a number of points minus coordinate y of the subjectt plant.
</p>
</td></tr>
<tr><td><code id="influence_+3A_marks">marks</code></td>
<td>

<p>Mark data for the subject plant.
</p>
</td></tr>
<tr><td><code id="influence_+3A_par">par</code></td>
<td>

<p>List of parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can program her/his own influence function. It must take the arguments <code>dx</code>, <code>dy</code>, <code>marks</code>, and optionally <code>par</code>.
</p>
<p>Influence function values are normally non-negative. Otherwise, they are set to 0 in <code>assimilation()</code>.
</p>
<p>The values of <code>par</code> are taken from the argument <code>infpar</code> of <code>assimilation()</code>, if not <code>NULL</code>. Otherwise the default is used.
</p>
<p><code>smark</code> in <code>par</code> must be 1 or &ldquo;mark&rdquo; if there is only one mark. If the marks are a data frame, <code>smark</code> must be the number or name of the column with the plant size variable.
</p>
<p>Let <code class="reqn">S</code> be the plant size, and <code class="reqn">R</code> be the Euclidean plant-to-point distance <code class="reqn">R = \sqrt{\mathrm{dx}^2 + \mathrm{dy}^2}</code>. Then the built-in influence functions are:
</p>

<dl>
<dt><code>zoi_inf()</code>:</dt><dd><p>1 if <code class="reqn">R &lt; k S</code>, 0 otherwise</p>
</dd>
<dt><code>tass_inf()</code>:</dt><dd><p><code class="reqn">\max\{0, \, S - c[\exp(R/b) - 1]\}</code></p>
</dd>
<dt><code>gates_inf()</code>:</dt><dd><p><code class="reqn">\max\{0, \, [S^a - (b R)^a]^{1/a}\}</code></p>
</dd>
<dt><code>gnomon_inf()</code>:</dt><dd><p><code class="reqn">\max\{0, \, S - b R^a\}</code></p>
</dd>
</dl>

<p>Other influence functions can be written following these examples.
</p>


<h3>Value</h3>

<p>Vector of influence values, of length equal to the length of dx and dy.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>García, O. &ldquo;A generic approach to spatial individual-based modelling and simulation of plant communities&rdquo;. Mathematical and Computational Forestry and Nat.-Res. Sci. (MCFNS) 6(1), 36-47. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assimilation">assimilation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example multi-species influence function (spruce/hardwoods)
multi_inf &lt;- function (dx, dy, marks, par) {
    out &lt;- numeric(length(dx))
    s &lt;- marks$SPECIES == "Spruce"
    out[s] &lt;- gnomon_inf(dx[s], dy[s], marks[s, ], par=list(a=par$aS,
        b=par$bS, smark=par$smark))
    out[!s] &lt;- gnomon_inf(dx[!s], dy[!s], marks[!s, ], par=list(a=par$aH,
        b=par$bH, smark=par$smark)) # Hardwoods
    return(out)
}
</code></pre>

<hr>
<h2 id='kernel'>
Competition Kernel Functions
</h2><span id='topic+kernel'></span><span id='topic+powers_ker'></span><span id='topic+spurr_ker'></span><span id='topic+staebler_ker'></span>

<h3>Description</h3>

<p>Functions representing the effect of a competitor on a subject plant, depending on distance and plant sizes (marks). For use in <code><a href="#topic+pairwise">pairwise</a>()</code>.
</p>
<p>Note: In previous versions of <span class="pkg">siplab</span> the function names had
<code>.ker</code> in place of <code>_ker</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powers_ker(imarks, jmarks, dists, dranks, par = list(pi=1, pj=1,
    pr=1, smark = 1))

staebler_ker(imarks, jmarks, dists, dranks, par = list(k=0.1, p=1,
    smark=1))

spurr_ker(imarks, jmarks, dists, dranks, par = list(type=1,
    smark=1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_imarks">imarks</code></td>
<td>

<p>Marks for the subject plant, a 1-row data frame.</p>
</td></tr>
<tr><td><code id="kernel_+3A_jmarks">jmarks</code></td>
<td>

<p>Data frame with marks for competitors</p>
</td></tr>
<tr><td><code id="kernel_+3A_dists">dists</code></td>
<td>

<p>Vector of distances between the subject plant and the competitors.</p>
</td></tr>
<tr><td><code id="kernel_+3A_dranks">dranks</code></td>
<td>

<p>Distance ranks.</p>
</td></tr>
<tr><td><code id="kernel_+3A_par">par</code></td>
<td>

<p>List of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>par</code> are taken from the argument <code>kerpar</code> of <code>pairwise()</code>, if not <code>NULL</code>.
</p>
<p><code>smark</code> in <code>par</code> must be 1 or &ldquo;mark&rdquo; if there is only one mark. If the marks are a data frame, <code>smark</code> must be the number or name of the column with the plant size variable.
</p>
<p><code>powers_ker()</code> is a general form that includes many examples from the literature. If <code class="reqn">S_i</code> is the size of the subject plant, <code class="reqn">S_j</code> the size of the competitor, and <code class="reqn">R</code> is the distance between them, then this kernel is <code class="reqn">(S_j^{p_j} / S_i^{p_i}) / R^{p_r}</code>. For instance, the popular Hegyi's index corresponds to <code>pi=1, pj=1, pr=1</code>.
This and other examples could be coded directly if computational efficiency is important, see the  example below.
</p>
<p><code>staebler_ker()</code> is the width of the overlap of zones of influence (ZOI), used by Staebler in 1951. Assumes that the ZOI radius is <code class="reqn">k S^p</code>, where <code class="reqn">S</code> is size.
</p>
<p><code>spurr_ker()</code> is an example of an index that depends on distance ranks: equations (9.5a), (9.5b) of Burkhart and Tomé (2012).
</p>
<p>Competition kernels seem to be limited only by the researchers imagination. Others can be written following these examples.
</p>


<h3>Value</h3>

<p>Vector of length equal to the length of <code>dists</code>.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>Burkhart, H. E. and Tomé, M. (2012) <em>Modeling Forest Trees and Stands</em>. Springer.
</p>
<p>García, O. &ldquo;Siplab, a spatial individual-based plant modelling system&rdquo;. Computational Ecology and Software 4(4), 215-222. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwise">pairwise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Originally Hegyi added one foot to the distance:
hegyiorig_ker &lt;- function(imarks, jmarks, dists, ...) {
# Assume coordinates in meters, and a single mark (dbh)
    (jmarks$mark / imarks$mark) / (dists + 0.30481)
}
</code></pre>

<hr>
<h2 id='pairwise'>
Compute Pairwise Competition Indices 
</h2><span id='topic+pairwise'></span>

<h3>Description</h3>

<p>This function computes competition indices based on pairs of plants, ignoring higher-order interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(plants, maxN = NULL, maxR = NULL, select = NULL, selpar =
         NULL, kernel, kerpar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_plants">plants</code></td>
<td>

<p>A <span class="pkg">spatstat</span> point pattern object (class <code>ppp</code>). It contains the plants coordinates, and marks with the plant size and possibly other attributes.
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_maxn">maxN</code></td>
<td>

<p>Maximum number of nearest neighbors to include as potential competitors. Default is NULL (no restriction).
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_maxr">maxR</code></td>
<td>

<p>Maximum radius to search for potential competitors. Default is NULL (no restriction).
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_select">select</code></td>
<td>

<p>Optional user-supplied selection function for choosing competitors. Must take arguments <code>(imarks, jmarks, dists, dranks)</code> or <code>(imarks, jmarks, dists, dranks, par)</code>, where <code>imarks</code> are the marks for the subject plant (a 1-row data frame), <code>jmarks</code> is a data frame with the marks of the potential competitors, <code>dists</code> is a vector distances between subject plant and the potential competitors, <code>dranks</code> are the distance ranks, and <code>par</code> receives the value of the <code>selpar</code> argument if not <code>NULL</code>. It must return a logical vector with the same length as <code>dists</code>. Examples are provided in the functions <code><a href="#topic+powlinear_sel">powlinear_sel</a>()</code>, etc. (see <a href="#topic+select">select</a>). Default is NULL (no selection).
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_selpar">selpar</code></td>
<td>

<p>Parameter(s) for <code>select</code>, usually a list or vector. Default: NULL. 
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_kernel">kernel</code></td>
<td>

<p>Competition kernel function for computing the effect of competitor <code class="reqn">j</code> on the subject plant <code class="reqn">i</code>. Must yake arguments <code>(imarks, jmarks, dists, dranks)</code> or <code>(imarks, jmarks, dists, dranks, par)</code>, where <code>imarks</code> are the marks for the subject plant (a 1-row data frame), <code>jmarks</code> is a data frame with the marks of the potential competitors, <code>dists</code> is a vector of distances between subject plant and the potential competitors, <code>dranks</code> are the distance ranks, and <code>par</code> receives the value of the <code>kerpar</code> argument if not <code>NULL</code>. It must return a numeric vector with the same length as <code>dists</code>. Examples are provided in the functions <code><a href="#topic+powers_ker">powers_ker</a>()</code>, etc. (see <a href="#topic+kernel">kernel</a>).
</p>
</td></tr>
<tr><td><code id="pairwise_+3A_kerpar">kerpar</code></td>
<td>

<p>Parameter(s) for <code>kernel</code>, usually a list or vector. Default: NULL. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traditionally, the competition index for a subject plant <code class="reqn">i</code> is obtained in two stages: (1) Choose a set of competitors of <code class="reqn">i</code> by some selection rule. (2) Compute a measure of the effect of each competitor <code class="reqn">j</code> on plant <code class="reqn">i</code>, and add over <code class="reqn">j</code>. This effect of <code class="reqn">j</code> on <code class="reqn">i</code> is normally a function of the sizes of both plants and of the distance between them, which we call a competition kernel. The kernel may depend on other plant attributes, like species, and in some rare instances on the distance ranks or on the number of competitors. Conceptually, the first stage is not strictly necessary, it could be replaced by specifying zero kernel values (the effect of the selection is usually to truncate the kernel function beyond some distance). However, a separate selection rule may be more transparent, and may reduce the computational effort in searching for neighbors.
</p>
<p>Some simple selection rules can be implemented by giving a value to <code>maxN</code> and/or <code>maxR</code>. In any case, reasonable limits on these variables may be advisable for reducing computation.
</p>
<p>More complex rules can be specified by the <code>select</code> function, with parameters in <code>selpar</code>. See <code><a href="#topic+select">select</a></code> for examples.  If more than one of <code>maxN</code>,  <code>maxR</code> or <code>select</code> are given, the intersection of the selection criteria is used.
</p>
<p>Kernel computation is specified by the <code>kernel</code> function and the parameters in <code>kerpar</code>. See <code><a href="#topic+kernel">kernel</a></code> for examples.
</p>


<h3>Value</h3>

<p>Returns the input point pattern <code>plants</code>, with the marks replaced by a data frame containing the original marks followed by the competition index in a column named <code>cindex</code>. 
</p>


<h3>Note</h3>

<p>Requires the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>García, O. &ldquo;Siplab, a spatial individual-based plant modelling system&rdquo;. Computational Ecology and Software 4(4), 215-222. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>, <code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+edges">edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Hegyi (1974) index (no distance offset, as usual)
summary(pairwise(finpines, maxR = 6, kernel=powers_ker))
</code></pre>

<hr>
<h2 id='select'>
Competitor Selection Rules
</h2><span id='topic+select'></span><span id='topic+size_sel'></span><span id='topic+powlinear_sel'></span>

<h3>Description</h3>

<p>Functions returning TRUE for plants that compete with a given subject plant, or FALSE otherwise. The decision can depend on distance and plant marks. For use in <code><a href="#topic+pairwise">pairwise</a>()</code>.
</p>
<p>Note: In previous versions of <span class="pkg">siplab</span> the function names had
<code>.sel</code> in place of <code>_sel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size_sel(imarks, jmarks, dists, dranks, par = list(k = 0.2, smark
    = 1))

powlinear_sel(imarks, jmarks, dists, dranks, par = list(ki = 0.2,
    kj = 0, p = 1, r0 = 0, smark=1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_imarks">imarks</code></td>
<td>

<p>Marks for the subject plant, a 1-row data frame.</p>
</td></tr>
<tr><td><code id="select_+3A_jmarks">jmarks</code></td>
<td>

<p>Data frame with marks for potential competitors</p>
</td></tr>
<tr><td><code id="select_+3A_dists">dists</code></td>
<td>

<p>Vector of distances between the subject plant and the potential competitors.</p>
</td></tr>
<tr><td><code id="select_+3A_dranks">dranks</code></td>
<td>

<p>Distance ranks.</p>
</td></tr>
<tr><td><code id="select_+3A_par">par</code></td>
<td>

<p>List of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>par</code> are taken from the argument <code>selpar</code> of <code>pairwise()</code>, if not <code>NULL</code>.
</p>
<p><code>smark</code> in <code>par</code> must be 1 or &ldquo;mark&rdquo; if there is only one mark. If the marks are a data frame, <code>smark</code> must be the number or name of the column with the plant size variable.
</p>
<p><code>size_sel()</code> is a simple example where competitors are selected within a radius proportional to plant size. This corresponds to the second example in Section 9.2.1 of Burkhart and Tomé (2012).
</p>
<p>Note that their first example (fixed radius) is implemented by giving a value to <code>maxR</code> in <code><a href="#topic+pairwise">pairwise</a>()</code>, no <code>select</code> function is needed. Similarly, their third example (fixed number of nearest neighbors) is obtained by giving a value to <code>maxN</code>.
</p>
<p><code>powlinear_sel()</code> is a general form that covers all the other examples in Burkhart and Tomé (2012) by choosing specific parameters values  (except for the <em>competition elimination angle</em>, which depends on relative positions among competitors and not only on distances).
It implements a condition <code>distance &lt; ki * sizei^p + kj * sizej^p + r0</code>, with the following special cases:
</p>

<ul>
<li><p> Multiple of crown radius: <code>kj=0, p=1, r0=0, smark="crownwidth"</code>.
</p>
</li>
<li><p> Angle count sampling: <code>ki=0, p=1, r0=0, smark="dbh"</code>.
</p>
</li>
<li><p> Areas of influence overlap: <code>ki=kj, p=1, r0=0</code>, if the radius is a linear function of size (<code>p</code> not 1 for an allometric relationship).
</p>
</li>
<li><p> Vertical search cone: If the height of the cone vertex is constant, proportional to tree height, or more generally some linear function <code class="reqn">c_1 h_i + c_2</code>, then <code>ki</code> = <code class="reqn">- c_1 / \tan(90 - \beta/2)</code>, <code>kj</code> = <code class="reqn">1 / \tan(90 - \beta/2)</code>, <code>p=1</code>, <code>r0</code> = <code class="reqn">- c_2 / \tan(90 - \beta/2)</code>, <code>smark="height"</code>.
</p>
</li></ul>

<p>These and other examples could be coded directly if computational efficiency is important.
</p>


<h3>Value</h3>

<p>Logical vector of length equal to the length of <code>dists</code>.
</p>


<h3>Author(s)</h3>

<p>Oscar García.
</p>


<h3>References</h3>

<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>Burkhart, H. E. and Tomé, M. (2012) <em>Modeling Forest Trees and Stands</em>. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwise">pairwise</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
