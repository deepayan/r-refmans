<!DOCTYPE html><html lang="en"><head><title>Help for package pegas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pegas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pegas-package'>
<p>Population and Evolutionary Genetics Analysis System</p></a></li>
<li><a href='#all.equal.haploNet'><p>Compare Two Haplotype Networks</p></a></li>
<li><a href='#alleles2loci'><p>Build Loci Object From Matrix of Alleles</p></a></li>
<li><a href='#allelicrichness'><p>Allelic Richness and Rarefaction Plots</p></a></li>
<li><a href='#amova'><p>Analysis of Molecular Variance</p></a></li>
<li><a href='#as.loci'><p>Conversion Among Allelic Data Classes</p></a></li>
<li><a href='#bind.loci'><p>Bind Loci Objects</p></a></li>
<li><a href='#by.loci'><p>Summary by Population or Other Factor</p></a></li>
<li><a href='#cophenetic.haploNet'><p>Cophenetic Matrix on Haplotype Networks</p></a></li>
<li><a href='#diffHaplo'><p>Comparison Between Two Haplotypes</p></a></li>
<li><a href='#dist.asd'><p>Allelic Sharing Distance</p></a></li>
<li><a href='#dist.hamming'><p>Hamming Distance</p></a></li>
<li><a href='#edit.loci'><p>Edit Allelic Data with R's Data Editor</p></a></li>
<li><a href='#F4'><p>F-Statistics From Patterson et al</p></a></li>
<li><a href='#Fst'><p>F-Statistics</p></a></li>
<li><a href='#geod'><p>Geodesic Distances</p></a></li>
<li><a href='#geoTrans'><p>Manipulate Geographical Coordinates</p></a></li>
<li><a href='#getHaploNetOptions'><p>Options to Plot haploNet Objects</p></a></li>
<li><a href='#hap.div'><p>Haplotype Diversity</p></a></li>
<li><a href='#haploFreq'><p>Haplotype Frequencies With a Covariate</p></a></li>
<li><a href='#haploNet'><p>Haplotype Networks</p></a></li>
<li><a href='#haplotype'><p>Haplotype Extraction and Frequencies</p></a></li>
<li><a href='#haplotype.loci'><p>Haplotype Extraction and Frequencies From Allelic Data</p></a></li>
<li><a href='#heterozygosity'><p>Heterozygosity at a Locus Using Gene Frequencies</p></a></li>
<li><a href='#hw.test'><p>Test of Hardy&ndash;Weinberg Equilibrium</p></a></li>
<li><a href='#jaguar'><p>Jaguar Micro-Satellites</p></a></li>
<li><a href='#LD'><p>Linkage Disequilibrium</p></a></li>
<li><a href='#LDscan'><p>Multi-Locus Linkage Disequilibrium</p></a></li>
<li><a href='#mjn'><p>Median-Joining Network</p></a></li>
<li><a href='#MMD'><p>Mismatch Distribution</p></a></li>
<li><a href='#mst'><p>Minimum Spanning Tree and Network</p></a></li>
<li><a href='#mutations'><p>Plot Mutations on Networks</p></a></li>
<li><a href='#na.omit.loci'><p>Missing Allelic Data</p></a></li>
<li><a href='#nuc.div'><p>Nucleotide Diversity</p></a></li>
<li><a href='#plotNetMDS'><p>Plot Networks With MDS Layout</p></a></li>
<li><a href='#R2.test'><p>Ramos-Onsins&ndash;Rozas Test of Neutrality</p></a></li>
<li><a href='#read.gtx'><p>Read Genetix Data Files</p></a></li>
<li><a href='#read.loci'><p>Read Allelic Data Files</p></a></li>
<li><a href='#read.vcf'><p>Read Variant Calling Format Files</p></a></li>
<li><a href='#replot'><p>Edit the Layout of a Haplotype Network</p></a></li>
<li><a href='#rr.test'><p>Tajima Relative Rate Test of Molecular Clock</p></a></li>
<li><a href='#site.spectrum'><p>Site Frequency Spectrum</p></a></li>
<li><a href='#stairway'><p>The Stairway Plot</p></a></li>
<li><a href='#subset.haplotype'><p>Subsetting and Filtering Haplotypes</p></a></li>
<li><a href='#summary.loci'><p>Print and Summaries of Loci Objects</p></a></li>
<li><a href='#sw'><p>Sliding Windows</p></a></li>
<li><a href='#tajima.test'><p>Test of the Neutral Mutation Hypothesis</p></a></li>
<li><a href='#theta.h'><p>Population Parameter THETA using Homozygosity</p></a></li>
<li><a href='#theta.k'><p>Population Parameter THETA using Expected Number of Alleles</p></a></li>
<li><a href='#theta.msat'>
<p>Population Parameter THETA From Micro-Satellites</p></a></li>
<li><a href='#theta.s'><p>Population Parameter THETA using Segregating Sites</p></a></li>
<li><a href='#theta.tree'>
<p>Population Parameter THETA Using Genealogy</p></a></li>
<li><a href='#utilities'><p>Utily Functions for pegas</p></a></li>
<li><a href='#VCFloci'><p>Information From VCF Files</p></a></li>
<li><a href='#write.loci'><p>Write Allelic Data Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Population and Evolutionary Genetics Analysis System</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), ape (&ge; 5.3-11)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, snpStats, adegenet</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for reading, writing, plotting, analysing, and manipulating allelic and haplotypic data, including from VCF files, and for the analysis of population nucleotide sequences and micro-satellites including coalescent analyses, linkage disequilibrium, population structure (Fst, Amova) and equilibrium (HWE), haplotype networks, minimum spanning tree and network, and median-joining networks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://emmanuelparadis.github.io/pegas.html">https://emmanuelparadis.github.io/pegas.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 04:25:30 UTC; paradis</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Paradis <a href="https://orcid.org/0000-0003-3092-2199"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Thibaut Jombart <a href="https://orcid.org/0000-0003-2226-8692"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Brian Knaus <a href="https://orcid.org/0000-0003-1665-4343"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Klaus Schliep <a href="https://orcid.org/0000-0003-2941-0161"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Alastair Potts <a href="https://orcid.org/0000-0003-0919-7279"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  David Winter <a href="https://orcid.org/0000-0002-6165-0029"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pegas-package'>
Population and Evolutionary Genetics Analysis System
</h2><span id='topic+pegas-package'></span><span id='topic+pegas'></span>

<h3>Description</h3>

<p><span class="pkg">pegas</span> provides functions for the analysis of allelic data and of
haplotype data from DNA sequences. It requires and complements two
other R-packages: <span class="pkg">ape</span> and <span class="pkg">adegenet</span>.
</p>
<p>The complete list of functions can be displayed with
<code>library(help = pegas)</code>.
</p>
<p>More information on <span class="pkg">pegas</span> can be found at
<a href="https://emmanuelparadis.github.io/pegas.html">https://emmanuelparadis.github.io/pegas.html</a>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Thibaut Jombart, Zhian N. Kamvar, Brian Knaus,
Alastair Potts, Klaus Schliep, David Winter
</p>
<p>Maintainer: Emmanuel Paradis
</p>

<hr>
<h2 id='all.equal.haploNet'>Compare Two Haplotype Networks</h2><span id='topic+all.equal.haploNet'></span>

<h3>Description</h3>

<p>This function compares two haplotype networks and returns either
<code>TRUE</code> or a description of the differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haploNet'
all.equal(target, current, use.steps = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.haploNet_+3A_target">target</code>, <code id="all.equal.haploNet_+3A_current">current</code></td>
<td>
<p>two objects of class <code>"haplotype"</code>.</p>
</td></tr>
<tr><td><code id="all.equal.haploNet_+3A_use.steps">use.steps</code></td>
<td>
<p>a logical value: whether to consider the number of
steps (or length) in each link.</p>
</td></tr>
<tr><td><code id="all.equal.haploNet_+3A_...">...</code></td>
<td>
<p>(unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should return <code>TRUE</code> if the two networks are
identical even if the links are ordered differently. In all other
situations, a vector of character strings describing the differences
is returned.
</p>
<p>As usual with the <code><a href="base.html#topic+all.equal">all.equal</a></code> function, this cannot
be used directly to return a <code>TRUE</code>/<code>FALSE</code> value (see
examples).
</p>


<h3>Value</h3>

<p>either a logical value (<code>TRUE</code>), or a vector of mode character.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>, <code><a href="#topic+mst">mst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- dist.dna(woodmouse, "n")
nt1 &lt;- mst(d)
nt2 &lt;- msn(d)
(comp &lt;- all.equal(nt1, nt2)) # clearly different

## how to use all.equal to return TRUE/FALSE:
isTRUE(comp) # FALSE
</code></pre>

<hr>
<h2 id='alleles2loci'>Build Loci Object From Matrix of Alleles</h2><span id='topic+alleles2loci'></span><span id='topic+loci2alleles'></span>

<h3>Description</h3>

<p>These functions transform a matrix of alleles into an object of class
<code>"loci"</code>, or the reverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleles2loci(x, ploidy = 2, rownames = NULL, population = NULL,
             phased = FALSE)
loci2alleles(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alleles2loci_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame where each column is an allele, or
an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="alleles2loci_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer specifying the level of ploidy.</p>
</td></tr>
<tr><td><code id="alleles2loci_+3A_rownames">rownames</code></td>
<td>
<p>an integer giving the column number to be used as
rownames of the output.</p>
</td></tr>
<tr><td><code id="alleles2loci_+3A_population">population</code></td>
<td>
<p>an integer giving the column number to be used as
population (if any).</p>
</td></tr>
<tr><td><code id="alleles2loci_+3A_phased">phased</code></td>
<td>
<p>a logical specifying whether the genotypes should be
output as phased. By default, they are unphased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic data matrices are often arranged with one allele
in each column of the matrix (particularly for micro-satellites), so
that the number of columns is equal to the number of loci times the
level of ploidy. <code>alleles2loci</code> transforms such matrices into a
<code>"loci"</code> object.
</p>
<p>If the rownames of the input matrix are already set, they are used in
the output. Alternatively, it is possible to specify which column to
use as rownames (this column will be deleted before creating the
genotypes).
</p>
<p>If the input matrix has colnames, then the names of the first column of
each genotype is used as names of the output loci (see examples).
</p>
<p><code>loci2alleles</code> checks that all individuals have the ploidy for a
given locus (if not an error occurs), but ploidy can vary among loci.
</p>


<h3>Value</h3>

<p>an object of class <code>"loci"</code> or a matrix.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="#topic+as.loci">as.loci</a></code>
</p>
<p>The vignette &ldquo;ReadingFiles&rdquo; explains how to read such a data
set from Dryad (<a href="https://datadryad.org/stash">https://datadryad.org/stash</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c("A", "A", "A", "a"), 2)
colnames(x) &lt;- c("Loc1", NA)
y &lt;- alleles2loci(x)
print(y, details = TRUE)
loci2alleles(y)
</code></pre>

<hr>
<h2 id='allelicrichness'>Allelic Richness and Rarefaction Plots</h2><span id='topic+allelicrichness'></span><span id='topic+rarefactionplot'></span><span id='topic+rhost'></span>

<h3>Description</h3>

<p>These functions analyse allelic richness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allelicrichness(x, pop = NULL, method = "extrapolation", min.n = NULL)
rarefactionplot(x, maxn = nrow(x), type = "l", xlab = "Sample size",
                ylab = "Expected number of alleles", plot = TRUE, ...)
rhost(x, pop = NULL, method = "extrapolation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allelicrichness_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_pop">pop</code></td>
<td>
<p>a vector or factor giving the population assignment of each
row of <code>x</code>, or a single numeric value specifying which column
of <code>x</code> to use as population indicator. By default, the column
labelled <code>"population"</code> is used.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_method">method</code></td>
<td>
<p>a character string which should be one of
&ldquo;extrapolation&rdquo;, &ldquo;rarefaction&rdquo;, &ldquo;raw&rdquo; or an unambiguous
abbreviation of these.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_min.n">min.n</code></td>
<td>
<p>the value of <code class="reqn">n</code> used in the rarefaction method; by
default, the smallest observed number of genotypes within a population.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_maxn">maxn</code></td>
<td>
<p>the largest sample size used to calculate the rarefaction
curve.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_type">type</code>, <code id="allelicrichness_+3A_xlab">xlab</code>, <code id="allelicrichness_+3A_ylab">ylab</code></td>
<td>
<p>arguments passed to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_plot">plot</code></td>
<td>
<p>a logical value specifying whether to do the rarefaction
plot (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="allelicrichness_+3A_...">...</code></td>
<td>
<p>arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>allelicrichness</code> computes for each locus in <code>x</code> the
estimated allelic richness. Three methods are available: the
extrapolation method (Foulley and Ollivier 2006), the rarefaction
method (Hurlbert 1971), and the raw numbers of alleles.
</p>
<p><code>rarefactionplot</code> computes the rarefaction curves of the number
of alleles with respect to sample size using Hurlbert's (1971)
method. A plot is made by default.
</p>


<h3>Value</h3>

<p><code>allelicrichness</code> returns a numeric matrix.
</p>
<p><code>rarefactionplot</code> returns invisibly a list of matrices with the
coordinates of the rarefaction plots for each locus.
</p>
<p><code>rhost</code> returns a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>El Mousadik, A. and Petit, R. J. (1996) High level of genetic
differentiation for allelic richness among populations of the argan
tree [Argania spinosa (L. Skeels)] endemic to
Morocco. <em>Theoretical and Applied Genetics</em>, <b>92</b>,
832&ndash;836.
</p>
<p>Foulley, J. L. and Ollivier, L. (2006) Estimating allelic richness and
its diversity. <em>Livestock Science</em>, <b>101</b>, 150&ndash;158.
</p>
<p>Hurlbert, S. H. (1971) The nonconcept of species diversity: a critique
and alternative parameters. <em>Ecology</em>, <b>52</b>, 577&ndash;586.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
rarefactionplot(jaguar)
allelicrichness(jaguar)
rhost(jaguar)
</code></pre>

<hr>
<h2 id='amova'>Analysis of Molecular Variance</h2><span id='topic+amova'></span><span id='topic+print.amova'></span><span id='topic+getPhi'></span><span id='topic+write.pegas.amova'></span>

<h3>Description</h3>

<p>This function performs a hierarchical analysis of molecular variance
as described in Excoffier et al. (1992). This implementation accepts
any number of hierarchical levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amova(formula, data = NULL, nperm = 1000, is.squared = FALSE)
## S3 method for class 'amova'
print(x, ...)
getPhi(sigma2)
write.pegas.amova(x, file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amova_+3A_formula">formula</code></td>
<td>
<p>a formula giving the AMOVA model to be fitted with the
distance matrix on the left-hand side of the <code>~</code>, and the
population, region, etc, levels on its right-hand side (see details).</p>
</td></tr>
<tr><td><code id="amova_+3A_data">data</code></td>
<td>
<p>an optional data frame where to find the hierarchical
levels; by default they are searched for in the user's workspace.</p>
</td></tr>
<tr><td><code id="amova_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations for the tests of hypotheses
(1000 by default). Set this argument to 0 to skip the tests and
simply estimate the variance components.</p>
</td></tr>
<tr><td><code id="amova_+3A_is.squared">is.squared</code></td>
<td>
<p>a logical specifying whether the distance matrix has
already been squared.</p>
</td></tr>
<tr><td><code id="amova_+3A_x">x</code></td>
<td>
<p>an object of class <code>"amova"</code>.</p>
</td></tr>
<tr><td><code id="amova_+3A_sigma2">sigma2</code></td>
<td>
<p>a named vector of variance components.</p>
</td></tr>
<tr><td><code id="amova_+3A_file">file</code></td>
<td>
<p>a file name.</p>
</td></tr>
<tr><td><code id="amova_+3A_...">...</code></td>
<td>
<p>unused (here for compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula must be of the form <code>d ~ A/B/...</code> where <code>d</code> is a
distance object, and <code>A</code>, <code>B</code>, etc, are the hierarchical
levels from the highest to the lowest one. Any number of levels is
accepted, so specifying <code>d ~ A</code> will simply test for population
differentiation.
</p>
<p>It is assumed that the rows of the distance matrix are in the same
order than the hierarchical levels (which may be checked by the user).
</p>
<p>The function <code>getPhi()</code> is a convenience function for extracting a
table of hierarchical Phi-statistics for reporting. This will be an N+1
by N matrix where N is the number of hierarchcial levels and GLOBAL is
always the first row of the matrix. The matrix can read as COLUMN in ROW.
</p>
<p>If the variance components passed to getPhi() are not named, they will
be reported as &quot;level 1&quot;, &quot;level 2&quot;, etc.
</p>


<h3>Value</h3>

<p>An object of class <code>"amova"</code> which is a list with a table of sums
of square deviations (SSD), mean square deviations (MSD), and the
number of degrees of freedom, and a vector of variance components.
</p>


<h3>Note</h3>

<p>If there are more than three levels, approximate formulae are used to
estimate the variance components.
</p>
<p>If there is an error message like this:
</p>
<p><code>Error in FUN(X[[1L]], ...) : 'bin' must be numeric or a factor</code>
</p>
<p>it may be that the factors you use in the formula were not read
correctly. You may convert them with the function <code>factor</code>, or,
before reading your data files, do this command (in case this option
was modified):
</p>
<p><code>options(stringsAsFactors = TRUE)</code>
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Zhian N. Kamvar, and Brian Knaus</p>


<h3>References</h3>

<p>Excoffier, L., Smouse, P. E. and Quattro, J. M. (1992) Analysis of
molecular variance inferred from metric distances among DNA
haplotypes: application to human mitochondrial DNA restriction
data. <em>Genetics</em>, <b>131</b>, 479&ndash;491.
</p>


<h3>See Also</h3>

<p><code>amova</code> in <span class="pkg">ade4</span> for an implementation of the original
Excoffier et al.'s model; <code>adonis</code> in <span class="pkg">vegan</span> for a general
(multivariate) implementation of an ANOVA framework with distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### All examples below have 'nperm = 100' for faster execution times.
### The default 'nperm = 1000' is recommended.
require(ape)
data(woodmouse)
d &lt;- dist.dna(woodmouse)
g &lt;- factor(c(rep("A", 7), rep("B", 8)))
p &lt;- factor(c(rep(1, 3), rep(2, 4), rep(3, 4), rep(4, 4)))
(d_gp &lt;- amova(d ~ g/p, nperm = 100)) # 2 levels
sig2 &lt;- setNames(d_gp$varcomp$sigma2, rownames(d_gp$varcomp))
getPhi(sig2) # Phi table
amova(d ~ p, nperm = 100) # 1 level
amova(d ~ g, nperm = 100)

## 3 levels (quite slow):
## Not run: 
pop &lt;- gl(64, 5, labels = paste0("pop", 1:64))
region &lt;- gl(16, 20, labels = paste0("region", 1:16))
conti &lt;- gl(4, 80, labels = paste0("conti", 1:4))
dd &lt;- as.dist(matrix(runif(320^2), 320))
(dd_crp &lt;- amova(dd ~ conti/region/pop, nperm = 100))
sig2 &lt;- setNames(dd_crp$varcomp$sigma2, rownames(dd_crp$varcomp))
getPhi(sig2)

## End(Not run)</code></pre>

<hr>
<h2 id='as.loci'>Conversion Among Allelic Data Classes</h2><span id='topic+as.loci'></span><span id='topic+as.loci.genind'></span><span id='topic+as.loci.data.frame'></span><span id='topic+as.loci.matrix'></span><span id='topic+as.loci.factor'></span><span id='topic+as.loci.character'></span><span id='topic+genind2loci'></span><span id='topic+loci2genind'></span><span id='topic+loci2SnpMatrix'></span>

<h3>Description</h3>

<p>These functions do conversion among different allelic data classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.loci(x, ...)
## S3 method for class 'genind'
as.loci(x, ...)
genind2loci(x)
## S3 method for class 'data.frame'
as.loci(x, allele.sep = "/|", col.pop = NULL, col.loci = NULL, ...)
loci2genind(x, ploidy = 2, na.alleles = c("0", "."), unphase = TRUE)
## S3 method for class 'factor'
as.loci(x, allele.sep = "/|", ...)
## S3 method for class 'character'
as.loci(x, allele.sep = "/|", ...)
loci2SnpMatrix(x, checkSNP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.loci_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code> or <code>"genind"</code>, a data
frame, a factor, or a vector of mode character.</p>
</td></tr>
<tr><td><code id="as.loci_+3A_allele.sep">allele.sep</code></td>
<td>
<p>the character(s) separating the alleles for each locus
in the data file (a forward slash by default).</p>
</td></tr>
<tr><td><code id="as.loci_+3A_col.pop">col.pop</code></td>
<td>
<p>specifies whether one of the column of the data file
identifies the population; default <code>NULL</code>, otherwise an integer
or a character giving the number or the name of the column.</p>
</td></tr>
<tr><td><code id="as.loci_+3A_col.loci">col.loci</code></td>
<td>
<p>a vector of integers or of characters specifying the
indices or the names of the columns that are loci. By default, all
columns are taken as loci except the one labelled &quot;population&quot;, if
present or specified.</p>
</td></tr>
<tr><td><code id="as.loci_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level (see details).</p>
</td></tr>
<tr><td><code id="as.loci_+3A_na.alleles">na.alleles</code></td>
<td>
<p>a vector of charater strings giving the alleles
to be treated as missing data.</p>
</td></tr>
<tr><td><code id="as.loci_+3A_unphase">unphase</code></td>
<td>
<p>a logical value; by default, the genotypes are unphased
before conversion (this should not be changed).</p>
</td></tr>
<tr><td><code id="as.loci_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.loci_+3A_checksnp">checkSNP</code></td>
<td>
<p>a logical value. If you are sure that all data in the
<code>"loci"</code> object are SNPs, using <code>checkSNP = FALSE</code> makes
it faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main objectives of these functions is to provide easy conversion
between the data structures of <span class="pkg">adegenet</span> and <span class="pkg">pegas</span>, so both
packages can be used together smoothly. In addition, it is possible to
create a <code>"loci"</code> object directly from a data frame, a vector, or
a factor.
</p>
<p><code>genind2loci(x)</code> and <code>as.loci(x)</code> are the same if <code>x</code>
is of class <code>"genind"</code>.
</p>
<p>The ploidy level specified in <code>loci2genind</code> can be a vector in
which case it should be of length equal to the number of individuals
and will be interpreted as giving the ploidy of each of them. Note
that this is different from <code><a href="#topic+getPloidy">getPloidy</a></code> which returns the
ploidy level of each locus.
</p>


<h3>Value</h3>

<p>An object of class <code>c("loci", "data.frame")</code> for <code>as.loci</code>
and <code>genind2loci</code>; an object of class <code>"genind"</code> for
<code>loci2genind</code>; an object of class <code>"SnpMatrix"</code> for
<code>loci2SnpMatrix</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="adegenet.html#topic+genind-class">genind</a></code>,
<code><a href="adegenet.html#topic+df2genind">df2genind</a></code> for converting data frames to
<code>"genind"</code>, <code><a href="#topic+alleles2loci">alleles2loci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("A-A", "A-a", "a-a")
as.loci(x, allele.sep = "-")
## Not run: 
require(adegenet)
data(nancycats)
x &lt;- as.loci(nancycats)
y &lt;- loci2genind(x) # back to "genind"
identical(nancycats@tab, y@tab)
identical(nancycats@pop, y@pop)

## End(Not run)</code></pre>

<hr>
<h2 id='bind.loci'>Bind Loci Objects</h2><span id='topic+bind.loci'></span><span id='topic+rbind.loci'></span><span id='topic+cbind.loci'></span>

<h3>Description</h3>

<p>These functions combine objects of class <code>"loci"</code> by binding
their rows or their columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
rbind(...)
## S3 method for class 'loci'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind.loci_+3A_...">...</code></td>
<td>
<p>some object(s) of class <code>"loci"</code>, separated with
commas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two methods call <code>[rc]bind.data.frame</code> and take care to
respect the attribute &ldquo;locicol&rdquo; of the returned object.
</p>
<p>You can pass a data frame in the <code>...</code>, but then you should
bypass the generic by calling <code>cbind.loci</code> directly. Do not try
to pass a vector: this will mess the &ldquo;locicol&rdquo; attribute. Instead,
make a data frame with this vector (see examples).
</p>


<h3>Value</h3>

<p>An object of class <code>"loci"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p>[.loci</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- as.loci(data.frame(x = "A/a", y = 1), col.loci = 1)
b &lt;- as.loci(data.frame(y = 2, x = "A/A"), col.loci = 2)
## rbind.loci reorders the columns if necessary:
str(rbind(a, b))
## cbind sets "locicol" correctly:
str(cbind(a, b))
str(cbind(b, a))
## Unexpected result...
str(cbind(a, data.frame(z = 10)))
## ... bypass the generic:
str(pegas:::cbind.loci(a, data.frame(z = 10)))
## ... or much better: a$z &lt;- 10
## Here "locicol" is not correct...
str(pegas:::cbind.loci(z = 10, a))
## ... instead
str(pegas:::cbind.loci(data.frame(z = 10), a))
</code></pre>

<hr>
<h2 id='by.loci'>Summary by Population or Other Factor</h2><span id='topic+by.loci'></span>

<h3>Description</h3>

<p>This is an implementation of the generic <code><a href="base.html#topic+by">by</a></code>
function which applies a function to some data for a each level of a
categorical factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
by(data, INDICES = data$population, FUN = NULL, ..., simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by.loci_+3A_data">data</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="by.loci_+3A_indices">INDICES</code></td>
<td>
<p>a vector of the same length as the number of rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="by.loci_+3A_fun">FUN</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="by.loci_+3A_...">...</code></td>
<td>
<p>(currently unused).</p>
</td></tr>
<tr><td><code id="by.loci_+3A_simplify">simplify</code></td>
<td>
<p>(currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>FUN = NULL</code> calculates allele frequencies for each
population in <code>data</code>.
</p>


<h3>Value</h3>

<p>a list by default indexed by locus.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+by">by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
by(jaguar)
by(na.omit(jaguar))
</code></pre>

<hr>
<h2 id='cophenetic.haploNet'>Cophenetic Matrix on Haplotype Networks</h2><span id='topic+cophenetic.haploNet'></span>

<h3>Description</h3>

<p>This function calculates the cophenetic distance on a network. The
output can be used to find nodes with short distances to most nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haploNet'
cophenetic(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cophenetic.haploNet_+3A_x">x</code></td>
<td>
<p>an object of class <code>"haploNet"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of the function are likely to be approximate in most
cases with reticulations in the network. In the case of MSTs, the
results are exact.
</p>


<h3>Value</h3>

<p>a numeric matrix with colnames and rownames set to the labels of the
network nodes.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+cophenetic.phylo">cophenetic.phylo</a></code> in <span class="pkg">ape</span>,
<code><a href="stats.html#topic+cophenetic">cophenetic</a></code> for the generic function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(mst)
coph &lt;- cophenetic(r)
rowSums(coph)
</code></pre>

<hr>
<h2 id='diffHaplo'>Comparison Between Two Haplotypes</h2><span id='topic+diffHaplo'></span>

<h3>Description</h3>

<p>This function compares two haplotypes and returns a summary of the
differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffHaplo(h, a = 1, b = 2, strict = FALSE, trailingGapsAsN = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffHaplo_+3A_h">h</code></td>
<td>
<p>an object of class <code>"haplotype"</code>.</p>
</td></tr>
<tr><td><code id="diffHaplo_+3A_a">a</code>, <code id="diffHaplo_+3A_b">b</code></td>
<td>
<p>two integers (or character strings) giving the indices (or
labels) of the two haplotypes to be compared.</p>
</td></tr>
<tr><td><code id="diffHaplo_+3A_strict">strict</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, ambiguities and gaps in
the sequences are ignored and treated as separate characters.</p>
</td></tr>
<tr><td><code id="diffHaplo_+3A_trailinggapsasn">trailingGapsAsN</code></td>
<td>
<p>a logical value; if <code>TRUE</code> (the default),
the leading and trailing alignment gaps are considered as unknown
bases (i.e., N). This option has no effect if <code>strict = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options <code>strict</code> and <code>trailingGapsAsN</code> are passed to
<code><a href="ape.html#topic+seg.sites">seg.sites</a></code>.
</p>


<h3>Value</h3>

<p>a data frame with three columns named <code>pos</code> (position of the
differences) and the labels of the two haplotypes compared.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>, <code><a href="#topic+haplotype">haplotype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
h &lt;- haplotype(woodmouse)
diffHaplo(h) # compares the 1st and 2nd haplotypes
diffHaplo(h, 1, 3)
diffHaplo(h, "I", "III") # same than above but using labels
</code></pre>

<hr>
<h2 id='dist.asd'>Allelic Sharing Distance</h2><span id='topic+dist.asd'></span>

<h3>Description</h3>

<p>This function computes the allelic sharing distance (ASD) for diploid
genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.asd(x, scaled = TRUE, pairwise.deletion = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.asd_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="dist.asd_+3A_scaled">scaled</code></td>
<td>
<p>a logical value specifying whether the distances should
be scaled by the number of loci.</p>
</td></tr>
<tr><td><code id="dist.asd_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical value: whether to check for missing
values for each pairwise comparison (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ASD between two diploid genotypes is (Gao and Martin, 2009):
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{L}\sum_{j=1}^L d_j</code>
</p>

<p>where <code class="reqn">L</code> is the number loci, <code class="reqn">d_j</code> is the value for the
<code class="reqn">j</code>th locus: 0 if both genotypes are identical, 1 if they have one
allele in common, or 2 if they have no allele in common.
</p>
<p><code>dist.asd</code> works for all diploid genotypes (phased or unphased,
with two alleles or more). Note that the required conditions are not
checked by the present function: see the functions below.
</p>
<p>The pairwise deletion is done with respect to missing values coded as
<code><a href="base.html#topic+NA">NA</a></code>, not on the &lsquo;null alleles&rsquo; (&lsquo;0&rsquo; or &lsquo;.&rsquo;). You
may need to use the function <code><a href="#topic+nullAlleles2NA">nullAlleles2NA</a></code> first if
your data has genotypes with null alleles that you want to treat as
missing values.
</p>


<h3>Value</h3>

<p>an object of class <code>"dist"</code>.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Gao, X. and Martin, E. R. (2009) Using allele sharing distance for
detecting human population stratification. <em>Human Hederity</em>,
<b>68</b>, 182&ndash;191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.snp">is.snp</a></code>, <code><a href="#topic+is.phased">is.phased</a></code>, <code><a href="#topic+getPloidy">getPloidy</a></code>,
<code><a href="#topic+nullAlleles2NA">nullAlleles2NA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
## ASD for micro-satellites:
d &lt;- dist.asd(jaguar)
co &lt;- rainbow(nlevels(jaguar$pop))
plot(nj(d), "u", tip.color = co[jaguar$pop], font = 2, lab4 = "a")
legend("topleft", legend = levels(jaguar$pop), text.col = co, text.font = 2)
</code></pre>

<hr>
<h2 id='dist.hamming'>Hamming Distance</h2><span id='topic+dist.hamming'></span>

<h3>Description</h3>

<p>This function implements a general purpose Hamming distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.hamming(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.hamming_+3A_x">x</code></td>
<td>
<p>a matrix or a data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should work for a wide range of data types. A typical
usage would be with an object of class <code>c("haplotype",
    "character")</code>.
</p>
<p>For objects of class <code>c("haplotype", "DNAbin")</code>, it is better to
use <code>dist.dna(x, "n")</code> to compute the Hamming distances.
</p>


<h3>Value</h3>

<p>an object of class <code>"dist"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplotype">haplotype</a></code>, <code><a href="#topic+dist.haplotype.loci">dist.haplotype.loci</a></code>
</p>

<hr>
<h2 id='edit.loci'>Edit Allelic Data with R's Data Editor</h2><span id='topic+edit.loci'></span>

<h3>Description</h3>

<p>This allows to edit a data frame of class <code>"loci"</code> with R's
spreadsheet-like data editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
edit(name, edit.row.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edit.loci_+3A_name">name</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="edit.loci_+3A_edit.row.names">edit.row.names</code></td>
<td>
<p>a logical specifying to allow editing the
rownames, <code>TRUE</code> by default (by contrast to data frames).</p>
</td></tr>
<tr><td><code id="edit.loci_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This &lsquo;method&rsquo; of the generic <code>edit</code> respects the class and the
attribute <code>"locicol"</code> of the allelic data frame.
</p>


<h3>Value</h3>

<p>A data frame with class <code>c("loci", "data.frame")</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="#topic+summary.loci">summary.loci</a></code>
</p>

<hr>
<h2 id='F4'>F-Statistics From Patterson et al</h2><span id='topic+F2'></span><span id='topic+F3'></span><span id='topic+F4'></span>

<h3>Description</h3>

<p>These functions compute the <em>F</em>-statistics developed by Patterson
et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F2(x, allele.freq = NULL, population = NULL, check.data = TRUE,
   pops = NULL, jackknife.block.size = 10, B = 1e4)
F3(x, allele.freq = NULL, population = NULL, check.data = TRUE,
   pops = NULL, jackknife.block.size = 10, B = 1e4)
F4(x, allele.freq = NULL, population = NULL, check.data = TRUE,
   pops = NULL, jackknife.block.size = 10, B = 1e4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F4_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="F4_+3A_allele.freq">allele.freq</code></td>
<td>
<p>alternatively, a list of allele (absolute)
frequencies as output by <code><a href="#topic+by.loci">by.loci</a></code> (if this is used,
<code>x</code> is ignored).</p>
</td></tr>
<tr><td><code id="F4_+3A_population">population</code></td>
<td>
<p>a column name or number giving which column of
<code>x</code> should be treated as the population variable. By default,
the column named &ldquo;population&rdquo; is used.</p>
</td></tr>
<tr><td><code id="F4_+3A_check.data">check.data</code></td>
<td>
<p>if <code>FALSE</code>, it is assumed that the user checked
that all loci are strict SNPs. By default, the data are checked for
the number of alleles and the non-SNP loci are dropped with a
warning.</p>
</td></tr>
<tr><td><code id="F4_+3A_pops">pops</code></td>
<td>
<p>a vector giving two, three, or four population names
depending on the function. The order of these names is important
(see Patterson et al. 2012). By default, the populations in
<code>x</code> are taken in the order they appear, and an error is
returned if the number of populations does not match the number
required by the function.</p>
</td></tr>
<tr><td><code id="F4_+3A_jackknife.block.size">jackknife.block.size</code></td>
<td>
<p>the size of the block used in the
jackknife to assess the significance of the <em>F</em>-statistic (this
should be around one thousandth of the number of loci, or not less
than 10.</p>
</td></tr>
<tr><td><code id="F4_+3A_b">B</code></td>
<td>
<p>the number of replications of the bootstrap used to assess
the significance of the <em>F</em>-statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are provisional versions.
</p>
<p>It is much better to compute the allele frequencies, and then use
<code>allele.freq</code> with different combinations of <code>pops</code>.
</p>


<h3>Value</h3>

<p>A vector with names.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Patterson, N., Moorjani, P., Luo, Y., Mallick, S., Rohland, N., Zhan,
Y., Genschoreck, T., Webster, T. and Reich, D. (2012) Ancient
admixture in human history. <em>Genetics</em>, <b>192</b>, 1065&ndash;1093.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by.loci">by.loci</a></code>, <code><a href="#topic+Fst">Fst</a></code>, the package
<span class="pkg">admixturegraph</span> that can draw graphs from the output of this
function.
</p>

<hr>
<h2 id='Fst'>F-Statistics</h2><span id='topic+Fst'></span><span id='topic+Rst'></span>

<h3>Description</h3>

<p><code>Fst</code> computes the <code class="reqn">F_{IT}</code>, <code class="reqn">F_{ST}</code> and
<code class="reqn">F_{IS}</code> for each locus in the data. <code>Rst</code> computes the
<code class="reqn">R_{ST}</code> for microsatellites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fst(x, pop = NULL, quiet = TRUE, na.alleles = "")
Rst(x, pop = NULL, quiet = TRUE, na.alleles = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fst_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="Fst_+3A_pop">pop</code></td>
<td>
<p>a vector or factor giving the population assignment of each
row of <code>x</code>, or a single numeric value specifying which column
of <code>x</code> to use as population indicator. By default, the column
labelled <code>"population"</code> is used.</p>
</td></tr>
<tr><td><code id="Fst_+3A_quiet">quiet</code></td>
<td>
<p>a logical value: should calculations be quiet?</p>
</td></tr>
<tr><td><code id="Fst_+3A_na.alleles">na.alleles</code></td>
<td>
<p>by default, only genotypes coded as
<a href="base.html#topic+NA">NA</a> are considered as missing data. This option
is to specify if some alleles code for missing data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Fst</code> uses the formulae in Weir and Cockerham (1984) for each
allele, and then averaged within each locus over the different alleles
as suggested by these authors.
</p>
<p><code>Rst</code> uses the formulae in Slatkin (1995).
</p>


<h3>Value</h3>

<p>A matrix with genes (loci) as rows and the three <em>F</em>-statistics
as columns.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Slatkin, M. (1995) A measure of population subdivision based on
microsatellite allele frequencies.  <em>Genetics</em>, <b>139</b>,
457&ndash;462.
</p>
<p>Weir, B. S. and Cockerham, C. C. (1984) Estimating <em>F</em>-statistics
for the analysis of population structure. <em>Evolution</em>, <b>38</b>,
1358&ndash;1370.
</p>
<p>Weir, B. S. and Hill, W. G. (2002) Estimating <em>F</em>-statistics.
<em>Annual Review of Genetics</em>, <b>36</b>, 721&ndash;750.
</p>


<h3>See Also</h3>

<p><code>fstat</code> in package <span class="pkg">hierfstat</span>; package <span class="pkg">dirmult</span>
on CRAN that implements various estimators of the
Dirichlet-multinomial distribution, including maximum likekihood and
the moments estimator of Weir and Hill (2002); <code>Fst</code> in
<span class="pkg">Biodem</span> that caculates <code class="reqn">F_{ST}</code> from a &ldquo;kinship
matrix&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
Fst(jaguar)
Rst(jaguar)

## no Fst but Fit and Fis in case of single population:
jaguar_corridor &lt;- jaguar[jaguar$population == "Green Corridor", ]
Fst(jaguar_corridor) 
</code></pre>

<hr>
<h2 id='geod'>Geodesic Distances</h2><span id='topic+geod'></span>

<h3>Description</h3>

<p>This function calculates geodesic (or great-circle) distances
between pairs of points with their longitudes and latitudes given in
(decimal) degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod(lon, lat = NULL, R = 6371)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod_+3A_lon">lon</code></td>
<td>
<p>either a vector of numeric values with the longitudes in
degrees, or, if <code>lat = NULL</code>, a matrix giving the longitudes
(first column) and the latitudes (second column).</p>
</td></tr>
<tr><td><code id="geod_+3A_lat">lat</code></td>
<td>
<p>a vector with the latitudes.</p>
</td></tr>
<tr><td><code id="geod_+3A_r">R</code></td>
<td>
<p>the mean radius of the Earth (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>R</code> is the mean radius of the Earth which is
slightly smaller than the radius at the equator (6378.1 km).
</p>


<h3>Value</h3>

<p>a numeric symmetric matrix with the distances between pairs of points
in kilometres.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Great-circle_distance">https://en.wikipedia.org/wiki/Great-circle_distance</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Earth">https://en.wikipedia.org/wiki/Earth</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoTrans">geoTrans</a></code>, <code><a href="stats.html#topic+as.dist">as.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## the distance between 0N 0E and 0N 180E...
geod(c(0, 180), c(0, 0)) # ~ 20015.09 km
## ... the same using the radius of the Earth at the equator:
geod(c(0, 180), c(0, 0), 6378.1) # ~ 20037.39 km
## The same comparison for two points 5 degrees apart:
geod(c(0, 5), c(0, 0)) # ~ 555.9746 km
geod(c(0, 5), c(0, 0), 6378.1) # ~ 556.5942 km
</code></pre>

<hr>
<h2 id='geoTrans'>Manipulate Geographical Coordinates</h2><span id='topic+geoTrans'></span><span id='topic+geoTrans2'></span>

<h3>Description</h3>

<p><code>geoTrans</code> transforms geographical coordinates in degrees,
minutes and seconds input as characters (or a factor) into numerical
values in degrees. <code>geoTrans2</code> does the reverse operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoTrans(x, degsym = NULL, minsym = "'", secsym = "\"")
geoTrans2(lon, lat = NULL, degsym = NULL, minsym = "'",
          secsym = "\"", dropzero = FALSE, digits = 3,
          latex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geoTrans_+3A_x">x</code></td>
<td>
<p>a vector of character strings storing geographical
coordinates; this can be a factor with the levels correctly set.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_degsym">degsym</code>, <code id="geoTrans_+3A_minsym">minsym</code>, <code id="geoTrans_+3A_secsym">secsym</code></td>
<td>
<p>a single character giving the symbol
used for degrees, minutes and seconds, respectively.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_lon">lon</code></td>
<td>
<p>either a vector of numeric values with the longitudes in
degrees, or, if <code>lat = NULL</code>, a matrix (or a data frame) giving
the longitudes in the first column and the latitudes in the second
column.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_lat">lat</code></td>
<td>
<p>a vector with the latitudes.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_dropzero">dropzero</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, the number of
arc-seconds is dropped if it is zero; similarly for the number of
arc-minutes if the number of arc-seconds is also zero.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_digits">digits</code></td>
<td>
<p>an integer used for rounding the number of arc-seconds.</p>
</td></tr>
<tr><td><code id="geoTrans_+3A_latex">latex</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, the returned character
is formatted with LaTeX code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geoTrans</code> should be robust to any pattern of spacing around the
values and the symbols (see examples). If the letter S, W, or O is
found is the coordinate, the returned value is negative. Note that
longitude and latitude should not be mixed in the same character
strings.
</p>
<p><code>geoTrans2</code> can be used with <code><a href="base.html#topic+cat">cat</a></code> (see
examples).
</p>
<p>The default for <code>degsym</code> (<code>NULL</code>) is because the degree
symbol (°) is coded differently in different character encodings.
By default, the function will use the appropriate character depending
on the system and encoding used.
</p>


<h3>Value</h3>

<p><code>geoTrans</code> returns a numeric vector with the coordinates in
degrees (eventually as decimal values). <code>geoTrans2</code> returns a
character vector.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+geod">geod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- c("N 43°27'30\"", "N43°27'30\"", "43°27'30\"N",
           "43° 27' 30\" N", "43 ° 27 ' 30 \" N",
           "43°27'30\"", "43°27.5'")
cat(coord, sep = "\n")
geoTrans(coord)
geoTrans("43 D 27.5'", degsym = "D")
geoTrans("43° 27' 30\" S")

XL &lt;- c(100.6417, 102.9500)
YL &lt;- c(11.55833, 14.51667)
cat(geoTrans2(XL, YL, dropzero = TRUE), sep = "\n")
cat(geoTrans2(XL, YL, latex = TRUE), sep = "\\\n")
</code></pre>

<hr>
<h2 id='getHaploNetOptions'>Options to Plot haploNet Objects</h2><span id='topic+getHaploNetOptions'></span><span id='topic+setHaploNetOptions'></span>

<h3>Description</h3>

<p>These functions change the graphical options to plot haplotype networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHaploNetOptions()
setHaploNetOptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHaploNetOptions_+3A_...">...</code></td>
<td>
<p>option(s) and value(s) to be changed (separated by commas
if several).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options are listed below with their default values. Most of these
values use the standard <span class="rlang"><b>R</b></span> graphical paramters (see
<code><a href="graphics.html#topic+par">par</a></code>).
</p>

<ul>
<li><p> bg = &quot;transparent&quot;: the background colour of the plot.
</p>
</li>
<li><p> labels = TRUE: whether to show the haplotype labels.
</p>
</li>
<li><p> labels.cex = 1: size of the haplotype labels.
</p>
</li>
<li><p> labels.font = 2: font of the haplotype labels.
</p>
</li>
<li><p> labels.color = &quot;black&quot;: colour of the haplotype labels.
</p>
</li>
<li><p> link.color = &quot;black&quot;: colour of the links.
</p>
</li>
<li><p> link.type = 1: type of line for the links.
</p>
</li>
<li><p> link.type.alt = 2: type of lines for the alternative links.
</p>
</li>
<li><p> link.width = 1: line width for the links.
</p>
</li>
<li><p> link.width.alt = 1: line width for the alternative links.
</p>
</li>
<li><p> haplotype.inner.color = &quot;white&quot;: colour used inside the
haplotype symbols.
</p>
</li>
<li><p> haplotype.outer.color = &quot;black&quot;: colour used for the border of
the haplotype symbols.
</p>
</li>
<li><p> mutations.cex = 1: size of the mutation annotations.
</p>
</li>
<li><p> mutations.font = 1: font of the mutation annotations.
</p>
</li>
<li><p> mutations.frame.background = &quot;#0000FF4D&quot;: background colour
(transparent blue).
</p>
</li>
<li><p> mutations.frame.border = &quot;black&quot;: colour of the frame.
</p>
</li>
<li><p> mutations.text.color = 1: colour of the mutation annotations.
</p>
</li>
<li><p> mutations.arrow.color = &quot;black&quot;: colour of the arrow pointing to
the link.
</p>
</li>
<li><p> mutations.arrow.type = &quot;triangle&quot;: type of the previous arrow.
</p>
</li>
<li><p> mutations.sequence.color = &quot;#BFBFBF4D&quot;: colour of the sequence
(transparent grey).
</p>
</li>
<li><p> mutations.sequence.end = &quot;round&quot;: possible choices: <code>"round"</code>,
<code>"butt"</code>, or <code>"square"</code> (or alternatively 0, 1, or 2).
</p>
</li>
<li><p> mutations.sequence.length = 0.3: the length of the segment
showing the sequence as fraction of the graphical window.
</p>
</li>
<li><p> mutations.sequence.width = 5: thickness of this segment.
</p>
</li>
<li><p> pie.outer.color = &quot;black&quot;: colour of the circle around pie
charts.
</p>
</li>
<li><p> pie.inner.segments.color = &quot;black&quot;: colour of the segments
separating the shares of the pies.
</p>
</li>
<li><p> pie.colors.function = rainbow: function used to define colours
for the frequencies.
</p>
</li>
<li><p> scale.ratio = 1: the scale ratio between links and symbol
sizes.
</p>
</li>
<li><p> show.mutation = 1: option used to show mutation or not (0).
</p>
</li></ul>


<h3>Value</h3>

<p><code>getHaploNetOptions</code> returns a list of options. The other
function returns nothing.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.haploNet">plot.haploNet</a></code>, <code><a href="#topic+mutations">mutations</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getHaploNetOptions()
</code></pre>

<hr>
<h2 id='hap.div'>Haplotype Diversity</h2><span id='topic+hap.div'></span><span id='topic+hap.div.haplotype'></span><span id='topic+hap.div.DNAbin'></span>

<h3>Description</h3>

<p>This function computes haplotype diversity from DNA
sequences. This is a generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap.div(x, ...)
## S3 method for class 'haplotype'
hap.div(x, variance = FALSE, method = "Nei", ...)
## S3 method for class 'DNAbin'
hap.div(x, variance = FALSE, method = "Nei", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hap.div_+3A_x">x</code></td>
<td>
<p>an object with DNA data.</p>
</td></tr>
<tr><td><code id="hap.div_+3A_variance">variance</code></td>
<td>
<p>a logical value specifying whether to calculate the
variance of the estimated haplotype diversity.</p>
</td></tr>
<tr><td><code id="hap.div_+3A_method">method</code></td>
<td>
<p>(unused, see details).</p>
</td></tr>
<tr><td><code id="hap.div_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only Nei and Tajima's (1981) method is available.
</p>


<h3>Value</h3>

<p>a numeric vector with one or two values (if <code>variance = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Nei, M. and Tajima, F. (1981) DNA polymorphism detectable by
restriction endonuclease. <em>Genetics</em>, <b>97</b>, 145&ndash;163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nuc.div">nuc.div</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
hap.div(woodmouse) # all haplotypes are unique

## neuraminidase sequences from the 2009 H1N1 data (delivered with adegenet):
fl &lt;- system.file("files/pdH1N1-NA.fasta", package = "adegenet")
H1N1.NA &lt;- read.dna(fl, "fasta")
hap.div(H1N1.NA, TRUE)
</code></pre>

<hr>
<h2 id='haploFreq'>Haplotype Frequencies With a Covariate</h2><span id='topic+haploFreq'></span>

<h3>Description</h3>

<p>This utility function extracts the absolute frequencies of haplotypes
with respect to a categorical variable (a factor). The output is
useful when ploting haplotype networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploFreq(x, fac, split = "_", what = 2, haplo = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haploFreq_+3A_x">x</code></td>
<td>
<p>a set of DNA sequences (as an object of class
<code>"DNAbin"</code>).</p>
</td></tr>
<tr><td><code id="haploFreq_+3A_fac">fac</code></td>
<td>
<p>a factor giving the categorical variable (can be missing).</p>
</td></tr>
<tr><td><code id="haploFreq_+3A_split">split</code></td>
<td>
<p>a single character (see details).</p>
</td></tr>
<tr><td><code id="haploFreq_+3A_what">what</code></td>
<td>
<p>a single integer (see details).</p>
</td></tr>
<tr><td><code id="haploFreq_+3A_haplo">haplo</code></td>
<td>
<p>an object of class <code>"haplotype"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frequencies of each haplotype in <code>x</code> are counted with respect
to a factor which is either specified with <code>fac</code>, or extracted
from the labels of <code>x</code>. In the second case, these labels are
split with respect to the character specified in <code>split</code> and the
<code>what</code>'th substrings are extracted and taken as the categorical
variable (see example).
</p>
<p>If <code>haplo</code> is specified, the haplotype frequencies are taken from
it, otherwise they are calculated from <code>x</code>.
</p>


<h3>Value</h3>

<p>a matrix of counts.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep and Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplotype">haplotype</a></code>, <code><a href="#topic+haploNet">haploNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some artificial data from 'woodmouse':
data(woodmouse)
x &lt;- woodmouse[sample(15, size = 50, replace = TRUE), ]
## labels IdXXX_PopXXX_LocXXX
rownames(x) &lt;- paste("Id", 1:50, "_Pop", 1:2, "_Loc", 1:5, sep = "")
head(labels(x))
h &lt;- haplotype(x)
## frequencies of haplotypes wrt 'Pop':
f.pop &lt;- haploFreq(x, haplo = h)
## frequencies of haplotypes wrt 'Loc':
f.loc &lt;- haploFreq(x, what = 3, haplo = h)
nt &lt;- haploNet(h)
fq &lt;- attr(nt, "freq")
op &lt;- par(mfcol = c(1, 2))
plot(nt, size = fq, pie = f.pop, labels = FALSE)
plot(nt, size = fq, pie = f.loc, labels = FALSE)
par(op)
</code></pre>

<hr>
<h2 id='haploNet'>Haplotype Networks</h2><span id='topic+haploNet'></span><span id='topic+print.haploNet'></span><span id='topic+plot.haploNet'></span><span id='topic+as.network.haploNet'></span><span id='topic+as.igraph.haploNet'></span><span id='topic+as.phylo.haploNet'></span><span id='topic+as.evonet.haploNet'></span>

<h3>Description</h3>

<p><code>haploNet</code> computes a haplotype network. There is a plot method
and two conversion functions towards other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploNet(h, d = NULL, getProb = TRUE)
## S3 method for class 'haploNet'
print(x, ...)
## S3 method for class 'haploNet'
plot(x, size = 1, col, bg, col.link, lwd, lty,
     shape = "circles", pie = NULL, labels, font, cex, col.lab, scale.ratio,
     asp = 1, legend = FALSE, fast = FALSE, show.mutation,
     threshold = c(1, 2), xy = NULL, ...)
## S3 method for class 'haploNet'
as.network(x, directed = FALSE, altlinks = TRUE, ...)
## S3 method for class 'haploNet'
as.igraph(x, directed = FALSE, use.labels = TRUE,
        altlinks = TRUE, ...)
## S3 method for class 'haploNet'
as.phylo(x, quiet, ...)
## S3 method for class 'haploNet'
as.evonet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haploNet_+3A_h">h</code></td>
<td>
<p>an object of class <code>"haplotype"</code>.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_d">d</code></td>
<td>
<p>an object giving the distances among haplotypes (see
details).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_getprob">getProb</code></td>
<td>
<p>a logical specifying whether to calculate Templeton's
probabilities (see details).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_x">x</code></td>
<td>
<p>an object of class <code>"haploNet"</code>.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_size">size</code></td>
<td>
<p>a numeric vector giving the diameter of the circles
representing the haplotypes: this is in the same unit than the links
and eventually recycled.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_col">col</code></td>
<td>
<p>a character vector specifying the colours of the circles;
eventually recycled.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_bg">bg</code></td>
<td>
<p>a character vector (or a function) specifying either the
colours of the background of the symbols (if <code>pie = NULL</code>), or
the colours of the slices of the pies (could be a function);
eventually recycled.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_col.link">col.link</code></td>
<td>
<p>a character vector specifying the colours of the links;
eventually recycled.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_lwd">lwd</code></td>
<td>
<p>a numeric vector giving the width of the links; eventually
recycled.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_lty">lty</code></td>
<td>
<p>idem for the line types.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_shape">shape</code></td>
<td>
<p>the symbol shape used for the haplotypes (eventually
recycled): <code>"circles"</code>, <code>"squares"</code>, <code>"diamonds"</code>
(can be abbreviated).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_pie">pie</code></td>
<td>
<p>a matrix used to draw pie charts for each haplotype; its
number of rows must be equal to the number of haplotypes.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_labels">labels</code></td>
<td>
<p>a logical specifying whether to identify the haplotypes
with their labels (the default).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_font">font</code></td>
<td>
<p>the font used for these labels (bold by default); must be
an integer between 1 and 4.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_cex">cex</code></td>
<td>
<p>a numerical specifying the character expansion of the
labels.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_col.lab">col.lab</code></td>
<td>
<p>the color of the labels.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_scale.ratio">scale.ratio</code></td>
<td>
<p>the ratio of the scale of the links representing
the number of steps on the scale of the circles representing the
haplotypes. It may be needed to give a value greater than one to
avoid overlapping circles.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_asp">asp</code></td>
<td>
<p>the aspect ratio of the plot. Do not change the default
unless you want to distort your network.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_legend">legend</code></td>
<td>
<p>a logical specifying whether to draw the legend, or a
vector of length two giving the coordinates where to draw the
legend; <code>FALSE</code> by default. If <code>TRUE</code>, the user is asked
to click where to draw the legend.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_fast">fast</code></td>
<td>
<p>a logical specifying whether to optimize the spacing of
the circles; <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_show.mutation">show.mutation</code></td>
<td>
<p>an integer value: if 0, nothing is drawn on the
links; if 1, the mutations are shown with small segments on the
links; if 2, they are shown with small dots; if 3, the number of
mutations are printed on the links.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_threshold">threshold</code></td>
<td>
<p>a numeric vector with two values (or 0) giving the
lower and upper numbers of mutations for alternative links to be
displayed. If <code>threshold = 0</code>, alternative links are not drawn
at all.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_directed">directed</code></td>
<td>
<p>a logical specifying whether the network is directed
(<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_use.labels">use.labels</code></td>
<td>
<p>a logical specifying whether to use the original
labels in the returned network.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_altlinks">altlinks</code></td>
<td>
<p>whether to output the alternative links when
converting to another class; <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_quiet">quiet</code></td>
<td>
<p>whether to give a warning when reticulations are dropped
when converting a network into a tree.</p>
</td></tr>
<tr><td><code id="haploNet_+3A_xy">xy</code></td>
<td>
<p>the coordinates of the nodes (see <code><a href="#topic+replot">replot</a></code>).</p>
</td></tr>
<tr><td><code id="haploNet_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the haplotype network is built using an infinite site
model (i.e., uncorrected or Hamming distance) of DNA sequences and
pairwise deletion of missing data (see <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).
Users may specify their own distance with the argument <code>d</code>. There
is no check of labels, so the user must make sure that the distances
are ordered in the same way than the haplotypes.
</p>
<p>The probabilities calculated with Templeton et al.'s (1992) method may
give non-finite values with very divergent sequences, resulting in an
error from <code>haploNet</code>. If this happens, it may be better to use
<code>getProb = FALSE</code>.
</p>
<p>If two haplotypes are very different, <code>haploNet</code> will likely fail
(error during integration due to non-finite values).
</p>


<h3>Value</h3>

<p><code>haploNet</code> returns an object of class <code>"haploNet"</code> which is
a matrix where each row represents a link in the network, the first
and second columns give the numbers of the linked haplotypes, the
third column, named <code>"step"</code>, gives the number of steps in this
link, and the fourth column, named <code>"Prob"</code>, gives the
probability of a parsimonious link as given by Templeton et
al. (1992). There are three additional attributes: <code>"freq"</code>, the
absolute frequencies of each haplotype, <code>"labels"</code>, their labels,
and <code>"alter.links"</code>, the alternative links of the network.
</p>
<p><code>as.network</code> and <code>as.igraph</code> return objects of the
appropriate class.
</p>


<h3>Note</h3>

<p>Plotting haplotype networks is a difficult task. There is a vignette
in <span class="pkg">pegas</span> (see <code>vignette("PlotHaploNet")</code>) giving some
information on this isseu. You may also see two posts on r-sig-genetics
(July 2022) that give some tricks in the situation when one haplotype
is abundant and the others are in low frequencies (the symbols are
likely to overlap a lot by default):
</p>
<p><a href="https://stat.ethz.ch/pipermail/r-sig-genetics/2022-July/000237.html">https://stat.ethz.ch/pipermail/r-sig-genetics/2022-July/000237.html</a>
</p>
<p><a href="https://stat.ethz.ch/pipermail/r-sig-genetics/2022-July/000238.html">https://stat.ethz.ch/pipermail/r-sig-genetics/2022-July/000238.html</a>
</p>
<p>The first post explains how to use the package <span class="pkg">network</span> in
combination with <span class="pkg">pegas</span>, and the second one gives a trick that
works with <span class="pkg">pegas</span> only for a similar result.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Klaus Schliep</p>


<h3>References</h3>

<p>Templeton, A. R., Crandall, K. A. and Sing, C. F. (1992) A cladistic
analysis of phenotypic association with haplotypes inferred from
restriction endonuclease mapping and DNA sequence data. III. Cladogram
estimation. <em>Genetics</em>, <b>132</b>, 619&ndash;635.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplotype">haplotype</a></code>, <code><a href="#topic+haploFreq">haploFreq</a></code>, <code><a href="#topic+replot">replot</a></code>,
<code><a href="#topic+diffHaplo">diffHaplo</a></code>, <code><a href="#topic+mst">mst</a></code>, <code><a href="#topic+mjn">mjn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some artificial data from 'woodmouse':
data(woodmouse)
x &lt;- woodmouse[sample(15, size = 110, replace = TRUE), ]
h &lt;- haplotype(x)
(net &lt;- haploNet(h))
plot(net)
## symbol sizes equal to haplotype sizes:
plot(net, size = attr(net, "freq"), fast = TRUE)
plot(net, size = attr(net, "freq"))
plot(net, size = attr(net, "freq"), scale.ratio = 2, cex = 0.8)
</code></pre>

<hr>
<h2 id='haplotype'>Haplotype Extraction and Frequencies</h2><span id='topic+haplotype'></span><span id='topic+haplotype.DNAbin'></span><span id='topic+haplotype.character'></span><span id='topic+haplotype.numeric'></span><span id='topic+plot.haplotype'></span><span id='topic+print.haplotype'></span><span id='topic+summary.haplotype'></span><span id='topic+sort.haplotype'></span><span id='topic++5B.haplotype'></span>

<h3>Description</h3>

<p><code>haplotype</code> extracts the haplotypes from a set of DNA
sequences. The result can be plotted with the appropriate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplotype(x, ...)
## S3 method for class 'DNAbin'
haplotype(x, labels = NULL, strict = FALSE,
                  trailingGapsAsN = TRUE, ...)
## S3 method for class 'character'
haplotype(x, labels = NULL, ...)
## S3 method for class 'numeric'
haplotype(x, labels = NULL, ...)
## S3 method for class 'haplotype'
plot(x, xlab = "Haplotype", ylab = "Number", ...)
## S3 method for class 'haplotype'
print(x, ...)
## S3 method for class 'haplotype'
summary(object, ...)
## S3 method for class 'haplotype'
sort(x,
     decreasing = ifelse(what == "frequencies", TRUE, FALSE),
     what = "frequencies", ...)
## S3 method for class 'haplotype'
x[...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplotype_+3A_x">x</code></td>
<td>
<p>a set of DNA sequences (as an object of class
<code>"DNAbin"</code>), or an object of class <code>"haplotype"</code>.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_object">object</code></td>
<td>
<p>an object of class <code>"haplotype"</code>.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_labels">labels</code></td>
<td>
<p>a vector of character strings used as names for the rows
of the returned object. By default, Roman numerals are given.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_strict">strict</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, ambiguities and gaps in
the sequences are ignored and treated as separate characters.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_trailinggapsasn">trailingGapsAsN</code></td>
<td>
<p>a logical value; if <code>TRUE</code> (the default),
the leading and trailing alignment gaps are considered as unknown
bases (i.e., N). This option has no effect if <code>strict = TRUE</code>.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_xlab">xlab</code>, <code id="haplotype_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x- and x-axes.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_...">...</code></td>
<td>
<p>further arguments passed to
<code><a href="graphics.html#topic+barplot">barplot</a></code> (unused in <code>print</code> and
<code>sort</code>).</p>
</td></tr>
<tr><td><code id="haplotype_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical value specifying in which order to sort
the haplotypes; by default this depends on the value of
<code>what</code>.</p>
</td></tr>
<tr><td><code id="haplotype_+3A_what">what</code></td>
<td>
<p>a character specifying on what feature the haplotypes
should be sorted: this must be <code>"frequencies"</code> or
<code>"labels"</code>, or an unambiguous abbreviation of these.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The way ambiguities in the sequences are taken into account is explained
in a post to r-sig-phylo (see the examples below):
</p>
<p><a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg05541.html">https://www.mail-archive.com/r-sig-phylo@r-project.org/msg05541.html</a>
</p>
<p>The <code>sort</code> method sorts the haplotypes in decreasing frequencies
(the default) or in alphabetical order of their labels (if <code>what =
"labels"</code>). Note that if these labels are Roman numerals (as assigned by
<code>haplotype</code>), their alphabetical order may not be their numerical
one (e.g., IX is alphabetically before VIII).
</p>
<p>From <span class="pkg">pegas</span> 0.7, <code>haplotype</code> extracts haplotypes taking into
account base ambiguities (see Note below).
</p>


<h3>Value</h3>

<p><code>haplotype</code> returns an object of class <code>c("haplotype",
    "DNAbin")</code> which is an object of class <code>"DNAbin"</code> with two
additional attributes: <code>"index"</code> identifying the index of each
observation that share the same haplotype, and <code>"from"</code> giving
the name of the original data.
</p>
<p><code>sort</code> returns an object of the same class respecting its
attributes.
</p>


<h3>Note</h3>

<p>The presence of ambiguous bases and/or alignment gaps in DNA sequences
can make the interpretation of haplotypes difficult. It is recommended
to check their distributions with <code><a href="ape.html#topic+image.DNAbin">image.DNAbin</a></code> and
<code><a href="ape.html#topic+base.freq">base.freq</a></code> (using the options in both functions).
</p>
<p>Comparing the results obtained playing with the options <code>strict</code>
and <code>trailingGapsAsN</code> of <code>haplotype.DNAbin</code> may be useful.
Note that the <span class="pkg">ape</span> function <code><a href="ape.html#topic+seg.sites">seg.sites</a></code> has the
same two options (as from <span class="pkg">ape</span> 5.4) which may be useful to find the
relevant sites in the sequence alignment.
</p>


<h3>Note</h3>

<p>There are cases where the algorithm that pools the different sequences
into haplotypes has difficulties, although it seems to require a
specific configuration of missing/ambiguous data. The last example
below is one of them.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>,  <code><a href="#topic+haploFreq">haploFreq</a></code>,
<code><a href="#topic+subset.haplotype">subset.haplotype</a></code>,
<code><a href="ape.html#topic+DNAbin">DNAbin</a></code> for manipulation of DNA sequences in R.
</p>
<p>The <code>haplotype</code> method for objects of class <code>"loci"</code> is
documented separately: <code><a href="#topic+haplotype.loci">haplotype.loci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some artificial data from 'woodmouse':
data(woodmouse)
x &lt;- woodmouse[sample(15, size = 110, replace = TRUE), ]
(h &lt;- haplotype(x))
## the indices of the individuals belonging to the 1st haplotype:
attr(h, "index")[[1]]
plot(sort(h))
## get the frequencies in a named vector:
setNames(lengths(attr(h, "index")), labels(h))

## data posted by Hirra Farooq on r-sig-phylo (see link above):
cat("&gt;[A]\nCCCGATTTTATATCAACATTTATTT------",
    "&gt;[D]\nCCCGATTTT----------------------",
    "&gt;[B]\nCCCGATTTTATATCAACATTTATTT------",
    "&gt;[C]\nCCCGATTTTATATCACCATTTATTTTGATTT",
    file = "x.fas", sep = "\n")
x &lt;- read.dna("x.fas", "f")
unlink("x.fas")

## show the sequences and the distances:
alview(x)
dist.dna(x, "N", p = TRUE)

## by default there are 3 haplotypes with a warning about ambiguity:
haplotype(x)

## the same 3 haplotypes without warning:
haplotype(x, strict = TRUE)

## if we remove the last sequence there is, by default, a single haplotype:
haplotype(x[-4, ])

## to get two haplotypes separately as with the complete data:
haplotype(x[-4, ], strict = TRUE)

## a simpler example:
y &lt;- as.DNAbin(matrix(c("A", "A", "A", "A", "R", "-"), 3))
haplotype(y) # 1 haplotype
haplotype(y, strict = TRUE) # 3 haplotypes
haplotype(y, trailingGapsAsN = FALSE) # 2 haplotypes

## a tricky example with 4 sequences and 1 site:
z &lt;- as.DNAbin(matrix(c("Y", "A", "R", "N"), 4))
alview(z, showpos = FALSE)

## a single haplotype is identified:
haplotype(z)
## 'Y' has zero-distance with (and only with) 'N', so they are pooled
## together; at a later iteration of this pooling step, 'N' has
## zero-distance with 'R' (and ultimately with 'A') so they are pooled

## if the sequences are ordered differently, 'Y' and 'A' are separated:
haplotype(z[c(4, 1:3), ])
</code></pre>

<hr>
<h2 id='haplotype.loci'>Haplotype Extraction and Frequencies From Allelic Data</h2><span id='topic+haplotype.loci'></span><span id='topic+plot.haplotype.loci'></span><span id='topic+dist.haplotype.loci'></span>

<h3>Description</h3>

<p>This function extracts haplotypes from phased genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
haplotype(x, locus = 1:2, quiet = FALSE, compress = TRUE,
           check.phase = TRUE, ...)
## S3 method for class 'haplotype.loci'
plot(x, ...)
dist.haplotype.loci(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplotype.loci_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code> or of class
<code>"haplotype.loci"</code>.</p>
</td></tr>
<tr><td><code id="haplotype.loci_+3A_locus">locus</code></td>
<td>
<p>a vector of integers giving the loci to analyse.</p>
</td></tr>
<tr><td><code id="haplotype.loci_+3A_quiet">quiet</code></td>
<td>
<p>a logical value specifying whether to not print the
progress of the analysis (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="haplotype.loci_+3A_compress">compress</code></td>
<td>
<p>by default only the unique haplotypes are returned
with their frequencies. If <code>compress = FALSE</code>, a matrix with
all observed haplotypes is returned (with the number of columns
equals to the number of individuals times the ploidy level).</p>
</td></tr>
<tr><td><code id="haplotype.loci_+3A_check.phase">check.phase</code></td>
<td>
<p>a logical value specifying whether to check if the
individual genotypes are phased.</p>
</td></tr>
<tr><td><code id="haplotype.loci_+3A_...">...</code></td>
<td>
<p>arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individuals with at least one unphased genotype are ignored with a
warning.
</p>
<p><code>dist.haplotype.loci</code> computes pairwise distances among
haplotypes by counting the number of different alleles.
</p>
<p>Checking whether the genotypes are phased can be time consuming with
very big data sets. It may be useful to set <code>check.phase = FALSE</code>
if several analyses are done on the same data and no warning was
issued after the first scan, or you are sure that the genotypes are phased.
</p>


<h3>Value</h3>

<p><code>haplotype</code> returns a matrix of mode character with the loci as
rows and the haplotypes as columns. The attribute <code>"freq"</code> gives
the counts of each haplotype and the class is <code>"haplotype.loci"</code>.
</p>
<p><code>dist.haplotype.loci</code> returns an object of class <code>"dist"</code>.
</p>


<h3>Note</h3>

<p><code>haplotype</code> is a generic function with methods for objects of
class <code>"DNAbin"</code> and of class <code>"loci"</code>. Note that the class
returned by these methods is different: <code>c("haplotype", "DNAbin")</code>
and <code>"haplotype.loci"</code>, respectively. This and other details are
likely to change in the future.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

 <p><code><a href="#topic+haplotype">haplotype</a></code>, <code><a href="#topic+LD">LD</a></code></p>

<hr>
<h2 id='heterozygosity'>Heterozygosity at a Locus Using Gene Frequencies</h2><span id='topic+heterozygosity'></span><span id='topic+H'></span><span id='topic+H.loci'></span><span id='topic+H.default'></span>

<h3>Description</h3>

<p>Thes functions compute the mean heterozygosity(ies) from gene
frequencies, and return optionally the associated variance(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(x, ...)
## S3 method for class 'loci'
H(x, variance = FALSE, observed = FALSE, ...)
## Default S3 method:
H(x, variance = FALSE, ...)

heterozygosity(x, variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heterozygosity_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>, or vector or a factor.</p>
</td></tr>
<tr><td><code id="heterozygosity_+3A_variance">variance</code></td>
<td>
<p>a logical indicating whether the variance of the
estimated heterozygosity should be returned (<code>TRUE</code>), the
default being <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="heterozygosity_+3A_observed">observed</code></td>
<td>
<p>a logical specifying whether to calculate the observed
heterozygosity.</p>
</td></tr>
<tr><td><code id="heterozygosity_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> can be either a factor or a vector. If it is a
factor, then it is taken to give the individual alleles in the
population. If it is a numeric vector, then its values are taken to be
the numbers of each allele in the population. If it is a non-numeric
vector, it is a coerced as a factor.
</p>
<p>The mean heterozygosity is estimated with:
</p>
<p style="text-align: center;"><code class="reqn">\hat{H} = \frac{n}{n-1} \left(1 - \sum_{i=1}^k p_i^2 \right)</code>
</p>

<p>where <code class="reqn">n</code> is the number of genes in the sample, <code class="reqn">k</code> is the
number of alleles, and <code class="reqn">p_i</code> is the observed (relative) frequency
of the <code class="reqn">i</code>th allele.
</p>


<h3>Value</h3>

<p>For the default method: a numeric vector of length one with the
estimated mean heterozygosity (the default), or of length two if the
variance is returned.
</p>
<p>For the <code>"loci"</code> method: a numeric matrix with one, two, or three
columns with a row for each locus and the values of heterozygosity as
columns.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Nei, M. (1987) <em>Molecular evolutionary genetics</em>. New York:
Columbia University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.s">theta.s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
H(jaguar, TRUE, TRUE)
## use the (old) default method:
## convert the data and compute frequencies:
S &lt;- summary(jaguar)
## compute H for all loci:
sapply(S, function(x) H(x$allele))
## ... and its variance
sapply(S, function(x) H(x$allele, variance = TRUE))
</code></pre>

<hr>
<h2 id='hw.test'>Test of Hardy&ndash;Weinberg Equilibrium</h2><span id='topic+hw.test'></span><span id='topic+hw.test.loci'></span><span id='topic+hw.test.genind'></span>

<h3>Description</h3>

<p>This function tests, for a series of loci, the hypothesis that
genotype frequencies follow the Hardy&ndash;Weinberg equilibrium.
<code>hw.test</code> is a generic with methods for the classes
<code>"<a href="#topic+loci">loci</a>"</code> and <code>genind</code>. Note that the latter
replaces <code>HWE.test.genind</code> in the <span class="pkg">adegenet</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hw.test(x, B = 1000, ...)
## S3 method for class 'loci'
hw.test(x, B = 1000, ...)
## S3 method for class 'genind'
hw.test(x, B = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hw.test_+3A_x">x</code></td>
<td>
<p>an object of class <code>"<a href="#topic+loci">loci</a>"</code> or <code>genind</code>.</p>
</td></tr>
<tr><td><code id="hw.test_+3A_b">B</code></td>
<td>
<p>the number of replicates for the Monte Carlo procedure; for
the regular HW test, set B = 0 (see details).</p>
</td></tr>
<tr><td><code id="hw.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test can be performed with any level of ploidy. Two versions
of the test are available: the classical <code class="reqn">\chi^2</code>-test based
on the expected genotype frequencies calculated from the allelic
frequencies, and an exact test based on Monte Carlo permutations of
alleles (Guo and Thompson 1992). For the moment, the latter version is
available only for diploids. Set <code>B = 0</code> if you want to skip the
second test.
</p>


<h3>Value</h3>

<p>A matrix with three or four columns with the <code class="reqn">\chi^2</code>-value,
the number of degrees of freedom, the associated <em>P</em>-value, and
possibly the <em>P</em>-value from the Monte Carlo test. The rows of
this matrix are the different loci in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Main code by Emmanuel Paradis; wrapper for <code>genind</code>
objects by Thibaut Jombart.
</p>


<h3>References</h3>

<p>Guo, S. W. and Thompson, E. A. (1992) Performing the exact test of
Hardy&ndash;Weinberg proportion for multiple alleles. <em>Biometrics</em>,
<b>48</b>, 361&ndash;372.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(adegenet)

## load data
data(nancycats)

## test on genind object, no permutation
hw.test(nancycats, B=0)

## test on loci object
x &lt;- as.loci(nancycats)
hw.test(x)

## End(Not run)
data(jaguar)
hw.test(jaguar)
</code></pre>

<hr>
<h2 id='jaguar'>Jaguar Micro-Satellites</h2><span id='topic+jaguar'></span>

<h3>Description</h3>

<p>Fifty nine jaguars (<em>Panthera onca</em>) from four populations
genotyped at thirteen micro-satellites by Haag et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jaguar)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"loci"</code> with 59 rows and 14 columns.
</p>


<h3>Source</h3>

<p>Haag, T., Santos, A. S., Sana, D. A., Morato, R. G., Cullen, Jr., L.,
Crawshaw, Jr., P. G., De Angelo, C., Di Bitetti, M. S., Salzano,
F. M. and Eizirik, E. (2010) The effect of habitat fragmentation on
the genetic structure of a top predator: loss of diversity and high
differentiation among remnant populations of Atlantic Forest jaguars
(<em>Panthera onca</em>). <em>Molecular Ecology</em>, <b>22</b>,
4906&ndash;4921.
</p>
<p>Haag, T., Santos, A. S., Sana, D. A., Morato, R. G., Cullen, Jr., L.,
Crawshaw, Jr., P. G., De Angelo, C., Di Bitetti, M. S., Salzano,
F. M. and Eizirik, E. (2010) Data from: The effect of habitat
fragmentation on the genetic structure of a top predator: loss of
diversity and high differentiation among remnant populations of
Atlantic Forest jaguars (Panthera onca). Dryad Digital
Repository. <a href="https://doi.org/10.5061/dryad.1884">doi:10.5061/dryad.1884</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loci">loci</a></code>, <code><a href="#topic+alleles2loci">alleles2loci</a></code>
</p>
<p>The vignette &ldquo;ReadingFiles&rdquo; explains how to read data like
these from Dryad (<a href="https://datadryad.org/stash">https://datadryad.org/stash</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
str(jaguar)
s &lt;- summary(jaguar)
## Not run: 
## works if the device is large enough:
plot(s, layout = 30, las = 2)

## End(Not run)</code></pre>

<hr>
<h2 id='LD'>Linkage Disequilibrium</h2><span id='topic+LD'></span><span id='topic+LD2'></span>

<h3>Description</h3>

<p>These two functions analyse linkage disequilibrium in the case of
phased (<code>LD</code>) or unphased (<code>LD2</code>) genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD(x, locus = c(1, 2), details = TRUE)
LD2(x, locus = c(1, 2), details = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LD_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="LD_+3A_locus">locus</code></td>
<td>
<p>a vector of two integers giving the loci to analyse.</p>
</td></tr>
<tr><td><code id="LD_+3A_details">details</code></td>
<td>
<p>a logical value indicating whether to print the
correlation matrix among alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions consider a pair of loci and compute the correlations
among pairs of alleles.
</p>
<p><code>LD</code> first scans the data for unphased genotypes: all individuals
with at least one unphased genotype are dropped with a warning. It is
based on the observed frequencies of haplotypes (Zaykin et
al. 2008). <code>LD2</code> is based on the observed frequencies of
different genotypes (Schaid 2004).
</p>
<p>Both functions accept any number of alleles. <code>LD</code> can work with
any level of ploidy; <code>LD2</code> works with diploid data.
</p>
<p>The present version does not test the significance of the <code class="reqn">T_2</code>
test (Zaykin et al. 2008) with permutations. These authors present
simulation results suggesting that the chi-squared approximation has
similar type I error rates and power than the test based on
permutations even for small sample sizes. Furthermore, this test has
better statistical properties than alternatives such as those reported
here (LRT and Pearson's test).
</p>


<h3>Value</h3>

<p>For both functions, if <code>details = FALSE</code>, only the T2 test is
returned.
</p>
<p>For <code>LD</code>: if <code>details = TRUE</code>, a named list with the
following elements:
</p>
<table role = "presentation">
<tr><td><code>Observed frequencies</code></td>
<td>
<p>the counts of haplotypes in the data.</p>
</td></tr>
<tr><td><code>Expected frequencies</code></td>
<td>
<p>the expected frequencies of haplotypes
computed from the observed proportions of alleles under the
assumption of no linkage disequilibrium.</p>
</td></tr>
<tr><td><code>Correlations among alleles</code></td>
<td>
<p>the observed correlations among
alleles from both loci.</p>
</td></tr>
<tr><td><code>LRT (G-squared)</code></td>
<td>
<p>the likelihood-ratio test of the null
hypothesis of no linkage disequilibrium.</p>
</td></tr>
<tr><td><code>Pearson's test (chi-squared)</code></td>
<td>
<p>the chi-squared test based on
haplotypes counts.</p>
</td></tr>
<tr><td><code>T2</code></td>
<td>
<p>the <code class="reqn">T_2</code> test with its number of degrees of freedom
(df).</p>
</td></tr>
</table>
<p>For <code>LD2</code>: if <code>details = TRUE</code>, a named list with two
elements:
</p>
<table role = "presentation">
<tr><td><code>Delta</code></td>
<td>
<p>the correlations among alleles (denoted <code class="reqn">Delta</code> in
Schaid 2004).</p>
</td></tr>
<tr><td><code>T2</code></td>
<td>
<p>the <code class="reqn">T_2</code> test with its number of degrees of freedom
(df).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Schaid, D. J. (2004) Linkage disequilibrium testing when linkage phase
is unknown. <em>Genetics</em>, <b>166</b>, 505&ndash;512.
</p>
<p>Zaykin, D. V., Pudovkin, A. and  Weir, B. S. (2008) Correlation-based
inference for linkage disequilibrium with multiple alleles.
<em>Genetics</em>, <b>180</b>, 533&ndash;545.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplotype.loci">haplotype.loci</a></code>, <code><a href="#topic+is.phased">is.phased</a></code>,
<code><a href="#topic+LDscan">LDscan</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
LD2(jaguar, details = FALSE)
LD2(jaguar, locus = 8:9, details = FALSE)
</code></pre>

<hr>
<h2 id='LDscan'>Multi-Locus Linkage Disequilibrium</h2><span id='topic+LDscan'></span><span id='topic+LDscan.DNAbin'></span><span id='topic+LDscan.loci'></span><span id='topic+LDmap'></span>

<h3>Description</h3>

<p><code>LDscan</code> computes a matrix of pairwise linkage disequilibrium (LD)
coefficients (<code class="reqn">|r|</code>) from a set of loci (which must be bi-allelic;
if not, the results are not guaranteed to be meaningful). The
genotypes must be phased.
</p>
<p><code>LDmap</code> plots a matrix of LD coefficients, optionally with the
positions of the loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDscan(x, ...)

## S3 method for class 'DNAbin'
LDscan(x, quiet = FALSE, what = c("r", "Dprime"), ...)
## S3 method for class 'loci'
LDscan(x, depth = NULL, quiet = FALSE,
        what = c("r", "Dprime"), ...)

LDmap(d, POS = NULL, breaks = NULL, col = NULL, border = NA,
      angle = 0, asp = 1, cex = 1, scale.legend = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LDscan_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code> with phased genotypes.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_depth">depth</code></td>
<td>
<p>a vector of integers giving the the depth(s) (or lags) at
which the <code class="reqn">r</code>'s are calculated. By default, all possible
depths are considered.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_quiet">quiet</code></td>
<td>
<p>a logical: should the progress of the operation be
printed?</p>
</td></tr>
<tr><td><code id="LDscan_+3A_what">what</code></td>
<td>
<p>the quantity to be computed. Two choices are possible:
<code>"r"</code> (the default) for the absolute value of the correlation
between alleles and <code>"Dprime"</code> for the (scaled) coefficients.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_d">d</code></td>
<td>
<p>a correlation matrix (can be an object of class <code>"dist"</code>).</p>
</td></tr>
<tr><td><code id="LDscan_+3A_pos">POS</code></td>
<td>
<p>an optional vector of locus positions (e.g., from a VCF
file; see examples).</p>
</td></tr>
<tr><td><code id="LDscan_+3A_breaks">breaks</code></td>
<td>
<p>a vector of break intervals to count the values in
<code>d</code>; by default, ten equally-sized intervals are used.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_col">col</code></td>
<td>
<p>an optional vector of colours; a scale from lightyellow to
red is used by default.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_border">border</code></td>
<td>
<p>the border of the rectangles: the default is to have no
border (this is not the same than default in
<code><a href="graphics.html#topic+rect">rect</a></code>; see examples).</p>
</td></tr>
<tr><td><code id="LDscan_+3A_angle">angle</code></td>
<td>
<p>value (in degrees) to rotate the graphic.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_asp">asp</code></td>
<td>
<p>the aspect ratio of the graphic; one by default so the
elements are squares (not rectangles).</p>
</td></tr>
<tr><td><code id="LDscan_+3A_cex">cex</code></td>
<td>
<p>the scaling of the labels and text.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_scale.legend">scale.legend</code></td>
<td>
<p>the scaling of the legend rectangles.</p>
</td></tr>
<tr><td><code id="LDscan_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods (<code>LDscan</code>) or to
<code>plot.default</code> (<code>LDmap</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LD coefficient <code class="reqn">r</code> is well defined when the two loci have
only two alleles. In other cases, LD is well defined (see
<code><a href="#topic+LD">LD</a></code>) but the definition of <code class="reqn">r</code> is not clear.
</p>
<p>All levels of ploidy are accepted, but all loci should have the same
ploidy level.
</p>
<p>If <code>depth</code> is used, the <code class="reqn">r</code>'s are calculated only for the
pairs of loci that are distant by these values in <code>x</code>, but
necessarily on the chromosome. The returned list has names set with
the values of <code>depth</code>.
</p>
<p>The value returned is actually <code class="reqn">|r|</code> (not <code class="reqn">r^2</code>).
</p>


<h3>Value</h3>

<p><code>LDscan</code> returns an object of class <code>"dist"</code> by default, or
a list if <code>depth</code> is used.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+LD">LD</a></code>, <code><a href="#topic+read.vcf">read.vcf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- LDscan(woodmouse)
LDmap(d, seg.sites(woodmouse), seq(0, 1, .1))

## Not run: 
## Download the VCF file from Dryad:
## https://doi.org/10.5061/dryad.446sv.2

## the VCF file should have this name:
fl &lt;- "global.pop.GATK.SNP.hard.filters.V3.phased_all.pop.maf.05.recode.vcf.gz"

info.fly &lt;- VCFloci(fl)

## LD map from the first 100 loci:
x &lt;- read.vcf(fl, to = 100) # read only 100 loci
res &lt;- LDscan(x)
bks &lt;- seq(0, 1, 0.2)
LDmap(res, info.fly$POS[1:100], bks, scale.legend = 3)

## check the chromosomes:
table(info.fly$CHROM)

## LD map from 100 loci randomly distributed on the chromosome:
s &lt;- ceiling(seq(1, 224253, length.out = 100))
xs &lt;- read.vcf(fl, which.loci = s)
res2 &lt;- LDscan(xs)
LDmap(res2, info.fly$POS[s], bks, scale.legend = 3)

## something simpler with 10 loci:
x10 &lt;- x[, 1:10]
## the VCF file has no locus IDs, so we give some here:
names(x10) &lt;- paste0("Loc", 1:10)
res10 &lt;- LDscan(x10, quiet = TRUE)
LDmap(res10, angle = 45, border = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='mjn'>Median-Joining Network</h2><span id='topic+mjn'></span><span id='topic+plot.mjn'></span>

<h3>Description</h3>

<p>This function computes the median-joining network (MJN) as described
by Bandelt et al. (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjn(x, epsilon = 0, max.n.cost = 10000, prefix = "median.vector_",
    quiet = FALSE)
## S3 method for class 'mjn'
plot(x, shape = c("circles", "diamonds"),
      bg = c("green", "slategrey"), labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjn_+3A_x">x</code></td>
<td>
<p>a matrix (or data frame) of DNA sequences or binary 0/1
data; an object of class <code>"mjn"</code> for <code>plot</code>.</p>
</td></tr>
<tr><td><code id="mjn_+3A_epsilon">epsilon</code></td>
<td>
<p>tolerance parameter.</p>
</td></tr>
<tr><td><code id="mjn_+3A_max.n.cost">max.n.cost</code></td>
<td>
<p>the maximum number of costs to be computed.</p>
</td></tr>
<tr><td><code id="mjn_+3A_prefix">prefix</code></td>
<td>
<p>the prefix used to label the median vectors.</p>
</td></tr>
<tr><td><code id="mjn_+3A_quiet">quiet</code></td>
<td>
<p>a logical value; by default, the progress of the
calculatins is printed.</p>
</td></tr>
<tr><td><code id="mjn_+3A_shape">shape</code>, <code id="mjn_+3A_bg">bg</code></td>
<td>
<p>the default shapes and colours for observed
haplotypes and median vectors.</p>
</td></tr>
<tr><td><code id="mjn_+3A_labels">labels</code></td>
<td>
<p>by default, the labels of the haplotypes are printed.</p>
</td></tr>
<tr><td><code id="mjn_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+plot.haploNet">plot.haploNet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MJN is a network method where unobserved sequences (the median
vectors) are reconstructed and included in the final network. Unlike
<code><a href="#topic+mst">mst</a></code>, <code>rmst</code>, and <code>msn</code>, <code>mjn</code> works with
the original sequences, the distances being calculated internally
using a Hamming distance method (with <code>dist(x, "manhattan")</code> for
binary data or <code>dist.dna(x, "N")</code> for DNA sequences).
</p>
<p>The parameter <code>epsilon</code> controls how the search for new median
vectors is performed: the larger this parameter, the wider the search
(see the example with binary data).
</p>
<p>If the sequences are very divergent, the search for new median vectors
can take a very long time. The argument <code>max.n.cost</code> controls how
many such vectors are added to the network (the default value should
avoid the function to run endlessly).
</p>
<p>The arguments <code>shape</code> and <code>bg</code> must be of length two (unlike
in <code><a href="#topic+plot.haploNet">plot.haploNet</a></code>). It is possible to have more
flexibility when plotting the MJN by changing its class, for instance
with the output in the examples below: <code>class(nt0) &lt;- "haplotNet"</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>c("mjn", "haploNet")</code> with an extra attribute
(data) containing the original data together with the median vectors.
</p>


<h3>Note</h3>

<p>Since <span class="pkg">pegas</span> 1.0, <code>mjn</code> is expected to run in reasonable
times (less than 15 sec with 100 sequences). Bandelt et al. (1999)
reported long computing times because of the need to compute a lot of
median vectors. Running times also depend on the level of polymorphism
in the data (see above).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Bandelt, H. J., Forster, P. and Rohl, A. (1999) Median-joining networks
for inferring intraspecific phylogenies. <em>Molecular Biology and
Evolution</em>, <b>16</b>, 37&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>, <code><a href="#topic+mst">mst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## data in Table 1 of Bandelt et al. (1999):
x &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0,
       1, 1, 1, 1, 0, 0, 0, 0, 0,
       1, 0, 0, 0, 1, 1, 1, 0, 0,
       0, 1, 1, 1, 1, 1, 0, 1, 1)
x &lt;- matrix(x, 4, 9, byrow = TRUE)
rownames(x) &lt;- LETTERS[1:4]
(nt0 &lt;- mjn(x))
(nt1 &lt;- mjn(x, 1))
(nt2 &lt;- mjn(x, 2))
plot(nt0)

## Not run: 
## same like in Fig. 4 of Bandelt et al. (1999):
plotNetMDS(nt2, dist(attr(nt2, "data"), "manhattan"), 3)

## End(Not run)

## data in Table 2 of Bandelt et al. (1999):
z &lt;- list(c("g", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a"),
          c("a", "g", "g", "a", "a", "a", "a", "a", "a", "a", "a", "a"),
          c("a", "a", "a", "g", "a", "a", "a", "a", "a", "a", "g", "g"),
          c("a", "a", "a", "a", "g", "g", "a", "a", "a", "a", "g", "g"),
          c("a", "a", "a", "a", "a", "a", "a", "a", "g", "g", "c", "c"),
          c("a", "a", "a", "a", "a", "a", "g", "g", "g", "g", "a", "a"))
names(z) &lt;- c("A1", "A2", "B1", "B2", "C", "D")
z &lt;- as.matrix(as.DNAbin(z))
(ntz &lt;- mjn(z, 2))

## Not run: 
## same like in Fig. 5 of Bandelt et al. (1999):
plotNetMDS(ntz, dist.dna(attr(ntz, "data"), "N"), 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='MMD'>Mismatch Distribution</h2><span id='topic+MMD'></span>

<h3>Description</h3>

<p>This function draws a histogram of the frequencies of pairwise
distances from a set of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMD(x, xlab = "Distance", main = "", rug = TRUE, legend = TRUE,
    lcol = c("blue", "red"), lty = c(1, 1), bw = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MMD_+3A_x">x</code></td>
<td>
<p>a set of DNA sequences (object of class <code>"DNAbin"</code>).</p>
</td></tr>
<tr><td><code id="MMD_+3A_xlab">xlab</code></td>
<td>
<p>the label for the x-axis.</p>
</td></tr>
<tr><td><code id="MMD_+3A_main">main</code></td>
<td>
<p>the title (none by default).</p>
</td></tr>
<tr><td><code id="MMD_+3A_rug">rug</code></td>
<td>
<p>a logical specifying whether to add a rug of the pairwise
distances on the horizontal axis (see <code><a href="graphics.html#topic+rug">rug</a></code>).</p>
</td></tr>
<tr><td><code id="MMD_+3A_legend">legend</code></td>
<td>
<p>a logical specifying whether to draw a legend.</p>
</td></tr>
<tr><td><code id="MMD_+3A_lcol">lcol</code></td>
<td>
<p>the colours used for the curves.</p>
</td></tr>
<tr><td><code id="MMD_+3A_lty">lty</code></td>
<td>
<p>the line types for the curves</p>
</td></tr>
<tr><td><code id="MMD_+3A_bw">bw</code></td>
<td>
<p>the bandwidth used for the empirical density curve (passed
to <code><a href="stats.html#topic+density">density</a></code>).</p>
</td></tr>
<tr><td><code id="MMD_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The histogram shows the observed distribution of pairwise
distances. The lines show an empirical density estimate (in blue) and
the expected distribution under stable population (Rogers and
Harpending 1992).
</p>


<h3>Value</h3>

<p>an invisible list with three elements:
</p>
<table role = "presentation">
<tr><td><code>histogram</code></td>
<td>
<p>the output of the <code><a href="graphics.html#topic+hist">hist</a></code>
call.</p>
</td></tr>
<tr><td><code>empirical.density</code></td>
<td>
<p>the empirical density as estimated by
<code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code>expected.curve:</code></td>
<td>
<p>the values of the curve expected under stable
population.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis and David Winter</p>


<h3>References</h3>

<p>Rogers, A. R. and Harpending, H. (1992) Population growth makes waves
in the distribution of pairwise genetic-differences. <em>Molecular
Biology and Evolution</em>, <b>9</b>, 552&ndash;569.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
mmd.woodm &lt;- MMD(woodmouse)
str(mmd.woodm)
MMD(woodmouse, breaks = 20, legend = FALSE)
MMD(woodmouse, lty = 1:2, lcol = rep("black", 2), col = "lightgrey")
</code></pre>

<hr>
<h2 id='mst'>Minimum Spanning Tree and Network</h2><span id='topic+mst'></span><span id='topic+msn'></span><span id='topic+rmst'></span>

<h3>Description</h3>

<p>Computes a minimum spanning tree using Kruskal's algorithm, the
minimum spanning network using Bandelt et al.'s algorithm, or the
randomized minimum spanning tree (Paradis 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst(d)
msn(d)
rmst(d, B = NULL, stop.criterion = NULL, iter.lim = 1000,
     quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mst_+3A_d">d</code></td>
<td>
<p>a distance matrix, either as an object of class <code>"dist"</code>,
or a (square symmetric) matrix.</p>
</td></tr>
<tr><td><code id="mst_+3A_b">B</code></td>
<td>
<p>number of randomizations.</p>
</td></tr>
<tr><td><code id="mst_+3A_stop.criterion">stop.criterion</code></td>
<td>
<p>the stopping criterion if <code>B</code> is not given
(see details).</p>
</td></tr>
<tr><td><code id="mst_+3A_iter.lim">iter.lim</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mst_+3A_quiet">quiet</code></td>
<td>
<p>a logical value specifying whether to indicate progress
of calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the RMST, the calculations stop when no new links are found after a
number of successive iterations specified by <code>stop.criterion</code>. By
default, this number is ceiling(sqrt(n)) where n is the number of
observations. This criterion is ignored if <code>B</code> is given, or if n
&lt; 6 in which case complete enumeration is done. In all cases, no more
than <code>iter.lim</code> iterations are done.
</p>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+haploNet">haploNet</a>"</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">ape</span> has a function named <code>mst</code> which is older (and used by
other packages) and returns its results in a different form. The
present version is more efficient. If you want to use the older
version after loading <span class="pkg">pegas</span>, use <code>ape::mst</code> since <span class="pkg">ape</span>
will certainly always be loaded before <span class="pkg">pegas</span>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Bandelt, H. J., Forster, P. and Rohl, A. (1999) Median-joining networks
for inferring intraspecific phylogenies. <em>Molecular Biology and
Evolution</em>, <b>16</b>, 37&ndash;48.
</p>
<p>Kruskal, J. B., Jr. (1956) On the shortest spanning subtree of a graph
and the traveling salesman problem. <em>Proceedings of the American
Mathematical Society</em>, <b>7</b>, 48&ndash;50.
</p>
<p>Paradis, E. (2018) Analysis of haplotype networks: the randomized
minimum spanning tree method. <em>Methods in Ecology and Evolution</em>,
<b>9</b>, 1308&ndash;1317. DOI: 10.1111/2041-210X.12969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>, <code><a href="#topic+mjn">mjn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- dist.dna(woodmouse, "n")
(r &lt;- mst(d))
plot(r)

## a case where the RMST and the MJN are identical:
x &lt;- c("&gt;A", "TAAGTGCAT", "&gt;B", "TAAATGCAT", "&gt;C", "TAGGTGCAT", "&gt;D", "TAAGTACAT",
       "&gt;E", "TAAGTGTAT", "&gt;F", "TAAGTACAC", "&gt;G", "TAAGTACGT", "&gt;H", "CAAGTACAC",
       "&gt;I", "CAAGCACAC", "&gt;J", "CAAGTACAT", "&gt;K", "CGAGTACAT", "&gt;L", "TAAGTACGC",
       "&gt;M", "CAAGCACAT")
fl &lt;- tempfile()
cat(x, file = fl, sep = "\n")
x &lt;- read.dna(fl, "f")
tr &lt;- rmst(dist.dna(x, "n"))
ts &lt;- mjn(x)
stopifnot(all.equal(tr, ts))
unlink(fl)
</code></pre>

<hr>
<h2 id='mutations'>Plot Mutations on Networks</h2><span id='topic+mutations'></span>

<h3>Description</h3>

<p><code>mutations</code> draws annotations about mutations related to the link
of a haplotype network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutations(haploNet, link, x, y, data = NULL, style = "table", POS, SEQLEN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutations_+3A_haplonet">haploNet</code></td>
<td>
<p>an object of class <code>"haploNet"</code> which should be
plotted beforehand.</p>
</td></tr>
<tr><td><code id="mutations_+3A_link">link</code></td>
<td>
<p>the link number; can be left missing in which case the
list of links in the network is printed and the function exits.</p>
</td></tr>
<tr><td><code id="mutations_+3A_x">x</code>, <code id="mutations_+3A_y">y</code></td>
<td>
<p>the coordinates where to draw the annotations; can be left
missing: the user is then asked to click where to draw them and the
chosen coordinates are printed.</p>
</td></tr>
<tr><td><code id="mutations_+3A_data">data</code></td>
<td>
<p>the sequence data; can be left missing if the data are
attached to the network (for a MJN network output by
<code><a href="#topic+mjn">mjn</a></code>.)</p>
</td></tr>
<tr><td><code id="mutations_+3A_style">style</code></td>
<td>
<p>the type annotations. There two possible choices:
<code>"table"</code> (default) and <code>"sequence"</code> (can be abbreviated).</p>
</td></tr>
<tr><td><code id="mutations_+3A_pos">POS</code>, <code id="mutations_+3A_seqlen">SEQLEN</code></td>
<td>
<p>a vector of genomic positions and the sequence
length in case <code>data</code> is of class <code>"haplotype.loci"</code>.</p>
</td></tr>
<tr><td><code id="mutations_+3A_...">...</code></td>
<td>
<p>options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The easiest way to use this function is with an output from
<code><a href="#topic+mjn">mjn</a></code> since the data are attached to the network. In other
cases, the sequence data must given to the argument <code>data</code> or
attached to the network as an attribute named <code>"data"</code>.
</p>


<h3>Value</h3>

<p>none</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.haploNet">plot.haploNet</a></code>, <code><a href="#topic+haplotype.loci">haplotype.loci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example
x &lt;- as.DNAbin(matrix(c("a", "g"), 2, 1))
rownames(x) &lt;- paste("Ind", 1:2, sep = "_")
nt &lt;- mst(dist.dna(x, "N"))
plot(nt)
mutations(nt, link = 1, x = 2, y = 2, data = x)

example(mjn)
plot(ntz, xlim = c(-5, 20))
mutations(ntz, 6, 10, 0, style = "s")
mutations(ntz, 8, 10, -2, style = "s")
</code></pre>

<hr>
<h2 id='na.omit.loci'>Missing Allelic Data</h2><span id='topic+na.omit.loci'></span><span id='topic+nullAlleles2NA'></span>

<h3>Description</h3>

<p>The first function is a method of the generic function
<code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>
<p><code>nullAlleles2NA</code> changes all genotypes with at least one &lsquo;null&rsquo;
allele (that is among the values in <code>na.alleles</code>) into <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
na.omit(object, na.alleles = c("0", "."), ...)

nullAlleles2NA(object, na.alleles = c("0", "."))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.omit.loci_+3A_object">object</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="na.omit.loci_+3A_na.alleles">na.alleles</code></td>
<td>
<p>a vector of character strings giving the alleles
to be treated as missing data.</p>
</td></tr>
<tr><td><code id="na.omit.loci_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The side effect of <code>na.omit</code> is to drop the rows (individuals)
with unclearly identified genotypes, i.e., with at least one allele
among <code>na.alleles</code>.
</p>
<p>Other variables in the data table are eventually checked and levels
with no observation (e.g., population) are dropped.
</p>
<p><code>nullAlleles2NA</code> does not remove any observation but changes
these genotypes into <code><a href="base.html#topic+NA">NA</a></code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"loci"</code>.</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
nrow(jaguar)
nrow(na.omit(jaguar))
nrow(nullAlleles2NA(jaguar))
</code></pre>

<hr>
<h2 id='nuc.div'>Nucleotide Diversity</h2><span id='topic+nuc.div'></span><span id='topic+nuc.div.DNAbin'></span><span id='topic+nuc.div.haplotype'></span>

<h3>Description</h3>

<p>This function computes the nucleotide diversity from a sample of DNA
sequences or a set of haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuc.div(x, ...)
## S3 method for class 'DNAbin'
nuc.div(x, variance = FALSE, pairwise.deletion = FALSE, ...)
## S3 method for class 'haplotype'
nuc.div(x, variance = FALSE, pairwise.deletion = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nuc.div_+3A_x">x</code></td>
<td>
<p>a matrix or a list which contains the DNA sequences.</p>
</td></tr>
<tr><td><code id="nuc.div_+3A_variance">variance</code></td>
<td>
<p>a logical indicating whether to compute the variance
of the estimated nucleotide diversity.</p>
</td></tr>
<tr><td><code id="nuc.div_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical indicating whether to delete the
sites with missing data in a pairwise way. The default is to delete
the sites with at least one missing data for all sequences.</p>
</td></tr>
<tr><td><code id="nuc.div_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function with methods for classes <code>"DNAbin"</code>
and <code>"haplotype"</code>. The first method uses the sum of the number of
differences between pairs of sequences divided by the number of
comparisons (i.e. <code class="reqn">n(n - 1)/2</code>, where <code class="reqn">n</code> is the number of
sequences). The second method uses haplotype frequencies. It could be
that both methods give (slightly) different results because of missing
or ambiguous nucleotides: this is generally solved by setting
<code>pairwise.deletion = TRUE</code>.
</p>
<p>The variance of the estimated diversity uses formula (10.9) from Nei
(1987). This applies only if all sequences are of the same lengths,
and cannot be used if <code>pairwise.deletion = TRUE</code>. A bootstrap
estimate may be in order if you insist on using the latter option.
</p>


<h3>Value</h3>

<p>A numeric vector with one or two values if <code>variance = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Nei, M. (1987) <em>Molecular evolutionary genetics</em>. New York:
Columbia University Press.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+base.freq">base.freq</a></code>, <code><a href="ape.html#topic+GC.content">GC.content</a></code>,
<code><a href="#topic+theta.s">theta.s</a></code>, <code><a href="ape.html#topic+seg.sites">seg.sites</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
nuc.div(woodmouse)
nuc.div(woodmouse, TRUE)
nuc.div(woodmouse, FALSE, TRUE)
</code></pre>

<hr>
<h2 id='plotNetMDS'>Plot Networks With MDS Layout</h2><span id='topic+plotNetMDS'></span>

<h3>Description</h3>

<p>This function plots a haplotype network using a layout calculated from
an MDS performed on the pairwise distance matrix. The haplotypes have
always the same positions for different networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNetMDS(net, d, k = 2, show.mutation = FALSE, col = NULL, font = 2, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotNetMDS_+3A_net">net</code></td>
<td>
<p>an object of class <code>"haploNet"</code>.</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_d">d</code></td>
<td>
<p>an object of class <code>"dist"</code> (or a matrix).</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_k">k</code></td>
<td>
<p>the number of dimensions of the plot (2 or 3).</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_show.mutation">show.mutation</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, the number of
steps is printed on the links.</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_col">col</code></td>
<td>
<p>the colours of the links; by default, semi-transparent
green.</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_font">font</code></td>
<td>
<p>the font used to print the labels; bold by default.</p>
</td></tr>
<tr><td><code id="plotNetMDS_+3A_cex">cex</code></td>
<td>
<p>the character expansion of the labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Paradis, E. (2017) Analysis of haplotype networks: the randomized
minimum spanning tree method. Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
d &lt;- dist.dna(woodmouse, "n")
net &lt;- rmst(d)
plotNetMDS(net, d)
</code></pre>

<hr>
<h2 id='R2.test'>Ramos-Onsins&ndash;Rozas Test of Neutrality</h2><span id='topic+R2.test'></span>

<h3>Description</h3>

<p>This function computes Ramos-Onsins and Rozas's test of neutrality
for a set of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2.test(x, B = 1000, theta = 1, plot = TRUE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2.test_+3A_x">x</code></td>
<td>
<p>a DNA matrix (object of class <code>"DNAbin"</code>).</p>
</td></tr>
<tr><td><code id="R2.test_+3A_b">B</code></td>
<td>
<p>the number of replicates used for the simulation procedure.</p>
</td></tr>
<tr><td><code id="R2.test_+3A_theta">theta</code></td>
<td>
<p>the value of the <code class="reqn">\theta</code> population parameter
used in the simulation.</p>
</td></tr>
<tr><td><code id="R2.test_+3A_plot">plot</code></td>
<td>
<p>a logical value specifying whether to plot the results
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="R2.test_+3A_quiet">quiet</code></td>
<td>
<p>a logical value specifying whether to not display the
progress of the simulations. The default is <code>FALSE</code> meaning
that a progress bar is displayed by default.</p>
</td></tr>
<tr><td><code id="R2.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>hist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements: <code>R2</code> the value of the test statistic
<code class="reqn">R_2</code>, and <code>P.val</code> the associated <em>P</em>-value. If
<code>B = 0</code> a single value, the test statistic, is returned
</p>


<h3>Note</h3>

<p>The simulation procedure probably needs to be tested and
improved. However the results make sense so far.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Ramos-Onsins, R. and Rozas, R. (2002) Statistical properties of new
neutrality tests against population growth. <em>Molecular Biology
and Evolution</em>, <b>19</b>, 2092&ndash;2100.
</p>
<p>Sano, J. and Tachida, G. (2005) Gene genealogy and properties of test
statistics of neutrality under population growth. <em>Genetics</em>,
<b>169</b>, 1687&ndash;1697.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
R2.test(woodmouse, quiet = TRUE)
</code></pre>

<hr>
<h2 id='read.gtx'>Read Genetix Data Files</h2><span id='topic+read.gtx'></span>

<h3>Description</h3>

<p>This function reads allelic data from a Genetix file (.gtx).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gtx(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.gtx_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character
or a quoted string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with class <code>c("loci", "data.frame")</code>.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">adegenet</span> has a similar function,
<code><a href="adegenet.html#topic+read.genetix">read.genetix</a></code>, but it returns an object of
class <code>"genind"</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Belkhir, K., Borsa, P., Chikhi, L., Raufaste, N. and Bonhomme,
F. (1996&ndash;2004) GENETIX 4.05, logiciel sous Windows(TM) pour la
genetique des populations. Laboratoire Genome, Populations,
Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier
(France). <a href="https://kimura.univ-montp2.fr/genetix/">https://kimura.univ-montp2.fr/genetix/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="#topic+write.loci">write.loci</a></code>,
<code><a href="#topic+read.vcf">read.vcf</a></code>, <code><a href="adegenet.html#topic+read.genetix">read.genetix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(adegenet)
(X &lt;- read.gtx(system.file("files/nancycats.gtx", package = "adegenet")))
## compare with the example in ?read.genetix
</code></pre>

<hr>
<h2 id='read.loci'>Read Allelic Data Files</h2><span id='topic+read.loci'></span><span id='topic+loci'></span>

<h3>Description</h3>

<p>This function reads allelic data from a text file: rows are
individuals, and columns are loci and optional variables. By default,
the first line of the file gives the locus names. If one column is
labelled &lsquo;population&rsquo;, it is taken as a population variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.loci(file, header = TRUE, loci.sep = "", allele.sep = "/|",
          col.pop = NULL, col.loci = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.loci_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a quoted string.</p>
</td></tr>
<tr><td><code id="read.loci_+3A_header">header</code></td>
<td>
<p>a logical specifying whether the first line of the data
file gives the names of the loci (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="read.loci_+3A_loci.sep">loci.sep</code></td>
<td>
<p>the character(s) separating the loci (columns) in the
data file (a white space by default).</p>
</td></tr>
<tr><td><code id="read.loci_+3A_allele.sep">allele.sep</code></td>
<td>
<p>the character(s) separating the alleles for each locus
in the data file (a forward slash by default).</p>
</td></tr>
<tr><td><code id="read.loci_+3A_col.pop">col.pop</code></td>
<td>
<p>specifies whether one of the column of the data file
identifies the population. By default, if one column is labelled
&lsquo;population&rsquo; (case-insensitive), it is taken as the population
variable; otherwise an integer giving the number of the column or a
character string giving its name. It is eventually renamed
&lsquo;population&rsquo; and transformed as a factor.</p>
</td></tr>
<tr><td><code id="read.loci_+3A_col.loci">col.loci</code></td>
<td>
<p>a vector of integers or characters specifying the
indices or the names of the columns that are loci. By default, all
columns are taken as loci except the population one, if present or
specified.</p>
</td></tr>
<tr><td><code id="read.loci_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>read.table</code> (e.g.,
<code>row.names</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rownames of the returned object identify the individual genotypes;
they are either taken from the data file if present, or given the
values <code>"1"</code>, <code>"2"</code>, ... Similarly for the colnames: if
absent in the file (in which case <code>header = FALSE</code> must be set),
they are given the values <code>"V1"</code>, <code>"V2"</code>, ...
</p>
<p>In the returned genotypes, alleles are separated by <code>"/"</code>, even
if it is not the case in the data file.
</p>
<p>The vignette &ldquo;Reading Genetic Data Files Into R with <span class="pkg">adegenet</span>
and <span class="pkg">pegas</span>&rdquo; explains how to read various file formats including
Excel files (type <code>vignette("ReadingFiles")</code> in R).
</p>


<h3>Value</h3>

<p>A data frame with class <code>c("loci", "data.frame")</code>. It is a data
frame with an attribute <code>"locicol"</code> specifying the columns that
must be treated as loci. The latter are factors. The other columns can
be of any type.
</p>
<p>Details on the structure can be found in
<a href="https://emmanuelparadis.github.io/pegas/DefinitionDataClassesPegas.pdf">https://emmanuelparadis.github.io/pegas/DefinitionDataClassesPegas.pdf</a>
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gtx">read.gtx</a></code>, <code><a href="#topic+read.vcf">read.vcf</a></code>,
<code><a href="#topic+write.loci">write.loci</a></code>, <code><a href="#topic+summary.loci">summary.loci</a></code>
</p>

<hr>
<h2 id='read.vcf'>Read Variant Calling Format Files</h2><span id='topic+read.vcf'></span><span id='topic+write.vcf'></span>

<h3>Description</h3>

<p><code>read.vcf</code> reads allelic data from VCF (variant calling format)
files.
</p>
<p><code>write.vcf</code> writes allelic data from an object of class
<code>"loci"</code> into a VCF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.vcf(file, from = 1, to = 10000, which.loci = NULL, quiet = FALSE)
write.vcf(x, file, CHROM = NULL, POS = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.vcf_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a quoted string.</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_from">from</code>, <code id="read.vcf_+3A_to">to</code></td>
<td>
<p>the loci to read; by default, the first 10,000.</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_which.loci">which.loci</code></td>
<td>
<p>an alternative way to specify which loci to read is
to give their indices (see <code>link{VCFloci}</code> how to obtain them).</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_quiet">quiet</code></td>
<td>
<p>a logical: should the progress of the operation be
printed?</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_chrom">CHROM</code>, <code id="read.vcf_+3A_pos">POS</code></td>
<td>
<p>two vectors giving the chromosomes and (genomic)
positions of the loci (typically from the output of <code><a href="#topic+VCFloci">VCFloci</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The VCF file can be compressed (*.gz) or not. Since pegas 0.11,
compressed remote files can be read (see examples).
</p>
<p>A TABIX file is not required (and will be ignored if present).
</p>
<p>In the VCF standard, missing data are represented by a dot and these
are read &ldquo;as is&rdquo; by the present function without trying to
substitute by <code>NA</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>c("loci", "data.frame")</code>.
</p>


<h3>Note</h3>

<p>Like for <code><a href="#topic+VCFloci">VCFloci</a></code>, the present function can read either
compressed (*.gz) or uncompressed files. There should be no difference
in performance between both types of files if they are relatively
small (less than 1 Gb as uncompressed, equivalent to ~50 Mb when
compressed). For bigger files, it is more efficient to uncompress them
(if disk space is sufficient), especially if they have to be accessed
several times during the same session.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://www.internationalgenome.org/wiki/Analysis/vcf4.0">https://www.internationalgenome.org/wiki/Analysis/vcf4.0</a>
</p>
<p><a href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VCFloci">VCFloci</a></code>, <code><a href="#topic+read.loci">read.loci</a></code>,
<code><a href="#topic+read.gtx">read.gtx</a></code>, <code><a href="#topic+write.loci">write.loci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Chr Y from the 1000 Genomes:
a &lt;- "https://ftp-trace.ncbi.nih.gov/1000genomes/ftp/release/20130502"
b &lt;- "ALL.chrY.phase3_integrated_v1b.20130502.genotypes.vcf.gz"
## WARNING: the name of the file above may change
url &lt;- paste(a, b, sep = "/")
## Solution 1: download first
download.file(url, "chrY.vcf.gz")
## no need to uncompress:
(info &lt;- VCFloci("chrY.vcf.gz"))
str(info) # show the modes of the columns
## Solution 2: read remotely (since pegas 0.11)
info2 &lt;- VCFloci(url)
identical(info, info2)
rm(info2)

SNP &lt;- is.snp(info)
table(SNP) # how many loci are SNPs?
## compare with:
table(getINFO(info, "VT"))

op &lt;- par(mfcol = c(4, 1), xpd = TRUE)
lim &lt;- c(2.65e6, 2.95e6)
## distribution of SNP and non-SNP mutations along the Y chr:
plot(info$POS, !SNP, "h", col = "red", main = "non-SNP mutations",
     xlab = "Position", ylab = "", yaxt = "n")
rect(lim[1], -0.1, lim[2], 1.1, lwd = 2, lty = 2)
plot(info$POS, SNP, "h", col = "blue", main = "SNP mutations",
     xlab = "Position", ylab = "", yaxt = "n")
rect(lim[1], -0.1, lim[2], 1.1, lwd = 2, lty = 2)
par(xpd = FALSE)
## same focusing on a smaller portion of the chromosome:
plot(info$POS, !SNP, "h", col = "red", xlim = lim, xlab = "Position",
     ylab = "", yaxt = "n")
plot(info$POS, SNP, "h", col = "blue", xlim = lim, xlab = "Position",
     ylab = "", yaxt = "n")
par(op)

## read both types of mutations separately:
X.SNP &lt;- read.vcf("chrY.vcf.gz", which.loci = which(SNP))
X.other &lt;- read.vcf("chrY.vcf.gz", which.loci = which(!SNP))

identical(rownames(X.SNP), VCFlabels("chrY.vcf.gz")) # TRUE
cat(VCFheader("chrY.vcf.gz"))

## get haplotypes for the first 10 loci:
h &lt;- haplotype(X.SNP, 1:10)
## plot their frequencies:
op &lt;- par(mar = c(3, 10, 1, 1))
plot(h, horiz=TRUE, las = 1)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='replot'>Edit the Layout of a Haplotype Network</h2><span id='topic+replot'></span>

<h3>Description</h3>

<p>This function makes possible to change the layout of a haplotype
network interactively or with specified coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replot(xy = NULL, col.identifier = "purple", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replot_+3A_xy">xy</code></td>
<td>
<p>an optional list with vectors names <code>x</code> and <code>y</code>
(or <code>xx</code> and <code>yy</code>) giving the coordinates of the nodes.</p>
</td></tr>
<tr><td><code id="replot_+3A_col.identifier">col.identifier</code></td>
<td>
<p>the colour used to identify the node to be moved.</p>
</td></tr>
<tr><td><code id="replot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in two ways. By default (i.e.,
<code>replot()</code>), the user can edit a plotted haplotype network by
clicking with the mouse on the graphical window: a message is printed
asking to click once close to the node to move and then clicking again
where this node should be placed (careful: two separate single
clicks). Editing is stopped with a right click.
</p>
<p>The second possible use is to specify the new coordinates of the nodes
with the argument <code>xy</code>, typically, from a previous call to
<code>replot</code> (see examples).
</p>
<p>Since <span class="pkg">pegas</span> 1.0, these coordinates can be used directly in
<code><a href="#topic+plot.haploNet">plot.haploNet</a></code> making possible to combine networks with
other graphics (which not possible with <code>replot</code> because the
network is replotted).
</p>


<h3>Value</h3>

<p>a named list with two numeric vertors (<code>x</code> and <code>y</code>).
</p>


<h3>Note</h3>

<p>For users of RStudio: the function does not work within this
application. It seems the best is to run R from a shell (or maybe
opening a new graphical device with <code><a href="grDevices.html#topic+X11">X11</a></code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploNet">haploNet</a></code>, <code><a href="#topic+haploFreq">haploFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a non-interactive example:
example(mjn)
layout(matrix(1:2, 1))
plot(ntz, labels = TRUE)
## it is possible plot this network with no line-crossing
## with these coordinates:
xy &lt;- list(x = c(3.2, -2.6, -6.6, -7.2, 0, 3.5, 2.6, -2.9, -0.3, 3.4, -3.4),
           y = c(3.4, 4.4, 1.3, -3.9, -5.5, -10.9, 0.1, -0.8, -2.3,  -7.9, -8.1))
replot(ntz, xy = xy) # or plot(ntz, xy = xy, labels = TRUE)
layout(1)

## an interactive example:
## Not run: 
data(woodmouse)
net &lt;- haploNet(haplotype(woodmouse))
plot(net)
o &lt;- replot() # interactive
## click to rearrange the network at will...
## then do a different plot using the same coordinates:
plot(net, bg = "red", labels = FALSE, show.mutation = 2)
replot(o) # not interactive

## End(Not run)</code></pre>

<hr>
<h2 id='rr.test'>Tajima Relative Rate Test of Molecular Clock</h2><span id='topic+rr.test'></span>

<h3>Description</h3>

<p>This function tests the hypothesis of a molecular evolutionary clock
(i.e., a constant rate of molecular evolution) between two samples
using an outgroup sample. It can be applied to both nucleotide and
amino acid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr.test(x, y, out)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rr.test_+3A_x">x</code>, <code id="rr.test_+3A_y">y</code></td>
<td>
<p>a single DNA sequence (object class <code>"DNAbin"</code>).</p>
</td></tr>
<tr><td><code id="rr.test_+3A_out">out</code></td>
<td>
<p>a single DNA sequence to be used as outgroup.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two numeric values: <code>Chi</code> (Chi-squared statistic) and
<code>Pval</code> (the P-value).
</p>


<h3>Author(s)</h3>

<p>Alastair Potts <a href="mailto:potts.a@gmail.com">potts.a@gmail.com</a></p>


<h3>References</h3>

<p>Tajima, F. (1993) Simple methods for testing molecular clock
hypothesis. <em>Genetics</em>, <b>135</b>, 599&ndash;607. (Equation 4)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)
data(woodmouse)
rr.test(x = woodmouse[2, ], y = woodmouse[3, ], out = woodmouse[1, ])

# Test all pairs in a sample:
outgroup &lt;- woodmouse[1, ]
n &lt;- nrow(woodmouse)
cc &lt;- combn(2:n, 2)
FUN &lt;- function(x)
    rr.test(woodmouse[x[1], ], woodmouse[x[2], ], outgroup)$Pval
OUT &lt;- apply(cc, 2, FUN)
### two ways to arrange the output:
RES &lt;- matrix(NA, n - 1, n - 1)
RES[row(RES) &gt; col(RES)] &lt;- OUT
RES &lt;- t(RES)
RES[row(RES) &gt; col(RES)] &lt;- OUT
RES &lt;- t(RES)
dimnames(RES) &lt;- list(2:n, 2:n)
RES &lt;- as.dist(RES)
### 2nd method:
class(OUT) &lt;- "dist"
attr(OUT, "Labels") &lt;- as.character(2:15)
attr(OUT, "Size") &lt;- n - 1L
attr(OUT, "Diag") &lt;- attr(OUT, "Upper") &lt;- FALSE
### they are the same:
all(OUT == RES)
</code></pre>

<hr>
<h2 id='site.spectrum'>Site Frequency Spectrum</h2><span id='topic+site.spectrum'></span><span id='topic+site.spectrum.DNAbin'></span><span id='topic+site.spectrum.loci'></span><span id='topic+plot.spectrum'></span>

<h3>Description</h3>

<p><code>site.spectrum</code> computes the (un)folded site frequency spectrum
of a set of aligned DNA sequences or SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site.spectrum(x, ...)
## S3 method for class 'DNAbin'
site.spectrum(x, folded = TRUE, outgroup = 1, ...)
## S3 method for class 'loci'
site.spectrum(x, folded = TRUE, ancestral = NULL, ...)
## S3 method for class 'spectrum'
plot(x, col = "red", main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="site.spectrum_+3A_x">x</code></td>
<td>
<p>a set of DNA sequences (as an object of class
<code>"DNAbin"</code>), or an object of class <code>"spectrum"</code>.</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_folded">folded</code></td>
<td>
<p>a logical specifying whether to compute the folded site
frequency spectrum (the default), or the unfolded spectrum if
<code>folded = FALSE</code>.</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_outgroup">outgroup</code></td>
<td>
<p>a single integer value giving which sequence is
ancestral; ignored if <code>folded = TRUE</code>.</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_ancestral">ancestral</code></td>
<td>
<p>a vector of ancestral alleles (required if
<code>folded = FALSE</code>), typically from an output of
<code><a href="#topic+VCFloci">VCFloci</a></code>.</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_col">col</code></td>
<td>
<p>the colour of the barplot (red by default).</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_main">main</code></td>
<td>
<p>a character string for the title of the plot; a generic
title is given by default (use <code>main = ""</code> to have no title).</p>
</td></tr>
<tr><td><code id="site.spectrum_+3A_...">...</code></td>
<td>
<p>further arguments passed to
<code><a href="graphics.html#topic+barplot">barplot</a></code>, or to other mehods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the infinite sites model of mutation, mutations occur on
distinct sites, so every segregating (polymorphic) site defines a
partition of the <code class="reqn">n</code> sequences (see Wakeley, 2009). The <em>site
frequency spectrum</em> is a series of values where the <code class="reqn">i</code>th element
is the number of segregating sites defining a partition of <code class="reqn">i</code> and
<code class="reqn">n - i</code> sequences. The <em>unfolded</em> version requires to define
an ancestral state with an external (outgroup) sequence, so <code class="reqn">i</code>
varies between 1 and <code class="reqn">n - 1</code>. If no ancestral state can be
defined, the <em>folded</em> version is computed, so <code class="reqn">i</code> varies
between 1 and <code class="reqn">n/2</code> or <code class="reqn">(n - 1)/2</code>, for <code class="reqn">n</code> even or odd,
respectively.
</p>
<p>If <code>folded = TRUE</code>, sites with more than two states are ignored
and a warning is returned giving how many were found.
</p>
<p>If <code>folded = FALSE</code>, sites with an ambiguous state at the
external sequence are ignored and a warning is returned giving how
many were found. Note that it is not checked if some sites have more
than two states.
</p>
<p>If <code>x</code> is an object of class <code>"loci"</code>, the loci which are
not biallelic (e.g., SNPs) are dropped with a warning.
</p>


<h3>Value</h3>

<p><code>site.spectrum</code> returns an object of class <code>"spectrum"</code>
which is a vector of integers (some values may be equal to zero) with
the attributes <code>"sample.size"</code> and <code>"folded"</code> (a logical
value) indicating which version of the spectrum has been computed.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Wakeley, J. (2009) <em>Coalescent Theory: An Introduction.</em>
Greenwood Village, CO: Roberts and Company Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+DNAbin">DNAbin</a></code> for manipulation of DNA sequences in R,
<code><a href="#topic+haplotype">haplotype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)
data(woodmouse)
(sp &lt;- site.spectrum(woodmouse))
plot(sp)
</code></pre>

<hr>
<h2 id='stairway'>The Stairway Plot</h2><span id='topic+stairway'></span><span id='topic+plot.stairway'></span><span id='topic+lines.stairway'></span>

<h3>Description</h3>

<p>This function fits a model of population change using the site
frequency spectrum (SFS). The default assumes <code class="reqn">\Theta=1</code>. A model of population change estimates the temporal changes in
<code class="reqn">\Theta</code> with respect to the value of this parameter at
present time. The model is specified by the user with the option
<code>epoch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairway(x, epoch = NULL, step.min = 1e-6, step.max = 1e-3)
## S3 method for class 'stairway'
plot(x, type = "S", xlab = "Coalescent intervals",
             ylab = expression(Theta), ...)
## S3 method for class 'stairway'
lines(x, type = "S", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stairway_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+site.spectrum">site.spectrum</a></code> or of class
<code>stairway</code>.</p>
</td></tr>
<tr><td><code id="stairway_+3A_epoch">epoch</code></td>
<td>
<p>an optional vector of integers giving the periods of time
(or epochs) with distinct <code class="reqn">\Theta</code>.</p>
</td></tr>
<tr><td><code id="stairway_+3A_step.min">step.min</code></td>
<td>
<p>a single numeric value giving the smallest step size
used during optimization.</p>
</td></tr>
<tr><td><code id="stairway_+3A_step.max">step.max</code></td>
<td>
<p>id. for the largest step size (see
<code><a href="stats.html#topic+nlminb">nlminb</a></code>).</p>
</td></tr>
<tr><td><code id="stairway_+3A_type">type</code></td>
<td>
<p>the type of lines.</p>
</td></tr>
<tr><td><code id="stairway_+3A_xlab">xlab</code>, <code id="stairway_+3A_ylab">ylab</code></td>
<td>
<p>the default labels on the axes.</p>
</td></tr>
<tr><td><code id="stairway_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic method implemented in this function is similar to Polanski
and Kimmel (2003). The temporal model with &ldquo;epochs&rdquo; is from Liu and
Fu (2015).
</p>


<h3>Value</h3>

<p>By default, a single numeric value with the null deviance. If
<code>epoch</code> is used, a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>estimates</code></td>
<td>
<p>the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance of the fitted model.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the deviance of the null model.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>the likelihood-ratio test comparing the null and the fitted models.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information criterion of the fitted model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Liu, X. M. and Fu, Y. X. (2015) Exploring population size changes using SNP frequency spectra. <em>Nature Genetics</em>, <b>47</b>, 555&ndash;559.
</p>
<p>Polanski, A. and Kimmel, M. (2003) New explicit expressions for relative frequencies of single-nucleotide polymorphisms with application to statistical inference on population growth. <em>Genetics</em>, <b>165</b>, 427&ndash;436.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+site.spectrum">site.spectrum</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
sp &lt;- site.spectrum(woodmouse)
stairway(sp, c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2))
</code></pre>

<hr>
<h2 id='subset.haplotype'>Subsetting and Filtering Haplotypes</h2><span id='topic+subset.haplotype'></span>

<h3>Description</h3>

<p>This function selects haplotypes based on their (absolute) frequencies
and/or proportions of missing nucleotides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplotype'
subset(x, minfreq = 1, maxfreq = Inf, maxna = Inf, na = c("N", "?"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.haplotype_+3A_x">x</code></td>
<td>
<p>an object of class <code>c("haplotype", "DNAbin")</code>.</p>
</td></tr>
<tr><td><code id="subset.haplotype_+3A_minfreq">minfreq</code>, <code id="subset.haplotype_+3A_maxfreq">maxfreq</code></td>
<td>
<p>the lower and upper limits of (absolute)
haplotype frequencies. By default, all haplotypes are selected
whatever their frequency.</p>
</td></tr>
<tr><td><code id="subset.haplotype_+3A_maxna">maxna</code></td>
<td>
<p>the maximum frequency (absolute or relative; see details)
of missing nucleotides within a given haplotype.</p>
</td></tr>
<tr><td><code id="subset.haplotype_+3A_na">na</code></td>
<td>
<p>a vector of mode character specifying which nucleotide
symbols should be treated as missing data; by default, unknown
nucleotide (N) and completely unknown site (?) (can be lower- or
uppercase). There are two shortcuts: see details.</p>
</td></tr>
<tr><td><code id="subset.haplotype_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of <code>maxna</code> can be either less than one, or greater or
equal to one. In the former case, it is taken as specifying the
maximum proportion (relative frequency) of missing data within a given
haplotype. In the latter case, it  is taken as the maximum number
(absolute frequency).
</p>
<p><code>na = "all"</code> is a shortcut for all ambiguous nucleotides
(including N) plus alignment gaps and completely unknown site (?).
</p>
<p><code>na = "ambiguous"</code> is a shortcut for only ambiguous nucleotides
(including N).
</p>


<h3>Value</h3>

<p>an object of class <code>c("haplotype", "DNAbin")</code>.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplotype">haplotype</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
h &lt;- haplotype(woodmouse)
subset(h, maxna = 20)
subset(h, maxna = 20/ncol(h)) # same thing than above
</code></pre>

<hr>
<h2 id='summary.loci'>Print and Summaries of Loci Objects</h2><span id='topic+summary.loci'></span><span id='topic++5B.loci'></span><span id='topic+print.summary.loci'></span><span id='topic+plot.summary.loci'></span><span id='topic+print.loci'></span>

<h3>Description</h3>

<p>These functions print and summarize table of alleles and loci (objects
of class <code>"loci"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loci'
print(x, details = FALSE, ...)
## S3 method for class 'loci'
summary(object, ...)
## S3 method for class 'summary.loci'
print(x, ...)
## S3 method for class 'loci'
x[i, j, drop = FALSE]
## S3 method for class 'summary.loci'
plot(x, loci, what = "both", layout = 1, col = c("blue", "red"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.loci_+3A_x">x</code>, <code id="summary.loci_+3A_object">object</code></td>
<td>
<p>an object of class <code>"loci"</code> or <code>"summary.loci"</code>.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_details">details</code></td>
<td>
<p>a logical value: if <code>TRUE</code> the data are printed as
a data frame; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_i">i</code>, <code id="summary.loci_+3A_j">j</code></td>
<td>
<p>indices of the rows and/or columns to select or to drop.
They may be numeric, logical, or character (in the same way than for
standard R objects).</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_drop">drop</code></td>
<td>
<p>a logical specifying whether to returned an object of
the smallest dimension possible, i.e., may return a vector or a
factor if <code>drop = TRUE</code> (this is not the default).</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_loci">loci</code></td>
<td>
<p>the loci (genes) to be plotted. By default, all loci are
plotted.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_what">what</code></td>
<td>
<p>the frequencies to be plotted. Three choices are possible:
<code>"alleles"</code>, <code>"genotypes"</code>, and <code>"both"</code> (the default),
or any unambiguous abbreviations.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_layout">layout</code></td>
<td>
<p>the number of graphs to be plotted simultaneously.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_col">col</code></td>
<td>
<p>the colours used for the barplots.</p>
</td></tr>
<tr><td><code id="summary.loci_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotypes not observed in the data frame are not counted.
</p>
<p>When using the <code>[</code> method, if only one column is extracted and 
the option <code>drop = TRUE</code>, or if the returned data frame has no &lsquo;locus&rsquo; 
column, then the class <code>"loci"</code> is dropped. The option <code>drop = FALSE</code> 
(default) keeps the class (see examples).
</p>
<p>An object of class <code>"loci"</code> can be edited in the R data editor
with, e.g., <code>fix(x)</code> or <code>x &lt;- edit(x)</code>.
</p>
<p><code>summary.loci</code> computes the absolute frequencies (counts); see
the examples on how to compute the relative frequencies (proportions).
</p>


<h3>Value</h3>

<p><code>summary.loci</code> returns a list with the genes as names and each
element made a list with two vectors <code>"genotype"</code> and
<code>"allele"</code> with the frequencies (numbers) of genotypes and
alleles, respectively. The names of these two vectors are the observed
genotypes and alleles.
</p>
<p><code>print</code> and <code>plot</code> methods return NULL.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="#topic+getAlleles">getAlleles</a></code>, <code><a href="#topic+edit.loci">edit.loci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
s &lt;- summary(jaguar)
## Not run: 
## works if the device is large enough:
plot(s, layout = 30, las = 2)
layout(1)

## End(Not run)
## compute the relative frequencies:
rapply(s, function(x) x/sum(x), how = "replace")
## extract a single locus:
jaguar[, 1]
jaguar[, 1, drop = TRUE] # returns a vector
jaguar[[1]]              # also returns a vector
</code></pre>

<hr>
<h2 id='sw'>Sliding Windows</h2><span id='topic+sw'></span><span id='topic+sw.default'></span><span id='topic+sw.DNAbin'></span><span id='topic+plot.sw'></span>

<h3>Description</h3>

<p>Applies a function over a matrix or a vector using sliding
windows. <code>sw</code> is a generic function with a method for
<code>"DNAbin"</code> matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sw(x, width, step, ...)
## Default S3 method:
sw(x, width = 100, step = 50, POS = NULL,
   FUN = mean, out.of.pos = NA_real_, na.rm = TRUE, L = NULL, ...)
## S3 method for class 'DNAbin'
sw(x, width = 100, step = 50, FUN = GC.content,
   rowAverage = FALSE, quiet = TRUE, ...)
## S3 method for class 'sw'
plot(x, type = "l", xlab = "Position", x.scaling = 1,
     show.ranges = FALSE, col.ranges = "blue",
     lty.ranges = 1, lwd.ranges = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sw_+3A_x">x</code></td>
<td>
<p>a vector or a matrix.</p>
</td></tr>
<tr><td><code id="sw_+3A_width">width</code></td>
<td>
<p>an integer giving the window width.</p>
</td></tr>
<tr><td><code id="sw_+3A_step">step</code></td>
<td>
<p>an integer giving the step separating successive windows.</p>
</td></tr>
<tr><td><code id="sw_+3A_pos">POS</code></td>
<td>
<p>a numeric vector giving the positions of the sites.</p>
</td></tr>
<tr><td><code id="sw_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to the windows.</p>
</td></tr>
<tr><td><code id="sw_+3A_rowaverage">rowAverage</code></td>
<td>
<p>a logical value: if <code>TRUE</code>, <code>FUN</code> is
applied over all rows of <code>x</code>; if <code>FALSE</code> (the default)
<code>FUN</code> is applied to each row of <code>x</code>.</p>
</td></tr>
<tr><td><code id="sw_+3A_out.of.pos">out.of.pos</code></td>
<td>
<p>the values used for the sites which are not in
<code>POS</code>.</p>
</td></tr>
<tr><td><code id="sw_+3A_na.rm">na.rm</code></td>
<td>
<p>option passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sw_+3A_l">L</code></td>
<td>
<p>the length of the chromosome (or sequence). If not given,
this is largest value in <code>POS</code> or the length of <code>x</code> if
<code>POS</code> is not given.</p>
</td></tr>
<tr><td><code id="sw_+3A_quiet">quiet</code></td>
<td>
<p>a logical value: if <code>FALSE</code>, the progress of the
calculations is printed.</p>
</td></tr>
<tr><td><code id="sw_+3A_type">type</code></td>
<td>
<p>the type of plotting (see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>).</p>
</td></tr>
<tr><td><code id="sw_+3A_xlab">xlab</code></td>
<td>
<p>the label under the x-axis.</p>
</td></tr>
<tr><td><code id="sw_+3A_x.scaling">x.scaling</code></td>
<td>
<p>the scaling of the x-axis.</p>
</td></tr>
<tr><td><code id="sw_+3A_show.ranges">show.ranges</code></td>
<td>
<p>a logical value specifying whether to show the
ranges of the windows with horizontal segments (ignored with a
warning if <code>x</code> is a matrix).</p>
</td></tr>
<tr><td><code id="sw_+3A_col.ranges">col.ranges</code>, <code id="sw_+3A_lty.ranges">lty.ranges</code>, <code id="sw_+3A_lwd.ranges">lwd.ranges</code></td>
<td>
<p>arguments to modify the
appearance of the above segments (see <code><a href="graphics.html#topic+segments">segments</a></code>).</p>
</td></tr>
<tr><td><code id="sw_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> should return a single value.
</p>
<p><code>x</code> should be a matrix for the <code>"DNAbin"</code> method, or a
vector for the default one.
</p>
<p>For the default method, the vector <code>x</code> is expanded into a vector
of length <code>L</code> (see above on how this value is found) and the
positions which are not in <code>POS</code> are filled with the value given
in <code>out.of.pos</code>. The resulting vector is then analysed with the
function <code>FUN</code> which must have an option <code>na.rm</code>. If the
function you want to use does not have this option, you can use
something like <code>FUN = function(x, na.rm = TRUE)
  foo(x[!is.na(x)])</code>, replacing &lsquo;foo&rsquo; by the name of your function. You
may also include more control on the handling of missing data.
</p>


<h3>Value</h3>

<p>a matrix or a vector (if <code>rowAverage = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
sw(woodmouse)
sw(woodmouse, 200, 200)
sw(woodmouse, 200, 200, rowAverage = TRUE)

## to get the proportions of G:
foo &lt;- function(x) base.freq(x)["g"]
sw(woodmouse, 200, 200, FUN = foo, rowAverage = TRUE)

## a simulated example with the default method:
x &lt;- runif(100)
pos &lt;- sort(sample(1e6, 100))
resx &lt;- sw(x, w = 2e4, s = 5e3, POS = pos, L = 1e6)
plot(resx, show.ranges = TRUE, x.scaling = 1e6, xlab = "Position (Mb)")
</code></pre>

<hr>
<h2 id='tajima.test'>Test of the Neutral Mutation Hypothesis</h2><span id='topic+tajima.test'></span>

<h3>Description</h3>

<p>This function tests the neutral mutation hypothesis with Tajima's
<em>D</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tajima.test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tajima.test_+3A_x">x</code></td>
<td>
<p>a set of DNA sequences (object of class <code>"DNAbin"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three numeric values:
</p>
<table role = "presentation">
<tr><td><code>D</code></td>
<td>
<p>Tajima's <em>D</em> statistic.</p>
</td></tr>
<tr><td><code>Pval.normal</code></td>
<td>
<p>the p-value assuming that <em>D</em> follows a normal
distribution with mean zero and variance one.</p>
</td></tr>
<tr><td><code>Pval.beta</code></td>
<td>
<p>the p-value assuming that <em>D</em> follows a beta
distribution after rescaling on [0, 1] (Tajima, 1989).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Alignment gaps in the sequences are ignored when calculating pairwise
distances.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Tajima, F. (1989) Statistical method for testing the neutral mutation
hypothesis by DNA polymorphism. <em>Genetics</em>, <b>123</b>, 595&ndash;595.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)
data(woodmouse)
tajima.test(woodmouse)
</code></pre>

<hr>
<h2 id='theta.h'>Population Parameter THETA using Homozygosity</h2><span id='topic+theta.h'></span>

<h3>Description</h3>

<p>This function computes the population parameter THETA using the
homozygosity (or mean heterozygosity) from gene frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.h(x, standard.error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta.h_+3A_x">x</code></td>
<td>
<p>a vector or a factor.</p>
</td></tr>
<tr><td><code id="theta.h_+3A_standard.error">standard.error</code></td>
<td>
<p>a logical indicating whether the standard error
of the estimated theta should be returned (<code>TRUE</code>), the default
being <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> can be either a factor or a vector. If it is a
factor, then it is taken to give the individual alleles in the
population. If it is a numeric vector, then its values are taken to be
the numbers of each allele in the population. If it is a non-numeric
vector, it is a coerced as a factor.
</p>
<p>The standard error is computed with an approximation due to
Chakraborty and Weiss (1991).
</p>


<h3>Value</h3>

<p>A numeric vector of length one with the estimated theta (the default),
or of length two if the standard error is returned
(<code>standard.error = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Zouros, E. (1979) Mutation rates, population sizes and amounts of
electrophoretic variation at enzyme loci in natural
populations. <em>Genetics</em>, <b>92</b>, 623&ndash;646.
</p>
<p>Chakraborty, R. and Weiss, K. M. (1991) Genetic variation of the
mitochondrial DNA genome in American Indians is at mutation-drift
equilibrium. <em>American Journal of Physical Anthropology</em>,
<b>86</b>, 497&ndash;506.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heterozygosity">heterozygosity</a></code>, <code><a href="#topic+theta.s">theta.s</a></code>,
<code><a href="#topic+theta.k">theta.k</a></code>, <code><a href="#topic+theta.tree">theta.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
## compute frequencies:
S &lt;- summary(jaguar)
## compute THETA for all loci:
sapply(S, function(x) theta.h(x$allele))
</code></pre>

<hr>
<h2 id='theta.k'>Population Parameter THETA using Expected Number of Alleles</h2><span id='topic+theta.k'></span>

<h3>Description</h3>

<p>This function computes the population parameter THETA using the
expected number of alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.k(x, n = NULL, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta.k_+3A_x">x</code></td>
<td>
<p>a vector or a factor.</p>
</td></tr>
<tr><td><code id="theta.k_+3A_n">n</code></td>
<td>
<p>a numeric giving the sample size.</p>
</td></tr>
<tr><td><code id="theta.k_+3A_k">k</code></td>
<td>
<p>a numeric giving the number of alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in two ways: either with a vector giving the
individual genotypes from which the sample size and number of alleles
are derived (e.g., <code>theta.k(x)</code>), or giving directly these two
quantities (e.g., <code>theta.k(n = 50, k = 5)</code>).
</p>
<p>The argument <code>x</code> can be either a factor or a vector. If it is a
factor, then it is taken to give the individual alleles in the
population. If it is a numeric vector, then its values are taken to be
the numbers of each allele in the population. If it is a non-numeric
vector, it is a coerced as a factor.
</p>
<p>Both arguments <code>n</code> and <code>k</code> must be single numeric values.
</p>


<h3>Value</h3>

<p>A numeric vector of length one with the estimated theta.
</p>


<h3>Note</h3>

<p>For the moment, no standard-error or confidence interval is computed.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Ewens, W. J. (1972) The sampling theory of selectively neutral
alleles. <em>Theoretical Population Biology</em>, <b>3</b>, 87&ndash;112.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.h">theta.h</a></code>, <code><a href="#topic+theta.s">theta.s</a></code>, <code><a href="#topic+theta.tree">theta.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
## compute frequencies:
S &lt;- summary(jaguar)
## compute THETA for all loci:
sapply(S, function(x) theta.k(x$allele))
</code></pre>

<hr>
<h2 id='theta.msat'>
Population Parameter THETA From Micro-Satellites
</h2><span id='topic+theta.msat'></span>

<h3>Description</h3>

<p>This function estimates the population parameter <code class="reqn">\theta</code>
using micro-satellite data with three different estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.msat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta.msat_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three estimators are based on (i) the variance of the number of
repeats, (ii) the expected homozygosity (both described in Kimmel et
al., 1998), and (iii) the mean allele frequencies (Haasl and Payseur,
2010).
</p>
<p>The data must be micro-satellites, so the allele names must be the
allele sizes (see the example). If the data are expressed in repeat
counts, then only the first estimator is affected.
</p>


<h3>Value</h3>

<p>a numeric matrix with loci as rows and the three estimates of
<code class="reqn">\theta</code> as columns.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Kimmel, M., Chakraborty, R., King, J. P., Bamshad, M., Watkins,
W. S. and Jorde, L. B. (1998) Signatures of population expansion in
microsatellite repeat data. <em>Genetics</em>, <b>148</b>, 1921&ndash;1930.
</p>
<p>Haasl, R. J. and Payseur, B. A. (2010) The number of alleles at a
microsatellite defines the allele frequency spectrum and facilitates
fast accurate estimation of <code class="reqn">\theta</code>. <em>Molecular
Biology and Evolution</em>, <b>27</b>, 2702&ndash;2715.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.h">theta.h</a></code>, <code><a href="#topic+theta.tree">theta.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
theta.msat(jaguar)
</code></pre>

<hr>
<h2 id='theta.s'>Population Parameter THETA using Segregating Sites</h2><span id='topic+theta.s'></span><span id='topic+theta.s.DNAbin'></span><span id='topic+theta.s.default'></span>

<h3>Description</h3>

<p>This function computes the population parameter THETA using the
number of segregating sites <code class="reqn">s</code> in a sample of <code class="reqn">n</code> DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.s(x, ...)
## S3 method for class 'DNAbin'
theta.s(x, variance = FALSE, ...)
## Default S3 method:
theta.s(x, n, variance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta.s_+3A_x">x</code></td>
<td>
<p>a numeric giving the number of segregating sites.</p>
</td></tr>
<tr><td><code id="theta.s_+3A_n">n</code></td>
<td>
<p>a numeric giving the number of sequences.</p>
</td></tr>
<tr><td><code id="theta.s_+3A_variance">variance</code></td>
<td>
<p>a logical indicating whether the variance of the
estimated THETA should be returned (<code>TRUE</code>), the default being
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="theta.s_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length one with the estimated theta (the default),
or of length two if the standard error is returned
(<code>variance = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Watterson, G. A. (1975) On the number of segragating sites in genetical
models without recombination. <em>Theoretical Population Biology</em>,
<b>7</b>, 256&ndash;276.
</p>
<p>Tajima, F. (1989) Statistical method for testing the neutral mutation
hypothesis by DNA polymorphism. <em>Genetics</em>, <b>123</b>, 585&ndash;595.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.h">theta.h</a></code>, <code><a href="#topic+theta.k">theta.k</a></code>,
<code><a href="ape.html#topic+seg.sites">seg.sites</a></code>, <code><a href="#topic+nuc.div">nuc.div</a></code>, <code><a href="#topic+theta.tree">theta.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
theta.s(woodmouse)
theta.s(woodmouse, variance = TRUE)
## using the default:
s &lt;- length(seg.sites(woodmouse))
n &lt;- nrow(woodmouse)
theta.s(s, n)
</code></pre>

<hr>
<h2 id='theta.tree'>
Population Parameter THETA Using Genealogy
</h2><span id='topic+theta.tree'></span><span id='topic+theta.tree.hetero'></span>

<h3>Description</h3>

<p>These functions estimate the population parameter <code class="reqn">\Theta</code>
from a genealogy (coded a as phylogenetic tree) under the coalescent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.tree(phy, theta, fixed = FALSE, analytical = TRUE, log = TRUE)
theta.tree.hetero(phy, theta, fixed = FALSE, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta.tree_+3A_phy">phy</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="theta.tree_+3A_theta">theta</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="theta.tree_+3A_fixed">fixed</code></td>
<td>
<p>a logical specifying whether to estimate <code>theta</code>
(the default), or to return the likelihoods for all values in
<code>theta</code>.</p>
</td></tr>
<tr><td><code id="theta.tree_+3A_analytical">analytical</code></td>
<td>
<p>a logical specifying whether to use analytical
formulae to estimate <code>theta</code> and its standard-error. If
<code>FALSE</code>, a numerical optimisation of the likelihood is
performed (this option is ignored if <code>fixed = TRUE</code>)</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="theta.tree_+3A_log">log</code></td>
<td>
<p>a logical specifying whether to return the likelihoods on a
log scale (the default); ignored if <code>fixed = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>theta.tree</code>, the tree <code>phy</code> is considered as a
genealogy with contemporaneous samples, and therefore should be
ultrametric. With <code>theta.tree.hetero</code>, the samples may be
heterochronous so <code>phy</code> can be non-ultrametric. If <code>phy</code> is
ultrametric, both functions return the same results.
</p>
<p>By default, <code class="reqn">\theta</code> is estimated by maximum likelihood and
the value given in <code>theta</code> is used as starting value for the
minimisation function (if several values are given as a vector the
first one is used). If <code>fixed = TRUE</code>, then the [log-]likelihood
values are returned corresponding to each value in <code>theta</code>.
</p>
<p>The present implementation does a numerical optimisation of the
log-likelihood function (with <code><a href="stats.html#topic+nlminb">nlminb</a></code>) with the
first partial derivative as gradient. It is possible to solve the
latter and have a direct analytical MLE of <code class="reqn">\theta</code> (and
its standard-error), but this does not seem to be faster.
</p>


<h3>Value</h3>

<p>If <code>fixed = FALSE</code>, a list with two elements:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>the maximum likelihood estimate of <code class="reqn">\Theta</code>;</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood at its maximum.</p>
</td></tr>
</table>
<p>If <code>fixed = TRUE</code>, a numeric vector with the [log-]likelihood
values.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Kingman, J. F. C. (1982) The coalescent. <em>Stochastic Processes
and their Applications</em>, <b>13</b>, 235&ndash;248.
</p>
<p>Kingman, J. F. C. (1982) On the genealogy of large
populations. <em>Journal of Applied Probability</em>, <b>19A</b>,
27&ndash;43.
</p>
<p>Wakeley, J. (2009) <em>Coalescent Theory: An Introduction.</em>
Greenwood Village, CO: Roberts and Company Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.h">theta.h</a></code>, <code><a href="#topic+theta.s">theta.s</a></code>, <code><a href="#topic+theta.k">theta.k</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr &lt;- rcoal(50)
(o &lt;- theta.tree(tr))
theta.tree(tr, 10, analytical = FALSE) # uses nlminb()
## profile log-likelihood:
THETA &lt;- seq(0.5, 2, 0.01)
logLikelihood &lt;- theta.tree(tr, THETA, fixed = TRUE)
plot(THETA, logLikelihood, type = "l")
xx &lt;- seq(o$theta - 1.96 * o$se, o$theta + 1.96 * o$se, 0.01)
yy &lt;- theta.tree(tr, xx, fixed = TRUE)
polygon(c(xx, rev(xx)), c(yy, rep(0, length(xx))),
        border = NA, col = "lightblue")
segments(o$theta, 0, o$theta, o$logLik, col = "blue")
abline(v = 1, lty = 3)
legend("topright", legend = expression("log-likelihood",
       "True " * theta, hat(theta) * " (MLE)", "95%\ conf. interv."),
       lty = c(1, 3, 1, 1), lwd = c(1, 1, 1, 15),
       col = c("black", "black", "blue", "lightblue"))
</code></pre>

<hr>
<h2 id='utilities'>Utily Functions for pegas</h2><span id='topic+getPloidy'></span><span id='topic+getAlleles'></span><span id='topic+getGenotypes'></span><span id='topic+expand.genotype'></span><span id='topic+proba.genotype'></span><span id='topic+is.snp'></span><span id='topic+is.snp.loci'></span><span id='topic+is.phased'></span><span id='topic+unphase'></span>

<h3>Description</h3>

<p>The first three functions extract information on loci,
<code>expand.genotype</code> creates a table of all possible genotypes given
a set of alleles, <code>proba.genotype</code> calculates expected
probabilities of genotypes under Hardy&ndash;Weinberg equilibrium,
<code>is.snp</code> tests whether a locus is a SNP, <code>is.phased</code> tests
whether a gentotype is phased, and <code>unphase</code> unphase phased
genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPloidy(x)
getAlleles(x)
getGenotypes(x)
expand.genotype(n, alleles = NULL, ploidy = 2, matrix = FALSE)
proba.genotype(alleles = c("1", "2"), p, ploidy = 2)
is.snp(x)
## S3 method for class 'loci'
is.snp(x)
is.phased(x)
unphase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utilities_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="utilities_+3A_n">n</code></td>
<td>
<p>an integer giving how many alleles to consider (ignored if
<code>alleles</code> is used).</p>
</td></tr>
<tr><td><code id="utilities_+3A_alleles">alleles</code></td>
<td>
<p>the allele names as a vector of mode character.</p>
</td></tr>
<tr><td><code id="utilities_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer giving the ploidy level (either 2 or 4 for
the moment).</p>
</td></tr>
<tr><td><code id="utilities_+3A_matrix">matrix</code></td>
<td>
<p>a logical specifying whether to return the genotypes in
a matrix or as a character vector.</p>
</td></tr>
<tr><td><code id="utilities_+3A_p">p</code></td>
<td>
<p>a vector of allele probabilities; if missing, equal
probabilities are assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expand.genotype</code> and <code>proba.genotype</code> accept any level of
ploidy and any number of alleles.
</p>
<p>For <code>is.snp</code>, a locus is defined as a SNP if it has two alleles
and their labels are made of a single character (e.g., A and T, or 1
and 2, but not A and AT).
</p>


<h3>Value</h3>

<p><code>getPloidy</code> returns the ploidy level of all genotypes as a matrix
of integers with rownames and colnames taken from <code>x</code>.
</p>
<p><code>getAlleles</code> and <code>getGenotypes</code> return the alleles and
genotypes, respectively, observed in all loci in an object of class
<code>"loci"</code> as a list.
</p>
<p><code>expand.genotype</code> returns a character vector (the default) or a
matrix where the rows are the genotypes and the columns are the
alleles. The matrix is numeric by default, or character if the
argument <code>alleles</code> is given.
</p>
<p><code>proba.genotype</code> returns a numeric vector with names set as the
genotypes.
</p>
<p><code>is.snp</code> returns a logical vector specifying whether each locus
is a SNP.
</p>
<p><code>is.phased</code> returns a matrix of the same size than the original
data specifying whether each genotype is phased or not.
</p>
<p><code>unphase</code> unphases the genotypes and eventually pools those that
become identical once unphased (e.g., A|T and T|A).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
X &lt;- jaguar[, 1:2]
getAlleles(X)
getGenotypes(X)
expand.genotype(2)
expand.genotype(2, LETTERS[1:3])
expand.genotype(3, ploidy = 4)
proba.genotype() # classical HWE with 2 alleles
## an octoploid with a six-allele locus (1287 possible genotypes):
length(p &lt;- proba.genotype(alleles = LETTERS[1:6], ploidy = 8))
max(p) # ~ 0.006
## back to the jaguar data:
s &lt;- summary(X)
## allele counts from the first locus:
p &lt;- s[[1]]$allele
## expected probabilities for the 136 possible genotypes...
proba.genotype(names(p), p/sum(p))
## ... to be compared with s[[1]]$genotype
</code></pre>

<hr>
<h2 id='VCFloci'>Information From VCF Files</h2><span id='topic+VCFloci'></span><span id='topic+VCFheader'></span><span id='topic+VCFlabels'></span><span id='topic+print.VCFinfo'></span><span id='topic+is.snp.VCFinfo'></span><span id='topic+rangePOS'></span><span id='topic+selectQUAL'></span><span id='topic+getINFO'></span>

<h3>Description</h3>

<p>These functions help to extract information from VCF files and to
select which loci to read with <code><a href="#topic+read.vcf">read.vcf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFloci(file, what = "all", chunk.size = 1e9, quiet = FALSE)
## S3 method for class 'VCFinfo'
print(x, ...)
VCFheader(file)
VCFlabels(file)
## S3 method for class 'VCFinfo'
is.snp(x)
rangePOS(x, from, to)
selectQUAL(x, threshold = 20)
getINFO(x, what = "DP", as.is = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFloci_+3A_file">file</code></td>
<td>
<p>file name of the VCF file.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_what">what</code></td>
<td>
<p>a character specifying the information to be extracted
(see details).</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_chunk.size">chunk.size</code></td>
<td>
<p>the size of data in bytes read at once.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_quiet">quiet</code></td>
<td>
<p>a logical: should the progress of the operation be printed?</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_x">x</code></td>
<td>
<p>an object of class <code>"VCFinfo"</code>.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_from">from</code>, <code id="VCFloci_+3A_to">to</code></td>
<td>
<p>integer values giving the range of position values.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_threshold">threshold</code></td>
<td>
<p>a numerical value indicating the minimum value of
quality for selecting loci.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_as.is">as.is</code></td>
<td>
<p>a logical. By default, <code>getINFO</code> tries to convert
its output as numeric: if too many NA's are produced, the output is
returned as character. Use <code>as.is = TRUE</code> to force the output
to be in character mode.</p>
</td></tr>
<tr><td><code id="VCFloci_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variant call format (VCF) is described in details in the
References. Roughly, a VCF file is made of two parts: the header and
the genotypes. The last line of the header gives the labels of the
genotypes: the first nine columns give information for each locus and
are (always) &quot;CHROM&quot;, &quot;POS&quot;, &quot;ID&quot;, &quot;REF&quot;, &quot;ALT&quot;, &quot;QUAL&quot;, &quot;FILTER&quot;,
&quot;INFO&quot;, and &quot;FORMAT&quot;. The subsequent columns give the labels
(identifiers) of the individuals; these may be missing if the file
records only the variants. Note that the data are arranged as the
transpose of the usual way: the individuals are as columns and the
loci are as rows.
</p>
<p><code>VCFloci</code> is the main function documented here: it reads the
information relative to each locus. The option <code>what</code> specifies
which column(s) to read. By default, all of them are read. If the user
is interested in only the locus positions, the option <code>what =
  "POS"</code> would be used.
</p>
<p>Since VCF files can be very big, the data are read in portions of
<code>chunk.size</code> bytes. The default (1 Gb) should be appropriate in
most situations. This value should not exceed 2e9.
</p>
<p><code>VCFheader</code> returns the header of the VCF file (excluding the
line of labels). <code>VCFlabels</code> returns the individual labels.
</p>
<p>The output of <code>VCFloci</code> is a data frame with as many rows as
there are loci in the VCF file and storing the requested
information. The other functions help to extract specific information
from this data frame: their outputs may then be used to select which
loci to read with <code><a href="#topic+read.vcf">read.vcf</a></code>.
</p>
<p><code>is.snp</code> tests whether each locus is a SNP (i.e., the reference
allele, REF, is a single charater and the alternative allele, ALT,
also). It returns a logical vector with as many values as there are
loci. Note that some VCF files have the information VT (variant type)
in the INFO column.
</p>
<p><code>rangePOS</code> and <code>selectQUAL</code> select some loci with respect to
values of position or quality. They return the indices (i.e., row
numbers) of the loci satisfying the conditions.
</p>
<p><code>getINFO</code> extracts a specific information from the INFO
column. By default, these are the total depths (DP) which can be
changed with the option <code>what</code>. The meaning of these information
should be described in the header of the VCF file.
</p>


<h3>Value</h3>

<p><code>VCFloci</code> returns an object of class <code>"VCFinfo"</code> which is a
data frame with a specific print method.
</p>
<p><code>VCFheader</code> returns a single character string which can be
printed nicely with <code>cat</code>.
</p>
<p><code>VCFlabels</code> returns a vector of mode character.
</p>
<p><code>is.snp</code> returns a vector of mode logical.
</p>
<p><code>rangePOS</code> and <code>selectQUAL</code> return a vector of mode
numeric.
</p>
<p><code>getINFO</code> returns a vector of mode character or numeric (see above).
</p>


<h3>Note</h3>

<p><code>VCFloci</code> is able to read either compressed (*.gz) or
uncompressed files.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p><a href="https://www.internationalgenome.org/wiki/Analysis/vcf4.0">https://www.internationalgenome.org/wiki/Analysis/vcf4.0</a>
</p>
<p><a href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.vcf">read.vcf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?read.vcf
</code></pre>

<hr>
<h2 id='write.loci'>Write Allelic Data Files</h2><span id='topic+write.loci'></span>

<h3>Description</h3>

<p>This function writes allelic data into a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.loci(x, file = "", loci.sep = " ", allele.sep = "/|", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.loci_+3A_x">x</code></td>
<td>
<p>an object of class <code>"loci"</code>.</p>
</td></tr>
<tr><td><code id="write.loci_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character,
or a quoted string. By default, the data are printed on the console.</p>
</td></tr>
<tr><td><code id="write.loci_+3A_loci.sep">loci.sep</code></td>
<td>
<p>the character(s) use to separate the loci (columns) in
the file (a space by default).</p>
</td></tr>
<tr><td><code id="write.loci_+3A_allele.sep">allele.sep</code></td>
<td>
<p>the character(s) used to separate the alleles for
each locus in the file (a slash by default).</p>
</td></tr>
<tr><td><code id="write.loci_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>write.table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.loci">read.loci</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code> for all its options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jaguar)
x &lt;- jaguar[1:10, 1:3] # take a small subset
write.loci(x)
## use of '...':
write.loci(x, loci.sep = "\t", quote = FALSE, col.names = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
