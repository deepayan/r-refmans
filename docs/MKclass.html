<!DOCTYPE html><html><head><title>Help for package MKclass</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MKclass}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUC'><p> Compute AUC</p></a></li>
<li><a href='#AUC.test'>
<p>AUC-Test</p></a></li>
<li><a href='#confMatrix'><p> Compute Confusion Matrix</p></a></li>
<li><a href='#decisionStump'><p> Compute Decision Stumps</p></a></li>
<li><a href='#HLgof.test'>
<p>Hosmer-Lemeshow goodness of fit tests.</p></a></li>
<li><a href='#MKclass-package'>
<p>Statistical Classification.</p></a></li>
<li><a href='#optCutoff'><p> Compute the Optimal Cutoff for Binary Classification</p></a></li>
<li><a href='#or2rr'><p> Transform OR to RR</p></a></li>
<li><a href='#pairwise.auc'><p> Compute pairwise AUCs</p></a></li>
<li><a href='#perfMeasures'><p> Compute Performance Measures or Binary Classification</p></a></li>
<li><a href='#perfScores'><p> Compute Performance Scores for Binary Classification</p></a></li>
<li><a href='#predValues'><p> Compute PPV and NPV.</p></a></li>
<li><a href='#risks'><p> Compute RR, OR and Other Risk Measures</p></a></li>
<li><a href='#rrCI'><p> Compute Approximate Confidence Interval for RR.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Classification</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, foreach, parallel, doParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Performance measures and scores for statistical classification such as accuracy, sensitivity, specificity, recall, similarity coefficients, AUC, GINI index, Brier score and many more. Calculation of optimal cut-offs and decision stumps (Iba and Langley (1991), &lt;<a href="https://doi.org/10.1016%2FB978-1-55860-247-2.50035-8">doi:10.1016/B978-1-55860-247-2.50035-8</a>&gt;) for all implemented performance measures. Hosmer-Lemeshow goodness of fit tests (Lemeshow and Hosmer (1982), &lt;<a href="https://doi.org/10.1093%2Foxfordjournals.aje.a113284">doi:10.1093/oxfordjournals.aje.a113284</a>&gt;; Hosmer et al (1997), &lt;<a href="https://doi.org/10.1002/(SICI)1097-0258(19970515)16:9%3C965::AID-SIM509%3E3.0.CO;2-O">doi:10.1002/(SICI)1097-0258(19970515)16:9%3C965::AID-SIM509%3E3.0.CO;2-O</a>&gt;). Statistical and epidemiological risk measures such as relative risk, odds ratio, number needed to treat (Porta (2014), &lt;<a href="https://doi.org/10.1093%2Facref%2F9780199976720.001.0001">doi:10.1093%2Facref%2F9780199976720.001.0001</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stamats/MKclass">https://github.com/stamats/MKclass</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-17 17:43:08 UTC; kohlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-17 22:50:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUC'> Compute AUC </h2><span id='topic+AUC'></span>

<h3>Description</h3>

<p>The function computes AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(x, y, group, switchAUC = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="AUC_+3A_y">y</code></td>
<td>
<p> numeric vector. If missing, <code>group</code> has to be specified.</p>
</td></tr>
<tr><td><code id="AUC_+3A_group">group</code></td>
<td>
<p> grouping vector or factor. </p>
</td></tr>
<tr><td><code id="AUC_+3A_switchauc">switchAUC</code></td>
<td>
<p>logical value. Switch AUC; see Details section.</p>
</td></tr>
<tr><td><code id="AUC_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value, remove <code>NA</code> before computation of AUC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the area under the receiver operating 
characteristic curve (AUC under ROC curve). 
</p>
<p>If <code>AUC &lt; 0.5</code>, a warning is printed and <code>1-AUC</code> is returned. This 
behaviour can be suppressed by using <code>switchAUC = FALSE</code>
</p>
<p>The implementation uses the connection of AUC to the Wilcoxon rank sum test;
see Hanley and McNeil (1982).
</p>


<h3>Value</h3>

<p>AUC value.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>J. A. Hanley and B. J. McNeil (1982). The meaning and use of the area under a receiver
operating characteristic (ROC) curve. <em>Radiology</em>, <b>143</b>, 29-36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100) ## assumed as log2-data
g &lt;- sample(1:2, 100, replace = TRUE)
AUC(x, group = g)
## avoid switching AUC
AUC(x, group = g, switchAUC = FALSE)
</code></pre>

<hr>
<h2 id='AUC.test'>
AUC-Test
</h2><span id='topic+AUC.test'></span>

<h3>Description</h3>

<p>Performs tests for one and two AUCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC.test(pred1, lab1, pred2, lab2, conf.level = 0.95, paired = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC.test_+3A_pred1">pred1</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="AUC.test_+3A_lab1">lab1</code></td>
<td>
<p> grouping vector or factor for <code>pred1</code>. </p>
</td></tr>
<tr><td><code id="AUC.test_+3A_pred2">pred2</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="AUC.test_+3A_lab2">lab2</code></td>
<td>
<p>grouping vector or factor for <code>pred2</code>. </p>
</td></tr>
<tr><td><code id="AUC.test_+3A_conf.level">conf.level</code></td>
<td>
<p> confidence level of the interval. </p>
</td></tr>
<tr><td><code id="AUC.test_+3A_paired">paired</code></td>
<td>
<p> not yet implemented. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pred2</code> and <code>lab2</code> are missing, the AUC for <code>pred1</code>
and <code>lab1</code> is tested using the Wilcoxon signed rank test;
see <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.
</p>
<p>If <code>pred1</code> and <code>lab1</code> as well as <code>pred2</code> and <code>lab2</code>
are specified, the Hanley and McNeil test (cf. Hanley and McNeil (1982)) 
is computed.
</p>


<h3>Value</h3>

<p>A list with AUC, SE and confidence interval as well as the corresponding
test result.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>J. A. Hanley and B. J. McNeil (1982). The meaning and use of the area under a receiver
operating characteristic (ROC) curve. <em>Radiology</em>, <b>143</b>, 29-36.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="#topic+AUC">AUC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100) ## assumed as log2-data
g &lt;- sample(1:2, 100, replace = TRUE)
AUC.test(x, g)
y &lt;- rnorm(100) ## assumed as log2-data
h &lt;- sample(1:2, 100, replace = TRUE)
AUC.test(x, g, y, h)
</code></pre>

<hr>
<h2 id='confMatrix'> Compute Confusion Matrix </h2><span id='topic+confMatrix'></span>

<h3>Description</h3>

<p>The function computes the confusion matrix of a binary classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confMatrix(pred, pred.group, truth, namePos, cutoff = 0.5, relative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confMatrix_+3A_pred">pred</code></td>
<td>
<p> numeric values that shall be used for classification; e.g. probabilities
to belong to the positive group. </p>
</td></tr>
<tr><td><code id="confMatrix_+3A_pred.group">pred.group</code></td>
<td>
<p> vector or factor including the predicted group. If missing,
<code>pred.group</code> is computed from <code>pred</code>, where <code>pred &gt;= cutoff</code> is
classified as positive.</p>
</td></tr>
<tr><td><code id="confMatrix_+3A_truth">truth</code></td>
<td>
<p> true grouping vector or factor. </p>
</td></tr>
<tr><td><code id="confMatrix_+3A_namepos">namePos</code></td>
<td>
<p> value representing the positive group.</p>
</td></tr>
<tr><td><code id="confMatrix_+3A_cutoff">cutoff</code></td>
<td>
<p> cutoff value used for classification.</p>
</td></tr>
<tr><td><code id="confMatrix_+3A_relative">relative</code></td>
<td>
<p> logical: absolute and relative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the confusion matrix of a binary classification
consisting of the number of true positive (TP), false negative (FN),
false positive (FP) and true negative (TN) predictions.
</p>
<p>In addition, their relative counterparts true positive rate (TPR), false 
negative rate (FNR), false positive rate (FPR) and true negative rate (TNR) 
can be computed.
</p>


<h3>Value</h3>

<p><code>matrix</code> or <code>list</code> of matrices with respective numbers of true 
and false predictions.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Wikipedia contributors. (2019, July 18). Confusion matrix. In Wikipedia, 
The Free Encyclopedia. Retrieved 06:00, August 21, 2019, from 
https://en.wikipedia.org/w/index.php?title=Confusion_matrix&amp;oldid=906886050
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from dataset infert
fit &lt;- glm(case ~ spontaneous+induced, data = infert, family = binomial())
pred &lt;- predict(fit, type = "response")

## with group numbers
confMatrix(pred, truth = infert$case, namePos = 1)

## with group names
my.case &lt;- factor(infert$case, labels = c("control", "case"))
confMatrix(pred, truth = my.case, namePos = "case")

## on the scale of the linear predictors
pred2 &lt;- predict(fit)
confMatrix(pred2, truth = infert$case, namePos = 1, cutoff = 0)

## only absolute numbers
confMatrix(pred, truth = infert$case, namePos = 1, relative = FALSE)
</code></pre>

<hr>
<h2 id='decisionStump'> Compute Decision Stumps </h2><span id='topic+decisionStump'></span>

<h3>Description</h3>

<p>The function computes a decision stump for binary classification also known 
as 1-level decision tree or 1-rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decisionStump(pred, truth, namePos, perfMeasure = "YJS",
          MAX = TRUE, parallel = FALSE, ncores, delta = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decisionStump_+3A_pred">pred</code></td>
<td>
<p> numeric values that shall be used for classification; e.g. probabilities
to belong to the positive group. </p>
</td></tr>
<tr><td><code id="decisionStump_+3A_truth">truth</code></td>
<td>
<p> true grouping vector or factor. </p>
</td></tr>
<tr><td><code id="decisionStump_+3A_namepos">namePos</code></td>
<td>
<p> value representing the positive group; i.e., the name of the 
category where one expects higher values for <code>pred</code>.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_perfmeasure">perfMeasure</code></td>
<td>
<p> a single performance measure computed by function <code>perfMeasure</code>.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_max">MAX</code></td>
<td>
<p>logical value. Whether to maximize or minimize the performacne
measure.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_parallel">parallel</code></td>
<td>
<p> logical value. If <code>TRUE</code> packages foreach and doParallel
are used to parallelize the computations.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_ncores">ncores</code></td>
<td>
<p>integer value, number of cores that shall be used to parallelize
the computations.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_delta">delta</code></td>
<td>
<p>numeric value for setting up grid for optimization; start is 
minimum of <code>pred-delta</code>, end is maximum of <code>pred+delta</code>.</p>
</td></tr>
<tr><td><code id="decisionStump_+3A_...">...</code></td>
<td>
<p>further arguments passed to function <code>prefMeasures</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is able to compute a decision stump for various performance
measures, all performance measures that are implemented in function
<code>perfMeasures</code>. Of course, for several of them the computation is 
not really usefull such as sensitivity or specificity where one will get
trivial decision rules. 
</p>
<p>In addition, a decision stump will only give a meaningful result if there is
a monotone relationship between the two categories and the numeric values 
given in <code>pred</code>. In such a case the name of the category where one expects 
higher values should be given in <code>namePos</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>decisionStump</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>W. Iba and P. Langley (1992). Induction of One-Level Decision Trees. 
In: <em>Machine Learning Proceedings 1992</em>, pages 233-240.
URL: https://doi.org/10.1016/B978-1-55860-247-2.50035-8  
</p>
<p>R.C. Holte (1993). Very simple classification rules perform well on most 
commonly used datasets. In: <em>Machine Learning</em>, pages 63-91.
URL: https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.67.2711
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from dataset infert
fit &lt;- glm(case ~ spontaneous+induced, data = infert, family = binomial())
pred &lt;- predict(fit, type = "response")
res &lt;- decisionStump(pred, truth = infert$case, namePos = 1)
predict(res, newdata = seq(from = 0, to = 1, by = 0.1))
</code></pre>

<hr>
<h2 id='HLgof.test'>
Hosmer-Lemeshow goodness of fit tests.
</h2><span id='topic+HLgof.test'></span>

<h3>Description</h3>

<p>The function computes Hosmer-Lemeshow goodness of fit tests
for C and H statistic as well as the le Cessie-van Houwelingen-Copas-Hosmer 
unweighted sum of squares test for global goodness of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLgof.test(fit, obs, ngr = 10, X, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HLgof.test_+3A_fit">fit</code></td>
<td>
<p> numeric vector with fitted probabilities. </p>
</td></tr>
<tr><td><code id="HLgof.test_+3A_obs">obs</code></td>
<td>
<p> numeric vector with observed values. </p>
</td></tr>
<tr><td><code id="HLgof.test_+3A_ngr">ngr</code></td>
<td>
<p> number of groups for C and H statistic. </p>
</td></tr>
<tr><td><code id="HLgof.test_+3A_x">X</code></td>
<td>
<p> covariate(s) for le Cessie-van Houwelingen-Copas-Hosmer
global goodness of fit test. </p>
</td></tr>
<tr><td><code id="HLgof.test_+3A_verbose">verbose</code></td>
<td>
<p> logical, print intermediate results. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hosmer-Lemeshow goodness of fit tests are computed; see Lemeshow and Hosmer 
(1982).
</p>
<p>If <code>X</code> is specified, the le Cessie-van Houwelingen-Copas-Hosmer 
unweighted sum of squares test for global goodness of fit is additionally 
determined; see Hosmer et al. (1997).
A more general version of this test is implemented in function 
<code><a href="rms.html#topic+residuals.lrm">residuals.lrm</a></code> in package <span class="pkg">rms</span>.
</p>


<h3>Value</h3>

<p>A list of test results.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>S. Lemeshow and D.W. Hosmer (1982). A review of goodness of fit statistics
for use in the development of logistic regression models. 
<em>American Journal of Epidemiology</em>, <b>115</b>(1), 92-106.
</p>
<p>D.W. Hosmer, T. Hosmer, S. le Cessie, S. Lemeshow (1997). A comparison 
of goodness-of-fit tests for the logistic regression model. 
<em>Statistics in Medicine</em>, <b>16</b>, 965-980.
</p>


<h3>See Also</h3>

 <p><code><a href="rms.html#topic+residuals.lrm">residuals.lrm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
x1 &lt;- factor(sample(1:3, 50, replace = TRUE))
x2 &lt;- rnorm(50)
obs &lt;- sample(c(0,1), 50, replace = TRUE)
fit &lt;- glm(obs ~ x1+x2, family = binomial)
HLgof.test(fit = fitted(fit), obs = obs)
HLgof.test(fit = fitted(fit), obs = obs, X = model.matrix(obs ~ x1+x2))
</code></pre>

<hr>
<h2 id='MKclass-package'>
Statistical Classification.
</h2><span id='topic+MKclass-package'></span><span id='topic+MKclass'></span>

<h3>Description</h3>

<p>Performance measures and scores for statistical classification such as accuracy, 
sensitivity, specificity, recall, similarity coefficients, AUC, GINI index, 
Brier score and many more. Calculation of optimal cut-offs and decision stumps 
(Iba and Langley (1991), &lt;doi:10.1016/B978-1-55860-247-2.50035-8&gt;) for all 
implemented performance measures. Hosmer-Lemeshow goodness of fit tests 
(Lemeshow and Hosmer (1982), &lt;doi:10.1093/oxfordjournals.aje.a113284&gt;; 
Hosmer et al (1997), &lt;doi:10.1002/(SICI)1097-0258(19970515)16:9%3C965::AID-SIM509%3E3.0.CO;2-O&gt;). 
Statistical and epidemiological risk measures such as relative risk, odds ratio, 
number needed to treat (Porta (2014), &lt;doi:10.1093%2Facref%2F9780199976720.001.0001&gt;).
</p>


<h3>Details</h3>

<p>library(MKclass)
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="https://www.stamats.de">https://www.stamats.de</a>
</p>
<p>Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>

<hr>
<h2 id='optCutoff'> Compute the Optimal Cutoff for Binary Classification </h2><span id='topic+optCutoff'></span>

<h3>Description</h3>

<p>The function computes the optimal cutoff for various performance weasures for
binary classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optCutoff(pred, truth, namePos, perfMeasure = "YJS",
          MAX = TRUE, parallel = FALSE, ncores, delta = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optCutoff_+3A_pred">pred</code></td>
<td>
<p> numeric values that shall be used for classification; e.g. probabilities
to belong to the positive group. </p>
</td></tr>
<tr><td><code id="optCutoff_+3A_truth">truth</code></td>
<td>
<p> true grouping vector or factor. </p>
</td></tr>
<tr><td><code id="optCutoff_+3A_namepos">namePos</code></td>
<td>
<p> value representing the positive group.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_perfmeasure">perfMeasure</code></td>
<td>
<p> a single performance measure computed by function <code>perfMeasure</code>.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_max">MAX</code></td>
<td>
<p>logical value. Whether to maximize or minimize the performacne
measure.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_parallel">parallel</code></td>
<td>
<p> logical value. If <code>TRUE</code> packages foreach and doParallel
are used to parallelize the computations.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_ncores">ncores</code></td>
<td>
<p>integer value, number of cores that shall be used to parallelize
the computations.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_delta">delta</code></td>
<td>
<p>numeric value for setting up grid for optimization; start is 
minimum of <code>pred-delta</code>, end is maximum of <code>pred+delta</code>.</p>
</td></tr>
<tr><td><code id="optCutoff_+3A_...">...</code></td>
<td>
<p>further arguments passed to function <code>prefMeasures</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is able to compute the optimal cutoff for various performance
measures, all performance measures that are implemented in function
<code>perfMeasures</code>. Of course, for several of them the computation is 
not really usefull such as sensitivity or specificity where one will get
trivial cutoffs. 
</p>


<h3>Value</h3>

<p>Optimal cutoff and value of the optimized performance measure based on a 
simple grid search.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from dataset infert
fit &lt;- glm(case ~ spontaneous+induced, data = infert, family = binomial())
pred &lt;- predict(fit, type = "response")
optCutoff(pred, truth = infert$case, namePos = 1)
</code></pre>

<hr>
<h2 id='or2rr'> Transform OR to RR </h2><span id='topic+or2rr'></span>

<h3>Description</h3>

<p>The function transforms a given odds-ratio (OR) to the respective
relative risk (RR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or2rr(or, p0, p1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or2rr_+3A_or">or</code></td>
<td>
<p> numeric vector: OR (odds-ratio). </p>
</td></tr>
<tr><td><code id="or2rr_+3A_p0">p0</code></td>
<td>
<p> numeric vector of length 1: incidence of the outcome of interest in the
nonexposed group.</p>
</td></tr>
<tr><td><code id="or2rr_+3A_p1">p1</code></td>
<td>
<p> numeric vector of length 1: incidence of the outcome of interest in the
exposed group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms a given odds-ratio (OR) to the respective
relative risk (RR). It can also be used to transform the limits
of confidence intervals.
</p>
<p>The formulas can be derived by combining the formulas for RR and OR; see
also Zhang and Yu (1998).
</p>


<h3>Value</h3>

<p>relative risk.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Zhang, J. and Yu, K. F. (1998). What's the relative risk? A method of correcting the odds ratio in cohort
studies of common outcomes. <em>JAMA</em>, <b>280</b>(19):1690-1691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We use data from Zhang and Yu (1998)

## OR to RR using OR and p0
or2rr(14.1, 0.05)

## compute p1
or2rr(14.1, 0.05)*0.05

## OR to RR using OR and p1
or2rr(14.1, p1 = 0.426)

## OR and 95% confidence interval
or2rr(c(14.1, 7.8, 27.5), 0.05)

## Logistic OR and 95% confidence interval
logisticOR &lt;- rbind(c(14.1, 7.8, 27.5),
                    c(8.7, 5.5, 14.3),
                    c(27.4, 17.2, 45.8),
                    c(4.5, 2.7, 7.8),
                    c(0.25, 0.17, 0.37),
                    c(0.09, 0.05, 0.14))
colnames(logisticOR) &lt;- c("OR", "2.5%", "97.5%")
rownames(logisticOR) &lt;- c("7.4", "4.2", "3.0", "2.0", "0.37", "0.14")
logisticOR

## p0
p0 &lt;- c(0.05, 0.12, 0.32, 0.27, 0.40, 0.40)

## Compute corrected RR
## helper function
or2rr.mat &lt;- function(or, p0){
  res &lt;- matrix(NA, nrow = nrow(or), ncol = ncol(or))
  for(i in seq_len(nrow(or)))
    res[i,] &lt;- or2rr(or[i,], p0[i])
  dimnames(res) &lt;- dimnames(or)
  res
}
RR &lt;- or2rr.mat(logisticOR, p0)
round(RR, 2)

## Results are not completely identical to Zhang and Yu (1998)
## what probably is caused by the fact that the logistic OR values
## provided in the table are rounded and are not exact values.
</code></pre>

<hr>
<h2 id='pairwise.auc'> Compute pairwise AUCs </h2><span id='topic+pairwise.auc'></span>

<h3>Description</h3>

<p>The function computes pairwise AUCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.auc(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.auc_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.auc_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise areas under the receiver operating 
characteristic curves (AUC under ROC curves) using function <code><a href="#topic+AUC">AUC</a></code>.
</p>
<p>The implementation is in certain aspects analogously to 
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>


<h3>Value</h3>

<p>Vector with pairwise AUCs.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+AUC">AUC</a></code>, <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100)
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.auc(x, g)
</code></pre>

<hr>
<h2 id='perfMeasures'> Compute Performance Measures or Binary Classification </h2><span id='topic+perfMeasures'></span><span id='topic+ACC'></span><span id='topic+PCC'></span><span id='topic+FC'></span><span id='topic+SMC'></span><span id='topic+RSI'></span><span id='topic+PMC'></span><span id='topic+ER'></span><span id='topic+FIC'></span><span id='topic+BACC'></span><span id='topic+BFG0'></span><span id='topic+BFG1'></span><span id='topic+BLR'></span><span id='topic+BPV'></span><span id='topic+CKC'></span><span id='topic+CRV'></span><span id='topic+CSI'></span><span id='topic+DFM'></span><span id='topic+DOR'></span><span id='topic+DP'></span><span id='topic+DPREV'></span><span id='topic+DPp'></span><span id='topic+DR'></span><span id='topic+DSC'></span><span id='topic+EACC'></span><span id='topic+EC'></span><span id='topic+F1S'></span><span id='topic+FBS'></span><span id='topic+FDR'></span><span id='topic+FNR'></span><span id='topic+FO'></span><span id='topic+FOR'></span><span id='topic+FPR'></span><span id='topic+HR'></span><span id='topic+INF'></span><span id='topic+INFQR'></span><span id='topic+JD'></span><span id='topic+JE2'></span><span id='topic+JSC'></span><span id='topic+MARK'></span><span id='topic+MCC'></span><span id='topic+MI2'></span><span id='topic+MR'></span><span id='topic+NIR'></span><span id='topic+NLR'></span><span id='topic+NPOSTO'></span><span id='topic+NPOSTP'></span><span id='topic+NPREO'></span><span id='topic+NPREP'></span><span id='topic+NPV'></span><span id='topic+NU'></span><span id='topic+PD'></span><span id='topic+PFA'></span><span id='topic+PHIC'></span><span id='topic+PLR'></span><span id='topic+POSTO'></span><span id='topic+POSTP'></span><span id='topic+PPP'></span><span id='topic+PPV'></span><span id='topic+PREC'></span><span id='topic+PREO'></span><span id='topic+PREP'></span><span id='topic+PREV'></span><span id='topic+PROF'></span><span id='topic+REC'></span><span id='topic+RED'></span><span id='topic+RPHI'></span><span id='topic+SEL'></span><span id='topic+SENS'></span><span id='topic+SPEC'></span><span id='topic+SU'></span><span id='topic+TNR'></span><span id='topic+TPR'></span><span id='topic+TS'></span><span id='topic+UC'></span><span id='topic+VI2'></span><span id='topic+WACC'></span><span id='topic+WLR'></span><span id='topic+WPV'></span><span id='topic+YJS'></span><span id='topic+FAR'></span>

<h3>Description</h3>

<p>The function computes various performance measures for binary classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perfMeasures(pred, pred.group, truth, namePos, cutoff = 0.5,
             weight = 0.5, wACC = weight, wLR = weight, 
             wPV = weight, beta = 1, measures = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perfMeasures_+3A_pred">pred</code></td>
<td>
<p> numeric values that shall be used for classification; e.g. probabilities
to belong to the positive group. </p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_pred.group">pred.group</code></td>
<td>
<p> vector or factor including the predicted group. If missing,
<code>pred.group</code> is computed from <code>pred</code>, where <code>pred &gt;= cutoff</code> is
classified as positive.</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_truth">truth</code></td>
<td>
<p> true grouping vector or factor. </p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_namepos">namePos</code></td>
<td>
<p> value representing the positive group.</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_cutoff">cutoff</code></td>
<td>
<p> cutoff value used for classification.</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_weight">weight</code></td>
<td>
<p> weight used for computing weighted values. Must be in [0,1].</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_wacc">wACC</code></td>
<td>
<p> weight used for computing the weighted accuracy, where sensitivity 
is multiplied by <code>wACC</code> and specificity by <code>1-wACC</code>. Must be in [0,1].</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_wlr">wLR</code></td>
<td>
<p> weight used for computing the weighted likelihood ratio, where PLR 
is multiplied by <code>wLR</code> and NLR by <code>1-wLR</code>. Must be in [0,1].</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_wpv">wPV</code></td>
<td>
<p> weight used for computing the weighted predictive value, where PPV 
is multiplied by <code>wPV</code> and NPV by <code>1-wPV</code>. Must be in [0,1].</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_beta">beta</code></td>
<td>
<p> beta coefficient used for computing the F beta score. Must be nonnegative.</p>
</td></tr>
<tr><td><code id="perfMeasures_+3A_measures">measures</code></td>
<td>
<p> character vector giving the measures that shall be computed;
see details. Default <code>"all"</code> computes all measures available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>perfMeasures</code> can be used to compute various performance 
measures. For computing specific measures, the abbreviation given in 
parentheses have to be specified in argument <code>measures</code>. Single measures
can also be computed by respective functions, where their names are identical
to the abbreviations given in the parentheses.
</p>
<p>The measures are:
accuracy (ACC), probability of correct classification (PCC), 
fraction correct (FC), simple matching coefficient (SMC), 
Rand (similarity) index (RSI), probability of misclassification (PMC), 
error rate (ER), fraction incorrect (FIC), 
sensitivity (SENS), recall (REC), true positive rate (TPR), 
probability of detection (PD), hit rate (HR), specificity (SPEC), 
true negative rate (TNR), selectivity (SEL), detection rate (DR), 
false positive rate (FPR), fall-out (FO), false alarm (rate) (FAR), 
probability of false alarm (PFA), false negative rate (FNR), 
miss rate (MR), false discovery rate (FDR), false omission rate (FOR), 
prevalence (PREV), (positive) pre-test probability (PREP), 
(positive) pre-test odds (PREO), detection prevalence (DPREV), 
negative pre-test probability (NPREP), negative pre-test odds (NPREO), 
no information rate (NIR), weighted accuracy (WACC), 
balanced accuracy (BACC), (bookmaker) informedness (INF), 
Youden's J statistic (YJS), deltap' (DPp), 
positive likelihood ratio (PLR), negative likelihood ratio (NLR), 
weighted likelihood ratio (WLR), balanced likelihood ratio (BLR), 
diagnostic odds ratio (DOR), positive predictive value (PPV), 
precision (PREC), (positive) post-test probability (POSTP), 
(positive) post-test odds (POSTO), Bayes factor G1 (BFG1), 
negative predictive value (NPV), negative post-test probability (NPOSTP), 
negative post-test odds (NPOSTO), Bayes factor G0 (BFG0), 
markedness (MARK), deltap (DP), weighted predictive value (WPV), 
balanced predictive value (BPV), F1 score (F1S), 
Dice similarity coefficient (DSC), F beta score (FBS), 
Jaccard similarity coefficient (JSC), threat score (TS), 
critical success index (CSI), Matthews' correlation coefficient (MCC), 
Pearson's correlation (r phi) (RPHI), Phi coefficient (PHIC), 
Cramer's V (CRV), proportion of positive predictions (PPP), 
expected accuracy (EACC), Cohen's kappa coefficient (CKC), 
mutual information in bits (MI2), joint entropy in bits (JE2), 
variation of information in bits (VI2), Jaccard distance (JD), 
information quality ratio (INFQR), uncertainty coefficient (UC), 
entropy coefficient (EC), proficiency (metric) (PROF), 
deficiency (metric) (DFM), redundancy (RED), 
symmetric uncertainty (SU), normalized uncertainty (NU)
</p>
<p>These performance measures have in common that they require a dichotomization
of the computed predictions (classification function). For measuring the performance 
without dichotomization one can apply function <code>perfScores</code>.
</p>
<p>The prevalence is the prevalence given by the data. This often is not identical
to the prevalence of the population. Hence, it might be better to compute
PPV and NPV (and derived measures) by applying function <code>predValues</code>,
where one can specify the assumed prevalence. This holds in general for all
measures that depend on the prevalence.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with names of the performance measures and their 
respective values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>K.H. Brodersen, C.S. Ong, K.E. Stephan, J.M. Buhmann (2010). The balanced
accuracy and its posterior distribution. In <em>Pattern Recognition</em> (ICPR),
20th International Conference on, 3121-3124 (IEEE, 2010).
</p>
<p>J.A. Cohen (1960). A coefficient of agreement for nominal scales.
<em>Educational and Psychological Measurement</em> <b>20</b>, 3746.
</p>
<p>T. Fawcett (2006). An introduction to ROC analysis.
<em>Pattern Recognition Letters</em> <b>27</b>, 861-874.
</p>
<p>T.A. Gerds, T. Cai, M. Schumacher (2008). The performance of risk prediction
models. <em>Biom J</em> <b>50</b>, 457-479.
</p>
<p>D. Hand, R. Till (2001). A simple generalisation of the area under the ROC
curve for multiple class classification problems.
<em>Machine Learning</em> <b>45</b>, 171-186.
</p>
<p>J. Hernandez-Orallo, P.A. Flach, C. Ferri (2012). A unified view of performance
metrics: Translating threshold choice into expected classification loss.
<em>J. Mach. Learn. Res.</em> <b>13</b>, 2813-2869.
</p>
<p>B.W. Matthews (1975). Comparison of the predicted and observed secondary
structure of t4 phage lysozyme. <em>Biochimica et Biophysica Acta</em> (BBA) -
Protein Structure <b>405</b>, 442-451.
</p>
<p>D.M. Powers (2011). Evaluation: From Precision, Recall and F-Factor to ROC,
Informedness, Markedness and Correlation. <em>Journal of Machine Learning
Technologies</em> <b>1</b>, 37-63.
</p>
<p>N.A. Smits (2010). A note on Youden's J and its cost ratio.
<em>BMC Medical Research Methodology</em> <b>10</b>, 89.
</p>
<p>B. Wallace, I. Dahabreh (2012). Class probability estimates are unreliable for
imbalanced data (and how to fix them). In <em>Data Mining</em> (ICDM), IEEE 12th
International Conference on, 695-04.
</p>
<p>J.W. Youden (1950). Index for rating diagnostic tests.
<em>Cancer</em> <b>3</b>, 32-35.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confMatrix">confMatrix</a></code>, <code><a href="#topic+predValues">predValues</a></code>, <code><a href="#topic+perfScores">perfScores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from dataset infert
fit &lt;- glm(case ~ spontaneous+induced, data = infert, family = binomial())
pred &lt;- predict(fit, type = "response")

## with group numbers
perfMeasures(pred, truth = infert$case, namePos = 1)

## with group names
my.case &lt;- factor(infert$case, labels = c("control", "case"))
perfMeasures(pred, truth = my.case, namePos = "case")

## on the scale of the linear predictors
pred2 &lt;- predict(fit)
perfMeasures(pred2, truth = infert$case, namePos = 1, cutoff = 0)

## using weights
perfMeasures(pred, truth = infert$case, namePos = 1, weight = 0.3)

## selecting a subset of measures
perfMeasures(pred, truth = infert$case, namePos = 1, 
             measures = c("SENS", "SPEC", "BACC", "YJS"))
</code></pre>

<hr>
<h2 id='perfScores'> Compute Performance Scores for Binary Classification </h2><span id='topic+perfScores'></span><span id='topic+BBS'></span><span id='topic+BS'></span><span id='topic+GINI'></span><span id='topic+NBS'></span><span id='topic+PBS'></span><span id='topic+WBS'></span><span id='topic+BSS'></span>

<h3>Description</h3>

<p>The function computes various performance scores for binary classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perfScores(pred, truth, namePos, wBS = 0.5, scores = "all", transform = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perfScores_+3A_pred">pred</code></td>
<td>
<p> numeric values that shall be used for classification; e.g. probabilities
to belong to the positive group. </p>
</td></tr>
<tr><td><code id="perfScores_+3A_truth">truth</code></td>
<td>
<p> true grouping vector or factor. </p>
</td></tr>
<tr><td><code id="perfScores_+3A_namepos">namePos</code></td>
<td>
<p> value representing the positive group.</p>
</td></tr>
<tr><td><code id="perfScores_+3A_wbs">wBS</code></td>
<td>
<p> weight used for computing the weighted Brier score (BS), where
postive BS is multiplied by <code>wBS</code> and negative BS by <code>1-wBS</code>. Must be in [0,1].</p>
</td></tr>
<tr><td><code id="perfScores_+3A_scores">scores</code></td>
<td>
<p> character vector giving the scores that shall be computed;
see details. Default <code>"all"</code> computes all scores available.</p>
</td></tr>
<tr><td><code id="perfScores_+3A_transform">transform</code></td>
<td>
<p> logical value indicating whether the values in <code>pred</code>
should be transformed to [0,1]; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>perfScores</code> can be used to compute various performance 
scores. For computing specific scores, the abbreviation given in 
parentheses have to be specified in argument <code>scores</code>. Single scores
can also be computed by respective functions, where their names are identical
to the abbreviations given in the parentheses.
</p>
<p>The available scores are:
area under the ROC curve (AUC), Gini index (GINI), Brier score (BS), 
positive Brier score (PBS), negative Brier score (NBS), 
weighted Brier score (WBS), balanced Brier score (BBS), 
Brier skill score (BSS).
</p>
<p>If the predictions (<code>pred</code>) are not in the interval [0,1], the various 
Brier scores are not valid. By setting argument <code>transform</code> to <code>TRUE</code>,
a simple logistic regression model is fit to the provided data and the 
predicted values are used for the computations.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with names of the scores and their respective values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>G.W. Brier (1950). Verification of forecasts expressed in terms of probability.
<em>Mon. Wea. Rev.</em> <b>78</b>, 1-3.
</p>
<p>T. Fawcett (2006). An introduction to ROC analysis.
<em>Pattern Recognition Letters</em> <b>27</b>, 861-874.
</p>
<p>T.A. Gerds, T. Cai, M. Schumacher (2008). The performance of risk prediction
models. <em>Biom J</em> <b>50</b>, 457-479.
</p>
<p>D. Hand, R. Till (2001). A simple generalisation of the area under the ROC
curve for multiple class classification problems.
<em>Machine Learning</em> <b>45</b>, 171-186.
</p>
<p>J. Hernandez-Orallo, P.A. Flach, C. Ferri (2011). Brier curves: a new cost-
based visualisation of classifier performance. In L. Getoor and T. Scheffer (eds.)
<em>Proceedings of the 28th International Conference on Machine Learning</em> (ICML-11),
585???592 (ACM, New York, NY, USA).
</p>
<p>J. Hernandez-Orallo, P.A. Flach, C. Ferri (2012). A unified view of performance
metrics: Translating threshold choice into expected classification loss.
<em>J. Mach. Learn. Res.</em> <b>13</b>, 2813-2869.
</p>
<p>B.W. Matthews (1975). Comparison of the predicted and observed secondary
structure of t4 phage lysozyme. <em>Biochimica et Biophysica Acta</em> (BBA) -
Protein Structure <b>405</b>, 442-451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perfMeasures">perfMeasures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from dataset infert
fit &lt;- glm(case ~ spontaneous+induced, data = infert, family = binomial())
pred &lt;- predict(fit, type = "response")

## with group numbers
perfScores(pred, truth = infert$case, namePos = 1)

## with group names
my.case &lt;- factor(infert$case, labels = c("control", "case"))
perfScores(pred, truth = my.case, namePos = "case")

## on the scale of the linear predictors
pred2 &lt;- predict(fit)
perfScores(pred2, truth = infert$case, namePos = 1)

## using weights
perfScores(pred, truth = infert$case, namePos = 1, wBS = 0.3)
</code></pre>

<hr>
<h2 id='predValues'> Compute PPV and NPV. </h2><span id='topic+predValues'></span>

<h3>Description</h3>

<p>The function computes the positive (PPV) and negative predictive value (NPV)
given sensitivity, specificity and prevalence (pre-test probability).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predValues(sens, spec, prev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predValues_+3A_sens">sens</code></td>
<td>
<p> numeric vector: sensitivities. </p>
</td></tr>
<tr><td><code id="predValues_+3A_spec">spec</code></td>
<td>
<p> numeric vector: specificities. </p>
</td></tr>
<tr><td><code id="predValues_+3A_prev">prev</code></td>
<td>
<p> numeric vector: prevalence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the positive (PPV) and negative predictive value (NPV)
given sensitivity, specificity and prevalence (pre-test probability).
</p>
<p>It's a simple application of the Bayes formula.
</p>
<p>One can also specify vectors of length larger than 1 for sensitivity and specificity.
</p>


<h3>Value</h3>

<p>Vector or matrix with PPV and NPV.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example: HIV test 
## 1. ELISA screening test (4th generation)
predValues(sens = 0.999, spec = 0.998, prev = 0.001)
## 2. Western-Plot confirmation test
predValues(sens = 0.998, spec = 0.999996, prev = 1/3)

## Example: connection between sensitivity, specificity and PPV
sens &lt;- seq(0.6, 0.99, by = 0.01)
spec &lt;- seq(0.6, 0.99, by = 0.01)
ppv &lt;- function(sens, spec, pre) predValues(sens, spec, pre)[,1]
res &lt;- outer(sens, spec, ppv, pre = 0.1)
image(sens, spec, res, col = terrain.colors(256), main = "PPV for prevalence = 10%",
      xlim = c(0.59, 1), ylim = c(0.59, 1))
contour(sens, spec, res, add = TRUE)
</code></pre>

<hr>
<h2 id='risks'> Compute RR, OR and Other Risk Measures </h2><span id='topic+risks'></span>

<h3>Description</h3>

<p>The function computes relative risk (RR), odds ration (OR), and several
other risk measures; see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risks(p0, p1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risks_+3A_p0">p0</code></td>
<td>
<p> numeric vector of length 1: incidence of the outcome of interest in
the nonexposed group.</p>
</td></tr>
<tr><td><code id="risks_+3A_p1">p1</code></td>
<td>
<p> numeric vector of length 1: incidence of the outcome of interest in
the exposed group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes relative risk (RR), odds-ratio (OR), relative risk
reduction (RRR) resp. relative risk increase (RRI), absolute risk reduction (ARR)
resp. absolute risk increase (ARI), number needed to treat (NNT) resp.
number needed to harm (NNH).
</p>


<h3>Value</h3>

<p>Vector including several risk measures.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Porta, M. (2014). A Dictionary of Epidemiology. Oxford University Press. 
Retrieved 3 Oct. 2020, from 
<a href="https://www.oxfordreference.com/view/10.1093/acref/9780199976720.001.0001/acref-9780199976720">https://www.oxfordreference.com/view/10.1093/acref/9780199976720.001.0001/acref-9780199976720</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See worked example in Wikipedia
risks(p0 = 0.4, p1 = 0.1)
risks(p0 = 0.4, p1 = 0.5)
</code></pre>

<hr>
<h2 id='rrCI'> Compute Approximate Confidence Interval for RR. </h2><span id='topic+rrCI'></span>

<h3>Description</h3>

<p>The function computes an approximate confidence interval for the
relative risk (RR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrCI(a, b, c, d, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrCI_+3A_a">a</code></td>
<td>
<p> integer: events in exposed group.</p>
</td></tr>
<tr><td><code id="rrCI_+3A_b">b</code></td>
<td>
<p> integer: non-events in exposed group.</p>
</td></tr>
<tr><td><code id="rrCI_+3A_c">c</code></td>
<td>
<p> integer: events in non-exposed group.</p>
</td></tr>
<tr><td><code id="rrCI_+3A_d">d</code></td>
<td>
<p> integer: non-events in non-exposed group.</p>
</td></tr>
<tr><td><code id="rrCI_+3A_conf.level">conf.level</code></td>
<td>
<p> numeric: confidence level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes an approximate confidence interval for the relative
risk (RR) based on the normal approximation; see Jewell (2004).
</p>


<h3>Value</h3>

<p>A list with class <code>"confint"</code> containing the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated relative risk. </p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p> a confidence interval for the relative risk. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Jewell, Nicholas P. (2004). Statistics for epidemiology. Chapman &amp; Hall/CRC.
</p>
<p>Relative risk. (2016, November 4). In Wikipedia, The Free Encyclopedia.
Retrieved 19:58, November 4, 2016,
from <a href="https://en.wikipedia.org/w/index.php?title=Relative_risk&amp;oldid=747857409">https://en.wikipedia.org/w/index.php?title=Relative_risk&amp;oldid=747857409</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See worked example in Wikipedia
rrCI(a = 15, b = 135, c = 100, d = 150)
rrCI(a = 75, b = 75, c = 100, d = 150)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
