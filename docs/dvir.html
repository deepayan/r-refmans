<!DOCTYPE html><html><head><title>Help for package dvir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dvir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amDrivenDVI'><p>AM driven DVI</p></a></li>
<li><a href='#Bmarginal'><p>Posterior pairing probabilities</p></a></li>
<li><a href='#combineSummaries'><p>Combine summary tables</p></a></li>
<li><a href='#directMatch'><p>Direct match LR</p></a></li>
<li><a href='#dviCompare'><p>Compare DVI approaches</p></a></li>
<li><a href='#dviData'><p>DVI data</p></a></li>
<li><a href='#dvir-package'><p>dvir: Disaster Victim Identification</p></a></li>
<li><a href='#dviSim'><p>Simulate genotypes in a DVI dataset</p></a></li>
<li><a href='#dviSolve'><p>A complete pipeline for solving a DVI case</p></a></li>
<li><a href='#example1'><p>DVI dataset: Generational trio</p></a></li>
<li><a href='#example2'><p>DVI dataset: Two reference families</p></a></li>
<li><a href='#excludePairing'><p>Exclude pairings</p></a></li>
<li><a href='#exclusionExample'><p>Dataset: Exclusion example</p></a></li>
<li><a href='#expand.grid.nodup'><p>Combinations without duplications</p></a></li>
<li><a href='#familias2dvir'><p>Convert a Familias file to DVI data</p></a></li>
<li><a href='#findExcluded'><p>Excluded individuals and pairings in a DVI dataset</p></a></li>
<li><a href='#findNonidentifiable'><p>Nonidentifiable missing persons</p></a></li>
<li><a href='#findUndisputed'><p>Undisputed identifications in a DVI problem</p></a></li>
<li><a href='#generatePairings'><p>Sex-consistent pairings</p></a></li>
<li><a href='#getFamily'><p>Get AM component of selected individuals</p></a></li>
<li><a href='#getSimpleFams'><p>Find the simple families of a DVI dataset</p></a></li>
<li><a href='#grave'><p>DVI dataset: Family grave</p></a></li>
<li><a href='#icmp'><p>DVI dataset: A large reference pedigree</p></a></li>
<li><a href='#jointDVI'><p>Joint DVI search</p></a></li>
<li><a href='#KETPch4'><p>Data used in the book Kling et al. (2021)</p></a></li>
<li><a href='#KETPex481'><p>Data used in the book Kling et al. (2021)</p></a></li>
<li><a href='#KETPex497'><p>Data used in the book Kling et al. (2021)</p></a></li>
<li><a href='#KETPex498'><p>Data used in the book Kling et al. (2021)</p></a></li>
<li><a href='#mergePM'><p>Identity and merge matching PM samples</p></a></li>
<li><a href='#ncomb'><p>The number of assignments for DVI problem</p></a></li>
<li><a href='#pairwiseLR'><p>Pairwise LR matrix</p></a></li>
<li><a href='#planecrash'><p>DVI dataset: Simulated plane crash</p></a></li>
<li><a href='#plotDVI'><p>Plot a DVI problem</p></a></li>
<li><a href='#plotSolution'><p>Plot DVI solution</p></a></li>
<li><a href='#plotUndisputed'><p>Plot undisputed identifications</p></a></li>
<li><a href='#relabelDVI'><p>Automatic labelling of a DVI dataset</p></a></li>
<li><a href='#sequentialDVI'><p>Sequential DVI search</p></a></li>
<li><a href='#setPairing'><p>Set identifications manually</p></a></li>
<li><a href='#subsetDVI'><p>Extract a subset of a DVI dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Disaster Victim Identification</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Joint DNA-based disaster victim identification (DVI), as
    described in Vigeland and Egeland (2021)
    &lt;<a href="https://doi.org/10.21203%2Frs.3.rs-296414%2Fv1">doi:10.21203/rs.3.rs-296414/v1</a>&gt;. Identification is performed by
    optimising the joint likelihood of all victim samples and reference
    individuals. Individual identification probabilities, conditional on
    all available information, are derived from the joint solution in the
    form of posterior pairing probabilities. 'dvir' is part of the
    'pedsuite' collection of packages for pedigree analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/dvir">https://github.com/magnusdv/dvir</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/magnusdv/dvir/issues">https://github.com/magnusdv/dvir/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>pedtools (&ge; 2.4.0), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>forrel (&ge; 1.5.2), pedprobr (&ge; 0.8.0), ribd</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-15 23:17:26 UTC; magnusdv</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Thore Egeland <a href="https://orcid.org/0000-0002-3465-8885"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-15 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amDrivenDVI'>AM driven DVI</h2><span id='topic+amDrivenDVI'></span>

<h3>Description</h3>

<p>AM-driven identification, i.e., considering one AM family at a time. Simple
families (exactly 1 missing) are handled directly from the LR matrix, while
nonsimple families are analysed with <code><a href="#topic+jointDVI">jointDVI()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amDrivenDVI(
  dvi,
  fams = NULL,
  threshold = 10000,
  threshold2 = max(1, threshold/10),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amDrivenDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="amDrivenDVI_+3A_fams">fams</code></td>
<td>
<p>A character; the names of families to consider. By default, all
families. Special keywords: &quot;simple&quot; (all families with exactly 1 missing)
and &quot;nonsimple&quot; (all families with &gt; 1 missing).</p>
</td></tr>
<tr><td><code id="amDrivenDVI_+3A_threshold">threshold</code></td>
<td>
<p>LR threshold for 'certain' match.</p>
</td></tr>
<tr><td><code id="amDrivenDVI_+3A_threshold2">threshold2</code></td>
<td>
<p>LR threshold for 'probable' match (in <em>simple</em> families).</p>
</td></tr>
<tr><td><code id="amDrivenDVI_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function assumes that undisputed identifications have been
removed. Strange outputs may occur otherwise.
</p>


<h3>Value</h3>

<p>A list of <code>dviReduced</code> and <code>summary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = amDrivenDVI(example2)
w$summary
w$dviReduced

# Bigger example: Undisputed first
u = findUndisputed(planecrash)
u$summary

# AM-driven analysis of the remaining
amDrivenDVI(u$dviReduced, threshold2 = 500)

</code></pre>

<hr>
<h2 id='Bmarginal'>Posterior pairing probabilities</h2><span id='topic+Bmarginal'></span>

<h3>Description</h3>

<p>Compute posterior pairing and non-pairing probabilities, based on a prior and
the output from <code><a href="#topic+jointDVI">jointDVI()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bmarginal(jointRes, missing, prior = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bmarginal_+3A_jointres">jointRes</code></td>
<td>
<p>Output from <code><a href="#topic+jointDVI">jointDVI()</a></code>.</p>
</td></tr>
<tr><td><code id="Bmarginal_+3A_missing">missing</code></td>
<td>
<p>Character vector with names of missing persons.</p>
</td></tr>
<tr><td><code id="Bmarginal_+3A_prior">prior</code></td>
<td>
<p>A numeric vector of length equal the number of rows in
<code>jointRes</code>. Default is a flat prior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior assigns a probability to each assignment, each row of <code>jointRes</code>.
If the prior is not specified, a flat prior is used. The prior needs not sum
to 1 since the user may rather choose a flat prior on the <em>a priori</em> possible
assignments.
</p>


<h3>Value</h3>

<p>A matrix. Row <code>i</code> gives the posterior probability that victim <code>i</code> is
one of the missing persons or someone else, denoted '*'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointDVI">jointDVI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jointRes = jointDVI(example1)

Bmarginal(jointRes, example1$missing)

# Artificial example: all but optimal solution excluded by prior
Bmarginal(jointRes, example1$missing, prior = c(1, rep(0,26)))


</code></pre>

<hr>
<h2 id='combineSummaries'>Combine summary tables</h2><span id='topic+combineSummaries'></span>

<h3>Description</h3>

<p>Combines summary tables from various functions into a final result table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineSummaries(dfs, orderBy = NULL, dvi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSummaries_+3A_dfs">dfs</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
<tr><td><code id="combineSummaries_+3A_orderby">orderBy</code></td>
<td>
<p>A character with column names to sort by.</p>
</td></tr>
<tr><td><code id="combineSummaries_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object used for sorting. Note that if given, this must
contain all victims and families.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u = findUndisputed(planecrash)
a = amDrivenDVI(u$dviReduced, threshold2 = 500)

u$summary
a$summary

combineSummaries(list(u$summary, a$summary),
                 orderBy = c("Family", "Missing"),
                 dvi = planecrash)
</code></pre>

<hr>
<h2 id='directMatch'>Direct match LR</h2><span id='topic+directMatch'></span>

<h3>Description</h3>

<p>Computes the likelihood ratio comparing if two samples are from the same
individual or from unrelated individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directMatch(x, y, geno1 = NULL, geno2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directMatch_+3A_x">x</code>, <code id="directMatch_+3A_y">y</code></td>
<td>
<p>Typed singletons.</p>
</td></tr>
<tr><td><code id="directMatch_+3A_geno1">geno1</code>, <code id="directMatch_+3A_geno2">geno2</code></td>
<td>
<p>(Optional) Named character vectors with genotypes for <code>x</code>
and <code>y</code> respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nonnegative likelihood ratio.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergePM">mergePM()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pm = singletons(c("V1", "V2", "V3")) |&gt; 
  addMarker(V1 = "1/1", V2 = "2/2", V3 = "1/1", 
            afreq = c("1" = 0.01, "2" = 0.99), name = "L1")

directMatch(pm[[1]], pm[[2]])
directMatch(pm[[1]], pm[[3]])

</code></pre>

<hr>
<h2 id='dviCompare'>Compare DVI approaches</h2><span id='topic+dviCompare'></span>

<h3>Description</h3>

<p>Compare the efficiency of different computational approaches to DVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dviCompare(
  dvi,
  true,
  refs = typedMembers(am),
  methods = 1:6,
  markers = NULL,
  threshold = 1,
  simulate = TRUE,
  db = getFreqDatabase(am),
  Nsim = 1,
  returnSims = FALSE,
  seed = NULL,
  numCores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dviCompare_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_true">true</code></td>
<td>
<p>A character of the same length as <code>dvi$pm</code>, with the true
solution, e.g., <code>true = c("M2", "M3", "*")</code> if the truth is V1 = M2, V2 =
M3 and V3 unmatched.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_refs">refs</code></td>
<td>
<p>Character vector with names of the reference individuals. By
default the typed members of <code>dvi$am</code>.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_methods">methods</code></td>
<td>
<p>A subset of the numbers 1,2,3,4,5,6.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_markers">markers</code></td>
<td>
<p>If <code>simulate = FALSE</code>: A vector indicating which markers
should be used.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_threshold">threshold</code></td>
<td>
<p>An LR threshold passed on to the sequential methods.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_simulate">simulate</code></td>
<td>
<p>A logical, indicating if simulations should be performed.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_db">db</code></td>
<td>
<p>A frequency database used for simulation, e.g.,
<code>forrel::NorwegianFrequencies</code>. By default the frequencies attached to
<code>dvi$am</code> are used.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_nsim">Nsim</code></td>
<td>
<p>A positive integer; the number of simulations.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_returnsims">returnSims</code></td>
<td>
<p>A logical: If TRUE, the simulated data are returned without
any DVI comparison.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_seed">seed</code></td>
<td>
<p>A seed for the random number generator, or NULL.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_numcores">numCores</code></td>
<td>
<p>The number of cores used in parallelisation. Default: 1.</p>
</td></tr>
<tr><td><code id="dviCompare_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods are available for comparison, through the <code>methods</code>
parameter:
</p>

<ol>
<li><p> Sequential, without LR updates
</p>
</li>
<li><p> Sequential, with LR updates
</p>
</li>
<li><p> Sequential (undisputed) + joint (remaining). Always return the most likely
solution(s).
</p>
</li>
<li><p> Joint - brute force. Always return the most likely solution(s).
</p>
</li>
<li><p> Like 3, but return winner(s) only if LR &gt; <code>threshold</code>; otherwise the empty
assignment.
</p>
</li>
<li><p> Like 4, but return winner(s) only if LR &gt; <code>threshold</code>; otherwise the empty
assignment.
</p>
</li></ol>



<h3>Value</h3>

<p>A list of solution frequencies for each method, and a vector of true
positive rates for each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
refs = "R1"
db = forrel::NorwegianFrequencies[1:3]

# True solution
true = c("M1", "M2", "M3")

# Run comparison

# dviCompare(example1, refs, true = true, db = db, Nsim = 2, seed = 123)


# Alternatively, simulations can be done first...
sims = dviCompare(example1, refs, true = true, simulate = TRUE,
                  db = db, Nsim = 2, seed = 123, returnSims = TRUE)

# ... and computations after:

# dviCompare(sims, refs, true = true, simulate = FALSE)


</code></pre>

<hr>
<h2 id='dviData'>DVI data</h2><span id='topic+dviData'></span><span id='topic+checkDVI'></span>

<h3>Description</h3>

<p>DVI data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dviData(pm, am, missing, generatePairings = TRUE)

checkDVI(
  dvi,
  pairings = NULL,
  errorIfEmpty = FALSE,
  ignoreSex = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dviData_+3A_pm">pm</code></td>
<td>
<p>A list of singletons: The victim samples.</p>
</td></tr>
<tr><td><code id="dviData_+3A_am">am</code></td>
<td>
<p>A list of pedigrees: The reference families.</p>
</td></tr>
<tr><td><code id="dviData_+3A_missing">missing</code></td>
<td>
<p>A character vector with names of missing persons.</p>
</td></tr>
<tr><td><code id="dviData_+3A_generatepairings">generatePairings</code></td>
<td>
<p>A logical. If TRUE (default) a list of sex-compatible
pairings is included as part of the output.</p>
</td></tr>
<tr><td><code id="dviData_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="dviData_+3A_pairings">pairings</code></td>
<td>
<p>A list of pairings.</p>
</td></tr>
<tr><td><code id="dviData_+3A_errorifempty">errorIfEmpty</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="dviData_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="dviData_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dviData</code>, which is basically a list of <code>pm</code>,
<code>am</code>, <code>missing</code> and <code>pairings</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dvi = dviData(pm = singleton("V1"), am = nuclearPed(1), missing = "3")
dvi

checkDVI(dvi)

</code></pre>

<hr>
<h2 id='dvir-package'>dvir: Disaster Victim Identification</h2><span id='topic+dvir'></span><span id='topic+dvir-package'></span>

<h3>Description</h3>

<p>Joint DNA-based disaster victim identification (DVI), as described in Vigeland and Egeland (2021) <a href="https://doi.org/10.21203/rs.3.rs-296414/v1">doi:10.21203/rs.3.rs-296414/v1</a>. Identification is performed by optimising the joint likelihood of all victim samples and reference individuals. Individual identification probabilities, conditional on all available information, are derived from the joint solution in the form of posterior pairing probabilities. 'dvir' is part of the 'pedsuite' collection of packages for pedigree analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Thore Egeland <a href="mailto:thore.egeland@nmbu.no">thore.egeland@nmbu.no</a> (<a href="https://orcid.org/0000-0002-3465-8885">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/dvir">https://github.com/magnusdv/dvir</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/magnusdv/dvir/issues">https://github.com/magnusdv/dvir/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dviSim'>Simulate genotypes in a DVI dataset</h2><span id='topic+dviSim'></span>

<h3>Description</h3>

<p>Simulates genotypes for the references and missing persons in each AM family,
transfers to the PM singletons according to the indicated matching. Remaining
victims are simulated as unrelated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dviSim(
  dvi,
  refs = typedMembers(dvi$am),
  truth = NULL,
  seed = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dviSim_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="dviSim_+3A_refs">refs</code></td>
<td>
<p>A character with names of all reference individuals. By default,
the typed members of the input.</p>
</td></tr>
<tr><td><code id="dviSim_+3A_truth">truth</code></td>
<td>
<p>A named vector of the format <code>c(vic1 = mis1, vic2 = mis2, ...)</code>.</p>
</td></tr>
<tr><td><code id="dviSim_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator.</p>
</td></tr>
<tr><td><code id="dviSim_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dviData</code> object similar to the input.
</p>


<h3>See Also</h3>

<p><code><a href="forrel.html#topic+profileSim">forrel::profileSim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex = dviSim(example2, truth = c(V1 = "M1", V2 = "M2"))
plotDVI(ex, marker = 1)

</code></pre>

<hr>
<h2 id='dviSolve'>A complete pipeline for solving a DVI case</h2><span id='topic+dviSolve'></span>

<h3>Description</h3>

<p>This wraps several other functions into a complete pipeline for solving a DVI
case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dviSolve(
  dvi,
  threshold = 10000,
  threshold2 = max(1, threshold/10),
  maxIncomp = 2,
  ignoreSex = FALSE,
  limit = 0,
  verbose = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dviSolve_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_threshold">threshold</code></td>
<td>
<p>LR threshold for 'significant' match.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_threshold2">threshold2</code></td>
<td>
<p>LR threshold for 'probable' match.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_maxincomp">maxIncomp</code></td>
<td>
<p>An integer passed onto <code><a href="#topic+findExcluded">findExcluded()</a></code>. A pairing is
excluded if the number of incompatible markers exceeds this.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical, by default FALSE.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_limit">limit</code></td>
<td>
<p>A number passed onto <code><a href="#topic+findUndisputed">findUndisputed()</a></code>; only pairwise LR values
above this are considered.</p>
</td></tr>
<tr><td><code id="dviSolve_+3A_verbose">verbose</code>, <code id="dviSolve_+3A_debug">debug</code></td>
<td>
<p>Logicals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dviSolve(example2)
dviSolve(example2, threshold = 5, verbose = FALSE)
</code></pre>

<hr>
<h2 id='example1'>DVI dataset: Generational trio</h2><span id='topic+example1'></span>

<h3>Description</h3>

<p>A proof-of-concept dataset involving three missing members (child, father,
grandfather) of a single family. With the given data, stepwise victim
identification fails to find the correct solution, while joint identification
succeeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example1
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 3 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A pedigree with three missing persons and one typed reference
individual.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>   
example1

plotDVI(example1, marker = 1)

jointDVI(example1)  

</code></pre>

<hr>
<h2 id='example2'>DVI dataset: Two reference families</h2><span id='topic+example2'></span>

<h3>Description</h3>

<p>A small DVI example with three victims, and three missing persons from two reference
families
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example2
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 3 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 2 pedigrees with three missing persons and one typed reference
individual.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>   
example2

plotDVI(example2, marker = 1, nrowPM = 3)

jointDVI(example2)

</code></pre>

<hr>
<h2 id='excludePairing'>Exclude pairings</h2><span id='topic+excludePairing'></span>

<h3>Description</h3>

<p>Disallow certain pairings by removing them from the list <code>dvi$pairings</code> of
candidate pairings for a given victim sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excludePairing(dvi, victim, missing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excludePairing_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="excludePairing_+3A_victim">victim</code></td>
<td>
<p>The name of a single victim sample.</p>
</td></tr>
<tr><td><code id="excludePairing_+3A_missing">missing</code></td>
<td>
<p>The name(s) of one or several missing individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dviData</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Disallow V1 = M1 in the `example2` dataset:
ex = excludePairing(example2, victim = "V1", missing = "M1")
jointDVI(ex, verbose = FALSE)

# Compare with original
jointDVI(example2, verbose = FALSE)

# The only difference is in the `pairings` slot:
ex$pairings
example2$pairings

</code></pre>

<hr>
<h2 id='exclusionExample'>Dataset: Exclusion example</h2><span id='topic+exclusionExample'></span>

<h3>Description</h3>

<p>This data is based on a real case, but pedigrees have been changed and
marker data simulated to preserve anonymity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclusionExample
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 16 singletons (male victims).
</p>
</li>
<li> <p><code>am</code>: A list of 15 pedigrees, each with one missing person
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the 15 missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
exclusionExample

</code></pre>

<hr>
<h2 id='expand.grid.nodup'>Combinations without duplications</h2><span id='topic+expand.grid.nodup'></span>

<h3>Description</h3>

<p>This is similar to <code><a href="base.html#topic+expand.grid">expand.grid()</a></code> except that combinations with repeated
elements are not included. The element &quot;*&quot; is treated separately, and is
allowed to be repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.grid.nodup(lst, max = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.grid.nodup_+3A_lst">lst</code></td>
<td>
<p>A list of vectors.</p>
</td></tr>
<tr><td><code id="expand.grid.nodup_+3A_max">max</code></td>
<td>
<p>A positive integer. If the number of combinations (according to a
preliminary lower bound) exceeds this, the function aborts with an
informative error message. Default: 1e5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lst = list(1, 1:2, 3:4)

# Compare
expand.grid.nodup(lst)
expand.grid(lst)

# Typical use case for DVI
lst2 = generatePairings(example1)
expand.grid.nodup(lst2)

</code></pre>

<hr>
<h2 id='familias2dvir'>Convert a Familias file to DVI data</h2><span id='topic+familias2dvir'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>readFam()</code> that reads Familias files with DVI
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>familias2dvir(
  famfile,
  victimPrefix = NULL,
  familyPrefix = NULL,
  refPrefix = NULL,
  missingPrefix = NULL,
  missingFormat = NULL,
  othersPrefix = NULL,
  verbose = FALSE,
  missingIdentifier = "^Missing"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="familias2dvir_+3A_famfile">famfile</code></td>
<td>
<p>Path to Familias file.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_victimprefix">victimPrefix</code></td>
<td>
<p>Prefix used to label PM individuals.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_familyprefix">familyPrefix</code></td>
<td>
<p>Prefix used to label the AM families.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_refprefix">refPrefix</code></td>
<td>
<p>Prefix used to label the reference individuals, i.e., the
typed members of the AM families.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_missingprefix">missingPrefix</code></td>
<td>
<p>Prefix used to label the missing persons. At most one of
<code>missingPrefix</code> and <code>missingFormat</code> can be given.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_missingformat">missingFormat</code></td>
<td>
<p>A string indicating family-wise labelling of missing
persons, using <code style="white-space: pre;">&#8288;[FAM]&#8288;</code>, <code style="white-space: pre;">&#8288;[IDX]&#8288;</code>, <code style="white-space: pre;">&#8288;[MIS]&#8288;</code> as place holders with the
following meanings (see Examples):
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;[FAM]&#8288;</code>: family index
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[IDX]&#8288;</code>: index of missing person within the family
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[MIS]&#8288;</code>: index within all missing persons
</p>
</li></ul>
</td></tr>
<tr><td><code id="familias2dvir_+3A_othersprefix">othersPrefix</code></td>
<td>
<p>Prefix used to label other untyped individuals. Use &quot;&quot;
for numeric labels ( 1, 2, ...).</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_verbose">verbose</code></td>
<td>
<p>A logical. Passed on to <code>readFam()</code>.</p>
</td></tr>
<tr><td><code id="familias2dvir_+3A_missingidentifier">missingIdentifier</code></td>
<td>
<p>A character of length 1 used to identify missing
persons in the Familias file. The default chooses everyone whose label
begins with &quot;Missing&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sex of the missing persons need to be checked as this
information may not be correctly recorded in the fam file.
</p>


<h3>Value</h3>

<p>A <code>dviData</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointDVI">jointDVI()</a></code>, <code><a href="#topic+dviData">dviData()</a></code>, <code><a href="#topic+relabelDVI">relabelDVI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Family with three missing
file = system.file("extdata", "dvi-example.fam", package="dvir")

# Read file without relabelling
y = familias2dvir(file)
plotDVI(y)

# With relabelling
z = familias2dvir(file, missingFormat = "M[FAM]-[IDX]",
                   refPrefix = "ref", othersPrefix = "E")
plotDVI(z)


</code></pre>

<hr>
<h2 id='findExcluded'>Excluded individuals and pairings in a DVI dataset</h2><span id='topic+findExcluded'></span><span id='topic+exclusionMatrix'></span>

<h3>Description</h3>

<p>Analysing exclusions is often an efficient way to reduce large DVI datasets.
A pairing V = M is <em>excluded</em> if it implies (too many) genetic
inconsistencies. The function <code>findExcluded()</code> identifies and removes (i)
victim samples with too many inconsistencies against all missing persons,
(ii) missing persons with too many inconsistencies against all victim
samples, and (iii) inconsistent pairings among the remaining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findExcluded(
  dvi,
  maxIncomp = 2,
  pairings = NULL,
  ignoreSex = FALSE,
  verbose = TRUE
)

exclusionMatrix(dvi, pairings = NULL, ignoreSex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findExcluded_+3A_dvi">dvi</code></td>
<td>
<p>A <code><a href="#topic+dviData">dviData()</a></code> object.</p>
</td></tr>
<tr><td><code id="findExcluded_+3A_maxincomp">maxIncomp</code></td>
<td>
<p>An integer. A pairing is excluded if the number of
incompatible markers exceeds this.</p>
</td></tr>
<tr><td><code id="findExcluded_+3A_pairings">pairings</code></td>
<td>
<p>A list of possible pairings for each victim. By default,
<code>dvi$pairings</code> is used, or, if this is NULL, <code>generatePairings(dvi, ignoreSex)</code>.</p>
</td></tr>
<tr><td><code id="findExcluded_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical, by default: FALSE.</p>
</td></tr>
<tr><td><code id="findExcluded_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main calculation in <code>findExcluded()</code> is done by <code>exclusionMatrix()</code>,
which records number of incompatible markers of each pairwise comparison.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>exclusionMatrix</code>: A matrix showing the number of inconsistencies for
each pair (or NA if the pairing was not considered)
</p>
</li>
<li> <p><code>excluded</code>: A list of three character vectors:
</p>

<ul>
<li> <p><code>sample</code>: victim samples excluded against all missing persons
</p>
</li>
<li> <p><code>missing</code>: missing persons excluded against all victims
</p>
</li>
<li> <p><code>fam</code>: families in which all missing members are excluded against
all victim samples
</p>
</li></ul>

</li>
<li> <p><code>dviReduced</code>: A reduced version of <code>dvi</code>, where the excluded elements
are removed, and the pairings are updated.
</p>
</li>
<li> <p><code>summary</code>: A list of data frames <code>PM</code> and <code>AM</code>, summarising the excluded
individuals.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+findUndisputed">findUndisputed()</a></code>. See also <code><a href="forrel.html#topic+findExclusions">forrel::findExclusions()</a></code> for analysis
of a specific pairwise comparison.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e = findExcluded(icmp)
e$summary
e$exclusionMatrix

# The exclusion matrix can also be computed directly:
exclusionMatrix(icmp)

# Inspect a particular pair: M4 vs V4
forrel::findExclusions(icmp$am, id = "M4", candidate = icmp$pm$V4)

# Plot one of the incompatible markers
plotDVI(icmp, pm = 4, marker ="D7S820")

</code></pre>

<hr>
<h2 id='findNonidentifiable'>Nonidentifiable missing persons</h2><span id='topic+findNonidentifiable'></span>

<h3>Description</h3>

<p>A missing person in a DVI case is <em>nonidentifiable</em> if unrelated to all
(genotyped) reference individuals and all other missing persons in the
reference family. It is often wise to ignore such individuals in <code><a href="#topic+jointDVI">jointDVI()</a></code>
and other analyses, to relieve the computational burden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNonidentifiable(dvi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNonidentifiable_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation uses <code>ribd::kinship()</code> to identify individuals having
kinship coefficient 0 with all relevant individuals.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>nonidentifiable</code>: A character vector (possibly empty) with the names of
the nonidentifiable missing persons.
</p>
</li>
<li> <p><code>dviReduced</code>: A reduced <code>dviData</code> object, where the nonidentifiable
individuals are removed from the list of missing persons. If there are no
<code>nonidentifiable</code>, this is just a copy of <code>dvi</code>.
</p>
</li>
<li> <p><code>summary</code>: A data frame summarising the findings.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: No nonidentifiables in dataset `example1`
findNonidentifiable(example1)

# Example 2: Add nonidentifiable person "A"
amNew = example1$am[[1]] |&gt;
  addSon(parents = c("NN", "A"))
missNew = c(example1$missing, "A")

dvi = dviData(pm = example1$pm, am = amNew, missing = missNew)
plotDVI(dvi, textAbove = c(A = "nonidentif."))

findNonidentifiable(dvi)

</code></pre>

<hr>
<h2 id='findUndisputed'>Undisputed identifications in a DVI problem</h2><span id='topic+findUndisputed'></span>

<h3>Description</h3>

<p>This function uses the pairwise LR matrix to find <em>undisputed</em> matches
between victims and missing individuals. An identification <code class="reqn">V_i = M_j</code> is
called undisputed, relative to a threshold T, if the corresponding likelihood
ratio <code class="reqn">LR_{i,j} \geq T</code> AND <code class="reqn">LR_{i,j}</code> is at least T times greater
than all other pairwise LRs involving <code class="reqn">V_i</code> or <code class="reqn">M_j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUndisputed(
  dvi,
  pairings = NULL,
  ignoreSex = FALSE,
  threshold = 10000,
  strict = FALSE,
  relax = !strict,
  limit = 0,
  nkeep = NULL,
  check = TRUE,
  numCores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUndisputed_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_pairings">pairings</code></td>
<td>
<p>A list of possible pairings for each victim. If NULL, all
sex-consistent pairings are used.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_threshold">threshold</code></td>
<td>
<p>A non-negative number. If no pairwise LR exceed this, the
iteration stops.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_strict">strict</code></td>
<td>
<p>A logical affecting the definition of being undisputed (see
Details). Default: FALSE.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_relax">relax</code></td>
<td>
<p>Deprecated; use <code>strict = FALSE</code> instead.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_limit">limit</code></td>
<td>
<p>A positive number. Only pairwise LR values above this are
considered.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_nkeep">nkeep</code></td>
<td>
<p>An integer, or NULL. If given, only the <code>nkeep</code> most likely
pairings are kept for each victim.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_check">check</code></td>
<td>
<p>A logical indicating if the input data should be checked for
consistency. Default: TRUE.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_numcores">numCores</code></td>
<td>
<p>An integer; the number of cores used in parallelisation.
Default: 1.</p>
</td></tr>
<tr><td><code id="findUndisputed_+3A_verbose">verbose</code></td>
<td>
<p>A logical. Default: TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the parameter <code>strict</code> is set to TRUE, the last criterion is replaced with
the stronger requirement that all other pairwise LRs involving <code class="reqn">V_i</code> or
<code class="reqn">M_j</code> must be at most 1.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>dviReduced</code>: A reduced version of <code>dvi</code>, where undisputed
victims/missing persons are removed, and data from undisputed victims
inserted into the reference data.
</p>
</li>
<li> <p><code>summary</code>: A data frame summarising the undisputed matches.
</p>
</li>
<li> <p><code>LRmatrix</code>: Output from <code>pairwiseLR()</code> applied to
the reduced problem.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pairwiseLR">pairwiseLR()</a></code>, <code><a href="#topic+findExcluded">findExcluded()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

u1 = findUndisputed(planecrash, verbose = FALSE)
u1$summary 

# With `strict = TRUE`, the match M3 = V2 goes away
u2 = findUndisputed(planecrash, strict = TRUE, verbose = FALSE)
u2$summary

# Reason: M3 has LR &gt; 1 also against V7
u2$LRmatrix[, "M3"] |&gt; round(2)


</code></pre>

<hr>
<h2 id='generatePairings'>Sex-consistent pairings</h2><span id='topic+generatePairings'></span>

<h3>Description</h3>

<p>Generate a list of sex-consistent pairings for each victim in a DVI problem.
By default, the empty pairing (denoted <code>*</code>) is included for each victim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePairings(dvi, includeEmpty = TRUE, ignoreSex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePairings_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="generatePairings_+3A_includeempty">includeEmpty</code></td>
<td>
<p>A logical. If TRUE (default), the do-nothing symbol (<code>*</code>)
is included for each victim.</p>
</td></tr>
<tr><td><code id="generatePairings_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors. Each vector is a subset of <code>missing</code>,
plus the character <code>*</code> denoting no pairing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointDVI">jointDVI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pm = list(singleton("V1", sex = 1),
          singleton("V2", sex = 2))
          
missing = paste0("M", 1:4)
am = list(nuclearPed(children = missing[1:3]),
          nuclearPed(children = missing[4], sex = 2))

dvi = dviData(pm, am, missing)
generatePairings(dvi)

</code></pre>

<hr>
<h2 id='getFamily'>Get AM component of selected individuals</h2><span id='topic+getFamily'></span>

<h3>Description</h3>

<p>Get AM component of selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFamily(dvi, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFamily_+3A_dvi">dvi</code></td>
<td>
<p>A <code><a href="#topic+dviData">dviData()</a></code> object.</p>
</td></tr>
<tr><td><code id="getFamily_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels of members of <code>dvi$am</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>ids</code>, containing the family names (if
<code>dvi$am</code> is named) or component indices (otherwise) of the <code>ids</code>
individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getFamily(example2, ids = example2$missing)

</code></pre>

<hr>
<h2 id='getSimpleFams'>Find the simple families of a DVI dataset</h2><span id='topic+getSimpleFams'></span>

<h3>Description</h3>

<p>Extract the names (if present) or indices of the <em>simple</em> reference families,
i.e., the families containing exactly 1 missing person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimpleFams(dvi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSimpleFams_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character (if <code>dvi$am</code> has names) or integer vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFamily">getFamily()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># No simple families
simple1 = getSimpleFams(example1)
stopifnot(length(simple1) == 0)

# Second family is simple
simple2 = getSimpleFams(example2)
stopifnot(simple2 == 2)

# With family names
simple3 = example2 |&gt; relabelDVI(familyPrefix = "FAM") |&gt; getSimpleFams()
stopifnot(simple3 == "FAM2")

</code></pre>

<hr>
<h2 id='grave'>DVI dataset: Family grave</h2><span id='topic+grave'></span>

<h3>Description</h3>

<p>Family grave data in Kling et al. (2021) &quot;Mass Identifications: Statistical
Methods in Forensic Genetics&quot;. There are 5 female victims and 3 male victims.
There is one reference family with 5 missing females and 3 missing males.
There are 23 markers, no mutation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grave
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 8 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A pedigree with 8 missing persons.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>grave

# plotDVI(grave, marker = 1)

# jointDVI(grave)

</code></pre>

<hr>
<h2 id='icmp'>DVI dataset: A large reference pedigree</h2><span id='topic+icmp'></span>

<h3>Description</h3>

<p>DVI dataset based loosely on the ICMP workshop material
https://www.few.vu.nl/~ksn560/Block-III-PartI-KS-ISFG2017.pdf (page 18).
There are 3 female victims, 2 male victims and 6 missing persons of both
sexes. We have renamed the individuals and simulated data for 13 CODIS
markers (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icmp
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 5 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A reference pedigree with 6 genotyped members and 12 missing
persons.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Details</h3>

<p>The 13 markers are, in order: <code>CSF1PO</code>, <code>D3S1358</code>, <code>D5S818</code>,<code>D7S820</code>,
<code>D8S1179</code>, <code>D13S317</code>, <code>D16S539</code>, <code>D18S51</code>, <code>D21S11</code>, <code>FGA</code>, <code>TH01</code>, <code>TPOX</code>,
and <code>vWA</code>.
</p>
<p>Source code for the simulation, and a file containing the allele frequencies,
can be found in the <code>data-raw</code> folder of the GitHub repository:
https://github.com/magnusdv/dvir.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>icmp

# plotDVI(icmp)

# Markers and allele frequencies
db = pedtools::getFreqDatabase(icmp$pm)
db

</code></pre>

<hr>
<h2 id='jointDVI'>Joint DVI search</h2><span id='topic+jointDVI'></span><span id='topic+compactJointRes'></span>

<h3>Description</h3>

<p>Victims are given as a list of singletons, and references as a list of
pedigrees. All possible assignments are evaluated and solutions ranked
according to the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointDVI(
  dvi,
  pairings = NULL,
  ignoreSex = FALSE,
  assignments = NULL,
  limit = 0,
  nkeep = NULL,
  undisputed = TRUE,
  markers = NULL,
  threshold = 10000,
  strict = FALSE,
  relax = !strict,
  disableMutations = NA,
  maxAssign = 1e+05,
  numCores = 1,
  check = TRUE,
  verbose = TRUE
)

compactJointRes(jointRes, LRthresh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_pairings">pairings</code></td>
<td>
<p>A list of possible pairings for each victim. If NULL, all
sex-consistent pairings are used.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_assignments">assignments</code></td>
<td>
<p>A data frame containing the assignments to be considered
in the joint analysis. By default, this is automatically generated by
taking all combinations from <code>pairings</code>.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_limit">limit</code></td>
<td>
<p>A positive number, by default 0. Only pairwise LR values above
this are considered.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_nkeep">nkeep</code></td>
<td>
<p>An integer, or NULL. If given, only the <code>nkeep</code> most likely
pairings are considered for each victim.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_undisputed">undisputed</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_markers">markers</code></td>
<td>
<p>A vector indicating which markers should be included in the
analysis. By default all markers are included.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_threshold">threshold</code></td>
<td>
<p>A positive number, passed onto <code><a href="#topic+findUndisputed">findUndisputed()</a></code>. Default:
1e4.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_strict">strict</code></td>
<td>
<p>A logical, passed onto <code><a href="#topic+findUndisputed">findUndisputed()</a></code>. Default: FALSE.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_relax">relax</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_disablemutations">disableMutations</code></td>
<td>
<p>A logical, or NA (default). The default action is to
disable mutations in all reference families without Mendelian errors.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_maxassign">maxAssign</code></td>
<td>
<p>A positive integer. If the number of assignments going into
the joint calculation exceeds this, the function will abort with an
informative error message. Default: 1e5.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_numcores">numCores</code></td>
<td>
<p>An integer; the number of cores used in parallelisation.
Default: 1.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_check">check</code></td>
<td>
<p>A logical, indicating if the input data should be checked for
consistency.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_jointres">jointRes</code></td>
<td>
<p>A data frame produced by <code>jointDVI()</code>.</p>
</td></tr>
<tr><td><code id="jointDVI_+3A_lrthresh">LRthresh</code></td>
<td>
<p>A positive number, used as upper limit for the LR comparing the
top result with all others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. Each row describes an assignment of victims to missing
persons, accompanied with its log likelihood, the LR compared to the null
(i.e., no identifications), and the posterior corresponding to a flat
prior.
</p>
<p>The function <code>compactJointRes()</code> removes columns without assignments, and
solutions whose LR compared with the top result is below <code>1/LRthresh</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwiseLR">pairwiseLR()</a></code>, <code><a href="#topic+findUndisputed">findUndisputed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jointDVI(example2)

</code></pre>

<hr>
<h2 id='KETPch4'>Data used in the book Kling et al. (2021)</h2><span id='topic+KETPch4'></span>

<h3>Description</h3>

<p>Data used in last example of Chapter 4 in Kling et al. (2021) &quot;Mass
Identifications: Statistical Methods in Forensic Genetics&quot;. There are 2
female victims, 2 male victims. There are four reference families with 2
missing females and 2 missing males. There are 21 markers. An 'equal mutation
mode with rate 0.005 is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KETPch4
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 4 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 3 pedigrees.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>KETPch4

plotDVI(KETPch4, nrowPM = 4)


</code></pre>

<hr>
<h2 id='KETPex481'>Data used in the book Kling et al. (2021)</h2><span id='topic+KETPex481'></span>

<h3>Description</h3>

<p>Data used in Example 4.8.1 in Kling et al. (2021) &quot;Mass Identifications:
Statistical Methods in Forensic Genetics&quot;. The victims are V1 and V2, both
females. There is one reference family with 2 missing persons, both females.
There are 21 markers, no mutation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KETPex481
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 2 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 1 pedigree.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>plotDVI(KETPex481, marker = 1)

</code></pre>

<hr>
<h2 id='KETPex497'>Data used in the book Kling et al. (2021)</h2><span id='topic+KETPex497'></span>

<h3>Description</h3>

<p>Data used in Exercise 4.9.7 in Kling et al. (2021) &quot;Mass Identifications:
Statistical Methods in Forensic Genetics&quot;. There are 3 female victims and 3
reference families with 3 missing females. There are 23 markers, equal
mutation model, rate 0.001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KETPex497
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 3 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 3 pedigrees.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>plotDVI(KETPex497, nrowPM = 3)


</code></pre>

<hr>
<h2 id='KETPex498'>Data used in the book Kling et al. (2021)</h2><span id='topic+KETPex498'></span>

<h3>Description</h3>

<p>Data used in Exercise 4.9.8 in Kling et al. (2021) &quot;Mass Identifications:
Statistical Methods in Forensic Genetics&quot;. There are 2 female victims and 1
male. There is one reference family with 2 missing females and one missing
male. There are 16 markers, equal mutation model, rate 0.001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KETPex498
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 3 singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 1 pedigree.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
plotDVI(KETPex498, nrowPM = 3)

</code></pre>

<hr>
<h2 id='mergePM'>Identity and merge matching PM samples</h2><span id='topic+mergePM'></span>

<h3>Description</h3>

<p>Computes the direct matching LR of each pair of samples, and merges the
matching samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePM(
  pm,
  threshold = 10000,
  method = c("mostcomplete", "first", "combine"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePM_+3A_pm">pm</code></td>
<td>
<p>A list of typed singletons.</p>
</td></tr>
<tr><td><code id="mergePM_+3A_threshold">threshold</code></td>
<td>
<p>LR threshold for positive identification.</p>
</td></tr>
<tr><td><code id="mergePM_+3A_method">method</code></td>
<td>
<p>A keyword indicating how to merging matching samples. See Details.</p>
</td></tr>
<tr><td><code id="mergePM_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available methods for merging matched samples are:
</p>

<ul>
<li><p> &quot;mostcomplete&quot;: Use the sample with the highest number of non-missing genotypes
</p>
</li>
<li><p> &quot;first&quot;: Use the first in each group, according to the input order
</p>
</li>
<li><p> &quot;combine&quot;: Not implemented yet.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>groups</code>: A list containing the groups of matching samples.
</p>
</li>
<li> <p><code>LRmat</code>: A symmetric matrix (with 0s on the diagonal) containing the direct
matching LR values.
</p>
</li>
<li> <p><code>nonmissing</code>: A named vector reporting the number of non-missing genotypes
for each sample.
</p>
</li>
<li> <p><code>pmReduced</code>: A list of singletons. If <code>use</code> is &quot;best&quot; or &quot;first&quot;, this is
a subset of the input <code>pm</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+directMatch">directMatch()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pm = singletons(c("V1", "V2", "V3")) |&gt; 
  addMarker(V1 = "1/1", V2 = "2/2", V3 = "1/1", 
            afreq = c("1" = 0.01, "2" = 0.99), name = "L1")

mergePM(pm)

</code></pre>

<hr>
<h2 id='ncomb'>The number of assignments for DVI problem</h2><span id='topic+ncomb'></span>

<h3>Description</h3>

<p>The number of victims and missing persons of each sex is given. The number of
possible assignments, i.e., the number of ways the victims can be identified
with the missing persons, is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncomb(nVfemales, nMPfemales, nVmales, nMPmales)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncomb_+3A_nvfemales">nVfemales</code></td>
<td>
<p>Integer. The number of female victims.</p>
</td></tr>
<tr><td><code id="ncomb_+3A_nmpfemales">nMPfemales</code></td>
<td>
<p>Integer. The number of female missing persons.</p>
</td></tr>
<tr><td><code id="ncomb_+3A_nvmales">nVmales</code></td>
<td>
<p>Integer. The number of male victims.</p>
</td></tr>
<tr><td><code id="ncomb_+3A_nmpmales">nMPmales</code></td>
<td>
<p>Integer. The number of male missing persons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total number of possible assignments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example
m1 = ncomb(5,5,5,5) #

# Example: 3 male victims; 2 male missing persons.
# The number of a priori possible assignments is
m1 = ncomb(0,0,3,2) # 13


# Compare with the complete list of assignments
m2 = expand.grid.nodup(list(V1 = c("*", "M1", "M2"),
                            V2 = c("*", "M1", "M2"),
                            V3 = c("*", "M1", "M2")))
stopifnot(m1 == nrow(m2))

</code></pre>

<hr>
<h2 id='pairwiseLR'>Pairwise LR matrix</h2><span id='topic+pairwiseLR'></span>

<h3>Description</h3>

<p>For a given DVI problem, compute the matrix consisting of pairwise likelihood
ratios <code class="reqn">LR_{i,j}</code> comparing <code class="reqn">V_i = M_j</code> to the null. The output may
be reduced by specifying arguments <code>limit</code> or <code>nkeep</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseLR(
  dvi,
  pairings = NULL,
  ignoreSex = FALSE,
  limit = 0,
  nkeep = NULL,
  check = TRUE,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseLR_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_pairings">pairings</code></td>
<td>
<p>A list of possible pairings for each victim. If NULL, all
sex-consistent pairings are used.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_ignoresex">ignoreSex</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_limit">limit</code></td>
<td>
<p>A nonnegative number controlling the <code>pairings</code> slot of the
output: Only pairings with LR greater or equal to <code>limit</code> are kept. If zero
(default), pairings with LR &gt; 0 are kept.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_nkeep">nkeep</code></td>
<td>
<p>An integer, or NULL. If given, only the <code>nkeep</code> most likely
pairings are kept for each victim.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_check">check</code></td>
<td>
<p>A logical, indicating if the input data should be checked for
consistency.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_numcores">numCores</code></td>
<td>
<p>An integer; the number of cores used in parallelisation.
Default: 1.</p>
</td></tr>
<tr><td><code id="pairwiseLR_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements:
</p>

<ul>
<li> <p><code>LRmatrix</code>: A matrix containing the pairwise LR values.
</p>
</li>
<li> <p><code>LRlist</code>: A list of numerical vectors, containing the pairwise LRs in
list format.
</p>
</li>
<li> <p><code>pairings</code>: A reduced version of the input <code>pairings</code>, keeping only
entries with corresponding LR &gt;= <code>limit</code>. For the default case <code>limit = 0</code>
a strict inequality is used, i.e., LR &gt; 0.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pairwiseLR(example1, verbose = TRUE)

</code></pre>

<hr>
<h2 id='planecrash'>DVI dataset: Simulated plane crash</h2><span id='topic+planecrash'></span>

<h3>Description</h3>

<p>A simulated dataset based on Exercise 3.3 in Egeland et al. &quot;Relationship
Inference with Familias and R&quot; (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planecrash
</code></pre>


<h3>Format</h3>

<p>A <code>dviData</code> object with the following content:
</p>

<ul>
<li> <p><code>pm</code>: A list of 8 female singletons (victims).
</p>
</li>
<li> <p><code>am</code>: A list of 5 pedigrees, each with one missing member and one
genotyped member.
</p>
</li>
<li> <p><code>missing</code>: A vector containing the names of the missing persons.
</p>
</li></ul>



<h3>Details</h3>

<p>The 15 markers are <code>CSF1PO</code>, <code>D13S317</code>, <code>D16S539</code>, <code>D18S51</code>, <code>D21S11</code>,
<code>D3S1358</code>, <code>D5S818</code>, <code>D7S820</code>, <code>D8S1179</code>, <code>FGA</code>, <code>PENTA_D</code>, <code>PENTA_E</code>,
<code>TH01</code>, <code>TPOX</code>, and <code>VWA</code>.
</p>
<p>Source code for the simulation, and a file containing the allele frequencies,
can be found in the <code>data-raw</code> folder of the GitHub repository:
https://github.com/magnusdv/dvir.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>planecrash

# plotDVI(planecrash)

# Markers and allele frequencies
db = pedtools::getFreqDatabase(planecrash$pm)
db

</code></pre>

<hr>
<h2 id='plotDVI'>Plot a DVI problem</h2><span id='topic+plotDVI'></span>

<h3>Description</h3>

<p>Plot a DVI problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDVI(
  dvi,
  pm = TRUE,
  am = TRUE,
  hatched = typedMembers,
  col = list(red = dvi$missing),
  frames = TRUE,
  titles = c("PM", "AM"),
  widths = NULL,
  nrowPM = NA,
  dev.height = NULL,
  dev.width = NULL,
  newdev = !is.null(c(dev.height, dev.width)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_pm">pm</code></td>
<td>
<p>Either a logical indicating if the PM data should be plotted (as a
set of singletons), or a vector of indices selecting a subset of the PM
samples. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_am">am</code></td>
<td>
<p>Either a logical indicating if the AM families data should be
plotted, or a vector of indices selecting a subset of the families.
Default: TRUE.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_hatched">hatched</code></td>
<td>
<p>A character vector of ID labels, or the name of a function. By
default, typed individuals are hatched.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_col">col</code></td>
<td>
<p>A list of colour vectors (see <code><a href="pedtools.html#topic+plot.ped">pedtools::plot.ped()</a></code>). By default,
missing members of <code>dvi$am</code> are shown in red.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_frames">frames</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_titles">titles</code></td>
<td>
<p>A character of length 2.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_widths">widths</code></td>
<td>
<p>A numeric with relative plot widths.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_nrowpm">nrowPM</code></td>
<td>
<p>The number of rows in the array of PM singletons.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_dev.height">dev.height</code>, <code id="plotDVI_+3A_dev.width">dev.width</code></td>
<td>
<p>Plot height and widths in inches. These are
optional, and only relevant if <code>newdev = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_newdev">newdev</code></td>
<td>
<p>A logical indicating if a new plot window should be opened.</p>
</td></tr>
<tr><td><code id="plotDVI_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed on to <code><a href="pedtools.html#topic+plot.ped">pedtools::plot.ped()</a></code>,
e.g., <code>marker</code>, <code>cex</code>, <code>cex.main</code>, <code>symbolsize</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
plotDVI(example2)

# Override default layout of PM singletons
plotDVI(example2, nrowPM = 3)

# Subset
plotDVI(example2, pm = 1:2, am = 1, titles = c("PM (1-2)", "AM (1)"))

# AM only
plotDVI(example2, pm = FALSE, titles = "AM families")

# Further options
# plotDVI(example2, new = T, frames = FALSE, marker = 1, cex = 1.2, nrowPM = 1)

</code></pre>

<hr>
<h2 id='plotSolution'>Plot DVI solution</h2><span id='topic+plotSolution'></span>

<h3>Description</h3>

<p>A version of <code><a href="#topic+plotDVI">plotDVI()</a></code> tailor-made to visualise identified individuals, for
example as reported by <code>jointDVI()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSolution(dvi, assignment, k = 1, format = "[S]=[M]", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSolution_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="plotSolution_+3A_assignment">assignment</code></td>
<td>
<p>A named character of the format <code>c(victim = missing, ...)</code>,
or a data frame produced by <code><a href="#topic+jointDVI">jointDVI()</a></code>.</p>
</td></tr>
<tr><td><code id="plotSolution_+3A_k">k</code></td>
<td>
<p>An integer; the row number when <code>assignment</code> is a data frame.</p>
</td></tr>
<tr><td><code id="plotSolution_+3A_format">format</code></td>
<td>
<p>A string indicating how identified individuals should be
labelled, using <code style="white-space: pre;">&#8288;[M]&#8288;</code> and <code style="white-space: pre;">&#8288;[S]&#8288;</code> as place holders for the missing person and
the matching sample, respectively. (See Examples.)</p>
</td></tr>
<tr><td><code id="plotSolution_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+plotDVI">plotDVI()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res = jointDVI(example2, verbose = FALSE)

plotSolution(example2, res)

# With line break in labels
plotSolution(example2, res, format = "[M]=\n[S]")

# With genotypes for marker 1
plotSolution(example2, res, marker = 1)

# Non-optimal solutions
plotSolution(example2, res, k = 2, pm = FALSE)
plotSolution(example2, res, k = 2, cex = 1.3)

</code></pre>

<hr>
<h2 id='plotUndisputed'>Plot undisputed identifications</h2><span id='topic+plotUndisputed'></span>

<h3>Description</h3>

<p>Plot undisputed identifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotUndisputed(dvi, undisputed, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotUndisputed_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object.</p>
</td></tr>
<tr><td><code id="plotUndisputed_+3A_undisputed">undisputed</code></td>
<td>
<p>A data frame containing the undisputed matches, typically
the entry <code>undisputed</code> in output from <code><a href="#topic+findUndisputed">findUndisputed()</a></code> (only three first
columns used).</p>
</td></tr>
<tr><td><code id="plotUndisputed_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+plotSolution">plotSolution()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+findUndisputed">findUndisputed()</a></code>, <code><a href="#topic+plotSolution">plotSolution()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example
res = findUndisputed(example2, threshold = 2, verbose = FALSE)
u = res$summary
plotUndisputed(example2, u, marker = 1)

</code></pre>

<hr>
<h2 id='relabelDVI'>Automatic labelling of a DVI dataset</h2><span id='topic+relabelDVI'></span>

<h3>Description</h3>

<p>Relabel the individuals and families in a DVI dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabelDVI(
  dvi,
  victimPrefix = NULL,
  familyPrefix = NULL,
  refPrefix = NULL,
  missingPrefix = NULL,
  missingFormat = NULL,
  othersPrefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabelDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="relabelDVI_+3A_victimprefix">victimPrefix</code></td>
<td>
<p>Prefix used to label PM individuals.</p>
</td></tr>
<tr><td><code id="relabelDVI_+3A_familyprefix">familyPrefix</code></td>
<td>
<p>Prefix used to label the AM families.</p>
</td></tr>
<tr><td><code id="relabelDVI_+3A_refprefix">refPrefix</code></td>
<td>
<p>Prefix used to label the reference individuals, i.e., the
typed members of the AM families.</p>
</td></tr>
<tr><td><code id="relabelDVI_+3A_missingprefix">missingPrefix</code></td>
<td>
<p>Prefix used to label the missing persons. At most one of
<code>missingPrefix</code> and <code>missingFormat</code> can be given.</p>
</td></tr>
<tr><td><code id="relabelDVI_+3A_missingformat">missingFormat</code></td>
<td>
<p>A string indicating family-wise labelling of missing
persons, using <code style="white-space: pre;">&#8288;[FAM]&#8288;</code>, <code style="white-space: pre;">&#8288;[IDX]&#8288;</code>, <code style="white-space: pre;">&#8288;[MIS]&#8288;</code> as place holders with the
following meanings (see Examples):
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;[FAM]&#8288;</code>: family index
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[IDX]&#8288;</code>: index of missing person within the family
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[MIS]&#8288;</code>: index within all missing persons
</p>
</li></ul>
</td></tr>
<tr><td><code id="relabelDVI_+3A_othersprefix">othersPrefix</code></td>
<td>
<p>Prefix used to label other untyped individuals. Use &quot;&quot;
for numeric labels ( 1, 2, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+dviData">dviData()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Builtin dataset `example2`
relabelDVI(example2,
           victimPrefix  = "vic",
           familyPrefix  = "fam",
           refPrefix     = "ref",
           missingPrefix = "mp")

# Family-wise labelling of missing persons
relabelDVI(example2, missingFormat = "M[FAM]-[IDX]")
relabelDVI(example2, missingFormat = "M[IDX] (F[FAM])")
relabelDVI(example2, missingFormat = "fam[FAM].m[IDX]")

</code></pre>

<hr>
<h2 id='sequentialDVI'>Sequential DVI search</h2><span id='topic+sequentialDVI'></span>

<h3>Description</h3>

<p>Performs a sequential matching procedure based on the pairwise LR matrix. In
each step the pairing corresponding to the highest LR is selected and
included as a match if the LR exceeds the given threshold. By default,
(<code>updateLR = TRUE</code>) the pairwise LRs are recomputed in each step after
including the data from the identified sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequentialDVI(
  dvi,
  updateLR = TRUE,
  threshold = 1,
  check = TRUE,
  verbose = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequentialDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code>dviData</code> object, typically created with <code><a href="#topic+dviData">dviData()</a></code>.</p>
</td></tr>
<tr><td><code id="sequentialDVI_+3A_updatelr">updateLR</code></td>
<td>
<p>A logical. If TRUE, the LR matrix is updated in each
iteration.</p>
</td></tr>
<tr><td><code id="sequentialDVI_+3A_threshold">threshold</code></td>
<td>
<p>A non-negative number. If no pairwise LR values exceed this,
the iteration stops.</p>
</td></tr>
<tr><td><code id="sequentialDVI_+3A_check">check</code></td>
<td>
<p>A logical, indicating if the input data should be checked for
consistency.</p>
</td></tr>
<tr><td><code id="sequentialDVI_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
<tr><td><code id="sequentialDVI_+3A_debug">debug</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, the LR matrix is printed
in each step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If, at any point, the highest LR is obtained by more than one pairing, the
process branches off and produces multiple solutions. (See Value.)
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>matches</code>: A single assignment vector, or (if multiple branches)
a data frame where each row is an assignment vector.
</p>
</li>
<li> <p><code>details</code>: A data frame (or a list of data frames, if multiple branches)
including the LR of each identification in the order they were made.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Without LR updates
sequentialDVI(example1, updateLR = FALSE)

# With LR updates (default). Note two branches!
r = sequentialDVI(example1)

# Plot the two solutions
plotSolution(example1, r$matches, k = 1)
plotSolution(example1, r$matches, k = 2)

# Add `debug = T` to see the LR matrix in each step
sequentialDVI(example1, debug = TRUE)

# The output of can be fed into `jointDVI()`:
jointDVI(example1, assignments = r$matches)

</code></pre>

<hr>
<h2 id='setPairing'>Set identifications manually</h2><span id='topic+setPairing'></span>

<h3>Description</h3>

<p>Manually set one or several identifications in a DVI dataset. Typically,
these are obtained by external means, e.g., fingerprints, dental records etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPairing(
  dvi,
  match = NULL,
  victim = NULL,
  missing = NULL,
  Conclusion = "Provided",
  Comment = "",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPairing_+3A_dvi">dvi</code></td>
<td>
<p>A DVI dataset.</p>
</td></tr>
<tr><td><code id="setPairing_+3A_match">match</code></td>
<td>
<p>A named vector of the format c(vic1 = miss2, vic2 = miss2, ...).</p>
</td></tr>
<tr><td><code id="setPairing_+3A_victim">victim</code></td>
<td>
<p>A vector of victim sample names. If NULL, defaulting to
<code>names(match)</code>.</p>
</td></tr>
<tr><td><code id="setPairing_+3A_missing">missing</code></td>
<td>
<p>A vector of missing person names, of the same length as
<code>victim</code>. If NULL, defaulting to <code>as.character(match)</code>.</p>
</td></tr>
<tr><td><code id="setPairing_+3A_conclusion">Conclusion</code></td>
<td>
<p>A character passed on to the <code>Conclusion</code> column of the
output summary.</p>
</td></tr>
<tr><td><code id="setPairing_+3A_comment">Comment</code></td>
<td>
<p>A character passed on to the <code>Comment</code> column of the output
summary.</p>
</td></tr>
<tr><td><code id="setPairing_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>setPairing(dvi, c("V" = "M"))</code> does the following:
</p>

<ul>
<li><p> Transfer the data of victim &quot;V&quot; to the individual &quot;M&quot; in the appropriate
reference family
</p>
</li>
<li><p> Remove &quot;M&quot; from the list of missing persons
</p>
</li>
<li><p> Remove &quot;V&quot; from the list of victim samples
</p>
</li>
<li><p> Update the list of pairings
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>dviReduced</code>: The new <code>dviData</code> object, as described in Details
</p>
</li>
<li> <p><code>summary</code>: A data frame summarising the identifications
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = setPairing(example2, match = c("V3" = "M2"))
x$dviReduced
x$summary

# Alternative syntax, using `victim` and `missing`
y = setPairing(planecrash, victim = c("V4", "V5"), missing = c("M4", "M5"),
           Conclusion = "External evidence", Comment = "Dental")
y$dviReduced
y$summary

</code></pre>

<hr>
<h2 id='subsetDVI'>Extract a subset of a DVI dataset</h2><span id='topic+subsetDVI'></span>

<h3>Description</h3>

<p>Extract a subset of a DVI dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetDVI(dvi, pm = NULL, am = NULL, missing = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetDVI_+3A_dvi">dvi</code></td>
<td>
<p>A <code><a href="#topic+dviData">dviData()</a></code> object</p>
</td></tr>
<tr><td><code id="subsetDVI_+3A_pm">pm</code></td>
<td>
<p>A vector with names or indices of victim samples. By
default, all are included.</p>
</td></tr>
<tr><td><code id="subsetDVI_+3A_am">am</code></td>
<td>
<p>A vector with names or indices of AM components. By
default, components without remaining missing individuals are dropped.</p>
</td></tr>
<tr><td><code id="subsetDVI_+3A_missing">missing</code></td>
<td>
<p>A vector with names or indices of missing persons. By
default, all missing persons in the remaining AM families are included.</p>
</td></tr>
<tr><td><code id="subsetDVI_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dviData</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
subsetDVI(example2, pm = 1:2) |&gt; plotDVI()
subsetDVI(example2, pm = "V1", am = 1) |&gt; plotDVI()
subsetDVI(example2, missing = "M3") |&gt; plotDVI()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
