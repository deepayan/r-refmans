<!DOCTYPE html><html lang="en"><head><title>Help for package FoReco</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FoReco}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FoReco-package'><p>FoReco: Forecast Reconciliation</p></a></li>
<li><a href='#aggts'><p>Non-overlapping temporal aggregation of a time series</p></a></li>
<li><a href='#balance_hierarchy'><p>Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form</p></a></li>
<li><a href='#commat'><p>Commutation matrix</p></a></li>
<li><a href='#csboot'><p>Cross-sectional joint block bootstrap</p></a></li>
<li><a href='#csbu'><p>Cross-sectional bottom-up reconciliation</p></a></li>
<li><a href='#cscov'><p>Cross-sectional covariance matrix approximation</p></a></li>
<li><a href='#cslcc'><p>Level conditional coherent reconciliation for genuine hierarchical/grouped time series</p></a></li>
<li><a href='#csmo'><p>Cross-sectional middle-out reconciliation</p></a></li>
<li><a href='#csprojmat'><p>Projection matrix for optimal combination cross-sectional reconciliation</p></a></li>
<li><a href='#csrec'><p>Optimal combination cross-sectional reconciliation</p></a></li>
<li><a href='#cstd'><p>Cross-sectional top-down reconciliation</p></a></li>
<li><a href='#cstools'><p>Cross-sectional reconciliation tools</p></a></li>
<li><a href='#ctboot'><p>Cross-temporal joint block bootstrap</p></a></li>
<li><a href='#ctbu'><p>Cross-temporal bottom-up reconciliation</p></a></li>
<li><a href='#ctcov'><p>Cross-temporal covariance matrix approximation</p></a></li>
<li><a href='#ctlcc'><p>Level conditional coherent reconciliation for cross-temporal hierarchies</p></a></li>
<li><a href='#ctmo'><p>Cross-temporal middle-out reconciliation</p></a></li>
<li><a href='#ctprojmat'><p>Projection matrix for optimal combination cross-temporal reconciliation</p></a></li>
<li><a href='#ctrec'><p>Optimal combination cross-temporal reconciliation</p></a></li>
<li><a href='#cttd'><p>Cross-temporal top-down reconciliation</p></a></li>
<li><a href='#cttools'><p>Cross-temporal reconciliation tools</p></a></li>
<li><a href='#df2aggmat'><p>Cross-sectional aggregation matrix of a dataframe</p></a></li>
<li><a href='#FoReco2matrix'><p>Reconciled forecasts to matrix/vector</p></a></li>
<li><a href='#itagdp'><p>Italian Quarterly National Accounts</p></a></li>
<li><a href='#iterec'><p>Iterative cross-temporal reconciliation</p></a></li>
<li><a href='#lcmat'><p>Linear combination (aggregation) matrix for a general linearly constrained multiple time series</p></a></li>
<li><a href='#recoinfo'><p>Informations on the reconciliation process</p></a></li>
<li><a href='#res2matrix'><p>One-step and multi-step residuals</p></a></li>
<li><a href='#shrink_estim'><p>Shrinkage of the covariance matrix</p></a></li>
<li><a href='#tcsrec'><p>Heuristic cross-temporal reconciliation</p></a></li>
<li><a href='#teboot'><p>Temporal joint block bootstrap</p></a></li>
<li><a href='#tebu'><p>Temporal bottom-up reconciliation</p></a></li>
<li><a href='#tecov'><p>Temporal covariance matrix approximation</p></a></li>
<li><a href='#telcc'><p>Level conditional coherent reconciliation for temporal hierarchies</p></a></li>
<li><a href='#temo'><p>Temporal middle-out reconciliation</p></a></li>
<li><a href='#teprojmat'><p>Projection matrix for optimal combination temporal reconciliation</p></a></li>
<li><a href='#terec'><p>Optimal combination temporal reconciliation</p></a></li>
<li><a href='#tetd'><p>Temporal top-down reconciliation</p></a></li>
<li><a href='#tetools'><p>Temporal reconciliation tools</p></a></li>
<li><a href='#unbalance_hierarchy'><p>Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form</p></a></li>
<li><a href='#vndata'><p>Australian Tourism Demand dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecast Reconciliation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Classical (bottom-up and top-down), optimal combination and heuristic  
    point (Di Fonzo and Girolimetto, 2023 &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>&gt;) and 
    probabilistic (Girolimetto et al. 2023 &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>&gt;) 
    forecast reconciliation procedures for linearly constrained time series 
    (e.g., hierarchical or grouped time series) in cross-sectional, temporal, 
    or cross-temporal frameworks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/daniGiro/FoReco">https://github.com/daniGiro/FoReco</a>,
<a href="https://danigiro.github.io/FoReco/">https://danigiro.github.io/FoReco/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daniGiro/FoReco/issues">https://github.com/daniGiro/FoReco/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, osqp, stats, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-20 12:37:56 UTC; daniele</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniele Girolimetto
    <a href="https://orcid.org/0000-0001-9387-1232"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    fnd],
  Tommaso Di Fonzo <a href="https://orcid.org/0000-0003-3388-7827"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniele Girolimetto &lt;daniele.girolimetto@unipd.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-20 22:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='FoReco-package'>FoReco: Forecast Reconciliation</h2><span id='topic+FoReco'></span><span id='topic+FoReco-package'></span>

<h3>Description</h3>

<p>Classical (bottom-up and top-down), optimal combination and heuristic point (Di Fonzo and Girolimetto, 2023 <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>) and probabilistic (Girolimetto et al. 2023 <a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>) forecast reconciliation procedures for linearly constrained time series (e.g., hierarchical or grouped time series) in cross-sectional, temporal, or cross-temporal frameworks.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniele Girolimetto <a href="mailto:daniele.girolimetto@unipd.it">daniele.girolimetto@unipd.it</a> (<a href="https://orcid.org/0000-0001-9387-1232">ORCID</a>) [funder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Tommaso Di Fonzo (<a href="https://orcid.org/0000-0003-3388-7827">ORCID</a>) [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/daniGiro/FoReco">https://github.com/daniGiro/FoReco</a>
</p>
</li>
<li> <p><a href="https://danigiro.github.io/FoReco/">https://danigiro.github.io/FoReco/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/daniGiro/FoReco/issues">https://github.com/daniGiro/FoReco/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aggts'>Non-overlapping temporal aggregation of a time series</h2><span id='topic+aggts'></span>

<h3>Description</h3>

<p>Non-overlapping temporal aggregation of a time series according
to a specific aggregation order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggts(y, agg_order, tew = "sum", align = "end", rm_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggts_+3A_y">y</code></td>
<td>
<p>Univariate or multivariate time series: a vector/matrix or a <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="aggts_+3A_agg_order">agg_order</code></td>
<td>
<p>A numeric vector with the aggregation orders to consider.</p>
</td></tr>
<tr><td><code id="aggts_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="aggts_+3A_align">align</code></td>
<td>
<p>A string or a vector specifying the alignment of <code>y</code>. Options include:
&quot;<code>end</code>&quot; (end of the series, <em>default</em>), &quot;<code>start</code>&quot; (start of the series),
an integer (or a vector of integers) indicating the starting period of the temporally
aggregated series.</p>
</td></tr>
<tr><td><code id="aggts_+3A_rm_na">rm_na</code></td>
<td>
<p>If <code>TRUE</code> the missing values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors or <code>ts</code> objects.
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Monthly time series (input vector)
y &lt;- ts(rnorm(24), start = 2020, frequency = 12)
# Quarterly time series
x1 &lt;- aggts(y, 3)
# Monthly, quarterly and annual time series
x2 &lt;- aggts(y, c(1, 3, 12))
# All temporally aggregated time series
x3 &lt;- aggts(y)

# Ragged data
y2 &lt;- ts(rnorm(11), start = c(2020, 3), frequency = 4)
# Annual time series: start in 2021
x4 &lt;- aggts(y2, 4, align = 3)
# Semi-annual (start in 2nd semester of 2020) and annual (start in 2021) time series
x5 &lt;- aggts(y2, c(2, 4), align = c(1, 3))

</code></pre>

<hr>
<h2 id='balance_hierarchy'>Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form</h2><span id='topic+balance_hierarchy'></span>

<h3>Description</h3>

<p>A hierarchy with <code class="reqn">L</code> upper levels is said to be balanced if each variable at level
<code class="reqn">l</code> has at least one child at level <code class="reqn">l+1</code>. When this doesn't hold, the hierarchy
is unbalanced. This function transforms an aggregation matrix of an unbalanced hierarchy
into an aggregation matrix of a balanced one. This function is used to reconcile forecasts
with <a href="#topic+cslcc">cslcc</a>, which operates exclusively with balanced hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_hierarchy(agg_mat, nodes = "auto", sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance_hierarchy_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="balance_hierarchy_+3A_nodes">nodes</code></td>
<td>
<p>A (<code class="reqn">L \times 1</code>) numeric vector indicating the number of variables
in each of the upper <code class="reqn">L</code> levels of the hierarchy. The <em>default</em>
value is the string &quot;<code>auto</code>&quot; which calculates the number of variables in each level.</p>
</td></tr>
<tr><td><code id="balance_hierarchy_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing four elements:
</p>
<table role = "presentation">
<tr><td><code>bam</code></td>
<td>
<p>The balanced aggregation matrix.</p>
</td></tr>
<tr><td><code>agg_mat</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>A (<code class="reqn">L \times 1</code>) numeric vector indicating the number of variables
in each of the <code class="reqn">L</code> upper levels of the balanced hierarchy.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>The identification number of each variable in the balanced hierarchy.
It may contains duplicated values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#    Unbalanced     -&gt;      Balanced
#        T                     T
#    |-------|             |-------|
#    A       |             A       B
#  |---|     |           |---|     |
# AA   AB    B          AA   AB    BA
A &lt;- matrix(c(1, 1, 1,
              1, 1, 0), 2, byrow = TRUE)
obj &lt;- balance_hierarchy(agg_mat = A, nodes = c(1, 1))
obj$bam
</code></pre>

<hr>
<h2 id='commat'>Commutation matrix</h2><span id='topic+commat'></span>

<h3>Description</h3>

<p>This function returns the (<code class="reqn">r c \times r c</code>)
commutation matrix <code class="reqn">\mathbf{P}</code> such that
<code class="reqn">\mathbf{P} \mbox{vec}(\mathbf{Y}) = \mbox{vec}(\mathbf{Y}'),</code>
where <code class="reqn">\mathbf{Y}</code> is a (<code class="reqn">r \times c</code>) matrix (Magnus and Neudecker, 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commat(r, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="commat_+3A_r">r</code></td>
<td>
<p>Number of rows of <code class="reqn">\mathbf{Y}</code>.</p>
</td></tr>
<tr><td><code id="commat_+3A_c">c</code></td>
<td>
<p>Number of columns of <code class="reqn">\mathbf{Y}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse (<code class="reqn">r c \times r c</code>) matrix, <code class="reqn">\mathbf{P}</code>.
</p>


<h3>References</h3>

<p>Magnus, J.R. and Neudecker, H. (2019), Matrix Differential Calculus with Applications
in Statistics and Econometrics, third edition, New York, Wiley, pp. 54-55.
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(30), 5, 6)
P &lt;- commat(5, 6)
P %*% as.vector(Y) == as.vector(t(Y)) # check

</code></pre>

<hr>
<h2 id='csboot'>Cross-sectional joint block bootstrap</h2><span id='topic+csboot'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between different time series (Panagiotelis et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csboot(model_list, boot_size, block_size, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csboot_+3A_model_list">model_list</code></td>
<td>
<p>A list of all the <code class="reqn">n</code> base forecasts models. A <code>simulate()</code>
function for each model has to be available and implemented according to the
package <a href="https://CRAN.R-project.org/package=forecast"><span class="pkg">forecast</span></a>,
with the following mandatory parameters: <em>object</em>,
<em>innov</em>, <em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="csboot_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="csboot_+3A_block_size">block_size</code></td>
<td>
<p>Block size of the bootstrap, which is typically equivalent
to the forecast horizon.</p>
</td></tr>
<tr><td><code id="csboot_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and a 3-d array
(<code class="reqn">\text{boot\_size}\times n \times \text{block\_size}</code>).
</p>


<h3>References</h3>

<p>Panagiotelis, A., Gamakumara, P., Athanasopoulos, G. and Hyndman, R.J. (2023),
Probabilistic forecast reconciliation: Properties, evaluation and score optimisation,
<em>European Journal of Operational Research</em> 306(2), 693–706.
<a href="https://doi.org/10.1016/j.ejor.2022.07.040">doi:10.1016/j.ejor.2022.07.040</a>
</p>


<h3>See Also</h3>

<p>Bootstrap samples: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+teboot">teboot</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>

<hr>
<h2 id='csbu'>Cross-sectional bottom-up reconciliation</h2><span id='topic+csbu'></span>

<h3>Description</h3>

<p>This function computes the cross-sectional bottom-up reconciled forecasts
(Dunn et al., 1976) for all series by appropriate summation of the bottom
base forecasts <code class="reqn">\widehat{\mathbf{b}}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\widetilde{\mathbf{y}} = \mathbf{S}_{cs}\widehat{\mathbf{b}},</code>
</p>

<p>where <code class="reqn">\mathbf{S}_{cs}</code> is the cross-sectional structural matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csbu(base, agg_mat, sntz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csbu_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h \times n_b</code>) numeric matrix or multivariate time series
(<code>mts</code> class) containing bottom base forecasts; <code class="reqn">h</code> is the
forecast horizon, and <code class="reqn">n_b</code> is the total number of bottom variables.</p>
</td></tr>
<tr><td><code id="csbu_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="csbu_+3A_sntz">sntz</code></td>
<td>
<p>If <code>TRUE</code>, the negative base forecasts are
set to zero before applying bottom-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h \times n</code>) numeric matrix of cross-sectional reconciled forecasts.
</p>


<h3>References</h3>

<p>Dunn, D. M., Williams, W. H. and Dechaine, T. L. (1976), Aggregate versus subaggregate
models in local area forecasting, <em>Journal of the American Statistical Association</em>
71(353), 68–71. <a href="https://doi.org/10.1080/01621459.1976.10481478">doi:10.1080/01621459.1976.10481478</a>
</p>


<h3>See Also</h3>

<p>Bottom-up reconciliation: 
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 2) bottom base forecasts matrix (simulated), Z = X + Y
bts &lt;- matrix(rnorm(6, mean = c(10, 10)), 3, byrow = TRUE)

# Aggregation matrix for Z = X + Y
A &lt;- t(c(1,1))
reco &lt;- csbu(base = bts, agg_mat = A)

# Non negative reconciliation
bts[2,2] &lt;- -bts[2,2] # Making negative one of the base forecasts for variable Y
nnreco &lt;- csbu(base = bts, agg_mat = A, sntz = TRUE)

</code></pre>

<hr>
<h2 id='cscov'>Cross-sectional covariance matrix approximation</h2><span id='topic+cscov'></span><span id='topic+cscov.default'></span><span id='topic+cscov.ols'></span><span id='topic+cscov.str'></span><span id='topic+cscov.wls'></span><span id='topic+cscov.shr'></span><span id='topic+cscov.sam'></span>

<h3>Description</h3>

<p>This function provides an approximation of the cross-sectional base forecasts errors
covariance matrix using different reconciliation methods (see Wickramasuriya et al.,
2019 and Di Fonzo and Girolimetto, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cscov(comb = "ols", n = NULL, agg_mat = NULL, res, mse = TRUE,
      shrink_fun = shrink_estim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cscov_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method.
</p>

<ul>
<li><p> Ordinary least squares:
</p>

<ul>
<li><p> &quot;<code>ols</code>&quot; (<em>default</em>) - identity error covariance matrix.
</p>
</li></ul>

</li>
<li><p> Weighted least squares:
</p>

<ul>
<li><p> &quot;<code>str</code>&quot; - structural variances.
</p>
</li>
<li><p> &quot;<code>wls</code>&quot; - series variances (uses <code>res</code>).
</p>
</li></ul>

</li>
<li><p> Generalized least squares:
</p>

<ul>
<li><p> &quot;<code>shr</code>&quot;/&quot;<code>sam</code>&quot; - shrunk/sample covariance (uses <code>res</code>).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="cscov_+3A_n">n</code></td>
<td>
<p>Number of variables (<code class="reqn">n = n_a + n_b</code>).</p>
</td></tr>
<tr><td><code id="cscov_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cscov_+3A_res">res</code></td>
<td>
<p>An (<code class="reqn">N \times n</code>) optional numeric matrix containing the in-sample
residuals. This matrix is used to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="cscov_+3A_mse">mse</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</td></tr>
<tr><td><code id="cscov_+3A_shrink_fun">shrink_fun</code></td>
<td>
<p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</td></tr>
<tr><td><code id="cscov_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times n</code>) symmetric positive (semi-)definite matrix.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>
<p>Wickramasuriya, S.L., Athanasopoulos, G. and Hyndman, R.J. (2019), Optimal forecast
reconciliation for hierarchical and grouped time series through trace minimization,
<em>Journal of the American Statistical Association</em>, 114, 526, 804-819.
<a href="https://doi.org/10.1080/01621459.2018.1448825">doi:10.1080/01621459.2018.1448825</a>
</p>


<h3>See Also</h3>

<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Aggregation matrix for Z = X + Y
A &lt;- t(c(1,1))
# (10 x 3) in-sample residuals matrix (simulated)
res &lt;- t(matrix(rnorm(n = 30), nrow = 3))

cov1 &lt;- cscov("ols", n = 3)          # OLS methods
cov2 &lt;- cscov("str", agg_mat = A)   # STR methods
cov3 &lt;- cscov("wls", res = res)      # WLS methods
cov4 &lt;- cscov("shr", res = res)      # SHR methods
cov5 &lt;- cscov("sam", res = res)      # SAM methods

# Custom covariance matrix
cscov.ols2 &lt;- function(comb, x) diag(x)
cscov(comb = "ols2", x = 3) # == cscov("ols", n = 3)

</code></pre>

<hr>
<h2 id='cslcc'>Level conditional coherent reconciliation for genuine hierarchical/grouped time series</h2><span id='topic+cslcc'></span>

<h3>Description</h3>

<p>This function implements the cross-sectional forecast reconciliation procedure that
extends the original proposal by Hollyman et al. (2021). Level conditional coherent
reconciled forecasts are conditional on (i.e., constrained by) the base forecasts
of a specific upper level in the hierarchy (exogenous constraints). It also allows
handling the linear constraints linking the variables endogenously (Di Fonzo and
Girolimetto, 2022). The function can calculate Combined Conditional Coherent (CCC)
forecasts as simple averages of Level-Conditional Coherent (LCC) and bottom-up
reconciled forecasts, with either endogenous or exogenous constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cslcc(base, agg_mat, nodes = "auto", comb = "ols", res = NULL, CCC = TRUE,
      const = "exogenous", bts = NULL, approach = "proj", nn = NULL,
      settings = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cslcc_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h \times n</code>) numeric matrix or multivariate time series (<code>mts</code> class)
containing the base forecasts to be reconciled; <code class="reqn">h</code> is the forecast horizon, and <code class="reqn">n</code> is
the total number of time series (<code class="reqn">n = n_a + n_b</code>).</p>
</td></tr>
<tr><td><code id="cslcc_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cslcc_+3A_nodes">nodes</code></td>
<td>
<p>A (<code class="reqn">L \times 1</code>) numeric vector indicating the number of variables
in each of the upper <code class="reqn">L</code> levels of the hierarchy. The <em>default</em>
value is the string &quot;<code>auto</code>&quot; which calculates the number of variables in each level.</p>
</td></tr>
<tr><td><code id="cslcc_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+cscov">cscov</a>.</p>
</td></tr>
<tr><td><code id="cslcc_+3A_res">res</code></td>
<td>
<p>An (<code class="reqn">N \times n</code>) optional numeric matrix containing the in-sample
residuals. This matrix is used to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="cslcc_+3A_ccc">CCC</code></td>
<td>
<p>A logical value indicating whether the Combined Conditional Coherent reconciled
forecasts reconciliation should include bottom-up forecasts (<code>TRUE</code>, <em>default</em>), or not.</p>
</td></tr>
<tr><td><code id="cslcc_+3A_const">const</code></td>
<td>
<p>A string specifying the reconciliation constraints:
</p>

<ul>
<li><p> &quot;<code>exogenous</code>&quot; (<em>default</em>): Fixes the top level of each sub-hierarchy.
</p>
</li>
<li><p> &quot;<code>endogenous</code>&quot;: Coherently revises both the top and bottom levels.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cslcc_+3A_bts">bts</code></td>
<td>
<p>A (<code class="reqn">h \times n_b</code>) numeric matrix or multivariate time series (<code>mts</code> class)
containing bottom base forecasts defined by the user (e.g., seasonal averages, as in Hollyman et al., 2021).
This parameter can be omitted if only base forecasts are used
(see Di Fonzo and Girolimetto, 2024).</p>
</td></tr>
<tr><td><code id="cslcc_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cslcc_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="cslcc_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="cslcc_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+cscov">cscov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h \times n</code>) numeric matrix of cross-sectional reconciled forecasts.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2024), Forecast combination-based forecast reconciliation:
Insights and extensions, <em>International Journal of Forecasting</em>, 40(2), 490–514.
<a href="https://doi.org/10.1016/j.ijforecast.2022.07.001">doi:10.1016/j.ijforecast.2022.07.001</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023b) Spatio-temporal reconciliation of solar forecasts.
<em>Solar Energy</em> 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Hollyman, R., Petropoulos, F. and Tipping, M.E. (2021), Understanding forecast reconciliation.
<em>European Journal of Operational Research</em>, 294, 149–160. <a href="https://doi.org/10.1016/j.ejor.2021.01.017">doi:10.1016/j.ejor.2021.01.017</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>


<h3>See Also</h3>

<p>Level conditional coherent reconciliation: 
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY
A &lt;- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE)
# (2 x 7) base forecasts matrix (simulated)
base &lt;- matrix(rnorm(7*2, mean = c(40, 20, 20, 10, 10, 10, 10)), 2, byrow = TRUE)
# (10 x 7) in-sample residuals matrix (simulated)
res &lt;- matrix(rnorm(n = 7*10), ncol = 7)
# (2 x 7) Naive bottom base forecasts matrix: all forecasts are set equal to 10
naive &lt;- matrix(10, 2, 4)

## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021)
# Level Conditional Coherent (LCC) reconciled forecasts
exo_LC &lt;- cslcc(base = base, agg_mat = A, comb = "wls", bts = naive,
                res = res, nodes = "auto", CCC = FALSE)

# Combined Conditional Coherent (CCC) reconciled forecasts
exo_CCC &lt;- cslcc(base = base, agg_mat = A, comb = "wls", bts = naive,
                 res = res, nodes = "auto", CCC = TRUE)

# Results detailed by level:
# L-1: Level 1 immutable reconciled forecasts for the whole hierarchy
# L-2: Middle-Out reconciled forecasts
# L-3: Bottom-Up reconciled forecasts
info_exo &lt;- recoinfo(exo_CCC, verbose = FALSE)
info_exo$lcc

## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024)
# Level Conditional Coherent (LCC) reconciled forecasts
endo_LC &lt;- cslcc(base = base, agg_mat = A, comb = "wls",
                 res = res, nodes = "auto", CCC = FALSE,
                 const = "endogenous")

# Combined Conditional Coherent (CCC) reconciled forecasts
endo_CCC &lt;- cslcc(base = base, agg_mat = A, comb = "wls",
                  res = res, nodes = "auto", CCC = TRUE,
                  const = "endogenous")

# Results detailed by level:
# L-1: Level 1 reconciled forecasts for L1 + L3 (bottom level)
# L-2: Level 2 reconciled forecasts for L2 + L3 (bottom level)
# L-3: Bottom-Up reconciled forecasts
info_endo &lt;- recoinfo(endo_CCC, verbose = FALSE)
info_endo$lcc

</code></pre>

<hr>
<h2 id='csmo'>Cross-sectional middle-out reconciliation</h2><span id='topic+csmo'></span>

<h3>Description</h3>

<p>The middle-out forecast reconciliation (Athanasopoulos et al., 2009) combines
top-down (<a href="#topic+cstd">cstd</a>) and bottom-up (<a href="#topic+csbu">csbu</a>) for genuine hierarchical/grouped
time series. Given the base forecasts of variables at an intermediate
level <code class="reqn">l</code>, it performs
</p>

<ul>
<li><p> a top-down approach for the levels <code class="reqn">&lt;l</code>;
</p>
</li>
<li><p> a bottom-up approach for the levels <code class="reqn">&gt;l</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>csmo(base, agg_mat, id_rows = 1, weights, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csmo_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h \times n_l</code>) numeric matrix containing the <code class="reqn">l</code>-level
base forecast; <code class="reqn">n_l</code> is the number of variables at level <code class="reqn">l</code>, and
<code class="reqn">h</code> is the forecast horizon.</p>
</td></tr>
<tr><td><code id="csmo_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="csmo_+3A_id_rows">id_rows</code></td>
<td>
<p>A numeric vector indicating the <code class="reqn">l</code>-level rows of <code>agg_mat</code>.</p>
</td></tr>
<tr><td><code id="csmo_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">h \times n_b</code>) numeric matrix containing the proportions for the
bottom time series; <code class="reqn">h</code> is the forecast horizon, and <code class="reqn">n_b</code> is the total number
of bottom variables.</p>
</td></tr>
<tr><td><code id="csmo_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h \times n</code>) numeric matrix of cross-sectional reconciled forecasts.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Ahmed, R. A. and Hyndman, R.J. (2009) Hierarchical forecasts
for Australian domestic tourism. <em>International Journal of Forecasting</em> 25(1),
146–166. <a href="https://doi.org/10.1016/j.ijforecast.2008.07.004">doi:10.1016/j.ijforecast.2008.07.004</a>
</p>


<h3>See Also</h3>

<p>Middle-out reconciliation: 
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY
A &lt;- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE)
# (3 x 2) top base forecasts vector (simulated), forecast horizon = 3
baseL2 &lt;- matrix(rnorm(2*3, 5), 3, 2)
# Same weights for different forecast horizons
fix_weights &lt;- runif(4)
reco &lt;- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- matrix(runif(4*3), 3, 4)
recoh &lt;- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = h_weights)

</code></pre>

<hr>
<h2 id='csprojmat'>Projection matrix for optimal combination cross-sectional reconciliation</h2><span id='topic+csprojmat'></span>

<h3>Description</h3>

<p>This function computes the projection or the mapping matrix
<code class="reqn">\mathbf{M}</code> and <code class="reqn">\mathbf{G}</code>, respectively, such that
<code class="reqn">\widetilde{\mathbf{y}} = \mathbf{M}\widehat{\mathbf{y}} = \mathbf{S}_{cs}\mathbf{G}\widehat{\mathbf{y}}</code>,
where <code class="reqn">\widetilde{\mathbf{y}}</code> is the vector of the reconciled forecasts,
<code class="reqn">\widehat{\mathbf{y}}</code> is the vector of the base forecasts,
<code class="reqn">\mathbf{S}_{cs}</code> is the cross-sectional structural matrix, and <code class="reqn">\mathbf{M} = \mathbf{S}_{cs}\mathbf{G}</code>.
For further information regarding on the structure of these matrices,
refer to Girolimetto et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csprojmat(agg_mat, cons_mat, comb = "ols", res = NULL, mat = "M", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csprojmat_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="csprojmat_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="csprojmat_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+cscov">cscov</a>.</p>
</td></tr>
<tr><td><code id="csprojmat_+3A_res">res</code></td>
<td>
<p>An (<code class="reqn">N \times n</code>) optional numeric matrix containing the in-sample
residuals. This matrix is used to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="csprojmat_+3A_mat">mat</code></td>
<td>
<p>A string specifying which matrix to return:
&quot;<code>M</code>&quot; (<em>default</em>) for <code class="reqn">\mathbf{M}</code> and &quot;<code>G</code>&quot; for <code class="reqn">\mathbf{G}</code>.</p>
</td></tr>
<tr><td><code id="csprojmat_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+cscov">cscov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The projection matrix <code class="reqn">\mathbf{M}</code> (<code>mat = "M"</code>) or
the mapping matrix <code class="reqn">\mathbf{G}</code> (<code>mat = "G"</code>).
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross-sectional framework
A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
Mcs &lt;- csprojmat(agg_mat = A, comb = "ols")
Gcs &lt;- csprojmat(agg_mat = A, comb = "ols", mat = "G")

</code></pre>

<hr>
<h2 id='csrec'>Optimal combination cross-sectional reconciliation</h2><span id='topic+csrec'></span>

<h3>Description</h3>

<p>This function performs optimal (in least squares sense) combination cross-sectional
forecast reconciliation for a linearly constrained (e.g., hierarchical/grouped)
multiple time series (Wickramasuriya et al., 2019, Panagiotelis et al., 2022,
Girolimetto and Di Fonzo, 2023). The reconciled forecasts are calculated
using either a projection approach (Byron, 1978, 1979) or the equivalent structural
approach by Hyndman et al. (2011). Non-negative (Di Fonzo and Girolimetto, 2023) and
immutable (including Zhang et al., 2023) reconciled forecasts can be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csrec(base, agg_mat, cons_mat, comb = "ols", res = NULL, approach = "proj",
      nn = NULL, settings = NULL, bounds = NULL, immutable = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csrec_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h \times n</code>) numeric matrix or multivariate time series (<code>mts</code> class)
containing the base forecasts to be reconciled; <code class="reqn">h</code> is the forecast horizon, and <code class="reqn">n</code> is
the total number of time series (<code class="reqn">n = n_a + n_b</code>).</p>
</td></tr>
<tr><td><code id="csrec_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="csrec_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="csrec_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+cscov">cscov</a>.</p>
</td></tr>
<tr><td><code id="csrec_+3A_res">res</code></td>
<td>
<p>An (<code class="reqn">N \times n</code>) optional numeric matrix containing the in-sample
residuals. This matrix is used to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="csrec_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="csrec_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="csrec_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="csrec_+3A_bounds">bounds</code></td>
<td>
<p>A (<code class="reqn">n \times 2</code>) numeric matrix specifying the cross-sectional bounds.
The first column represents the lower bound, and the second column represents the upper bound.</p>
</td></tr>
<tr><td><code id="csrec_+3A_immutable">immutable</code></td>
<td>
<p>A numeric vector containing the column indices of the base forecasts
(<code>base</code> parameter) that should be fixed.</p>
</td></tr>
<tr><td><code id="csrec_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+cscov">cscov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h \times n</code>) numeric matrix of cross-sectional reconciled forecasts.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023), Spatio-temporal reconciliation of solar
forecasts, <em>Solar Energy</em>, 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Girolimetto, D. and Di Fonzo, T. (2023), Point and probabilistic forecast reconciliation
for general linearly constrained multiple time series,
<em>Statistical Methods &amp; Applications</em>, in press. <a href="https://doi.org/10.1007/s10260-023-00738-6">doi:10.1007/s10260-023-00738-6</a>.
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Panagiotelis, A., Athanasopoulos, G., Gamakumara, P. and Hyndman, R.J. (2021), Forecast
reconciliation: A geometric view with new insights on bias correction,
<em>International Journal of Forecasting</em>, 37, 1, 343–359.
<a href="https://doi.org/10.1016/j.ijforecast.2020.06.004">doi:10.1016/j.ijforecast.2020.06.004</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>
<p>Wickramasuriya, S.L., Athanasopoulos, G. and Hyndman, R.J. (2019), Optimal forecast
reconciliation for hierarchical and grouped time series through trace minimization,
<em>Journal of the American Statistical Association</em>, 114, 526, 804-819.
<a href="https://doi.org/10.1080/01621459.2018.1448825">doi:10.1080/01621459.2018.1448825</a>
</p>
<p>Zhang, B., Kang, Y., Panagiotelis, A. and Li, F. (2023), Optimal reconciliation with
immutable forecasts, <em>European Journal of Operational Research</em>, 308(2), 650–660.
<a href="https://doi.org/10.1016/j.ejor.2022.11.035">doi:10.1016/j.ejor.2022.11.035</a>
</p>


<h3>See Also</h3>

<p>Regression-based reconciliation: 
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (2 x 3) base forecasts matrix (simulated), Z = X + Y
base &lt;- matrix(rnorm(6, mean = c(20, 10, 10)), 2, byrow = TRUE)
# (10 x 3) in-sample residuals matrix (simulated)
res &lt;- t(matrix(rnorm(n = 30), nrow = 3))

# Aggregation matrix for Z = X + Y
A &lt;- t(c(1,1))
reco &lt;- csrec(base = base, agg_mat = A, comb = "wls", res = res)

# Zero constraints matrix for Z - X - Y = 0
C &lt;- t(c(1, -1, -1))
reco &lt;- csrec(base = base, cons_mat = C, comb = "wls", res = res) # same results

# Non negative reconciliation
base[1,3] &lt;- -base[1,3] # Making negative one of the base forecasts for variable Y
nnreco &lt;- csrec(base = base, agg_mat = A, comb = "wls", res = res, nn = "osqp")
recoinfo(nnreco, verbose = FALSE)$info

</code></pre>

<hr>
<h2 id='cstd'>Cross-sectional top-down reconciliation</h2><span id='topic+cstd'></span>

<h3>Description</h3>

<p>Top-down forecast reconciliation for genuine hierarchical/grouped time series
(Gross and Sohl, 1990), where the forecast of a &lsquo;Total&rsquo; (top-level series,
expected to be positive) is disaggregated according to a proportional scheme
(weights). Besides fulfilling any aggregation constraint, the top-down
reconciled forecasts should respect two main properties:
</p>

<ul>
<li><p> the top-level value remains unchanged;
</p>
</li>
<li><p> all the bottom time series reconciled forecasts are non-negative.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cstd(base, agg_mat, weights, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cstd_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h \times 1</code>) numeric vector containing the top-level base forecast;
<code class="reqn">h</code> is the forecast horizon.</p>
</td></tr>
<tr><td><code id="cstd_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cstd_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">h \times n_b</code>) numeric matrix containing the proportions for the
bottom time series; <code class="reqn">h</code> is the forecast horizon, and <code class="reqn">n_b</code> is the total number
of bottom variables.</p>
</td></tr>
<tr><td><code id="cstd_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h \times n</code>) numeric matrix of cross-sectional reconciled forecasts.
</p>


<h3>References</h3>

<p>Gross, C.W. and Sohl, J.E. (1990), Disaggregation methods to expedite product
line forecasting. <em>Journal of Forecasting</em> 9(3), 233–254. <a href="https://doi.org/10.1002/for.3980090304">doi:10.1002/for.3980090304</a>
</p>


<h3>See Also</h3>

<p>Top-down reconciliation: 
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>
</p>
<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY
A &lt;- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE)
# (3 x 1) top base forecasts vector (simulated), forecast horizon = 3
topf &lt;- rnorm(3, 10)
# Same weights for different forecast horizons
fix_weights &lt;- runif(4)
reco &lt;- cstd(base = topf, agg_mat = A, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- matrix(runif(4*3), 3, 4)
recoh &lt;- cstd(base = topf, agg_mat = A, weights = h_weights)

</code></pre>

<hr>
<h2 id='cstools'>Cross-sectional reconciliation tools</h2><span id='topic+cstools'></span>

<h3>Description</h3>

<p>Some useful tools for the cross-sectional forecast reconciliation of a
linearly constrained (e.g., hierarchical/grouped) multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstools(agg_mat, cons_mat, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cstools_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cstools_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="cstools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements:
</p>
<table role = "presentation">
<tr><td><code>dim</code></td>
<td>
<p>A vector containing information about the number of series for the complete
system (<code>n</code>), for upper levels (<code>na</code>) and bottom level (<code>nb</code>).</p>
</td></tr>
<tr><td><code>agg_mat</code></td>
<td>
<p>The cross-sectional aggregation matrix.</p>
</td></tr>
<tr><td><code>strc_mat</code></td>
<td>
<p>The cross-sectional structural matrix.</p>
</td></tr>
<tr><td><code>cons_mat</code></td>
<td>
<p>The cross-sectional zero constraints matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Cross-sectional framework: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+cscov">cscov</a>()</code>,
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+cstd">cstd</a>()</code>
</p>
<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross-sectional framework
# One level hierarchy A = [1 1]
A &lt;- matrix(1, 1, 2)
obj &lt;- cstools(agg_mat = A)

</code></pre>

<hr>
<h2 id='ctboot'>Cross-temporal joint block bootstrap</h2><span id='topic+ctboot'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between variables at different temporal aggregation orders
(Girolimetto et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctboot_+3A_model_list">model_list</code></td>
<td>
<p>A list of <code class="reqn">n</code> elements, one for each cross-sectional series.
Each elements is a list with the <code class="reqn">(k^\ast+m)</code> base forecasts models ordered
from the lowest frequency (most temporally aggregated) to the highest frequency.
A <code>simulate()</code> function for each model has to be available and implemented
according to the package <a href="https://CRAN.R-project.org/package=forecast"><span class="pkg">forecast</span></a>,
with the following mandatory parameters: <em>object</em>, <em>innov</em>,
<em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="ctboot_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="ctboot_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctboot_+3A_block_size">block_size</code></td>
<td>
<p>Block size of the bootstrap, which is typically equivalent
to the forecast horizon for the most temporally aggregated series.</p>
</td></tr>
<tr><td><code id="ctboot_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and
a (<code class="reqn">\text{boot\_size}\times n(k^\ast+m)\text{block\_size}</code>) matrix.
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2023), Cross-temporal
probabilistic forecast reconciliation: Methodological and practical issues.
<em>International Journal of Forecasting</em>, in press. <a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Bootstrap samples: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+teboot">teboot</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>

<hr>
<h2 id='ctbu'>Cross-temporal bottom-up reconciliation</h2><span id='topic+ctbu'></span>

<h3>Description</h3>

<p>Cross-temporal bottom-up reconciled forecasts for all series at any temporal
aggregation level are computed by appropriate summation of the high-frequency
bottom base forecasts <code class="reqn">\widehat{\mathbf{B}^{[1]}}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\widetilde{\mathbf{X}} = \mathbf{S}_{cs}\widehat{\mathbf{B}^{[1]}}\mathbf{S}'_{te},</code>
</p>

<p>where <code class="reqn">\mathbf{S}_{cs}</code> and <code class="reqn">\mathbf{S}_{te}</code> are the cross-sectional and
temporal structural matrices, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbu(base, agg_mat, agg_order, tew = "sum", sntz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctbu_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n_b \times hm</code>) numeric matrix containing high-frequency bottom base
forecasts; <code class="reqn">n_b</code> is the total number of high-frequency bottom variables, <code class="reqn">m</code> is
the max aggregation order, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency
time series.</p>
</td></tr>
<tr><td><code id="ctbu_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctbu_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctbu_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctbu_+3A_sntz">sntz</code></td>
<td>
<p>If <code>TRUE</code>, the negative base forecasts are
set to zero before applying bottom-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Bottom-up reconciliation: 
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y
A &lt;- t(c(1,1))
# (2 x 4) high frequency bottom base forecasts matrix (simulated),
# agg_order = 4 (annual-quarterly)
hfbts &lt;- matrix(rnorm(4*2, 2.5), 2, 4)

reco &lt;- ctbu(base = hfbts, agg_mat = A, agg_order = 4)

# Non negative reconciliation
hfbts[1,4] &lt;- -hfbts[1,4] # Making negative one of the quarterly base forecasts for variable X
nnreco &lt;- ctbu(base = hfbts, agg_mat = A, agg_order = 4, sntz = TRUE)

</code></pre>

<hr>
<h2 id='ctcov'>Cross-temporal covariance matrix approximation</h2><span id='topic+ctcov'></span><span id='topic+ctcov.default'></span><span id='topic+ctcov.ols'></span><span id='topic+ctcov.str'></span><span id='topic+ctcov.csstr'></span><span id='topic+ctcov.testr'></span><span id='topic+ctcov.sam'></span><span id='topic+ctcov.wlsh'></span><span id='topic+ctcov.wlsv'></span><span id='topic+ctcov.shr'></span><span id='topic+ctcov.acov'></span><span id='topic+ctcov.Ssam'></span><span id='topic+ctcov.Sshr'></span><span id='topic+ctcov.bdshr'></span><span id='topic+ctcov.bdsam'></span><span id='topic+ctcov.hbshr'></span><span id='topic+ctcov.hbsam'></span><span id='topic+ctcov.hshr'></span><span id='topic+ctcov.hsam'></span><span id='topic+ctcov.bshr'></span><span id='topic+ctcov.bsam'></span>

<h3>Description</h3>

<p>This function provides an approximation of the cross-temporal base forecasts errors
covariance matrix using different reconciliation methods (Di Fonzo and Girolimetto, 2023,
Girolimetto et al., 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctcov(comb = "ols", n = NULL, agg_mat = NULL, agg_order = NULL, res = NULL,
      tew = "sum", mse = TRUE, shrink_fun = shrink_estim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctcov_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method.
</p>

<ul>
<li><p> Ordinary least squares:
</p>

<ul>
<li><p> &quot;<code>ols</code>&quot; (<em>default</em>) - identity error covariance.
</p>
</li></ul>

</li>
<li><p> Weighted least squares:
</p>

<ul>
<li><p> &quot;<code>str</code>&quot; - structural variances.
</p>
</li>
<li><p> &quot;<code>csstr</code>&quot; - cross-sectional structural variances.
</p>
</li>
<li><p> &quot;<code>testr</code>&quot; - temporal structural variances.
</p>
</li>
<li><p> &quot;<code>wlsh</code>&quot; - hierarchy variances (uses <code>res</code>).
</p>
</li>
<li><p> &quot;<code>wlsv</code>&quot; - series variances (uses <code>res</code>).
</p>
</li></ul>

</li>
<li><p> Generalized least squares (uses <code>res</code>):
</p>

<ul>
<li><p> &quot;<code>acov</code>&quot; - series auto-covariance.
</p>
</li>
<li><p> &quot;<code>bdshr</code>&quot;/&quot;<code>bdsam</code>&quot; - shrunk/sample block diagonal cross-sectional covariance.
</p>
</li>
<li><p> &quot;<code>Sshr</code>&quot;/&quot;<code>Ssam</code>&quot; - series shrunk/sample covariance.
</p>
</li>
<li><p> &quot;<code>shr</code>&quot;/&quot;<code>sam</code>&quot; - shrunk/sample covariance.
</p>
</li>
<li><p> &quot;<code>hbshr</code>&quot;/&quot;<code>hbsam</code>&quot; - shrunk/sample high frequency bottom time series covariance.
</p>
</li>
<li><p> &quot;<code>bshr</code>&quot;/&quot;<code>bsam</code>&quot; - shrunk/sample bottom time series covariance.
</p>
</li>
<li><p> &quot;<code>hshr</code>&quot;/&quot;<code>hsam</code>&quot; - shrunk/sample high frequency covariance.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="ctcov_+3A_n">n</code></td>
<td>
<p>Cross-sectional number of variables.</p>
</td></tr>
<tr><td><code id="ctcov_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctcov_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctcov_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="ctcov_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctcov_+3A_mse">mse</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</td></tr>
<tr><td><code id="ctcov_+3A_shrink_fun">shrink_fun</code></td>
<td>
<p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</td></tr>
<tr><td><code id="ctcov_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n(k^\ast+m) \times n(k^\ast+m)</code>) symmetric matrix.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>
<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y
A &lt;- t(c(1,1))
# (3 x 70) in-sample residuals matrix (simulated),
# agg_order = 4 (annual-quarterly)
res &lt;- rbind(rnorm(70), rnorm(70), rnorm(70))

cov1 &lt;- ctcov("ols", n = 3, agg_order = 4)                     # OLS methods
cov2 &lt;- ctcov("str", agg_mat = A, agg_order = 4)               # STR methods
cov3 &lt;- ctcov("csstr", agg_mat = A, agg_order = 4)             # CSSTR methods
cov4 &lt;- ctcov("testr", n = 3, agg_order = 4)                   # TESTR methods
cov5 &lt;- ctcov("wlsv", agg_order = 4, res = res)                # WLSv methods
cov6 &lt;- ctcov("wlsh", agg_order = 4, res = res)                # WLSh methods
cov7 &lt;- ctcov("shr", agg_order = 4, res = res)                 # SHR methods
cov8 &lt;- ctcov("sam", agg_order = 4, res = res)                 # SAM methods
cov9 &lt;- ctcov("acov", agg_order = 4, res = res)                # ACOV methods
cov10 &lt;- ctcov("Sshr", agg_order = 4, res = res)               # Sshr methods
cov11 &lt;- ctcov("Ssam", agg_order = 4, res = res)               # Ssam methods
cov12 &lt;- ctcov("hshr", agg_order = 4, res = res)               # Hshr methods
cov13 &lt;- ctcov("hsam", agg_order = 4, res = res)               # Hsam methods
cov14 &lt;- ctcov("hbshr", agg_mat = A, agg_order = 4, res = res) # HBshr methods
cov15 &lt;- ctcov("hbsam", agg_mat = A, agg_order = 4, res = res) # HBsam methods
cov16 &lt;- ctcov("bshr", agg_mat = A, agg_order = 4, res = res)  # Bshr methods
cov17 &lt;- ctcov("bsam", agg_mat = A, agg_order = 4, res = res)  # Bsam methods
cov18 &lt;- ctcov("bdshr", agg_order = 4, res = res)              # BDshr methods
cov19 &lt;- ctcov("bdsam", agg_order = 4, res = res)              # BDsam methods

# Custom covariance matrix
ctcov.ols2 &lt;- function(comb, x) diag(x)
cov20 &lt;- ctcov(comb = "ols2", x = 21) # == ctcov("ols", n = 3, agg_order = 4)

</code></pre>

<hr>
<h2 id='ctlcc'>Level conditional coherent reconciliation for cross-temporal hierarchies</h2><span id='topic+ctlcc'></span>

<h3>Description</h3>

<p>This function implements a forecast reconciliation procedure inspired by the original
proposal by Hollyman et al. (2021) for cross-temporal hierarchies. Level conditional
coherent reconciled forecasts are conditional on (i.e., constrained by) the base
forecasts of a specific upper level in the hierarchy (exogenous constraints). It also
allows handling the linear constraints linking the variables endogenously (Di Fonzo
and Girolimetto, 2022). The function can calculate Combined Conditional Coherent (CCC)
forecasts as simple averages of Level-Conditional Coherent (LCC) and bottom-up
reconciled forecasts, with either endogenous or exogenous constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctlcc(base, agg_mat, nodes = "auto", agg_order, comb = "ols", res = NULL,
      CCC = TRUE, const = "exogenous", hfbts = NULL, tew = "sum",
      approach = "proj", nn = NULL, settings = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctlcc_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix containing the base forecasts to
be reconciled; <code class="reqn">n</code> is the total number of variables, <code class="reqn">m</code> is the max. order of temporal
aggregation, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>) factors of <code class="reqn">m</code>,
excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency time series.
The row identifies a time series, and the forecasts in each row are ordered from the
lowest frequency (most temporally aggregated) to the highest frequency.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_nodes">nodes</code></td>
<td>
<p>A (<code class="reqn">L \times 1</code>) numeric vector indicating the number of variables
in each of the upper <code class="reqn">L</code> levels of the hierarchy. The <em>default</em>
value is the string &quot;<code>auto</code>&quot; which calculates the number of variables in each level.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+ctcov">ctcov</a>.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_ccc">CCC</code></td>
<td>
<p>A logical value indicating whether the Combined Conditional Coherent reconciled
forecasts reconciliation should include bottom-up forecasts (<code>TRUE</code>, <em>default</em>), or not.</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_const">const</code></td>
<td>
<p>A string specifying the reconciliation constraints:
</p>

<ul>
<li><p> &quot;<code>exogenous</code>&quot; (<em>default</em>): Fixes the top level of each sub-hierarchy.
</p>
</li>
<li><p> &quot;<code>endogenous</code>&quot;: Coherently revises both the top and bottom levels.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctlcc_+3A_hfbts">hfbts</code></td>
<td>
<p>A (<code class="reqn">n \times mh</code>) numeric matrix containing high frequency bottom base
forecasts defined by the user. This parameter can be omitted
if only base forecasts are used (see Di Fonzo and Girolimetto, 2024).</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctlcc_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctlcc_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="ctlcc_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+ctcov">ctcov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2024), Forecast combination-based forecast reconciliation:
Insights and extensions, <em>International Journal of Forecasting</em>, 40(2), 490–514.
<a href="https://doi.org/10.1016/j.ijforecast.2022.07.001">doi:10.1016/j.ijforecast.2022.07.001</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023b) Spatio-temporal reconciliation of solar forecasts.
<em>Solar Energy</em> 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Hollyman, R., Petropoulos, F. and Tipping, M.E. (2021), Understanding forecast reconciliation.
<em>European Journal of Operational Research</em>, 294, 149–160. <a href="https://doi.org/10.1016/j.ejor.2021.01.017">doi:10.1016/j.ejor.2021.01.017</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>


<h3>See Also</h3>

<p>Level conditional coherent reconciliation: 
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY
A &lt;- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE)
# (7 x 7) base forecasts matrix (simulated), agg_order = 4
base &lt;- rbind(rnorm(7, rep(c(40, 20, 10), c(1, 2, 4))),
              rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))
# (7 x 70) in-sample residuals matrix (simulated)
res &lt;- matrix(rnorm(70*7), nrow = 7)
# (4 x 4) Naive high frequency bottom base forecasts vector:
# all forecasts are set equal to 2.5
naive &lt;- matrix(2.5, 4, 4)

## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021)
# Level Conditional Coherent (LCC) reconciled forecasts
exo_LC &lt;- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = "wlsh", nn = "osqp",
                hfbts = naive, res = res, nodes = "auto", CCC = FALSE)

# Combined Conditional Coherent (CCC) reconciled forecasts
exo_CCC &lt;- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = "wlsh",
                hfbts = naive, res = res, nodes = "auto", CCC = TRUE)

# Results detailed by level:
info_exo &lt;- recoinfo(exo_CCC, verbose = FALSE)
# info_exo$lcc

## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024)
# Level Conditional Coherent (LCC) reconciled forecasts
endo_LC &lt;- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = "wlsh",
                 res = res, nodes = "auto", CCC = FALSE,
                 const = "endogenous")

# Combined Conditional Coherent (CCC) reconciled forecasts
endo_CCC &lt;- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = "wlsh",
                  res = res, nodes = "auto", CCC = TRUE,
                  const = "endogenous")

# Results detailed by level:
info_endo &lt;- recoinfo(endo_CCC, verbose = FALSE)
# info_endo$lcc

</code></pre>

<hr>
<h2 id='ctmo'>Cross-temporal middle-out reconciliation</h2><span id='topic+ctmo'></span>

<h3>Description</h3>

<p>The cross-temporal middle-out forecast reconciliation combines top-down
(<a href="#topic+cttd">cttd</a>) and bottom-up (<a href="#topic+ctbu">ctbu</a>) methods in the cross-temporal framework for
genuine hierarchical/grouped time series. Given the base forecasts of an
intermediate cross-sectional level <code class="reqn">l</code> and aggregation order <code class="reqn">k</code>,
it performs
</p>

<ul>
<li><p> a top-down approach for the aggregation orders <code class="reqn">\geq k</code> and
cross-sectional levels <code class="reqn">\geq l</code>;
</p>
</li>
<li><p> a bottom-up approach, otherwise.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ctmo(base, agg_mat, agg_order, id_rows = 1, order = max(agg_order),
     weights, tew = "sum", normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctmo_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n_l \times hk</code>) numeric matrix containing the <code class="reqn">l</code>-level
base forecasts of temporal aggregation order <code class="reqn">k</code>; <code class="reqn">n_l</code> is the number of variables at
level <code class="reqn">l</code>, <code class="reqn">k</code> is an aggregation order (a factor of <code class="reqn">m</code>, and <code class="reqn">1&lt;k&lt;m</code>),
<code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is the forecast horizon for the
lowest frequency time series.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_id_rows">id_rows</code></td>
<td>
<p>A numeric vector indicating the <code class="reqn">l</code>-level rows of <code>agg_mat</code>.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_order">order</code></td>
<td>
<p>The intermediate fixed aggregation order <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">n_b \times hm</code>) numeric matrix containing the proportions for each
high-frequency bottom time series; <code class="reqn">n_b</code> is the total number of high-frequency
bottom variables, <code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is the forecast horizon
for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="ctmo_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctmo_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Middle-out reconciliation: 
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY
A &lt;- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE)
# (2 x 6) base forecasts matrix (simulated), forecast horizon = 3
# and intermediate aggregation order k = 2 (max agg order = 4)
baseL2k2 &lt;- rbind(rnorm(3*2, 5), rnorm(3*2, 5))

# Same weights for different forecast horizons, agg_order = 4
fix_weights &lt;- matrix(runif(4*4), 4, 4)
reco &lt;- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,
             order = 2, agg_order = 4, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- matrix(runif(4*4*3), 4, 3*4)
recoh &lt;- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,
             order = 2, agg_order = 4, weights = h_weights)

</code></pre>

<hr>
<h2 id='ctprojmat'>Projection matrix for optimal combination cross-temporal reconciliation</h2><span id='topic+ctprojmat'></span>

<h3>Description</h3>

<p>This function computes the projection or the mapping matrix
<code class="reqn">\mathbf{M}</code> and <code class="reqn">\mathbf{G}</code>, respectively, such that
<code class="reqn">\widetilde{\mathbf{y}} = \mathbf{M}\widehat{\mathbf{y}} = \mathbf{S}_{ct}\mathbf{G}\widehat{\mathbf{y}}</code>,
where <code class="reqn">\widetilde{\mathbf{y}}</code> is the vector of the reconciled forecasts,
<code class="reqn">\widehat{\mathbf{y}}</code> is the vector of the base forecasts,
<code class="reqn">\mathbf{S}_{ct}</code> is the cross-temporal structural matrix, and <code class="reqn">\mathbf{M} = \mathbf{S}_{ct}\mathbf{G}</code>.
For further information regarding on the structure of these matrices,
refer to Girolimetto et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctprojmat(agg_mat, cons_mat, agg_order, comb = "ols", res = NULL,
          mat = "M", tew = "sum", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctprojmat_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+ctcov">ctcov</a>.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_mat">mat</code></td>
<td>
<p>A string specifying which matrix to return:
&quot;<code>M</code>&quot; (<em>default</em>) for <code class="reqn">\mathbf{M}</code> and &quot;<code>G</code>&quot; for <code class="reqn">\mathbf{G}</code>.</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctprojmat_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+ctcov">ctcov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The projection matrix <code class="reqn">\mathbf{M}</code> (<code>mat = "M"</code>) or
the mapping matrix <code class="reqn">\mathbf{G}</code> (<code>mat = "G"</code>).
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross-temporal framework (Z = X + Y, annual-quarterly)
A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
Mct &lt;- ctprojmat(agg_mat = A, agg_order = 4, comb = "ols")
Gct &lt;- ctprojmat(agg_mat = A, agg_order = 4, comb = "ols", mat = "G")

</code></pre>

<hr>
<h2 id='ctrec'>Optimal combination cross-temporal reconciliation</h2><span id='topic+ctrec'></span>

<h3>Description</h3>

<p>This function performs optimal (in least squares sense) combination cross-temporal forecast
reconciliation (Di Fonzo and Girolimetto 2023a, Girolimetto et al. 2023). The reconciled
forecasts are calculated using either a projection approach (Byron, 1978, 1979) or the
equivalent structural approach by Hyndman et al. (2011). Non-negative (Di Fonzo and
Girolimetto, 2023) and immutable reconciled forecasts can be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctrec(base, agg_mat, cons_mat, agg_order, comb = "ols", res = NULL,
      tew = "sum", approach = "proj", nn = NULL, settings = NULL,
      bounds = NULL, immutable = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctrec_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix containing the base forecasts to
be reconciled; <code class="reqn">n</code> is the total number of variables, <code class="reqn">m</code> is the max. order of temporal
aggregation, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>) factors of <code class="reqn">m</code>,
excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency time series.
The row identifies a time series, and the forecasts in each row are ordered from the
lowest frequency (most temporally aggregated) to the highest frequency.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+ctcov">ctcov</a>.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="ctrec_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctrec_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctrec_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="ctrec_+3A_bounds">bounds</code></td>
<td>
<p>A (<code class="reqn">n(k^\ast + m) \times 2</code>) numeric matrix specifying the
cross-temporal bounds. The first column represents the lower bound, and the
second column represents the upper bound.</p>
</td></tr>
<tr><td><code id="ctrec_+3A_immutable">immutable</code></td>
<td>
<p>A matrix with three columns (<code class="reqn">i,k,j</code>), such that
</p>

<dl>
<dt>Column 1</dt><dd><p>Represents the cross-sectional series (<code class="reqn">i = 1, \dots, n</code>).</p>
</dd>
<dt>Column 2</dt><dd><p>Denotes the temporal aggregation order (<code class="reqn">k = m,\dots,1</code>).</p>
</dd>
<dt>Column 3</dt><dd><p>Indicates the temporal forecast horizon (<code class="reqn">j = 1,\dots,m/k</code>).</p>
</dd>
</dl>

<p>For example, when working with a quarterly multivariate time series (<code class="reqn">n = 3</code>):
</p>

<ul>
<li> <p><code>t(c(1, 4, 1))</code> - Fix the one step ahead annual forecast of the first time series.
</p>
</li>
<li> <p><code>t(c(2, 1, 2))</code> - Fix the two step ahead quarterly forecast of the second time series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ctrec_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+ctcov">ctcov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023a), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023), Spatio-temporal reconciliation of solar
forecasts, <em>Solar Energy</em>, 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>


<h3>See Also</h3>

<p>Regression-based reconciliation: 
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4
base &lt;- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))
# (3 x 70) in-sample residuals matrix (simulated)
res &lt;- rbind(rnorm(70), rnorm(70), rnorm(70))

A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
m &lt;- 4 # from quarterly to annual temporal aggregation
reco &lt;- ctrec(base = base, agg_mat = A, agg_order = m, comb = "wlsv", res = res)

C &lt;- t(c(1, -1, -1)) # Zero constraints matrix for Z - X - Y = 0
reco &lt;- ctrec(base = base, cons_mat = C, agg_order = m, comb = "wlsv", res = res)

# Immutable reconciled forecasts
# Fix all the quarterly forecasts of the second variable.
imm_mat &lt;- expand.grid(i = 2, k = 1, j = 1:4)
immreco &lt;- ctrec(base = base, cons_mat = C, agg_order = m, comb = "wlsv",
                 res = res, immutable = imm_mat)

# Non negative reconciliation
base[2,7] &lt;- -2*base[2,7] # Making negative one of the quarterly base forecasts for variable X
nnreco &lt;- ctrec(base = base, cons_mat = C, agg_order = m, comb = "wlsv",
                res = res, nn = "osqp")
recoinfo(nnreco, verbose = FALSE)$info

</code></pre>

<hr>
<h2 id='cttd'>Cross-temporal top-down reconciliation</h2><span id='topic+cttd'></span>

<h3>Description</h3>

<p>Top-down forecast reconciliation for cross-temporal hierarchical/grouped
time series, where the forecast of a &lsquo;Total&rsquo; (top-level series, expected
to be positive) is disaggregated according to a proportional scheme (weights).
Besides fulfilling any aggregation constraint, the top-down reconciled
forecasts should respect two main properties:
</p>

<ul>
<li><p> the top-level value remains unchanged;
</p>
</li>
<li><p> all the bottom time series reconciled forecasts are non-negative.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cttd(base, agg_mat, agg_order, weights, tew = "sum", normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cttd_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">hm \times 1</code>) numeric vector containing top- and <code class="reqn">m</code> temporal
aggregated level base forecasts; <code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is
the forecast horizon for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="cttd_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cttd_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="cttd_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">n_b \times hm</code>) numeric matrix containing the proportions for each
high-frequency bottom time series; <code class="reqn">n_b</code> is the total number of high-frequency
bottom variables, <code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is the forecast horizon
for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="cttd_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="cttd_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Top-down reconciliation: 
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>
</p>
<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 1) top base forecasts vector (simulated), forecast horizon = 3
topf &lt;- rnorm(3, 10)
A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y

# Same weights for different forecast horizons, agg_order = 4
fix_weights &lt;- matrix(runif(4*2), 2, 4)
reco &lt;- cttd(base = topf, agg_mat = A, agg_order = 4, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- matrix(runif(4*2*3), 2, 3*4)
recoh &lt;- cttd(base = topf, agg_mat = A, agg_order = 4, weights = h_weights)

</code></pre>

<hr>
<h2 id='cttools'>Cross-temporal reconciliation tools</h2><span id='topic+cttools'></span>

<h3>Description</h3>

<p>Some useful tools for the cross-temporal forecast reconciliation of a linearly constrained
(e.g., hierarchical/grouped) multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cttools(agg_mat, cons_mat, agg_order, tew = "sum", fh = 1, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cttools_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="cttools_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n</code>) numeric matrix representing the cross-sectional
zero constraints. It spans the null space for the reconciled forecasts.</p>
</td></tr>
<tr><td><code id="cttools_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="cttools_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="cttools_+3A_fh">fh</code></td>
<td>
<p>Forecast horizon for the lowest frequency (most temporally aggregated)
time series (<em>default</em> is <code>1</code>).</p>
</td></tr>
<tr><td><code id="cttools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements:
</p>
<table role = "presentation">
<tr><td><code>dim</code></td>
<td>
<p>A vector containing information about the number of series for the
complete system (<code>n</code>), for upper levels (<code>na</code>) and bottom level
(<code>nb</code>), the maximum aggregation order  (<code>m</code>), the number of factor
(<code>p</code>), the partial (<code>ks</code>) and total sum (<code>kt</code>) of factors.</p>
</td></tr>
<tr><td><code>set</code></td>
<td>
<p>The vector of the temporal aggregation orders (in decreasing order).</p>
</td></tr>
<tr><td><code>agg_mat</code></td>
<td>
<p>The cross-temporal aggregation matrix.</p>
</td></tr>
<tr><td><code>strc_mat</code></td>
<td>
<p>The cross-temporal structural matrix.</p>
</td></tr>
<tr><td><code>cons_mat</code></td>
<td>
<p>The cross-temporal zero constraints matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>
<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross-temporal framework
A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
m &lt;- 4 # from quarterly to annual temporal aggregation
cttools(agg_mat = A, agg_order = m)

</code></pre>

<hr>
<h2 id='df2aggmat'>Cross-sectional aggregation matrix of a dataframe</h2><span id='topic+df2aggmat'></span>

<h3>Description</h3>

<p>This function allows the user to easily build the (<code class="reqn">n_a \times n_b</code>)
cross-sectional aggregation matrix starting from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2aggmat(formula, data, sep = "_", sparse = TRUE, top_label = "Total",
          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df2aggmat_+3A_formula">formula</code></td>
<td>
<p>Specification of the hierarchical structure: grouped hierarchies are specified
using <code>~ g1 * g2</code> and nested hierarchies are specified using <code>~ parent / child</code>.
Mixtures of the two formulations are also possible, like <code>~ g1 * (grandparent / parent / child)</code>.</p>
</td></tr>
<tr><td><code id="df2aggmat_+3A_data">data</code></td>
<td>
<p>A dataset in which each column contains the values of the variables in the formula
and each row identifies a bottom level time series.</p>
</td></tr>
<tr><td><code id="df2aggmat_+3A_sep">sep</code></td>
<td>
<p>Character to separate the names of the aggregated series, (<em>default</em> is &quot;<code>_</code>&quot;).</p>
</td></tr>
<tr><td><code id="df2aggmat_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="df2aggmat_+3A_top_label">top_label</code></td>
<td>
<p>Label of the top level variable (<em>default</em> is &quot;<code>Total</code>&quot;).</p>
</td></tr>
<tr><td><code id="df2aggmat_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), hierarchy informations are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>na x nb</code>) matrix.
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Balanced hierarchy
#         T
#    |--------|
#    A        B
#  |---|   |--|--|
# AA   AB  BA BB BC
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "B", "B", "B"),
                       X2 = c("A", "B", "A", "B", "C"),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
agg_mat &lt;- df2aggmat(~ X1 / X2, data_bts, sep = "", verbose = FALSE)

## Unbalanced hierarchy
#                 T
#       |---------|---------|
#       A         B         C
#     |---|     |---|     |---|
#    AA   AB   BA   BB   CA   CB
#  |----|         |----|
# AAA  AAB       BBA  BBB
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "A", "B", "B", "B", "C", "C"),
                       X2 = c("A", "A", "B", "A", "B", "B", "A", "B"),
                       X3 = c("A", "B", NA, NA, "A", "B", NA, NA),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
agg_mat &lt;- df2aggmat(~ X1 / X2 / X3, data_bts, sep = "", verbose = FALSE)

## Group of two hierarchies
#     T          T         T | A  | B  | C
#  |--|--|  X  |---|  -&gt;  ---+----+----+----
#  A  B  C     M   F       M | AM | BM | CM
#                          F | AF | BF | CF
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "B", "B", "C", "C"),
                       Y1 = c("M", "F", "M", "F", "M", "F"),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
agg_mat &lt;- df2aggmat(~ Y1 * X1, data_bts, sep = "", verbose = FALSE)

</code></pre>

<hr>
<h2 id='FoReco2matrix'>Reconciled forecasts to matrix/vector</h2><span id='topic+FoReco2matrix'></span>

<h3>Description</h3>

<p>This function splits the temporal vectors and the cross-temporal matrices in a
list according to the temporal aggregation order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FoReco2matrix(x, agg_order, keep_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FoReco2matrix_+3A_x">x</code></td>
<td>
<p>An output from any reconciliation function implemented by <span class="pkg">FoReco</span>.</p>
</td></tr>
<tr><td><code id="FoReco2matrix_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="FoReco2matrix_+3A_keep_names">keep_names</code></td>
<td>
<p>If <code>FALSE</code> (<em>default</em>), the rownames names of the output matrices are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices or vectors distinct by temporal aggregation order.
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4
base &lt;- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))

reco &lt;- ctrec(base = base, agg_mat = t(c(1,1)), agg_order = 4, comb = "ols")
matrix_list &lt;- FoReco2matrix(reco)
</code></pre>

<hr>
<h2 id='itagdp'>Italian Quarterly National Accounts</h2><span id='topic+itagdp'></span><span id='topic+outside'></span><span id='topic+expside'></span><span id='topic+incside'></span><span id='topic+gdpconsmat'></span>

<h3>Description</h3>

<p>A subset of the data used by Girolimetto et al. (2023) from the Italian Quarterly
National Accounts (output, income and expenditure sides) spanning the period
2000:Q1-2019:Q4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># 21 time series of the Italian Quarterly National Accounts
itagdp

# 'agg_mat' and 'cons_mat' for the output side
outside

# 'agg_mat' and 'cons_mat' for the expenditure side
expside

# 'agg_mat' and 'cons_mat' for the income side
incside

# zero constraints matrix encompassing output, expenditure and income sides
gdpconsmat
</code></pre>


<h3>Format</h3>

<p><code>itagdp</code> is a <code class="reqn">(80 \times 21)</code> <code>ts</code> object, corresponding to
21 time series of the Italian Quarterly National Accounts (2000:Q1-2019:Q4).
</p>
<p><code>outside</code>, <code>income</code> and <code>expenditure</code> are lists with two elements:
</p>

<ul>
<li><p><code>agg_mat</code> contains the <code class="reqn">(1 \times 2)</code>, <code class="reqn">(2 \times 4)</code>, or <code class="reqn">(6 \times 8)</code>
aggregation matrix according to output, income or expenditure side, respectively.
</p>
</li>
<li><p><code>cons_mat</code> contains the <code class="reqn">(1 \times 3)</code>, <code class="reqn">(2 \times 6)</code>, or <code class="reqn">(6 \times 14)</code>
zero constraints matrix according to output, income or expenditure side, respectively.
</p>
</li></ul>

<p><code>gdpconsmat</code> is the complete <code class="reqn">(9 \times 21)</code> zero constraints matrix
encompassing output, expenditure and income sides.
</p>


<h3>Source</h3>

<p><a href="https://ec.europa.eu/eurostat/web/national-accounts/">https://ec.europa.eu/eurostat/web/national-accounts/</a>
</p>


<h3>References</h3>

<p>Girolimetto, D. and Di Fonzo, T. (2023), Point and probabilistic forecast reconciliation
for general linearly constrained multiple time series,
<em>Statistical Methods &amp; Applications</em>, in press. <a href="https://doi.org/10.1007/s10260-023-00738-6">doi:10.1007/s10260-023-00738-6</a>.
</p>

<hr>
<h2 id='iterec'>Iterative cross-temporal reconciliation</h2><span id='topic+iterec'></span>

<h3>Description</h3>

<p>This function performs the iterative procedure described in Di Fonzo and Girolimetto (2023),
which produces cross-temporally reconciled forecasts by alternating forecast
reconciliation along one single dimension (either cross-sectional or temporal)
at each iteration step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterec(base, cslist, telist, res = NULL, itmax = 100, tol = 1e-5,
       type = "tcs", norm = "inf", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterec_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix containing the base forecasts to
be reconciled; <code class="reqn">n</code> is the total number of variables, <code class="reqn">m</code> is the max. order of temporal
aggregation, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>) factors of <code class="reqn">m</code>,
excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency time series.
The row identifies a time series, and the forecasts in each row are ordered from the
lowest frequency (most temporally aggregated) to the highest frequency.</p>
</td></tr>
<tr><td><code id="iterec_+3A_cslist">cslist</code></td>
<td>
<p>A list of elements for the cross-sectional reconciliation.
See <a href="#topic+csrec">csrec</a> for a complete list (excluded <code>base</code> and <code>res</code>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_telist">telist</code></td>
<td>
<p>A list of elements for the temporal reconciliation.
See <a href="#topic+terec">terec</a> for a complete list (excluded <code>base</code> and <code>res</code>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="iterec_+3A_itmax">itmax</code></td>
<td>
<p>Max number of iteration (<code>100</code>, <em>default</em>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance (<code>1e-5</code>, <em>default</em>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_type">type</code></td>
<td>
<p>A string specifying the uni-dimensional reconciliation order:
temporal and then cross-sectional (&quot;<code>tcs</code>&quot;) or cross-sectional and
then temporal (&quot;<code>cst</code>&quot;).</p>
</td></tr>
<tr><td><code id="iterec_+3A_norm">norm</code></td>
<td>
<p>Norm used to calculate the temporal and the cross-sectional
incoherence: infinity norm (&quot;<code>inf</code>&quot;, <em>default</em>), one norm (&quot;<code>one</code>&quot;), and
2-norm (&quot;<code>two</code>&quot;).</p>
</td></tr>
<tr><td><code id="iterec_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, reconciliation information are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>


<h3>See Also</h3>

<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4
base &lt;- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))
# (3 x 70) in-sample residuals matrix (simulated)
res &lt;- rbind(rnorm(70), rnorm(70), rnorm(70))

A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
m &lt;- 4 # from quarterly to annual temporal aggregation

rite &lt;- iterec(base = base,
               cslist = list(agg_mat = A, comb = "shr"),
               telist = list(agg_order = m, comb = "wlsv"),
               res = res)

</code></pre>

<hr>
<h2 id='lcmat'>Linear combination (aggregation) matrix for a general linearly constrained multiple time series</h2><span id='topic+lcmat'></span>

<h3>Description</h3>

<p>This function transforms a general (possibly redundant) zero constraints matrix into a
linear combination (aggregation) matrix <code class="reqn">\mathbf{A}_{cs}</code>.
When working with a general linearly constrained multiple (<code class="reqn">n</code>-variate)
time series, getting a linear combination matrix <code class="reqn">\mathbf{A}_{cs}</code> is a critical
step to obtain a structural-like representation such that
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}_{cs} = [\mathbf{I} \quad -\mathbf{A}],</code>
</p>

<p>where <code class="reqn">\mathbf{C}_{cs}</code> is the full rank zero constraints matrix (Girolimetto and
Di Fonzo, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcmat(cons_mat, method = "rref", tol = sqrt(.Machine$double.eps),
       verbose = FALSE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lcmat_+3A_cons_mat">cons_mat</code></td>
<td>
<p>A (<code class="reqn">r \times n</code>) numeric matrix representing the cross-sectional
zero constraints.</p>
</td></tr>
<tr><td><code id="lcmat_+3A_method">method</code></td>
<td>
<p>Method to use: &quot;<code>rref</code>&quot; for the Reduced Row Echelon
Form through Gauss-Jordan elimination (<em>default</em>), or &quot;<code>qr</code>&quot;
for the (pivoting) QR decomposition (Strang, 2019).</p>
</td></tr>
<tr><td><code id="lcmat_+3A_tol">tol</code></td>
<td>
<p>Tolerance for the &quot;<code>rref</code>&quot; or &quot;<code>qr</code>&quot; method.</p>
</td></tr>
<tr><td><code id="lcmat_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate steps are printed (<em>default</em> is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lcmat_+3A_sparse">sparse</code></td>
<td>
<p>Option to return a sparse matrix (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: (i) the linear combination (aggregation) matrix
(<code>agg_mat</code>) and (ii) the vector of the column permutations (<code>pivot</code>).
</p>


<h3>References</h3>

<p>Girolimetto, D. and Di Fonzo, T. (2023), Point and probabilistic forecast reconciliation
for general linearly constrained multiple time series,
<em>Statistical Methods &amp; Applications</em>, in press. <a href="https://doi.org/10.1007/s10260-023-00738-6">doi:10.1007/s10260-023-00738-6</a>.
</p>
<p>Strang, G. (2019), <em>Linear algebra and learning from data</em>, Wellesley, Cambridge Press.
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two hierarchy sharing the same top-level variable, but not sharing the bottom variables
#        X            X
#    |-------|    |-------|
#    A       B    C       D
#  |---|
# A1   A2
# 1) X = C + D,
# 2) X = A + B,
# 3) A = A1 + A2.
cons_mat &lt;- matrix(c(1,-1,-1,0,0,0,0,
               1,0,0,-1,-1,0,0,
               0,0,0,1,0,-1,-1), nrow = 3, byrow = TRUE)
obj &lt;- lcmat(cons_mat = cons_mat, verbose = TRUE)
agg_mat &lt;- obj$agg_mat # linear combination matrix
pivot &lt;- obj$pivot # Pivot vector

</code></pre>

<hr>
<h2 id='recoinfo'>Informations on the reconciliation process</h2><span id='topic+recoinfo'></span>

<h3>Description</h3>

<p>This function extracts reconciliation information from the output of any reconciled
function implemented by <span class="pkg">FoReco</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recoinfo(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recoinfo_+3A_x">x</code></td>
<td>
<p>An output from any reconciliation function implemented by <span class="pkg">FoReco</span>.</p>
</td></tr>
<tr><td><code id="recoinfo_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (<em>defaults</em>), reconciliation information are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following reconciliation process informations:
</p>
<table role = "presentation">
<tr><td><code>rfun</code></td>
<td>
<p>the reconciliation function.</p>
</td></tr>
<tr><td><code>cs_n</code></td>
<td>
<p>the cross-sectional number of variables.</p>
</td></tr>
<tr><td><code>te_set</code></td>
<td>
<p>the set of temporal aggregation orders.</p>
</td></tr>
<tr><td><code>forecast_horizon</code></td>
<td>
<p>the forecast horizon
(in temporal and cross-temporal frameworks, for the most temporally aggregated series).</p>
</td></tr>
<tr><td><code>framework</code></td>
<td>
<p>the reconciliation framework (cross-sectional, temporal or cross-temporal).</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>non-negative reconciled forecast convergence information.</p>
</td></tr>
<tr><td><code>lcc</code></td>
<td>
<p>list of level conditional reconciled forecasts (+ BU) for
<a href="#topic+cslcc">cslcc</a>, <a href="#topic+telcc">telcc</a> and <a href="#topic+ctlcc">ctlcc</a>.</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>if <code>TRUE</code>, all the forecasts are not negative.</p>
</td></tr>
<tr><td><code>comb</code></td>
<td>
<p>the covariance approximation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>

<hr>
<h2 id='res2matrix'>One-step and multi-step residuals</h2><span id='topic+res2matrix'></span><span id='topic+arrange_hres'></span>

<h3>Description</h3>

<p>These functions can be used to arrange residuals to reconcile temporal or
cross-temporal forecasts.
</p>
<p><a href="#topic+res2matrix">res2matrix</a> takes as input a set of temporal and cross-temporal residuals and
re-organizes them into a matrix where the rows correspond to different forecast
horizons, capturing the temporal dimension. Meanwhile, the columns are ordered
based on the specific arrangement as described in Di Fonzo and Girolimetto (2023).
</p>
<p><a href="#topic+arrange_hres">arrange_hres</a> takes as input a list of multi-step residuals and is
designed to organize them in accordance with their time order (Girolimetto et al.
2023). When applied, this function ensures that the sequence of multi-step
residuals aligns with the chronological order in which they occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res2matrix(res, agg_order)

arrange_hres(list_res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="res2matrix_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) numeric matrix (cross-temporal framework)
or an (<code class="reqn">N(k^\ast+m) \times 1</code>) numeric vector (temporal framework) representing
the in-sample residuals at all the temporal frequencies ordered from the lowest
frequency to the highest frequency (columns) for each variable (rows).</p>
</td></tr>
<tr><td><code id="res2matrix_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="res2matrix_+3A_list_res">list_res</code></td>
<td>
<p>A list of <code class="reqn">H</code> multi-step residuals. Each element in the list
can be either a (<code class="reqn">T \times 1</code>) vector (temporal framework) or a (<code class="reqn">T \times n</code>)
matrix (cross-temporal framework).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z_t</code>, <code class="reqn">t=1,\dots,T</code>, be a univariate time series. We can define the multi-step
residuals such us
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\varepsilon}_{h,t} = Z_{t+h} - \widehat{Z}_{t+h|t} \qquad h \le t \le T-h</code>
</p>

<p>where <code class="reqn">\widehat{Z}_{t+h|t}</code> is the <code class="reqn">h</code>-step fitted value, calculated as the <code class="reqn">h</code>-step ahead
forecast condition to the information up to time <code class="reqn">t</code>. Given the list of errors at different steps
</p>
<p style="text-align: center;"><code class="reqn">\left([\widehat{\varepsilon}_{1,1}, \; \dots, \; \widehat{\varepsilon}_{1,T}], \dots, [\widehat{\varepsilon}_{H,1}, \; \dots, \; \widehat{\varepsilon}_{H,T}]\right),</code>
</p>

<p><a href="#topic+arrange_hres">arrange_hres</a> returns a <code class="reqn">T</code>-vector with the residuals, organized in the following way:
</p>
<p style="text-align: center;"><code class="reqn">[\varepsilon_{1,1} \; \varepsilon_{2,2} \; \dots \; \varepsilon_{H,H} \; \varepsilon_{1,H+1} \; \dots \; \varepsilon_{H,T-H}]'</code>
</p>

<p>A similar organisation can be apply to a multivariate time series.
</p>


<h3>Value</h3>

<p><a href="#topic+res2matrix">res2matrix</a> returns a (<code class="reqn">N \times n(k^\ast + m)</code>) matrix, where <code class="reqn">n = 1</code>
for the temporal framework.
</p>
<p><a href="#topic+arrange_hres">arrange_hres</a> returns a (<code class="reqn">N(k^\ast+m) \times 1</code>) vector (temporal framework)
or a (<code class="reqn">n \times N(k^\ast+m)</code>) matrix  (cross-temporal framework) of multi-step residuals.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>
<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>

<hr>
<h2 id='shrink_estim'>Shrinkage of the covariance matrix</h2><span id='topic+shrink_estim'></span>

<h3>Description</h3>

<p>Shrinkage of the covariance matrix according to Schäfer and Strimmer (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_estim(x, mse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrink_estim_+3A_x">x</code></td>
<td>
<p>A numeric matrix containing the in-sample residuals.</p>
</td></tr>
<tr><td><code id="shrink_estim_+3A_mse">mse</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shrunk covariance matrix.
</p>


<h3>References</h3>

<p>Schäfer, J.L. and Strimmer, K. (2005), A shrinkage approach to large-scale
covariance matrix estimation and implications for functional genomics,
<em>Statistical Applications in Genetics and Molecular Biology</em>, 4, 1
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>

<hr>
<h2 id='tcsrec'>Heuristic cross-temporal reconciliation</h2><span id='topic+tcsrec'></span><span id='topic+cstrec'></span>

<h3>Description</h3>

<p><a href="#topic+tcsrec">tcsrec</a> replicates the procedure by Kourentzes and Athanasopoulos (2019):
(i) for each time series the forecasts at any temporal aggregation order are
reconciled using temporal hierarchies; (ii) time-by-time cross-sectional
reconciliation is performed; and (iii) the projection matrices obtained at
step (ii) are then averaged and used to cross-sectionally reconcile the
forecasts obtained at step (i). In <a href="#topic+cstrec">cstrec</a>, the order of application of the
two reconciliation steps (temporal first, then cross-sectional), is inverted
compared to <a href="#topic+tcsrec">tcsrec</a> (Di Fonzo and Girolimetto, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># First-temporal-then-cross-sectional forecast reconciliation
tcsrec(base, cslist, telist, res = NULL, avg = "KA")

# First-cross-sectional-then-temporal forecast reconciliation
cstrec(base, cslist, telist, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcsrec_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix containing the base forecasts to
be reconciled; <code class="reqn">n</code> is the total number of variables, <code class="reqn">m</code> is the max. order of temporal
aggregation, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>) factors of <code class="reqn">m</code>,
excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency time series.
The row identifies a time series, and the forecasts in each row are ordered from the
lowest frequency (most temporally aggregated) to the highest frequency.</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_cslist">cslist</code></td>
<td>
<p>A list of elements for the cross-sectional reconciliation.
See <a href="#topic+csrec">csrec</a> for a complete list (excluded <code>base</code> and <code>res</code>).</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_telist">telist</code></td>
<td>
<p>A list of elements for the temporal reconciliation.
See <a href="#topic+terec">terec</a> for a complete list (excluded <code>base</code> and <code>res</code>).</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">n \times N(k^\ast+m)</code>) optional numeric matrix containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency (columns) for each variable (rows). This matrix is used
to compute some covariance matrices.</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_avg">avg</code></td>
<td>
<p>If <code>avg = "KA"</code> (<em>default</em>), the final projection
matrix <code class="reqn">\mathbf{M}</code> is the one proposed by Kourentzes and
Athanasopoulos (2019), otherwise it is calculated as simple average of
all the involved projection matrices at step 2 of the procedure (see
Di Fonzo and Girolimetto, 2023).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">n \times h(k^\ast+m)</code>) numeric matrix of cross-temporal reconciled forecasts.
</p>


<h3>Warning</h3>

<p>The two-step heuristic reconciliation allows considering
non negativity constraints only in the first step. This means that non-negativity
is not guaranteed in the final reconciled values.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>
<p>Kourentzes, N. and Athanasopoulos, G. (2019), Cross-temporal coherent forecasts
for Australian tourism, <em>Annals of Tourism Research</em>, 75, 393-409.
<a href="https://doi.org/10.1016/j.annals.2019.02.001">doi:10.1016/j.annals.2019.02.001</a>
</p>


<h3>See Also</h3>

<p>Cross-temporal framework: 
<code><a href="#topic+ctboot">ctboot</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+ctcov">ctcov</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4
base &lt;- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),
              rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))
# (3 x 70) in-sample residuals matrix (simulated)
res &lt;- rbind(rnorm(70), rnorm(70), rnorm(70))

A &lt;- t(c(1,1)) # Aggregation matrix for Z = X + Y
m &lt;- 4 # from quarterly to annual temporal aggregation

rtcs &lt;- tcsrec(base = base,
               cslist = list(agg_mat = A, comb = "shr"),
               telist = list(agg_order = m, comb = "wlsv"),
               res = res)

rcst &lt;- tcsrec(base = base,
               cslist = list(agg_mat = A, comb = "shr"),
               telist = list(agg_order = m, comb = "wlsv"),
               res = res)

</code></pre>

<hr>
<h2 id='teboot'>Temporal joint block bootstrap</h2><span id='topic+teboot'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between different temporal aggregation orders (Girolimetto et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="teboot_+3A_model_list">model_list</code></td>
<td>
<p>A list of all the <code class="reqn">(k^\ast+m)</code> base forecasts models ordered
from the lowest frequency (most temporally aggregated) to the highest frequency.
A <code>simulate()</code> function for each model has to be available and implemented
according to the package <a href="https://CRAN.R-project.org/package=forecast"><span class="pkg">forecast</span></a>,
with the following mandatory parameters: <em>object</em>, <em>innov</em>,
<em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="teboot_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="teboot_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="teboot_+3A_block_size">block_size</code></td>
<td>
<p>Block size of the bootstrap, which is typically equivalent
to the forecast horizon for the most temporally aggregated series.</p>
</td></tr>
<tr><td><code id="teboot_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and
a (<code class="reqn">\text{boot\_size}\times (k^\ast+m)\text{block\_size}</code>) matrix.
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2023), Cross-temporal
probabilistic forecast reconciliation: Methodological and practical issues.
<em>International Journal of Forecasting</em>, in press. <a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Bootstrap samples: 
<code><a href="#topic+csboot">csboot</a>()</code>,
<code><a href="#topic+ctboot">ctboot</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>

<hr>
<h2 id='tebu'>Temporal bottom-up reconciliation</h2><span id='topic+tebu'></span>

<h3>Description</h3>

<p>Temporal bottom-up reconciled forecasts at any temporal aggregation level are computed by
appropriate aggregation of the high-frequency base forecasts, <code class="reqn">\widehat{\mathbf{x}}^{[1]}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\widetilde{\mathbf{x}} = \mathbf{S}_{te}\widehat{\mathbf{x}}^{[1]},</code>
</p>

<p>where <code class="reqn">\mathbf{S}_{te}</code> is the temporal structural matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tebu(base, agg_order, tew = "sum", sntz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tebu_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">hm \times 1</code>) numeric vector containing the high-frequency base forecasts;
<code class="reqn">m</code> is the max. temporal aggregation order, and <code class="reqn">h</code> is the forecast horizon for the
lowest frequency time series.</p>
</td></tr>
<tr><td><code id="tebu_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="tebu_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="tebu_+3A_sntz">sntz</code></td>
<td>
<p>If <code>TRUE</code>, the negative base forecasts are
set to zero before applying bottom-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h(k^\ast+m) \times 1</code>) numeric vector of temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Bottom-up reconciliation: 
<code><a href="#topic+csbu">csbu</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (4 x 1) high frequency base forecasts vector (simulated),
# agg_order = 4 (annual-quarterly)
hfts &lt;- rnorm(4, 5)

reco &lt;- tebu(base = hfts, agg_order = 4)

# Non negative reconciliation
hfts[4] &lt;- -hfts[4] # Making negative one of the quarterly base forecasts
nnreco &lt;- tebu(base = hfts, agg_order = 4, sntz = TRUE)

</code></pre>

<hr>
<h2 id='tecov'>Temporal covariance matrix approximation</h2><span id='topic+tecov'></span><span id='topic+tecov.default'></span><span id='topic+tecov.ols'></span><span id='topic+tecov.str'></span><span id='topic+tecov.wlsv'></span><span id='topic+tecov.wlsh'></span><span id='topic+tecov.acov'></span><span id='topic+tecov.strar1'></span><span id='topic+tecov.sar1'></span><span id='topic+tecov.har1'></span><span id='topic+tecov.shr'></span><span id='topic+tecov.sam'></span>

<h3>Description</h3>

<p>This function provides an approximation of the temporal base forecasts errors
covariance matrix using different reconciliation methods (see Di Fonzo and Girolimetto, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tecov(comb, agg_order = NULL, res = NULL, tew = "sum",
      mse = TRUE, shrink_fun = shrink_estim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tecov_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method.
</p>

<ul>
<li><p> Ordinary least squares:
</p>

<ul>
<li><p> &quot;<code>ols</code>&quot; (<em>default</em>) - identity error covariance.
</p>
</li></ul>

</li>
<li><p> Weighted least squares:
</p>

<ul>
<li><p> &quot;<code>str</code>&quot; - structural variances.
</p>
</li>
<li><p> &quot;<code>wlsh</code>&quot; - hierarchy variances (uses <code>res</code>).
</p>
</li>
<li><p> &quot;<code>wlsv</code>&quot; - series variances (uses <code>res</code>).
</p>
</li></ul>

</li>
<li><p> Generalized least squares (uses <code>res</code>):
</p>

<ul>
<li><p> &quot;<code>acov</code>&quot; - series auto-covariance.
</p>
</li>
<li><p> &quot;<code>strar1</code>&quot; - structural Markov covariance.
</p>
</li>
<li><p> &quot;<code>sar1</code>&quot; - series Markov covariance.
</p>
</li>
<li><p> &quot;<code>har1</code>&quot; - hierarchy Markov covariance.
</p>
</li>
<li><p> &quot;<code>shr</code>&quot;/&quot;<code>sam</code>&quot; - shrunk/sample covariance.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="tecov_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="tecov_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">N(k^\ast+m) \times 1</code>) optional numeric vector containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency. This vector is used to compute come covariance matrices.</p>
</td></tr>
<tr><td><code id="tecov_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="tecov_+3A_mse">mse</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</td></tr>
<tr><td><code id="tecov_+3A_shrink_fun">shrink_fun</code></td>
<td>
<p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>)</p>
</td></tr>
<tr><td><code id="tecov_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">(k^\ast+m) \times (k^\ast+m)</code>) symmetric matrix.
</p>


<h3>References</h3>

<p>Di Fonzo, T. and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39, 1, 39-57. <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>
</p>


<h3>See Also</h3>

<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (7 x 70) in-sample residuals matrix (simulated), agg_order = 4
res &lt;- rnorm(70)

cov1 &lt;- tecov("ols", agg_order = 4)                 # OLS methods
cov2 &lt;- tecov("str", agg_order = 4)                 # STRC methods
cov3 &lt;- tecov("wlsv", agg_order = 4, res = res)     # WLSv methods
cov4 &lt;- tecov("wlsh", agg_order = 4, res = res)     # WLSh methods
cov5 &lt;- tecov("acov", agg_order = 4, res = res)     # ACOV methods
cov6 &lt;- tecov("strar1", agg_order = 4, res = res)   # STRAR1 methods
cov7 &lt;- tecov("har1", agg_order = 4, res = res)     # HAR1 methods
cov8 &lt;- tecov("sar1", agg_order = 4, res = res)     # SAR1 methods
cov9 &lt;- tecov("shr", agg_order = 4, res = res)      # SHR methods
cov10 &lt;- tecov("sam", agg_order = 4, res = res)     # SAM methods

# Custom covariance matrix
tecov.ols2 &lt;- function(comb, x) diag(x)
tecov(comb = "ols2", x = 7) # == tecov("ols", agg_order = 4)

</code></pre>

<hr>
<h2 id='telcc'>Level conditional coherent reconciliation for temporal hierarchies</h2><span id='topic+telcc'></span>

<h3>Description</h3>

<p>This function implements a forecast reconciliation procedure inspired by the original proposal
by Hollyman et al. (2021) for temporal hierarchies. Level conditional coherent
reconciled forecasts are conditional on (i.e., constrained by) the base forecasts
of a specific upper level in the hierarchy (exogenous constraints). It also allows
handling the linear constraints linking the variables endogenously (Di Fonzo and
Girolimetto, 2022). The function can calculate Combined Conditional Coherent (CCC)
forecasts as simple averages of Level-Conditional Coherent (LCC) and bottom-up
reconciled forecasts, with either endogenous or exogenous constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>telcc(base, agg_order, comb = "ols", res = NULL, CCC = TRUE,
      const = "exogenous", hfts = NULL, tew = "sum",
      approach = "proj", nn = NULL, settings = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="telcc_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h(k^\ast + m) \times 1</code>) numeric vector containing base forecasts
to be reconciled ordered from the lowest frequency to the highest frequency; <code class="reqn">m</code>
is the max aggregation order, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>)
factors of <code class="reqn">m</code>, excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the
lowest frequency time series.</p>
</td></tr>
<tr><td><code id="telcc_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="telcc_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+tecov">tecov</a>.</p>
</td></tr>
<tr><td><code id="telcc_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">N(k^\ast+m) \times 1</code>) optional numeric vector containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency. This vector is used to compute come covariance matrices.</p>
</td></tr>
<tr><td><code id="telcc_+3A_ccc">CCC</code></td>
<td>
<p>A logical value indicating whether the Combined Conditional Coherent reconciled
forecasts reconciliation should include bottom-up forecasts (<code>TRUE</code>, <em>default</em>), or not.</p>
</td></tr>
<tr><td><code id="telcc_+3A_const">const</code></td>
<td>
<p>A string specifying the reconciliation constraints:
</p>

<ul>
<li><p> &quot;<code>exogenous</code>&quot; (<em>default</em>): Fixes the top level of each sub-hierarchy.
</p>
</li>
<li><p> &quot;<code>endogenous</code>&quot;: Coherently revises both the top and bottom levels.
</p>
</li></ul>
</td></tr>
<tr><td><code id="telcc_+3A_hfts">hfts</code></td>
<td>
<p>A (<code class="reqn">mh \times 1</code>) numeric vector containing high frequency base forecasts defined
by the user. This parameter can be omitted if only base forecasts in
<code>base</code> are used (see Di Fonzo and Girolimetto, 2024).</p>
</td></tr>
<tr><td><code id="telcc_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="telcc_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="telcc_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="telcc_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="telcc_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+tecov">tecov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h(k^\ast+m) \times 1</code>) numeric vector of temporal reconciled forecasts.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2024), Forecast combination-based forecast reconciliation:
Insights and extensions, <em>International Journal of Forecasting</em>, 40(2), 490–514.
<a href="https://doi.org/10.1016/j.ijforecast.2022.07.001">doi:10.1016/j.ijforecast.2022.07.001</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023b) Spatio-temporal reconciliation of solar forecasts.
<em>Solar Energy</em> 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Hollyman, R., Petropoulos, F. and Tipping, M.E. (2021), Understanding forecast reconciliation.
<em>European Journal of Operational Research</em>, 294, 149–160. <a href="https://doi.org/10.1016/j.ejor.2021.01.017">doi:10.1016/j.ejor.2021.01.017</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>


<h3>See Also</h3>

<p>Level conditional coherent reconciliation: 
<code><a href="#topic+cslcc">cslcc</a>()</code>,
<code><a href="#topic+ctlcc">ctlcc</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (7 x 1) base forecasts vector (simulated), agg_order = 4
base &lt;- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4)))
# (70 x 1) in-sample residuals vector (simulated)
res &lt;- rnorm(70)
# (4 x 1) Naive high frequency base forecasts vector: all forecasts are set equal to 2.5
naive &lt;- rep(2.5, 4)

## EXOGENOUS CONSTRAINTS
# Level Conditional Coherent (LCC) reconciled forecasts
exo_LC &lt;- telcc(base = base, agg_order = 4, comb = "wlsh", hfts = naive,
                res = res, nodes = "auto", CCC = FALSE)

# Combined Conditional Coherent (CCC) reconciled forecasts
exo_CCC &lt;- telcc(base = base, agg_order = 4, comb = "wlsh", hfts = naive,
                 res = res, nodes = "auto", CCC = TRUE)

# Results detailed by level:
info_exo &lt;- recoinfo(exo_CCC, verbose = FALSE)
# info_exo$lcc

## ENDOGENOUS CONSTRAINTS
# Level Conditional Coherent (LCC) reconciled forecasts
endo_LC &lt;- telcc(base = base, agg_order = 4, comb = "wlsh", res = res,
                 nodes = "auto", CCC = FALSE, const = "endogenous")

# Combined Conditional Coherent (CCC) reconciled forecasts
endo_CCC &lt;- telcc(base = base, agg_order = 4, comb = "wlsh", res = res,
                  nodes = "auto", CCC = TRUE, const = "endogenous")

# Results detailed by level:
info_endo &lt;- recoinfo(endo_CCC, verbose = FALSE)
# info_endo$lcc

</code></pre>

<hr>
<h2 id='temo'>Temporal middle-out reconciliation</h2><span id='topic+temo'></span>

<h3>Description</h3>

<p>The middle-out forecast reconciliation for temporal hierarchies
combines top-down (<a href="#topic+tetd">tetd</a>) and bottom-up (<a href="#topic+tebu">tebu</a>) methods. Given
the base forecasts of an intermediate temporal aggregation order <code class="reqn">k</code>, it performs
</p>

<ul>
<li><p> a top-down approach for the aggregation orders <code class="reqn">&lt;k</code>;
</p>
</li>
<li><p> a bottom-up approach for the aggregation orders <code class="reqn">&gt;k</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>temo(base, agg_order, order = max(agg_order), weights, tew = "sum",
     normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temo_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">hk \times 1</code>) numeric vector containing the temporal
aggregated base forecasts of order <code class="reqn">k</code>; <code class="reqn">k</code> is an aggregation
order (a factor of <code class="reqn">m</code>, and <code class="reqn">1&lt;k&lt;m</code>), <code class="reqn">m</code> is the max aggregation
order, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="temo_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="temo_+3A_order">order</code></td>
<td>
<p>The intermediate fixed aggregation order <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="temo_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">hm \times 1</code>) numeric vector containing the proportions for the
high-frequency time series; <code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is the
forecast horizon for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="temo_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="temo_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h(k^\ast+m) \times 1</code>) numeric vector of temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Middle-out reconciliation: 
<code><a href="#topic+csmo">csmo</a>()</code>,
<code><a href="#topic+ctmo">ctmo</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (6 x 1) base forecasts vector (simulated), forecast horizon = 3
# and intermediate aggregation order k = 2 (max agg order = 4)
basek2 &lt;- rnorm(3*2, 5)
# Same weights for different forecast horizons
fix_weights &lt;- runif(4)
reco &lt;- temo(base = basek2, order = 2, agg_order = 4, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- runif(4*3)
recoh &lt;- temo(base = basek2, order = 2, agg_order = 4, weights = h_weights)

</code></pre>

<hr>
<h2 id='teprojmat'>Projection matrix for optimal combination temporal reconciliation</h2><span id='topic+teprojmat'></span>

<h3>Description</h3>

<p>This function computes the projection or the mapping matrix
<code class="reqn">\mathbf{M}</code> and <code class="reqn">\mathbf{G}</code>, respectively, such that
<code class="reqn">\widetilde{\mathbf{y}} = \mathbf{M}\widehat{\mathbf{y}} = \mathbf{S}_{te}\mathbf{G}\widehat{\mathbf{y}}</code>,
where <code class="reqn">\widetilde{\mathbf{y}}</code> is the vector of the reconciled forecasts,
<code class="reqn">\widehat{\mathbf{y}}</code> is the vector of the base forecasts,
<code class="reqn">\mathbf{S}_{te}</code> is the temporal structural matrix, and <code class="reqn">\mathbf{M} = \mathbf{S}_{te}\mathbf{G}</code>.
For further information regarding on the structure of these matrices,
refer to Girolimetto et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teprojmat(agg_order, comb = "ols", res = NULL, mat = "M", tew = "sum", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="teprojmat_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="teprojmat_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+tecov">tecov</a>.</p>
</td></tr>
<tr><td><code id="teprojmat_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">N(k^\ast+m) \times 1</code>) optional numeric vector containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency. This vector is used to compute come covariance matrices.</p>
</td></tr>
<tr><td><code id="teprojmat_+3A_mat">mat</code></td>
<td>
<p>A string specifying which matrix to return:
&quot;<code>M</code>&quot; (<em>default</em>) for <code class="reqn">\mathbf{M}</code> and &quot;<code>G</code>&quot; for <code class="reqn">\mathbf{G}</code>.</p>
</td></tr>
<tr><td><code id="teprojmat_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="teprojmat_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+tecov">tecov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The projection matrix <code class="reqn">\mathbf{M}</code> (<code>mat = "M"</code>) or
the mapping matrix <code class="reqn">\mathbf{G}</code> (<code>mat = "G"</code>).
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>, 40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Temporal framework (annual-quarterly)
Mte &lt;- teprojmat(agg_order = 4, comb = "ols")
Gte &lt;- teprojmat(agg_order = 4, comb = "ols", mat = "G")

</code></pre>

<hr>
<h2 id='terec'>Optimal combination temporal reconciliation</h2><span id='topic+terec'></span>

<h3>Description</h3>

<p>This function performs forecast reconciliation for a single time series using temporal
hierarchies (Athanasopoulos et al., 2017, Nystrup et al., 2020). The reconciled forecasts can be computed
using either a projection approach (Byron, 1978, 1979) or the equivalent structural
approach by Hyndman et al. (2011). Non-negative (Di Fonzo and Girolimetto, 2023)
and immutable reconciled forecasts can be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terec(base, agg_order, comb = "ols", res = NULL, tew = "sum",
      approach = "proj", nn = NULL, settings = NULL, bounds = NULL,
      immutable = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terec_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">h(k^\ast + m) \times 1</code>) numeric vector containing base forecasts
to be reconciled ordered from the lowest frequency to the highest frequency; <code class="reqn">m</code>
is the max aggregation order, <code class="reqn">k^\ast</code> is the sum of (a subset of) (<code class="reqn">p-1</code>)
factors of <code class="reqn">m</code>, excluding <code class="reqn">m</code>, and <code class="reqn">h</code> is the forecast horizon for the
lowest frequency time series.</p>
</td></tr>
<tr><td><code id="terec_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="terec_+3A_comb">comb</code></td>
<td>
<p>A string specifying the reconciliation method. For a complete list, see <a href="#topic+tecov">tecov</a>.</p>
</td></tr>
<tr><td><code id="terec_+3A_res">res</code></td>
<td>
<p>A (<code class="reqn">N(k^\ast+m) \times 1</code>) optional numeric vector containing the
in-sample residuals at all the temporal frequencies ordered from the lowest frequency
to the highest frequency. This vector is used to compute come covariance matrices.</p>
</td></tr>
<tr><td><code id="terec_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="terec_+3A_approach">approach</code></td>
<td>
<p>A string specifying the approach used to compute the reconciled
forecasts. Options include:
</p>

<ul>
<li><p> &quot;<code>proj</code>&quot; (<em>default</em>): Projection approach according to Byron (1978, 1979).
</p>
</li>
<li><p> &quot;<code>strc</code>&quot;: Structural approach as proposed by Hyndman et al. (2011).
</p>
</li>
<li><p> &quot;<code>proj_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for projection approach.
</p>
</li>
<li><p> &quot;<code>strc_osqp</code>&quot;: Numerical solution using <a href="https://osqp.org/"><span class="pkg">osqp</span></a>
for structural approach.
</p>
</li></ul>
</td></tr>
<tr><td><code id="terec_+3A_nn">nn</code></td>
<td>
<p>A string specifying the algorithm to compute non-negative reconciled forecasts:
</p>

<ul>
<li><p> &quot;<code>osqp</code>&quot;: quadratic programming optimization
(<a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver).
</p>
</li>
<li><p> &quot;<code>sntz</code>&quot;: heuristic &quot;set-negative-to-zero&quot; (Di Fonzo and Girolimetto, 2023).
</p>
</li></ul>
</td></tr>
<tr><td><code id="terec_+3A_settings">settings</code></td>
<td>
<p>An object of class <code>osqpSettings</code> specifying settings
for the <a href="https://osqp.org/"><span class="pkg">osqp</span></a> solver. For details, refer to the
<a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a> (Stellato et al., 2020).</p>
</td></tr>
<tr><td><code id="terec_+3A_bounds">bounds</code></td>
<td>
<p>A (<code class="reqn">(k^\ast + m) \times 2</code>) numeric matrix specifying the
temporal bounds. The first column represents the lower bound, and the
second column represents the upper bound.</p>
</td></tr>
<tr><td><code id="terec_+3A_immutable">immutable</code></td>
<td>
<p>A matrix with two columns (<code class="reqn">k,j</code>), such that
</p>

<dl>
<dt>Column 1</dt><dd><p>Denotes the temporal aggregation order (<code class="reqn">k = m,\dots,1</code>).</p>
</dd>
<dt>Column 2</dt><dd><p>Indicates the temporal forecast horizon (<code class="reqn">j = 1,\dots,m/k</code>).</p>
</dd>
</dl>

<p>For example, when working with a quarterly time series:
</p>

<ul>
<li> <p><code>t(c(4, 1))</code> - Fix the one step ahead annual forecast.
</p>
</li>
<li> <p><code>t(c(1, 2))</code> - Fix the two step ahead quarterly forecast.
</p>
</li></ul>
</td></tr>
<tr><td><code id="terec_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+tecov">tecov</a></code>
</p>

<dl>
<dt><code>mse</code></dt><dd><p>If <code>TRUE</code> (<em>default</em>) the residuals used to compute the covariance
matrix are not mean-corrected.</p>
</dd>
<dt><code>shrink_fun</code></dt><dd><p>Shrinkage function of the covariance matrix, <a href="#topic+shrink_estim">shrink_estim</a> (<em>default</em>)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h(k^\ast+m) \times 1</code>) numeric vector of temporal reconciled forecasts.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Hyndman, R.J., Kourentzes, N. and Petropoulos, F. (2017),
Forecasting with Temporal Hierarchies, <em>European Journal of Operational
Research</em>, 262, 1, 60-74. <a href="https://doi.org/10.1016/j.ejor.2017.02.046">doi:10.1016/j.ejor.2017.02.046</a>
</p>
<p>Byron, R.P. (1978), The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 141, 3, 359-367.
<a href="https://doi.org/10.2307/2344807">doi:10.2307/2344807</a>
</p>
<p>Byron, R.P. (1979), Corrigenda: The estimation of large social account matrices,
<em>Journal of the Royal Statistical Society, Series A</em>, 142(3), 405.
<a href="https://doi.org/10.2307/2982515">doi:10.2307/2982515</a>
</p>
<p>Di Fonzo, T. and Girolimetto, D. (2023), Spatio-temporal reconciliation of solar
forecasts, <em>Solar Energy</em>, 251, 13–29. <a href="https://doi.org/10.1016/j.solener.2023.01.003">doi:10.1016/j.solener.2023.01.003</a>
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G. and Shang, H.L. (2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
<a href="https://doi.org/10.1016/j.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>
</p>
<p>Nystrup, P.,  Lindström, E., Pinson, P. and Madsen, H. (2020),
Temporal hierarchies with autocorrelation for load forecasting,
<em>European Journal of Operational Research</em>, 280, 1, 876-888.
<a href="https://doi.org/10.1016/j.ejor.2019.07.061">doi:10.1016/j.ejor.2019.07.061</a>
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A. and Boyd, S. (2020), OSQP:
An Operator Splitting solver for Quadratic Programs,
<em>Mathematical Programming Computation</em>, 12, 4, 637-672.
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</p>


<h3>See Also</h3>

<p>Regression-based reconciliation: 
<code><a href="#topic+csrec">csrec</a>()</code>,
<code><a href="#topic+ctrec">ctrec</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (7 x 1) base forecasts vector (simulated), m = 4
base &lt;- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4)))
# (70 x 1) in-sample residuals vector (simulated)
res &lt;- rnorm(70)

m &lt;- 4 # from quarterly to annual temporal aggregation
reco &lt;- terec(base = base, agg_order = m, comb = "wlsv", res = res)

# Immutable reconciled forecast
# E.g. fix all the quarterly forecasts
imm_q &lt;- expand.grid(k = 1, j = 1:4)
immreco &lt;- terec(base = base, agg_order = m, comb = "wlsv",
                 res = res, immutable = imm_q)

# Non negative reconciliation
base[7] &lt;- -base[7] # Making negative one of the quarterly base forecasts
nnreco &lt;- terec(base = base, agg_order = m, comb = "wlsv",
                res = res, nn = "osqp")
recoinfo(nnreco, verbose = FALSE)$info

</code></pre>

<hr>
<h2 id='tetd'>Temporal top-down reconciliation</h2><span id='topic+tetd'></span>

<h3>Description</h3>

<p>Top-down forecast reconciliation for a univariate time series, where the forecast
of the most aggregated temporal level is disaggregated according to a proportional
scheme (weights). Besides fulfilling any aggregation constraint, the
top-down reconciled forecasts should respect two main properties:
</p>

<ul>
<li><p> the top-level value remains unchanged;
</p>
</li>
<li><p> all the bottom time series reconciled forecasts are non-negative.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tetd(base, agg_order, weights, tew = "sum", normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tetd_+3A_base">base</code></td>
<td>
<p>A (<code class="reqn">hm \times 1</code>) numeric vector containing the temporal
aggregated base forecasts of order <code class="reqn">m</code>; <code class="reqn">m</code> is the max aggregation
order, and <code class="reqn">h</code> is the forecast horizon for the lowest frequency
time series.</p>
</td></tr>
<tr><td><code id="tetd_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="tetd_+3A_weights">weights</code></td>
<td>
<p>A (<code class="reqn">hm \times 1</code>) numeric vector containing the proportions for the
high-frequency time series; <code class="reqn">m</code> is the max aggregation order, and <code class="reqn">h</code> is the
forecast horizon for the lowest frequency time series.</p>
</td></tr>
<tr><td><code id="tetd_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="tetd_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (<em>default</em>), the <code>weights</code> will sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">h(k^\ast+m) \times 1</code>) numeric vector of temporal reconciled forecasts.
</p>


<h3>See Also</h3>

<p>Top-down reconciliation: 
<code><a href="#topic+cstd">cstd</a>()</code>,
<code><a href="#topic+cttd">cttd</a>()</code>
</p>
<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# (2 x 1) top base forecasts vector (simulated), forecast horizon = 2
topf &lt;- rnorm(2, 10)
# Same weights for different forecast horizons
fix_weights &lt;- runif(4)
reco &lt;- tetd(base = topf, agg_order = 4, weights = fix_weights)

# Different weights for different forecast horizons
h_weights &lt;- runif(4*2)
recoh &lt;- tetd(base = topf, agg_order = 4, weights = h_weights)

</code></pre>

<hr>
<h2 id='tetools'>Temporal reconciliation tools</h2><span id='topic+tetools'></span>

<h3>Description</h3>

<p>Some useful tools for forecast reconciliation through temporal hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tetools(agg_order, fh = 1, tew = "sum", sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tetools_+3A_agg_order">agg_order</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, <code class="reqn">m</code>), or a vector representing a subset of <code class="reqn">p</code> factors
of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="tetools_+3A_fh">fh</code></td>
<td>
<p>Forecast horizon for the lowest frequency (most temporally aggregated)
time series (<em>default</em> is <code>1</code>).</p>
</td></tr>
<tr><td><code id="tetools_+3A_tew">tew</code></td>
<td>
<p>A string specifying the type of temporal aggregation. Options include:
&quot;<code>sum</code>&quot; (simple summation, <em>default</em>), &quot;<code>avg</code>&quot; (average),
&quot;<code>first</code>&quot; (first value of the period), and &quot;<code>last</code>&quot;
(last value of the period).</p>
</td></tr>
<tr><td><code id="tetools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements:
</p>
<table role = "presentation">
<tr><td><code>dim</code></td>
<td>
<p>A vector containing information about the maximum aggregation order
(<code>m</code>), the number of factor (<code>p</code>), the partial (<code>ks</code>) and total
sum (<code>kt</code>) of factors.</p>
</td></tr>
<tr><td><code>set</code></td>
<td>
<p>The vector of the temporal aggregation orders (in decreasing order).</p>
</td></tr>
<tr><td><code>agg_mat</code></td>
<td>
<p>The temporal linear combination or aggregation matrix.</p>
</td></tr>
<tr><td><code>strc_mat</code></td>
<td>
<p>The temporal structural matrix.</p>
</td></tr>
<tr><td><code>cons_mat</code></td>
<td>
<p>The temporal zero constraints matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Temporal framework: 
<code><a href="#topic+teboot">teboot</a>()</code>,
<code><a href="#topic+tebu">tebu</a>()</code>,
<code><a href="#topic+tecov">tecov</a>()</code>,
<code><a href="#topic+telcc">telcc</a>()</code>,
<code><a href="#topic+temo">temo</a>()</code>,
<code><a href="#topic+terec">terec</a>()</code>,
<code><a href="#topic+tetd">tetd</a>()</code>
</p>
<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+unbalance_hierarchy">unbalance_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Temporal framework (quarterly data)
obj &lt;- tetools(agg_order = 4, sparse = FALSE)

</code></pre>

<hr>
<h2 id='unbalance_hierarchy'>Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form</h2><span id='topic+unbalance_hierarchy'></span>

<h3>Description</h3>

<p>A hierarchy with <code class="reqn">L</code> upper levels is said to be balanced if each variable at level
<code class="reqn">l</code> has at least one child at level <code class="reqn">l+1</code>. When this doesn't hold, the
hierarchy is unbalanced.
This function transforms an aggregation matrix of a balanced hierarchy
into an aggregation matrix of an unbalanced one, by removing possible duplicated series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbalance_hierarchy(agg_mat, more_info = FALSE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unbalance_hierarchy_+3A_agg_mat">agg_mat</code></td>
<td>
<p>A (<code class="reqn">n_a \times n_b</code>) numeric matrix representing the cross-sectional
aggregation matrix. It maps the <code class="reqn">n_b</code> bottom-level (free)
variables into the <code class="reqn">n_a</code> upper (constrained) variables.</p>
</td></tr>
<tr><td><code id="unbalance_hierarchy_+3A_more_info">more_info</code></td>
<td>
<p>If <code>TRUE</code>, it returns only the aggregation matrix
of the unbalanced hierarchy. <em>Default</em> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unbalance_hierarchy_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing four
elements (<code>more_info = TRUE</code>):
</p>
<table role = "presentation">
<tr><td><code>ubm</code></td>
<td>
<p>The aggregation matrix of the unbalanced hierarchy.</p>
</td></tr>
<tr><td><code>agg_mat</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
<tr><td><code>idrm</code></td>
<td>
<p>The identification number of the duplicated variables (row numbers of
the aggregation matrix <code>agg_mat</code>).</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>The identification number of each variable in the balanced hierarchy.
It may contains duplicated values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities: 
<code><a href="#topic+FoReco2matrix">FoReco2matrix</a>()</code>,
<code><a href="#topic+aggts">aggts</a>()</code>,
<code><a href="#topic+balance_hierarchy">balance_hierarchy</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+csprojmat">csprojmat</a>()</code>,
<code><a href="#topic+cstools">cstools</a>()</code>,
<code><a href="#topic+ctprojmat">ctprojmat</a>()</code>,
<code><a href="#topic+cttools">cttools</a>()</code>,
<code><a href="#topic+df2aggmat">df2aggmat</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+recoinfo">recoinfo</a>()</code>,
<code><a href="#topic+res2matrix">res2matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+teprojmat">teprojmat</a>()</code>,
<code><a href="#topic+tetools">tetools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#     Balanced     -&gt;     Unbalanced
#        T                    T
#    |-------|            |-------|
#    A       B            A       |
#  |---|     |          |---|     |
# AA   AB    BA        AA   AB    BA
A &lt;- matrix(c(1, 1, 1,
              1, 1, 0,
              0, 0, 1), 3, byrow = TRUE)
obj &lt;- unbalance_hierarchy(agg_mat = A)
obj
</code></pre>

<hr>
<h2 id='vndata'>Australian Tourism Demand dataset</h2><span id='topic+vndata'></span><span id='topic+vnaggmat'></span>

<h3>Description</h3>

<p>The Australian Tourism Demand dataset (Wickramasuriya et al. 2019) measures the number of
nights Australians spent away from home. It includes 228 monthly observations of Visitor
Nights (VNs) from January 1998 to December 2016, and has a cross-sectional grouped
structure based on a geographic hierarchy crossed by purpose of travel. The geographic
hierarchy comprises 7 states, 27 zones, and 76 regions, for a total of 111 nested geographic
divisions. Six of these zones are each formed by a single region, resulting in 105 unique
nodes in the hierarchy. The purpose of travel comprises four categories: holiday, visiting
friends and relatives, business, and other. To avoid redundancies (Girolimetto et al. 2023),
24 nodes (6 zones are formed by a single region) are not considered, resulting in an unbalanced
hierarchy of 525 (304 bottom and 221 upper time series) unique nodes instead of the theoretical
555 with duplicated nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># 525 time series of the Australian Tourism Demand dataset
vndata

# aggregation matrix
vnaggmat
</code></pre>


<h3>Format</h3>

<p><code>vndata</code> is a <code class="reqn">(228 \times 525)</code> <code>ts</code> object, corresponding to
525 time series of the Australian Tourism Demand dataset (1998:01-2016:12).
</p>
<p><code>vnaggmat</code> is the <code class="reqn">(221 \times 304)</code> aggregation matrix.
</p>


<h3>Source</h3>

<p><a href="https://robjhyndman.com/publications/mint/">https://robjhyndman.com/publications/mint/</a>
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. and Hyndman, R.J. (2024),
Cross-temporal probabilistic forecast reconciliation: Methodological and
practical issues. <em>International Journal of Forecasting</em>,  40, 3, 1134-1151.
<a href="https://doi.org/10.1016/j.ijforecast.2023.10.003">doi:10.1016/j.ijforecast.2023.10.003</a>
</p>
<p>Wickramasuriya, S.L., Athanasopoulos, G. and Hyndman, R.J. (2019), Optimal forecast
reconciliation for hierarchical and grouped time series through trace minimization,
<em>Journal of the American Statistical Association</em>, 114, 526, 804-819.
<a href="https://doi.org/10.1080/01621459.2018.1448825">doi:10.1080/01621459.2018.1448825</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
