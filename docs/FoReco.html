<!DOCTYPE html><html><head><title>Help for package FoReco</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FoReco}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FoReco-package'><p>FoReco: forecast reconciliation</p></a></li>
<li><a href='#agg_ts'><p>Non-overlapping temporal aggregation of a time series</p></a></li>
<li><a href='#arrange_hres'><p>Re-arrange the multi-step residuals</p></a></li>
<li><a href='#boot_cs'><p>Cross-sectional Joint Bootstrap</p></a></li>
<li><a href='#boot_ct'><p>Cross-temporal Joint Bootstrap</p></a></li>
<li><a href='#boot_te'><p>Temporal Joint Bootstrap</p></a></li>
<li><a href='#Cmatrix'><p>Cross-sectional (contemporaneous) aggregation matrix</p></a></li>
<li><a href='#commat'><p>Commutation matrix</p></a></li>
<li><a href='#cstrec'><p>Heuristic first-cross-sectional-then-temporal cross-temporal forecast reconciliation</p></a></li>
<li><a href='#ctbu'><p>Bottom-up cross-temporal forecast reconciliation</p></a></li>
<li><a href='#ctf_tools'><p>Cross-temporal reconciliation tools</p></a></li>
<li><a href='#FoReco_data'><p>Forecast reconciliation for a simulated linearly constrained, genuine hierarchical multiple time series</p></a></li>
<li><a href='#FoReco-hts'><p>Simple examples to compare <code>FoReco</code> and <code>hts</code> packages</p></a></li>
<li><a href='#FoReco-thief'><p>Simple examples to compare <code>FoReco</code> and <code>thief</code> packages</p></a></li>
<li><a href='#FoReco2ts'><p>Reconciled forecasts matrix/vector to time-series class</p></a></li>
<li><a href='#hts_tools'><p>Cross-sectional reconciliation tools</p></a></li>
<li><a href='#htsrec'><p>Cross-sectional (contemporaneous) forecast reconciliation</p></a></li>
<li><a href='#iterec'><p>Iterative heuristic cross-temporal forecast reconciliation</p></a></li>
<li><a href='#lccrec'><p>Level conditional coherent forecast reconciliation for genuine hierarchical/grouped time series</p></a></li>
<li><a href='#lcmat'><p>Linear Combination Matrix for a general linearly constrained multiple time series</p></a></li>
<li><a href='#oct_bounds'><p>Optimal cross-temporal bounds</p></a></li>
<li><a href='#octrec'><p>Optimal combination cross-temporal forecast reconciliation</p></a></li>
<li><a href='#residuals_matrix'><p>Arrange temporal and cross-temporal residuals in a matrix form</p></a></li>
<li><a href='#score_index'><p>Measuring accuracy in a rolling forecast experiment</p></a></li>
<li><a href='#shrink_estim'><p>Shrinkage of the covariance matrix</p></a></li>
<li><a href='#tcsrec'><p>Heuristic first-temporal-then-cross-sectional cross-temporal forecast reconciliation</p></a></li>
<li><a href='#tdrec'><p>Top-down forecast reconciliation for genuine hierarchical/grouped time series</p></a></li>
<li><a href='#thf_tools'><p>Temporal reconciliation tools</p></a></li>
<li><a href='#thfrec'><p>Forecast reconciliation through temporal hierarchies (temporal reconciliation)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecast Reconciliation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Classical (bottom-up and top-down), optimal and heuristic combination forecast 
    point (Di Fonzo and Girolimetto, 2023) &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>&gt; and 
    probabilistic (Girolimetto et al. 2023) &lt;<a href="https://doi.org/10.48550/arXiv.2303.17277">doi:10.48550/arXiv.2303.17277</a>&gt; reconciliation procedures 
    for cross-sectional, temporal, and cross-temporal linearly constrained time series.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/daniGiro/FoReco">https://github.com/daniGiro/FoReco</a>,
<a href="https://danigiro.github.io/FoReco/">https://danigiro.github.io/FoReco/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daniGiro/FoReco/issues">https://github.com/daniGiro/FoReco/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), Matrix, osqp, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, corpcor, methods, mathjaxr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-16 08:06:14 UTC; daniele</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniele Girolimetto
    <a href="https://orcid.org/0000-0001-9387-1232"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    fnd],
  Tommaso Di Fonzo <a href="https://orcid.org/0000-0003-3388-7827"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniele Girolimetto &lt;daniele.girolimetto@phd.unipd.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-16 08:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='FoReco-package'>FoReco: forecast reconciliation</h2><span id='topic+FoReco-package'></span>

<h3>Description</h3>

<p>An R package offering classical (bottom-up and top-down), and modern (optimal and heuristic combination)
forecast reconciliation procedures for cross-sectional, temporal, and cross-temporal
linearly constrained time series.
</p>


<h3>Details</h3>

<p>The <code>FoReco</code> package is designed for forecast reconciliation, a
post-forecasting process aimed to improve the accuracy of the base
forecasts for a system of linearly constrained (e.g. hierarchical/grouped) time series.
The main functions are:
</p>

<dl>
<dt><code><a href="#topic+htsrec">htsrec</a>():</code></dt><dd><p>cross-sectional (contemporaneous) forecast reconciliation.</p>
</dd>
<dt><code><a href="#topic+thfrec">thfrec</a>():</code></dt><dd><p>forecast reconciliation for a single time series through temporal hierarchies.</p>
</dd>
<dt><code><a href="#topic+lccrec">lccrec</a>():</code></dt><dd><p>level conditional forecast reconciliation for genuine hierarchical/grouped time series.</p>
</dd>
<dt><code><a href="#topic+tdrec">tdrec</a>():</code></dt><dd><p>top-down (cross-sectional, temporal, cross-temporal) forecast reconciliation for genuine hierarchical/grouped time series.</p>
</dd>
<dt><code><a href="#topic+ctbu">ctbu</a>():</code></dt><dd><p>bottom-up cross-temporal forecast reconciliation.</p>
</dd>
<dt><code><a href="#topic+tcsrec">tcsrec</a>():</code></dt><dd><p>heuristic first-temporal-then-cross-sectional cross-temporal forecast reconciliation.</p>
</dd>
<dt><code><a href="#topic+cstrec">cstrec</a>():</code></dt><dd><p>heuristic first-cross-sectional-then-temporal cross-temporal forecast reconciliation.</p>
</dd>
<dt><code><a href="#topic+iterec">iterec</a>():</code></dt><dd><p>heuristic iterative cross-temporal forecast reconciliation.</p>
</dd>
<dt><code><a href="#topic+octrec">octrec</a>():</code></dt><dd><p>optimal combination cross-temporal forecast reconciliation.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tommaso Di Fonzo and Daniele Girolimetto, Department of Statistical Sciences, University of Padua (Italy).
</p>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57 <a href="https://doi.org/10.1016/j.ijforecast.2021.08.004">doi:10.1016/j.ijforecast.2021.08.004</a>.
</p>
<p>Di Fonzo, T., Girolimetto, D. (2022), Forecast combination based forecast reconciliation:
insights and extensions, <em>International Journal of Forecasting</em>, in press.
</p>
<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T., and Hyndman, R. J. (2023),
Cross-temporal Probabilistic Forecast Reconciliation, <a href="https://doi.org/10.48550/arXiv.2303.17277">doi:10.48550/arXiv.2303.17277</a>.
</p>

<hr>
<h2 id='agg_ts'>Non-overlapping temporal aggregation of a time series</h2><span id='topic+agg_ts'></span>

<h3>Description</h3>

<p>Non-overlapping temporal aggregation of a time series according
to a specific aggregation order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_ts(agg_order, x, align = "end", rm_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_ts_+3A_agg_order">agg_order</code></td>
<td>
<p>Aggregation order to consider.</p>
</td></tr>
<tr><td><code id="agg_ts_+3A_x">x</code></td>
<td>
<p>Univariate time series: a vector or a <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="agg_ts_+3A_align">align</code></td>
<td>
<p>Specifies whether the aggregates should be aligned with the start ()
or end of the series.</p>
</td></tr>
<tr><td><code id="agg_ts_+3A_rm_na">rm_na</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or <code>ts</code> object
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
annual_ts &lt;- agg_ts(12, FoReco_data$obs$k1[,1]) # == FoReco_data$obs$k12[,1]

</code></pre>

<hr>
<h2 id='arrange_hres'>Re-arrange the multi-step residuals</h2><span id='topic+arrange_hres'></span>

<h3>Description</h3>

<p>Re-arrange the multi-step residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_hres(list_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_hres_+3A_list_res">list_res</code></td>
<td>
<p>a list of \(H\) multi-step residuals. Each element
of the list can be a vector (univariate time series) or a matrix (multivariate time series).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let \(Z_t\), \(t=1,\dots,T\), be a univariate time series. We can define the multi-step
residuals such us
\[\widehat{\varepsilon}_{h,t} = Z_{t+h} - \widehat{Z}_{t+h|t} \qquad h \le t \le T-h\]
where \(\widehat{Z}_{t+h|t}\) is the \(h\)-step fitted value, calculated as the \(h\)-step ahead
forecast given the time \(t\). Given the list of errors at different step
(\([\widehat{\varepsilon}_{1,1}, \; \dots, \; \widehat{\varepsilon}_{1,T}]\), ..., \([\widehat{\varepsilon}_{H,1}, \; \dots, \; \widehat{\varepsilon}_{H,T}]\))
this function returns a \(T\)-vector with the residuals, organized in the following way:
\[[\varepsilon_{1,1} \; \varepsilon_{2,2} \; \dots \; \varepsilon_{H,H} \; \varepsilon_{1,H+1} \; \dots \; \varepsilon_{H,T-H}]'\]
Same idea can be apply for a multivariate time series.
</p>


<h3>Value</h3>

<p>A vector or a matrix of multi-step residuals
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>

<hr>
<h2 id='boot_cs'>Cross-sectional Joint Bootstrap</h2><span id='topic+boot_cs'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between different time series (Panagiotelis et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_cs(fit, boot_size, h, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_cs_+3A_fit">fit</code></td>
<td>
<p>A list of \(n\) base forecast models. It is important to note that the models
must have the <code>simulate()</code> function available and implemented as with
the package <span class="pkg">forecast</span>, with the following mandatory parameters:
<em>object</em>, <em>innov</em>, <em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="boot_cs_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_cs_+3A_h">h</code></td>
<td>
<p>Block size of the bootstrap, which is typically equivalent to the forecast horizon.</p>
</td></tr>
<tr><td><code id="boot_cs_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and a 3-d array
(\(boot\_size\times n \times h\))
</p>


<h3>References</h3>

<p>Panagiotelis, A., Gamakumara, P., Athanasopoulos, G. &amp; Hyndman, R. J. (2023),
Probabilistic forecast reconciliation: Properties, evaluation and score optimisation,
<em>European Journal of Operational Research</em> 306(2), 693–706.
</p>


<h3>See Also</h3>

<p>Other bootstrap: 
<code><a href="#topic+boot_ct">boot_ct</a>()</code>,
<code><a href="#topic+boot_te">boot_te</a>()</code>
</p>

<hr>
<h2 id='boot_ct'>Cross-temporal Joint Bootstrap</h2><span id='topic+boot_ct'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between different time series and temporal aggregation order at the same time
(Girolimetto et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ct(fit, boot_size, m, h = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ct_+3A_fit">fit</code></td>
<td>
<p>A list of \(n\) elements. Each elements is a list with the \((k^\ast+m)\)
base forecast models ordered as [lowest_freq' ...  highest_freq']' of the cross-sectional
series. It is important to note that the models must have the <code>simulate()</code>
function available and implemented as with the package <span class="pkg">forecast</span>, with
the following mandatory parameters: <em>object</em>, <em>innov</em>, <em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="boot_ct_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_ct_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="boot_ct_+3A_h">h</code></td>
<td>
<p>Forecast horizon for the most temporally aggregated series.</p>
</td></tr>
<tr><td><code id="boot_ct_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and
a (\(boot\_size\times hn(k^\ast+m)\)) matrix
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T., &amp; Hyndman, R. J. (2023),
Cross-temporal Probabilistic Forecast Reconciliation,
<a href="https://doi.org/10.48550/arXiv.2303.17277">doi:10.48550/arXiv.2303.17277</a>.
</p>


<h3>See Also</h3>

<p>Other bootstrap: 
<code><a href="#topic+boot_cs">boot_cs</a>()</code>,
<code><a href="#topic+boot_te">boot_te</a>()</code>
</p>

<hr>
<h2 id='boot_te'>Temporal Joint Bootstrap</h2><span id='topic+boot_te'></span>

<h3>Description</h3>

<p>Joint block bootstrap for generating probabilistic base forecasts that take into account
the correlation between different temporal aggregation order (Girolimetto et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_te(fit, boot_size, m, h = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_te_+3A_fit">fit</code></td>
<td>
<p>A list of \((k^\ast+m)\) base forecast models ordered as
[lowest_freq' ...  highest_freq']'. It is important to note that the models
must have the <code>simulate()</code> function available and implemented as with
the package <span class="pkg">forecast</span>, with the following mandatory parameters:
<em>object</em>, <em>innov</em>, <em>future</em>, and <em>nsim</em>.</p>
</td></tr>
<tr><td><code id="boot_te_+3A_boot_size">boot_size</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_te_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="boot_te_+3A_h">h</code></td>
<td>
<p>Forecast horizon for the most temporally aggregated series.</p>
</td></tr>
<tr><td><code id="boot_te_+3A_seed">seed</code></td>
<td>
<p>An integer seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: the seed used to sample the errors and
a (\(boot\_size\times h(k^\ast+m)\)) matrix
</p>


<h3>References</h3>

<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T., &amp; Hyndman, R. J. (2023),
Cross-temporal Probabilistic Forecast Reconciliation,
<a href="https://doi.org/10.48550/arXiv.2303.17277">doi:10.48550/arXiv.2303.17277</a>.
</p>


<h3>See Also</h3>

<p>Other bootstrap: 
<code><a href="#topic+boot_cs">boot_cs</a>()</code>,
<code><a href="#topic+boot_ct">boot_ct</a>()</code>
</p>

<hr>
<h2 id='Cmatrix'>Cross-sectional (contemporaneous) aggregation matrix</h2><span id='topic+Cmatrix'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function allows the user to easily build the (\(n_a \times n_b\))
cross-sectional (contemporaneous) matrix mapping the \(n_b\) bottom
level series into the \(n_a\) higher level ones. (<em>Experimental version</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cmatrix(formula, data, sep = "_", sparse = TRUE, top_label = "Total")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cmatrix_+3A_formula">formula</code></td>
<td>
<p>Specification of the hierarchical structure: grouped hierarchies are specified
using <code>~ g1 * g2</code> and nested hierarchies are specified using <code>~ parent / child</code>.
Mixtures of the two formulations are also possible, like <code>~ g1 * (grandparent / parent / child)</code>.</p>
</td></tr>
<tr><td><code id="Cmatrix_+3A_data">data</code></td>
<td>
<p>A dataset in which each column contains the values of the variables in the formula
and each row identifies a bottom level time series.</p>
</td></tr>
<tr><td><code id="Cmatrix_+3A_sep">sep</code></td>
<td>
<p>Character to separate the names of the aggregated series (<em>default</em> is <code>"_"</code>).</p>
</td></tr>
<tr><td><code id="Cmatrix_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrix (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="Cmatrix_+3A_top_label">top_label</code></td>
<td>
<p>Label of the top level variable (<em>default</em> is <code>"Total"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>na x nb</code>) matrix.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Balanced hierarchy
#         T
#    |--------|
#    A        B
#  |---|   |--|--|
# AA   AB  BA BB BC
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "B", "B", "B"),
                       X2 = c("A", "B", "A", "B", "C"),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
C &lt;- Cmatrix(~ X1 / X2, data_bts, sep = "")

## Unbalanced hierarchy (1)
#             T
#    |--------|------|
#    A        B      C
#  |---|   |--|--|
# AA   AB  BA BB BC
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "B", "B", "B", "C"),
                       X2 = c("A", "B", "A", "B", "C", NA),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
C &lt;- Cmatrix(~ X1 / X2, data_bts, sep = "")

## Unbalanced hierarchy (2)
#                 T
#       |---------|---------|
#       A         B         C
#     |---|     |---|     |---|
#    AA   AB   BA   BB   CA   CB
#  |----|         |----|
# AAA  AAB       BBA  BBB
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "A", "B", "B", "B", "C", "C"),
                       X2 = c("A", "A", "B", "A", "B", "B", "A", "B"),
                       X3 = c("A", "B", NA, NA, "A", "B", NA, NA),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
C &lt;- Cmatrix(~ X1 / X2 / X3, data_bts, sep = "")

## Grouped hierarchy
#         C               S
#    |--------|      |--------|
#    A        B      M        F
#  |---|    |---|
# AA   AB  BA   BB
# Names of the bottom level variables
data_bts &lt;- data.frame(X1 = c("A", "A", "B", "B", "A", "A", "B", "B"),
                       X2 = c("A", "B", "A", "B", "A", "B", "A", "B"),
                       Y1 = c("M", "M", "M", "M", "F", "F", "F", "F"),
                       stringsAsFactors = FALSE)
# Cross-sectional aggregation matrix
C &lt;- Cmatrix(~ Y1 * (X1 / X2), data_bts, sep = "")

</code></pre>

<hr>
<h2 id='commat'>Commutation matrix</h2><span id='topic+commat'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function returns the (\(r c \times r c\))
commutation matrix \(\mathbf{P}\) such that
\[\mathbf{P} \mbox{vec}(\mathbf{Y}) = \mbox{vec}(\mathbf{Y}'),\]
where \(\mathbf{Y}\) is a (\(r \times c\)) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commat(r, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commat_+3A_r">r</code></td>
<td>
<p>Number of rows of \(\mathbf{Y}\).</p>
</td></tr>
<tr><td><code id="commat_+3A_c">c</code></td>
<td>
<p>Number of columns of \(\mathbf{Y}\).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse (\(r c \times r c\)) matrix, \(\mathbf{P}\).
</p>


<h3>References</h3>

<p>Magnus, J.R., Neudecker, H. (2019), Matrix Differential Calculus
with Applications in Statistics and Econometrics, third edition, New York,
Wiley, pp. 54-55.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(30), 5, 6)
P &lt;- commat(5, 6)
P %*% as.vector(Y) == as.vector(t(Y)) # check
</code></pre>

<hr>
<h2 id='cstrec'>Heuristic first-cross-sectional-then-temporal cross-temporal forecast reconciliation</h2><span id='topic+cstrec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Cross-temporal forecast reconciliation according to the heuristic procedure by
Kourentzes and Athanasopoulos (2019), where the order of application of the
two reconciliation steps (temporal-first-then-cross-sectional, as in the function
<code><a href="#topic+tcsrec">tcsrec</a>()</code>), is inverted. The function
<code><a href="#topic+cstrec">cstrec</a>()</code> performs cross-sectional reconciliation
(<code><a href="#topic+htsrec">htsrec</a>()</code>) first, then temporal reconciliation
(<code><a href="#topic+thfrec">thfrec</a>()</code>), and finally applies the average of the
projection matrices obtained in the second step to the one dimensional
reconciled values obtained in the first step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstrec(basef, hts_comb, thf_comb, res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cstrec_+3A_basef">basef</code></td>
<td>
<p>(\(n \times h(k^\ast+m)\)) matrix of base forecasts to be
reconciled, \(\widehat{\mathbf{Y}}\); \(n\) is the total number of variables,
\(m\) is the highest time frequency, \(k^\ast\) is the sum of (a
subset of) (\(p-1\)) factors of \(m\), excluding \(m\), and
\(h\) is the forecast horizon for the lowest frequency time series.
Each row identifies a time series, and the forecasts are ordered as
[lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="cstrec_+3A_hts_comb">hts_comb</code>, <code id="cstrec_+3A_thf_comb">thf_comb</code></td>
<td>
<p>Type of covariance matrix (respectively
(\(n \times n\)) and (\((k^\ast + m) \times (k^\ast + m)\))) to
be used in the cross-sectional and temporal reconciliation. More details in
<code>comb</code> param of <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>.</p>
</td></tr>
<tr><td><code id="cstrec_+3A_res">res</code></td>
<td>
<p>(\(n \times N(k^\ast + m)\)) matrix containing the residuals
at all the temporal frequencies ordered as [lowest_freq' ...  highest_freq']'
(columns) for each variable (row), needed to estimate the covariance matrix
when <code>hts_comb =</code> <code>{"wls",</code> <code>"shr",</code> <code>"sam"}</code> and/or
<code>hts_comb =</code> <code>{"wlsv",</code> <code>"wlsh",</code> <code>"acov",</code>
<code>"strar1",</code> <code>"sar1",</code> <code>"har1",</code> <code>"shr",</code> <code>"sam"}</code>.
The rows must be in the same order as <code>basef</code>.</p>
</td></tr>
<tr><td><code id="cstrec_+3A_...">...</code></td>
<td>
<p>Any other options useful for <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>, e.g. <code>m</code>, <code>C</code> (or <code>Ut</code> and
<code>nb</code>), <code>nn</code> (for non-negative reconciliation only at the first step),
<code>mse</code>, <code>corpcor</code>, <code>type</code>, <code>sol</code>, <code>settings</code>,
<code>W</code>, <code>Omega</code>,...</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Warning</strong>,
the two-step heuristic reconciliation allows considering non negativity constraints only in
the first step. This means that non-negativity is not guaranteed in the final reconciled values.
</p>


<h3>Value</h3>

<p>The function returns a list with two elements:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(n \times h(k^\ast + m)\)) reconciled forecasts matrix, \(\widetilde{\mathbf{Y}}\).</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Matrix which transforms the uni-dimensional reconciled forecasts of step 1 (projection approach) .</p>
</td></tr>
</table>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Kourentzes, N., Athanasopoulos, G. (2019), Cross-temporal coherent forecasts
for Australian tourism, <em>Annals of Tourism Research</em>, 75, 393-409.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), <em>Package &lsquo;corpcor&rsquo;</em>, R
package version 1.6.9 (April 1, 2017), <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the 'OSQP' Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
obj &lt;- cstrec(FoReco_data$base, m = 12, C = FoReco_data$C,
              hts_comb = "shr", thf_comb = "acov", res = FoReco_data$res)

</code></pre>

<hr>
<h2 id='ctbu'>Bottom-up cross-temporal forecast reconciliation</h2><span id='topic+ctbu'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Cross temporal reconciled forecasts for all series at any temporal
aggregation level are computed by appropriate summation of the high-frequency
bottom base forecasts \(\widehat{\mathbf{b}}_i, i = 1,...,n_b\), according to a
bottom-up procedure like what is currently done in both the cross-sectional
and temporal frameworks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbu(Bmat, m, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbu_+3A_bmat">Bmat</code></td>
<td>
<p>(\(n_b \times h m\)) matrix of high-frequency bottom time
series base forecasts (\(\widehat{\mathbf{B}}^{[1]}\)).
\(h\) is the forecast horizon for the lowest frequency (most temporally aggregated)
time series.</p>
</td></tr>
<tr><td><code id="ctbu_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of the \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="ctbu_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denoting by \(\ddot{\mathbf{Y}}\) the (\(n \times h (k^\ast + m)\)) matrix containing
the bottom-up cross temporal reconciled forecasts, it is:
\[\ddot{\mathbf{Y}} = \left[\begin{array}{cc}
\mathbf{C}\widehat{\mathbf{B}}^{[1]}\mathbf{K}_1' & \mathbf{C}\widehat{\mathbf{B}}^{[1]} \cr
\widehat{\mathbf{B}}^{[1]} \mathbf{K}_1' & \widehat{\mathbf{B}}^{[1]}
\end{array}\right],\]
where \(\mathbf{C}\) is the cross-sectional (contemporaneous) aggregation matrix,
\(\mathbf{K}_1\) is the temporal aggregation matrix with \(h=1\), and
\(\widehat{\mathbf{B}}^{[1]}\) is the matrix containing the high-frequency bottom
time series base forecasts. This expression is equivalent to
\(\mbox{vec}(\ddot{\mathbf{Y}}') = \widetilde{\mathbf{S}}
\mbox{vec}(\widehat{\mathbf{Y}}')\) for \(h = 1\), where
\(\widetilde{\mathbf{S}}\) is the cross-temporal summing matrix for
\(\mbox{vec}(\widehat{\mathbf{Y}}')\), and \(\widehat{\mathbf{Y}}\)
is the (\(n \times h (k^\ast + m)\)) matrix containing all the base forecasts
at any temporal aggregation order.
</p>


<h3>Value</h3>

<p>The function returns a (\(n \times h (k^\ast + m)\)) matrix of
bottom-up cross-temporally reconciled forecasts, \(\ddot{\mathbf{Y}}\).
</p>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
# monthly base forecasts
hfbts &lt;- t(FoReco2matrix(FoReco_data$base, m = 12)$k1[, -c(1:3), drop = FALSE])
obj &lt;- ctbu(Bmat = hfbts, m = 12, C = FoReco_data$C)
rownames(obj) &lt;- rownames(FoReco_data$base)

</code></pre>

<hr>
<h2 id='ctf_tools'>Cross-temporal reconciliation tools</h2><span id='topic+ctf_tools'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Some useful tools for the cross-temporal forecast reconciliation of a linearly constrained
(hierarchical/grouped) multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctf_tools(C, m, h = 1, Ut, nb, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctf_tools_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
<tr><td><code id="ctf_tools_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of the \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="ctf_tools_+3A_h">h</code></td>
<td>
<p>Forecast horizon for the lowest frequency (most temporally aggregated) time
series (<em>default</em> is <code>1</code>).</p>
</td></tr>
<tr><td><code id="ctf_tools_+3A_ut">Ut</code></td>
<td>
<p>Zero constraints cross-sectional (contemporaneous) kernel matrix
\((\mathbf{U}'\mathbf{y} = \mathbf{0})\) spanning the null space valid
for the reconciled forecasts. It can be used instead of parameter
<code>C</code>, but <code>nb</code> (\(n = n_a + n_b\)) is needed if
\(\mathbf{U}' \neq [\mathbf{I} \ -\mathbf{C}]\). If the hierarchy
admits a structural representation, \(\mathbf{U}'\) has dimension
(\(n_a \times n\)).</p>
</td></tr>
<tr><td><code id="ctf_tools_+3A_nb">nb</code></td>
<td>
<p>Number of bottom time series; if <code>C</code> is present, <code>nb</code>
and <code>Ut</code> are not used.</p>
</td></tr>
<tr><td><code id="ctf_tools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse object (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>ctf</strong> list with:
</p>
<table>
<tr><td><code>Ht</code></td>
<td>
<p>Full row-rank cross-temporal zero constraints (kernel)
matrix coherent with \(\mathbf{y} = \mbox{vec}(\mathbf{Y}')\): \(\mathbf{H}'\mathbf{y} = \mathbf{0}\).</p>
</td></tr>
<tr><td><code>Hbrevet</code></td>
<td>
<p>Complete, not full row-rank cross-temporal zero
constraints (kernel) matrix coherent with \(\mathbf{y} = \mbox{vec}(\mathbf{Y}')\):
\(\breve{\mathbf{H}}'\mathbf{y} = \mathbf{0}\).</p>
</td></tr>
<tr><td><code>Hcheckt</code></td>
<td>
<p>Full row-rank cross-temporal zero constraints (kernel) matrix coherent with
\(\check{\mathbf{y}}\) (structural representation):
\(\check{\mathbf{H}}' \check{\mathbf{y}} = \mathbf{0}\).</p>
</td></tr>
<tr><td><code>Ccheck</code></td>
<td>
<p>Cross-temporal aggregation matrix \(\check{\mathbf{C}}\)
coherent with \(\check{\mathbf{y}}\) (structural representation).</p>
</td></tr>
<tr><td><code>Scheck</code></td>
<td>
<p>Cross-temporal summing matrix \(\check{\mathbf{S}}\)
coherent with \(\check{\mathbf{y}}\) (structural representation).</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>Cross-temporal summing matrix \(\widetilde{\mathbf{F}}\)
coherent with \(\mathbf{y} = \mbox{vec}(\mathbf{Y}')\).</p>
</td></tr>
</table>
<p><strong>hts</strong> list from <code><a href="#topic+hts_tools">hts_tools</a></code> .
</p>
<p><strong>thf</strong> list from <code><a href="#topic+thf_tools">thf_tools</a></code> .
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One level hierarchy (na = 1, nb = 2) with quarterly data
obj &lt;- ctf_tools(C = matrix(c(1, 1), 1), m = 4)

</code></pre>

<hr>
<h2 id='FoReco_data'>Forecast reconciliation for a simulated linearly constrained, genuine hierarchical multiple time series</h2><span id='topic+FoReco_data'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A two-level hierarchy with \(n = 8\) monthly time series. In the cross-sectional framework,
at any time it is \(Tot = A + B + C\), \(A = AA + AB\) and \(B = BA + BB\)
(the bottom time series being \(AA\), \(AB\), \(BA\), \(BB\), and \(C\), it is \(n_b = 5\)).
The monthly observations are aggregated to their annual (\(k = 12\)),
semi-annual (\(k = 6\)), four-monthly (\(k = 4\)), quarterly (\(k = 3\)), and
bi-monthly (\(k = 2\)) counterparts. The monthly bottom time series are simulated
from five different SARIMA models (see
<a href="https://danigiro.github.io/FoReco/articles/FoReco_package.html"><code>Using the `FoReco` package</code></a>).
There are 180 (15 years) monthly observations: the first 168 values (14 years) are used as
training set, and the last 12 form the test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FoReco_data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"list"</code>:
</p>

<dl>
<dt>base</dt><dd><p>(\(8 \times 28\)) matrix of base forecasts. Each row identifies a time series and the forecasts
are ordered as [lowest_freq' ...  highest_freq']'.</p>
</dd>
<dt>test</dt><dd><p>(\(8 \times 28\)) matrix of test set. Each row identifies a time series and the observed values
are ordered as [lowest_freq' ...  highest_freq']'.</p>
</dd>
<dt>res</dt><dd><p>(\(8 \times 392\)) matrix of in-sample residuals. Each row identifies a time series and the in-sample residuals
are ordered as [lowest_freq' ...  highest_freq']'.</p>
</dd>
<dt>C</dt><dd><p>(\(3 \times 5\)) cross-sectional (contemporaneous) aggregation matrix.</p>
</dd>
<dt>obs</dt><dd><p>List of the observations at any levels and temporal frequencies.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(FoReco_data)
# Cross-sectional reconciliation for all temporal aggregation levels
# (annual, ..., bi-monthly, monthly)
K &lt;- c(12, 6, 4, 3, 2, 1)
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)
hts_recf &lt;- lapply(K, function(k){
  htsrec(mbase[[paste0("k", k)]], C = FoReco_data$C, comb = "shr",
         res = mres[[paste0("k", k)]], keep = "recf")
})
names(hts_recf) &lt;- paste("k", K, sep="")

# Forecast reconciliation through temporal hierarchies for all time series
# comb = "acov"
n &lt;- NROW(FoReco_data$base)
thf_recf &lt;- matrix(NA, n, NCOL(FoReco_data$base))
dimnames(thf_recf) &lt;- dimnames(FoReco_data$base)
for(i in 1:n){
  # ts base forecasts ([lowest_freq' ...  highest_freq']')
  tsbase &lt;- FoReco_data$base[i, ]
  # ts residuals ([lowest_freq' ...  highest_freq']')
  tsres &lt;- FoReco_data$res[i, ]
  thf_recf[i,] &lt;- thfrec(tsbase, m = 12, comb = "acov",
                         res = tsres, keep = "recf")
}

# Iterative cross-temporal reconciliation
# Each iteration: t-acov + cs-shr
ite_recf &lt;- iterec(FoReco_data$base, note=FALSE,
                   m = 12, C = FoReco_data$C,
                   thf_comb = "acov", hts_comb = "shr",
                   res = FoReco_data$res, start_rec = "thf")$recf

# Heuristic first-cross-sectional-then-temporal cross-temporal reconciliation
# cs-shr + t-acov
cst_recf &lt;- cstrec(FoReco_data$base, m = 12, C = FoReco_data$C,
                   thf_comb = "acov", hts_comb = "shr",
                   res = FoReco_data$res)$recf

# Heuristic first-temporal-then-cross-sectional cross-temporal reconciliation
# t-acov + cs-shr
tcs_recf &lt;- tcsrec(FoReco_data$base, m = 12, C = FoReco_data$C,
                   thf_comb = "acov", hts_comb = "shr",
                   res = FoReco_data$res)$recf

# Optimal cross-temporal reconciliation
# comb = "bdshr"
oct_recf &lt;- octrec(FoReco_data$base, m = 12, C = FoReco_data$C,
                   comb = "bdshr", res = FoReco_data$res, keep = "recf")

</code></pre>

<hr>
<h2 id='FoReco-hts'>Simple examples to compare <code>FoReco</code> and <code>hts</code> packages</h2><span id='topic+FoReco-hts'></span>

<h3>Description</h3>

<p>Two datasets of the <span class="pkg">hts</span> package are used to show how to get the same results
using <span class="pkg">FoReco</span>. First, we consider the <code>htseg1</code> dataset
(a simulated three level hierarchy, with a total of 8 series, each of length 10).
Then, we take the <code>htseg2</code> dataset (a simulated four level hierarchy with
a total of 17 series, each of length 16). <code>htseg1</code> and <code>htseg2</code>
are objects of class <code>hts</code> in <span class="pkg">hts</span>.
</p>


<h3>References</h3>

<p>Hyndman, R. J., Lee, A., Wang, E., and Wickramasuriya, S. (2020).
hts: Hierarchical and Grouped Time Series, <em>R package version 6.0.1</em>,
<a href="https://CRAN.R-project.org/package=hts">https://CRAN.R-project.org/package=hts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(hts)
require(FoReco)

####### htseg1 #######
data &lt;- allts(htseg1)
n &lt;- NCOL(data)
nb &lt;- NCOL(htseg1$bts)
na &lt;- n-nb
C &lt;- smatrix(htseg1)[1:na, ]

# List containing the base forecasts
# Forecast horizon: 10
base &lt;- list()
for (i in 1:n) {
  base[[i]] &lt;- forecast(auto.arima(data[, i]))
}

# Create the matrix of base forecasts
BASE &lt;- NULL
for (i in 1:n) {
  BASE &lt;- cbind(BASE, base[[i]]$mean)
}
colnames(BASE) &lt;- colnames(data)

# Create the matrix of residuals
res &lt;- NULL
for (i in 1:n) {
  res &lt;- cbind(res, base[[i]]$residuals)
}
colnames(res) &lt;- colnames(data)

## Comparisons
# ols
# two commands in hts...
Y_hts_forecast &lt;- forecast(htseg1, method = "comb", fmethod = "arima", weights = "ols")
Y_hts_ols &lt;- combinef(BASE, nodes = get_nodes(htseg1), keep = "all")
# ...with the same results:
sum(abs(allts(Y_hts_forecast) - Y_hts_ols) &gt; 1e-10)

Y_FoReco_ols &lt;- htsrec(BASE, C = C, comb = "ols")$recf
sum(abs(Y_hts_ols - Y_FoReco_ols) &gt; 1e-10)

# struc
w &lt;- 1 / apply(smatrix(htseg1), 1, sum)
Y_hts_struc &lt;- combinef(BASE, nodes = get_nodes(htseg1), weights = w, keep = "all")
Y_FoReco_struc &lt;- htsrec(BASE, C = C, comb = "struc")$recf
sum(abs(Y_hts_struc - Y_FoReco_struc) &gt; 1e-10)

# shr
Y_hts_shr &lt;- MinT(BASE, nodes = get_nodes(htseg1), keep = "all",
                  covariance = "shr", residual = res)
Y_FoReco_shr &lt;- htsrec(BASE, C = C, comb = "shr", res = res)$recf
sum(abs(Y_hts_shr - Y_FoReco_shr) &gt; 1e-10)

# sam - hts error "MinT needs covariance matrix to be positive definite."
#       The covariance matrix is ill-conditioned, hts considers it as non-invertible
Y_hts_sam &lt;- MinT(BASE, nodes = get_nodes(htseg1), keep = "all",
                  covariance = "sam", residual = res)
Y_FoReco_sam &lt;- htsrec(BASE, C = C, comb = "sam", res = res)$recf
# sum((Y_hts_sam-Y_FoReco_sam)&gt;1e-10)

####### htseg2 #######
data &lt;- allts(htseg2)
n &lt;- NCOL(data)
nb &lt;- NCOL(htseg2$bts)
na &lt;- n-nb
C &lt;- smatrix(htseg2)[1:na, ]

## Computation of the base forecasts
# using the auto.arima() function of the package forecast (loaded by hts)
# List containing the base forecasts
# Forecast horizon: 10
base &lt;- list()
for (i in 1:n) {
  base[[i]] &lt;- forecast(auto.arima(data[, i]))
}

# Create the matrix of base forecasts
BASE &lt;- NULL
for (i in 1:n) {
  BASE &lt;- cbind(BASE, base[[i]]$mean)
}
colnames(BASE) &lt;- colnames(data)

# Create the matrix of residuals
res &lt;- NULL
for (i in 1:n) {
  res &lt;- cbind(res, base[[i]]$residuals)
}
colnames(res) &lt;- colnames(data)

## Comparisons
# ols
Y_hts_ols &lt;- combinef(BASE, nodes = get_nodes(htseg2), keep = "all")
Y_FoReco_ols &lt;- htsrec(BASE, C = C, comb = "ols")$recf
sum(abs(Y_hts_ols - Y_FoReco_ols) &gt; 1e-10)

# struc
w &lt;- 1 / apply(smatrix(htseg2), 1, sum)
Y_hts_struc &lt;- combinef(BASE, nodes = get_nodes(htseg2), weights = w, keep = "all")
Y_FoReco_struc &lt;- htsrec(BASE, C = C, comb = "struc")$recf
sum(abs(Y_hts_struc - Y_FoReco_struc) &gt; 1e-10)

# shr
Y_hts_shr &lt;- MinT(BASE, nodes = get_nodes(htseg2), keep = "all", covariance = "shr", residual = res)
Y_FoReco_shr &lt;- htsrec(BASE, C = C, comb = "shr", res = res)$recf
sum(abs(Y_hts_shr- Y_FoReco_shr) &gt; 1e-10)

## End(Not run)
</code></pre>

<hr>
<h2 id='FoReco-thief'>Simple examples to compare <code>FoReco</code> and <code>thief</code> packages</h2><span id='topic+FoReco-thief'></span>

<h3>Description</h3>

<p>The dataset in the <code>thief</code> package is used to show how to get the same results with the FoReco package.
In particular, we take the weekly data of Accident and Emergency demand in the UK, <code>AEdemand</code>, from 1 January
2011 to 31 December 2014.
</p>


<h3>References</h3>

<p>Hyndman, R. J., Kourentzes, N. (2018), thief: Temporal HIErarchical Forecasting, <em>R package version 0.3</em>,
<a href="https://cran.r-project.org/package=thief">https://cran.r-project.org/package=thief</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(thief)
require(FoReco)
dataset &lt;- window(AEdemand[, 12], start = c(2011, 1), end = c(2014, 52))
data &lt;- tsaggregates(dataset)
# Base forecasts
base &lt;- list()
for (i in 1:5) {
  base[[i]] &lt;- forecast(auto.arima(data[[i]]))
}
base[[6]] &lt;- forecast(auto.arima(data[[6]]), h = 2)
# Base forecasts vector
base_vec &lt;- NULL
for (i in 6:1) {
  base_vec &lt;- c(base_vec, base[[i]]$mean)
}
# Residual vector
res &lt;- NULL
for (i in 6:1) {
  res &lt;- c(res, base[[i]]$residuals)
}

# OLS
# two commands in thief...
obj_thief &lt;- thief(dataset, m = 52, h = 2 * 52, comb = "ols", usemodel = "arima")
obj_thief &lt;- tsaggregates(obj_thief$mean)
y_thief &lt;- NULL
for (i in 6:1) {
  y_thief &lt;- c(y_thief, obj_thief[[i]])
}
obj_thief_ols &lt;- reconcilethief(base, comb="ols")
y_thief_ols &lt;- NULL
for (i in 6:1) {
  y_thief_ols &lt;- c(y_thief_ols, obj_thief_ols[[i]]$mean)
}
# ...with the same results:
sum(abs(y_thief_ols - y_thief) &gt; 1e-10)

y_FoReco_ols &lt;- thfrec(base_vec, 52, comb = "ols")$recf
sum(abs(y_FoReco_ols - y_thief_ols) &gt; 1e-10)

# STRUC
obj_thief_struc &lt;- reconcilethief(base, comb="struc")
y_thief_struc &lt;- NULL
for (i in 6:1) {
  y_thief_struc &lt;- c(y_thief_struc, obj_thief_struc[[i]]$mean)
}
y_FoReco_struc &lt;- thfrec(base_vec, 52, comb = "struc")$recf
sum(abs(y_FoReco_struc - y_thief_struc) &gt; 1e-10)

# BU
obj_thief_bu &lt;- reconcilethief(base, comb="bu")
y_thief_bu &lt;- NULL
for (i in 6:1) {
  y_thief_bu &lt;- c(y_thief_bu, obj_thief_bu[[i]]$mean)
}
y_FoReco_bu &lt;- thfrec(base_vec, 52, comb = "bu")$recf
sum(abs(y_FoReco_bu - y_thief_bu) &gt; 1e-10)

# SHR
obj_thief_shr &lt;- reconcilethief(base, comb="shr")
y_thief_shr &lt;- NULL
for (i in 6:1) {
  y_thief_shr &lt;- c(y_thief_shr, obj_thief_shr[[i]]$mean)
}
y_FoReco_shr &lt;- thfrec(base_vec, 52, comb = "shr", res = res)$recf
sum(abs(y_FoReco_shr - y_thief_shr) &gt; 1e-10)

## End(Not run)
</code></pre>

<hr>
<h2 id='FoReco2ts'>Reconciled forecasts matrix/vector to time-series class</h2><span id='topic+FoReco2ts'></span><span id='topic+FoReco2matrix'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function to transform the matrix/vector of FoReco forecasts input and output into a list of
time series/matrix/vector objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FoReco2ts(recf, m, ...)

FoReco2matrix(recf, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FoReco2ts_+3A_recf">recf</code></td>
<td>
<p>(\(h(k^\ast + m) \times 1\)) forecasts vector from <a href="#topic+thfrec">thfrec</a>,
(\(h \times n\)) forecasts matrix from <a href="#topic+htsrec">htsrec</a> or
(\(n \times h(k^\ast + m)\)) forecasts matrix from <a href="#topic+octrec">octrec</a>,
<a href="#topic+tcsrec">tcsrec</a>, <a href="#topic+cstrec">cstrec</a>, <a href="#topic+iterec">iterec</a>,
<a href="#topic+ctbu">ctbu</a>.</p>
</td></tr>
<tr><td><code id="FoReco2ts_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="FoReco2ts_+3A_...">...</code></td>
<td>
<p>optional arguments to <a href="stats.html#topic+ts">ts</a> (i.e. starting date);
frequency is required only for the cross-sectional case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"ts"</code> objects for <a href="#topic+FoReco2ts">FoReco2ts</a> and a list of
matrix/vector for <a href="#topic+FoReco2matrix">FoReco2matrix</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
# Cross-temporal framework
oct_recf &lt;- octrec(FoReco_data$base, m = 12, C = FoReco_data$C,
                   comb = "bdshr", res = FoReco_data$res)$recf
ts_oct &lt;- FoReco2ts(recf = oct_recf, m = 12, start = c(15, 1))
mat_oct &lt;- FoReco2matrix(recf = oct_recf, m = 12)

# Cross-sectional framework
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
# monthly residuals
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)$k1
hts_recf &lt;- htsrec(mbase, C = FoReco_data$C, comb = "shr", res = mres)$recf
ts_hts &lt;- FoReco2ts(recf = hts_recf, start = c(15, 1), frequency = 12)
mat_hts &lt;- FoReco2matrix(recf = hts_recf)

# Temporal framework
# top ts base forecasts ([lowest_freq' ...  highest_freq']')
topbase &lt;- FoReco_data$base[1, ]
# top ts residuals ([lowest_freq' ...  highest_freq']')
topres &lt;- FoReco_data$res[1, ]
thf_recf &lt;- thfrec(topbase, m = 12, comb = "acov", res = topres)$recf
ts_thf &lt;- FoReco2ts(recf = thf_recf, m = 12, start = c(15, 1))
mat_thf &lt;- FoReco2matrix(recf = thf_recf, m = 12)

</code></pre>

<hr>
<h2 id='hts_tools'>Cross-sectional reconciliation tools</h2><span id='topic+hts_tools'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Some useful tools for the cross-sectional forecast reconciliation of a
linearly constrained (e.g., hierarchical/grouped) multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hts_tools(C, h = 1, Ut, nb, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hts_tools_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
<tr><td><code id="hts_tools_+3A_h">h</code></td>
<td>
<p>Forecast horizon (<em>default</em> is <code>1</code>).</p>
</td></tr>
<tr><td><code id="hts_tools_+3A_ut">Ut</code></td>
<td>
<p>Zero constraints cross-sectional (contemporaneous) kernel matrix
\((\mathbf{U}'\mathbf{y} = \mathbf{0})\) spanning the null space valid
for the reconciled forecasts. It can be used instead of parameter
<code>C</code>, but <code>nb</code> is needed if
\(\mathbf{U}' \neq [\mathbf{I} \ -\mathbf{C}]\). If the hierarchy
admits a structural representation, \(\mathbf{U}'\) has dimension
(\(n_a \times n\)).</p>
</td></tr>
<tr><td><code id="hts_tools_+3A_nb">nb</code></td>
<td>
<p>Number of bottom time series; if <code>C</code> is present, <code>nb</code>
and <code>Ut</code> are not used.</p>
</td></tr>
<tr><td><code id="hts_tools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse matrices (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of five elements:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>(\(n \times n_b\)) cross-sectional (contemporaneous) aggregation matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>(\(n \times n_b\)) cross-sectional (contemporaneous) summing matrix,
\(\mathbf{S} = \left[\begin{array}{c} \mathbf{C} \cr \mathbf{I}_{n_b}\end{array}\right].\)</p>
</td></tr>
<tr><td><code>Ut</code></td>
<td>
<p>(\(n_a \times n\)) zero constraints cross-sectional (contemporaneous)
kernel matrix. If the hierarchy admits a structural representation \(\mathbf{U}' = [\mathbf{I} \ -\mathbf{C}]\)</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of variables \(n_a + n_b\).</p>
</td></tr>
<tr><td><code>na</code></td>
<td>
<p>Number of upper level variables.</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>Number of bottom level variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One level hierarchy (na = 1, nb = 2)
obj &lt;- hts_tools(C = matrix(c(1, 1), 1), sparse = FALSE)

</code></pre>

<hr>
<h2 id='htsrec'>Cross-sectional (contemporaneous) forecast reconciliation</h2><span id='topic+htsrec'></span>

<h3>Description</h3>

<p>Cross-sectional (contemporaneous) forecast reconciliation of a linearly constrained
(e.g., hierarchical/grouped) multiple time series.
The reconciled forecasts are calculated either through a
projection approach (Byron, 1978, see also van Erven and Cugliari, 2015, and
Wickramasuriya et al., 2019), or the equivalent structural approach by Hyndman
et al. (2011). Moreover, the classic bottom-up approach is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htsrec(basef, comb, C, res, Ut, nb, mse = TRUE, corpcor = FALSE,
       type = "M", sol = "direct", keep = "list",  v = NULL, nn = FALSE,
       nn_type = "osqp", settings = list(), bounds = NULL, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htsrec_+3A_basef">basef</code></td>
<td>
<p>(\(h \times n\)) matrix of base forecasts to be reconciled;
\(h\) is the forecast horizon and \(n\) is the total number of time series.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_comb">comb</code></td>
<td>
<p>Type of the reconciliation. Except for Bottom-up, each
option corresponds to a specific (\(n \times n\)) covariance matrix:
</p>

<ul>
<li> <p><b>bu</b> (Bottom-up);
</p>
</li>
<li> <p><b>ols</b> (Identity);
</p>
</li>
<li> <p><b>struc</b> (Structural variances);
</p>
</li>
<li> <p><b>wls</b> (Series variances) - uses res;
</p>
</li>
<li> <p><b>shr</b> (Shrunk covariance matrix - MinT-shr) - uses res;
</p>
</li>
<li> <p><b>sam</b> (Sample covariance matrix - MinT-sam) - uses res;
</p>
</li>
<li> <p><b>w</b> use your personal matrix W in param <code>W</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="htsrec_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_res">res</code></td>
<td>
<p>(\(N \times n\)) in-sample residuals matrix needed when <code>comb =</code>
<code>{"wls",</code> <code>"shr",</code> <code>"sam"}</code>. The columns must be in
the same order as <code>basef</code>.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_ut">Ut</code></td>
<td>
<p>Zero constraints cross-sectional (contemporaneous) kernel matrix
\((\mathbf{U}'\mathbf{y} = \mathbf{0})\) spanning the null space valid
for the reconciled forecasts. It can be used instead of parameter
<code>C</code>, but <code>nb</code> (\(n = n_a + n_b\)) is needed if
\(\mathbf{U}' \neq [\mathbf{I} \ -\mathbf{C}]\). If the hierarchy
admits a structural representation, \(\mathbf{U}'\) has dimension
(\(n_a \times n\)).</p>
</td></tr>
<tr><td><code id="htsrec_+3A_nb">nb</code></td>
<td>
<p>Number of bottom time series; if <code>C</code> is present, <code>nb</code>
and <code>Ut</code> are not used.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_mse">mse</code></td>
<td>
<p>Logical value: <code>TRUE</code> (<em>default</em>) calculates the
covariance matrix of the in-sample residuals (when necessary) according to
the original <span class="pkg">hts</span> and <span class="pkg">thief</span> formulation: no mean correction,
T as denominator.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_corpcor">corpcor</code></td>
<td>
<p>Logical value: <code>TRUE</code> if <span class="pkg">corpcor</span> (Schäfer et
al., 2017) must be used to shrink the sample covariance matrix according to
Schäfer and Strimmer (2005), otherwise the function uses the
same implementation as package <span class="pkg">hts</span>.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_type">type</code></td>
<td>
<p>Approach used to compute the reconciled forecasts: <code>"M"</code> for
the projection approach with matrix M (<em>default</em>), or <code>"S"</code> for the
structural approach with summing matrix S.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_sol">sol</code></td>
<td>
<p>Solution technique for the reconciliation problem: either
<code>"direct"</code> (<em>default</em>) for the closed-form matrix solution, or
<code>"osqp"</code> for the numerical solution (solving a linearly constrained
quadratic program using <code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code>).</p>
</td></tr>
<tr><td><code id="htsrec_+3A_keep">keep</code></td>
<td>
<p>Return a list object of the reconciled forecasts at all levels
(if keep = &quot;list&quot;) or only the reconciled forecasts matrix (if keep = &quot;recf&quot;).</p>
</td></tr>
<tr><td><code id="htsrec_+3A_v">v</code></td>
<td>
<p>vector index of the fixed base forecast (\(\mbox{min}(v) > 0\)
and \(\mbox{max}(v) < n\)).</p>
</td></tr>
<tr><td><code id="htsrec_+3A_nn">nn</code></td>
<td>
<p>Logical value: <code>TRUE</code> if non-negative reconciled forecasts
are wished.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_nn_type">nn_type</code></td>
<td>
<p>&quot;osqp&quot; (default), &quot;KAnn&quot; (only <code>type == "M"</code>) or &quot;sntz&quot;.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_settings">settings</code></td>
<td>
<p>Settings for <span class="pkg">osqp</span> (object <code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>).
The default options are: <code>verbose = FALSE</code>, <code>eps_abs = 1e-5</code>,
<code>eps_rel = 1e-5</code>, <code>polish_refine_iter = 100</code> and <code>polish = TRUE</code>.
For details, see the <a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a>
(Stellato et al., 2019).</p>
</td></tr>
<tr><td><code id="htsrec_+3A_bounds">bounds</code></td>
<td>
<p>(\(n \times 2\)) matrix containing the cross-sectional bounds:
the first column is the lower bound, and the second column is the upper bound.</p>
</td></tr>
<tr><td><code id="htsrec_+3A_w">W</code></td>
<td>
<p>This option permits to directly enter the covariance matrix:
</p>

<ol>
<li> <p><code>W</code> must be a p.d. (\(n \times n\)) matrix or a list of \(h\) matrix (one for each forecast horizon);
</p>
</li>
<li><p> if <code>comb</code> is different from &quot;<code>w</code>&quot;, <code>W</code> is not used.
</p>
</li></ol>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Let \(\mathbf{y}\) be a (\(n \times 1\)) vector of target point
forecasts which are wished to satisfy the system of linearly independent
constraints \[\mathbf{U}'\mathbf{y} = \mathbf{0}_{(r \times 1)},\]
where \(\mathbf{U}'\) is a (\(r \times n\)) matrix, with
rank\((\mathbf{U}') = r \leq n\), and \(\mathbf{0}_{(r \times 1)}\)
is a (\(r \times 1\)) null vector. Let \(\widehat{\mathbf{y}}\)
be a (\(n \times 1\)) vector of unbiased point forecasts, not
fulfilling the linear constraints (i.e., \(\mathbf{U}'\widehat{\mathbf{y}}
\ne \mathbf{0}\)).
</p>
<p>We consider a regression-based reconciliation method assuming
that \(\widehat{\mathbf{y}}\) is related to \(\mathbf{y}\) by
\[\widehat{\mathbf{y}} = \mathbf{y} + \mathbf{\varepsilon},\]
where \(\mathbf{\varepsilon}\) is a (\(n \times 1\)) vector
of zero mean disturbances, with known p.d. covariance matrix
\(\mathbf{W}\). The reconciled forecasts \(\widetilde{\mathbf{y}}\)
are found by minimizing the generalized least squares (GLS) objective
function \(\left(\widehat{\mathbf{y}} - \mathbf{y}\right)'\mathbf{W}^{-1}
\left(\widehat{\mathbf{y}} - \mathbf{y}\right)\) constrained by
\(\mathbf{U}'\mathbf{y} = \mathbf{0}_{(r \times 1)}\):
</p>
\[\widetilde{\mathbf{y}} = \mbox{argmin}_\mathbf{y} \left(\mathbf{y} -
\widehat{\mathbf{y}} \right)' \mathbf{W}^{-1} \left(\mathbf{y} -
\widehat{\mathbf{y}} \right), \quad \mbox{s.t. } \mathbf{U}'\mathbf{y} =
\mathbf{0}.\]
<p>The solution is given by
\[\widetilde{\mathbf{y}}= \widehat{\mathbf{y}} - \mathbf{W}\mathbf{U}
\left(\mathbf{U}’\mathbf{WU}\right)^{-1}\mathbf{U}'\widehat{\mathbf{y}}=
\mathbf{M}\widehat{\mathbf{y}},\]
where \(\mathbf{M} = \mathbf{I}_n - \mathbf{W}\mathbf{U}\left(
\mathbf{U}’\mathbf{WU}\right)^{-1}\mathbf{U}’\)
is a (\(n \times n\)) projection matrix. This solution is used by
<code><a href="#topic+htsrec">htsrec</a></code> when <code>type = "M"</code>.
</p>
<p>Denoting with \(\mathbf{d}_{\widehat{\mathbf{y}}} = \mathbf{0} -
\mathbf{U}'\widehat{\mathbf{y}}\) the (\(r \times 1\)) vector containing
the <em>coherency</em> errors of the base forecasts, we can re-state the solution as
\[\widetilde{\mathbf{y}}= \widehat{\mathbf{y}} + \mathbf{WU} \left(
\mathbf{U}'\mathbf{WU}\right)^{-1}\mathbf{d}_{\widehat{y}},\]
which makes it clear that the reconciliation formula simply adjusts the
vector \(\widehat{\mathbf{y}}\) with a linear
combination &ndash; according to the smoothing matrix
\(\mathbf{L} = \mathbf{WU} \left(\mathbf{U}’\mathbf{WU}\right)^{-1}\) &ndash;
of the coherency errors of the base forecasts.
</p>
<p>In addition, if the error term \(\mathbf{\varepsilon}\) is gaussian, the reconciliation
error \(\widetilde{\varepsilon} = \widetilde{\mathbf{y}} - \mathbf{y}\) is
a zero-mean gaussian vector with covariance matrix
\[E\left( \widetilde{\mathbf{y}} - \mathbf{y}\right) \left(
\widetilde{\mathbf{y}} - \mathbf{y}\right)' = \mathbf{W} - \mathbf{WU}
\left(\mathbf{U}'\mathbf{WU}\right)^{-1}\mathbf{U}' = \mathbf{MW}.\]
</p>
<p>Hyndman et al. (2011, see also Wickramasuriya et al., 2019) propose an
equivalent, alternative formulation as for the reconciled estimates, obtained
by GLS estimation of the model
\[\widehat{\mathbf{y}} = \mathbf{S}\mathbf{\beta} + \mathbf{\varepsilon},\]
where \(\mathbf{S}\) is the <em>structural summation matrix</em> describing
the aggregation relationships operating on \(\mathbf{y}\), and
\(\mathbf{\beta}\) is a subset of \(\mathbf{y}\) containing the
target forecasts of the bottom level series, such that
\(\mathbf{y} = \mathbf{S}\mathbf{\beta}\). Since the hypotheses on
\(\mathbf{\varepsilon}\) remain unchanged,
\[\widetilde{\mathbf{\beta}} = \left(\mathbf{S}'\mathbf{W}^{-1}\mathbf{S}
\right)^{-1}\mathbf{S}'\mathbf{W}^{-1}\widehat{\mathbf{y}}\]
is the best linear unbiased estimate of \(\mathbf{\beta}\), and
the whole reconciled forecasts vector is given by
\[\widetilde{\mathbf{y}} = \mathbf{S}\widetilde{\mathbf{\beta}} = \mathbf{SG}
\widehat{\mathbf{y}},\]
where \(\mathbf{G} = \left(\mathbf{S}'\mathbf{W}^{-1}
\mathbf{S}\right)^{-1}\mathbf{S}'\mathbf{W}^{-1}\), and \(\mathbf{M}=\mathbf{SG}\).
This solution is used by <code><a href="#topic+htsrec">htsrec</a></code> when <code>type = "S"</code>.
</p>
<p><strong>Bounds on the reconciled forecasts</strong>
</p>
<p>The user may impose bounds on the reconciled forecasts.
The parameter <code>bounds</code> permits to consider lower (\(\mathbf{a}\)) and
upper (\(\mathbf{b}\)) bounds like \(\mathbf{a} \leq
\widetilde{\mathbf{y}} \leq \mathbf{b}\) such that:
\[ \begin{array}{c}
a_1 \leq \widetilde{y}_1 \leq b_1 \cr
\dots \cr
a_n \leq \widetilde{y}_n \leq b_n \cr
\end{array} \Rightarrow
\mbox{bounds} = [\mathbf{a} \; \mathbf{b}] =
\left[\begin{array}{cc}
a_1 & b_1 \cr
\vdots & \vdots \cr
a_n & b_n \cr
\end{array}\right],\]
where \(a_i \in [- \infty, + \infty]\) and \(b_i \in [- \infty, + \infty]\).
If \(y_i\) is unbounded, the i-th row of <code>bounds</code> would be equal
to <code>c(-Inf, +Inf)</code>.
Notice that if the <code>bounds</code> parameter is used, <code>sol = "osqp"</code> must be used.
This is not true in the case of non-negativity constraints:
</p>

<ul>
<li> <p><code>sol = "direct"</code>: first the base forecasts
are reconciled without non-negativity constraints, then, if negative reconciled
values are present, the <code>"osqp"</code> solver is used;
</p>
</li>
<li> <p><code>sol = "osqp"</code>: the base forecasts are
reconciled using the <code>"osqp"</code> solver.
</p>
</li></ul>

<p>In this case it is not necessary to build a matrix containing
the bounds, and it is sufficient to set <code>nn = "TRUE"</code>.
</p>
<p>Non-negative reconciled forecasts may be obtained by setting <code>nn_type</code> alternatively as:
</p>

<ul>
<li> <p><code>nn_type = "sntz"</code> (&quot;set-negative-to-zero&quot;)
</p>
</li>
<li> <p><code>nn_type = "osqp"</code> (Stellato et al., 2020)
</p>
</li></ul>



<h3>Value</h3>

<p>If the parameter <code>keep</code> is equal to <code>"recf"</code>, then the function
returns only the (\(h \times n\)) reconciled forecasts matrix, otherwise (<code>keep="all"</code>)
it returns a list that mainly depends on what type of representation (<code>type</code>)
and solution technique (<code>sol</code>) have been used:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(h \times n\)) reconciled forecasts matrix, \(\widetilde{\mathbf{Y}}\).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Covariance matrix used for forecast reconciliation, \(\mathbf{W}\).</p>
</td></tr>
<tr><td><code>nn_check</code></td>
<td>
<p>Number of negative values (if zero, there are no values below zero).</p>
</td></tr>
<tr><td><code>rec_check</code></td>
<td>
<p>Logical value: <code>rec_check = TRUE</code> when the constraints have been fulfilled.</p>
</td></tr>
<tr><td><code>varf (type="direct")</code></td>
<td>
<p>(\(n \times 1\)) reconciled forecasts variance vector for \(h=1\), \(\mbox{diag}(\mathbf{MW}\)).</p>
</td></tr>
<tr><td><code>M (type="direct")</code></td>
<td>
<p>Projection matrix, \(\mathbf{M}\) (projection approach).</p>
</td></tr>
<tr><td><code>G (type="S" and type="direct")</code></td>
<td>
<p>Projection matrix, \(\mathbf{G}\) (structural approach, \(\mathbf{M}=\mathbf{S}\mathbf{G}\)).</p>
</td></tr>
<tr><td><code>S (type="S" and type="direct")</code></td>
<td>
<p>Cross-sectional summing matrix, \(\mathbf{S}\).</p>
</td></tr>
<tr><td><code>info (type="osqp")</code></td>
<td>
<p>matrix with information in columns
for each forecast horizon \(h\) (rows): run time (<code>run_time</code>),
number of iteration (<code>iter</code>), norm of primal residual (<code>pri_res</code>),
status of osqp's solution (<code>status</code>) and polish's status
(<code>status_polish</code>). It will also be returned with <code>nn = TRUE</code> if
a solver (see <code>nn_type</code>) will be used.</p>
</td></tr>
</table>
<p>Only if <code>comb = "bu"</code>, the function returns <code>recf</code>, <code>S</code> and <code>M</code>.
</p>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social accounts matrices,
<em>Journal of the Royal Statistical Society A</em>, 141, 3, 359-367.
</p>
<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Di Fonzo, T., Marini, M. (2011), Simultaneous and two-step reconciliation of
systems of time series: methodological and practical issues,
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>,
60, 2, 143-164
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G., Shang, H.L.(2011),
Optimal combination forecasts for hierarchical time series,
<em>Computational Statistics &amp; Data Analysis</em>, 55, 9, 2579-2589.
</p>
<p>Kourentzes, N., Athanasopoulos, G. (2021),
Elucidate structure in intermittent demand series,
<em>European Journal of Operational Research</em>, 288, 1, pp. 141–152.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), <em>Package &lsquo;corpcor&rsquo;</em>, R
package version 1.6.9 (April 1, 2017), <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the &lsquo;OSQP&rsquo; Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>
<p>van Erven, T., Cugliari, J. (2015), Game-theoretically Optimal Reconciliation
of Contemporaneous Hierarchical Time Series Forecasts, in Antoniadis, A.,
Poggi, J.M., Brossat, X. (eds.), <em>Modeling and Stochastic Learning for
Forecasting in High Dimensions</em>, Berlin, Springer, 297-317.
</p>
<p>Wickramasuriya, S.L., Athanasopoulos, G., Hyndman, R.J. (2019), Optimal forecast
reconciliation for hierarchical and grouped time series through trace minimization,
<em>Journal of the American Statistical Association</em>, 114, 526, 804-819.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
# monthly residuals
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)$k1
obj &lt;- htsrec(mbase, C = FoReco_data$C, comb = "shr", res = mres)

# FoReco is able to work also with covariance matrix that are not equal
# across all the forecast horizon. For example, we can consider the
# normalized squared differences (see Di Fonzo and Marini, 2011) where
# Wh = diag(|yh|):
Wh &lt;- lapply(split(mbase, row(mbase)), function(x) diag(abs(x)))

# Now we can introduce the list of the covariance matrix in htsrec throught
# the parameter "W" and setting comb = "w".
objh &lt;- htsrec(mbase, C = FoReco_data$C, W = Wh, comb = "w")

</code></pre>

<hr>
<h2 id='iterec'>Iterative heuristic cross-temporal forecast reconciliation</h2><span id='topic+iterec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Iterative procedure which produces cross-temporally reconciled
forecasts by alternating forecast reconciliation along one single dimension
(either cross-sectional or temporal) at each iteration step. <strong>Each iteration</strong>
consists in the first two steps of the heuristic procedure by Kourentzes and Athanasopoulos (2019),
so the forecasts are reconciled by alternating cross-sectional (contemporaneous) reconciliation,
and reconciliation through temporal hierarchies in a cyclic fashion.
The choice of the dimension along which the first reconciliation step in each
iteration is performed is up to the user (param <code>start_rec</code>), and there is
no particular reason why one should perform the temporal reconciliation first, and
the cross-sectional reconciliation then.
The iterative procedure allows the user to get non-negative reconciled forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterec(basef, thf_comb, hts_comb, res, itmax = 100, tol = 1e-5,
       start_rec = "thf", norm = "inf", note = TRUE, plot = "mti", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterec_+3A_basef">basef</code></td>
<td>
<p>(\(n \times h(k^\ast+m)\)) matrix of base forecasts to be
reconciled, \(\widehat{\mathbf{Y}}\); \(n\) is the total number of variables,
\(m\) is the highest time frequency, \(k^\ast\) is the sum of (a
subset of) (\(p-1\)) factors of \(m\), excluding \(m\), and
\(h\) is the forecast horizon for the lowest frequency time series.
Each row identifies a time series, and the forecasts are ordered as
[lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="iterec_+3A_hts_comb">hts_comb</code>, <code id="iterec_+3A_thf_comb">thf_comb</code></td>
<td>
<p>Type of covariance matrix (respectively
(\(n \times n\)) and (\((k^\ast + m) \times (k^\ast + m)\))) to
be used in the cross-sectional and temporal reconciliation, see more in
<code>comb</code> param of <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>.</p>
</td></tr>
<tr><td><code id="iterec_+3A_res">res</code></td>
<td>
<p>(\(n \times N(k^\ast + m)\)) matrix containing the residuals
at all the temporal frequencies ordered [lowest_freq' ...  highest_freq']'
(columns) for each variable (row), needed to estimate the covariance matrix
when <code>hts_comb =</code> <code>{"wls",</code> <code>"shr",</code> <code>"sam"}</code> and/or
<code>hts_comb =</code> <code>{"wlsv",</code> <code>"wlsh",</code> <code>"acov",</code>
<code>"strar1",</code> <code>"sar1",</code> <code>"har1",</code> <code>"shr",</code> <code>"sam"}</code>.
The row must be in the same order as <code>basef</code>.</p>
</td></tr>
<tr><td><code id="iterec_+3A_itmax">itmax</code></td>
<td>
<p>Max number of iteration (<code>100</code>, <em>default</em>)
(old version <code>maxit</code>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance (<code>1e-5</code>, <em>default</em>).</p>
</td></tr>
<tr><td><code id="iterec_+3A_start_rec">start_rec</code></td>
<td>
<p>Dimension along with the first reconciliation step in each
iteration is performed: it start from temporal reconciliation with
&quot;<code>thf</code>&quot; (<em>default</em>), from cross-sectional with &quot;<code>hts</code>&quot; and
it does both reconciliation with &quot;<code>auto</code>&quot;.</p>
</td></tr>
<tr><td><code id="iterec_+3A_norm">norm</code></td>
<td>
<p>Norm used to calculate the temporal and the cross-sectional
incoherence. There are two alternatives: &quot;<code>inf</code>&quot; (\(\max{|x_1|,
|x_2|,\dots}\), <em>default</em>) or &quot;<code>one</code>&quot; (\(\sum |x_i|\)).</p>
</td></tr>
<tr><td><code id="iterec_+3A_note">note</code></td>
<td>
<p>If <code>note = TRUE</code> (<em>default</em>) the function writes some
notes to the console, otherwise no note is produced (also no plot).</p>
</td></tr>
<tr><td><code id="iterec_+3A_plot">plot</code></td>
<td>
<p>Some useful plots: <code>"mti"</code> (<em>default</em>) marginal trend
inconsistencies, <code>"pat"</code> step by step inconsistency pattern for each
iteration, <code>"distf"</code> distance forecasts iteration i and i-1,
<code>"all"</code> all the plots.</p>
</td></tr>
<tr><td><code id="iterec_+3A_...">...</code></td>
<td>
<p>any other options useful for <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>, e.g. <code>m</code>, <code>C</code> (or <code>Ut</code> and
<code>nb</code>), <code>nn</code> (for non negativity reconciliation only at first step),
<code>mse</code>, <code>corpcor</code>, <code>type</code>, <code>sol</code>, <code>settings</code>,
<code>W</code>, <code>Omega</code>,...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This reconciliation procedure can be seen as an extension of the well known iterative proportional
fitting procedure (Deming and Stephan, 1940, Johnston and Pattie, 1993), also known as
RAS method (Miller and Blair, 2009), to adjust the internal cell values of a
two-dimensional matrix until they sum to some predetermined row and column
totals. In that case the adjustment follows a proportional adjustment scheme, whereas
in the cross-temporal reconciliation framework each adjustment step is made according to
the penalty function associated to the single-dimension reconciliation procedure adopted.
</p>
<p>Control status of iterative reconciliation:
</p>

<dl>
<dt><code>-2</code></dt><dd><p>Temporal/Cross-sectional reconciliation does not work.</p>
</dd>
<dt><code>-1</code></dt><dd><p>Convergence not achieved (maximum iteration limit reached).</p>
</dd>
<dt><code>0</code></dt><dd><p>Convergence achieved.</p>
</dd>
<dt><code>+1</code></dt><dd><p>Convergence achieved: incoherence has increased in the next
iteration (at least one time).</p>
</dd>
<dt><code>+2</code></dt><dd><p>Convergence achieved: incoherence has increased in the next
two or more iteration (at least one time).</p>
</dd>
<dt><code>+3</code></dt><dd><p>The forecasts are already reconciled.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>iterec</code> returns a list with:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(n \times h(k^\ast + m)\)) reconciled forecasts matrix, \(\widetilde{\mathbf{Y}}\).</p>
</td></tr>
<tr><td><code>d_cs</code></td>
<td>
<p>Cross-sectional incoherence at each iteration.</p>
</td></tr>
<tr><td><code>d_te</code></td>
<td>
<p>Temporal incoherence at each iteration.</p>
</td></tr>
<tr><td><code>start_rec</code></td>
<td>
<p>Starting coherence dimension (thf or hts).</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>Control code (see <em>details</em>).</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Elapsed time.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>If <code>start_rec = "auto"</code>, matrix of distances of the forecasts reconciled
from the base.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Deming, E., Stephan, F.F. (1940), On a least squares adjustment of a sampled frequency
table when the expected marginal totals are known, <em>The Annals of Mathematical
Statistics</em>, 11, 4, 427–444.
</p>
<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Johnston, R.J., Pattie, C.J. (1993), Entropy-Maximizing and the Iterative Proportional
Fitting Procedure, <em>The Professional Geographer</em>, 45, 3, 317–322.
</p>
<p>Kourentzes, N., Athanasopoulos, G. (2019), Cross-temporal coherent forecasts
for Australian tourism, <em>Annals of Tourism Research</em>, 75, 393-409.
</p>
<p>Miller, R.E., Blair, P.D. (2009), Input-output analysis: foundations and extensions,
2nd edition, New York, Cambridge University Press.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), <em>Package &lsquo;corpcor&rsquo;</em>, R
package version 1.6.9 (April 1, 2017),
<a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the &lsquo;OSQP&rsquo; Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FoReco_data)
obj &lt;- iterec(FoReco_data$base, note = FALSE,
  m = 12, C = FoReco_data$C, thf_comb = "acov",
  hts_comb = "shr", res = FoReco_data$res, start_rec = "thf")


</code></pre>

<hr>
<h2 id='lccrec'>Level conditional coherent forecast reconciliation for genuine hierarchical/grouped time series</h2><span id='topic+lccrec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Forecast reconciliation procedure built on and extending the original
proposal by Hollyman et al. (2021). Level conditional coherent
reconciled forecasts may be computed in cross-sectional, temporal, and
cross-temporal frameworks. The reconciled forecasts are conditional to (i.e.,
constrained by) the base forecasts of a specific upper level of the hierarchy
(exogenous constraints). The linear constraints linking the variables may be
dealt with endogenously as well (Di Fonzo and Girolimetto, 2022).
<em>Combined Conditional Coherent</em> (CCC)
forecasts may be calculated as simple averages of LCC and bottom-up
reconciled forecasts, with either endogenous or exogenous constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lccrec(basef, m, C, nl, weights, bnaive = NULL, const = "exogenous",
       CCC = TRUE, nn = FALSE, nn_type = "osqp", settings = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lccrec_+3A_basef">basef</code></td>
<td>
<p>matrix/vector of base forecasts to be reconciled:
(\(h \times n\)) matrix in the cross-sectional framework;
(\(h(k^\ast + m) \times 1\)) vector in the temporal framework;
(\(n \times h(k^\ast+m)\)) matrix in the cross-temporal framework.
\(n\) is the total number of variables, \(m\) is the highest time
frequency, \(k^\ast\) is the sum of (a subset of) (\(p-1\)) factors
of \(m\), excluding \(m\), and \(h\) is the forecast horizon.</p>
</td></tr>
<tr><td><code id="lccrec_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of the \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones (or a list
of matrices forming \(\mathbf{C} = [\mathbf{C}_1' \; \mathbf{C}_2' \; ... \; \mathbf{C}_L']'\),
\(1, ..., L\) being the number of the cross-sectional upper levels.</p>
</td></tr>
<tr><td><code id="lccrec_+3A_nl">nl</code></td>
<td>
<p>(\(L \times 1\)) vector containing the number of time series
in each level of the hierarchy (<code>nl[1] = 1</code>).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_weights">weights</code></td>
<td>
<p>covariance matrix or a vector (weights used in the reconciliation:
either (\(n_b \times 1\)) for exogenous or (\(n \times 1\)) for
endogenous constraints).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_bnaive">bnaive</code></td>
<td>
<p>matrix/vector of naive bts base forecasts
(e.g., seasonal averages, as in Hollyman et al., 2021):
(\(h \times n_b\)) matrix in the cross-sectional framework;
(\(h m \times 1\)) vector in the temporal framework;
(\(n_b \times h m\)) matrix in the cross-temporal framework.
Ignore it, if only basef are to be used as base forecasts.</p>
</td></tr>
<tr><td><code id="lccrec_+3A_const">const</code></td>
<td>
<p><strong>exo</strong>genous (<em>default</em>) or <strong>endo</strong>genous
constraints</p>
</td></tr>
<tr><td><code id="lccrec_+3A_ccc">CCC</code></td>
<td>
<p>Option to return Combined Conditional Coherent reconciled
forecasts (<em>default</em> is TRUE).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_nn">nn</code></td>
<td>
<p>Logical value: <code>TRUE</code> if non-negative reconciled forecasts
are wished.</p>
</td></tr>
<tr><td><code id="lccrec_+3A_nn_type">nn_type</code></td>
<td>
<p>Non-negative method: &quot;osqp&quot; (<em>default</em>) or &quot;sntz&quot;
(<em>set-negative-to-zero</em>, only if <code>CCC = TRUE</code>) with exogenous
constraints (<code>const = "exo"</code>); &quot;osqp&quot; (<em>default</em>), &quot;KAnn&quot;
(only <code>type == "M"</code>) or &quot;sntz&quot; with endogenous constraints
(<code>const = "endo"</code>).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_settings">settings</code></td>
<td>
<p>Settings for <span class="pkg">osqp</span> (object <code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>).
The default options are: <code>verbose = FALSE</code>, <code>eps_abs = 1e-5</code>,
<code>eps_rel = 1e-5</code>, <code>polish_refine_iter = 100</code> and <code>polish = TRUE</code>.
For details, see the <a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a>
(Stellato et al., 2019).</p>
</td></tr>
<tr><td><code id="lccrec_+3A_...">...</code></td>
<td>
<p>Additional functional arguments passed to <a href="#topic+htsrec">htsrec</a> of
FoReco.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Cross-sectional hierarchies</strong>
</p>
<p>To be as simple as possible, we fix the forecast horizon equal to 1.
Let the base forecasts be a vector \(\widehat{\mathbf{y}} =
\left[\widehat{\mathbf{a}}' \; \widehat{\mathbf{b}}'\right]'\), where
vector \(\widehat{\mathbf{a}}\) consists of the sub-vectors forming each
of the upper \(L\) levels of the hierarchy/grouping:
\[\widehat{\mathbf{a}} = \left[\begin{array}{c}
    \widehat{a}_1 \cr \widehat{\mathbf{a}}_2 \cr \vdots \cr \widehat{\mathbf{a}}_L
    \end{array}\right],\]
where \(\widehat{\mathbf{a}}_l\), \(l=1,\ldots, L\), has dimension
\((n_l \times 1)\) and \(\sum_{l=1}^{L} n_l = n_a\). Denote
\(\mathbf{C}_l\) the \((n_l \times n_b)\) matrix mapping the
bts into the level-\(l\) uts, then the aggregation matrix
\(\mathbf{C}\) may be written as
\[\mathbf{C} = \left[\begin{array}{c}
  \mathbf{C}_1 \cr\mathbf{C}_2 \cr \vdots \cr \mathbf{C}_L
  \end{array}\right],\]
where the generic matrix \(\mathbf{C}_L\) is (\(n_L \times n_b\)),
\(l=1, \ldots, L\). Given a generic level \(l\), the reconciled
forecasts coherent with the base forecasts of that level are the solution to
a quadratic minimization problem with linear
exogenous constraints (<code>const = "exo"</code>):
\[\begin{array}{c}\widetilde{\mathbf{b}}_{l} = \arg\min_{\mathbf{b}}
\left(\mathbf{b} - \widehat{\mathbf{b}}\right)'\mathbf{W}_b^{-1}
\left(\mathbf{b} - \widehat{\mathbf{b}}\right) \quad \mbox{ s.t. }
\mathbf{C}_l\mathbf{b} = \widehat{\mathbf{a}}_l, \quad l=1, \ldots, L ,\cr
\Downarrow \cr
\widetilde{\mathbf{b}}_{l} = \widehat{\mathbf{b}} +
\mathbf{W}_b\mathbf{C}_l'\left(\mathbf{C}_l\mathbf{W}_b\mathbf{C}_l'
\right)^{-1}\left(\widehat{\mathbf{a}}_l -\mathbf{C}_l\widehat{\mathbf{b}}
\right), \quad l=1,\ldots,L,\end{array}\]
where \(\mathbf{W}_b\) is a (\(n_b \times n_b\)) p.d. matrix
(in Hollyman et al., 2021, \(\mathbf{W}_b\) is diagonal).
If endogenous constraints (<code>const = "endo"</code>) are considered,
denote \(\widehat{\mathbf{y}}_l =
\left[\widehat{\mathbf{a}}_l' \; \widehat{\mathbf{b}}'\right]'\) and
\(\mathbf{U}_l' = \left[\mathbf{I}_{n_l}'  \; \mathbf{C}_l'\right]'\),
then
\[\begin{array}{c}\widetilde{\mathbf{y}}_{l} = \arg\min_{\mathbf{y}_l}
\left(\mathbf{y}_l - \widehat{\mathbf{y}}_l\right)'\mathbf{W}_l^{-1}
\left(\mathbf{y}_l - \widehat{\mathbf{y}}_l\right) \quad \mbox{ s.t. }
\mathbf{U}_l'\mathbf{y}_l = \mathbf{0}, \quad l=1, \ldots, L ,\cr
\Downarrow \cr
\widetilde{\mathbf{y}}_{l} = \left(\mathbf{I}_{n_b+n_l} -
\mathbf{W}_l\mathbf{U}_l\left(\mathbf{U}_l'\mathbf{W}_l
\mathbf{U}_l\right)^{-1}\mathbf{U}_l'\right)\widehat{\mathbf{y}}_{l},
\quad l=1,...,L,
\end{array}\]
where \(\mathbf{W}_l\) is a (\(n_l + n_b \times n_l + n_b\))
p.d. matrix.
Combined Conditional Coherent (CCC) forecasts are obtained by taking
the simple average of the \(L\) level conditional, and of the bottom-up
reconciled forecasts, respectively (Di Fonzo and Girolimetto, 2022):
\[\widetilde{\mathbf{y}}_{CCC}=\frac{1}{L+1}\sum_{l=1}^{L+1} \mathbf{S}\widetilde{\mathbf{b}}_l,\]
with \[\widetilde{\mathbf{b}}_{L+1} = \widehat{\mathbf{b}}.\]
</p>
<p>Non-negative reconciled forecasts may be obtained by setting <code>nn_type</code>
alternatively as:
</p>

<ul>
<li> <p><code>nn_type = "osqp"</code> to apply non-negative constraints to each level:
</p>
</li>
<li> <p><code>nn_type = "sntz"</code> (&quot;set-negative-to-zero&quot;) to apply non-negative constraints only to the CCC forecasts:
</p>
</li></ul>

<p><strong>Temporal hierarchies</strong>
</p>
<p>The extension to the case of <strong>temporal hierarchies</strong> is quite simple.
Using the same notation as in <code><a href="#topic+thfrec">thfrec</a>()</code>, the
following &lsquo;equivalences&rsquo; hold between the symbols used
for the level conditional cross-sectional reconciliation and the ones
used in temporal reconciliation:
\[L \equiv p-1, \quad (n_a, n_b, n) \equiv (k^*, m, k^*+m),\]
and
\[\mathbf{C} \equiv \mathbf{K} , \;
\mathbf{C}_1 \equiv \mathbf{K}_1 = \mathbf{1}_m', \;
\mathbf{C}_2 \equiv \mathbf{K}_2 = \mathbf{I}_{\frac{m}{k_{p-1}}},\; \ldots, \;
\mathbf{C}_L \equiv \mathbf{K}_{p-1} = \mathbf{I}_{\frac{m}{k_{2}}} \otimes
\mathbf{1}_{k_{2}}',\; \mathbf{S} \equiv \mathbf{R}.\]
</p>
<p>The description of the <strong>cross-temporal extension</strong> is currently under progress.
</p>


<h3>Value</h3>

<p>The function returns the level reconciled forecasts
in case of an elementary hierarchy with one level.
Otherwise it returns a list with
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>Level Conditional Coherent (<code>CCC = FALSE</code>) forecasts
matrix/vector calculated as simple averages of upper level conditional
reconciled forecasts, with either endogenous or exogenous constraints.
If <code>CCC = TRUE</code> then it is the Combined Conditional Coherent matrix/vector,
as weighted averages of LCC and bottom-up reconciled forecasts.</p>
</td></tr>
<tr><td><code>levrecf</code></td>
<td>
<p>list of level conditional reconciled forecasts (+ BU).</p>
</td></tr>
<tr><td><code>info (type="osqp")</code></td>
<td>
<p>matrix with some useful indicators (columns)
for each forecast horizon \(h\) (rows): run time (<code>run_time</code>), number of iteration,
norm of primal residual (<code>pri_res</code>), status of osqp's solution (<code>status</code>) and
polish's status (<code>status_polish</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Di Fonzo, T., Girolimetto, D. (2022), Forecast combination based forecast reconciliation:
insights and extensions, <em>International Journal of Forecasting</em>, in press.
</p>
<p>Hollyman, R., Petropoulos, F., Tipping, M.E. (2021), Understanding Forecast Reconciliation,
<em>European Journal of Operational Research</em> (in press).
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
### LCC and CCC CROSS-SECTIONAL FORECAST RECONCILIATION
# Cross sectional aggregation matrix
C &lt;- rbind(FoReco_data$C, c(0,0,0,0,1))
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
mbase &lt;- mbase[, c("T", "A","B","C","AA","AB","BA","BB","C")]
# residuals
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)$k1
mres &lt;- mres[, c("T", "A","B","C","AA","AB","BA","BB","C")]
# covariance matrix of all the base forecasts, computed using the in-sample residuals
Wres &lt;- cov(mres)
# covariance matrix of the bts base forecasts, computed using the in-sample residuals
Wb &lt;- Wres[c("AA","AB", "BA", "BB", "C"),
           c("AA","AB", "BA", "BB", "C")]
# bts seasonal averages
obs_1 &lt;- FoReco_data$obs$k1
bts_sm &lt;- apply(obs_1, 2, function(x) tapply(x[1:168],rep(1:12, 14), mean))
bts_sm &lt;- bts_sm[,c("AA", "AB", "BA", "BB", "C")]

## EXOGENOUS CONSTRAINTS AND DIAGONAL COVARIANCE MATRIX (Hollyman et al., 2021)
# Forecast reconciliation for an elementary hierarchy:
# 1 top-level series + 5 bottom-level series (Level 2 base forecasts are not considered).
# The input is given by the base forecasts of the top and bottom levels series,
# along with a vector of positive weights for the bts base forecasts
exo_EHd &lt;- lccrec(basef = mbase[, c("T","AA","AB", "BA", "BB", "C")],
                 weights = diag(Wb), bnaive = bts_sm)

# Level conditional reconciled forecasts
# recf/L1: Level 1 reconciled forecasts for the whole hierarchy
# L2: Middle-Out reconciled forecasts hinging on Level 2 conditional reconciled forecasts
# L3: Bottom-Up reconciled forecasts
exo_LCd &lt;- lccrec(basef = mbase, C = C, nl = c(1,3), weights = diag(Wb),
                 CCC = FALSE, bnaive = bts_sm)

# Combined Conditional Coherent (CCC) reconciled forecasts
# recf: CCC reconciled forecasts matrix
# L1: Level 1 conditional reconciled forecasts for the whole hierarchy
# L2: Middle-Out reconciled forecasts hinging on Level 2 conditional reconciled forecasts
# L3: Bottom-Up reconciled forecasts
exo_CCCd &lt;- lccrec(basef = mbase, C = C, nl = c(1,3), weights = diag(Wb))

## EXOGENOUS CONSTRAINTS AND FULL COVARIANCE MATRIX
# Simply substitute weights=diag(Wb) with weights=Wb
exo_EHf &lt;- lccrec(basef = mbase[, c("T","AA","AB", "BA", "BB", "C")], weights = Wb, bnaive = bts_sm)
exo_LCf &lt;- lccrec(basef = mbase, C = C, nl = c(1,3), weights = Wb, CCC = FALSE, bnaive = bts_sm)
exo_CCCf &lt;- lccrec(basef = mbase, C = C, nl = c(1,3), weights = Wb, bnaive = bts_sm)

## ENDOGENOUS CONSTRAINTS AND DIAGONAL COVARIANCE MATRIX
# parameters of function htsrec(), like "type" and "nn_type" may be used

# Forecast reconciliation for an elementary hierarchy with endogenous constraints
W1 &lt;- Wres[c("T","AA","AB", "BA", "BB", "C"),
           c("T","AA","AB", "BA", "BB", "C")]
endo_EHd &lt;- lccrec(basef = mbase[, c("T","AA","AB", "BA", "BB", "C")],
                 weights = diag(W1), const = "endo", CCC = FALSE)

# Level conditional reconciled forecasts with endogenous constraints
endo_LCd &lt;- lccrec(basef = mbase, C = C, nl = c(1,3), weights = diag(Wres),
                  const = "endo", CCC = FALSE)

# Combined Conditional Coherent (CCC) reconciled forecasts with endogenous constraints
endo_CCCd &lt;- lccrec(basef = mbase, C = C, nl = c(1,3),
                    weights = diag(Wres), const = "endo")

## ENDOGENOUS CONSTRAINTS AND FULL COVARIANCE MATRIX
# Simply substitute weights=diag(Wres) with weights=Wres
endo_EHf &lt;- lccrec(basef = mbase[, c("T","AA","AB", "BA", "BB", "C")],
                   weights = W1,
                   const = "endo")
endo_LCf &lt;- lccrec(basef = mbase, C = C, nl = c(1,3),
                   weights = Wres, const = "endo", CCC = FALSE)
endo_CCCf &lt;- lccrec(basef = mbase-40, C = C, nl = c(1,3),
                   weights = Wres, const = "endo")

### LCC and CCC TEMPORAL FORECAST RECONCILIATION
# top ts base forecasts ([lowest_freq' ...  highest_freq']')
topbase &lt;- FoReco_data$base[1, ]
# top ts residuals ([lowest_freq' ...  highest_freq']')
topres &lt;- FoReco_data$res[1, ]
Om_bt &lt;- cov(matrix(topres[which(simplify2array(strsplit(names(topres),
            "_"))[1,]=="k1")], ncol = 12, byrow = TRUE))
t_exo_LCd &lt;- lccrec(basef = topbase, m = 12, weights = diag(Om_bt), CCC = FALSE)
t_exo_CCCd &lt;- lccrec(basef = topbase, m = 12, weights = diag(Om_bt))

### LCC and CCC CROSS-TEMPORAL FORECAST RECONCILIATION
idr &lt;- which(simplify2array(strsplit(colnames(FoReco_data$res), "_"))[1,]=="k1")
bres &lt;- FoReco_data$res[-c(1:3), idr]
bres &lt;- lapply(1:5, function(x) matrix(bres[x,], nrow=14, byrow = TRUE))
bres &lt;- do.call(cbind, bres)
ctbase &lt;- FoReco_data$base[c("T", "A","B","C","AA","AB","BA","BB","C"),]
ct_exo_LCf &lt;- lccrec(basef = ctbase, m = 12, C = C, nl = c(1,3),
                    weights = diag(cov(bres)), CCC = FALSE)
ct_exo_CCCf &lt;- lccrec(basef = ctbase, m = 12, C = C, nl = c(1,3),
                     weights = diag(cov(bres)), CCC = TRUE)

</code></pre>

<hr>
<h2 id='lcmat'>Linear Combination Matrix for a general linearly constrained multiple time series</h2><span id='topic+lcmat'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>When working with a general linearly constrained multiple (\(n\)-variate) time series
(\(\mathbf{x}_t\)), getting a linear combination matrix
\(\bar{\mathbf{C}}\) is a critical step to obtain a <em>structural-like</em>
representation such that, for \(t = 1, ..., T\),
\[\bar{\mathbf{U}}'= [\mathbf{I} \quad -\bar{\mathbf{C}}] \quad \Rightarrow
\quad \mathbf{y}_t = \mathbf{P}\mathbf{x}_t = \left[\begin{array}{c}
\mathbf{v}_t\cr
\mathbf{f}_t
\end{array}\right] = \left[\begin{array}{c}
\mathbf{\bar{\mathbf{C}}}\cr
\mathbf{I}
\end{array}\right]\mathbf{f}_t = \mathbf{\bar{\mathbf{S}}}\mathbf{f}_t,\]
where \(\bar{\mathbf{U}}'\) is the (\(n_v \times n\)) full rank zero constraints matrix,
\(\bar{\mathbf{S}}\) is the (\(n \times n_f\)) matrix analogous of the summing matrix
\(\mathbf{S}\) for a genuine hierarchical/groupped times series,
\(\bar{\mathbf{C}}\) is the (\(n_v \times n_f\)) linear combination matrix
such that \(\mathbf{v}_t = \bar{\mathbf{C}}\mathbf{f}_t\),
\(\mathbf{v}_t\) is the (\(n_v \times 1\)) vector of ‘basic’ variables, and
\(\mathbf{f}_t\) is the (\(n_f \times 1\)) vector of ‘free’ variables
(Di Fonzo and Girolimetto, 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcmat(Gt, alg = "rref", tol = sqrt(.Machine$double.eps),
       verbose = FALSE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcmat_+3A_gt">Gt</code></td>
<td>
<p>(\(r \times n\)) coefficient matrix (\(\mathbf{\Gamma}'\))
for a general linearly constrained multiple time series (\(\mathbf{x}_t\))
such that \(\mathbf{\Gamma}'\mathbf{x}_t = \mathbf{0}_{(r \times 1)}\).</p>
</td></tr>
<tr><td><code id="lcmat_+3A_alg">alg</code></td>
<td>
<p>Technique used to trasform \(\mathbf{\Gamma}'\) in
\(\bar{\mathbf{U}}' = [\mathbf{I} \quad -\bar{\mathbf{C}}]\), such that
\(\bar{\mathbf{U}'}\mathbf{y}_t = \mathbf{0}_{(n_v \times 1)}\). Use
<code>"rref"</code> for the Row Reduced Echelon Form through Gauss-Jordan elimination
(<em>default</em>), or <code>"qr"</code> for the (pivoting) QR decomposition (Strang, 2019).</p>
</td></tr>
<tr><td><code id="lcmat_+3A_tol">tol</code></td>
<td>
<p>Tolerance for the <code>"rref"</code> or  <code>"qr"</code> algorithm.</p>
</td></tr>
<tr><td><code id="lcmat_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate steps are printed (<em>default</em> is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lcmat_+3A_sparse">sparse</code></td>
<td>
<p>Option to return a sparse \(\bar{\mathbf{C}}\)
matrix (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking for an analogous of the summing matrix \(\mathbf{S}\), say
\(\bar{\mathbf{S}} = \left[\begin{array}{c}
\mathbf{\bar{\mathbf{C}}}\cr
\mathbf{I}
\end{array}\right]\), the <code>lcmat</code> function transforms  \(\mathbf{\Gamma}'\) into
\(\bar{\mathbf{U}}' = [\mathbf{I} \quad -\bar{\mathbf{C}}]\), such that
\(\bar{\mathbf{U}}'\mathbf{y}_t = \mathbf{0}_{(n_v \times 1)}\).
Consider the simple example of a linearly constrained multiple time series consisting
of two hierarchies, each with distinct bottom time series,
with a common top-level series (\(X\)):
\[\begin{array}{l}
1)\; X = C + D,\cr
2)\; X = A + B, \cr
3)\; A = A1 + A2.
\end{array}\]
The coefficient matrix \(\mathbf{\Gamma}'\) of the linear system
\(\mathbf{\Gamma}'\mathbf{x}_t=\mathbf{0}\)
(\(\mathbf{x}_t = [X\; C\; D\; A\; B\; A1\; A2]\)) is
\[\mathbf{\Gamma}' = \left[\begin{array}{ccccccc}
1 & -1 & -1 & 0 & 0 & 0 & 0 \cr
1 & 0 & 0 & -1 & -1 & 0 & 0 \cr
0 & 0 & 0 & 1 & 0 & -1 & -1
\end{array}\right].\]
The <a href="#topic+lcmat">lcmat</a> function returns
\[\bar{\mathbf{C}} = \left[\begin{array}{cccc}
0 & 1 & 1 & 1 \cr
-1 & 1 & 1 & 1 \cr
0 & 0 & -1 & -1
\end{array}\right].\]
Then
\[\bar{\mathbf{U}}' = \left[\begin{array}{ccc|cccc}
1 & 0 & 0 & 0 & -1 & -1 & -1 \cr
0 & 1 & 0 & 1 & -1 & -1 & -1 \cr
0 & 0 & 1 & 0 & 0 & 1 & 1
\end{array}\right], \quad \mbox{with} \quad
\bar{\mathbf{U}}'\mathbf{y}_t = \bar{\mathbf{U}}' \left[\begin{array}{c}
\mathbf{v}_t \cr
\mathbf{f}_t
\end{array}\right] = \mathbf{0},\]
where \(\mathbf{v}_t = [X\; C\; A]\), and
\(\mathbf{f}_t = [D\; B\; A1\; A2]\).
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>Cbar</code></td>
<td>
<p>(\(n_v \times n_f\)) linear combination matrix \(\bar{\mathbf{C}}\)</p>
</td></tr>
<tr><td><code>pivot</code></td>
<td>
<p>(\(n \times 1\)) vector of the column permutations
s.t. \(\mathbf{P} = \mathbf{I}[,\mbox{pivot}]\)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Di Fonzo, T., Girolimetto, D. (2022), <em>Point and probabilistic forecast reconciliation
for general linearly constrained multiple time series</em> (mimeo).
</p>
<p>Strang, G., (2019), <em>Linear algebra and learning from data</em>, Wellesley, Cambridge Press.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gt &lt;- matrix(c(1,-1,-1,0,0,0,0,
               1,0,0,-1,-1,0,0,
               0,0,0,1,0,-1,-1), nrow = 3, byrow = TRUE)
Cbar &lt;- lcmat(Gt = Gt)$Cbar
P &lt;- diag(1, NCOL(Gt))[,lcmat(Gt = Gt)$pivot]

</code></pre>

<hr>
<h2 id='oct_bounds'>Optimal cross-temporal bounds</h2><span id='topic+oct_bounds'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function to export the constraints designed for the cross-sectional and/or
temporal reconciled forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oct_bounds(hts_bounds, thf_bounds, m, C, Ut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oct_bounds_+3A_hts_bounds">hts_bounds</code></td>
<td>
<p>(\(n \times 2\)) matrix with cross-sectional bounds:
the first column is the lower bound, and the second column is the upper bound.</p>
</td></tr>
<tr><td><code id="oct_bounds_+3A_thf_bounds">thf_bounds</code></td>
<td>
<p>(\((k^\ast + m) \times 2\)) matrix with temporal bounds:
the first column is the lower bound, and the second column is the upper bound.</p>
</td></tr>
<tr><td><code id="oct_bounds_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="oct_bounds_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
<tr><td><code id="oct_bounds_+3A_ut">Ut</code></td>
<td>
<p>Zero constraints cross-sectional (contemporaneous) kernel matrix
\((\mathbf{U}'\mathbf{y} = \mathbf{0})\) spanning the null space valid
for the reconciled forecasts. It can be used instead of parameter
<code>C</code>, but <code>nb</code> (\(n = n_a + n_b\)) is needed if
\(\mathbf{U}' \neq [\mathbf{I} \ -\mathbf{C}]\). If the hierarchy
admits a structural representation, \(\mathbf{U}'\) has dimension
(\(n_a \times n\)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the cross-temporal bounds.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
# monthly residuals
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)$k1

# For example, in FoReco_data we want that BA &gt; 78, and C &gt; 50
cs_bound &lt;- matrix(c(rep(-Inf, 5), 78, -Inf, 50, rep(+Inf, 8)), ncol = 2)
## Cross-sectional reconciliation
csobj &lt;- htsrec(mbase, C = FoReco_data$C, comb = "shr", res = mres, bounds = cs_bound)

# Extension of the constraints to the cross-temporal case
ct_bound &lt;- oct_bounds(hts_bounds = cs_bound, m = 12)
## Cross-temporal reconciliation
obj &lt;- octrec(FoReco_data$base, m = 12, C = FoReco_data$C, comb = "bdshr",
              res = FoReco_data$res, bounds = ct_bound)

</code></pre>

<hr>
<h2 id='octrec'>Optimal combination cross-temporal forecast reconciliation</h2><span id='topic+octrec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Optimal (in least squares sense) combination cross-temporal forecast
reconciliation. The reconciled forecasts are calculated either through a
projection approach (Byron, 1978), or the equivalent structural approach
by Hyndman et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>octrec(basef, m, C, comb, res, Ut, nb, mse = TRUE, corpcor = FALSE,
       type = "M", sol = "direct", keep = "list", v = NULL, nn = FALSE,
       nn_type = "osqp", settings = list(), bounds = NULL, W = NULL,
       Omega = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octrec_+3A_basef">basef</code></td>
<td>
<p>(\(n \times h(k^\ast+m)\)) matrix of base forecasts to be
reconciled, \(\widehat{\mathbf{Y}}\); \(n\) is the total number of variables,
\(m\) is the highest time frequency, \(k^\ast\) is the sum of (a
subset of) (\(p-1\)) factors of \(m\), excluding \(m\), and
\(h\) is the forecast horizon for the lowest frequency time series.
Each row identifies a time series, and the forecasts are ordered as
[lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="octrec_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="octrec_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the bottom level series into the higher level ones.</p>
</td></tr>
<tr><td><code id="octrec_+3A_comb">comb</code></td>
<td>
<p>Type of the reconciliation. It corresponds to a specific
(\(n(k\ast + m) \times n(k^\ast + m)\)) covariance matrix (Di Fonzo and Girolimetto 2023,
Girolimetto et al. 2023), where \(k^\ast\) is the sum of (a subset of) (\(p-1\))
factors of \(m\) (\(m\) is not considered) and \(n\) is the number
of variables:
</p>

<ul>
<li> <p><b>ols</b> (Identity);
</p>
</li>
<li> <p><b>struc</b> (Cross-temporal structural variances);
</p>
</li>
<li> <p><b>cs_struc</b> (Cross-sectional structural variances and temporal independence);
</p>
</li>
<li> <p><b>t_struc</b> (Cross-sectional independence and temporal structural variances);
</p>
</li>
<li> <p><b>wlsh</b> (Hierarchy variances);
</p>
</li>
<li> <p><b>wlsv</b> (Series variances);
</p>
</li>
<li> <p><b>bdshr</b> (Shrunk cross-covariance matrix, cross-sectional framework);
</p>
</li>
<li> <p><b>bdsam</b> (Sample cross-covariance matrix, cross-sectional framework);
</p>
</li>
<li> <p><b>acov</b> (Series auto-covariance matrix);
</p>
</li>
<li> <p><b>Sshr</b> (Series shrunk cross-covariance matrix);
</p>
</li>
<li> <p><b>Ssam</b> (Series cross-covariance matrix);
</p>
</li>
<li> <p><b>shr</b> (Shrunk cross-covariance matrix);
</p>
</li>
<li> <p><b>sam</b> (Sample cross-covariance matrix);
</p>
</li>
<li> <p><b>hbshr</b> (Shrunk high frequency bottom time series cross-covariance matrix);
</p>
</li>
<li> <p><b>hbsam</b> (Sample high frequency bottom time series cross-covariance matrix);
</p>
</li>
<li> <p><b>bshr</b> (Shrunk bottom time series cross-covariance matrix);
</p>
</li>
<li> <p><b>bsam</b> (Sample bottom time series cross-covariance matrix);
</p>
</li>
<li> <p><b>hshr</b> (Shrunk high frequency cross-covariance matrix);
</p>
</li>
<li> <p><b>hsam</b> (Sample high frequency cross-covariance matrix);
</p>
</li>
<li> <p><b>w</b> use your personal matrix W in param <code>W</code>;
</p>
</li>
<li> <p><b>omega</b> use your personal matrix Omega in param <code>Omega</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="octrec_+3A_res">res</code></td>
<td>
<p>(\(n \times N(k^\ast + m)\)) matrix containing the residuals at
all the temporal frequencies ordered [lowest_freq' ...  highest_freq']'
(columns) for each variable (row), needed to estimate the covariance matrix.</p>
</td></tr>
<tr><td><code id="octrec_+3A_ut">Ut</code></td>
<td>
<p>Zero constraints cross-sectional (contemporaneous) kernel matrix
\((\textbf{U}'\textbf{y} = \mathbf{0})\) spanning the null space valid
for the reconciled forecasts. It can be used instead of parameter
<code>C</code>, but <code>nb</code> (\(n = n_a + n_b\)) is needed if
\(\textbf{U}' \neq [\textbf{I} \ -\textbf{C}]\). If the hierarchy
admits a structural representation, \(\textbf{U}'\) has dimension
(\(n_a \times n\)).</p>
</td></tr>
<tr><td><code id="octrec_+3A_nb">nb</code></td>
<td>
<p>Number of bottom time series; if <code>C</code> is present, <code>nb</code>
and <code>Ut</code> are not used.</p>
</td></tr>
<tr><td><code id="octrec_+3A_mse">mse</code></td>
<td>
<p>Logical value: <code>TRUE</code> (<em>default</em>) calculates the
covariance matrix of the in-sample residuals (when necessary) according to
the original <span class="pkg">hts</span> and <span class="pkg">thief</span> formulation: no mean correction,
T as denominator.</p>
</td></tr>
<tr><td><code id="octrec_+3A_corpcor">corpcor</code></td>
<td>
<p>Logical value: <code>TRUE</code> if <span class="pkg">corpcor</span> (Schäfer et
al., 2017) must be used to shrink the sample covariance matrix according to
Schäfer and Strimmer (2005), otherwise the function uses the
same implementation as package <span class="pkg">hts</span>.</p>
</td></tr>
<tr><td><code id="octrec_+3A_type">type</code></td>
<td>
<p>Approach used to compute the reconciled forecasts: <code>"M"</code> for
the projection approach with matrix M (<em>default</em>), or <code>"S"</code> for the
structural approach with summing matrix S.</p>
</td></tr>
<tr><td><code id="octrec_+3A_sol">sol</code></td>
<td>
<p>Solution technique for the reconciliation problem: either
<code>"direct"</code> (<em>default</em>) for the closed-form matrix solution, or
<code>"osqp"</code> for the numerical solution (solving a linearly constrained
quadratic program using <code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code>).</p>
</td></tr>
<tr><td><code id="octrec_+3A_keep">keep</code></td>
<td>
<p>Return a list object of the reconciled forecasts at all levels
(if keep = &quot;list&quot;) or only the reconciled forecasts matrix (if keep = &quot;recf&quot;).</p>
</td></tr>
<tr><td><code id="octrec_+3A_v">v</code></td>
<td>
<p>vector index of the fixed base forecast (\(\mbox{min}(v) > 0\)
and \(\mbox{max}(v) < n(k^\ast + m)\)).</p>
</td></tr>
<tr><td><code id="octrec_+3A_nn">nn</code></td>
<td>
<p>Logical value: <code>TRUE</code> if non-negative reconciled forecasts
are wished.</p>
</td></tr>
<tr><td><code id="octrec_+3A_nn_type">nn_type</code></td>
<td>
<p>&quot;osqp&quot; (default), &quot;KAnn&quot; (only <code>type == "M"</code>) or &quot;sntz&quot;.</p>
</td></tr>
<tr><td><code id="octrec_+3A_settings">settings</code></td>
<td>
<p>Settings for <span class="pkg">osqp</span> (object <code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>).
The default options are: <code>verbose = FALSE</code>, <code>eps_abs = 1e-5</code>,
<code>eps_rel = 1e-5</code>, <code>polish_refine_iter = 100</code> and <code>polish = TRUE</code>.
For details, see the <a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a>
(Stellato et al., 2019).</p>
</td></tr>
<tr><td><code id="octrec_+3A_bounds">bounds</code></td>
<td>
<p>(\(n(k^\ast + m) \times 2\)) matrix of the bounds on the
variables: the first column is the lower bound, and the second column is the
upper bound.</p>
</td></tr>
<tr><td><code id="octrec_+3A_w">W</code>, <code id="octrec_+3A_omega">Omega</code></td>
<td>
<p>This option permits to directly enter the covariance matrix:
</p>

<ol>
<li> <p><code>W</code> must be a p.d. (\(n(k^\ast + m) \times n(k^\ast + m)\))
matrix or a list of \(h\) matrix (one for each forecast horizon);
</p>
</li>
<li> <p><code>Omega</code> must be a p.d. (\(n(k^\ast + m) \times n(k^\ast + m)\))
matrix or a list of <code>h</code> matrix (one for each forecast horizon);
</p>
</li>
<li><p> if <code>comb</code> is different from &quot;<code>w</code>&quot; or &quot;<code>omega</code>&quot;,
<code>W</code> or <code>Omega</code> is not used.
</p>
</li></ol>
</td></tr>
</table>


<h3>Details</h3>

<p>Considering contemporaneous and temporal dimensions in the
same framework requires to extend and adapt the notations
used in <a href="#topic+htsrec">htsrec</a> and <a href="#topic+thfrec">thfrec</a>.
To do that, we define the matrix containing the base forecasts
at any considered temporal frequency as
\[
\widehat{\textbf{Y}}_{n \times h(k^\ast+m))} =
\left[\begin{array}{ccccc}
\widehat{\textbf{A}}^{[m]} & \widehat{\textbf{A}}^{[k_{p-1}]} & \cdots &
\widehat{\textbf{A}}^{[k_2]} & \widehat{\textbf{A}}^{[1]} \cr
\widehat{\textbf{B}}^{[m]} & \widehat{\textbf{B}}^{[k_{p-1}]} & \cdots &
\widehat{\textbf{B}}^{[k_2]} & \widehat{\textbf{B}}^{[1]}
\end{array}
\right] \qquad k \in {\cal K},\]
where \(\cal K\) is a subset of \(p\) factors of \(m\) and,
\(\widehat{\textbf{B}}^{[k]}\) and \(\widehat{\textbf{A}}^{[k]}\)
are the matrices containing the \(k\)-order temporal aggregates of the
bts and uts, of dimension (\(n_b \times h m/k\)) and
(\(n_a \times h m/k\)), respectively.
</p>
<p>Let us consider the multivariate regression model
\[\widehat{\mathbf{Y}} = \mathbf{Y} + \mathbf{E} ,\]
where the involved matrices have each dimension
\([n \times (k^\ast+m)]\) and contain, respectively, the base
(\(\widehat{\mathbf{Y}}\)) and the target forecasts
(\(\mathbf{Y}\)), and the coherency errors (\(\mathbf{E}\)) for
the \(n\) component variables of the linearly constrained time series
of interest. For each variable, \(k^\ast + m\) base forecasts are
available, pertaining to all aggregation levels of the temporal hierarchy
for a complete cycle of high-frequency observation, \(m\). Consider
now two vectorized versions of model, by transforming the matrices either
in original form:
\[\mbox{vec}\left(\widehat{\mathbf{Y}}\right) =
\mbox{vec}\left(\mathbf{Y}\right) + \mathbf{\varepsilon} \; \mbox{ with }
\; \mathbf{\varepsilon} = \mbox{vec}\left(\mathbf{E}\right)\]
or in transposed form:
\[\mbox{vec}\left(\widehat{\mathbf{Y}}'\right) =
\mbox{vec}\left(\mathbf{Y}'\right) + \mathbf{\eta} \; \mbox{ with }
\; \mathbf{\eta} = \mbox{vec}\left(\mathbf{E}'\right).\]
Denote with \(\mathbf{P}\) the \([n(k^\ast+m) \times n(k^\ast+m)]\)
commutation matrix such that
\(\mathbf{P}\mbox{vec}(\mathbf{Y}) = \mbox{vec}(\mathbf{Y}')\),
\(\mathbf{P}\mbox{vec}(\widehat{\mathbf{Y}}) = \mbox{vec}(\widehat{\mathbf{Y}}')\)
and \(\mathbf{P}\mathbf{\varepsilon} = {\bf \eta}\).
Let \(\mathbf{W} = \mathrm{E}[\mathbf{\varepsilon\varepsilon}']\) be the
covariance matrix of vector \(\mathbf{\varepsilon}\), and
\(\mathbf{\Omega} = \mathrm{E}[\mathbf{\eta\eta}']\) the covariance matrix of
vector \(\mathbf{\eta}\). Clearly, \(\mathbf{W}\) and
\(\mathbf{\Omega}\) are different parameterizations of the same
statistical object for which the following relationships hold:
\[\mathbf{\Omega} = \mathbf{P}\mathbf{W}\mathbf{P}',
\qquad \mathbf{W} = \mathbf{P}' \mathbf{\Omega}\mathbf{P} .\]
In order to apply the general point forecast reconciliation according to the
projection approach (<code>type = "M"</code>) to a cross-temporal forecast
reconciliation problem, we may consider either two <em>vec</em>-forms , e.g.
if we follow the first:
\[
\tilde{\mathbf{y}}= \hat{\mathbf{y}} - \mathbf{\Omega}\mathbf{H}\left(
\mathbf{H}'\mathbf{\Omega}\mathbf{H}\right)^{-1}\mathbf{H}'\hat{\mathbf{y}} =
{\mathbf{M}}\hat{\mathbf{y}},\]
where \(\widehat{\mathbf{y}} = \mbox{vec}(\widehat{\mathbf{Y}}')\) is the
row vectorization of the base forecasts matrix \(\widehat{\mathbf{Y}}\)
The alternative equivalent solution (<code>type = "S"</code>) (following the
structural reconciliation approach by Hyndman et al., 2011) is
\[\widetilde{\mathbf{y}} = \widetilde{\mathbf{S}}\left(\widetilde{\mathbf{S}}'
\mathbf{\Omega}^{-1}\widetilde{\mathbf{S}}\right)^{-1}\widetilde{\mathbf{S}}'
\mathbf{\Omega}^{-1}\widehat{\mathbf{y}} = \widetilde{\mathbf{S}}\mathbf{G}\widehat{\mathbf{y}}.\]
where \(\widetilde{\mathbf{S}}\) is the cross-temporal summing matrix.
</p>
<p><strong>Bounds on the reconciled forecasts</strong>
</p>
<p>When the reconciliation uses the optimization package osqp,
the user may impose bounds on the reconciled forecasts.
The parameter <code>bounds</code> permits to consider lower (\(\mathbf{a}\)) and
upper (\(\mathbf{b}\)) bounds like \(\mathbf{a} \leq
\widetilde{\mathbf{y}} \leq \mathbf{b}\), where \(\widehat{\mathbf{y}} =
\mbox{vec}(\widehat{\mathbf{Y}}')\), such that:
\[ \begin{array}{c}
a_1 \leq \widetilde{y}_1 \leq b_1 \cr
\dots \cr
a_{n(k^\ast + m)} \leq \widetilde{y}_{n(k^\ast + m)} \leq b_{n(k^\ast + m)} \cr
\end{array} \Rightarrow
\mbox{bounds} = [\mathbf{a} \; \mathbf{b}] =
\left[\begin{array}{cc}
a_1 & b_1 \cr
\vdots & \vdots \cr
a_{n(k^\ast + m)} & b_{n(k^\ast + m)} \cr
\end{array}\right],\]
where \(a_i \in [- \infty, + \infty]\) and \(b_i \in [- \infty, + \infty]\).
If \(y_i\) is unbounded, the i-th row of <code>bounds</code> would be equal
to <code>c(-Inf, +Inf)</code>.
Notice that if the <code>bounds</code> parameter is used, <code>sol = "osqp"</code> must be used.
This is not true in the case of non-negativity constraints:
</p>

<ul>
<li> <p><code>sol = "direct"</code>: first the base forecasts
are reconciled without non-negativity constraints, then, if negative reconciled
values are present, the <code>"osqp"</code> solver is used;
</p>
</li>
<li> <p><code>sol = "osqp"</code>: the base forecasts are
reconciled using the <code>"osqp"</code> solver.
</p>
</li></ul>

<p>In this case it is not necessary to build a matrix containing
the bounds, and it is sufficient to set <code>nn = "TRUE"</code>.
</p>
<p>Non-negative reconciled forecasts may be obtained by setting <code>nn_type</code> alternatively as:
</p>

<ul>
<li> <p><code>nn_type = "sntz"</code> (&quot;set-negative-to-zero&quot;)
</p>
</li>
<li> <p><code>nn_type = "osqp"</code> (Stellato et al., 2020)
</p>
</li></ul>



<h3>Value</h3>

<p>If the parameter <code>keep</code> is equal to <code>"recf"</code>, then the function
returns only the (\(n \times h(k^\ast + m)\)) reconciled forecasts
matrix, otherwise (<code>keep="all"</code>) it returns a list that mainly depends
on what type of representation (<code>type</code>) and solution technique
(<code>sol</code>) have been used:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(n \times h(k^\ast + m)\)) reconciled forecasts matrix, \(\widetilde{\textbf{Y}}\).</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>Covariance matrix used for reconciled forecasts (\(\mbox{vec}(\widehat{\textbf{Y}}')\) representation).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Covariance matrix used for reconciled forecasts (\(\mbox{vec}(\widehat{\textbf{Y}})\) representation).</p>
</td></tr>
<tr><td><code>nn_check</code></td>
<td>
<p>Number of negative values (if zero, there are no values below zero).</p>
</td></tr>
<tr><td><code>rec_check</code></td>
<td>
<p>Logical value: <code>rec_check = TRUE</code> when the constraints have been fulfilled.</p>
</td></tr>
<tr><td><code>varf (type="direct")</code></td>
<td>
<p>(\(n \times (k^\ast + m)\)) reconciled forecasts variance matrix for \(h=1\), \(\mbox{diag}(\mathbf{MW}\)).</p>
</td></tr>
<tr><td><code>M (type="direct")</code></td>
<td>
<p>Projection matrix (projection approach).</p>
</td></tr>
<tr><td><code>G (type="S" and type="direct")</code></td>
<td>
<p>Projection matrix (structural approach, \(\mathbf{M}=\mathbf{S}\mathbf{G}\)).</p>
</td></tr>
<tr><td><code>S (type="S" and type="direct")</code></td>
<td>
<p>Cross-temporal summing matrix (\(\widetilde{\textbf{F}}\mbox{vec}(\widehat{\textbf{Y}}')\) representation).</p>
</td></tr>
<tr><td><code>info (type="osqp")</code></td>
<td>
<p>matrix with some useful indicators (columns)
for each forecast horizon \(h\) (rows): run time (<code>run_time</code>), number of iteration,
norm of primal residual (<code>pri_res</code>), status of osqp's solution (<code>status</code>) and
polish's status (<code>status_polish</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Byron, R.P. (1978), The estimation of large social accounts matrices,
<em>Journal of the Royal Statistical Society A</em>, 141, 3, 359-367.
</p>
<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Girolimetto, D., Athanasopoulos, G., Di Fonzo, T., &amp; Hyndman, R. J. (2023),
Cross-temporal Probabilistic Forecast Reconciliation,
<a href="https://doi.org/10.48550/arXiv.2303.17277">doi:10.48550/arXiv.2303.17277</a>.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), <em>Package &lsquo;corpcor&rsquo;</em>, R
package version 1.6.9 (April 1, 2017), <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the &lsquo;OSQP&rsquo; Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
obj &lt;- octrec(FoReco_data$base, m = 12, C = FoReco_data$C,
              comb = "bdshr", res = FoReco_data$res)

</code></pre>

<hr>
<h2 id='residuals_matrix'>Arrange temporal and cross-temporal residuals in a matrix form</h2><span id='topic+residuals_matrix'></span>

<h3>Description</h3>

<p>Arrange temporal and cross-temporal residuals in a matrix form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_matrix(res, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_matrix_+3A_res">res</code></td>
<td>
<p>(\(n \times N(k^\ast + m)\)) matrix or (\(N(k^\ast + m)\))
vector containing the residuals at all the temporal frequencies
ordered [lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="residuals_matrix_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (\(N \times n(k^\ast + m)\)) matrix
(if the input res is a vector then \(n = 1\))
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
mat &lt;- residuals_matrix(FoReco_data$res, m = 12)

</code></pre>

<hr>
<h2 id='score_index'>Measuring accuracy in a rolling forecast experiment</h2><span id='topic+score_index'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function to calculate the accuracy indices of the reconciled point
forecasts of a cross-temporal (not only, see examples) system (more in
<a href="https://danigiro.github.io/FoReco/articles/accuracy_indices.html">Average relative accuracy indices</a>).
(<em>Experimental version</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_index(recf, base, test, m, nb, nl, type = "mse", compact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_index_+3A_recf">recf</code></td>
<td>
<p>list of q (forecast origins) reconciled forecasts' matrices
(\([n \times h(k^\ast + m)]\) in the cross-temporal case,
\([h \times n]\) in the cross-sectional case, and vectors of length
\([h(k^\ast \times m)]\) in the temporal framework).</p>
</td></tr>
<tr><td><code id="score_index_+3A_base">base</code></td>
<td>
<p>list of q (forecast origins) base forecasts' matrices
(\([n \times h(k^\ast + m)]\) in the cross-temporal case,
\([h \times n]\) in the cross-sectional case, and vectors of length
\([h(k^\ast \times m)]\) in the temporal framework).</p>
</td></tr>
<tr><td><code id="score_index_+3A_test">test</code></td>
<td>
<p>list of q (forecast origins) test observations' matrices
(\([n \times h(k^\ast + m)]\) in the cross-temporal case,
\([h \times n]\) in the cross-sectional case, and vectors of length
\([h(k^\ast \times m)]\) in the temporal framework).</p>
</td></tr>
<tr><td><code id="score_index_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="score_index_+3A_nb">nb</code></td>
<td>
<p>number of bottom time series in the cross-sectional framework.</p>
</td></tr>
<tr><td><code id="score_index_+3A_nl">nl</code></td>
<td>
<p>(\(L \times 1\)) vector containing the number of time series
in each cross-sectional level of the hierarchy (<code>nl[1] = 1</code>).</p>
</td></tr>
<tr><td><code id="score_index_+3A_type">type</code></td>
<td>
<p>type of accuracy measure (&quot;<code>mse</code>&quot; Mean Square Error,
&quot;<code>rmse</code>&quot; Root Mean Square Error or &quot;<code>mae</code>&quot; Mean Absolute Error).</p>
</td></tr>
<tr><td><code id="score_index_+3A_compact">compact</code></td>
<td>
<p>if TRUE returns only the summary matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a summary table called <code>Avg_mat</code> (if <code>compact</code> option is <code>TRUE</code>,
<em>default</em>), otherwise it returns a list of six tables (more in
<a href="https://danigiro.github.io/FoReco/articles/accuracy_indices.html">Average relative accuracy indices</a>).
</p>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FoReco_data)

# Cross-temporal framework
oct_recf &lt;- octrec(FoReco_data$base, m = 12, C = FoReco_data$C,
                   comb = "bdshr", res = FoReco_data$res)$recf
oct_score &lt;- score_index(recf = oct_recf,
                         base = FoReco_data$base,
                         test = FoReco_data$test, m = 12, nb = 5)

# Cross-sectional framework
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
# monthly test set
mtest &lt;- FoReco2matrix(FoReco_data$test, m = 12)$k1
# monthly residuals
mres &lt;- FoReco2matrix(FoReco_data$res, m = 12)$k1
# monthly reconciled forecasts
mrecf &lt;- htsrec(mbase, C = FoReco_data$C, comb = "shr", res = mres)$recf
# score
hts_score &lt;- score_index(recf = mrecf, base = mbase, test = mtest, nb = 5)

# Temporal framework
# top ts base forecasts ([lowest_freq' ...  highest_freq']')
topbase &lt;- FoReco_data$base[1, ]
# top ts residuals ([lowest_freq' ...  highest_freq']')
topres &lt;- FoReco_data$res[1, ]
# top ts test ([lowest_freq' ...  highest_freq']')
toptest &lt;- FoReco_data$test[1, ]
# top ts recf ([lowest_freq' ...  highest_freq']')
toprecf &lt;- thfrec(topbase, m = 12, comb = "acov", res = topres)$recf
# score
thf_score &lt;- score_index(recf = toprecf, base = topbase, test = toptest, m = 12)


</code></pre>

<hr>
<h2 id='shrink_estim'>Shrinkage of the covariance matrix</h2><span id='topic+shrink_estim'></span>

<h3>Description</h3>

<p>Shrinkage of the covariance matrix according to Schäfer and Strimmer (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_estim(x, minT = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_estim_+3A_x">x</code></td>
<td>
<p>residual matrix</p>
</td></tr>
<tr><td><code id="shrink_estim_+3A_mint">minT</code></td>
<td>
<p>this param allows to calculate the covariance matrix according
to the original hts formulation (<code>TRUE</code>) or according to the standard
approach (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two objects: the first (<code>$scov</code>) is the shrunk covariance matrix
and the second (<code>$lambda</code>) is the shrinkage intensity coefficient.
</p>


<h3>Author(s)</h3>

<p>This function is a modified version of the <code>shrink_estim</code>() hidden function of <span class="pkg">hts</span>.
</p>


<h3>References</h3>

<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance Matrix
Estimation and Implications for Functional Genomics, <em>Statistical Applications in Genetics
and Molecular Biology</em>, 4, 1
</p>
<p>Hyndman, R. J., Lee, A., Wang, E., and Wickramasuriya, S. (2020).
hts: Hierarchical and Grouped Time Series, <em>R package version 6.0.1</em>,
<a href="https://CRAN.R-project.org/package=hts">https://CRAN.R-project.org/package=hts</a>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+thf_tools">thf_tools</a>()</code>
</p>

<hr>
<h2 id='tcsrec'>Heuristic first-temporal-then-cross-sectional cross-temporal forecast reconciliation</h2><span id='topic+tcsrec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The cross-temporal forecast reconciliation procedure by
Kourentzes and Athanasopoulos (2019) can be viewed as an ensemble
forecasting procedure which exploits the simple averaging of different
forecasts. First, for each time series the forecasts at any temporal
aggregation order are reconciled using temporal hierarchies
(<code><a href="#topic+thfrec">thfrec</a>()</code>), then time-by-time cross-sectional
reconciliation is performed (<code><a href="#topic+htsrec">htsrec</a>()</code>). The
projection matrices obtained at this step are then averaged and used to
cross-sectionally reconcile the forecasts obtained at step 1, by this way
fulfilling both cross-sectional and temporal constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcsrec(basef, thf_comb, hts_comb, res, avg = "KA", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcsrec_+3A_basef">basef</code></td>
<td>
<p>(\(n \times h(k^\ast+m)\)) matrix of base forecasts to be
reconciled, \(\widehat{\mathbf{Y}}\); \(n\) is the total number of variables,
\(m\) is the highest time frequency, \(k^\ast\) is the sum of (a
subset of) (\(p-1\)) factors of \(m\), excluding \(m\), and
\(h\) is the forecast horizon for the lowest frequency time series.
Each row identifies a time series, and the forecasts are ordered as
[lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_hts_comb">hts_comb</code>, <code id="tcsrec_+3A_thf_comb">thf_comb</code></td>
<td>
<p>Type of covariance matrix (respectively
(\(n \times n\)) and (\((k^\ast + m) \times (k^\ast + m)\))) to
be used in the cross-sectional and temporal reconciliation. More details in
<code>comb</code> param of <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>.</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_res">res</code></td>
<td>
<p>(\(n \times N(k^\ast + m)\)) matrix containing the residuals
at all the temporal frequencies ordered [lowest_freq' ...  highest_freq']'
(columns) for each variable (row), needed to estimate the covariance matrix
when <code>hts_comb =</code> <code>{"wls",</code> <code>"shr",</code> <code>"sam"}</code> and/or
<code>hts_comb =</code> <code>{"wlsv",</code> <code>"wlsh",</code> <code>"acov",</code>
<code>"strar1",</code> <code>"sar1",</code> <code>"har1",</code> <code>"shr",</code> <code>"sam"}</code>.
The row must be in the same order as <code>basef</code>.</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_avg">avg</code></td>
<td>
<p>If <code>avg = "KA"</code> (<em>default</em>), the final projection
matrix \(\mathbf{M}\) is the one proposed by Kourentzes and
Athanasopoulos (2019), otherwise it is calculated as simple average of
all the involved projection matrices at step 2 of the procedure (see
Di Fonzo and Girolimetto, 2020).</p>
</td></tr>
<tr><td><code id="tcsrec_+3A_...">...</code></td>
<td>
<p>Any other options useful for <code><a href="#topic+htsrec">htsrec</a>()</code> and
<code><a href="#topic+thfrec">thfrec</a>()</code>, e.g. <code>m</code>, <code>C</code> (or <code>Ut</code> and
<code>nb</code>), <code>nn</code> (for non negativity reconciliation only at first step),
<code>mse</code>, <code>corpcor</code>, <code>type</code>, <code>sol</code>, <code>settings</code>,
<code>W</code>, <code>Omega</code>,...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a two-step cross-temporal forecast reconciliation using
the covariance matrices chosen by the user. If the combinations used by Kourentzes and Athanasopoulos (2019) are
wished, <code>thf_comb</code> must be set equal to either <code>"struc"</code> or <code>"wlsv"</code>,
and <code>hts_comb</code> equal to either <code>"shr"</code> or <code>"wls"</code>.
</p>
<p><strong>Warning</strong>,
the two-step heuristic reconciliation allows considering non negativity constraints only in
the first step. This means that non-negativity is not guaranteed in the final reconciled values.
</p>


<h3>Value</h3>

<p>The function returns a list with two elements:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(n \times h(k^\ast + m)\)) reconciled forecasts matrix, \(\widetilde{\mathbf{Y}}\).</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Matrix which transforms the uni-dimensional reconciled forecasts of step 1 (projection approach) .</p>
</td></tr>
</table>


<h3>References</h3>

<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Kourentzes, N., Athanasopoulos, G. (2019), Cross-temporal coherent forecasts
for Australian tourism, <em>Annals of Tourism Research</em>, 75, 393-409.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), <em>Package &lsquo;corpcor&rsquo;</em>, R
package version 1.6.9 (April 1, 2017), <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the &lsquo;OSQP&rsquo; Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
obj &lt;- tcsrec(FoReco_data$base, m = 12, C = FoReco_data$C,
              thf_comb = "acov", hts_comb = "shr", res = FoReco_data$res)

</code></pre>

<hr>
<h2 id='tdrec'>Top-down forecast reconciliation for genuine hierarchical/grouped time series</h2><span id='topic+tdrec'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Top-down forecast reconciliation for genuine hierarchical/grouped time series,
where the forecast of a &lsquo;Total&rsquo; (top-level series, expected to be positive)
is disaggregated according to a proportional scheme given by a vector
of proportions (weights).
Besides the fulfillment of any aggregation constraint,
the top-down reconciled forecasts should respect two main properties:
</p>

<ul>
<li><p> the top-level value remains unchanged;
</p>
</li>
<li><p> all the bottom time series reconciled forecasts are non-negative.
</p>
</li></ul>

<p>The top-down procedure is extended to deal with both temporal and cross-temporal cases.
Since this is a post-forecasting function, the vector of weights must be given
in input by the user, and is not calculated automatically (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdrec(topf, C, m, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdrec_+3A_topf">topf</code></td>
<td>
<p>(\(h \times 1\)) vector of the top-level base forecast to be
disaggregated; \(h\) is the forecast horizon (for the lowest temporal
aggregation order in temporal and cross-temporal cases).</p>
</td></tr>
<tr><td><code id="tdrec_+3A_c">C</code></td>
<td>
<p>(\(n_a \times n_b\)) cross-sectional (contemporaneous) matrix
mapping the \(n_b\) bottom level series into the \(n_a\) higher level ones.</p>
</td></tr>
<tr><td><code id="tdrec_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of the \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="tdrec_+3A_weights">weights</code></td>
<td>
<p>vector of weights to be used to disaggregate topf:
(\(n_b \times h\)) matrix in the cross-sectional framework;
(\(m \times h\)) matrix in the temporal framework;
(\(n_b m \times h\)) matrix in the cross-temporal framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fix \(h = 1\), then
\[\widetilde{\mathbf{y}} = \mathbf{S}\mathbf{w}\widehat{a}_1\]
where \(\widetilde{\mathbf{y}}\) is the vector of reconciled forecasts,
\(\mathbf{S}\) is the summing matrix (whose pattern depends on which type
of reconciliation is being performed), \(\mathbf{w}\) is the vector of weights,
and \(\widehat{a}_1\) is the top-level value to be disaggregated.
</p>


<h3>Value</h3>

<p>The function returns an (\(h \times n\)) matrix of
cross-sectionally reconciled forecasts, or an (\(h(k^\ast + m) \times 1\))
vector of top-down temporally reconciled forecasts, or an
(\(n \times h (k^\ast + m)\)) matrix of top-down
cross-temporally reconciled forecasts.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Ahmed, R.A., Hyndman, R.J. (2009), Hierarchical
forecasts for Australian domestic tourism, <em>International Journal of
Forecasting</em>, 25, 1, 146–166.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+thfrec">thfrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
### CROSS-SECTIONAL TOP-DOWN RECONCILIATION
# Cross sectional aggregation matrix
C &lt;- FoReco_data$C
# monthly base forecasts
mbase &lt;- FoReco2matrix(FoReco_data$base, m = 12)$k1
obs_1 &lt;- FoReco_data$obs$k1
# average historical proportions
props &lt;- colMeans(obs_1[1:168,-c(1:3)]/obs_1[1:168,1])
cs_td &lt;- tdrec(topf = mbase[,1], C = C, weights = props)

### TEMPORAL TOP-DOWN RECONCILIATION
# top ts base forecasts ([lowest_freq' ...  highest_freq']')
top_obs12 &lt;- FoReco_data$obs$k12[1:14,1]
bts_obs1 &lt;- FoReco_data$obs$k1[1:168,1]
# average historical proportions
props &lt;- colMeans(matrix(bts_obs1, ncol = 12, byrow = TRUE)/top_obs12)
topbase &lt;- FoReco_data$base[1, 1]
t_td &lt;- tdrec(topf = topbase, m = 12, weights = props)

### CROSS-TEMPORAL TOP-DOWN RECONCILIATION
top_obs &lt;- FoReco_data$obs$k12[1:14,1]
bts_obs &lt;- FoReco_data$obs$k1[1:168,-c(1:3)]
bts_obs &lt;- lapply(1:5, function(x) matrix(bts_obs[,x], nrow=14, byrow = TRUE))
bts_obs &lt;- do.call(cbind, bts_obs)
# average historical proportions
props &lt;- colMeans(bts_obs/top_obs)
ct_td &lt;- tdrec(topf = topbase, m = 12, C = C, weights = props)

</code></pre>

<hr>
<h2 id='thf_tools'>Temporal reconciliation tools</h2><span id='topic+thf_tools'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Some useful tools for forecast reconciliation through temporal hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thf_tools(m, h = 1, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thf_tools_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order of temporal aggregation, \(m\)),
or a subset of the \(p\) factors of \(m\).</p>
</td></tr>
<tr><td><code id="thf_tools_+3A_h">h</code></td>
<td>
<p>Forecast horizon for the lowest frequency (most temporally aggregated) time series (<em>default</em> is \(1\)).</p>
</td></tr>
<tr><td><code id="thf_tools_+3A_sparse">sparse</code></td>
<td>
<p>Option to return sparse object (<em>default</em> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of seven elements:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>Temporal aggregation matrix.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Temporal summing matrix.</p>
</td></tr>
<tr><td><code>Zt</code></td>
<td>
<p>Zero constraints temporal kernel matrix, \(\mathbf{Z}_h'\mathbf{Y}' =
\mathbf{0}_{\left[hk^* \times n \right]}\).</p>
</td></tr>
<tr><td><code>kset</code></td>
<td>
<p>Set of factors (\(p\)) of \(m\) in descending order (from \(m\)
to 1), \({\cal K} = \left\lbrace k_p, k_{p-1}, \ldots, k_2, k_1\right\rbrace\), \(k_p=m\), \(k_1=1\).</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order of temporal aggregation).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of elements of kset, \({\cal K}\).</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>Sum of \(p-1\) factors of \(m\) (out of \(m\) itself), \(k^*\).</p>
</td></tr>
<tr><td><code>kt</code></td>
<td>
<p>Sum of all factors of m, \(k^{tot} = k^*+m\).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Cmatrix">Cmatrix</a>()</code>,
<code><a href="#topic+FoReco2ts">FoReco2ts</a>()</code>,
<code><a href="#topic+agg_ts">agg_ts</a>()</code>,
<code><a href="#topic+arrange_hres">arrange_hres</a>()</code>,
<code><a href="#topic+commat">commat</a>()</code>,
<code><a href="#topic+ctf_tools">ctf_tools</a>()</code>,
<code><a href="#topic+hts_tools">hts_tools</a>()</code>,
<code><a href="#topic+lcmat">lcmat</a>()</code>,
<code><a href="#topic+oct_bounds">oct_bounds</a>()</code>,
<code><a href="#topic+residuals_matrix">residuals_matrix</a>()</code>,
<code><a href="#topic+score_index">score_index</a>()</code>,
<code><a href="#topic+shrink_estim">shrink_estim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># quarterly data
obj &lt;- thf_tools(m = 4, sparse = FALSE)

</code></pre>

<hr>
<h2 id='thfrec'>Forecast reconciliation through temporal hierarchies (temporal reconciliation)</h2><span id='topic+thfrec'></span>

<h3>Description</h3>

<p>Forecast reconciliation of one time series through temporal hierarchies
(Athanasopoulos et al., 2017). The reconciled forecasts are calculated
either through a projection approach (Byron, 1978), or the equivalent
structural approach by Hyndman et al. (2011). Moreover, the classic
bottom-up approach is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thfrec(basef, m, comb, res, mse = TRUE, corpcor = FALSE,
       type = "M", sol = "direct", keep = "list", v = NULL, nn = FALSE,
        nn_type = "osqp", settings = list(), bounds = NULL, Omega = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thfrec_+3A_basef">basef</code></td>
<td>
<p>(\(h(k^\ast + m) \times 1\)) vector of base forecasts to be
reconciled, containing the forecasts at all the needed temporal frequencies
ordered as [lowest_freq' ...  highest_freq']'.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_m">m</code></td>
<td>
<p>Highest available sampling frequency per seasonal cycle (max. order
of temporal aggregation, \(m\)), or a subset of \(p\) factors
of \(m\).</p>
</td></tr>
<tr><td><code id="thfrec_+3A_comb">comb</code></td>
<td>
<p>Type of the reconciliation. Except for bottom up, all other
options correspond to a different (\((k^\ast + m) \times (k^\ast + m)\))
covariance matrix, \(k^\ast\) is the sum of (\(p-1\)) factors of
\(m\) (excluding \(m\)):
</p>

<ul>
<li> <p><b>bu</b> (Bottom-up);
</p>
</li>
<li> <p><b>ols</b> (Identity);
</p>
</li>
<li> <p><b>struc</b> (Structural variances);
</p>
</li>
<li> <p><b>wlsv</b> (Series variances);
</p>
</li>
<li> <p><b>wlsh</b> (Hierarchy variances);
</p>
</li>
<li> <p><b>acov</b> (Auto-covariance matrix);
</p>
</li>
<li> <p><b>strar1</b> (Structural Markov);
</p>
</li>
<li> <p><b>sar1</b> (Series Markov);
</p>
</li>
<li> <p><b>har1</b> (Hierarchy Markov);
</p>
</li>
<li> <p><b>shr</b> (Shrunk cross-covariance matrix);
</p>
</li>
<li> <p><b>sam</b> (Sample cross-covariance matrix);
</p>
</li>
<li> <p><b>omega</b> use your personal matrix Omega in param <code>Omega</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="thfrec_+3A_res">res</code></td>
<td>
<p>vector containing the in-sample residuals at all the temporal
frequencies ordered as <code>basef</code>, i.e. [lowest_freq' ...  highest_freq']',
needed to estimate the covariance matrix when <code>comb =</code> <code>{"wlsv",</code>
<code>"wlsh",</code> <code>"acov",</code> <code>"strar1",</code> <code>"sar1",</code> <code>"har1",</code>
<code>"shr",</code> <code>"sam"}</code>.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_mse">mse</code></td>
<td>
<p>Logical value: <code>TRUE</code> (<em>default</em>) calculates the
covariance matrix of the in-sample residuals (when necessary) according to
the original <span class="pkg">hts</span> and <span class="pkg">thief</span> formulation: no mean correction,
T as denominator.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_corpcor">corpcor</code></td>
<td>
<p>Logical value: <code>TRUE</code> if <span class="pkg">corpcor</span> (Schäfer et
al., 2017) must be used to shrink the sample covariance matrix according to
Schäfer and Strimmer (2005), otherwise the function uses the
same implementation as package <span class="pkg">hts</span>.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_type">type</code></td>
<td>
<p>Approach used to compute the reconciled forecasts: <code>"M"</code> for
the projection approach with matrix M (<em>default</em>), or <code>"S"</code> for the
structural approach with temporal summing matrix R.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_sol">sol</code></td>
<td>
<p>Solution technique for the reconciliation problem: either
<code>"direct"</code> (<em>default</em>) for the closed-form matrix solution, or
<code>"osqp"</code> for the numerical solution (solving a linearly constrained
quadratic program using <code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code>).</p>
</td></tr>
<tr><td><code id="thfrec_+3A_keep">keep</code></td>
<td>
<p>Return a list object of the reconciled forecasts at all levels
(if keep = &quot;list&quot;) or only the reconciled forecasts matrix (if keep = &quot;recf&quot;).</p>
</td></tr>
<tr><td><code id="thfrec_+3A_v">v</code></td>
<td>
<p>vector index of the fixed base forecast (\(\mbox{min}(v) > 0\)
and \(\mbox{max}(v) < (k^\ast + m)\)).</p>
</td></tr>
<tr><td><code id="thfrec_+3A_nn">nn</code></td>
<td>
<p>Logical value: <code>TRUE</code> if non-negative reconciled forecasts
are wished.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_nn_type">nn_type</code></td>
<td>
<p>&quot;osqp&quot; (default), &quot;KAnn&quot; (only <code>type == "M"</code>) or &quot;sntz&quot;.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_settings">settings</code></td>
<td>
<p>Settings for <span class="pkg">osqp</span> (object <code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>).
The default options are: <code>verbose = FALSE</code>, <code>eps_abs = 1e-5</code>,
<code>eps_rel = 1e-5</code>, <code>polish_refine_iter = 100</code> and <code>polish = TRUE</code>.
For details, see the <a href="https://osqp.org/"><span class="pkg">osqp</span> documentation</a>
(Stellato et al., 2019).</p>
</td></tr>
<tr><td><code id="thfrec_+3A_bounds">bounds</code></td>
<td>
<p>(\((k^\ast + m) \times 2\)) matrix with temporal bounds: the
first column is the lower bound, and the second column is the upper bound.</p>
</td></tr>
<tr><td><code id="thfrec_+3A_omega">Omega</code></td>
<td>
<p>This option permits to directly enter the covariance matrix:
</p>

<ol>
<li> <p><code>Omega</code> must be a p.d. (\((k^\ast + m) \times (k^\ast + m)\))
matrix or a list of \(h\) matrix (one for each forecast horizon);
</p>
</li>
<li><p> if <code>comb</code> is different from &quot;<code>omega</code>&quot;, <code>Omega</code> is
not used.
</p>
</li></ol>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Let \(m\) be the highest available
sampling frequency per seasonal cycle, and denote
\({\cal K} = \left\lbrace k_m, k_{p-1}, \ldots, k_{2}, k_1\right\rbrace\)
the \(p\) factors of \(m\), in descending order, where
\(k_p=m\), and \(k_1=1\). Define \(\mathbf{K}\)
the \(\left( k^\ast \times m\right)\) temporal aggregation matrix
converting the high-frequency observations into lower-frequency
(temporally aggregated) ones:
\[ \mathbf{K} = \left[\begin{array}{c}
\mathbf{1}_m' \cr
\mathbf{I}_{\frac{m}{k_{p-1}}} \otimes \mathbf{1}_{k_{p-1}}' \cr
\vdots \cr
\mathbf{I}_{\frac{m}{k_{2}}} \otimes \mathbf{1}_{k_{2}}' \cr
\end{array}\right].\]
Denote
\(\mathbf{R} = \left[\begin{array}{c}
\mathbf{K} \cr \mathbf{I}_m
\end{array}\right]\) the \(\left[(k^\ast+m) \times m \right]\)
<em>temporal summing</em> matrix, and
\(\mathbf{Z}' = \left[ \mathbf{I}_{k^\ast} \; -\mathbf{K} \right]\)
the zero constraints kernel matrix.
</p>
<p>Suppose we have the \(\left[(k^\ast+m) \times 1\right]\) vector
\(\widehat{\mathbf{y}}\) of unbiased base forecasts for the
\(p\) temporal aggregates of a single time series \(Y\)
within a complete time cycle, i.e. at the forecast horizon \(h=1\)
for the lowest (most aggregated) time frequency. If the base forecasts
have been independently obtained, generally they do not fulfill the
temporal aggregation constraints, i.e. \(\mathbf{Z}'
\widehat{\mathbf{y}} \ne \mathbf{0}_{(k^\ast \times 1)}\).
By adapting the general point forecast reconciliation according to
the projection approach (<code>type = "M"</code>),
the vector of temporally reconciled forecasts
is given by:
\[\widetilde{\mathbf{y}} = \widehat{\mathbf{y}} -
\mathbf{\Omega}\mathbf{Z}\left(\mathbf{Z}'\mathbf{\Omega}
\mathbf{Z}\right)^{-1}\mathbf{Z}'\widehat{\mathbf{y}},\]
where \(\mathbf{\Omega}\) is a \(\left[(k^\ast+m)
\times (k^\ast+m)\right]\) p.d. matrix, assumed known. The alternative
equivalent solution (<code>type = "S"</code>) following the
structural reconciliation approach by Athanasopoulos et al. (2017) is given by:
\[\widetilde{\mathbf{y}} = \mathbf{R}\left(\mathbf{R}'
\mathbf{\Omega}^{-1}\mathbf{R}\right)^{-1}\mathbf{R}'
\mathbf{\Omega}^{-1}\widehat{\mathbf{y}}.\]
</p>
<p><strong>Bounds on the reconciled forecasts</strong>
</p>
<p>When the reconciliation makes use of the optimization package osqp,
the user may impose bounds on the reconciled forecasts.
The parameter <code>bounds</code> permits to consider lower (\(\mathbf{a}\)) and
upper (\(\mathbf{b}\)) bounds like \(\mathbf{a} \leq
\widetilde{\mathbf{y}} \leq \mathbf{b}\) such that:
\[ \begin{array}{c}
a_1 \leq \widetilde{y}_1 \leq b_1 \cr
\dots \cr
a_{(k^\ast + m)} \leq \widetilde{y}_{(k^\ast + m)} \leq b_{(k^\ast + m)} \cr
\end{array} \Rightarrow
\mbox{bounds} = [\mathbf{a} \; \mathbf{b}] =
\left[\begin{array}{cc}
a_1 & b_1 \cr
\vdots & \vdots \cr
a_{(k^\ast + m)} & b_{(k^\ast + m)} \cr
\end{array}\right],\]
where \(a_i \in [- \infty, + \infty]\) and \(b_i \in [- \infty, + \infty]\).
If \(y_i\) is unbounded, the \(i\)-th row of <code>bounds</code> would be equal
to <code>c(-Inf, +Inf)</code>.
Notice that if the <code>bounds</code> parameter is used, <code>sol = "osqp"</code> must be used.
This is not true in the case of non-negativity constraints:
</p>

<ul>
<li> <p><code>sol = "direct"</code>: first the base forecasts
are reconciled without non-negativity constraints, then, if negative reconciled
values are present, the <code>"osqp"</code> solver is used;
</p>
</li>
<li> <p><code>sol = "osqp"</code>: the base forecasts are
reconciled using the <code>"osqp"</code> solver.
</p>
</li></ul>

<p>In this case it is not necessary to build a matrix containing
the bounds, and it is sufficient to set <code>nn = "TRUE"</code>.
</p>
<p>Non-negative reconciled forecasts may be obtained by setting <code>nn_type</code> alternatively as:
</p>

<ul>
<li> <p><code>nn_type = "sntz"</code> (&quot;set-negative-to-zero&quot;)
</p>
</li>
<li> <p><code>nn_type = "osqp"</code> (Stellato et al., 2020)
</p>
</li></ul>



<h3>Value</h3>

<p>If the parameter <code>keep</code> is equal to <code>"recf"</code>, then the function
returns only the (\(h(k^\ast + m) \times 1\)) reconciled forecasts vector, otherwise (<code>keep="all"</code>)
it returns a list that mainly depends on what type of representation (<code>type</code>)
and solution technique (<code>sol</code>) have been used:
</p>
<table>
<tr><td><code>recf</code></td>
<td>
<p>(\(h(k^\ast + m) \times 1\)) reconciled forecasts vector, \(\widetilde{\mathbf{y}}\).</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>Covariance matrix used for forecast reconciliation, \(\mathbf{\Omega}\).</p>
</td></tr>
<tr><td><code>nn_check</code></td>
<td>
<p>Number of negative values (if zero, there are no values below zero).</p>
</td></tr>
<tr><td><code>rec_check</code></td>
<td>
<p>Logical value: <code>rec_check = TRUE</code> when the constraints have been fulfilled.</p>
</td></tr>
<tr><td><code>varf (type="direct")</code></td>
<td>
<p>(\((k^\ast + m) \times 1\)) reconciled forecasts variance vector for \(h=1\), \(\mbox{diag}(\mathbf{MW}\)).</p>
</td></tr>
<tr><td><code>M (type="direct")</code></td>
<td>
<p>Projection matrix, \(\mathbf{M}\) (projection approach).</p>
</td></tr>
<tr><td><code>G (type="S" and type="direct")</code></td>
<td>
<p>Projection matrix, \(\mathbf{G}\) (structural approach, \(\mathbf{M}=\mathbf{R}\mathbf{G}\)).</p>
</td></tr>
<tr><td><code>S (type="S" and type="direct")</code></td>
<td>
<p>Temporal summing matrix, \(\mathbf{R}\).</p>
</td></tr>
<tr><td><code>info (type="osqp")</code></td>
<td>
<p>matrix with information in columns
for each forecast horizon \(h\) (rows): run time (<code>run_time</code>),
number of iteration (<code>iter</code>), norm of primal residual (<code>pri_res</code>),
status of osqp's solution (<code>status</code>) and polish's status
(<code>status_polish</code>). It will also be returned with <code>nn = TRUE</code> if
a solver (see <code>nn_type</code>) will be use.</p>
</td></tr>
</table>
<p>Only if <code>comb = "bu"</code>, the function returns <code>recf</code>, <code>R</code> and <code>M</code>.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Hyndman, R.J., Kourentzes, N., Petropoulos, F. (2017),
Forecasting with Temporal Hierarchies, <em>European Journal of Operational
Research</em>, 262, 1, 60-74.
</p>
<p>Byron, R.P. (1978), The estimation of large social accounts matrices,
<em>Journal of the Royal Statistical Society A</em>, 141, 3, 359-367.
</p>
<p>Di Fonzo, T., and Girolimetto, D. (2023), Cross-temporal forecast reconciliation:
Optimal combination method and heuristic alternatives, <em>International Journal
of Forecasting</em>, 39(1), 39-57.
</p>
<p>Hyndman, R.J., Ahmed, R.A., Athanasopoulos, G., Shang, H.L. (2011), Optimal combination
forecasts for hierarchical time series, <em>Computational Statistics &amp; Data
Analysis</em>, 55, 9, 2579-2589.
</p>
<p>Nystrup, P.,  Lindström, E., Pinson, P., Madsen, H. (2020),
Temporal hierarchies with autocorrelation for load forecasting,
<em>European Journal of Operational Research</em>, 280, 1, 876-888.
</p>
<p>Schäfer, J.L., Opgen-Rhein, R., Zuber, V., Ahdesmaki, M.,
Duarte Silva, A.P., Strimmer, K. (2017), Package &lsquo;corpcor&rsquo;, R
package version 1.6.9 (April 1, 2017), <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package= corpcor</a>.
</p>
<p>Schäfer, J.L., Strimmer, K. (2005), A Shrinkage Approach to Large-Scale Covariance
Matrix Estimation and Implications for Functional Genomics, <em>Statistical
Applications in Genetics and Molecular Biology</em>, 4, 1.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S. (2020). OSQP:
An Operator Splitting Solver for Quadratic Programs, <em>Mathematical Programming Computation</em>,
12, 4, 637-672.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Boyd, S., Anderson, E. (2019), OSQP:
Quadratic Programming Solver using the 'OSQP' Library, R package version 0.6.0.3
(October 10, 2019), <a href="https://CRAN.R-project.org/package=osqp">https://CRAN.R-project.org/package=osqp</a>.
</p>


<h3>See Also</h3>

<p>Other reconciliation procedures: 
<code><a href="#topic+cstrec">cstrec</a>()</code>,
<code><a href="#topic+ctbu">ctbu</a>()</code>,
<code><a href="#topic+htsrec">htsrec</a>()</code>,
<code><a href="#topic+iterec">iterec</a>()</code>,
<code><a href="#topic+lccrec">lccrec</a>()</code>,
<code><a href="#topic+octrec">octrec</a>()</code>,
<code><a href="#topic+tcsrec">tcsrec</a>()</code>,
<code><a href="#topic+tdrec">tdrec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FoReco_data)
# top ts base forecasts ([lowest_freq' ...  highest_freq']')
topbase &lt;- FoReco_data$base[1, ]
 # top ts residuals ([lowest_freq' ...  highest_freq']')
topres &lt;- FoReco_data$res[1, ]
obj &lt;- thfrec(topbase, m = 12, comb = "acov", res = topres)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
