<!DOCTYPE html><html lang="en"><head><title>Help for package hettx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hettx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hettx-package'><p>Fisherian and Neymanian Methods for Detecting and Measuring Treatment Effect Variation</p></a></li>
<li><a href='#coef.RI.regression.result'><p>Extract coefficients of a fit RI regression model.</p></a></li>
<li><a href='#detect_idiosyncratic'><p>detect_idiosyncratic</p></a></li>
<li><a href='#estimate_systematic'><p>Calculate systematic effects model using LATE, ITT, or full potential outcomes.</p></a></li>
<li><a href='#get.p.value'><p>get p-value along with uncertainty on p-value</p></a></li>
<li><a href='#KS.stat'><p>KS.stat</p></a></li>
<li><a href='#make.linear.data'><p>Generate dataset according to a linear model.</p></a></li>
<li><a href='#make.randomized.compliance.dat'><p>Generate fake data with noncompliance.</p></a></li>
<li><a href='#make.randomized.dat'><p>Make fake data for simulations</p></a></li>
<li><a href='#Penn46_ascii'><p>Sample data set</p></a></li>
<li><a href='#plot.FRTCI.test'><p>plot.FRTCI.test</p></a></li>
<li><a href='#plot.RI.R2.result'><p>Make a plot of the treatment effect R2 estimates</p></a></li>
<li><a href='#R2'><p>Estimate treatment variation R2</p></a></li>
<li><a href='#rq.stat'><p>rq.stat</p></a></li>
<li><a href='#SE'><p>Extract the standard errors from a var-cov matrix.</p></a></li>
<li><a href='#SKS.pool.t'><p>SKS.pool.t</p></a></li>
<li><a href='#SKS.stat'><p>SKS.stat</p></a></li>
<li><a href='#SKS.stat.cov.pool'><p>SKS.stat.cov.pool</p></a></li>
<li><a href='#SKS.stat.cov.rq'><p>SKS.stat.cov.rq</p></a></li>
<li><a href='#SKS.stat.int.cov.pool'><p>SKS.stat.int.cov.pool</p></a></li>
<li><a href='#test.stat.info'><p>test.stat.info</p></a></li>
<li><a href='#ToyData'><p>Toy data set</p></a></li>
<li><a href='#variance.ratio.test'><p>Variance ratio test</p></a></li>
<li><a href='#vcov.RI.regression.result'><p>Get vcov() from object.</p></a></li>
<li><a href='#WSKS.t'><p>WSKS.t</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fisherian and Neymanian Methods for Detecting and Measuring
Treatment Effect Variation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods developed by Ding, Feller, and Miratrix (2016) &lt;<a href="https://doi.org/10.1111%2Frssb.12124">doi:10.1111/rssb.12124</a>&gt; &lt;<a href="https://doi.org/10.48550/arXiv.1412.5000">doi:10.48550/arXiv.1412.5000</a>&gt;,
    and Ding, Feller, and Miratrix (2018) &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1407322">doi:10.1080/01621459.2017.1407322</a>&gt; &lt;<a href="https://doi.org/10.48550/arXiv.1605.06566">doi:10.48550/arXiv.1605.06566</a>&gt;
    for testing whether there is unexplained variation in treatment effects across observations, and for characterizing
    the extent of the explained and unexplained variation in treatment effects. The package includes wrapper functions
    implementing the proposed methods, as well as helper functions for analyzing and visualizing the results of the test.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>quantreg, plyr, mvtnorm, MASS, foreach, parallel, doParallel,
moments, formula.tools, purrr, dplyr, ggplot2, tidyr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bfifield/hettx/issues">https://github.com/bfifield/hettx/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 12:58:35 UTC; benfifield</td>
</tr>
<tr>
<td>Author:</td>
<td>Peng Ding [aut],
  Avi Feller [aut],
  Ben Fifield [aut, cre],
  Luke Miratrix [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Fifield &lt;benfifield@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 22:22:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='hettx-package'>Fisherian and Neymanian Methods for Detecting and Measuring Treatment Effect Variation</h2><span id='topic+hettx-package'></span>

<h3>Description</h3>

<p>This package implements methods developed by Ding, Feller, and Miratrix
(JRSS-B, 2016) &quot;Randomization Inference for Treatment Effect Variation&quot;, for
validly testing whether there is unexplained variation in treatment effects
across observations. The package also implements methods introduced in Ding,
Feller, and Miratrix (JASA, 2019) &quot;Decomposing Treatment Effect Variation&quot;, for
measuring the degree of treatment effect heterogeneity explained by
covariates. The package includes wrapper functions implementing the proposed
methods, as well as helper functions for analyzing and visualizing the
results of the tests.
</p>


<h3>Details</h3>

<p>This package partially supported by the Institute of Education Sciences, U.S.
Department of Education, through Grant R305D150040. The opinions expressed
are those of the authors and do not represent views of the Institute or the
U.S. Department of Education.
</p>
<p>Special thanks to Masha Bertling for some early work on documenting this project.
</p>


<h3>Author(s)</h3>

<p>Peng Ding, Avi Feller, Ben Fifield, and Luke Miratrix
</p>
<p>Maintainer: Ben Fifield <a href="mailto:benfifield@gmail.com">benfifield@gmail.com</a>
</p>


<h3>References</h3>

<p>Ding, Peng, Avi Feller and Luke Miratrix. (2016) &quot;Randomization Inference for Treatment Effect Variation&quot;, Journal of the Royal Statistical Society-Series B.
Ding, Peng, Avi Feller and Luke Miratrix. (2019) &quot;Decomposing Treatment Effect Variation&quot;, Journal of the American Statistical Association.
</p>

<hr>
<h2 id='coef.RI.regression.result'>Extract coefficients of a fit RI regression model.</h2><span id='topic+coef.RI.regression.result'></span>

<h3>Description</h3>

<p>Extract coefficients of a fit RI regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RI.regression.result'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.RI.regression.result_+3A_object">object</code></td>
<td>
<p>A RI.regression.result object.</p>
</td></tr>
<tr><td><code id="coef.RI.regression.result_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )
coef(es)

</code></pre>

<hr>
<h2 id='detect_idiosyncratic'>detect_idiosyncratic</h2><span id='topic+detect_idiosyncratic'></span>

<h3>Description</h3>

<p>Test for systematic treatment effect heterogeneity using Fisherian
permutation inference methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_idiosyncratic(formula, data, interaction.formula,
  control.formula, plugin, tau.hat, test.stat, te.vec, B, gamma, grid.gamma,
  grid.size, return.matrix, na.rm, n.cores, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_idiosyncratic_+3A_formula">formula</code></td>
<td>
<p>An object of class formula, as in lm(), such as Y ~ Z with
only the treatment variable on the right-hand side.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_data">data</code></td>
<td>
<p>A data.frame, tbl_df, or data.table with the input data.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_interaction.formula">interaction.formula</code></td>
<td>
<p>A right-sided formula with pre-treatment
covariates to model treatment effects for on the right hand side, such as ~
x1 + x2 + x3. Defaultis NULL (no interactions modeled)</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_control.formula">control.formula</code></td>
<td>
<p>A right-sided formula with pre-treatment covariates to
adjust for on the right hand side, such as ~ x1 + x2 + x3. Default is NULL
(no variables adjusted for)</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_plugin">plugin</code></td>
<td>
<p>Whether to calculate the plug-in p-value without sweeping over
range of possible treatment effect magnitudes. Default is FALSE.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_tau.hat">tau.hat</code></td>
<td>
<p>The value of the plug-in treatment effect. Default is sample
average treatment effect.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_test.stat">test.stat</code></td>
<td>
<p>Test statistic function to use on the data. Default is
shifted Kolmogorov-Smirnov statistic, potentially with covariate adjustment
depending on passed arguments.  test.stat can be a string name for a test statistic function, or the function itself.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_te.vec">te.vec</code></td>
<td>
<p>Vector of taus to examine if you want to override generating
ones automatically. Default is NULL.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_b">B</code></td>
<td>
<p>Number of permutations to take. Default is 500.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_gamma">gamma</code></td>
<td>
<p>How wide of a CI to make around tau-hat for search. Default is
0.0001.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_grid.gamma">grid.gamma</code></td>
<td>
<p>Parameter to govern where the grid points are sampled.
Bigger values means more samples towards the estimated tau-hat. Default is
100*gamma.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_grid.size">grid.size</code></td>
<td>
<p>Number of points in the grid. Default is 151.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_return.matrix">return.matrix</code></td>
<td>
<p>Whether to return the matrix of all the imputed
statistics.  Default is FALSE.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical flag indicating whether to list-wise delete missing
data. The function will report an error if missing data exist. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to use to parallelize permutation step.
Default is 1.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out progress bar when fitting and other
diagnostics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="detect_idiosyncratic_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the generate.permutations function and
test.stat functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If plug-in, the value of the test and the associated p-value. If not,
a list with the value of the test statistic on the observed data, the value
of the CI-adjusted p-value, the plug-in p-value, and other information on
the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rep(c(0, 1), 100)
tau &lt;- 4
Y &lt;- ifelse(Z, rnorm(100, tau), rnorm(100, 0))
df &lt;- data.frame(Y=Y, Z=Z)
tst &lt;- detect_idiosyncratic(Y ~ Z, df, B = 50, grid.size = 50)
</code></pre>

<hr>
<h2 id='estimate_systematic'>Calculate systematic effects model using LATE, ITT, or full potential outcomes.</h2><span id='topic+estimate_systematic'></span>

<h3>Description</h3>

<p>Implements the systematic effects model proposed in Ding, Feller, and Miratrix
(2018). Can estimate an ITT or LATE model, or the actual beta in cases where
full potential outcomes schedule is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_systematic(formula, data, interaction.formula, control.formula,
method, na.rm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_systematic_+3A_formula">formula</code></td>
<td>
<p>An object of class formula, as in lm(). For ITT estimation, specify as Y ~ Z with only the treatment variable on the right-hand side. For LATE estimation, specify as Y ~ D | Z with only the endogenous variable (D) and the instrument (Z) on the right-hand side separated by a vertical bar (|). For oracle estimation (where full potential outcome schedule is known), specify as Y(1) + Y(0) ~ Z with only the treatment variable on the right-hand side and the variables indicating the outcome under treatment and the outcome under control on the left-hand-side. The first variable on the left-hand-side will be treated as the outcome under treatment, and the second variable on the right-hand-side will be treated as the outcome under control.</p>
</td></tr>
<tr><td><code id="estimate_systematic_+3A_data">data</code></td>
<td>
<p>A data.frame, tbl_df, or data.table with the input data.</p>
</td></tr>
<tr><td><code id="estimate_systematic_+3A_interaction.formula">interaction.formula</code></td>
<td>
<p>A right-sided formula with pre-treatment covariates to model treatment effects for on the right hand side, such as ~ x1 + x2 + x3.</p>
</td></tr>
<tr><td><code id="estimate_systematic_+3A_control.formula">control.formula</code></td>
<td>
<p>A right-sided formula with pre-treatment covariates to adjust for on the right hand side, such as ~ x1 + x2 + x3. Default is NULL (no variables adjusted for). Will be ignored for LATE estimation and oracle estimation. Default is NULL</p>
</td></tr>
<tr><td><code id="estimate_systematic_+3A_method">method</code></td>
<td>
<p>RI or OLS (for ITT and oracle), RI or 2SLS (for LATE). method=OLS is shorthand for setting the empirical.Sxx variable to TRUE, nothing more.</p>
</td></tr>
<tr><td><code id="estimate_systematic_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical flag indicating whether to list-wise delete missing data. The function will report an error if missing data exist. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OLS method differs from the RI method only by how the Sxx matrix is handled.
In the OLS case, seperate Sxx for treatment and control are calculated for each 
treatment arm. For RI the known Sxx based on all units is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )

</code></pre>

<hr>
<h2 id='get.p.value'>get p-value along with uncertainty on p-value</h2><span id='topic+get.p.value'></span>

<h3>Description</h3>

<p>Give confidence bounds (from monte carlo simulation error) for the p-values returned by a test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.p.value(tst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.p.value_+3A_tst">tst</code></td>
<td>
<p>A FRTCI.test object from detect_idiosyncratic()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value and range of p-values due to monte carlo error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rep(c(0, 1), 100)
tau &lt;- 4
Y &lt;- ifelse(Z, rnorm(100, tau), rnorm(100, 0))
df &lt;- data.frame(Y=Y, Z=Z)
tst &lt;- detect_idiosyncratic(Y ~ Z, df, B = 50, grid.size = 50)
get.p.value( tst )

</code></pre>

<hr>
<h2 id='KS.stat'>KS.stat</h2><span id='topic+KS.stat'></span>

<h3>Description</h3>

<p>Calculate classic (not shifted) KS statistic; code is a modified version of R's ks.test().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KS.stat(Y, Z, tau, alternative)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KS.stat_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="KS.stat_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="KS.stat_+3A_tau">tau</code></td>
<td>
<p>Value of treatment effect for shifting Y1. Default is NULL (Y1 not shifted).</p>
</td></tr>
<tr><td><code id="KS.stat_+3A_alternative">alternative</code></td>
<td>
<p>Direction of test (&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If tau passed, Y1 will be shifted by tau.
</p>


<h3>Value</h3>

<p>The value of the test.
</p>


<h3>See Also</h3>

<p>detect_idiosyncratic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
KS.stat(df$Yobs, df$Z)

</code></pre>

<hr>
<h2 id='make.linear.data'>Generate dataset according to a linear model.</h2><span id='topic+make.linear.data'></span><span id='topic+make.quadradic.data'></span><span id='topic+make.skew.data'></span>

<h3>Description</h3>

<p>Given the parameters, generate a dataset and return a potential outcomes schedule (science table)
of synthetic potential outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.linear.data(
  n,
  gamma.vec = c(1, 2, 2, 1),
  gamma2.vec = NULL,
  beta.vec = c(-1, -1, 1),
  ideo.sd = 0,
  quad.tx = FALSE,
  mu.X = FALSE,
  corr.X = TRUE
)

make.quadradic.data(n, beta.vec = c(-1, -1, 1))

make.skew.data(n, beta.vec = c(-1, -1, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.linear.data_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_gamma.vec">gamma.vec</code></td>
<td>
<p>Control outcome surface</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_gamma2.vec">gamma2.vec</code></td>
<td>
<p>Quadratic terms</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_beta.vec">beta.vec</code></td>
<td>
<p>Treatment effect surface</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_ideo.sd">ideo.sd</code></td>
<td>
<p>Ideosyncratic residual variation</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_quad.tx">quad.tx</code></td>
<td>
<p>Quadratic treatment effects?</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_mu.x">mu.X</code></td>
<td>
<p>Center of the X covariates (can be single number or vector of length equal to the max of the length of gamma.vec, gamma2.vec, and beta.vec)</p>
</td></tr>
<tr><td><code id="make.linear.data_+3A_corr.x">corr.X</code></td>
<td>
<p>TRUE or FALSE.  Have Xs correlated or no.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The control outcome surface is either linear or quadratic, of the form:
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \\gamma_0 + \\sum_{k=1}^J \\gamma_k X_{ki} + \\sum_{k=1}^{J_2} \\gamma^{(2)}_k X_{ki}^2 + \\epsilon_i</code>
</p>

<p>The individual treatment effects are similarly a linear or quadratic model.
</p>


<h3>Value</h3>

<p>List of elements of data (not data frame)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>make.quadradic.data</code>: Generate dataset according to a quadratic model
</p>
</li>
<li> <p><code>make.skew.data</code>: Generate dataset with a skew
</p>
</li></ul>

<hr>
<h2 id='make.randomized.compliance.dat'>Generate fake data with noncompliance.</h2><span id='topic+make.randomized.compliance.dat'></span>

<h3>Description</h3>

<p>This will generate and randomize a science table to get observed outcomes and treatment assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.randomized.compliance.dat(
  n,
  p = 0.6,
  science.table.generator = make.linear.data,
  include.POs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.randomized.compliance.dat_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="make.randomized.compliance.dat_+3A_p">p</code></td>
<td>
<p>Proportion treated</p>
</td></tr>
<tr><td><code id="make.randomized.compliance.dat_+3A_science.table.generator">science.table.generator</code></td>
<td>
<p>Method to generate potential outcomes</p>
</td></tr>
<tr><td><code id="make.randomized.compliance.dat_+3A_include.pos">include.POs</code></td>
<td>
<p>Preserve potential outcomes in returned value</p>
</td></tr>
<tr><td><code id="make.randomized.compliance.dat_+3A_...">...</code></td>
<td>
<p>To be passed to science.table.generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with data randomized to tx and control, and compliers, etc.
</p>


<h3>See Also</h3>

<p>make.randomized.dat
</p>

<hr>
<h2 id='make.randomized.dat'>Make fake data for simulations</h2><span id='topic+make.randomized.dat'></span>

<h3>Description</h3>

<p>Randomize a science table to get observed outcomes and treatment assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.randomized.dat(
  n,
  p = 0.6,
  science.table.generator = make.linear.data,
  include.POs = TRUE,
  as.data.frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.randomized.dat_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="make.randomized.dat_+3A_p">p</code></td>
<td>
<p>Proportion treated</p>
</td></tr>
<tr><td><code id="make.randomized.dat_+3A_science.table.generator">science.table.generator</code></td>
<td>
<p>Data generator</p>
</td></tr>
<tr><td><code id="make.randomized.dat_+3A_include.pos">include.POs</code></td>
<td>
<p>TRUE/FALSE. Keep POs</p>
</td></tr>
<tr><td><code id="make.randomized.dat_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>TRUE/FALSE.  Return as dataframe or as list of elements.</p>
</td></tr>
<tr><td><code id="make.randomized.dat_+3A_...">...</code></td>
<td>
<p>Additional to be passed to science.table.generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list of elements or a dataframe.
</p>

<hr>
<h2 id='Penn46_ascii'>Sample data set</h2><span id='topic+Penn46_ascii'></span>

<h3>Description</h3>

<p>This is a sample data set to illustrate the package methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Penn46_ascii
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 6384 observations and 12 columns.
</p>

<hr>
<h2 id='plot.FRTCI.test'>plot.FRTCI.test</h2><span id='topic+plot.FRTCI.test'></span>

<h3>Description</h3>

<p>Plot curve from FRTCI.test object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FRTCI.test'
plot(x, true.tau, xlab, ylab, true.tau.col, plot.envelope, ci.line.col, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.FRTCI.test_+3A_x">x</code></td>
<td>
<p>An object of class <code>FRTCI.test</code></p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_true.tau">true.tau</code></td>
<td>
<p>The true value of tau, if known. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. Default is tau.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label. Default is &quot;p-value&quot;.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_true.tau.col">true.tau.col</code></td>
<td>
<p>Color to plot true tau value, if provided. Default is red.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_plot.envelope">plot.envelope</code></td>
<td>
<p>Plot envelope around tested values of tau. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_ci.line.col">ci.line.col</code></td>
<td>
<p>Color to plot confidence interval around estimated treatment effect. Default is blue.</p>
</td></tr>
<tr><td><code id="plot.FRTCI.test_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>print.FRTCI.test()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rep(c(0, 1), 100)
tau &lt;- 4
Y &lt;- ifelse(Z, rnorm(100, tau), rnorm(100, 0))
df &lt;- data.frame(Y=Y, Z=Z)
tst &lt;- detect_idiosyncratic(Y ~ Z, df, B = 50, grid.size = 50)
plot(tst)

</code></pre>

<hr>
<h2 id='plot.RI.R2.result'>Make a plot of the treatment effect R2 estimates</h2><span id='topic+plot.RI.R2.result'></span>

<h3>Description</h3>

<p>Make a plot of the treatment effect R2 estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RI.R2.result'
plot(
  x,
  main = paste("R2 for Het Tx (", x$type, ")", sep = ""),
  ADD = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.RI.R2.result_+3A_x">x</code></td>
<td>
<p>Results from est.beta, etc.</p>
</td></tr>
<tr><td><code id="plot.RI.R2.result_+3A_main">main</code></td>
<td>
<p>Title for plot</p>
</td></tr>
<tr><td><code id="plot.RI.R2.result_+3A_add">ADD</code></td>
<td>
<p>TRUE if add to existing plot. FALSE make a new plot.</p>
</td></tr>
<tr><td><code id="plot.RI.R2.result_+3A_...">...</code></td>
<td>
<p>Arguments to pass to plotting of points.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>calc.beta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )
r2_out &lt;- R2(es)
plot(r2_out)

</code></pre>

<hr>
<h2 id='R2'>Estimate treatment variation R2</h2><span id='topic+R2'></span>

<h3>Description</h3>

<p>Bounds the R2 measure (how much of treatment variation is explained by given
covariates) using either the OLS output for the ITT from est.beta, or the
LATE estimation from est.beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2(est.beta, rho.step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_+3A_est.beta">est.beta</code></td>
<td>
<p>The output from 'est.beta()'. Either an estimate of overall
systematic effect variation, or systematic effect variation for compliers.</p>
</td></tr>
<tr><td><code id="R2_+3A_rho.step">rho.step</code></td>
<td>
<p>Grid size for sensitivity analysis on values of rho. Default
is 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RI.R2.result object.
</p>


<h3>See Also</h3>

<p>print.RI.R2.result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )
r2_out &lt;- R2(es)

</code></pre>

<hr>
<h2 id='rq.stat'>rq.stat</h2><span id='topic+rq.stat'></span><span id='topic+rq.stat.cond.cov'></span><span id='topic+rq.stat.uncond.cov'></span>

<h3>Description</h3>

<p>rq.stat is the Kolmogorov-smirnov statistic via quantile regression with covariates without further adjustment.
</p>
<p>rq.stat.cond.cov does Kolmogorov-smirnov statistic via quantile regression
with covariates, with a conditional approach; see Koenker and Xiao (2002).
</p>
<p>rq.stat.uncond.cov implements a Kolmogorov-smirnov statistic via quantile regression with covariates,
unconditional approach; see Firpo (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq.stat(Y, Z, rq.pts)

rq.stat.cond.cov(Y, Z, X, rq.pts)

rq.stat.uncond.cov(Y, Z, X, rq.pts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rq.stat_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="rq.stat_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="rq.stat_+3A_rq.pts">rq.pts</code></td>
<td>
<p>Sequence of quantile points at which to evaluate the test. Default is seq(.1, .9, by = .1). Should not go beyond 0 and 1.</p>
</td></tr>
<tr><td><code id="rq.stat_+3A_x">X</code></td>
<td>
<p>Additional pre-treatment covariates to adjust for in estimation, but
not to interact with treatment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: This function supresses all warnings of the 'rq()' method call.
</p>
<p>Warning: This function supresses all warnings of the 'rq()' method call.
</p>


<h3>Value</h3>

<p>The value of the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
rq.stat(df$Yobs, df$Z)

df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
rq.stat.cond.cov(df$Yobs, df$Z, df$A)

df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
rq.stat.uncond.cov(df$Yobs, df$Z, df$A)

</code></pre>

<hr>
<h2 id='SE'>Extract the standard errors from a var-cov matrix.</h2><span id='topic+SE'></span>

<h3>Description</h3>

<p>Extract the standard errors from a var-cov matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SE(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SE_+3A_object">object</code></td>
<td>
<p>est.beta object</p>
</td></tr>
<tr><td><code id="SE_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )
SE(es)

</code></pre>

<hr>
<h2 id='SKS.pool.t'>SKS.pool.t</h2><span id='topic+SKS.pool.t'></span>

<h3>Description</h3>

<p>Subtract off group level treatment effect estimates and then look
at KS statistic on residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKS.pool.t(Y, Z, W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SKS.pool.t_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="SKS.pool.t_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="SKS.pool.t_+3A_w">W</code></td>
<td>
<p>A a factor or categorical covariate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distinct from the interacted lm in that the control units are not
shifted and centered with respect to eachother.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
df$W &lt;- sample(c("A", "B", "C"), nrow(df), replace = TRUE)
SKS.pool.t(df$Yobs, df$Z, df$W)

</code></pre>

<hr>
<h2 id='SKS.stat'>SKS.stat</h2><span id='topic+SKS.stat'></span>

<h3>Description</h3>

<p>Shifted kolmogorov-smirnov statistic. Calculate KS distance between Y0 and Y1
shifted by sample tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKS.stat(Y, Z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SKS.stat_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="SKS.stat_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the test.
</p>


<h3>See Also</h3>

<p>KS.stat, SKS.stat.cov
</p>
<p>detect_idiosyncratic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat(df$Yobs, df$Z)

</code></pre>

<hr>
<h2 id='SKS.stat.cov.pool'>SKS.stat.cov.pool</h2><span id='topic+SKS.stat.cov.pool'></span><span id='topic+SKS.stat.cov'></span>

<h3>Description</h3>

<p>SKS.stat.cov.pool is the shifted kolmogorov-smirnov statistic with covariates
to increase precision.  This is the test statistic used Ding, Feller, and
Miratrix (2016), JRSS-B.
</p>
<p>SKS.stat.cov is the shifted kolmogorov-smirnov statistic with covariates
with model for outcomes calculated on control group only.
This avoids &quot;splitting&quot; the treatment variation between tx 
and co groups.  
We recommend this method over the &quot;pool&quot; method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKS.stat.cov.pool(Y, Z, X)

SKS.stat.cov(Y, Z, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SKS.stat.cov.pool_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="SKS.stat.cov.pool_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="SKS.stat.cov.pool_+3A_x">X</code></td>
<td>
<p>Additional pre-treatment covariates to adjust for in estimation, but not to interact with treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat.cov.pool(df$Yobs, df$Z, df$A)

df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat.cov(df$Yobs, df$Z, df$A)

</code></pre>

<hr>
<h2 id='SKS.stat.cov.rq'>SKS.stat.cov.rq</h2><span id='topic+SKS.stat.cov.rq'></span>

<h3>Description</h3>

<p>Shifted kolmogorov-smirnov statistic with covariates and quantile regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKS.stat.cov.rq(Y, Z, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SKS.stat.cov.rq_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="SKS.stat.cov.rq_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="SKS.stat.cov.rq_+3A_x">X</code></td>
<td>
<p>Additional pre-treatment covariates to adjust for in estimation, but not to interact with treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The test statistic value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat.cov.rq(df$Yobs, df$Z, df$A)

</code></pre>

<hr>
<h2 id='SKS.stat.int.cov.pool'>SKS.stat.int.cov.pool</h2><span id='topic+SKS.stat.int.cov.pool'></span><span id='topic+SKS.stat.int.cov'></span>

<h3>Description</h3>

<p>SKS.stat.int.cov.pool is a shifted kolmogorov-smirnov statistic with a linear
treatment effect model defined by W. It will attempt to remove any systematic
variation corresponding to W and then return a SKS statistic on the residuals
to measure any variation &quot;left over&quot;.
</p>
<p>SKS.stat.int.cov() is a Shifted kolmogorov-smirnov statistic with a linear
treatment effect model defined by W. It will attempt to remove any systematic
variation corresponding to W and then return a SKS statistic on the residuals
to measure any variation &quot;left over&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKS.stat.int.cov.pool(Y, Z, W, X)

SKS.stat.int.cov(Y, Z, W, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SKS.stat.int.cov.pool_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="SKS.stat.int.cov.pool_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="SKS.stat.int.cov.pool_+3A_w">W</code></td>
<td>
<p>Additional pre-treatment covariates to interact with T to define
linear model of treatment effects.</p>
</td></tr>
<tr><td><code id="SKS.stat.int.cov.pool_+3A_x">X</code></td>
<td>
<p>Additional pre-treatment covariates to adjust for in estimation, but not to interact with treatment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>X are _additional_ covariates to adjust for beyond those involved in
treatment effect model.  It will automatically ajust for W as well.  Do not
put a covariate in for both X and W.
</p>
<p>This is the test statistic used in Ding, Feller, and Miratrix (2016), JRSS-B.
</p>
<p>SKS.stat.int.cov first adjusts for baseline and then models treatment effect
on the residuals to not split treatment effects (see the vignette for more
information on this).
</p>
<p>We recommend SKS.stat.int.cov over the &quot;pool&quot; method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat.int.cov.pool(Y = df$Yobs, Z = df$Z, W = df$A, X = df$B)


df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
SKS.stat.int.cov(Y = df$Yobs, Z = df$Z, W = df$A, X = df$B)

</code></pre>

<hr>
<h2 id='test.stat.info'>test.stat.info</h2><span id='topic+test.stat.info'></span>

<h3>Description</h3>

<p>A list of test statistics for detect.idiosyncratic(), and information on use cases when each is appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.stat.info()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>test.stat.info()

</code></pre>

<hr>
<h2 id='ToyData'>Toy data set</h2><span id='topic+ToyData'></span>

<h3>Description</h3>

<p>This is a toy data set to illustrate the package methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ToyData
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 500 observations and 7 columns.
</p>

<hr>
<h2 id='variance.ratio.test'>Variance ratio test</h2><span id='topic+variance.ratio.test'></span>

<h3>Description</h3>

<p>Given vector of observed outcomes and treatment vector, test to see if there is evidence
the variances are different (taking kurtosis into account).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance.ratio.test(Yobs, Z, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance.ratio.test_+3A_yobs">Yobs</code></td>
<td>
<p>Outcome</p>
</td></tr>
<tr><td><code id="variance.ratio.test_+3A_z">Z</code></td>
<td>
<p>Treatment assignment vector</p>
</td></tr>
<tr><td><code id="variance.ratio.test_+3A_data">data</code></td>
<td>
<p>Dataframe with variables listed in formula and control.formula</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
variance.ratio.test(df$Yobs, df$Z)

</code></pre>

<hr>
<h2 id='vcov.RI.regression.result'>Get vcov() from object.</h2><span id='topic+vcov.RI.regression.result'></span>

<h3>Description</h3>

<p>Get vcov() from object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RI.regression.result'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.RI.regression.result_+3A_object">object</code></td>
<td>
<p>est.beta object</p>
</td></tr>
<tr><td><code id="vcov.RI.regression.result_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
es &lt;- estimate_systematic( Yobs ~ Z,  interaction.formula = ~ A + B, data = df )
vcov(es)

</code></pre>

<hr>
<h2 id='WSKS.t'>WSKS.t</h2><span id='topic+WSKS.t'></span>

<h3>Description</h3>

<p>Weighted average of the group-level SKS statistics.  This is useful for a
blocked experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WSKS.t(Y, Z, W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WSKS.t_+3A_y">Y</code></td>
<td>
<p>Observed outcome vector</p>
</td></tr>
<tr><td><code id="WSKS.t_+3A_z">Z</code></td>
<td>
<p>Treatment assigment vector</p>
</td></tr>
<tr><td><code id="WSKS.t_+3A_w">W</code></td>
<td>
<p>A a factor or categorical covariate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- make.randomized.dat( 1000, gamma.vec=c(1,1,1,2), beta.vec=c(-1,-1,1,0) )
df$W &lt;- sample(c("A", "B", "C"), nrow(df), replace = TRUE)
WSKS.t(df$Yobs, df$Z, df$W)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
