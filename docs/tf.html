<!DOCTYPE html><html><head><title>Help for package tf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.tf'><p>Convert functional data back to tabular data formats</p></a></li>
<li><a href='#ensure_list'><p>Turns any object into a list</p></a></li>
<li><a href='#fpc_wsvd'><p>Eigenfunctions via weighted, regularized SVD</p></a></li>
<li><a href='#functionwise'><p>Summarize each <code>tf</code> in a vector</p></a></li>
<li><a href='#in_range'><p>Find out if values are inside given bounds</p></a></li>
<li><a href='#Ops.tf'><p>Math, Summary and Ops Methods for <code>tf</code></p></a></li>
<li><a href='#plot.tf'><p><code>base</code> plots for <code>tf</code>s</p></a></li>
<li><a href='#prep_plotting_arg'><p>Preprocess evaluation grid for plotting</p></a></li>
<li><a href='#print.tf'><p>Pretty printing and formatting for functional data</p></a></li>
<li><a href='#tf_approx_linear'><p>Inter- and extrapolation functions for <code>tfd</code>-objects</p></a></li>
<li><a href='#tf_arg'><p>Utility functions for <code>tf</code>-objects</p></a></li>
<li><a href='#tf_depth'><p>Functional Data Depth</p></a></li>
<li><a href='#tf_derive'><p>Differentiating functional data: approximating derivative functions</p></a></li>
<li><a href='#tf_evaluate'><p>Evaluate <code>tf</code>-vectors for given argument values</p></a></li>
<li><a href='#tf_integrate'><p>Integrals and anti-derivatives of functional data</p></a></li>
<li><a href='#tf_interpolate'><p>Re-evaluate <code>tf</code>-objects on a new grid of argument values.</p></a></li>
<li><a href='#tf_jiggle'><p>Make a <code>tf</code> (more) irregular</p></a></li>
<li><a href='#tf_rebase'><p>Change (basis) representation of a <code>tf</code>-object</p></a></li>
<li><a href='#tf_rgp'><p>Gaussian Process random generator</p></a></li>
<li><a href='#tf_smooth'><p>Simple smoothing of <code>tf</code> objects</p></a></li>
<li><a href='#tf_where'><p>Find out where functional data fulfills certain conditions.</p></a></li>
<li><a href='#tf_zoom'><p>Functions to zoom in/out on functions</p></a></li>
<li><a href='#tf-package'><p>tf: S3 Classes and Methods for Tidy Functional Data</p></a></li>
<li><a href='#tfb'><p>Constructors for functional data in basis representation</p></a></li>
<li><a href='#tfb_fpc'><p>Functional data in FPC-basis representation</p></a></li>
<li><a href='#tfb_spline'><p>Spline-based representation of functional data</p></a></li>
<li><a href='#tfbrackets'><p>Accessing, evaluating, subsetting and subassigning <code>tf</code> vectors</p></a></li>
<li><a href='#tfd'><p>Constructors for vectors of &quot;raw&quot; functional data</p></a></li>
<li><a href='#tfsummaries'><p>Functions that summarize <code>tf</code> objects across argument values</p></a></li>
<li><a href='#unique_id'><p>Make syntactically valid unique names</p></a></li>
<li><a href='#vec_cast.tfd_reg'><p><code>vctrs</code> methods for <code>tf</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>S3 Classes and Methods for Tidy Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines S3 vector data types for vectors of functional data 
   (grid-based, spline-based or functional principal components-based) with all 
   arithmetic and summary methods, derivation, integration and smoothing, 
   plotting, data import and export, and data wrangling, such as re-evaluating, 
   subsetting, sub-assigning, zooming into sub-domains, or extracting functional 
   features like minima/maxima and their locations. 
   The implementation allows including such vectors in data frames for joint 
   analysis of functional and scalar variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidyfun.github.io/tf/">https://tidyfun.github.io/tf/</a>, <a href="https://github.com/tidyfun/tf/">https://github.com/tidyfun/tf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyfun/tf/issues">https://github.com/tidyfun/tf/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, methods, mgcv, mvtnorm, pracma, purrr, rlang,
stats, vctrs (&ge; 0.2.4), zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, knitr, refund, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'approx.R' 'bibentries.R' 'brackets.R' 'calculus.R'
'convert-construct-utils.R' 'convert.R' 'depth.R' 'evaluate.R'
'fwise.R' 'globals.R' 'graphics.R' 'interpolate.R' 'ops.R'
'math.R' 'methods.R' 'print-format.R' 'rebase.R' 'rng.R'
'smooth.R' 'soft-impute-svd.R' 'summarize.R' 'tf-package.R'
'tfb-fpc.R' 'tfb-spline.R' 'tfb-class.R' 'tfd-class.R'
'tf-s4.R' 'tfb-fpc-utils.R' 'tfb-spline-utils.R' 'utils.R'
'vctrs-cast.R' 'vctrs-ptype2.R' 'where.R' 'zoom.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 10:45:38 UTC; fabians</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabian Scheipl <a href="https://orcid.org/0000-0001-8172-3603"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jeff Goldsmith [aut],
  Julia Wrobel <a href="https://orcid.org/0000-0001-6783-1421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Maximilian Muecke <a href="https://orcid.org/0009-0000-9432-9795"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sebastian Fischer <a href="https://orcid.org/0000-0002-9609-3197"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Trevor Hastie [ctb] (softImpute author),
  Rahul Mazumder [ctb] (softImpute author),
  Chen Meng [ctb] (mogsa author)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabian Scheipl &lt;fabian.scheipl@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.tf'>Convert functional data back to tabular data formats</h2><span id='topic+as.data.frame.tf'></span><span id='topic+as.matrix.tf'></span><span id='topic+as.function.tf'></span>

<h3>Description</h3>

<p>Various converters to turn <code>tfb</code>- or <code>tfd</code>-vectors into data.frames or
matrices, or even an actual R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
as.data.frame(x, row.names = NULL, optional = FALSE, unnest = FALSE, ...)

## S3 method for class 'tf'
as.matrix(x, arg, interpolate = FALSE, ...)

## S3 method for class 'tf'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.tf_+3A_x">x</code></td>
<td>
<p>a <code>tf</code> object</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_optional">optional</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_unnest">unnest</code></td>
<td>
<p>if <code>TRUE</code>, the function will return a data.frame with the
evaluated functions.</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_arg">arg</code></td>
<td>
<p>a vector of argument values / evaluation points for <code>x</code>. Defaults
to <code>tf_arg(x)</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.tf_+3A_interpolate">interpolate</code></td>
<td>
<p>should functions be evaluated (i.e., inter-/extrapolated)
for values in <code>arg</code> for which no original data is available? Only relevant
for the raw data class <code>tfd</code>, for which it defaults to <code>FALSE</code>.
Basis-represented functional data <code>tfb</code> are always &quot;interpolated&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>for <code>as.data.frame.tf</code>:</strong> if <code>unnest</code> is <code>FALSE</code> (default), a
one-column <code>data.frame</code> with a <code>tf</code>-column containing <code>x</code>. if <code>unnest</code> is
<code>TRUE</code>, a 3-column data frame with columns <code>id</code> for the (unique) names of
<code>x</code> or a numeric identifier, <code>arg</code> and <code>value</code>, with each row containing
one function evaluation at the original <code>arg</code>-values.
</p>
<p><strong>for <code>as.matrix.tf</code>:</strong> a matrix with one row per function and one
column per <code>arg</code>.
</p>
<p><strong>for <code>as.function.tf</code>:</strong> an R function with argument <code>arg</code> that
evaluates <code>x</code> on <code>arg</code> and returns the list of function values
</p>

<hr>
<h2 id='ensure_list'>Turns any object into a list</h2><span id='topic+ensure_list'></span>

<h3>Description</h3>

<p>See above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_list_+3A_x">x</code></td>
<td>
<p>any input</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> turned into a list.
</p>


<h3>See Also</h3>

<p>Other tidyfun developer tools: 
<code><a href="#topic+prep_plotting_arg">prep_plotting_arg</a>()</code>,
<code><a href="#topic+unique_id">unique_id</a>()</code>
</p>

<hr>
<h2 id='fpc_wsvd'>Eigenfunctions via weighted, regularized SVD</h2><span id='topic+fpc_wsvd'></span><span id='topic+fpc_wsvd.matrix'></span><span id='topic+fpc_wsvd.data.frame'></span>

<h3>Description</h3>

<p>Compute (truncated) orthonormal eigenfunctions and scores
for (partially missing) data on a common (potentially non-equidistant) grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpc_wsvd(data, arg, pve = 0.995)

## S3 method for class 'matrix'
fpc_wsvd(data, arg, pve = 0.995)

## S3 method for class 'data.frame'
fpc_wsvd(data, arg, pve = 0.995)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpc_wsvd_+3A_data">data</code></td>
<td>
<p>numeric matrix of function evaluations
(each row is one curve, no NAs)</p>
</td></tr>
<tr><td><code id="fpc_wsvd_+3A_arg">arg</code></td>
<td>
<p>numeric vector of argument values</p>
</td></tr>
<tr><td><code id="fpc_wsvd_+3A_pve">pve</code></td>
<td>
<p>percentage of variance explained</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a weighted SVD with trapezoidal quadrature weights s.t. returned
vectors represent (evaluations of)
orthonormal eigen<em>functions</em> <code class="reqn">\phi_j(t)</code>, not eigen<em>vectors</em>
<code class="reqn">\phi_j = (\phi_j(t_1), \dots, \phi_j(t_n))</code>, specifically:<br />
<code class="reqn">\int_T \phi_j(t)^2 dt \approx \sum_i \Delta_i \phi_j(t_i)^2 = 1</code>
given quadrature weights <code class="reqn">\Delta_i</code>, not
<code class="reqn">\phi_j'\phi_j = \sum_i \phi_j(t_i)^2 = 1</code>;<br />
<code class="reqn">\int_T \phi_j(t) \phi_k(t) dt = 0</code> not
<code class="reqn">\phi_j'\phi_k = \sum_i \phi_j(t_i)\phi_k(t_i) = 0</code>,
c.f. <code>mogsa::wsvd()</code>.<br />
For incomplete data, this uses an adaptation of <code>softImpute::softImpute()</code>,
see references. Note that will not work well for data on a common grid if more
than a few percent of data points are missing, and it breaks down completely
for truly irregular data with no/few common timepoints, even if observed very
densely. For such data, either re-evaluate on a common grid first or use more
advanced FPCA approaches like <code>refund::fpca_sc()</code>,
see last example for <code><a href="#topic+tfb_fpc">tfb_fpc()</a></code>
</p>


<h3>Value</h3>

<p>a list with entries
</p>

<ul>
<li> <p><code>mu</code> estimated mean function (numeric vector)
</p>
</li>
<li> <p><code>efunctions</code> estimated FPCs (numeric matrix, columns represent FPCs)
</p>
</li>
<li> <p><code>scores</code> estimated FPC scores (one row per observed curve)
</p>
</li>
<li> <p><code>npc</code> how many FPCs were returned for the given <code>pve</code> (integer)
</p>
</li>
<li> <p><code>scoring_function</code> a function that returns FPC scores for new data
and given eigenfunctions, see <code>tf:::.fpc_wsvd_scores</code> for an example.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Trevor Hastie, Rahul Mazumder, Cheng Meng, Fabian Scheipl
</p>


<h3>References</h3>

<p>code adapted from / inspired by <code>mogsa::wsvd()</code> by Cheng Meng
and <code>softImpute::softImpute()</code> by Trevor Hastie and Rahul Mazumder.<br />
Meng C (2023).
<em><code>mogsa</code>: Multiple omics data integrative clustering and gene set analysis</em>.
<a href="https://bioconductor.org/packages/mogsa">https://bioconductor.org/packages/mogsa</a>.<br />
Mazumder, Rahul, Hastie, Trevor, Tibshirani, Robert (2010).
&ldquo;Spectral regularization algorithms for learning large incomplete matrices.&rdquo;
<em>The Journal of Machine Learning Research</em>, <b>11</b>, 2287-2322.<br />
Hastie T, Mazumder R (2021).
<em><code>softImpute</code>: Matrix Completion via Iterative Soft-Thresholded SVD</em>.
R package version 1.4-1, <a href="https://CRAN.R-project.org/package=softImpute">https://CRAN.R-project.org/package=softImpute</a>.
</p>


<h3>See Also</h3>

<p>Other tfb-class: 
<code><a href="#topic+tfb">tfb</a></code>,
<code><a href="#topic+tfb_fpc">tfb_fpc</a>()</code>,
<code><a href="#topic+tfb_spline">tfb_spline</a>()</code>
</p>
<p>Other tfb_fpc-class: 
<code><a href="#topic+tfb_fpc">tfb_fpc</a>()</code>
</p>

<hr>
<h2 id='functionwise'>Summarize each <code>tf</code> in a vector</h2><span id='topic+functionwise'></span><span id='topic+tf_fwise'></span><span id='topic+tf_fmax'></span><span id='topic+tf_fmin'></span><span id='topic+tf_fmedian'></span><span id='topic+tf_frange'></span><span id='topic+tf_fmean'></span><span id='topic+tf_fvar'></span><span id='topic+tf_fsd'></span><span id='topic+tf_crosscov'></span><span id='topic+tf_crosscor'></span>

<h3>Description</h3>

<p>These functions extract (user-specified) <strong>function-wise</strong> summary statistics
from each entry in a  <code>tf</code>-vector. To summarize a vector of functions at each
argument value, see <code>?tfsummaries</code>. Note that these will tend to yield lots
of <code>NA</code>s for irregular <code>tfd</code> unless you set a <code><a href="#topic+tf_evaluator">tf_evaluator()</a></code>-function
that does inter- and extrapolation for them beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_fwise(x, .f, arg = tf_arg(x), ...)

tf_fmax(x, arg = tf_arg(x), na.rm = FALSE)

tf_fmin(x, arg = tf_arg(x), na.rm = FALSE)

tf_fmedian(x, arg = tf_arg(x), na.rm = FALSE)

tf_frange(x, arg = tf_arg(x), na.rm = FALSE, finite = FALSE)

tf_fmean(x, arg = tf_arg(x))

tf_fvar(x, arg = tf_arg(x))

tf_fsd(x, arg = tf_arg(x))

tf_crosscov(x, y, arg = tf_arg(x))

tf_crosscor(x, y, arg = tf_arg(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functionwise_+3A_x">x</code></td>
<td>
<p>a <code>tf</code> object</p>
</td></tr>
<tr><td><code id="functionwise_+3A_.f">.f</code></td>
<td>
<p>a function or formula that is applied to each entry of <code>x</code>, see
<code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code> and Details.</p>
</td></tr>
<tr><td><code id="functionwise_+3A_arg">arg</code></td>
<td>
<p>defaults to standard argument values of <code>x</code></p>
</td></tr>
<tr><td><code id="functionwise_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="purrr.html#topic+as_mapper">purrr::as_mapper()</a></code></p>
</td></tr>
<tr><td><code id="functionwise_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
<tr><td><code id="functionwise_+3A_finite">finite</code></td>
<td>
<p>logical, indicating if all non-finite elements should
be omitted.</p>
</td></tr>
<tr><td><code id="functionwise_+3A_y">y</code></td>
<td>
<p>a <code>tf</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tf_fwise</code> turns <code>x</code> into a list of data.frames with columns <code>arg</code>
and <code>values</code> internally, so the function/formula in <code>.f</code> gets a data.frame
<code>.x</code> with these columns, see examples below or source code for <code><a href="#topic+tf_fmin">tf_fmin()</a></code>,
<code><a href="#topic+tf_fmax">tf_fmax()</a></code>, etc
</p>


<h3>Value</h3>

<p>a list (or vector) of the same length as <code>x</code> with the respective
summaries
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>tf_fwise()</code>: User-specified function-wise summary statistics
</p>
</li>
<li> <p><code>tf_fmax()</code>: maximal value of each function
</p>
</li>
<li> <p><code>tf_fmin()</code>: minimal value of each function
</p>
</li>
<li> <p><code>tf_fmedian()</code>: median value of each function
</p>
</li>
<li> <p><code>tf_frange()</code>: range of values of each function
</p>
</li>
<li> <p><code>tf_fmean()</code>: mean of each function:
<code class="reqn">\tfrac{1}{|T|}\int_T x_i(t) dt</code>
</p>
</li>
<li> <p><code>tf_fvar()</code>: variance of each function:
<code class="reqn">\tfrac{1}{|T|}\int_T (x_i(t) - \bar x(t))^2 dt</code>
</p>
</li>
<li> <p><code>tf_fsd()</code>: standard deviation of each function:
<code class="reqn">\sqrt{\tfrac{1}{|T|}\int_T (x_i(t) - \bar x(t))^2 dt}</code>
</p>
</li>
<li> <p><code>tf_crosscov()</code>: cross-covariances between two functional vectors:
<code class="reqn">\tfrac{1}{|T|}\int_T (x_i(t) - \bar x(t)) (y_i(t)-\bar y(t)) dt</code>
</p>
</li>
<li> <p><code>tf_crosscor()</code>: cross-correlation between two functional vectors:
<code>tf_crosscov(x, y) / (tf_fsd(x) * tf_fsd(y))</code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other tidyfun summary functions: 
<code><a href="#topic+tfsummaries">tfsummaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tf_rgp(3)
layout(t(1:3))
plot(x, col = 1:3)
#  each function's values to [0,1]:
x_clamp &lt;- (x - tf_fmin(x)) / (tf_fmax(x) - tf_fmin(x))
plot(x_clamp, col = 1:3)
# standardize each function to have mean / integral 0 and sd 1:
x_std &lt;- (x - tf_fmean(x)) / tf_fsd(x)
tf_fvar(x_std) == c(1, 1, 1)
plot(x_std, col = 1:3)
# Custom functions:
# 80%tiles of each function's values:
tf_fwise(x, ~ quantile(.x$value, .8)) |&gt; unlist()
# minimal value of each function for t &gt;.5
tf_fwise(x, ~ min(.x$value[.x$arg &gt; .5])) |&gt; unlist()

tf_crosscor(x, -x)
tf_crosscov(x, x) == tf_fvar(x)
</code></pre>

<hr>
<h2 id='in_range'>Find out if values are inside given bounds</h2><span id='topic+in_range'></span><span id='topic++25inr+25'></span>

<h3>Description</h3>

<p><code>in_range</code> and its infix-equivalent <code style="white-space: pre;">&#8288;%inr%&#8288;</code> return <code>TRUE</code> for all values in
the numeric vector <code>f</code> that are within the range of values in <code>r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_range(f, r)

f %inr% r
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_range_+3A_f">f</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="in_range_+3A_r">r</code></td>
<td>
<p>numeric vector used to specify a range, only the minimum and maximum
of <code>r</code> are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>logical</code> vector of the same length as <code>f</code>
</p>


<h3>See Also</h3>

<p>Other tidyfun utility functions: 
<code><a href="#topic+tf_arg">tf_arg</a>()</code>,
<code><a href="#topic+tf_zoom">tf_zoom</a>()</code>
</p>

<hr>
<h2 id='Ops.tf'>Math, Summary and Ops Methods for <code>tf</code></h2><span id='topic+Ops.tf'></span><span id='topic++3D+3D.tfd'></span><span id='topic++21+3D.tfd'></span><span id='topic++3D+3D.tfb'></span><span id='topic++21+3D.tfb'></span><span id='topic+Ops.tfd'></span><span id='topic+Ops.tfb'></span><span id='topic+Math.tfd'></span><span id='topic+Math.tfb'></span><span id='topic+Summary.tf'></span><span id='topic+cummax.tfd'></span><span id='topic+cummin.tfd'></span><span id='topic+cumsum.tfd'></span><span id='topic+cumprod.tfd'></span><span id='topic+cummax.tfb'></span><span id='topic+cummin.tfb'></span><span id='topic+cumsum.tfb'></span><span id='topic+cumprod.tfb'></span>

<h3>Description</h3>

<p>These methods and operators mostly work <code>arg</code>-value-wise on <code>tf</code> objects, see
<code>?groupGeneric</code> for implementation details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
Ops(e1, e2)

## S3 method for class 'tfd'
e1 == e2

## S3 method for class 'tfd'
e1 != e2

## S3 method for class 'tfb'
e1 == e2

## S3 method for class 'tfb'
e1 != e2

## S3 method for class 'tfd'
Ops(e1, e2)

## S3 method for class 'tfb'
Ops(e1, e2)

## S3 method for class 'tfd'
Math(x, ...)

## S3 method for class 'tfb'
Math(x, ...)

## S3 method for class 'tf'
Summary(...)

## S3 method for class 'tfd'
cummax(...)

## S3 method for class 'tfd'
cummin(...)

## S3 method for class 'tfd'
cumsum(...)

## S3 method for class 'tfd'
cumprod(...)

## S3 method for class 'tfb'
cummax(...)

## S3 method for class 'tfb'
cummin(...)

## S3 method for class 'tfb'
cumsum(...)

## S3 method for class 'tfb'
cumprod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.tf_+3A_e1">e1</code></td>
<td>
<p>an <code>tf</code> or a numeric vector</p>
</td></tr>
<tr><td><code id="Ops.tf_+3A_e2">e2</code></td>
<td>
<p>an <code>tf</code> or a numeric vector</p>
</td></tr>
<tr><td><code id="Ops.tf_+3A_x">x</code></td>
<td>
<p>an <code>tf</code></p>
</td></tr>
<tr><td><code id="Ops.tf_+3A_...">...</code></td>
<td>
<p><code>tf</code>-objects (not used for <code>Math</code> group generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples below. Equality checks of functional objects are even more iffy
than usual for computer math and not very reliable. Note that <code>max</code> and <code>min</code>
are not guaranteed to be maximal/minimal over the entire domain, only on the
evaluation grid used for computation. With the exception of addition and
multiplication, operations on <code>tfb</code>-objects first evaluate the data on their
<code>arg</code>, perform computations on these evaluations and then convert back to an
<code>tfb</code>- object, so a loss of precision should be expected &ndash; especially so for
small spline bases and/or very wiggly data.
</p>


<h3>Value</h3>

<p>a <code>tf</code>- or <code>logical</code> vector with the computed result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf_fwise">tf_fwise()</a></code> for scalar summaries of each function in a <code>tf</code>-vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1859)
f &lt;- tf_rgp(4)
2 * f == f + f
sum(f) == f[1] + f[2] + f[3] + f[4]
log(exp(f)) == f
plot(f, points = FALSE)
lines(range(f), col = 2, lty = 2)

f2 &lt;- tf_rgp(5) |&gt; exp() |&gt; tfb(k = 25)
layout(t(1:3))
plot(f2, col = gray.colors(5))
plot(cummin(f2), col = gray.colors(5))
plot(cumsum(f2), col = gray.colors(5))

# ?tf_integrate for integrals, ?tf_fwise for scalar summaries of each function
</code></pre>

<hr>
<h2 id='plot.tf'><code>base</code> plots for <code>tf</code>s</h2><span id='topic+plot.tf'></span><span id='topic+lines.tf'></span><span id='topic+points.tf'></span>

<h3>Description</h3>

<p>Some <code>base</code> functions for displaying functional data in
spaghetti- (i.e., line plots) and lasagna- (i.e., heat map) flavors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
plot(
  x,
  y,
  n_grid = 50,
  points = is_irreg(x),
  type = c("spaghetti", "lasagna"),
  alpha = min(1, max(0.05, 2/length(x))),
  ...
)

## S3 method for class 'tf'
lines(x, arg, n_grid = 50, alpha = min(1, max(0.05, 2/length(x))), ...)

## S3 method for class 'tf'
points(
  x,
  arg,
  n_grid = NA,
  alpha = min(1, max(0.05, 2/length(x))),
  interpolate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tf_+3A_x">x</code></td>
<td>
<p>an <code>tf</code> object</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_y">y</code></td>
<td>
<p>(optional) numeric vector to be used as <code>arg</code>
(i.e., for the <strong>x</strong>-axis...!)</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_n_grid">n_grid</code></td>
<td>
<p>minimal size of equidistant grid used for plotting,
defaults to 50. See details.</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_points">points</code></td>
<td>
<p>should the original evaluation points be marked by points?
Defaults to <code>TRUE</code> for irregular <code>tfd</code> and FALSE for all others</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_type">type</code></td>
<td>
<p>&quot;spaghetti&quot;: line plots, &quot;lasagna&quot;: heat maps.</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_alpha">alpha</code></td>
<td>
<p>alpha-value (see<code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code>) for noodle transparency.
Defaults to 2/(no. of observations). Lower is more transparent.</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="graphics.html#topic+matplot">matplot()</a></code> (&quot;spaghetti&quot;) or
<code><a href="Matrix.html#topic+image">image()</a></code> (&quot;lasagna&quot;)</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_arg">arg</code></td>
<td>
<p>evaluation grid (vector)</p>
</td></tr>
<tr><td><code id="plot.tf_+3A_interpolate">interpolate</code></td>
<td>
<p>should functions be evaluated (i.e., inter-/extrapolated)
for arg for which no original data is available? Only relevant for
tfd, defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no second argument <code>y</code> is given, evaluation points (<code>arg</code>) for the functions
are given by the union of the <code>tf</code>'s <code>arg</code> and an equidistant grid
over its domain with <code>n_grid</code> points. If you want to only see the original
data for <code>tfd</code>-objects without inter-/extrapolation, use <code>n_grid &lt; 1</code> or
<code>n_grid = NA</code>.
</p>


<h3>Value</h3>

<p>the plotted <code>tf</code>-object, invisibly.
</p>


<h3>References</h3>

<p>Swihart, J B, Caffo, Brian, James, D B, Strand, Matthew, Schwartz, S B, Punjabi, M N (2010).
&ldquo;Lasagna plots: a saucy alternative to spaghetti plots.&rdquo;
<em>Epidemiology (Cambridge, Mass.)</em>, <b>21</b>(5), 621&ndash;625.
</p>

<hr>
<h2 id='prep_plotting_arg'>Preprocess evaluation grid for plotting</h2><span id='topic+prep_plotting_arg'></span>

<h3>Description</h3>

<p>(internal function exported for re-use in upstream packages)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_plotting_arg(f, n_grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_plotting_arg_+3A_f">f</code></td>
<td>
<p>a <code>tf</code>-object</p>
</td></tr>
<tr><td><code id="prep_plotting_arg_+3A_n_grid">n_grid</code></td>
<td>
<p>length of evaluation grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a semi-regular grid rounded down to appropriate resolution
</p>


<h3>See Also</h3>

<p>Other tidyfun developer tools: 
<code><a href="#topic+ensure_list">ensure_list</a>()</code>,
<code><a href="#topic+unique_id">unique_id</a>()</code>
</p>

<hr>
<h2 id='print.tf'>Pretty printing and formatting for functional data</h2><span id='topic+print.tf'></span><span id='topic+print.tfd_reg'></span><span id='topic+print.tfd_irreg'></span><span id='topic+print.tfb'></span><span id='topic+format.tf'></span>

<h3>Description</h3>

<p>Print/format <code>tf</code>-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
print(x, n = 5, ...)

## S3 method for class 'tfd_reg'
print(x, n = 5, ...)

## S3 method for class 'tfd_irreg'
print(x, n = 5, ...)

## S3 method for class 'tfb'
print(x, n = 5, ...)

## S3 method for class 'tf'
format(
  x,
  digits = 2,
  nsmall = 0,
  width = options()$width,
  n = 5,
  prefix = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tf_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object (conceptually); typically numeric.</p>
</td></tr>
<tr><td><code id="print.tf_+3A_n">n</code></td>
<td>
<p>how many elements of <code>x</code> to print out</p>
</td></tr>
<tr><td><code id="print.tf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.tf_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating how many significant digits
are to be used for
numeric and complex <code>x</code>.  The default, <code>NULL</code>, uses
<code><a href="base.html#topic+getOption">getOption</a>("digits")</code>.  This is a suggestion: enough decimal
places will be used so that the smallest (in magnitude) number has
this many significant digits, and also to satisfy <code>nsmall</code>.
(For more, notably the interpretation for complex numbers see
<code><a href="base.html#topic+signif">signif</a></code>.)</p>
</td></tr>
<tr><td><code id="print.tf_+3A_nsmall">nsmall</code></td>
<td>
<p>the minimum number of digits to the right of the decimal
point in formatting real/complex numbers in non-scientific formats.
Allowed values are <code>0 &lt;= nsmall &lt;= 20</code>.</p>
</td></tr>
<tr><td><code id="print.tf_+3A_width">width</code></td>
<td>
<p><code>default</code> method: the <em>minimum</em> field width or
<code>NULL</code> or <code>0</code> for no restriction.
</p>
<p><code>AsIs</code> method: the <em>maximum</em> field width for non-character
objects.  <code>NULL</code> corresponds to the default <code>12</code>.
</p>
</td></tr>
<tr><td><code id="print.tf_+3A_prefix">prefix</code></td>
<td>
<p>used internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints out <code>x</code> and returns it invisibly
</p>

<hr>
<h2 id='tf_approx_linear'>Inter- and extrapolation functions for <code>tfd</code>-objects</h2><span id='topic+tf_approx_linear'></span><span id='topic+tf_approx_spline'></span><span id='topic+tf_approx_none'></span><span id='topic+tf_approx_fill_extend'></span><span id='topic+tf_approx_locf'></span><span id='topic+tf_approx_nocb'></span>

<h3>Description</h3>

<p>These are the currently available <code>evaluator</code>-functions for <code>tfd</code>-objects,
which control how the entries are inter-/extrapolated to previously unseen
<code>arg</code>-values. They all are merely wrappers around <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code>,
<code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code>, etc... Note that these are not meant to be called directly &ndash;
they are internal functions used by <code><a href="#topic+tf_evaluate.tfd">tf_evaluate.tfd()</a></code> to do its thing.
</p>
<p>The list:
</p>

<ul>
<li> <p><code>tf_approx_linear</code> for linear interpolation without extrapolation (i.e.,
<code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code> with <code>na.rm = FALSE</code>)  &ndash; this is the default,
</p>
</li>
<li> <p><code>tf_approx_spline</code> for cubic spline interpolation, (i.e., <code><a href="zoo.html#topic+na.approx">zoo::na.spline()</a></code>
with <code>na.rm = FALSE</code>),
</p>
</li>
<li> <p><code>tf_approx_none</code> in order to not inter-/extrapolate ever (i.e., <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> with <code>fill = NA</code>)
</p>
</li>
<li> <p><code>tf_approx_fill_extend</code> for linear interpolation and constant extrapolation
(i.e., <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> with <code>fill = "extend"</code>)
</p>
</li>
<li> <p><code>tf_approx_locf</code> for &quot;last observation carried forward&quot;  (i.e.,
<code><a href="zoo.html#topic+na.locf">zoo::na.locf()</a></code> with <code>na.rm = FALSE</code> and
</p>
</li>
<li> <p><code>tf_approx_nocb</code> for &quot;next observation carried backward&quot; (i.e.,
<code><a href="zoo.html#topic+na.locf">zoo::na.locf()</a></code> with <code style="white-space: pre;">&#8288;na.rm = FALSE, fromLast = TRUE&#8288;</code>).
</p>
</li></ul>

<p>For implementing your own, see source code of <code>tf:::zoo_wrapper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_approx_linear(x, arg, evaluations)

tf_approx_spline(x, arg, evaluations)

tf_approx_none(x, arg, evaluations)

tf_approx_fill_extend(x, arg, evaluations)

tf_approx_locf(x, arg, evaluations)

tf_approx_nocb(x, arg, evaluations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_approx_linear_+3A_x">x</code></td>
<td>
<p>new <code>arg</code> values to approximate/interpolate/extrapolate the function for</p>
</td></tr>
<tr><td><code id="tf_approx_linear_+3A_arg">arg</code></td>
<td>
<p>the <code>arg</code> values of the <code>evaluations</code></p>
</td></tr>
<tr><td><code id="tf_approx_linear_+3A_evaluations">evaluations</code></td>
<td>
<p>the function values at <code>arg</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of values of the function defined by the given
<code class="reqn">(x_i, f(x_i))</code>=<code style="white-space: pre;">&#8288;(arg, evaluations)&#8288;</code>-tuples at new argument values <code>x</code>.
</p>


<h3>See Also</h3>

<p>tfd
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>

<hr>
<h2 id='tf_arg'>Utility functions for <code>tf</code>-objects</h2><span id='topic+tf_arg'></span><span id='topic+tf_evaluations'></span><span id='topic+tf_count'></span><span id='topic+tf_domain'></span><span id='topic+tf_domain+3C-'></span><span id='topic+tf_evaluator'></span><span id='topic+tf_evaluator+3C-'></span><span id='topic+tf_basis'></span><span id='topic+tf_arg+3C-'></span><span id='topic+tf_arg+3C-.tfd_irreg'></span><span id='topic+tf_arg+3C-.tfd_reg'></span><span id='topic+tf_arg+3C-.tfb'></span><span id='topic+coef.tfb'></span><span id='topic+rev.tf'></span><span id='topic+is.na.tf'></span><span id='topic+is.na.tfd_irreg'></span><span id='topic+is_tf'></span><span id='topic+is_tfd'></span><span id='topic+is_reg'></span><span id='topic+is_tfd_reg'></span><span id='topic+is_irreg'></span><span id='topic+is_tfd_irreg'></span><span id='topic+is_tfb'></span><span id='topic+is_tfb_spline'></span><span id='topic+is_tfb_fpc'></span>

<h3>Description</h3>

<p>A bunch of methods &amp; utilities that do what they say: get or set the
respective attributes of a <code>tf</code>-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_arg(f)

tf_evaluations(f)

tf_count(f)

tf_domain(f)

tf_domain(x) &lt;- value

tf_evaluator(f)

tf_evaluator(x) &lt;- value

tf_basis(f, as_tfd = FALSE)

tf_arg(x) &lt;- value

## S3 replacement method for class 'tfd_irreg'
tf_arg(x) &lt;- value

## S3 replacement method for class 'tfd_reg'
tf_arg(x) &lt;- value

## S3 replacement method for class 'tfb'
tf_arg(x) &lt;- value

## S3 method for class 'tfb'
coef(object, ...)

## S3 method for class 'tf'
rev(x)

## S3 method for class 'tf'
is.na(x)

## S3 method for class 'tfd_irreg'
is.na(x)

is_tf(x)

is_tfd(x)

is_reg(x)

is_tfd_reg(x)

is_irreg(x)

is_tfd_irreg(x)

is_tfb(x)

is_tfb_spline(x)

is_tfb_fpc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_arg_+3A_f">f</code></td>
<td>
<p>an <code>tf</code> object</p>
</td></tr>
<tr><td><code id="tf_arg_+3A_x">x</code></td>
<td>
<p>an <code>tf</code> object</p>
</td></tr>
<tr><td><code id="tf_arg_+3A_value">value</code></td>
<td>
<p><strong>for <code style="white-space: pre;">&#8288;tf_evaluator&lt;-&#8288;</code>:</strong> (bare or quoted) name of a function
that can be used to interpolate an <code>tfd</code>. Needs to accept vector arguments
<code>x</code>, <code>arg</code>, <code>evaluations</code> and return evaluations of the function defined by
<code>arg</code>, <code>evaluations</code> at <code>x</code>. <br />
<strong>for <code style="white-space: pre;">&#8288;tf_arg&lt;-&#8288;</code>:</strong> (list of) new <code>arg</code>-values. <br />
<strong>for <code style="white-space: pre;">&#8288;tf_domain&lt;-&#8288;</code>:</strong> sorted numeric vector with the 2 new endpoints of
the domain. <br /></p>
</td></tr>
<tr><td><code id="tf_arg_+3A_as_tfd">as_tfd</code></td>
<td>
<p>should the basis be returned as a <code>tfd</code>-vector evaluated on
<code>tf_arg(f)</code>? Defaults to <code>FALSE</code>, which returns the matrix of basis functions
(columns) evaluated on <code>tf_arg(f)</code> (rows).</p>
</td></tr>
<tr><td><code id="tf_arg_+3A_object">object</code></td>
<td>
<p>as usual</p>
</td></tr>
<tr><td><code id="tf_arg_+3A_...">...</code></td>
<td>
<p>dots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the respective attribute or, for setters (assignment functions),
the input object with modified properties.
</p>


<h3>See Also</h3>

<p>Other tidyfun utility functions: 
<code><a href="#topic+in_range">in_range</a>()</code>,
<code><a href="#topic+tf_zoom">tf_zoom</a>()</code>
</p>

<hr>
<h2 id='tf_depth'>Functional Data Depth</h2><span id='topic+tf_depth'></span><span id='topic+tf_depth.matrix'></span><span id='topic+tf_depth.tf'></span>

<h3>Description</h3>

<p>Data depths for functional data.
Currently implemented: Modified Band-2 Depth, see reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_depth(x, arg, depth = "MBD", na.rm = TRUE, ...)

## S3 method for class 'matrix'
tf_depth(x, arg, depth = "MBD", na.rm = TRUE, ...)

## S3 method for class 'tf'
tf_depth(x, arg, depth = "MBD", na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_depth_+3A_x">x</code></td>
<td>
<p><code>tf</code> (or a matrix of evaluations)</p>
</td></tr>
<tr><td><code id="tf_depth_+3A_arg">arg</code></td>
<td>
<p>grid of evaluation points</p>
</td></tr>
<tr><td><code id="tf_depth_+3A_depth">depth</code></td>
<td>
<p>currently available: &quot;MBD&quot;, i.e. modified band depth</p>
</td></tr>
<tr><td><code id="tf_depth_+3A_na.rm">na.rm</code></td>
<td>
<p>TRUE remove missing observations?</p>
</td></tr>
<tr><td><code id="tf_depth_+3A_...">...</code></td>
<td>
<p>further arguments handed to the function computing the respective
tf_depth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of tf_depth values
</p>


<h3>References</h3>

<p>Sun, Ying, Genton, G M, Nychka, W D (2012).
&ldquo;Exact fast computation of band depth for large functional datasets: How quickly can one million curves be ranked?&rdquo;
<em>Stat</em>, <b>1</b>(1), 68&ndash;74.
</p>
<p>LÃ³pez-Pintado, Sara, Romo, Juan (2009).
&ldquo;On the concept of depth for functional data.&rdquo;
<em>Journal of the American statistical Association</em>, <b>104</b>(486), 718&ndash;734.
</p>

<hr>
<h2 id='tf_derive'>Differentiating functional data: approximating derivative functions</h2><span id='topic+tf_derive'></span><span id='topic+tf_derive.matrix'></span><span id='topic+tf_derive.tfd'></span><span id='topic+tf_derive.tfb_spline'></span><span id='topic+tf_derive.tfb_fpc'></span>

<h3>Description</h3>

<p>Derivatives of <code>tf</code>-objects use finite differences of the evaluations for
<code>tfd</code> and finite differences of the basis functions for <code>tfb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_derive(f, arg, order = 1, ...)

## S3 method for class 'matrix'
tf_derive(f, arg, order = 1, ...)

## S3 method for class 'tfd'
tf_derive(f, arg, order = 1, ...)

## S3 method for class 'tfb_spline'
tf_derive(f, arg, order = 1, ...)

## S3 method for class 'tfb_fpc'
tf_derive(f, arg, order = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_derive_+3A_f">f</code></td>
<td>
<p>a <code>tf</code>-object</p>
</td></tr>
<tr><td><code id="tf_derive_+3A_arg">arg</code></td>
<td>
<p>grid to use for the finite differences.
Not the <code>arg</code> of the returned object for <code>tfd</code>-inputs, see Details.</p>
</td></tr>
<tr><td><code id="tf_derive_+3A_order">order</code></td>
<td>
<p>order of differentiation. Maximal value for <code>tfb_spline</code> is 2.</p>
</td></tr>
<tr><td><code id="tf_derive_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The derivatives of <code>tfd</code> objects use centered finite differences, e.g. for
first derivatives <code class="reqn">f'((t_i + t_{i+1})/2) \approx \frac{f(t_i) +
f(t_{i+1})}{t_{i+1} - t_i}</code>, so the <strong>domains of differentiated <code>tfd</code> will
shrink (slightly) at both ends</strong>. Unless the <code>tfd</code> has a rather fine and
regular grid, representing the data in a suitable basis representation with
<code><a href="#topic+tfb">tfb()</a></code> and then computing the derivatives or integrals of those is usually
preferable.
</p>
<p>Note that, for some spline bases like <code>"cr"</code> or <code>"tp"</code> which always begin/end
linearly, computing second derivatives will produce artefacts at the outer
limits of the functions' domain due to these boundary constraints. Basis
<code>"bs"</code> does not have this problem for sufficiently high orders, but tends to
yield slightly less stable fits.
</p>


<h3>Value</h3>

<p>a <code>tf</code> (with slightly different <code>arg</code> or <code>basis</code> for the
derivatives, see Details)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tf_derive(matrix)</code>: row-wise finite differences
</p>
</li>
<li> <p><code>tf_derive(tfd)</code>: derivatives by finite differencing.
</p>
</li>
<li> <p><code>tf_derive(tfb_spline)</code>: derivatives by finite differencing.
</p>
</li>
<li> <p><code>tf_derive(tfb_fpc)</code>: derivatives by finite differencing.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other tidyfun calculus functions: 
<code><a href="#topic+tf_integrate">tf_integrate</a>()</code>
</p>

<hr>
<h2 id='tf_evaluate'>Evaluate <code>tf</code>-vectors for given argument values</h2><span id='topic+tf_evaluate'></span><span id='topic+tf_evaluate.default'></span><span id='topic+tf_evaluate.tfd'></span><span id='topic+tf_evaluate.tfb'></span>

<h3>Description</h3>

<p>Also used internally by the <code>[</code>-operator for <code>tf</code> data (see <code>?tfbrackets</code>) to
evaluate <code>object</code>, see examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_evaluate(object, arg, ...)

## Default S3 method:
tf_evaluate(object, arg, ...)

## S3 method for class 'tfd'
tf_evaluate(object, arg, evaluator = tf_evaluator(object), ...)

## S3 method for class 'tfb'
tf_evaluate(object, arg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_evaluate_+3A_object">object</code></td>
<td>
<p>a <code>tf</code>, or a <code>data.frame</code>-like object with <code>tf</code> columns.</p>
</td></tr>
<tr><td><code id="tf_evaluate_+3A_arg">arg</code></td>
<td>
<p>optional evaluation grid (vector or list of vectors).
Defaults to <code>tf_arg(object)</code>, implicitly.</p>
</td></tr>
<tr><td><code id="tf_evaluate_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="tf_evaluate_+3A_evaluator">evaluator</code></td>
<td>
<p>optional. The function to use for inter/extrapolating the
<code>tfd</code>. Defaults to <code>tf_evaluator(object)</code>.
See e.g. <code><a href="#topic+tf_approx_linear">tf_approx_linear()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numeric vectors containing the function
evaluations on <code>arg</code>.
</p>


<h3>See Also</h3>

<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_approx_linear">tf_approx_linear</a>()</code>,
<code><a href="#topic+tf_interpolate">tf_interpolate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- tf_rgp(3, arg = seq(0, 1, length.out = 11))
tf_evaluate(f) |&gt; str()
tf_evaluate(f, arg = 0.5) |&gt; str()
# equivalent, as matrix:
f[, 0.5]
new_grid &lt;- seq(0, 1, length.out = 6)
tf_evaluate(f, arg = new_grid) |&gt; str()
# equivalent, as matrix:
f[, new_grid]
</code></pre>

<hr>
<h2 id='tf_integrate'>Integrals and anti-derivatives of functional data</h2><span id='topic+tf_integrate'></span><span id='topic+tf_integrate.default'></span><span id='topic+tf_integrate.tfd'></span><span id='topic+tf_integrate.tfb'></span>

<h3>Description</h3>

<p>Integrals of <code>tf</code>-objects are computed by simple quadrature (trapezoid rule).
By default the scalar definite integral
<code class="reqn">\int^{upper}_{lower}f(s)ds</code> is returned (option <code>definite = TRUE</code>),
alternatively for <code>definite = FALSE</code> the <em>anti-derivative</em> on
<code style="white-space: pre;">&#8288;[lower, upper]&#8288;</code>, e.g. a <code>tfd</code> or <code>tfb</code> object representing <code class="reqn">F(t) \approx
\int^{t}_{lower}f(s)ds</code>, for <code class="reqn">t \in</code><code style="white-space: pre;">&#8288;[lower, upper]&#8288;</code>, is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_integrate(f, arg, lower, upper, ...)

## Default S3 method:
tf_integrate(f, arg, lower, upper, ...)

## S3 method for class 'tfd'
tf_integrate(
  f,
  arg,
  lower = tf_domain(f)[1],
  upper = tf_domain(f)[2],
  definite = TRUE,
  ...
)

## S3 method for class 'tfb'
tf_integrate(
  f,
  arg,
  lower = tf_domain(f)[1],
  upper = tf_domain(f)[2],
  definite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_integrate_+3A_f">f</code></td>
<td>
<p>a <code>tf</code>-object</p>
</td></tr>
<tr><td><code id="tf_integrate_+3A_arg">arg</code></td>
<td>
<p>(optional) grid to use for the quadrature.</p>
</td></tr>
<tr><td><code id="tf_integrate_+3A_lower">lower</code></td>
<td>
<p>lower limits of the integration range. For <code>definite=TRUE</code>, this
can be a vector of the same length as <code>f</code>.</p>
</td></tr>
<tr><td><code id="tf_integrate_+3A_upper">upper</code></td>
<td>
<p>upper limits of the integration range (but see <code>definite</code> arg /
Description). For <code>definite=TRUE</code>, this can be a vector of the same length
as <code>f</code>.</p>
</td></tr>
<tr><td><code id="tf_integrate_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="tf_integrate_+3A_definite">definite</code></td>
<td>
<p>should the definite integral  be returned (default) or the
antiderivative. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>definite = TRUE</code>, the definite integrals of the functions in
<code>f</code>. For <code>definite = FALSE</code> and <code>tf</code>-inputs, a <code>tf</code> object containing their
anti-derivatives
</p>


<h3>See Also</h3>

<p>Other tidyfun calculus functions: 
<code><a href="#topic+tf_derive">tf_derive</a>()</code>
</p>

<hr>
<h2 id='tf_interpolate'>Re-evaluate <code>tf</code>-objects on a new grid of argument values.</h2><span id='topic+tf_interpolate'></span><span id='topic+tf_interpolate.tfb'></span><span id='topic+tf_interpolate.tfd'></span>

<h3>Description</h3>

<p>Change the internal representation of a <code>tf</code>-object so that it
uses a different grid of argument values (<code>arg</code>). Useful for
</p>

<ul>
<li><p> thinning out dense grids to make data smaller
</p>
</li>
<li><p> filling out sparse grids to make derivatives/integrals and locating extrema
or zero crossings more accurate (... <em>if</em> the interpolation works well ...)
</p>
</li>
<li><p> making irregular functional data into (more) regular data.
</p>
</li></ul>

<p>For <code>tfd</code>-objects, this is just syntactic sugar for <code>tfd(object, arg = arg)</code>.
To inter/extrapolate more reliably and avoid <code>NA</code>s, call
<code>tf_interpolate</code> with <code>evaluator = tf_approx_fill_extend</code>.<br />
For <code>tfb</code>-objects, this re-evaluates basis functions on the new grid which can
speed up subsequent computations if they all use that grid.
NB: <strong>To reliably impute very irregular data on a regular, common grid,
you'll be better off doing FPCA-based imputation or other model-based
approaches in most cases.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_interpolate(object, arg, ...)

## S3 method for class 'tfb'
tf_interpolate(object, arg, ...)

## S3 method for class 'tfd'
tf_interpolate(object, arg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_interpolate_+3A_object">object</code></td>
<td>
<p>an object inheriting from <code>tf</code></p>
</td></tr>
<tr><td><code id="tf_interpolate_+3A_arg">arg</code></td>
<td>
<p>a vector of argument values on which to evaluate the functions in
<code>object</code></p>
</td></tr>
<tr><td><code id="tf_interpolate_+3A_...">...</code></td>
<td>
<p>additional arguments handed over to <code>tfd</code> or <code>tfb</code>, for the
construction of the returned object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tfd</code> or <code>tfb</code> object on the new grid given by <code>arg</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf_rebase">tf_rebase()</a></code>, which is more general.
</p>
<p>Other tidyfun inter/extrapolation functions: 
<code><a href="#topic+tf_approx_linear">tf_approx_linear</a>()</code>,
<code><a href="#topic+tf_evaluate">tf_evaluate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# thinning out a densely observed tfd
dense &lt;- tf_rgp(10, arg = seq(0, 1, length.out = 1001))
less_dense &lt;- tf_interpolate(dense, arg = seq(0, 1, length.out = 101))
dense
less_dense
# filling out sparse data (use a suitable evaluator-function!)
sparse &lt;- tf_rgp(10, arg = seq(0, 5, length.out = 11))
plot(sparse, points = TRUE)
# change evaluator for better interpolation
tfd(sparse, evaluator = tf_approx_spline) |&gt;
  tf_interpolate(arg = seq(0, 5, length.out = 201)) |&gt;
  lines(col = 2, lty = 2)

set.seed(1860)
sparse_irregular &lt;- tf_rgp(5) |&gt;
  tf_sparsify(0.5) |&gt;
  tf_jiggle()
tf_interpolate(sparse_irregular, arg = seq(0, 1, length.out = 51))

</code></pre>

<hr>
<h2 id='tf_jiggle'>Make a <code>tf</code> (more) irregular</h2><span id='topic+tf_jiggle'></span><span id='topic+tf_sparsify'></span>

<h3>Description</h3>

<p>Randomly create some irregular functional data from regular ones.
<strong>jiggle</strong> it by randomly moving around its <code>arg</code>-values. Only for <code>tfd</code>.
<strong>sparsify</strong> it by setting (100*<code>dropout</code>)% of its values to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_jiggle(f, amount = 0.4, ...)

tf_sparsify(f, dropout = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_jiggle_+3A_f">f</code></td>
<td>
<p>a <code>tfd</code> object</p>
</td></tr>
<tr><td><code id="tf_jiggle_+3A_amount">amount</code></td>
<td>
<p>how far away from original grid points can the new grid points
lie, at most (relative to original distance to neighboring grid points).
Defaults to at most 40% (0.4) of the original grid distances. Must be lower
than 0.5</p>
</td></tr>
<tr><td><code id="tf_jiggle_+3A_...">...</code></td>
<td>
<p>additional args for the returned <code>tfd</code> in <code>tf_jiggle</code></p>
</td></tr>
<tr><td><code id="tf_jiggle_+3A_dropout">dropout</code></td>
<td>
<p>how many values of <code>f</code> to drop, defaults to 50%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (irregular) <code>tfd</code> object
</p>


<h3>See Also</h3>

<p>Other tidyfun RNG functions: 
<code><a href="#topic+tf_rgp">tf_rgp</a>()</code>
</p>
<p>Other tidyfun RNG functions: 
<code><a href="#topic+tf_rgp">tf_rgp</a>()</code>
</p>

<hr>
<h2 id='tf_rebase'>Change (basis) representation of a <code>tf</code>-object</h2><span id='topic+tf_rebase'></span><span id='topic+tf_rebase.tfd'></span><span id='topic+tf_rebase.tfb'></span>

<h3>Description</h3>

<p>Apply the representation of one <code>tf</code>-object to another; i.e. re-express it in
the other's basis, on its grid, etc.<br />
Useful for making different functional data objects compatible so they can
be combined, compared or computed with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_rebase(object, basis_from, arg = tf_arg(basis_from), ...)

## S3 method for class 'tfd'
tf_rebase(object, basis_from, arg = tf_arg(basis_from), ...)

## S3 method for class 'tfb'
tf_rebase(object, basis_from, arg = tf_arg(basis_from), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_rebase_+3A_object">object</code></td>
<td>
<p>a <code>tf</code> object whose representation should be changed</p>
</td></tr>
<tr><td><code id="tf_rebase_+3A_basis_from">basis_from</code></td>
<td>
<p>the <code>tf</code> object with the desired basis, <code>arg</code>, <code>evaluator</code>, etc.</p>
</td></tr>
<tr><td><code id="tf_rebase_+3A_arg">arg</code></td>
<td>
<p>optional new <code>arg</code> values, defaults to those of <code>basis_from</code></p>
</td></tr>
<tr><td><code id="tf_rebase_+3A_...">...</code></td>
<td>
<p>forwarded to the <code>tfb</code> or <code>tfd</code> constructors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses double dispatch (S3) internally, so the methods defined below are
themselves generics for methods <code>tf_rebase.tfd.tfd</code>,
<code>tf_rebase.tfd.tfb_spline</code>, <code>tf_rebase.tfd.tfb_fpc</code>, <code>tf_rebase.tfb.tfd</code>,
<code>tf_rebase.tfb.tfb</code> that dispatch on <code>object_from</code>.
</p>


<h3>Value</h3>

<p>a <code>tf</code>-vector containing the data of <code>object</code> in the same representation
as <code>basis_from</code> (potentially modified by the arguments given in <code>...</code>).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tf_rebase(tfd)</code>: re-express a <code>tfd</code>-vector in the same representation as
some other  <code>tf</code>-vector
</p>
</li>
<li> <p><code>tf_rebase(tfb)</code>: re-express a <code>tfb</code>-vector in the same representation as
some other  <code>tf</code>-vector.
</p>
</li></ul>

<hr>
<h2 id='tf_rgp'>Gaussian Process random generator</h2><span id='topic+tf_rgp'></span>

<h3>Description</h3>

<p>Generates <code>n</code> realizations of a zero-mean Gaussian process. The function also
accepts user-defined covariance functions (without &quot;nugget&quot; effect, see
<code>cov</code>), The implemented defaults with <code>scale</code> parameter <code class="reqn">\phi</code>, <code>order</code>
<code class="reqn">o</code> and <code>nugget</code> effect variance <code class="reqn">\sigma^2</code> are:
</p>

<ul>
<li> <p><em>squared exponential</em> covariance <code class="reqn">Cov(x(t), x(t')) = \exp(-(t-t')^2)/\phi) + \sigma^2
\delta_{t}(t')</code>.
</p>
</li>
<li> <p><em>Wiener</em> process covariance <code class="reqn">Cov(x(t), x(t')) =
\min(t',t)/\phi + \sigma^2 \delta_{t}(t')</code>,
</p>
</li>
<li> <p><a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function#Definition"><em>MatÃ¨rn</em> process</a>
covariance <code class="reqn">Cov(x(t), x(t')) =
\tfrac{2^{1-o}}{\Gamma(o)} (\tfrac{\sqrt{2o}|t-t'|}{\phi})^o \text{Bessel}_o(\tfrac{\sqrt{2o}|t-t'|}{s})
+ \sigma^2 \delta_{t}(t')</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tf_rgp(
  n,
  arg = 51L,
  cov = c("squareexp", "wiener", "matern"),
  scale = diff(range(arg))/10,
  nugget = scale/200,
  order = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_rgp_+3A_n">n</code></td>
<td>
<p>how many realizations to draw</p>
</td></tr>
<tr><td><code id="tf_rgp_+3A_arg">arg</code></td>
<td>
<p>vector of evaluation points (<code>arg</code> of the return object). Defaults
to (0, 0.02, 0.04, ..., 1). If given as a single <strong>integer</strong> (don't forget
the <strong><code>L</code></strong>...), creates a  regular grid of that length over (0,1).</p>
</td></tr>
<tr><td><code id="tf_rgp_+3A_cov">cov</code></td>
<td>
<p>type of covariance function to use. Implemented defaults are
<code>"squareexp"</code>, <code>"wiener"</code>, <code>"matern"</code>, see Description. Can also be any
vectorized function returning <code class="reqn">Cov(x(t), x(t'))</code> <em>without nugget
effect</em> for pairs of inputs t and t'.</p>
</td></tr>
<tr><td><code id="tf_rgp_+3A_scale">scale</code></td>
<td>
<p>scale parameter (see Description). Defaults to the width of the
domain divided by 10.</p>
</td></tr>
<tr><td><code id="tf_rgp_+3A_nugget">nugget</code></td>
<td>
<p>nugget effect for additional white noise / unstructured
variability. Defaults to <code>scale/200</code> (so: very little white noise).</p>
</td></tr>
<tr><td><code id="tf_rgp_+3A_order">order</code></td>
<td>
<p>order of the MatÃ¨rn covariance (if used, must be &gt;0), defaults
to 1.5. The higher, the smoother the process. Evaluation of the covariance
function becomes numerically unstable for large (&gt;20) <code>order</code>, use
&quot;squareexp&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>tfd</code>-vector of length <code>n</code>
</p>


<h3>See Also</h3>

<p>Other tidyfun RNG functions: 
<code><a href="#topic+tf_jiggle">tf_jiggle</a>()</code>
</p>

<hr>
<h2 id='tf_smooth'>Simple smoothing of <code>tf</code> objects</h2><span id='topic+tf_smooth'></span><span id='topic+tf_smooth.tfb'></span><span id='topic+tf_smooth.tfd'></span>

<h3>Description</h3>

<p>Apply running means or medians, <code>lowess</code> or Savitzky-Golay
filtering to smooth functional data. This does nothing for <code>tfb</code>-objects,
which should be smoothed by using a smaller basis / stronger penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_smooth(x, ...)

## S3 method for class 'tfb'
tf_smooth(x, verbose = TRUE, ...)

## S3 method for class 'tfd'
tf_smooth(
  x,
  method = c("lowess", "rollmean", "rollmedian", "savgol"),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_smooth_+3A_x">x</code></td>
<td>
<p>a <code>tf</code> object containing functional data</p>
</td></tr>
<tr><td><code id="tf_smooth_+3A_...">...</code></td>
<td>
<p>arguments for the respective <code>method</code>. See Details.</p>
</td></tr>
<tr><td><code id="tf_smooth_+3A_verbose">verbose</code></td>
<td>
<p>give lots of diagnostic messages? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="tf_smooth_+3A_method">method</code></td>
<td>
<p>one of &quot;lowess&quot; (see <code><a href="stats.html#topic+lowess">stats::lowess()</a></code>), &quot;rollmean&quot;,
&quot;rollmedian&quot; (see <code><a href="zoo.html#topic+rollmean">zoo::rollmean()</a></code>) or &quot;savgol&quot; (see <code><a href="pracma.html#topic+savgol">pracma::savgol()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tf_smooth.tfd</code> overrides/automatically sets some defaults of the
used methods:
</p>

<ul>
<li> <p><strong><code>lowess</code></strong> uses a span parameter of <code>f</code> = 0.15 (instead of 0.75)
by default.
</p>
</li>
<li> <p><strong><code>rollmean</code>/<code>median</code></strong> use a window size of <code>k</code> = $&lt;$number of
grid points$&gt;$/20 (i.e., the nearest odd integer to that) and sets <code>fill=   "extend"</code> (i.e., constant extrapolation to replace missing values at the
extremes of the domain) by default. Use <code>fill= NA</code> for <code>zoo</code>'s default
behavior of shortening the smoothed series.
</p>
</li>
<li> <p><strong><code>savgol</code></strong> uses a window size of <code>k</code> = $&lt;$number of
grid points$&gt;$/10 (i.e., the nearest odd integer to that).
</p>
</li></ul>



<h3>Value</h3>

<p>a smoothed version of the input. For some methods/options, the
smoothed functions may be shorter than the original ones (at both ends).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(zoo)
library(pracma)
f &lt;- tf_sparsify(tf_jiggle(tf_rgp(4, 201, nugget = 0.05)))
f_lowess &lt;- tf_smooth(f, "lowess")
# these methods ignore the distances between arg-values:
f_mean &lt;- tf_smooth(f, "rollmean")
f_median &lt;- tf_smooth(f, "rollmean", k = 31)
f_sg &lt;- tf_smooth(f, "savgol", fl = 31)
layout(t(1:4))
plot(f, points = FALSE, main = "original")
plot(f_lowess,
  points = FALSE, col = "blue", main = "lowess (default,\n span 0.9 in red)"
)
lines(tf_smooth(f, "lowess", f = 0.9), col = "red", alpha = 0.2)
plot(f_mean,
  points = FALSE, col = "blue", main = "rolling means &amp;\n medians (red)"
)
lines(f_median, col = "red", alpha = 0.2) # note constant extrapolation at both ends!
plot(f, points = FALSE, main = "orginal and\n savgol (red)")
lines(f_sg, col = "red")
</code></pre>

<hr>
<h2 id='tf_where'>Find out where functional data fulfills certain conditions.</h2><span id='topic+tf_where'></span><span id='topic+tf_anywhere'></span>

<h3>Description</h3>

<p><code>tf_where</code> allows to define a logical expression about the function values
and returns the argument values for which that condition is true.<br />
<code>tf_anywhere</code> is syntactic sugar for <code>tf_where</code> with <code>return = "any"</code> to
get a logical flag for each function if the condition is <code>TRUE</code> <em>anywhere</em>,
see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_where(f, cond, return = c("all", "first", "last", "range", "any"), arg)

tf_anywhere(f, cond, arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_where_+3A_f">f</code></td>
<td>
<p>a <code>tf</code> object</p>
</td></tr>
<tr><td><code id="tf_where_+3A_cond">cond</code></td>
<td>
<p>a logical expression about <code>value</code> (and/or <code>arg</code>) that defines a
condition about the functions, see examples and details.</p>
</td></tr>
<tr><td><code id="tf_where_+3A_return">return</code></td>
<td>
<p>for each entry in <code>f</code>, <code>tf_where</code> either returns <em>all</em> <code>arg</code>
for which <code>cond</code> is true, the <em>first</em>, the <em>last</em> or their <em>range</em> or
logical flags whether the functions fullfill the condition <em>any</em>where. For
<code>"range"</code>, note that <code>cond</code> may not be true for all <code>arg</code> values in this
range, though, this is not checked.</p>
</td></tr>
<tr><td><code id="tf_where_+3A_arg">arg</code></td>
<td>
<p>optional <code>arg</code>-values on which to evaluate <code>f</code> and check <code>cond</code>,
defaults to <code>tf_arg(f)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entries in <code>f</code> that do not fulfill <code>cond</code> anywhere yield <code>numeric(0)</code>.<br />
<code>cond</code>  is evaluated as a <code><a href="base.html#topic+subset">base::subset()</a></code>-statement on a <code>data.frame</code>
containing a single entry in <code>f</code> with columns <code>arg</code> and <code>value</code>, so most
of the usual <code>dplyr</code> tricks are available as well, see examples.<br />
Any <code>cond</code>ition evaluates to <code>NA</code> on <code>NA</code>-entries in <code>f</code>.
</p>


<h3>Value</h3>

<p>depends on  <code>return</code>:
</p>

<ul>
<li> <p><code>return = "any"</code>, i.e, <code>anywhere</code>:
a logical vector of the same length as <code>f</code>.
</p>
</li>
<li> <p><code>return = "all"</code>: a list of vectors of the same length as <code>f</code>, with
empty vectors for the functions that  never fulfill the <code>cond</code>ition.
</p>
</li>
<li> <p><code>return = "range"</code>: a data frame with columns &quot;begin&quot; and &quot;end&quot;.
</p>
</li>
<li><p> else, a numeric vector of the same length as <code>f</code> with <code>NA</code> for entries of
<code>f</code> that nowhere fulfill the <code>cond</code>ition.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>lin &lt;- 1:4 * tfd(seq(-1, 1, length.out = 11), seq(-1, 1, length.out = 11))
tf_where(lin, value %inr% c(-1, 0.5))
tf_where(lin, value %inr% c(-1, 0.5), "range")
a &lt;- 1
tf_where(lin, value &gt; a, "first")
tf_where(lin, value &lt; a, "last")
tf_where(lin, value &gt; 2, "any")
tf_anywhere(lin, value &gt; 2)

set.seed(4353)
f &lt;- tf_rgp(5, 11)
plot(f, pch = as.character(1:5), points = TRUE)
tf_where(f, value == max(value))
# where is the function increasing/decreasing?
tf_where(f, value &gt; dplyr::lag(value, 1, value[1]))
tf_where(f, value &lt; dplyr::lead(value, 1, tail(value, 1)))
# where are the (interior) extreme points (sign changes of `diff(value)`)?
tf_where(
  f,
  sign(c(diff(value)[1], diff(value))) !=
    sign(c(diff(value), tail(diff(value), 1)))
)
# where in its second half is the function positive?
tf_where(f, arg &gt; 0.5 &amp; value &gt; 0)
# does the function ever exceed?
tf_anywhere(f, value &gt; 1)
</code></pre>

<hr>
<h2 id='tf_zoom'>Functions to zoom in/out on functions</h2><span id='topic+tf_zoom'></span><span id='topic+tf_zoom.tfd'></span><span id='topic+tf_zoom.tfb'></span><span id='topic+tf_zoom.tfb_fpc'></span>

<h3>Description</h3>

<p>These are used to redefine or restrict the <code>domain</code> of <code>tf</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf_zoom(f, begin, end, ...)

## S3 method for class 'tfd'
tf_zoom(f, begin = tf_domain(f)[1], end = tf_domain(f)[2], ...)

## S3 method for class 'tfb'
tf_zoom(f, begin = tf_domain(f)[1], end = tf_domain(f)[2], ...)

## S3 method for class 'tfb_fpc'
tf_zoom(f, begin = tf_domain(f)[1], end = tf_domain(f)[2], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tf_zoom_+3A_f">f</code></td>
<td>
<p>a <code>tf</code>-object</p>
</td></tr>
<tr><td><code id="tf_zoom_+3A_begin">begin</code></td>
<td>
<p>numeric vector of length 1 or <code>length(f)</code>.
Defaults to the lower limit of the domain of <code>f</code>.</p>
</td></tr>
<tr><td><code id="tf_zoom_+3A_end">end</code></td>
<td>
<p>numeric vector of length 1 or <code>length(f)</code>.
Defaults to the upper limit of the domain of <code>f</code>.</p>
</td></tr>
<tr><td><code id="tf_zoom_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object like <code>f</code> on a new domain (potentially).
Note that regular functional data and functions in basis representation will
be turned into irregular <code>tfd</code>-objects iff <code>begin</code> or <code>end</code> are not scalar.
</p>


<h3>See Also</h3>

<p>Other tidyfun utility functions: 
<code><a href="#topic+in_range">in_range</a>()</code>,
<code><a href="#topic+tf_arg">tf_arg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tf_rgp(10)
plot(x)
tf_zoom(x, 0.5, 0.9)
tf_zoom(x, 0.5, 0.9) |&gt; lines(col = "red")
tf_zoom(x, seq(0, 0.5, length.out = 10), seq(0.5, 1, length.out = 10)) |&gt;
  lines(col = "blue", lty = 3)
</code></pre>

<hr>
<h2 id='tf-package'>tf: S3 Classes and Methods for Tidy Functional Data</h2><span id='topic+tf'></span><span id='topic+tf-package'></span>

<h3>Description</h3>

<p><code>tf</code> is a light-weight package with few dependencies that
provides the class definitions and methods infrastructure for <code>tidyfun</code> &ndash;
<code>tf</code> gives you:
</p>

<ul>
<li><p> new S3 data types for representing (vectors of) functional data:
<code><a href="#topic+tfd">tfd()</a></code> &amp; <code><a href="#topic+tfb">tfb()</a></code>
</p>
</li>
<li><p> arithmetic operators for such data (<code><a href="#topic+Ops.tf">Ops.tf()</a></code>),
</p>
</li>
<li><p> simple descriptive statistics: e.g. <code><a href="#topic+mean.tf">mean.tf()</a></code>, <code><a href="#topic+median.tf">median.tf()</a></code>
</p>
</li>
<li><p> base graphics functions for such data: <code><a href="#topic+plot.tf">plot.tf()</a></code>
</p>
</li>
<li><p> functions to do smoothing (<code><a href="#topic+tf_smooth.tfd">tf_smooth.tfd()</a></code>),
differentiation <code><a href="#topic+tf_derive.tfd">tf_derive.tfd()</a></code>) and integration (<code><a href="#topic+tf_derive.tfd">tf_derive.tfd()</a></code>)
</p>
</li></ul>

<p>The goal of the add-on package <code>tidyfun</code> is to make data wrangling and
exploratory analysis for functional data in <code>R</code> quick and easy, using
<code>tidyverse</code> syntax and standards. <br /><br />
Please also install <code>tidyfun</code> for the full functionality to
access the full documentation including a number of vignettes and case
studies, or visit the <a href="https://tidyfun.github.io/tidyfun/"><code>tidyfun</code> website</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Fabian Scheipl <a href="mailto:fabian.scheipl@googlemail.com">fabian.scheipl@googlemail.com</a> (<a href="https://orcid.org/0000-0001-8172-3603">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jeff Goldsmith
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Julia Wrobel (<a href="https://orcid.org/0000-0001-6783-1421">ORCID</a>) [contributor]
</p>
</li>
<li><p> Maximilian Muecke (<a href="https://orcid.org/0009-0000-9432-9795">ORCID</a>) [contributor]
</p>
</li>
<li><p> Sebastian Fischer (<a href="https://orcid.org/0000-0002-9609-3197">ORCID</a>) [contributor]
</p>
</li>
<li><p> Trevor Hastie (softImpute author) [contributor]
</p>
</li>
<li><p> Rahul Mazumder (softImpute author) [contributor]
</p>
</li>
<li><p> Chen Meng (mogsa author) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tidyfun.github.io/tf/">https://tidyfun.github.io/tf/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyfun/tf/">https://github.com/tidyfun/tf/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyfun/tf/issues">https://github.com/tidyfun/tf/issues</a>
</p>
</li></ul>


<hr>
<h2 id='tfb'>Constructors for functional data in basis representation</h2><span id='topic+tfb'></span><span id='topic+tfb_wavelet'></span><span id='topic+as.tfb'></span>

<h3>Description</h3>

<p>Various constructors for <code>tfb</code>-vectors from different kinds of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfb(data = data.frame(), basis = c("spline", "fpc", "wavelet"), ...)

tfb_wavelet(data, ...)

as.tfb(data, basis = c("spline", "fpc"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfb_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code>, <code>data.frame</code> or <code>list</code> of suitable shape, or another
<code>tf</code>-object containing functional data.</p>
</td></tr>
<tr><td><code id="tfb_+3A_basis">basis</code></td>
<td>
<p>either &quot;<code>spline</code>&quot; (see <code><a href="#topic+tfb_spline">tfb_spline()</a></code>, the default) or &quot;<code>fpc</code>&quot;
(see <code><a href="#topic+tfb_fpc">tfb_fpc()</a></code>).
(<code>wavelet</code> not implemented yet)</p>
</td></tr>
<tr><td><code id="tfb_+3A_...">...</code></td>
<td>
<p>further arguments for <code><a href="#topic+tfb_spline">tfb_spline()</a></code> or <code><a href="#topic+tfb_fpc">tfb_fpc()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfb</code> is a wrapper for functions that set up spline-, principal component- or
wavelet-based representations of functional data. For all three, the input
data <code class="reqn">x_i(t)</code> are represented as weighted sums of a set of common basis
functions <code class="reqn">B_k(t); k = 1,\dots, K</code> identical for all observations and
weight or coefficient vectors <code class="reqn">b_i = (b_{i1}, \dots, b_{iK})</code> estimated
for each observation: <code class="reqn">x_i(t) \approx \sum_k B_k(t) b_{ik}</code>. Depending on
the value of <code>basis</code>, the basis functions <code class="reqn">B(t)</code> will either be <code>spline</code>
functions or the first few estimated eigenfunctions of the covariance
operator of the <code class="reqn">x(t)</code> (<code>fpc</code>) or wavelets (<code>wavelet</code>).
</p>
<p>See <strong><code><a href="#topic+tfb_spline">tfb_spline()</a></code></strong> for more details on spline basis representation (the
default). See <strong><code><a href="#topic+tfb_fpc">tfb_fpc()</a></code></strong> for using an functional principal component
representation with an orthonormal basis estimated from the data instead.
</p>


<h3>Value</h3>

<p>a <code>tfb</code>-object (or a <code>data.frame</code>/<code>matrix</code> for the conversion
functions, obviously.)
</p>


<h3>See Also</h3>

<p>Other tfb-class: 
<code><a href="#topic+fpc_wsvd">fpc_wsvd</a>()</code>,
<code><a href="#topic+tfb_fpc">tfb_fpc</a>()</code>,
<code><a href="#topic+tfb_spline">tfb_spline</a>()</code>
</p>
<p>Other tfb-class: 
<code><a href="#topic+fpc_wsvd">fpc_wsvd</a>()</code>,
<code><a href="#topic+tfb_fpc">tfb_fpc</a>()</code>,
<code><a href="#topic+tfb_spline">tfb_spline</a>()</code>
</p>

<hr>
<h2 id='tfb_fpc'>Functional data in FPC-basis representation</h2><span id='topic+tfb_fpc'></span><span id='topic+tfb_fpc.data.frame'></span><span id='topic+tfb_fpc.matrix'></span><span id='topic+tfb_fpc.numeric'></span><span id='topic+tfb_fpc.tf'></span><span id='topic+tfb_fpc.default'></span>

<h3>Description</h3>

<p>These functions perform a (functional) principal component analysis (FPCA) of
the input data and return an <code>tfb_fpc</code> <code>tf</code>-object that uses the empirical
eigenfunctions as basis functions for representing the data. The default
(&quot;<code>method = fpc_wsvd</code>&quot;) uses a (truncated) weighted SVD for complete
data on a common grid and a nuclear-norm regularized (truncated) weighted SVD
for partially missing data on a common grid, see <code><a href="#topic+fpc_wsvd">fpc_wsvd()</a></code>.
The latter is likely to break down for high PVE and/or high amounts of
missingness.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfb_fpc(data, ...)

## S3 method for class 'data.frame'
tfb_fpc(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  method = fpc_wsvd,
  ...
)

## S3 method for class 'matrix'
tfb_fpc(data, arg = NULL, domain = NULL, method = fpc_wsvd, ...)

## S3 method for class 'numeric'
tfb_fpc(data, arg = NULL, domain = NULL, method = fpc_wsvd, ...)

## S3 method for class 'tf'
tfb_fpc(data, arg = NULL, method = fpc_wsvd, ...)

## Default S3 method:
tfb_fpc(data, arg = NULL, domain = NULL, method = fpc_wsvd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfb_fpc_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code>, <code>data.frame</code> or <code>list</code> of suitable shape, or another
<code>tf</code>-object containing functional data.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_...">...</code></td>
<td>
<p>arguments to the <code>method</code> which computes the
(regularized/smoothed) FPCA - see e.g. <code><a href="#topic+fpc_wsvd">fpc_wsvd()</a></code>.
Unless set by the user, uses proportion of variance explained
<code>pve = 0.995</code> to determine the truncation levels.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_id">id</code></td>
<td>
<p>The name or number of the column defining which data belong to
which function.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_arg">arg</code></td>
<td>
<p><code>numeric</code>, or list of <code>numeric</code>s. The evaluation grid.
For the <code>data.frame</code>-method: the
name/number of the column defining the evaluation grid. The <code>matrix</code> method
will try to guess suitable <code>arg</code>-values from the column names of <code>data</code> if
<code>arg</code> is not supplied. Other methods fall back on integer sequences
(<code style="white-space: pre;">&#8288;1:&lt;length of data&gt;&#8288;</code>) as the default if not provided.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_value">value</code></td>
<td>
<p>The name or number of the column containing the function
evaluations.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_domain">domain</code></td>
<td>
<p>range of the <code>arg</code>.</p>
</td></tr>
<tr><td><code id="tfb_fpc_+3A_method">method</code></td>
<td>
<p>the function to use that computes eigenfunctions and scores.
Defaults to <code><a href="#topic+fpc_wsvd">fpc_wsvd()</a></code>, which is quick and easy but returns completely
unsmoothed eigenfunctions unlikely to be suited for noisy data. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the FPC basis, any factorization method that accepts a <code>data.frame</code> with
columns <code>id</code>, <code>arg</code>, <code>value</code> containing the functional data and returns a
list with eigenfunctions and FPC scores structured like the return object
of <code><a href="#topic+fpc_wsvd">fpc_wsvd()</a></code> can be used for the 'method&ldquo; argument, see example below.
Note that the mean function, with a fixed &quot;score&quot; of 1 for all functions,
is used as the first basis function for all FPC bases.
</p>


<h3>Value</h3>

<p>an object of class <code>tfb_fpc</code>, inheriting from <code>tfb</code>.
The basis used by <code>tfb_fpc</code> is a <code>tfd</code>-vector containing the estimated
mean and eigenfunctions.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tfb_fpc(default)</code>: convert <code>tfb</code>: default method, returning prototype when
data is NULL
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fpc_wsvd">fpc_wsvd()</a></code> for FPCA options.
</p>
<p>Other tfb-class: 
<code><a href="#topic+fpc_wsvd">fpc_wsvd</a>()</code>,
<code><a href="#topic+tfb">tfb</a></code>,
<code><a href="#topic+tfb_spline">tfb_spline</a>()</code>
</p>
<p>Other tfb_fpc-class: 
<code><a href="#topic+fpc_wsvd">fpc_wsvd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13121)
x &lt;- tf_rgp(25, nugget = .02)
x_pc &lt;- tfb_fpc(x, pve = .9)
x_pc
plot(x, lwd = 3)
lines(x_pc, col = 2, lty = 2)
x_pc_full &lt;- tfb_fpc(x, pve = .995)
x_pc_full
lines(x_pc_full, col = 3, lty = 2)
# partially missing data on common grid:
x_mis &lt;- x |&gt; tf_sparsify(dropout = .05)
x_pc_mis &lt;- tfb_fpc(x_mis, pve = .9)
x_pc_mis
plot(x_mis, lwd = 3)
lines(x_pc_mis, col = 4, lty = 2)
# extract FPC basis --
# first "eigenvector" in black is (always) the mean function
x_pc |&gt; tf_basis(as_tfd = TRUE) |&gt; plot(col = 1:5)

# Apply FPCA for sparse, irregular data using refund::fpca.sc:
set.seed(99290)
# create small, sparse, irregular data:
x_irreg &lt;- x[1:8] |&gt;
  tf_jiggle() |&gt; tf_sparsify(dropout = 0.3)
plot(x_irreg)
x_df &lt;- x_irreg |&gt;
  as.data.frame(unnest = TRUE)
# wrap refund::fpca_sc for use as FPCA method in tfb_fpc --
# 1. define scoring function (simple weighted LS fit)
fpca_scores &lt;- function(data_matrix, efunctions, mean, weights) {
  w_mat &lt;- matrix(weights, ncol = length(weights), nrow = nrow(data_matrix),
                  byrow = TRUE)
  w_mat[is.na(data_matrix)] &lt;- 0
  data_matrix[is.na(data_matrix)] &lt;- 0
  data_wc &lt;- t((t(data_matrix) - mean) * sqrt(t(w_mat)))
  t(qr.coef(qr(efunctions), t(data_wc) / sqrt(weights)))
}
# 2. define wrapper for fpca_sc:
fpca_sc_wrapper &lt;- function(data, arg, pve = 0.995, ...) {
  data_mat &lt;- tfd(data) |&gt; as.matrix(interpolate = TRUE)
  fpca &lt;- refund::fpca.sc(
    Y = data_mat, argvals = attr(data_mat, "arg"), pve = pve, ...
  )
  c(fpca[c("mu", "efunctions", "scores", "npc")],
    scoring_function = fpca_scores)
}
x_pc &lt;- tfb_fpc(x_df, method = fpca_sc_wrapper)
lines(x_pc, col = 2, lty = 2)

</code></pre>

<hr>
<h2 id='tfb_spline'>Spline-based representation of functional data</h2><span id='topic+tfb_spline'></span><span id='topic+tfb_spline.data.frame'></span><span id='topic+tfb_spline.matrix'></span><span id='topic+tfb_spline.numeric'></span><span id='topic+tfb_spline.list'></span><span id='topic+tfb_spline.tfd'></span><span id='topic+tfb_spline.tfb'></span><span id='topic+tfb_spline.default'></span>

<h3>Description</h3>

<p>Represent curves as a weighted sum of spline basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfb_spline(data, ...)

## S3 method for class 'data.frame'
tfb_spline(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'matrix'
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'numeric'
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'list'
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'tfd'
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'tfb'
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)

## Default S3 method:
tfb_spline(
  data,
  arg = NULL,
  domain = NULL,
  penalized = TRUE,
  global = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfb_spline_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code>, <code>data.frame</code> or <code>list</code> of suitable shape, or another
<code>tf</code>-object containing functional data.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_...">...</code></td>
<td>
<p>arguments to the calls to <code><a href="mgcv.html#topic+s">mgcv::s()</a></code> setting up the basis (and
to <code><a href="mgcv.html#topic+magic">mgcv::magic()</a></code> or <code><a href="mgcv.html#topic+gam.fit">mgcv::gam.fit()</a></code> if <code>penalized = TRUE</code>). Uses <code>k = 25</code> cubic regression spline basis functions (<code>bs = "cr"</code>) by default, but
should be set appropriately by the user. See Details and examples in the
vignettes.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_id">id</code></td>
<td>
<p>The name or number of the column defining which data belong to
which function.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_arg">arg</code></td>
<td>
<p><code>numeric</code>, or list of <code>numeric</code>s. The evaluation grid.
For the <code>data.frame</code>-method: the
name/number of the column defining the evaluation grid. The <code>matrix</code> method
will try to guess suitable <code>arg</code>-values from the column names of <code>data</code> if
<code>arg</code> is not supplied. Other methods fall back on integer sequences
(<code style="white-space: pre;">&#8288;1:&lt;length of data&gt;&#8288;</code>) as the default if not provided.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_value">value</code></td>
<td>
<p>The name or number of the column containing the function
evaluations.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_domain">domain</code></td>
<td>
<p>range of the <code>arg</code>.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_penalized">penalized</code></td>
<td>
<p><code>TRUE</code> (default) estimates regularized/penalized basis
coefficients via <code><a href="mgcv.html#topic+magic">mgcv::magic()</a></code> or <code><a href="mgcv.html#topic+gam.fit">mgcv::gam.fit()</a></code>, <code>FALSE</code> yields
ordinary least squares / ML estimates for basis coefficients. <code>FALSE</code> is
much faster but will overfit for noisy data if <code>k</code> is (too) large.</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_global">global</code></td>
<td>
<p>Defaults to <code>FALSE</code>. If <code>TRUE</code> and <code>penalized = TRUE</code>, all
functions share the same smoothing parameter (see Details).</p>
</td></tr>
<tr><td><code id="tfb_spline_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> (default) outputs statistics about the fit achieved by
the basis and other diagnostic messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basis to be used is set up via a call to <code><a href="mgcv.html#topic+s">mgcv::s()</a></code> and all the spline
bases discussed in <code><a href="mgcv.html#topic+smooth.terms">mgcv::smooth.terms()</a></code> are available, in principle.
Depending on the value of the <code>penalized</code>- and <code>global</code>-flags, the
coefficient vectors for each observation are then estimated via fitting a GAM
(separately for each observation, if <code>!global</code>) via <code><a href="mgcv.html#topic+magic">mgcv::magic()</a></code> (least
square error, the default) or <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> (if a <code>family</code> argument was
supplied) or unpenalized least squares / maximum likelihood.
</p>
<p>After the &quot;smoothed&quot; representation is computed, the amount of smoothing that
was performed is reported in terms of the &quot;percentage of variability
preserved&quot;, which is the variance (or the explained deviance, in the general
case if <code>family</code> was specified) of the smoothed function values divided by the variance of the original
values (the null deviance, in the general case). Reporting can be switched off
with <code>verbose = FALSE</code>.
</p>
<p>The <code>...</code> arguments supplies arguments to both the
spline basis (via <code><a href="mgcv.html#topic+s">mgcv::s()</a></code>) and the estimation (via
<code><a href="mgcv.html#topic+magic">mgcv::magic()</a></code> or <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>), the most important arguments are:
</p>

<ul>
<li> <p><strong><code>k</code></strong>: how many basis functions should the spline basis use, default is 25.
</p>
</li>
<li> <p><strong><code>bs</code></strong>: which type of spline basis should be used, the default is cubic
regression splines (<code>bs = "cr"</code>)
</p>
</li>
<li> <p><strong><code>family</code></strong> argument: use this if minimizing squared errors is not
a reasonable criterion for the representation accuracy (see
<code><a href="mgcv.html#topic+family.mgcv">mgcv::family.mgcv()</a></code> for what's available) and/or if function values are
restricted to be e.g. positive (<code>family = Gamma()/tw()/...</code>), in
<code class="reqn">[0,1]</code>  (<code>family = betar()</code>), etc.
</p>
</li>
<li> <p><strong><code>sp</code></strong>: numeric value for the smoothness penalty weight, for manually
setting the amount of smoothing for all curves, see <code><a href="mgcv.html#topic+s">mgcv::s()</a></code>. This
(drastically) reduces computation time. Defaults to <code>-1</code>, i.e., automatic
optimization of <code>sp</code> using <code><a href="mgcv.html#topic+magic">mgcv::magic()</a></code> (LS fits) or <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> (GLM),
source code in <code>R/tfb-spline-utils.R</code>.
</p>
</li></ul>

<p>If <strong><code>global == TRUE</code></strong>, this uses a small subset of curves (10<code style="white-space: pre;">&#8288;%&#8288;</code> of curves,
at least 5, at most 100; non-random sample using every j-th curve in the
data) on which smoothing parameters per curve are estimated and then takes
the mean of the log smoothing parameter of those as <code>sp</code> for all curves. This
is much faster than optimizing for each curve on large data sets. For very
sparse or noisy curves, estimating a common smoothing parameter based on the
data for all curves simultaneously is likely to yield better results, this is
<em>not</em> what's implemented here.
</p>


<h3>Value</h3>

<p>a <code>tfb</code>-object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tfb_spline(data.frame)</code>: convert data frames
</p>
</li>
<li> <p><code>tfb_spline(matrix)</code>: convert matrices
</p>
</li>
<li> <p><code>tfb_spline(numeric)</code>: convert matrices
</p>
</li>
<li> <p><code>tfb_spline(list)</code>: convert lists
</p>
</li>
<li> <p><code>tfb_spline(tfd)</code>: convert <code>tfd</code> (raw functional data)
</p>
</li>
<li> <p><code>tfb_spline(tfb)</code>: convert <code>tfb</code>: modify basis representation, smoothing.
</p>
</li>
<li> <p><code>tfb_spline(default)</code>: convert <code>tfb</code>: default method, returning prototype
when data is missing
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.terms">mgcv::smooth.terms()</a></code> for spline basis options.
</p>
<p>Other tfb-class: 
<code><a href="#topic+fpc_wsvd">fpc_wsvd</a>()</code>,
<code><a href="#topic+tfb">tfb</a></code>,
<code><a href="#topic+tfb_fpc">tfb_fpc</a>()</code>
</p>

<hr>
<h2 id='tfbrackets'>Accessing, evaluating, subsetting and subassigning <code>tf</code> vectors</h2><span id='topic+tfbrackets'></span><span id='topic++5B.tf'></span><span id='topic++5B+3C-.tf'></span>

<h3>Description</h3>

<p>These functions access, subset, replace and evaluate <code>tf</code> objects.
For more information on creating <code>tf</code> objects and converting them to/from
<code>list</code>, <code>data.frame</code> or <code>matrix</code>, see <code><a href="#topic+tfd">tfd()</a></code> and <code><a href="#topic+tfb">tfb()</a></code>. See Details.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
x[i, j, interpolate = TRUE, matrix = TRUE]

## S3 replacement method for class 'tf'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfbrackets_+3A_x">x</code></td>
<td>
<p>an <code>tf</code></p>
</td></tr>
<tr><td><code id="tfbrackets_+3A_i">i</code></td>
<td>
<p>index of the observations (<code>integer</code>ish, <code>character</code> or <code>logical</code>,
usual R rules apply)</p>
</td></tr>
<tr><td><code id="tfbrackets_+3A_j">j</code></td>
<td>
<p>The <code>arg</code> used to evaluate the functions. A (list of) <code>numeric</code>
vectors. <em>NOT</em> interpreted as a column number but as the argument value of
the respective functional datum.</p>
</td></tr>
<tr><td><code id="tfbrackets_+3A_interpolate">interpolate</code></td>
<td>
<p>should functions be evaluated (i.e., inter-/extrapolated)
for values in <code>arg</code> for which no original data is available? Only relevant for
the raw data class <code>tfd</code>, for which it defaults to <code>TRUE</code>. Basis-represented
<code>tfb</code> are always &quot;interpolated&quot;.</p>
</td></tr>
<tr><td><code id="tfbrackets_+3A_matrix">matrix</code></td>
<td>
<p>should the result be returned as a <code>matrix</code> or as a list of
<code>data.frame</code>s? If <code>TRUE</code>, <code>j</code> has to be a (list of a) single vector of
<code>arg</code>. See return value.</p>
</td></tr>
<tr><td><code id="tfbrackets_+3A_value">value</code></td>
<td>
<p><code>tf</code> object for subassignment. This is typed more strictly
than concatenation:  subassignment only happens if the common type of
<code>value</code> and <code>x</code> is the same as the type of <code>x</code>,
so subassignment never changes the type of <code>x</code> but may do a
potentially lossy cast of <code>value</code> to the type of <code>x</code> (with a warning).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these break certain (terrible) R conventions for vector-like objects:<br />
</p>

<ul>
<li><p> no argument recycling,
</p>
</li>
<li><p> no indexing with <code>NA</code>,
</p>
</li>
<li><p> no indexing with names not present in <code>x</code>,
</p>
</li>
<li><p> no indexing with integers <code style="white-space: pre;">&#8288;&gt; length(x)&#8288;</code>
</p>
</li></ul>

<p>All of the above will trigger errors.
</p>


<h3>Value</h3>

<p>If <code>j</code> is missing, a subset of the functions in <code>x</code> as given by
<code>i</code>.<br /> If <code>j</code> is given and <code>matrix == TRUE</code>, a numeric matrix of function
evaluations in which each row represents one function and each column
represents one <code>argval</code> as given in argument <code>j</code>, with an attribute
<code>arg</code>=<code>j</code> and row- and column-names derived from <code>x[i]</code> and <code>j</code>.<br /> If
<code>j</code> is given and <code>matrix == FALSE</code>, a list of <code>tbl_df</code>s with columns
<code>arg</code> = <code>j</code> and <code>value</code> = evaluations at <code>j</code> for each observation in
<code>i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3 * tfd(data = 0:10, arg = 0:10)
plot(x)
# this operator's 2nd argument is quite overloaded -- you can:
# 1. simply extract elements from the vector if no second arg is given:
x[1]
x[c(TRUE, FALSE, FALSE)]
x[-(2:3)]
# 2. use the second argument and optional additional arguments to
#    extract specific function evaluations in a number of formats:
x[1:2, c(4.5, 9)] # returns a matrix of function evaluations
x[1:2, c(4.5, 9), interpolate = FALSE] # NA for arg-values not in the original data
x[-3, seq(1, 9, by = 2), matrix = FALSE] # list of data.frames for each function
# in order to evaluate a set of observed functions on a new grid and
# save them as a functional data vector again, use `tfd` or `tfb` instead:
tfd(x, arg = seq(0, 10, by = 0.01))
</code></pre>

<hr>
<h2 id='tfd'>Constructors for vectors of &quot;raw&quot; functional data</h2><span id='topic+tfd'></span><span id='topic+tfd.matrix'></span><span id='topic+tfd.numeric'></span><span id='topic+tfd.data.frame'></span><span id='topic+tfd.list'></span><span id='topic+tfd.tf'></span><span id='topic+tfd.default'></span><span id='topic+as.tfd'></span><span id='topic+as.tfd_irreg'></span>

<h3>Description</h3>

<p>Various constructor methods for <code>tfd</code>-objects.
</p>
<p><code>tfd.matrix</code> accepts a numeric matrix with one function per
<em>row</em> (!). If <code>arg</code> is not provided, it tries to guess <code>arg</code> from the
column names and falls back on <code>1:ncol(data)</code> if that fails.
</p>
<p><code>tfd.data.frame</code> uses the first 3 columns of <code>data</code> for
function information by default: (<code>id</code>, <code>arg</code>, <code>value</code>)
</p>
<p><code>tfd.list</code> accepts a list of vectors of identical lengths
containing evaluations or a list of 2-column matrices/data.frames with
<code>arg</code> in the first and evaluations in the second column
</p>
<p><code>tfd.default</code> returns class prototype when argument to tfd() is
NULL or not a recognised class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfd(data, ...)

## S3 method for class 'matrix'
tfd(data, arg = NULL, domain = NULL, evaluator = tf_approx_linear, ...)

## S3 method for class 'numeric'
tfd(data, arg = NULL, domain = NULL, evaluator = tf_approx_linear, ...)

## S3 method for class 'data.frame'
tfd(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  evaluator = tf_approx_linear,
  ...
)

## S3 method for class 'list'
tfd(data, arg = NULL, domain = NULL, evaluator = tf_approx_linear, ...)

## S3 method for class 'tf'
tfd(data, arg = NULL, domain = NULL, evaluator = NULL, ...)

## Default S3 method:
tfd(data, arg = NULL, domain = NULL, evaluator = tf_approx_linear, ...)

as.tfd(data, ...)

as.tfd_irreg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfd_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code>, <code>data.frame</code> or <code>list</code> of suitable shape, or another
<code>tf</code>-object. when this argument is <code>NULL</code> (i.e. when calling <code>tfd()</code>) this
returns a prototype of class <code>tfd</code></p>
</td></tr>
<tr><td><code id="tfd_+3A_...">...</code></td>
<td>
<p>not used in <code>tfd</code>, except for <code>tfd.tf</code> &ndash; specify <code>arg</code> and
<code>Ã¬nterpolate = TRUE</code> to turn an irregular <code>tfd</code> into a regular one, see
examples.</p>
</td></tr>
<tr><td><code id="tfd_+3A_arg">arg</code></td>
<td>
<p><code>numeric</code>, or list of <code>numeric</code>s. The evaluation grid.
For the <code>data.frame</code>-method: the
name/number of the column defining the evaluation grid. The <code>matrix</code> method
will try to guess suitable <code>arg</code>-values from the column names of <code>data</code> if
<code>arg</code> is not supplied. Other methods fall back on integer sequences
(<code style="white-space: pre;">&#8288;1:&lt;length of data&gt;&#8288;</code>) as the default if not provided.</p>
</td></tr>
<tr><td><code id="tfd_+3A_domain">domain</code></td>
<td>
<p>range of the <code>arg</code>.</p>
</td></tr>
<tr><td><code id="tfd_+3A_evaluator">evaluator</code></td>
<td>
<p>a function accepting arguments <code style="white-space: pre;">&#8288;x, arg, evaluations&#8288;</code>. See
details for <code><a href="#topic+tfd">tfd()</a></code>.</p>
</td></tr>
<tr><td><code id="tfd_+3A_id">id</code></td>
<td>
<p>The name or number of the column defining which data belong to
which function.</p>
</td></tr>
<tr><td><code id="tfd_+3A_value">value</code></td>
<td>
<p>The name or number of the column containing the function
evaluations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong><code>evaluator</code></strong>: must be the (quoted or bare) name of a
function with signature <code style="white-space: pre;">&#8288;function(x, arg, evaluations)&#8288;</code> that returns
the functions' (approximated/interpolated) values at locations <code>x</code> based on
the function <code>evaluations</code> available at locations <code>arg</code>.<br />
Available <code>evaluator</code>-functions:
</p>

<ul>
<li> <p><code>tf_approx_linear</code> for linear interpolation without extrapolation (i.e.,
<code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code> with <code>na.rm = FALSE</code>)  &ndash; this is the default,
</p>
</li>
<li> <p><code>tf_approx_spline</code> for cubic spline interpolation, (i.e., <code><a href="zoo.html#topic+na.approx">zoo::na.spline()</a></code>
with <code>na.rm = FALSE</code>),
</p>
</li>
<li> <p><code>tf_approx_fill_extend</code> for linear interpolation and constant extrapolation
(i.e., <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> with <code>fill = "extend"</code>)
</p>
</li>
<li> <p><code>tf_approx_locf</code> for &quot;last observation carried forward&quot;  (i.e.,
<code><a href="zoo.html#topic+na.locf">zoo::na.locf()</a></code> with <code>na.rm = FALSE</code> and
</p>
</li>
<li> <p><code>tf_approx_nocb</code> for &quot;next observation carried backward&quot; (i.e.,
<code><a href="zoo.html#topic+na.locf">zoo::na.locf()</a></code> with <code style="white-space: pre;">&#8288;na.rm = FALSE, fromLast = TRUE&#8288;</code>).
See <code>tf:::zoo_wrapper</code> and <code>tf:::tf_approx_linear</code>, which is simply
<code>zoo_wrapper(zoo::na.tf_approx, na.rm = FALSE)</code>, for examples of
implementations of this.
</p>
</li></ul>



<h3>Value</h3>

<p>an <code>tfd</code>-object (or a <code>data.frame</code>/<code>matrix</code> for the conversion
functions, obviously.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># turn irregular to regular tfd by evaluating on a common grid:

f &lt;- c(
  tf_rgp(1, arg = seq(0, 1, length.out = 11)),
  tf_rgp(1, arg = seq(0, 1, length.out = 21))
)
tfd(f, arg = seq(0, 1, length.out = 21))

set.seed(1213)
f &lt;- tf_rgp(3, arg = seq(0, 1, length.out = 51)) |&gt; tf_sparsify(0.9)
# does not yield regular data because linear extrapolation yields NAs
#   outside observed range:
tfd(f, arg = seq(0, 1, length.out = 101))
# this "works" (but may not yield sensible values..!!) for
#   e.g. constant extrapolation:
tfd(f, evaluator = tf_approx_fill_extend, arg = seq(0, 1, length.out = 101))
plot(f, col = 2)
tfd(f,
  arg = seq(0, 1, length.out = 151), evaluator = tf_approx_fill_extend
) |&gt; lines()
</code></pre>

<hr>
<h2 id='tfsummaries'>Functions that summarize <code>tf</code> objects across argument values</h2><span id='topic+tfsummaries'></span><span id='topic+mean.tf'></span><span id='topic+median.tf'></span><span id='topic+sd'></span><span id='topic+sd.default'></span><span id='topic+sd.tf'></span><span id='topic+var'></span><span id='topic+var.default'></span><span id='topic+var.tf'></span><span id='topic+summary.tf'></span>

<h3>Description</h3>

<p>These will return a <code>tf</code> object containing the respective <em>functional</em>
statistic. See <code><a href="#topic+tf_fwise">tf_fwise()</a></code> for scalar summaries
(e.g. <code>tf_fmean</code> for means, <code>tf_fmax</code> for max. values) of each entry
in a <code>tf</code>-vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tf'
mean(x, ...)

## S3 method for class 'tf'
median(x, na.rm = FALSE, depth = c("MBD", "pointwise"), ...)

sd(x, na.rm = FALSE)

## Default S3 method:
sd(x, na.rm = FALSE)

## S3 method for class 'tf'
sd(x, na.rm = FALSE)

var(x, y = NULL, na.rm = FALSE, use)

## Default S3 method:
var(x, y = NULL, na.rm = FALSE, use)

## S3 method for class 'tf'
var(x, y = NULL, na.rm = FALSE, use)

## S3 method for class 'tf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfsummaries_+3A_x">x</code></td>
<td>
<p>a <code>tf</code> object</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values be removed?</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_depth">depth</code></td>
<td>
<p>method used to determine the most central element in <code>x</code>, i.e.,
the median. One of the functional data depths available via <code><a href="#topic+tf_depth">tf_depth()</a></code> or
<code>"pointwise"</code> for a pointwise median function.</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_y">y</code></td>
<td>
<p><code>NULL</code> (default) or a vector, matrix or data frame with
compatible dimensions to <code>x</code>.   The default is equivalent to
<code>y = x</code> (but more efficient).</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_use">use</code></td>
<td>
<p>an optional character string giving a
method for computing covariances in the presence
of missing values.  This must be (an abbreviation of) one of the strings
<code>"everything"</code>, <code>"all.obs"</code>, <code>"complete.obs"</code>,
<code>"na.or.complete"</code>, or <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="tfsummaries_+3A_object">object</code></td>
<td>
<p>a <code>tfd</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tf</code> object with the computed result.<br />
<strong><code>summary.tf</code></strong> returns a <code>tf</code>-vector with the mean function, the
variance function, the functional median, and the functional range
(i.e., <em>pointwise</em> min/max) of the central half of the functions,
as defined by <code><a href="#topic+tf_depth">tf_depth()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf_fwise">tf_fwise()</a></code>
</p>
<p>Other tidyfun summary functions: 
<code><a href="#topic+functionwise">functionwise</a></code>
</p>

<hr>
<h2 id='unique_id'>Make syntactically valid unique names</h2><span id='topic+unique_id'></span>

<h3>Description</h3>

<p>See above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_id(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_id_+3A_x">x</code></td>
<td>
<p>any input</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> turned into a list.
</p>


<h3>See Also</h3>

<p>Other tidyfun developer tools: 
<code><a href="#topic+ensure_list">ensure_list</a>()</code>,
<code><a href="#topic+prep_plotting_arg">prep_plotting_arg</a>()</code>
</p>

<hr>
<h2 id='vec_cast.tfd_reg'><code>vctrs</code> methods for <code>tf</code> objects</h2><span id='topic+vec_cast.tfd_reg'></span><span id='topic+vec_cast.tfd_irreg'></span><span id='topic+vec_cast.tfd_reg.tfd_reg'></span><span id='topic+vec_cast.tfd_reg.tfd_irreg'></span><span id='topic+vec_cast.tfd_reg.tfb_spline'></span><span id='topic+vec_cast.tfd_reg.tfb_fpc'></span><span id='topic+vec_cast.tfd_irreg.tfd_reg'></span><span id='topic+vec_cast.tfd_irreg.tfd_irreg'></span><span id='topic+vec_cast.tfd_irreg.tfb_spline'></span><span id='topic+vec_cast.tfd_irreg.tfb_fpc'></span><span id='topic+vec_cast.tfb_spline'></span><span id='topic+vec_cast.tfb_fpc'></span><span id='topic+vec_cast.tfb_spline.tfb_spline'></span><span id='topic+vec_cast.tfb_spline.tfb_fpc'></span><span id='topic+vec_cast.tfb_fpc.tfb_spline'></span><span id='topic+vec_cast.tfb_fpc.tfb_fpc'></span><span id='topic+vec_cast.tfb_spline.tfd_reg'></span><span id='topic+vec_cast.tfb_spline.tfd_irreg'></span><span id='topic+vec_cast.tfb_fpc.tfd_reg'></span><span id='topic+vec_cast.tfb_fpc.tfd_irreg'></span><span id='topic+vctrs'></span><span id='topic+vec_ptype2.tfd_reg'></span><span id='topic+vec_ptype2.tfd_reg.tfd_reg'></span><span id='topic+vec_ptype2.tfd_reg.tfd_irreg'></span><span id='topic+vec_ptype2.tfd_reg.tfb_spline'></span><span id='topic+vec_ptype2.tfd_reg.tfb_fpc'></span><span id='topic+vec_ptype2.tfd_irreg'></span><span id='topic+vec_ptype2.tfd_irreg.tfd_reg'></span><span id='topic+vec_ptype2.tfd_irreg.tfd_irreg'></span><span id='topic+vec_ptype2.tfd_irreg.tfb_spline'></span><span id='topic+vec_ptype2.tfd_irreg.tfb_fpc'></span><span id='topic+vec_ptype2.tfb_spline'></span><span id='topic+vec_ptype2.tfb_spline.tfb_spline'></span><span id='topic+vec_ptype2.tfb_spline.tfb_fpc'></span><span id='topic+vec_ptype2.tfb_spline.tfd_reg'></span><span id='topic+vec_ptype2.tfb_spline.tfd_irreg'></span><span id='topic+vec_ptype2.tfb_fpc'></span><span id='topic+vec_ptype2.tfb_fpc.tfb_spline'></span><span id='topic+vec_ptype2.tfb_fpc.tfb_fpc'></span><span id='topic+vec_ptype2.tfb_fpc.tfd_reg'></span><span id='topic+vec_ptype2.tfb_fpc.tfd_irreg'></span>

<h3>Description</h3>

<p>These functions are the extensions that allow <code>tf</code> vectors
to work with <code>vctrs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfd_reg'
vec_cast(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_reg'
vec_ptype2(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfb_fpc(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_cast.tfd_reg_+3A_x">x</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
<tr><td><code id="vec_cast.tfd_reg_+3A_to">to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td></tr>
<tr><td><code id="vec_cast.tfd_reg_+3A_...">...</code></td>
<td>
<p>For <code>vec_cast_common()</code>, vectors to cast. For
<code>vec_cast()</code>, <code>vec_cast_default()</code>, and <code>vec_restore()</code>, these
dots are only for future extensions and should be empty.</p>
</td></tr>
<tr><td><code id="vec_cast.tfd_reg_+3A_y">y</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Notes on <code>vec_cast</code>:</strong>
Use <code><a href="#topic+tf_rebase">tf_rebase()</a></code> to change the representations of <code>tf</code>-vectors,
these methods are only for internal use &ndash;
automatic/implicit casting of <code>tf</code> objects is tricky
because it's hard to determine automatically whether such an operation would
lose precision (different bases with different expressivity? different
argument grids?), and it's not generally clear which instances of which
<code>tf</code>-subclasses should be considered the &quot;richer&quot; objects.
Rules for casting:
</p>

<ul>
<li><p> If the casted object's <code>domain</code> would not contain the entire original <code>domain</code>,
no casting is possible (would lose data).
</p>
</li>
<li><p> Every cast that evaluates (basis) functions on different <code>arg</code> values is a <em>lossy</em> cast,
since it might lose precision (<code>vctrs::maybe_lossy_cast</code>).
</p>
</li>
<li><p> As long as the casted object's <code>domain</code> contains the entire original <code>domain</code>:
</p>

<ul>
<li><p> every <code>tfd_reg</code>, <code>tfd_irreg</code> or <code>tfb</code> can always be cast into an equivalent
<code>tfd_irreg</code> (which may also change its <code>evaluator</code> and <code>domain</code>).
</p>
</li>
<li><p> every <code>tfd_reg</code> can always be cast to <code>tfd_reg</code> (which may change its <code>evaluator</code> and <code>domain</code>)
</p>
</li>
<li><p> every <code>tfb</code> can be cast <em>losslessly</em> to <code>tfd</code> (regular or irregular,
note it's lossless only on the <em>original</em> <code>arg</code>-grid)
</p>
</li></ul>

</li>
<li><p> Any cast of a <code>tfd</code> into <code>tfb</code> is potentially <em>lossy</em> (because we don't know how expressive the chosen basis is)
</p>
</li>
<li><p> Only <code>tfb</code> with identical bases and domains can be cast into one another <em>losslessly</em>
</p>
</li></ul>



<h3>Value</h3>

<p>for <code>vec_cast</code>: the casted <code>tf</code>-vector, for <code>vec_ptype2</code>: the common prototype
</p>


<h3>See Also</h3>

<p><code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>, <code><a href="vctrs.html#topic+vec_ptype2">vctrs::vec_ptype2()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
