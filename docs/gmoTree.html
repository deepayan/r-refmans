<!DOCTYPE html><html><head><title>Help for package gmoTree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmoTree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apptime'><p>Calculate the time that was spent on an app</p></a></li>
<li><a href='#assignv'><p>Assign a variable from all_apps_wide</p></a></li>
<li><a href='#assignv_to_aaw'><p>Assign a variable to all_apps_wide</p></a></li>
<li><a href='#delete_cases'><p>Delete specific cases</p></a></li>
<li><a href='#delete_dropouts'><p>Delete dropouts</p></a></li>
<li><a href='#delete_duplicate'><p>Delete duplicate data</p></a></li>
<li><a href='#delete_plabels'><p>Delete participant labels in all apps</p></a></li>
<li><a href='#delete_sessions'><p>Delete all cases of one session</p></a></li>
<li><a href='#extime'><p>Calculate the time that was spent on the whole experiment</p></a></li>
<li><a href='#import_otree'><p>Import oTree data</p></a></li>
<li><a href='#make_ids'><p>Make IDs</p></a></li>
<li><a href='#messy_chat'><p>Check if the Chats data frame is messy</p></a></li>
<li><a href='#messy_time'><p>Check if the Time data frame is messy</p></a></li>
<li><a href='#oTree'><p>Sample experiment data</p></a></li>
<li><a href='#pagesec'><p>Calculate the seconds spent on each page</p></a></li>
<li><a href='#show_constant'><p>Show constant columns</p></a></li>
<li><a href='#show_dropouts'><p>Show participants who did not finish the experiment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Get and Modify 'oTree' Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Manage data from 'oTree' experiments.  Import 'oTree' data and
    clean them up by using functions to deal with messy data, dropouts, and
    other problematic cases. Create IDs, calculate the time, transfer
    variables between app data frames, and delete sensitive information.
    You can also check your experimental data before running the
    experiment. Information on 'oTree' is found in Chen, D. L., Schonger, M., 
    &amp; Wickens, C. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jbef.2015.12.001">doi:10.1016/j.jbef.2015.12.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://zauchnerp.github.io/gmoTree/">https://zauchnerp.github.io/gmoTree/</a>,
<a href="https://github.com/ZauchnerP/gmoTree/">https://github.com/ZauchnerP/gmoTree/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ZauchnerP/gmoTree/issues/">https://github.com/ZauchnerP/gmoTree/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.8), dplyr (&ge; 1.1.2), openxlsx (&ge;
4.2.5.2), plyr (&ge; 1.8.8), rlang (&ge; 1.1.1), rlist (&ge;
0.4.6.2), stats (&ge; 4.3.0), stringr (&ge; 1.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.43), rmarkdown (&ge; 2.22), testthat (&ge; 3.1.9),
withr (&ge; 2.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 16:44:00 UTC; pzauchner</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricia F. Zauchner
    <a href="https://orcid.org/0000-0002-5938-1683"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, trl,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patricia F. Zauchner &lt;patricia.zauchner@gmx.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 17:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='apptime'>Calculate the time that was spent on an app</h2><span id='topic+apptime'></span>

<h3>Description</h3>

<p>Calculate the time spent on one app or several apps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apptime(
  oTree,
  apps = NULL,
  pcode = NULL,
  plabel = NULL,
  group_id = NULL,
  seconds = FALSE,
  rounded = TRUE,
  digits = 2,
  sinfo = "session_code",
  combine = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apptime_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="apptime_+3A_apps">apps</code></td>
<td>
<p>Character. Name(s) of the app(s) for which the time
should be calculated.</p>
</td></tr>
<tr><td><code id="apptime_+3A_pcode">pcode</code></td>
<td>
<p>Character. The value of the participant.code variable if the
time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="apptime_+3A_plabel">plabel</code></td>
<td>
<p>Character. The value of the participant.label variable if the
time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="apptime_+3A_group_id">group_id</code></td>
<td>
<p>Integer. The value of the group_id variable if the
time should only be calculated for one specified group. The group_id
variable can be created with make_ids().</p>
</td></tr>
<tr><td><code id="apptime_+3A_seconds">seconds</code></td>
<td>
<p>Logical.
TRUE if the output should be in seconds instead of minutes.</p>
</td></tr>
<tr><td><code id="apptime_+3A_rounded">rounded</code></td>
<td>
<p>Logical.
TRUE if the output should be rounded.</p>
</td></tr>
<tr><td><code id="apptime_+3A_digits">digits</code></td>
<td>
<p>Integer.
The number of digits to which the output should be rounded.
This parameter has no effect unless rounded = TRUE.</p>
</td></tr>
<tr><td><code id="apptime_+3A_sinfo">sinfo</code></td>
<td>
<p>Character.
&quot;session_id&quot; to use session ID for additional information in the data frame
of single durations, &quot;session_code&quot; to use session codes, or NULL if no
session column should be shown.</p>
</td></tr>
<tr><td><code id="apptime_+3A_combine">combine</code></td>
<td>
<p>Logical.
TRUE if all variables relating to epoch time should be merged, and
all variables relating to participant code should be merged
when data from multiple versions of oTree are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list for each app containing
information on the mean, the minimum, and maximum time the participants
spent on the app, a data frame with information on the time
each participant spent on the app, and eventually,
vectors of relevant background information on these numbers.
</p>
<p>If the experiment's duration is only calculated for one participant,
the output returns an NA (per app) if the person did not make
it to the app(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show how much time all participants spent on app "survey"
apptime(oTree, apps = "survey")

# Show how much time the participant "y8rbzcju" spent on
# the app "survey"
apptime(oTree, pcode = "y8rbzcju", apps = "survey")

# Show how much time the participants in group 4 spent on
# the app "survey"
oTree &lt;- make_ids(oTree, gmake = TRUE,
                  from_var = "dictator.1.group.id_in_subsession")
apptime(oTree, group_id = 4, apps = "survey")
</code></pre>

<hr>
<h2 id='assignv'>Assign a variable from all_apps_wide</h2><span id='topic+assignv'></span>

<h3>Description</h3>

<p>Assign a variable from all_apps_wide to the other app data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignv(oTree, variable, newvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignv_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="assignv_+3A_variable">variable</code></td>
<td>
<p>Character. The variable in the all_apps_wide data frame that
should be assigned to all other apps.</p>
</td></tr>
<tr><td><code id="assignv_+3A_newvar">newvar</code></td>
<td>
<p>Character. The name of the newly created variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the
original oTree list of data frames
but with an additional column in all data frames. The additional column
contains data from the specified variable found in all_apps_wide.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Assign variable "survey.1.player.gender" and name it "gender"
oTree &lt;- assignv(oTree = oTree,
                 variable = "survey.1.player.gender",
                 newvar = "gender")

# Show the new variable in some of the other app data frames
oTree$dictator$gender
oTree$chatapp$gender

# The variable is now duplicated in app "survey" because it is obtained from
# there (This can be avoided by naming the new variable the same as the old
# variable)
oTree$survey$gender
oTree$survey$player.gender

# In app "all_apps_wide," the variable is also there twice (This can be
# avoided by naming the new variable the same as the old variable)
oTree$all_apps_wide$gender
oTree$all_apps_wide$survey.1.player.gender
</code></pre>

<hr>
<h2 id='assignv_to_aaw'>Assign a variable to all_apps_wide</h2><span id='topic+assignv_to_aaw'></span>

<h3>Description</h3>

<p>Assign a variable from one of the app data frames to all_apps_wide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignv_to_aaw(oTree, app, variable, newvar, resafter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignv_to_aaw_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_app">app</code></td>
<td>
<p>Character. The data frame from which the variable is taken.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_variable">variable</code></td>
<td>
<p>Character.
The name of the variable that should be assigned to all_apps_wide.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_newvar">newvar</code></td>
<td>
<p>Character.
The name of the newly created variable in the all_apps_wide data frame.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_resafter">resafter</code></td>
<td>
<p>Character.
The name of the variable that precedes the new variable.
If NULL, the new variable will be placed at the end of the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames but with an additional column in the all_apps_wide data frame
that contains the variable in question.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Create a new variable
oTree$survey$younger30 &lt;- ifelse(oTree$survey$player.age &lt; 30, 0, 1)

# Assign the variable younger30 to all_apps_wide
oTree2 &lt;- assignv_to_aaw(
  oTree = oTree,
  app = "survey",
  variable = "younger30",
  newvar = "younger30")

# Show the new variable in the all_apps_wide data frame
oTree2$all_apps_wide$younger30

# Check the position of the new variable
match("younger30",names(oTree2$all_apps_wide))

# Place the new variable immediately after the "survey.1.player.age" variable
oTree2 &lt;- assignv_to_aaw(oTree,
                        app = "survey",
                        variable = "younger30",
                        newvar = "younger30",
                        resafter = "survey.1.player.age")

# Show the new variable in the all_apps_wide data frame
oTree2$all_apps_wide$younger30

# Show the position of the new variable
match("younger30", names(oTree2$all_apps_wide))
</code></pre>

<hr>
<h2 id='delete_cases'>Delete specific cases</h2><span id='topic+delete_cases'></span>

<h3>Description</h3>

<p>Delete specific cases from all data frames in the oTree list.
</p>
<p>Caution 1: This function does not delete cases from the original
CSV and Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports
and custom data frames if these data frames do not have a variable
named participant.code!
</p>
<p>Caution 3: This function does not delete any data from the Chats data frame!
(As the interpretation of chat data depends on how participants
engage with each other, the data must be deleted
with more care than deleting data in other apps.
Hence, this function does not delete data in this data frame.
Please do this manually if necessary!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_cases(
  oTree,
  pcodes = NULL,
  plabels = NULL,
  saved_vars = NULL,
  reason,
  omit = FALSE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_cases_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_pcodes">pcodes</code></td>
<td>
<p>Character. The value(s) of the participant.code variable of
the participants whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_plabels">plabels</code></td>
<td>
<p>Character. The value(s) of the participant.label variable of
the participants whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_omit">omit</code></td>
<td>
<p>Logical. TRUE if the deleted cases should not be added to
the information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the case deletion
process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list
of data frames that do not include the deleted cases.
</p>
<p>It adds information on the deleted cases to $info$deleted_cases. (This
list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>$codes = A vector with the participant codes of all deleted cases.
</p>
<p>$count = The number of participants in $codes.
</p>
<p>$full and $unique = The data frames $full and $unique contain information
on each deleted participant and the reason why they were
deleted. The entries to the $full and the $unique data frames are the same.
Columns &quot;end_app&quot; and &quot;end_page&quot; are left empty intentionally
because they are only filled by the delete_dropouts() function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete only one case
oTree2 &lt;- delete_cases(oTree,
                       pcodes = "xmxl46rm",
                       reason = "requested")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete several cases
deletionlist &lt;- c("4zhzdmzo", "xmxl46rm")
oTree2 &lt;- delete_cases(oTree,
                       pcodes = deletionlist,
                       reason = "requested")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Show information on all deleted cases (also dropouts):
oTree2$info$deleted_cases$full

# Save one variable
oTree2 &lt;- delete_cases(oTree,
  pcodes = deletionlist,
  reason = "requested",
  saved_vars = "participant._index_in_pages")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Save some variables
oTree2 &lt;- delete_cases(oTree,
  pcodes = deletionlist,
  reason = "requested",
  saved_vars = c(
    "participant._index_in_pages",
    "participant._max_page_index"))

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Get a list of all deleted cases
# (If there is already a list, the new list is added to it)
oTree2$info$deleted_cases$codes

# Show number of all deleted cases
length(oTree2$info$deleted_cases$codes)
oTree2$info$deleted_cases$count
</code></pre>

<hr>
<h2 id='delete_dropouts'>Delete dropouts</h2><span id='topic+delete_dropouts'></span>

<h3>Description</h3>

<p>Delete the data of all participants who did not end the experiment at (a)
certain page(s) and/or app(s).
</p>
<p>Caution 1: This function does not delete cases from the original CSV and
Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports if the
custom exports do not have a variable named participant.code and a variable
named session.code!
</p>
<p>Caution 3: This function does not delete any data from the Chats data frame!
(As the interpretation of chat data depends on how participants engage with
each other, the data must be deleted with more care than deleting data in
other apps. Hence, this function does not delete data in this data frame.
Please do this manually if necessary!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_dropouts(
  oTree,
  final_apps = NULL,
  final_pages = NULL,
  saved_vars = NULL,
  inconsistent = NULL,
  reason = "ENC",
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_dropouts_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_inconsistent">inconsistent</code></td>
<td>
<p>Character. Should the function continue or be stopped if
at least one participant has inconsistent end_pages, inconsistent end_apps,
or both? To continue, type &quot;yes,&quot;
to stop the function, type &quot;no.&quot;</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the dropout deletion
process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of data frames
but without the deleted cases.
</p>
<p>It adds information on the deleted cases to $info$deleted_cases. (This
list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>$full = A data frame that contains information
on all participants who did not finish the study;
it shows their participant codes, the names of the apps in which they
left the experiment,
the names of the pages in which they left the experiment,
the names of the app data frames in which this information was found, and
the dropout reason (&quot;ENC,&quot; experiment not completed, combined
with the name of the data frame in which the dropout was observed).
Because participants usually appear in multiple app data frames,
the $info$deleted_cases$full data frame may contain several entries for
each person.
</p>
<p>$unique = A data frame that contains similar information as the $full data
frame but with only one row per participant and no information on the data
frame in which the dropout was observed.
</p>
<p>$all_end = A table that provides information on the app and page combinations
where participants ended the experiment. This table also includes
information for participants who did not drop out of the experiment.
The $all_end table is only shown if an all_apps_wide data frame exists.
</p>
<p>$codes = A vector containing the participant codes of
all deleted participants.
</p>
<p>$count = The number of all deleted participants.
</p>
<p>It is important to note that if only the argument final_pages is set,
this function does not distinguish between page names that reoccur in
different apps.
</p>
<p>If the columns end_app and end_page in the output are empty,
these variables were not saved by oTree for the specific participants.
This could be because empty rows were not deleted. This can be done
by using the argument &quot;del_empty = TRUE&quot; when using import_otree().
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete all cases that didn't end the experiment on the page "Demographics"
# within the app "survey"
oTree2 &lt;- delete_dropouts(oTree,
                         final_apps = c("survey"),
                         final_pages = c("Demographics"))

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete all cases that didn't end the experiment on the page "Demographics"
# This page can be in any app
oTree2 &lt;- delete_dropouts(oTree, final_pages = "Demographics")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete all cases that didn't end the experiment on
# any page in the app "survey"
oTree &lt;- delete_dropouts(oTree, final_apps = "survey")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Get list of information on all deleted cases
# (If there is already a list, the new list is added to it!)
oTree2$info$deleted_cases
</code></pre>

<hr>
<h2 id='delete_duplicate'>Delete duplicate data</h2><span id='topic+delete_duplicate'></span>

<h3>Description</h3>

<p>Delete duplicate rows from all oTree app data frames and all_apps_wide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_duplicate(oTree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_duplicate_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree
list of data frames but without duplicate rows in all app data
frames and all_apps_wide. This function has no effect on the data
frames Time and Chats.
</p>
<p>This function does NOT add information to $info$deleted_cases,
because it does not delete any important information but only
cleans up a messy data import.
</p>
<p>However, the function adjusts info$initial_n, if an all_apps_wide
data frame exists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete duplicate rows
oTree &lt;- delete_duplicate(oTree)

# Show row numbers again
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

</code></pre>

<hr>
<h2 id='delete_plabels'>Delete participant labels in all apps</h2><span id='topic+delete_plabels'></span>

<h3>Description</h3>

<p>If you work with MTurk, the MTurk IDs will be stored in the
participant labels variable.
This function deletes this variable in all_apps_wide and every app data frame
in the list of data frames that was created by import_otree() and/or all
variables referring to MTurk, such as participant.mturk_worker_id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_plabels(oTree, del_plabel = TRUE, del_mturk = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_plabels_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="delete_plabels_+3A_del_plabel">del_plabel</code></td>
<td>
<p>Logical.
TRUE if all participant labels should be deleted.</p>
</td></tr>
<tr><td><code id="delete_plabels_+3A_del_mturk">del_mturk</code></td>
<td>
<p>Logical.
TRUE if all MTurk variables should be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that do not include the participant labels and/or the MTurk
variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show participant labels
oTree$all_apps_wide$participant.label
oTree$survey$participant.label

# Delete all participant labels
oTree2 &lt;- delete_plabels(oTree)

# Show participant labels again
oTree2$all_apps_wide$participant.label
oTree2$survey$participant.label
</code></pre>

<hr>
<h2 id='delete_sessions'>Delete all cases of one session</h2><span id='topic+delete_sessions'></span>

<h3>Description</h3>

<p>Delete cases from specific sessions in all data frames in the
oTree list of data frames.
</p>
<p>Caution 1: This function does not delete cases from the
original CSV and Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports if the
custom exports do not have a variable named participant.code and a variable
named session.code!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_sessions(oTree, scodes, saved_vars = NULL, reason, info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_sessions_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_scodes">scodes</code></td>
<td>
<p>Character. The session.code(s) of the
session(s) whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in $info$deleted_cases.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the session
deletion process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that do not include the deleted sessions.
</p>
<p>It adds information on the deleted cases to $info$deleted_cases. (This
list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>$full and $unique = The data frames $full and $unique contain
information on all participants
whose data were deleted. The entries to the $full and the $unique data
frames in this list are the same. Columns &quot;end_app&quot; and &quot;end_page&quot; are left
empty intentionally because they are only filled by the delete_dropouts()
function. Columns &quot;participant.code&quot; and &quot;reason&quot; are filled.
</p>
<p>$codes = A vector containing the participant codes of
all deleted participants.
</p>
<p>$count = The number of all deleted participants.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete one session
oTree2 &lt;- delete_sessions(oTree,
  scodes = "7bfqtokx",
  reason = "Only tests")

# Show row numbers
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete two sessions
oTree2 &lt;- delete_sessions(oTree,
  scodes = c("7bfqtokx", "vd1h01iv"),
  reason = "Only tests")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))
</code></pre>

<hr>
<h2 id='extime'>Calculate the time that was spent on the whole experiment</h2><span id='topic+extime'></span>

<h3>Description</h3>

<p>Calculate the time spent on the experiment.
If not stated otherwise, the calculation only starts at the end of
the first page!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extime(
  oTree,
  pcode = NULL,
  plabel = NULL,
  group_id = NULL,
  seconds = FALSE,
  rounded = TRUE,
  digits = 2,
  startat = 1,
  tz = "UTC",
  sinfo = "session_code",
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extime_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="extime_+3A_pcode">pcode</code></td>
<td>
<p>Character. The value of the participant.code variable if the
time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="extime_+3A_plabel">plabel</code></td>
<td>
<p>Character. The value of the participant.label variable if the
time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="extime_+3A_group_id">group_id</code></td>
<td>
<p>Integer. The value of the group_id variable if the
time should only be calculated for one specified group. The group_id
variable can be created with make_ids().</p>
</td></tr>
<tr><td><code id="extime_+3A_seconds">seconds</code></td>
<td>
<p>Logical.
TRUE if the output should be in seconds instead of minutes.</p>
</td></tr>
<tr><td><code id="extime_+3A_rounded">rounded</code></td>
<td>
<p>Logical. TRUE if the output should be rounded.</p>
</td></tr>
<tr><td><code id="extime_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits to which the output
should be rounded.
This parameter has no effect unless rounded = TRUE.</p>
</td></tr>
<tr><td><code id="extime_+3A_startat">startat</code></td>
<td>
<p>Integer or character string &quot;real&quot;.
Whether the start of the experiment should be taken from the time at
a certain index of each person's vector of page_indexes in the
Time data frame or from the &quot;time_started&quot;
variable in all_apps_wide (&quot;real&quot;). Important: If integer,
it represents the position within the page index sequence,
not the numeric value of the page_index variable.</p>
</td></tr>
<tr><td><code id="extime_+3A_tz">tz</code></td>
<td>
<p>Character. Time zone.</p>
</td></tr>
<tr><td><code id="extime_+3A_sinfo">sinfo</code></td>
<td>
<p>Character.
&quot;session_id&quot; to use session ID for additional information in the data frame
of single durations, &quot;session_code&quot; to use session codes, or NULL if no
session column should be shown.</p>
</td></tr>
<tr><td><code id="extime_+3A_combine">combine</code></td>
<td>
<p>Logical. TRUE if all variables referring to epoch time should
be merged, and all variables referring to participant code should
be merged in case data of several versions of oTree are used. If FALSE,
the function returns an error if several oTree versions' data are present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns either a single value if only the data of one person
is calculated or a list of information on the time several participants
spent on the experiment.
</p>
<p>In this list, you can find the following information:
</p>
<p>$mean_duration = The experiment's average duration.
</p>
<p>$min_duration = The experiment's minimum duration.
</p>
<p>$max_duration = The experiment's maximum duration.
</p>
<p>$single_durations = A data frame of all durations that
are used for calculating the min, max, and mean duration.
</p>
<p>$messages = All important notes to the calculations.
</p>
<p>$only_one_page = A vector of all individuals who only have one time stamp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show time for one participant
extime(oTree, pcode = "wk247s9w")

# Make a data frame of durations
extime(oTree)

# Make a data frame of durations (beginning from the end of the second page)
extime(oTree, startat = 2)
</code></pre>

<hr>
<h2 id='import_otree'>Import oTree data</h2><span id='topic+import_otree'></span>

<h3>Description</h3>

<p>Import data files that were created by oTree.
All files containing the pattern YYYY-MM-DD at the end
of their file names are considered oTree files.
Bot outputs are saved by oTree without the date included. Hence, to
import bot data, you must either rename the original bot files
using the YYYY-MM-DD format or use the argument &quot;onlybots = TRUE.&quot;
By using the second option, only data of bot files are imported.
</p>
<p>Caution! Data can be downloaded from within the
session and globally at the same time. If both files are downloaded,
this can lead to the all_apps_wide data being there twice! You can remove
duplicate data by using delete_duplicate().
</p>
<p>Caution! When importing Excel files, this function does not check 
for erroneous data structures
and will combine all data frames with the same file name patterns.
Before using the &quot;CSV = FALSE&quot; argument, clean up your data appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_otree(
  path = ".",
  file_names = NULL,
  final_apps = NULL,
  final_pages = NULL,
  recursive = TRUE,
  csv = TRUE,
  onlybots = FALSE,
  del_empty = TRUE,
  info = FALSE,
  encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_otree_+3A_path">path</code></td>
<td>
<p>Character. The path to the files (default is the
working directory).</p>
</td></tr>
<tr><td><code id="import_otree_+3A_file_names">file_names</code></td>
<td>
<p>Character. The name(s) of the file(s) to be imported.
If not specified, all files in the path and subfolders are imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment. If the argument final_apps is left empty, you can still call
for deleting the participants who did not finish the experiment with
delete_dropouts().</p>
</td></tr>
<tr><td><code id="import_otree_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment. If the argument final_pages is left empty, you can still
call for deleting the participants who did not finish the experiment
with delete_dropouts().</p>
</td></tr>
<tr><td><code id="import_otree_+3A_recursive">recursive</code></td>
<td>
<p>Logical. TRUE if the files in the path's
subfolders should also be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_csv">csv</code></td>
<td>
<p>Logical.
TRUE if only CSV files should be imported.
FALSE if only Excel files should be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_onlybots">onlybots</code></td>
<td>
<p>Logical. TRUE if only bot-created files should be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_del_empty">del_empty</code></td>
<td>
<p>Logical. TRUE if all empty cases should be deleted from the
all_apps_wide or normal app data frames (not Time or Chats).</p>
</td></tr>
<tr><td><code id="import_otree_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the data import should be
printed.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_encoding">encoding</code></td>
<td>
<p>Character. Encoding of the CSV files that are imported.
Default is &quot;UTF-8&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frames (one data frame for each app and
all_apps_wide) and a list of information on this list of data frames
in $info.
</p>
<p>See detailed information on the imported files in $info$imported_files.
</p>
<p>If all_apps_wide is imported, see the number of imported cases
in $info$initial_n. In this number, empty rows are
already considered. So, if empty rows are deleted with del_empty=TRUE,
initial_n counts all rows that are not empty.
Cases that are deleted because the participants did not make it to the
last page and/or app are not subtracted from this number.
</p>
<p>Information: Empty rows are rows without the &quot;participant._current_app_name&quot;
variable set. Empty rows are deleted from all app data frames and
all_apps_wide when using del_empty=TRUE. Empty rows in the Chats and Time
data frames are not deleted.
</p>
<p>If old and new oTree versions are combined, the Time data frame contains
variables called &quot;participant_code&quot; and &quot;participant__code&quot;
(the difference is in the underscores).
Caution! If there is an unusual amount of NAs,
check if everything got imported correctly.
Sometimes, the CSV or Excel file may be corrupted, and all information is
only found in one column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()

# Show the structure of the import
str(oTree, max.level = 1)

# Show the names of all imported files
oTree$info$imported_files

# Delete empty cases and delete every case of a person
# who didn't end the experiment in the app "survey"
oTree &lt;- import_otree(
  del_empty = TRUE,
  final_apps = "survey",
  info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import bot files
import_otree(
  path = "./bot_data",
  onlybots = TRUE,
  csv = TRUE,
  info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import with file names (path separately)
oTree2 &lt;- import_otree(
     del_empty = TRUE,
     path = "./exp_data",
     file_names = c("all_apps_wide-2023-03-27.csv",
                   "ChatMessages-2023-03-27.csv",
                   "PageTimes-2023-03-27.csv"),
     onlybots = FALSE,
     csv = TRUE,
     info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import with file names (without path separately)
oTree2 &lt;- import_otree(
     del_empty = TRUE,
     file_names = c("exp_data/all_apps_wide-2023-03-27.csv",
                   "exp_data/ChatMessages-2023-03-27.csv",
                   "exp_data/PageTimes-2023-03-27.csv"),
     onlybots = FALSE,
     csv = TRUE,
     info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)
})

</code></pre>

<hr>
<h2 id='make_ids'>Make IDs</h2><span id='topic+make_ids'></span>

<h3>Description</h3>

<p>Make session IDs and, optionally, group IDs and participant IDs
that span across all data frames created by
import_otree(). Information for these IDs is taken from all_apps_wide
but can be defined otherwise.
</p>
<p>Note: Older versions of oTree may already contain a
variable called session_id in their Time data frames.
This variable is overwritten by this function!
</p>
<p>Important: Combine duplicate data before running this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ids(
  oTree,
  gmake = FALSE,
  pmake = TRUE,
  from_app = "all_apps_wide",
  from_var = NULL,
  sstart = 1,
  gstart = 1,
  pstart = 1,
  emptyrows = NULL,
  icw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ids_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="make_ids_+3A_gmake">gmake</code></td>
<td>
<p>Logical. TRUE if a variable called group_id should be made.
If from_var is not NULL, gmake is automatically set to TRUE.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_pmake">pmake</code></td>
<td>
<p>Logical. TRUE if a variable called participant_id
should be made.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_from_app">from_app</code></td>
<td>
<p>Character. Name of the data frame from which the session,
group, and participant information should be taken.
All normal app data frames and all_apps_wide are allowed.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_from_var">from_var</code></td>
<td>
<p>Character. Name of the variable from which the group
information should be taken. This argument is only relevant when
all_apps_wide is used as from_app and has group information that contradicts
each other.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_sstart">sstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for session IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_gstart">gstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for group IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_pstart">pstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for participant IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_emptyrows">emptyrows</code></td>
<td>
<p>Character. &quot;no&quot; if the function should stop if there are
empty rows in from_app. &quot;yes&quot; if the function should continue to make IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_icw">icw</code></td>
<td>
<p>Logical. TRUE if the warning message should be
ignored that states that IDs cannot be made because of an oTree bug.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ID variables are made in all_apps_wide, all app data frames,
the Time data frame, and the Chats data frame.
See list of the additional ID variables in $info$additional_variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Make session IDs only
oTree2 &lt;- make_ids(oTree)

# Show new variables
oTree2$all_apps_wide$session_id

# Make session IDs and group IDs
# Not working with this data set because group ID is not the same in all apps
## Not run: 
      oTree2 &lt;- make_ids(oTree, gmake = TRUE)

      # Show new variables
      oTree2$all_apps_wide$session_id
      oTree2$all_apps_wide$group_id

## End(Not run)

# Get IDs from variable "dictator.1.group.id_in_subsession"
# in the data frame "all_apps_wide"
oTree2 &lt;- make_ids(oTree,
                   gmake = TRUE,
                   from_var = "dictator.1.group.id_in_subsession")

# Show new variables
oTree2$all_apps_wide$session_id
oTree2$all_apps_wide$group_id

# Get IDs from another app than all_apps_wide
oTree2 &lt;- make_ids(oTree, gmake = TRUE, from_app = "dictator")

# Show new variables
oTree2$all_apps_wide$session_id
oTree2$all_apps_wide$group_id
</code></pre>

<hr>
<h2 id='messy_chat'>Check if the Chats data frame is messy</h2><span id='topic+messy_chat'></span>

<h3>Description</h3>

<p>Check if the Chats data frame includes both
session-related variables and participant-related variables that
appear multiple times. This may occur when data from different
oTree versions, which use different variable names, are combined.
</p>
<p>If desired, the function can merge these variables,
storing the data using the newer oTree version's variable names
and removing the outdated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_chat(
  oTree,
  combine = FALSE,
  session = TRUE,
  participant = TRUE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messy_chat_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_combine">combine</code></td>
<td>
<p>Logical. TRUE if all variables referring to
the session code should be merged and/or all variables referring
to participant code should be merged in case data of several versions
of oTree are used.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_session">session</code></td>
<td>
<p>Logical. TRUE if all variables referring to the session code
should be checked and merged. Merging only works if combine = TRUE.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_participant">participant</code></td>
<td>
<p>Logical. TRUE if all variables referring to the
participant code should be checked and merged. Merging only works if
combine = TRUE.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the process should
be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an oTree list of data frames that is
an exact copy of the original oTree list of data frames but - if the user
wishes to do so - combines the participant code and session code
variables in the Chats data frame if several variables are referring to
those because of the
combination of different oTree versions. The final variables are called
participant_code and session_code.
</p>
<p>If combine = FALSE, the function only checks for the existence of several
variables referring to the participant code and session code and throws an
error if yes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# Show all Chats column names
print(colnames(oTree$Chats))

# Run function
oTree &lt;- messy_chat(oTree, combine = TRUE)

# Show all Chats column names again
print(colnames(oTree$Chats))

</code></pre>

<hr>
<h2 id='messy_time'>Check if the Time data frame is messy</h2><span id='topic+messy_time'></span>

<h3>Description</h3>

<p>Check if the Time data frame includes both participant-related variables
and time stamp variables that appear multiple times. This may occur when
data from different oTree versions, which use different variable names,
are combined.
</p>
<p>If desired, the function can merge these variables,
storing the data using the newer oTree version's variable names
and removing the outdated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_time(
  oTree,
  combine = FALSE,
  epoch_time = TRUE,
  participant = TRUE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messy_time_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="messy_time_+3A_combine">combine</code></td>
<td>
<p>Logical. TRUE if all variables referring to epoch time should
be merged and/or all variables referring to participant code should be merged
in case data of several versions of oTree are used.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_epoch_time">epoch_time</code></td>
<td>
<p>Logical. TRUE if all variables referring to the time stamp
should be checked and merged. Only works if combine = TRUE.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_participant">participant</code></td>
<td>
<p>Logical. TRUE if all variables referring to the
participant code should be checked and merged. Only works if combine = TRUE.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_info">info</code></td>
<td>
<p>Logical. TRUE if a brief information on the process should
be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an oTree list of data frames that is
an exact copy of the original oTree list of data frames but - if the user
wishes to do so - combines the
time tamps and participant codes in the Time data frame if several variables
are referring to those because of the
combination of different oTree versions. The final variables are called
epoch_time_completed and participant_code.
</p>
<p>If combine = FALSE, the function only checks for the existence of several
variables referring to the time stamp or the participant code and throws an
error if yes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# Show all Time column names
print(colnames(oTree$Time))

# Run function
oTree &lt;- messy_time(oTree, combine = TRUE)

# Show all Time column names again
print(colnames(oTree$Time))

</code></pre>

<hr>
<h2 id='oTree'>Sample experiment data</h2><span id='topic+oTree'></span>

<h3>Description</h3>

<p>Sample experiment data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oTree
</code></pre>


<h3>Format</h3>

<p>A list of data frames created by import_otree().
</p>


<h3>Source</h3>

<p>The data set was created by using modified versions of the official
oTree sample experiments that can be downloaded when installing oTree.
In detail, the following apps were used: &quot;dictator,&quot; &quot;chatapp,&quot; &quot;survey.&quot;
</p>

<hr>
<h2 id='pagesec'>Calculate the seconds spent on each page</h2><span id='topic+pagesec'></span>

<h3>Description</h3>

<p>Create a new variable in the Time data frame that contains the time
spent on each page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagesec(oTree, rounded = TRUE, digits = 2, minutes = FALSE, combine = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagesec_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="pagesec_+3A_rounded">rounded</code></td>
<td>
<p>Logical. TRUE if the output should be rounded.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits to which the
output should be rounded.
This parameter has no effect unless rounded = TRUE.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_minutes">minutes</code></td>
<td>
<p>Logical. TRUE if the output should be
minutes instead of seconds.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_combine">combine</code></td>
<td>
<p>Logical. TRUE if all variables referring to epoch time should
be merged, and all variables referring to participant code should be
merged in case data of several versions of oTree are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that also contains a column in the Time data frame named
seconds_on_page2 or minutes_on_page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Create two new columns: seconds_on_page2 and minutes_on_page
oTree &lt;- pagesec(oTree, rounded = TRUE, minutes = TRUE)

# Show the Time data frame
head(oTree$Time, n = 30)
</code></pre>

<hr>
<h2 id='show_constant'>Show constant columns</h2><span id='topic+show_constant'></span>

<h3>Description</h3>

<p>Show all columns with no variation in their values for each data frame
in the oTree list of data frames (except the ones in the info list).
This function is helpful before running an experiment to check if there
are unnecessary variables.
You can check for columns that have any unchanging possible value
or for columns containing only a specific value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_constant(oTree, value = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_constant_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="show_constant_+3A_value">value</code></td>
<td>
<p>The value that is controlled to be the same within a column.
The default is NA. If the value is set to &quot;any,&quot; the function checks for
columns where any possible values are identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of vectors, one for each app,
all_apps_wide, the Time and/or the Chats data frame.
Each vector contains the names of all variables with constant values.
If there are no variables with constant values, the vector is empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show all columns that contain only NAs
show_constant(oTree = oTree)
show_constant(oTree = oTree, value = NA)

# Show all columns that contain only -99
show_constant(oTree = oTree, value = -99)
</code></pre>

<hr>
<h2 id='show_dropouts'>Show participants who did not finish the experiment</h2><span id='topic+show_dropouts'></span>

<h3>Description</h3>

<p>Show information on the people who did not finish the experiment at (a)
certain page(s) and/or app(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_dropouts(oTree, final_apps = NULL, final_pages = NULL, saved_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_dropouts_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created by import_otree().</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_saved_vars">saved_vars</code></td>
<td>
<p>The name(s) of variable(s) that need(s) to be
shown in the list of information on dropout cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of information on participants who did not
finish the experiment.
</p>
<p>In this list, you can find the following information:
</p>
<p>$full = A data frame that contains information
on all participants who did not finish the study;
it shows their participant codes, the names of the apps in which they
left the experiment,
the names of the pages in which they left the experiment,
the names of the app data frames in which this information was found, and
the dropout reason (&quot;ENC,&quot; experiment not completed, combined
with the name of the data frame in which the dropout was observed).
Because participants usually appear in multiple app data frames,
the $full data frame may contain several entries for
each person.
</p>
<p>$unique = A data frame that contains similar information as the $full data
frame but with only one row per participant and no information on the data
frame in which the dropout was observed.
</p>
<p>$all_end = A table that provides information on the app and page combinations
where participants ended the experiment. This table also includes
information on participants who did not drop out of the experiment.
The $all_end table is only shown if an all_apps_wide data frame exists.
</p>
<p>$codes = A vector containing the participant codes of
all participants who did not finish the experiment.
</p>
<p>$count = The number of all participants who did not finish the experiment.
</p>
<p>It is important to note that if only the argument final_pages is set,
this function does not distinguish between page names that reoccur in
different apps.
</p>
<p>If the columns end_app and end_page in the output are empty,
these variables were not saved by oTree for the specific participants.
This could be because empty rows were not deleted. This can be done
by using the argument &quot;del_empty = TRUE&quot; when using import_otree().
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show everyone who did not finish with the app "survey"
show_dropouts(oTree, final_apps = "survey")

# Show everyone who did not finish with the page "Demographics"
show_dropouts(oTree, final_pages = "Demographics")

# Show everyone who finished with the following apps: "survey," "dictator"
final_apps &lt;- unique(oTree$all_apps_wide$participant._current_app_name)
final_apps &lt;- final_apps[final_apps != "survey"]
final_apps &lt;- final_apps[final_apps != "dictator"]
show_dropouts(oTree, final_apps = final_apps)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
