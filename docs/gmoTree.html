<!DOCTYPE html><html><head><title>Help for package gmoTree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmoTree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apptime'><p>Calculate the time that was spent on an app</p></a></li>
<li><a href='#assignv'><p>Assign a variable from all_apps_wide</p></a></li>
<li><a href='#assignv_to_aaw'><p>Assign a variable to all_apps_wide</p></a></li>
<li><a href='#delete_cases'><p>Delete specific cases</p></a></li>
<li><a href='#delete_dropouts'><p>Delete dropouts</p></a></li>
<li><a href='#delete_duplicate'><p>Delete duplicate data</p></a></li>
<li><a href='#delete_plabels'><p>Delete participant labels in all apps</p></a></li>
<li><a href='#delete_sessions'><p>Delete all cases of one session</p></a></li>
<li><a href='#extime'><p>Calculate the time that was spent on the whole experiment</p></a></li>
<li><a href='#import_otree'><p>Import oTree data</p></a></li>
<li><a href='#make_ids'><p>Make IDs</p></a></li>
<li><a href='#messy_chat'><p>Check if the Chats data frame is messy</p></a></li>
<li><a href='#messy_time'><p>Check if the Time data frame is messy</p></a></li>
<li><a href='#oTree'><p>Sample experiment data</p></a></li>
<li><a href='#pagesec'><p>Calculate the seconds spent on each page</p></a></li>
<li><a href='#show_constant'><p>Show constant columns</p></a></li>
<li><a href='#show_dropouts'><p>Show participants who did not finish the experiment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Get and Modify 'oTree' Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Manage data from 'oTree' experiments.  Import 'oTree' data
    and clean them by using functions to deal with messy data,
    dropouts, and other problematic cases. Create IDs, calculate the time,
    transfer variables between app data frames, and delete sensitive
    information. You can also check your experimental data before running
    the experiment. 
    Information on 'oTree' is found in Chen, D. L.,
    Schonger, M., &amp; Wickens, C. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jbef.2015.12.001">doi:10.1016/j.jbef.2015.12.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://zauchnerp.github.io/gmoTree/">https://zauchnerp.github.io/gmoTree/</a>,
<a href="https://github.com/ZauchnerP/gmoTree/">https://github.com/ZauchnerP/gmoTree/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ZauchnerP/gmoTree/issues/">https://github.com/ZauchnerP/gmoTree/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.15.4), dplyr (&ge; 1.1.4), openxlsx (&ge;
4.2.5.2), plyr (&ge; 1.8.9), rlang (&ge; 1.1.4), rlist (&ge;
0.4.6.2), stats (&ge; 4.4.1), stringr (&ge; 1.5.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.47), rmarkdown (&ge; 2.27), testthat (&ge; 3.2.1),
withr (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 15:08:01 UTC; pzauchner</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricia F. Zauchner
    <a href="https://orcid.org/0000-0002-5938-1683"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, trl,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patricia F. Zauchner &lt;patricia.zauchner@gmx.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apptime'>Calculate the time that was spent on an app</h2><span id='topic+apptime'></span>

<h3>Description</h3>

<p>Calculate the time spent on one app or several apps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apptime(
  oTree,
  apps = NULL,
  pcode = NULL,
  plabel = NULL,
  group_id = NULL,
  seconds = FALSE,
  rounded = TRUE,
  digits = 2,
  sinfo = "session_code",
  combine = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apptime_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code></p>
</td></tr>
<tr><td><code id="apptime_+3A_apps">apps</code></td>
<td>
<p>Character. Name(s) of the app(s) for which the time
should be calculated.</p>
</td></tr>
<tr><td><code id="apptime_+3A_pcode">pcode</code></td>
<td>
<p>Character. The value of the <code>participant.code</code> 
variable if the time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="apptime_+3A_plabel">plabel</code></td>
<td>
<p>Character. The value of the <code>participant.label</code> 
variable if the time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="apptime_+3A_group_id">group_id</code></td>
<td>
<p>Integer. The value of the <code>group_id</code> variable if the
time should only be calculated for one specified group. The <code>group_id</code>
variable can be created with <code><a href="#topic+make_ids">make_ids</a></code>.</p>
</td></tr>
<tr><td><code id="apptime_+3A_seconds">seconds</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be 
in seconds instead of minutes.</p>
</td></tr>
<tr><td><code id="apptime_+3A_rounded">rounded</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be rounded.</p>
</td></tr>
<tr><td><code id="apptime_+3A_digits">digits</code></td>
<td>
<p>Integer.
The number of digits to which the output should be rounded.
This parameter has no effect unless <code>rounded = TRUE</code>.</p>
</td></tr>
<tr><td><code id="apptime_+3A_sinfo">sinfo</code></td>
<td>
<p>Character. <code>"session_id"</code> to use session ID 
for additional information in the data frame
of single durations, <code>"session_code"</code> to use session codes, 
or <code>NULL</code> if no
session column should be shown.</p>
</td></tr>
<tr><td><code id="apptime_+3A_combine">combine</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables relating to epoch time 
should be merged, and
all variables relating to participant code should be merged
when data from multiple versions of oTree are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list for each app containing
information on the mean, the minimum, and maximum time the participants
spent on the app, a data frame with information on the time
each participant spent on the app, and eventually,
vectors of relevant background information on these numbers.
</p>
<p>If the experiment's duration is only calculated for one participant,
the output returns an <code>NA</code> (per app) if the person did not make
it to the app(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show how much time all participants spent on app "survey"
apptime(oTree, apps = "survey")

# Show how much time the participant "a7dppel1" spent on
# the app "survey"
apptime(oTree, pcode = "a7dppel1", apps = "survey")

# Show how much time the participants in group 4 spent on
# the app "survey"
oTree &lt;- make_ids(oTree,
    gmake = TRUE,
    from_var = "dictator.1.group.id_in_subsession"
)
apptime(oTree, group_id = 4, apps = "survey")

# Show how much time all participants spent on all apps
apptime(oTree)
</code></pre>

<hr>
<h2 id='assignv'>Assign a variable from all_apps_wide</h2><span id='topic+assignv'></span>

<h3>Description</h3>

<p>Assign a variable from <code>$all_apps_wide</code> to the other app data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignv(oTree, variable, newvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignv_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were 
created by <code><a href="#topic+import_otree">import_otree</a></code></p>
</td></tr>
<tr><td><code id="assignv_+3A_variable">variable</code></td>
<td>
<p>Character. The variable in the <code>$all_apps_wide</code> 
data frame that should be assigned to all other apps.</p>
</td></tr>
<tr><td><code id="assignv_+3A_newvar">newvar</code></td>
<td>
<p>Character. The name of the newly created variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the
original oTree list of data frames
but with an additional column in all data frames. The additional column
contains data from the specified variable found in <code>$all_apps_wide</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Assign variable "survey.1.player.gender" and name it "gender"
oTree &lt;- assignv(oTree = oTree,
                 variable = "survey.1.player.gender",
                 newvar = "gender")

# Show the new variable in some of the other app data frames
oTree$dictator$gender
oTree$chatapp$gender

# The variable is now duplicated in app "survey" because it is obtained from
# there (This can be avoided by naming the new variable the same as the old
# variable)
oTree$survey$gender
oTree$survey$player.gender

# In app "all_apps_wide," the variable is also there twice (This can be
# avoided by naming the new variable the same as the old variable)
oTree$all_apps_wide$gender
oTree$all_apps_wide$survey.1.player.gender
</code></pre>

<hr>
<h2 id='assignv_to_aaw'>Assign a variable to all_apps_wide</h2><span id='topic+assignv_to_aaw'></span>

<h3>Description</h3>

<p>Assign a variable from one of the app data frames to <code>$all_apps_wide</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignv_to_aaw(oTree, app, variable, newvar, resafter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignv_to_aaw_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_app">app</code></td>
<td>
<p>Character. The data frame from which the variable is taken.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_variable">variable</code></td>
<td>
<p>Character.
The name of the variable that should be assigned to <code>$all_apps_wide</code>.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_newvar">newvar</code></td>
<td>
<p>Character.
The name of the newly created variable in the <code>$all_apps_wide</code> data 
frame.</p>
</td></tr>
<tr><td><code id="assignv_to_aaw_+3A_resafter">resafter</code></td>
<td>
<p>Character.
The name of the variable that precedes the new variable.
If <code>NULL</code>, the new variable will be placed at the end of the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames but with an additional column in the <code>$all_apps_wide</code> data 
frame that contains the variable in question.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Create a new variable
oTree$survey$younger30 &lt;- ifelse(oTree$survey$player.age &lt; 30, 0, 1)

# Assign the variable younger30 to all_apps_wide
oTree2 &lt;- assignv_to_aaw(
  oTree = oTree,
  app = "survey",
  variable = "younger30",
  newvar = "younger30")

# Show the new variable in the all_apps_wide data frame
oTree2$all_apps_wide$younger30

# Check the position of the new variable
match("younger30",names(oTree2$all_apps_wide))

# Place the new variable immediately after the "survey.1.player.age" variable
oTree2 &lt;- assignv_to_aaw(oTree,
                        app = "survey",
                        variable = "younger30",
                        newvar = "younger30",
                        resafter = "survey.1.player.age")

# Show the new variable in the all_apps_wide data frame
oTree2$all_apps_wide$younger30

# Show the position of the new variable
match("younger30", names(oTree2$all_apps_wide))
</code></pre>

<hr>
<h2 id='delete_cases'>Delete specific cases</h2><span id='topic+delete_cases'></span>

<h3>Description</h3>

<p>Delete specific cases from all data frames in the oTree list.
</p>
<p>Caution 1: This function does not delete cases from the original
CSV and Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports
and custom data frames if these data frames do not have a variable
named participant.code!
</p>
<p>Caution 3: This function does not delete any data from 
the <code>$Chats</code> data frame!
(As the interpretation of chat data depends on how participants
engage with each other, the data must be deleted
with more care than deleting data in other apps.
Hence, this function does not delete data in this data frame.
Please do this manually if necessary!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_cases(
  oTree,
  pcodes = NULL,
  plabels = NULL,
  saved_vars = NULL,
  reason,
  omit = FALSE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_cases_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_pcodes">pcodes</code></td>
<td>
<p>Character. The value(s) of the participant.code variable of
the participants whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_plabels">plabels</code></td>
<td>
<p>Character. The value(s) of the participant.label variable of
the participants whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases 
in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_omit">omit</code></td>
<td>
<p>Logical. <code>TRUE</code> if the deleted cases should not be added to
the information on deleted cases in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_cases_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the case deletion
process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list
of data frames that do not include the deleted cases.
</p>
<p>It adds information on the deleted cases to <code>$info$deleted_cases</code>. (This
list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>- <code>$codes</code> = A vector with the participant codes of all deleted cases.
</p>
<p>- <code>$count</code> = The number of participants in <code>$codes</code>.
</p>
<p>- <code>$full</code> and <code>$unique</code> = The data frames <code>$full</code> 
and <code>$unique</code> contain information
on each deleted participant and the reason why they were
deleted. The entries to the <code>$full</code> and the <code>$unique</code> 
data frames are the same.
Columns <code>"end_app"</code> and <code>"end_page"</code> are left empty intentionally
because they are only filled by the <code><a href="#topic+delete_dropouts">delete_dropouts</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete only one case
oTree2 &lt;- delete_cases(oTree,
                       pcodes = "xmxl46rm",
                       reason = "requested")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete several cases
deletionlist &lt;- c("4zhzdmzo", "xmxl46rm")
oTree2 &lt;- delete_cases(oTree,
                       pcodes = deletionlist,
                       reason = "requested")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Show information on all deleted cases (also dropouts):
oTree2$info$deleted_cases$full

# Save one variable
oTree2 &lt;- delete_cases(oTree,
  pcodes = deletionlist,
  reason = "requested",
  saved_vars = "participant._index_in_pages")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Save some variables
oTree2 &lt;- delete_cases(oTree,
  pcodes = deletionlist,
  reason = "requested",
  saved_vars = c(
    "participant._index_in_pages",
    "participant._max_page_index"))

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Get a list of all deleted cases
# (If there is already a list, the new list is added to it)
oTree2$info$deleted_cases$codes

# Show number of all deleted cases
length(oTree2$info$deleted_cases$codes)
oTree2$info$deleted_cases$count
</code></pre>

<hr>
<h2 id='delete_dropouts'>Delete dropouts</h2><span id='topic+delete_dropouts'></span>

<h3>Description</h3>

<p>Delete the data of all participants who did not end the experiment at (a)
certain page(s) and/or app(s).
</p>
<p>Caution 1: This function does not delete cases from the original CSV and
Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports if the
custom exports do not have a variable named <code>participant.code</code> and 
a variable named <code>session.code</code>!
</p>
<p>Caution 3: This function does not delete any data from 
the <code>$Chats</code> data frame!
(As the interpretation of chat data depends on how participants engage with
each other, the data must be deleted with more care than deleting data in
other apps. Hence, this function does not delete data in this data frame.
Please do this manually if necessary!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_dropouts(
  oTree,
  final_apps = NULL,
  final_pages = NULL,
  saved_vars = NULL,
  inconsistent = NULL,
  reason = "ENC",
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_dropouts_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code></p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases 
in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_inconsistent">inconsistent</code></td>
<td>
<p>Character. Should the function continue or be stopped if
at least one participant has inconsistent end_pages, inconsistent end_apps,
or both? To continue, type <code>"yes"</code>,
to stop the function, type <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_dropouts_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the dropout 
deletion process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of data frames
but without the deleted cases.
</p>
<p>It adds information on the deleted cases to <code>$info$deleted_cases</code>. (This
list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>- <code>$full</code> = A data frame that contains information
on all participants who did not finish the study;
it shows their participant codes, the names of the apps in which they
left the experiment,
the names of the pages in which they left the experiment,
the names of the app data frames in which this information was found, and
the dropout reason (<code>"ENC"</code>, experiment not completed, combined
with the name of the data frame in which the dropout was observed).
Because participants usually appear in multiple app data frames,
the <code>$info$deleted_cases$full</code> data frame may contain several entries
for each person.
</p>
<p>- <code>$unique</code> = A data frame that contains similar information as
the <code>$full</code> data frame but with only one row per participant and 
no information on the data frame in which the dropout was observed.
</p>
<p>- <code>$all_end</code> = A table that provides information on the app and page
combinations where participants ended the experiment. 
This table also includes information for participants who did not drop out 
of the experiment.
The <code>$all_end</code> table is only shown if an <code>$all_apps_wide</code> data 
frame exists.
</p>
<p>- <code>$codes</code> = A vector containing the participant codes of
all deleted participants.
</p>
<p>- <code>$count</code> = The number of all deleted participants.
</p>
<p>It is important to note that if only the argument <code>final_pages</code> is set,
this function does not distinguish between page names that reoccur in
different apps.
</p>
<p>If the columns <code>end_app</code> and <code>end_page</code> in the output are empty,
these variables were not saved by oTree for the specific participants.
This could be because empty rows were not deleted. This can be done
by using the argument <code>del_empty = TRUE</code> when 
using <code><a href="#topic+import_otree">import_otree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete all cases that didn't end the experiment on the page "Demographics"
# within the app "survey"
oTree2 &lt;- delete_dropouts(oTree,
                         final_apps = c("survey"),
                         final_pages = c("Demographics"))

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete all cases that didn't end the experiment on the page "Demographics"
# This page can be in any app
oTree2 &lt;- delete_dropouts(oTree, final_pages = "Demographics")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete all cases that didn't end the experiment on
# any page in the app "survey"
oTree &lt;- delete_dropouts(oTree, final_apps = "survey")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Get list of information on all deleted cases
# (If there is already a list, the new list is added to it!)
oTree2$info$deleted_cases
</code></pre>

<hr>
<h2 id='delete_duplicate'>Delete duplicate data</h2><span id='topic+delete_duplicate'></span>

<h3>Description</h3>

<p>Delete duplicate rows from all oTree app data frames 
and <code>$all_apps_wide</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_duplicate(oTree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_duplicate_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree
list of data frames but without duplicate rows in all app data
frames and <code>$all_apps_wide</code>. This function has no effect on the data
frames <code>$Time</code> and <code>$Chats</code>.
</p>
<p>This function does NOT add information to <code>$info$deleted_cases</code>,
because it does not delete any important information but only
cleans up a messy data import.
</p>
<p>However, the function adjusts <code>$info$initial_n</code>, if 
an <code>$all_apps_wide</code> data frame exists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete duplicate rows
oTree &lt;- delete_duplicate(oTree)

# Show row numbers again
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

</code></pre>

<hr>
<h2 id='delete_plabels'>Delete participant labels in all apps</h2><span id='topic+delete_plabels'></span>

<h3>Description</h3>

<p>If you work with MTurk, the MTurk IDs will be stored in the
participant labels variable.
This function deletes this variable in <code>$all_apps_wide</code> 
and every app data frame in the list of data frames that was created 
by <code><a href="#topic+import_otree">import_otree</a></code> and/or all
variables referring to MTurk, such as <code>participant.mturk_worker_id</code>.
</p>
<p>Caution: This function does not delete the variables from the original
CSV and Excel files!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_plabels(oTree, del_plabel = TRUE, del_mturk = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_plabels_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="delete_plabels_+3A_del_plabel">del_plabel</code></td>
<td>
<p>Logical. <code>TRUE</code> if all participant labels
should be deleted.</p>
</td></tr>
<tr><td><code id="delete_plabels_+3A_del_mturk">del_mturk</code></td>
<td>
<p>Logical. <code>TRUE</code> if all MTurk variables 
should be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that do not include the participant labels and/or the MTurk
variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show participant labels
oTree$all_apps_wide$participant.label
oTree$survey$participant.label

# Delete all participant labels
oTree2 &lt;- delete_plabels(oTree)

# Show participant labels again
oTree2$all_apps_wide$participant.label
oTree2$survey$participant.label
</code></pre>

<hr>
<h2 id='delete_sessions'>Delete all cases of one session</h2><span id='topic+delete_sessions'></span>

<h3>Description</h3>

<p>Delete cases from specific sessions in all data frames in the
oTree list of data frames.
</p>
<p>Caution 1: This function does not delete cases from the
original CSV and Excel files!
</p>
<p>Caution 2: This function does not delete cases from custom exports if the
custom exports do not have a variable named <code>participant.code</code> 
and a variable named <code>session.code</code>!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_sessions(oTree, scodes, saved_vars = NULL, reason, info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_sessions_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_scodes">scodes</code></td>
<td>
<p>Character. The session.code(s) of the
session(s) whose data should be removed.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_saved_vars">saved_vars</code></td>
<td>
<p>Character. The name(s) of variable(s) that need(s) to be
stored in the list of information on deleted cases 
in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_reason">reason</code></td>
<td>
<p>Character. The reason for deletion that should be stored in
the list of information on deleted cases in <code>$info$deleted_cases</code>.</p>
</td></tr>
<tr><td><code id="delete_sessions_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the session
deletion process should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that do not include the deleted sessions.
</p>
<p>It adds information on the deleted cases to <code>$info$deleted_cases</code>. 
(This list is also filled by other functions.)
</p>
<p>In this list, you can find the following information:
</p>
<p>- <code>$full</code> and <code>$unique</code> = The data frames <code>$full</code> 
and <code>$unique</code> contain
information on all participants
whose data were deleted. The entries to the <code>$full</code> 
and the <code>$unique</code> data
frames in this list are the same. Columns <code>end_app</code> 
and <code>end_page</code> are left
empty intentionally because they are only filled by 
the <code><a href="#topic+delete_dropouts">delete_dropouts</a></code>
function. Columns <code>participant.code</code> and <code>reason</code> are filled.
</p>
<p>- <code>$codes</code> = A vector containing the participant codes of
all deleted participants.
</p>
<p>- <code>$count</code> = The number of all deleted participants.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# First, show some row numbers
print(paste(nrow(oTree$all_apps_wide), nrow(oTree$survey),
nrow(oTree$Time), nrow(oTree$Chats)))

# Delete one session
oTree2 &lt;- delete_sessions(oTree,
  scodes = "7bfqtokx",
  reason = "Only tests")

# Show row numbers
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))

# Delete two sessions
oTree2 &lt;- delete_sessions(oTree,
  scodes = c("7bfqtokx", "vd1h01iv"),
  reason = "Only tests")

# Show row numbers again
print(paste(nrow(oTree2$all_apps_wide), nrow(oTree2$survey),
nrow(oTree2$Time), nrow(oTree2$Chats)))
</code></pre>

<hr>
<h2 id='extime'>Calculate the time that was spent on the whole experiment</h2><span id='topic+extime'></span>

<h3>Description</h3>

<p>Calculate the time spent on the experiment.
If not stated otherwise, the calculation only starts at the end of
the first page!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extime(
  oTree,
  pcode = NULL,
  plabel = NULL,
  group_id = NULL,
  seconds = FALSE,
  rounded = TRUE,
  digits = 2L,
  startat = 1L,
  tz = "UTC",
  sinfo = "session_code",
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extime_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="extime_+3A_pcode">pcode</code></td>
<td>
<p>Character. The value of the <code>participant.code</code> 
variable if the time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="extime_+3A_plabel">plabel</code></td>
<td>
<p>Character. The value of the <code>participant.label</code> variable 
if the time should only be calculated for one specified participant.</p>
</td></tr>
<tr><td><code id="extime_+3A_group_id">group_id</code></td>
<td>
<p>Integer. The value of the group_id variable if the
time should only be calculated for one specified group. The <code>group_id</code>
variable can be created with <code><a href="#topic+make_ids">make_ids</a></code>.</p>
</td></tr>
<tr><td><code id="extime_+3A_seconds">seconds</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be in seconds 
instead of minutes.</p>
</td></tr>
<tr><td><code id="extime_+3A_rounded">rounded</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be rounded.</p>
</td></tr>
<tr><td><code id="extime_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits to which the output
should be rounded.
This parameter has no effect unless <code>rounded = TRUE</code>.</p>
</td></tr>
<tr><td><code id="extime_+3A_startat">startat</code></td>
<td>
<p>Integer or character string <code>"real"</code>
Whether the start of the experiment should be taken from the time at
a certain index of each person's vector of page_indexes in
the <code>$Time</code> data frame or from the <code>time_started</code>
variable in <code>$all_apps_wide</code> (<code>"real"</code>). Important: If integer,
it represents the position within the page index sequence,
not the numeric value of the <code>page_index</code> variable.</p>
</td></tr>
<tr><td><code id="extime_+3A_tz">tz</code></td>
<td>
<p>Character. Time zone.</p>
</td></tr>
<tr><td><code id="extime_+3A_sinfo">sinfo</code></td>
<td>
<p>Character. <code>"session_id"</code> to use session ID for
additional information in the data frame
of single durations, <code>"session_code"</code> to use session codes,
or <code>NULL</code> if no session column should be shown.</p>
</td></tr>
<tr><td><code id="extime_+3A_combine">combine</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to epoch time 
should be merged, and all variables referring to participant code should
be merged in case data of several versions of oTree are used. 
If <code>FALSE</code>,
the function returns an error if several oTree versions' data are present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions calculates the time spent on the experiment by using
the variable that refers to the time stamp. If that variable is not
present, the function alternatively uses <code>seconds_on_page2</code>, 
which can be created with the <code><a href="#topic+pagesec">pagesec</a></code> function.
</p>


<h3>Value</h3>

<p>This function returns either a single value if only the data of one person
is calculated or a list of information on the time several participants
spent on the experiment.
</p>
<p>In this list, you can find the following information:
</p>
<p>- <code>$mean_duration</code> = The experiment's average duration.
</p>
<p>- <code>$min_duration</code> = The experiment's minimum duration.
</p>
<p>- <code>$max_duration</code> = The experiment's maximum duration.
</p>
<p>- <code>$single_durations</code> = A data frame of all durations that
are used for calculating the min, max, and mean duration.
</p>
<p>- <code>$messages</code> = All important notes to the calculations.
</p>
<p>- <code>$only_one_page</code> = A vector of all individuals who 
only have one time stamp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show time for one participant
extime(oTree, pcode = "wk247s9w")

# Make a data frame of durations
extime(oTree)

# Make a data frame of durations (beginning from the end of the second page)
extime(oTree, startat = 2)
</code></pre>

<hr>
<h2 id='import_otree'>Import oTree data</h2><span id='topic+import_otree'></span>

<h3>Description</h3>

<p>Import data files that were created by oTree.
All files containing the pattern YYYY-MM-DD at the end
of their file names are considered oTree files.
Bot outputs are saved by oTree without the date included. Hence, to
import bot data, you must either rename the original bot files
using the YYYY-MM-DD format or use the argument <code>onlybots = TRUE</code>.
By using the second option, only data of bot files are imported.
</p>
<p>Caution! Data can be downloaded from within the
session and globally at the same time. If both files are downloaded,
this can lead to the <code>$all_apps_wide</code> data being there twice! You can 
remove duplicate data by using <code><a href="#topic+delete_duplicate">delete_duplicate</a></code>.
</p>
<p>Caution! When importing Excel files, this function does not check
for erroneous data structures
and will combine all data frames with the same file name patterns.
Before using the <code>CSV = FALSE</code> argument, 
clean up your data appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_otree(
  path = ".",
  file_names = NULL,
  final_apps = NULL,
  final_pages = NULL,
  recursive = TRUE,
  csv = TRUE,
  onlybots = FALSE,
  del_empty = TRUE,
  info = FALSE,
  encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_otree_+3A_path">path</code></td>
<td>
<p>Character. The path to the files (default is the
working directory).</p>
</td></tr>
<tr><td><code id="import_otree_+3A_file_names">file_names</code></td>
<td>
<p>Character. The name(s) of the file(s) to be imported.
If not specified, all files in the path and subfolders are imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment. If the argument final_apps is left empty, you can still call
for deleting the participants who did not finish the experiment
with <code><a href="#topic+delete_dropouts">delete_dropouts</a></code>.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment. If the argument final_pages is left empty, you can still
call for deleting the participants who did not finish the experiment
with <code><a href="#topic+delete_dropouts">delete_dropouts</a></code>.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_recursive">recursive</code></td>
<td>
<p>Logical. <code>TRUE</code> if the files in the path's
subfolders should also be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_csv">csv</code></td>
<td>
<p>Logical. <code>TRUE</code> if only CSV files should be 
imported. <code>FALSE</code> if only Excel files should be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_onlybots">onlybots</code></td>
<td>
<p>Logical. <code>TRUE</code> if only bot-created files 
should be imported.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_del_empty">del_empty</code></td>
<td>
<p>Logical. <code>TRUE</code> if all empty cases should be deleted 
from the <code>$all_apps_wide</code> or normal app data frames (not Time or Chats).</p>
</td></tr>
<tr><td><code id="import_otree_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the data 
import should be printed.</p>
</td></tr>
<tr><td><code id="import_otree_+3A_encoding">encoding</code></td>
<td>
<p>Character. Encoding of the CSV files that are imported.
Default is <code>"UTF-8"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frames (one data frame for each app 
and <code>$all_apps_wide</code>) and a list of information on this list 
of data frames in <code>$info</code>.
</p>
<p>See detailed information on the imported files 
in <code>$info$imported_files</code>.
</p>
<p>If <code>$all_apps_wide</code> is imported, see the number of imported cases
in <code>$info$initial_n</code>. In this number, empty rows are
already considered. So, if empty rows are deleted 
with <code>del_empty=TRUE</code>, <code>initial_n</code> 
counts all rows that are not empty.
Cases that are deleted because the participants did not make it to the
last page and/or app are not subtracted from this number.
</p>
<p>Information: Empty rows are rows without 
the <code>participant._current_app_name</code>
variable set. Empty rows are deleted from all app data frames
and <code>$all_apps_wide</code> when using <code>del_empty = TRUE</code>. Empty rows in 
the <code>$Chats</code> and <code>$Time</code> data frames are not deleted.
</p>
<p>If old and new oTree versions are combined, the <code>$Time</code> data frame 
contains variables called <code>participant_code</code> 
and <code>participant__code</code> (the difference is in the underscores).
Caution! If there is an unusual amount of <code>NA</code>s,
check if everything got imported correctly.
Sometimes, the CSV or Excel file may be corrupted, and all information is
only found in one column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()

# Show the structure of the import
str(oTree, max.level = 1)

# Show the names of all imported files
oTree$info$imported_files

# Delete empty cases and delete every case of a person
# who didn't end the experiment in the app "survey"
oTree &lt;- import_otree(
  del_empty = TRUE,
  final_apps = "survey",
  info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import bot files
import_otree(
  path = "./bot_data",
  onlybots = TRUE,
  csv = TRUE,
  info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import with file names (path separately)
oTree2 &lt;- import_otree(
     del_empty = TRUE,
     path = "./exp_data",
     file_names = c("all_apps_wide-2023-03-27.csv",
                   "ChatMessages-2023-03-27.csv",
                   "PageTimes-2023-03-27.csv"),
     onlybots = FALSE,
     csv = TRUE,
     info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)

# Import with file names (without path separately)
oTree2 &lt;- import_otree(
     del_empty = TRUE,
     file_names = c("exp_data/all_apps_wide-2023-03-27.csv",
                   "exp_data/ChatMessages-2023-03-27.csv",
                   "exp_data/PageTimes-2023-03-27.csv"),
     onlybots = FALSE,
     csv = TRUE,
     info = TRUE)

# Show the structure of the import
str(oTree, max.level = 1)
})

</code></pre>

<hr>
<h2 id='make_ids'>Make IDs</h2><span id='topic+make_ids'></span>

<h3>Description</h3>

<p>Make session IDs and, optionally, group IDs and participant IDs
that span across all data frames created by <code><a href="#topic+import_otree">import_otree</a></code>. 
Information for these IDs is taken from <code>$all_apps_wide</code>
but can be defined otherwise.
</p>
<p>Note: Older versions of oTree may already contain a
variable called session_id in their <code>$Time</code> data frames.
This variable is overwritten by this function!
</p>
<p>Important: Combine duplicate data before running this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ids(
  oTree,
  gmake = FALSE,
  pmake = TRUE,
  from_app = "all_apps_wide",
  from_var = NULL,
  sstart = 1L,
  gstart = 1L,
  pstart = 1L,
  emptyrows = NULL,
  icw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ids_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_gmake">gmake</code></td>
<td>
<p>Logical. <code>TRUE</code> if a variable 
called group_id should be made.
If from_var is not <code>NULL</code>, gmake is automatically set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_pmake">pmake</code></td>
<td>
<p>Logical. <code>TRUE</code> if a variable called <code>participant_id</code>
should be made.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_from_app">from_app</code></td>
<td>
<p>Character. Name of the data frame from which the session,
group, and participant information should be taken.
All normal app data frames and <code>$all_apps_wide</code> are allowed.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_from_var">from_var</code></td>
<td>
<p>Character. Name of the variable from which the group
information should be taken. This argument is only relevant
when <code>$all_apps_wide</code> is used as from_app and has group information 
that contradicts each other.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_sstart">sstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for session IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_gstart">gstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for group IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_pstart">pstart</code></td>
<td>
<p>Integer.
The number that serves as a starting point for participant IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_emptyrows">emptyrows</code></td>
<td>
<p>Character. <code>"no"</code> if the function should stop if 
there are empty rows in from_app. <code>"yes"</code> if the function should 
continue to make IDs.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_icw">icw</code></td>
<td>
<p>Logical. <code>TRUE</code> if the warning message should be
ignored that states that IDs cannot be made because of an oTree bug.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ID variables are made in <code>$all_apps_wide</code>, all app data frames,
the <code>$Time</code> data frame, and the <code>$Chats</code> data frame.
See list of the additional ID variables in <code>$info$additional_variables</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Make session IDs only
oTree2 &lt;- make_ids(oTree)

# Show new variables
oTree2$all_apps_wide$session_id

# Make session IDs and group IDs
# Not working with this data set because group ID is not the same in all apps
## Not run: 
      oTree2 &lt;- make_ids(oTree, gmake = TRUE)

      # Show new variables
      oTree2$all_apps_wide$session_id
      oTree2$all_apps_wide$group_id

## End(Not run)

# Get IDs from variable "dictator.1.group.id_in_subsession"
# in the data frame "all_apps_wide"
oTree2 &lt;- make_ids(oTree,
                   gmake = TRUE,
                   from_var = "dictator.1.group.id_in_subsession")

# Show new variables
oTree2$all_apps_wide$session_id
oTree2$all_apps_wide$group_id

# Get IDs from another app than all_apps_wide
oTree2 &lt;- make_ids(oTree, gmake = TRUE, from_app = "dictator")

# Show new variables
oTree2$all_apps_wide$session_id
oTree2$all_apps_wide$group_id
</code></pre>

<hr>
<h2 id='messy_chat'>Check if the Chats data frame is messy</h2><span id='topic+messy_chat'></span>

<h3>Description</h3>

<p>Check if the <code>$Chats</code> data frame includes both
session-related variables and participant-related variables that
appear multiple times. This may occur when data from different
oTree versions, which use different variable names, are combined.
</p>
<p>If desired, the function can merge these variables,
storing the data using the newer oTree version's variable names
and removing the outdated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_chat(
  oTree,
  combine = FALSE,
  session = TRUE,
  participant = TRUE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messy_chat_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_combine">combine</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to
the session code should be merged and/or all variables referring
to participant code should be merged in case data of several versions
of oTree are used.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_session">session</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to the session 
code should be checked and merged. Merging only works 
if <code>combine = TRUE</code>.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_participant">participant</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to the
participant code should be checked and merged. Merging only works 
if <code>combine = TRUE</code>.</p>
</td></tr>
<tr><td><code id="messy_chat_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the process should
be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function searches for multiple variables related to the session code 
or the participant code in the <code>$Chats</code> data frame.
which can occur when data from both old and new oTree versions are used.
</p>
<p>If <code>combine = FALSE</code>, the function will throw an error 
if such variables are found.
</p>
<p>If <code>combine = TRUE</code>, the function will not throw an error
if such variables are found.
Instead, it automatically combines the variables into new variables 
and adds them to the original <code>$Chats</code> data frame. 
This function then returns a duplicate of the original oTree list but
with the <code>$Chats</code> data frame modified.
</p>
<p>The new variables are called
<code>participant_code</code> and <code>session_code</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# Show all Chats column names
print(colnames(oTree$Chats))

# Run function
oTree &lt;- messy_chat(oTree, combine = TRUE)

# Show all Chats column names again
print(colnames(oTree$Chats))

</code></pre>

<hr>
<h2 id='messy_time'>Check if the Time data frame is messy</h2><span id='topic+messy_time'></span>

<h3>Description</h3>

<p>Checks if the Time data frame includes both participant-related variables
and time stamp variables that appear multiple times. This may occur when
data from different oTree versions, which use different variable names,
are combined.
</p>
<p>If desired, the function can merge these variables,
storing the data using the newer oTree version's variable names
and removing the outdated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_time(
  oTree,
  combine = FALSE,
  epoch_time = TRUE,
  participant = TRUE,
  info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messy_time_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_combine">combine</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to epoch time 
should be merged and/or all variables referring to participant code should be merged
in case data of several versions of oTree are used.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_epoch_time">epoch_time</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to the time
stamp should be checked and merged. Only works if <code>combine = TRUE</code>.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_participant">participant</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to the
participant code should be checked and merged. 
Only works if <code>combine = TRUE</code>.</p>
</td></tr>
<tr><td><code id="messy_time_+3A_info">info</code></td>
<td>
<p>Logical. <code>TRUE</code> if a brief information on the process should
be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function searches for multiple variables related to the time stamp 
or the participant code in the <code>$Time</code> data frame,
which can occur when data from both old and new oTree versions are used.
</p>
<p>If <code>combine = FALSE</code>, the function will throw an error 
if such variables are found.
</p>
<p>If <code>combine = TRUE</code>, the function will not throw an error
if such variables are found.
Instead, it automatically combines the variables into new variables 
and adds them to the original <code>$Time</code> data frame. 
This function then returns a duplicate of the original oTree list but
with the <code>$Time</code> data frame modified.
</p>
<p>The new variables are
called <code>epoch_time_completed</code> and <code>participant_code</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set data folder first
withr::with_dir(system.file("extdata", package = "gmoTree"), {

# Import all oTree files in this folder and its subfolders
oTree &lt;- import_otree()
})

# Show all Time column names
print(colnames(oTree$Time))

# Run function
oTree &lt;- messy_time(oTree, combine = TRUE)

# Show all Time column names again
print(colnames(oTree$Time))

</code></pre>

<hr>
<h2 id='oTree'>Sample experiment data</h2><span id='topic+oTree'></span>

<h3>Description</h3>

<p>Sample experiment data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oTree
</code></pre>


<h3>Format</h3>

<p>A list of data frames created by import_otree().
</p>


<h3>Source</h3>

<p>The data set was created by using modified versions of the official
oTree sample experiments that can be downloaded when installing oTree.
In detail, the following apps were used: 
&quot;start,&quot; &quot;dictator,&quot; &quot;chatapp,&quot; &quot;survey.&quot;
</p>

<hr>
<h2 id='pagesec'>Calculate the seconds spent on each page</h2><span id='topic+pagesec'></span>

<h3>Description</h3>

<p>Create a new variable in the <code>$Time</code> data frame that contains the time
spent on each page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagesec(oTree, rounded = TRUE, digits = 2, minutes = FALSE, combine = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagesec_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_rounded">rounded</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be rounded.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits to which the
output should be rounded.
This parameter has no effect unless <code>rounded = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_minutes">minutes</code></td>
<td>
<p>Logical. <code>TRUE</code> if the output should be
minutes instead of seconds.</p>
</td></tr>
<tr><td><code id="pagesec_+3A_combine">combine</code></td>
<td>
<p>Logical. <code>TRUE</code> if all variables referring to epoch time 
should be merged, and all variables referring to participant code should be
merged in case data of several versions of oTree are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a duplicate of the original oTree list of
data frames that also contains a column in the <code>$Time</code> data frame
named <code>seconds_on_page2</code> or <code>minutes_on_page</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Create two new columns: seconds_on_page2 and minutes_on_page
oTree &lt;- pagesec(oTree, rounded = TRUE, minutes = TRUE)

# Show the Time data frame
head(oTree$Time, n = 30)
</code></pre>

<hr>
<h2 id='show_constant'>Show constant columns</h2><span id='topic+show_constant'></span>

<h3>Description</h3>

<p>Show all columns with no variation in their values for each data frame
in the oTree list of data frames (except the ones in the info list).
This function is helpful before running an experiment to check if there
are unnecessary variables.
You can check for columns that have any unchanging possible value
or for columns containing only a specific value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_constant(oTree, value = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_constant_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="show_constant_+3A_value">value</code></td>
<td>
<p>The value that is controlled to be the same within a column.
If the value is set to <code>"any"</code>, the function checks for
columns where any possible values are identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of vectors, one for each app,
<code>$all_apps_wide</code>, the <code>$Time</code> and/or the <code>$Chats</code> data frame.
Each vector contains the names of all variables with constant values.
If there are no variables with constant values, the vector is empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show all columns that contain only NAs
show_constant(oTree = oTree)
show_constant(oTree = oTree, value = NA)

# Show all columns that contain only -99
show_constant(oTree = oTree, value = -99)
</code></pre>

<hr>
<h2 id='show_dropouts'>Show participants who did not finish the experiment</h2><span id='topic+show_dropouts'></span>

<h3>Description</h3>

<p>Show information on the people who did not finish the experiment at (a)
certain page(s) and/or app(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_dropouts(oTree, final_apps = NULL, final_pages = NULL, saved_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_dropouts_+3A_otree">oTree</code></td>
<td>
<p>A list of data frames that were created 
by <code><a href="#topic+import_otree">import_otree</a></code>.</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_final_apps">final_apps</code></td>
<td>
<p>Character.
The name(s) of the app(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_final_pages">final_pages</code></td>
<td>
<p>Character.
The name(s) of the page(s) at which the participants have to finish the
experiment.</p>
</td></tr>
<tr><td><code id="show_dropouts_+3A_saved_vars">saved_vars</code></td>
<td>
<p>The name(s) of variable(s) that need(s) to be
shown in the list of information on dropout cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of information on participants who did not
finish the experiment.
</p>
<p>In this list, you can find the following information:
</p>
<p>- <code>$full</code> = A data frame that contains information
on all participants who did not finish the study;
it shows their participant codes, the names of the apps in which they
left the experiment,
the names of the pages in which they left the experiment,
the names of the app data frames in which this information was found, and
the dropout reason (<code>"ENC"</code>, experiment not completed, combined
with the name of the data frame in which the dropout was observed).
Because participants usually appear in multiple app data frames,
the <code>$full</code> data frame may contain several entries for
each person.
</p>
<p>- <code>$unique</code> = A data frame that contains similar information as 
the <code>$full</code> data frame but with only one row per participant and 
no information on the data frame in which the dropout was observed.
</p>
<p>- <code>$all_end</code> = A table that provides information 
on the app and page combinations
where participants ended the experiment. This table also includes
information on participants who did not drop out of the experiment.
The <code>$all_end</code> table is only shown if an <code>$all_apps_wide</code> 
data frame exists.
</p>
<p>- <code>$codes</code> = A vector containing the participant codes of
all participants who did not finish the experiment.
</p>
<p>- <code>$count</code> = The number of all participants who did not 
finish the experiment.
</p>
<p>It is important to note that if only the argument <code>final_pages</code> is set,
this function does not distinguish between page names that reoccur in
different apps.
</p>
<p>If the columns <code>end_app</code> and <code>end_page</code> in the output are empty,
these variables were not saved by oTree for the specific participants.
This could be because empty rows were not deleted. This can be done
by using the argument <code>del_empty = TRUE</code>&quot; when 
using <code><a href="#topic+import_otree">import_otree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use package-internal list of oTree data frames
oTree &lt;- gmoTree::oTree

# Show everyone who did not finish with the app "survey"
show_dropouts(oTree, final_apps = "survey")

# Show everyone who did not finish with the page "Demographics"
show_dropouts(oTree, final_pages = "Demographics")

# Show everyone who finished with the following apps: "survey," "dictator"
final_apps &lt;- unique(oTree$all_apps_wide$participant._current_app_name)
final_apps &lt;- final_apps[final_apps != "survey"]
final_apps &lt;- final_apps[final_apps != "dictator"]
show_dropouts(oTree, final_apps = final_apps)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
