<!DOCTYPE html><html><head><title>Help for package xegaPopulation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaPopulation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AcceptBest'><p>Accepts only genes with equal or better fitness.</p></a></li>
<li><a href='#AcceptFactory'><p>Configure the acceptance function of a genetic algorithm.</p></a></li>
<li><a href='#AcceptIVMetropolis'><p>Individually Adaptive Metropolis Acceptance Rule.</p></a></li>
<li><a href='#AcceptMetropolis'><p>Metropolis Acceptance Rule.</p></a></li>
<li><a href='#AcceptNewGene'><p>Accepts a new gene.</p></a></li>
<li><a href='#ApplyFactory'><p>Configure the the execution model for gene evaluation.</p></a></li>
<li><a href='#ConstCRate'><p>Constant crossover rate.</p></a></li>
<li><a href='#ConstMRate'><p>Constant mutation rate.</p></a></li>
<li><a href='#CoolingFactory'><p>Configure the cooling schedule of the acceptance</p>
function of a genetic algorithm.</a></li>
<li><a href='#Cross2Gene'><p>Import for examples.</p></a></li>
<li><a href='#CrossGene'><p>Import for examples.</p></a></li>
<li><a href='#CrossRateFactory'><p>Configure the crossover function of a genetic algorithm.</p></a></li>
<li><a href='#ExponentialAdditiveCooling'><p>Exponential additive cooling.</p></a></li>
<li><a href='#ExponentialMultiplicativeCooling'><p>Exponential multiplicative cooling.</p></a></li>
<li><a href='#futureLapply'><p>Future apply of R-package <code>future.apply</code>.</p></a></li>
<li><a href='#IACRate'><p>Individually adaptive crossover rate.</p></a></li>
<li><a href='#IAMBitRate'><p>Individually adaptive mutation rate. (Bit mutation Rate)</p></a></li>
<li><a href='#IAMRate'><p>Individually adaptive mutation rate.</p></a></li>
<li><a href='#InitGene'><p>Import for examples.</p></a></li>
<li><a href='#lFxegaGaGene'><p>Import for examples.</p></a></li>
<li><a href='#LogarithmicMultiplicativeCooling'><p>Logarithmic multiplicative cooling.</p></a></li>
<li><a href='#MClapply'><p>MultiCore apply of library parallel.</p></a></li>
<li><a href='#MetropolisAcceptanceProbability'><p>Metropolis acceptance probability.</p></a></li>
<li><a href='#MetropolisTable'><p>Metropolis acceptance probability table.</p></a></li>
<li><a href='#MutationRateFactory'><p>Configure the mutation rate function of a genetic algorithm.</p></a></li>
<li><a href='#PowerAdditiveCooling'><p>Power additive cooling.</p></a></li>
<li><a href='#PowerMultiplicativeCooling'><p>Power multiplicative cooling.</p></a></li>
<li><a href='#PparLapply'><p>uses parLapply of library parallel for using workers on</p>
machines in a local network.</a></li>
<li><a href='#ReplicateGene'><p>Import for examples.</p></a></li>
<li><a href='#TrigonometricAdditiveCooling'><p>Trigonometric additive cooling.</p></a></li>
<li><a href='#xegaBestGeneInPopulation'><p>Extracts indices of best genes in population.</p></a></li>
<li><a href='#xegaBestInPopulation'><p>Best solution in the population.</p></a></li>
<li><a href='#xegaConfiguration'><p>Remembers R command command with which algorithm has been called.</p></a></li>
<li><a href='#xegaEvalPopulation'><p>Evaluates a population of genes in a a problem environment</p></a></li>
<li><a href='#xegaInitPopulation'><p>Initializes a population of genes.</p></a></li>
<li><a href='#xegaLogEvalsPopulation'><p>Combine fitness, generations, and the phentype of the gene.</p></a></li>
<li><a href='#xegaNextPopulation'><p>Computes the next population of genes.</p></a></li>
<li><a href='#xegaObservePopulation'><p>Observe summary statistics of the fitness of the population.</p></a></li>
<li><a href='#xegaPopulation'><p>Package xegaPopulation.</p></a></li>
<li><a href='#xegaSummaryPopulation'><p>Provide elementary summary statistics of the fitness of the population.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Genetic Population Level Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>This collection of gene representation-independent functions 
   implements the population layer of extended evolutionary and genetic 
   algorithms and its support. The population layer consists of functions 
   for initializing, logging, observing, evaluating a population of genes, 
   as well as of computing the next population. For parallel evaluation of a 
   population of genes 4 execution models - named Sequential, MultiCore, 
   FutureApply, and Cluster - are provided. They are implemented by 
   configuring the lapply() function. The execution model FutureApply can be 
   externally configured as recommended by Bengtsson (2021) 
   &lt;<a href="https://doi.org/10.32614%2FRJ-2021-048">doi:10.32614/RJ-2021-048</a>&gt;. Configurable acceptance rules and cooling 
   schedules (see Kirkpatrick, S., Gelatt, C. D. J, and Vecchi, M. P. (1983) 
   &lt;<a href="https://doi.org/10.1126%2Fscience.220.4598.671">doi:10.1126/science.220.4598.671</a>&gt;, and Aarts, E., and Korst, J. 
   (1989, ISBN:0-471-92146-7) offer simulated annealing or greedy randomized 
   approximate search procedure elements. Adaptive crossover and mutation 
   rates depending on population statistics generalize the approach of 
   Stanhope, S. A. and Daida, J. M. (1996, ISBN:0-18-201-031-7). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaPopulation&amp;gt;">https://github.com/ageyerschulz/xegaPopulation&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), parallel, future.apply, utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), future, parallelly</td>
</tr>
<tr>
<td>Imports:</td>
<td>xegaGaGene, xegaSelectGene</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 15:06:25 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AcceptBest'>Accepts only genes with equal or better fitness.</h2><span id='topic+AcceptBest'></span>

<h3>Description</h3>

<p>Change the gene by a genetic operator pipeline 
and return the new gene only if the new gene 
has at least the same fitness as the gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcceptBest(OperatorPipeline, gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AcceptBest_+3A_operatorpipeline">OperatorPipeline</code></td>
<td>
<p>Genetic operator pipeline.</p>
</td></tr>
<tr><td><code id="AcceptBest_+3A_gene">gene</code></td>
<td>
<p>Gene.</p>
</td></tr>
<tr><td><code id="AcceptBest_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitness of genes never decreases.
New genes with inferior fitness do not survive.
</p>


<h3>Value</h3>

<p>The new gene, if it is at least as fit as <code>gene</code> else
the old gene <code>gene</code>.
</p>


<h3>See Also</h3>

<p>Other Acceptance Rule: 
<code><a href="#topic+AcceptIVMetropolis">AcceptIVMetropolis</a>()</code>,
<code><a href="#topic+AcceptMetropolis">AcceptMetropolis</a>()</code>,
<code><a href="#topic+AcceptNewGene">AcceptNewGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OPpipe1&lt;-function(g, lF){InitGene(lF)}
g1&lt;-lFxegaGaGene$EvalGene(InitGene(lFxegaGaGene), lFxegaGaGene)
g2&lt;-AcceptBest(OPpipe1, g1, lFxegaGaGene)
identical(g1, g2)
</code></pre>

<hr>
<h2 id='AcceptFactory'>Configure the acceptance function of a genetic algorithm.</h2><span id='topic+AcceptFactory'></span>

<h3>Description</h3>

<p><code>AcceptanceFactory()</code> implements selection
of an acceptance rule.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;All&quot; returns <code>AcceptNewGene()</code> (Default).
</p>
</li>
<li><p> &quot;Best&quot; returns <code>AcceptBest()</code>.
</p>
</li>
<li><p> &quot;Metropolis&quot; returns <code>AcceptMetropolis()</code>.
</p>
</li>
<li><p> &quot;IVMetropolis&quot; returns <code>AcceptIVMetropolis()</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>AcceptFactory(method = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AcceptFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the acceptance rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An acceptance rule for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+ApplyFactory">ApplyFactory</a>()</code>,
<code><a href="#topic+CoolingFactory">CoolingFactory</a>()</code>,
<code><a href="#topic+CrossRateFactory">CrossRateFactory</a>()</code>,
<code><a href="#topic+MutationRateFactory">MutationRateFactory</a>()</code>,
<code><a href="#topic+xegaConfiguration">xegaConfiguration</a>()</code>
</p>

<hr>
<h2 id='AcceptIVMetropolis'>Individually Adaptive Metropolis Acceptance Rule.</h2><span id='topic+AcceptIVMetropolis'></span>

<h3>Description</h3>

<p>Change the gene by a genetic operator pipeline.
Always accept new genes with fitness improvement.
For maximizing fitness
accept genes with lower fitness with probability
<code>(runif(1)&lt;exp(-(fitness-newfitness)*beta/Temperature)</code>
and reduce temperature with a cooling schedule.
For each gene, the temperature is corrected upward by a term 
whose size is proportional to 
the difference between the fitness of the current best gene 
in the population and the fitness of the gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcceptIVMetropolis(OperatorPipeline, gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AcceptIVMetropolis_+3A_operatorpipeline">OperatorPipeline</code></td>
<td>
<p>Genetic operator pipeline.</p>
</td></tr>
<tr><td><code id="AcceptIVMetropolis_+3A_gene">gene</code></td>
<td>
<p>Gene.</p>
</td></tr>
<tr><td><code id="AcceptIVMetropolis_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
</p>


<h3>Value</h3>

<p>The new gene if it has at least equal performance as the old gene 
else the old gene.
</p>


<h3>References</h3>

<p>Locatelli, M. (2000):
Convergence of a Simulated Annealing Algorithm for 
Continuous Global Optimization.
Journal of Global Optimization, 18:219-233.
&lt;doi:10.1023/A:1008339019740&gt;
</p>
<p>The-Crankshaft Publishing (2023):
A Comparison of Cooling Schedules for Simulated Annealing.
&lt;URL:https://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/&gt;
</p>


<h3>See Also</h3>

<p>Other Acceptance Rule: 
<code><a href="#topic+AcceptBest">AcceptBest</a>()</code>,
<code><a href="#topic+AcceptMetropolis">AcceptMetropolis</a>()</code>,
<code><a href="#topic+AcceptNewGene">AcceptNewGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lFxegaGaGene$Beta&lt;-parm(1)
lFxegaGaGene$TempK&lt;-parm(10)
set.seed(2)
OPpipe1&lt;-function(g, lF){InitGene(lF)}
g1&lt;-lFxegaGaGene$EvalGene(InitGene(lFxegaGaGene), lFxegaGaGene)
lFxegaGaGene$CBestFitness&lt;-parm(g1$fit)
g2&lt;-AcceptMetropolis(OPpipe1, g1, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='AcceptMetropolis'>Metropolis Acceptance Rule.</h2><span id='topic+AcceptMetropolis'></span>

<h3>Description</h3>

<p>Change the gene by a genetic operator pipeline.
Always accept a new gene with a fitness improvement.
For maximizing fitness
accept genes with lower fitness with probability
<code>(runif(1)&lt;exp(-(fitness-newfitness)*beta/Temperature)</code>
and reduce temperature with a cooling schedule.
Used: <code>Temperature&lt;-alpha*Temperature</code> with 
<code>alpha&lt;1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcceptMetropolis(OperatorPipeline, gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AcceptMetropolis_+3A_operatorpipeline">OperatorPipeline</code></td>
<td>
<p>Genetic operator pipeline.</p>
</td></tr>
<tr><td><code id="AcceptMetropolis_+3A_gene">gene</code></td>
<td>
<p>Gene.</p>
</td></tr>
<tr><td><code id="AcceptMetropolis_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
</p>


<h3>Value</h3>

<p>The new gene if it has at least equal performance as the 
old gene else the old gene.
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C. D. J, and Vecchi, M. P. (1983):
Optimization by Simulated Annealing. 
Science, 220(4598): 671-680.
&lt;doi:10.1126/science.220.4598.671&gt;
</p>
<p>Metropolis, N., Rosenbluth, A. W., Rosenbluth, M. N., Teller, A. H.,
Teller, E. (1953):
Equation of state calculations by fast computing machines.
Journal of Chemical Physics, 21(6):1087 – 1092.
&lt;doi:10.1063/1.1699114&gt;
</p>


<h3>See Also</h3>

<p>Other Acceptance Rule: 
<code><a href="#topic+AcceptBest">AcceptBest</a>()</code>,
<code><a href="#topic+AcceptIVMetropolis">AcceptIVMetropolis</a>()</code>,
<code><a href="#topic+AcceptNewGene">AcceptNewGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lFxegaGaGene$Beta&lt;-parm(1)
lFxegaGaGene$TempK&lt;-parm(10)
OPpipe1&lt;-function(g, lF){InitGene(lF)}
g1&lt;-lFxegaGaGene$EvalGene(InitGene(lFxegaGaGene), lFxegaGaGene)
g2&lt;-AcceptMetropolis(OPpipe1, g1, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='AcceptNewGene'>Accepts a new gene.</h2><span id='topic+AcceptNewGene'></span>

<h3>Description</h3>

<p>Executes a genetic operator pipeline.
The new gene is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcceptNewGene(OperatorPipeline, gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AcceptNewGene_+3A_operatorpipeline">OperatorPipeline</code></td>
<td>
<p>Genetic operator pipeline (an R function).</p>
</td></tr>
<tr><td><code id="AcceptNewGene_+3A_gene">gene</code></td>
<td>
<p>Gene.</p>
</td></tr>
<tr><td><code id="AcceptNewGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New gene.
</p>


<h3>See Also</h3>

<p>Other Acceptance Rule: 
<code><a href="#topic+AcceptBest">AcceptBest</a>()</code>,
<code><a href="#topic+AcceptIVMetropolis">AcceptIVMetropolis</a>()</code>,
<code><a href="#topic+AcceptMetropolis">AcceptMetropolis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id&lt;-function(x, lF){x}
g1&lt;-InitGene(lFxegaGaGene)
AcceptNewGene(id, g1, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='ApplyFactory'>Configure the the execution model for gene evaluation.</h2><span id='topic+ApplyFactory'></span>

<h3>Description</h3>

<p>The current approach to distribution/parallelization of the genetic
algorithm is to parallelize the evaluation of the fitness function
only. The execution model defines the function <code>lF$lapply()</code>
used in the function <code>EvalPopulation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyFactory(method = "Sequential")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ApplyFactory_+3A_method">method</code></td>
<td>
<p>The label of the execution model: 
&quot;Sequential&quot; | &quot;MultiCore&quot; | 
&quot;FutureApply&quot; |  &quot;Cluster&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently we support the following parallelization models:
</p>

<ol>
<li><p> &quot;Sequential&quot;: Uses <code>base::apply()</code>. (Default).
</p>
</li>
<li><p> &quot;MultiCore&quot;: Uses <code>parallel::mclapply()</code>. 
</p>
</li>
<li><p> &quot;FutureApply&quot;: Uses <code>future.apply::future_lapply()</code>
Plans must be set up and
worker processes must be stopped.
</p>
</li>
<li><p> &quot;Cluster&quot;: Uses <code>parallel:parLapply()</code>.
A cluster object must be set up and the 
worker processes must be stopped. 
</p>
</li></ol>

<p>The execution model <strong>&quot;MultiCore&quot;</strong> provides parallelization restricted 
to a single computer: The master process starts R slave processes 
by fork() which are are run in separate memory spaces. 
At the time of fork() both memory spaces 
have the same content. Memory writes performed by one of the processes
do not affect the other. 
</p>
<p>The execution model <strong>&quot;FutureApply&quot;</strong> makes the possibilities 
of the future backends for a wide range of parallel and distributed 
architectures available.  
The models of parallel resolving a future use 
different types of communication between master 
and slaves: 
</p>
 
<ol>
<li> <p><code>plan(sequential)</code> configures sequential execution. Default.
</p>
</li>
<li> <p><code>w&lt;-5; plan(multicore, workers=w)</code> configures an 
asynchronous multicore execution of futures on 5 workers.
</p>
</li>
<li> <p><code>w&lt;-8; plan(multisession, workers=w)</code> configures a 
multisession environment with 5 workers. 
The evaluation of the future is done in parallel in 5 other 
R sessions on the same machine. 
Communication is done via socket connections, 
the R sessions started serve multiple futures over their life time.
The worker R sessions are stopped by calling <code>plan(sequential)</code>.
The number of parallel sessions is restricted by the availability
of connections. Up to R version 4.3, 
a maximum of 125 connections is available.
</p>
</li>
<li> <p><code>w&lt;-7; plan(callr, workers=w)</code> configures  
the evaluation of futures on top of the <code>callr</code> package.
The <code>callr</code> package creates for each future a separate R session.
The communications is via files of serialized R objects.
The advantages of <code>callr</code> are:
</p>
  
<ol>
<li><p> Each <code>callr</code> future is evaluated in a new R session
which ends as soon as the value of the future has been 
collected.
</p>
</li>
<li><p> The number of parallel <code>callr</code> futures is not restricted
by the number of available connections, because the 
communication is based on files of serialized R objects.
</p>
</li>
<li><p> No ports are used. This means no port clashes with other 
processes and no firewall issues.
</p>
</li></ol>

</li>
<li><p> Setting up a cluster environment for resolving futures works
as follows. Write a function with the following elements:
</p>

<ol>
<li><p> Generate a cluster object:
</p>
<p><code>cl&lt;-makeClusterPSOCK(rep("localhost", workers)</code> 
</p>
</li>
<li><p> Set up an on.exit condition for stopping the worker processes.
</p>
<p><code>on.exit(parallel::stopCluster(cl))</code>
</p>
</li>
<li><p> Set up the plan for resolving the future:
</p>
<p><code>oldplan&lt;-plan(cluster, workers=cl)</code>
</p>
</li>
<li><p> Call the function with <code>future.apply::future_lapply</code>.
E.g. the genetic algorithm.
</p>
</li>
<li><p> Restore the previous plan:
<code>plan(oldplan)</code>
</p>
</li></ol>

<p>The cluster processes may be located on one or several computers.
The communication between the processes is via sockets.
Remote computers must allow the use of ssh to start R-processes
without an interactive login.
</p>
</li></ol>

<p>The execution model <strong>&quot;Cluster&quot;</strong> allows the configuration of 
master-slave processing on local and remote machines.
</p>


<h3>Value</h3>

<p>A function with the same result as the <code>lapply()</code>-function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+AcceptFactory">AcceptFactory</a>()</code>,
<code><a href="#topic+CoolingFactory">CoolingFactory</a>()</code>,
<code><a href="#topic+CrossRateFactory">CrossRateFactory</a>()</code>,
<code><a href="#topic+MutationRateFactory">MutationRateFactory</a>()</code>,
<code><a href="#topic+xegaConfiguration">xegaConfiguration</a>()</code>
</p>

<hr>
<h2 id='ConstCRate'>Constant crossover rate.</h2><span id='topic+ConstCRate'></span>

<h3>Description</h3>

<p>Constant crossover rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstCRate(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstCRate_+3A_fit">fit</code></td>
<td>
<p>Fitness of gene.</p>
</td></tr>
<tr><td><code id="ConstCRate_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Constant crossover rate.
</p>


<h3>See Also</h3>

<p>Other Rates: 
<code><a href="#topic+ConstMRate">ConstMRate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(CrossRate1=parm(0.20))
ConstCRate(100, lF)
ConstCRate(50, lF)
</code></pre>

<hr>
<h2 id='ConstMRate'>Constant mutation rate.</h2><span id='topic+ConstMRate'></span>

<h3>Description</h3>

<p>Constant mutation rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstMRate(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstMRate_+3A_fit">fit</code></td>
<td>
<p>Fitness of gene.</p>
</td></tr>
<tr><td><code id="ConstMRate_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Constant mutation rate.
</p>


<h3>See Also</h3>

<p>Other Rates: 
<code><a href="#topic+ConstCRate">ConstCRate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list()
lF$MutationRate1&lt;-parm(0.20)
ConstMRate(100, lF)
ConstMRate(50, lF)
</code></pre>

<hr>
<h2 id='CoolingFactory'>Configure the cooling schedule of the acceptance 
function of a genetic algorithm.</h2><span id='topic+CoolingFactory'></span>

<h3>Description</h3>

<p><code>CoolingFactory()</code> implements selection
of a cooling schedule method.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;ExponentialMultiplicative&quot; returns 
<code>ExponentialMultiplicativeCooling</code>. (Default)
</p>
</li>
<li><p> &quot;LogarithmicMultiplicative&quot; returns 
<code>LogarithmicMultiplicativeCooling</code>.
</p>
</li>
<li><p> &quot;PowerMultiplicative&quot; returns 
<code>PowerMultiplicativeCooling</code>.
<code>coolingPower=1</code> specifies linear multiplicative cooling,  
<code>coolingPower=2</code> specifies quadratic multiplicative cooling.
</p>
</li>
<li><p> &quot;PowerAdditive&quot; returns 
<code>PowerAdditiveCooling</code>.
<code>coolingPower=1</code> specifies linear additive cooling,  
<code>coolingPower=2</code> specifies quadratic additive cooling.
</p>
</li>
<li><p> &quot;ExponentialAdditive&quot; returns 
<code>ExponentialAdditiveCooling</code>.
</p>
</li>
<li><p> &quot;TrigonometricAdditive&quot; returns 
<code>TrigonometricAdditiveCooling</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>CoolingFactory(method = "ExponentialMultiplicative")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoolingFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the cooling schedule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cooling schedule.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+AcceptFactory">AcceptFactory</a>()</code>,
<code><a href="#topic+ApplyFactory">ApplyFactory</a>()</code>,
<code><a href="#topic+CrossRateFactory">CrossRateFactory</a>()</code>,
<code><a href="#topic+MutationRateFactory">MutationRateFactory</a>()</code>,
<code><a href="#topic+xegaConfiguration">xegaConfiguration</a>()</code>
</p>

<hr>
<h2 id='Cross2Gene'>Import for examples.</h2><span id='topic+Cross2Gene'></span>

<h3>Description</h3>

<p>Import for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cross2Gene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross2Gene_+3A_gg1">gg1</code></td>
<td>
<p>a gene</p>
</td></tr>
<tr><td><code id="Cross2Gene_+3A_gg2">gg2</code></td>
<td>
<p>a gene</p>
</td></tr>
<tr><td><code id="Cross2Gene_+3A_lf">lF</code></td>
<td>
<p>list of local functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two genes
</p>

<hr>
<h2 id='CrossGene'>Import for examples.</h2><span id='topic+CrossGene'></span>

<h3>Description</h3>

<p>Import for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossGene_+3A_gg1">gg1</code></td>
<td>
<p>a gene</p>
</td></tr>
<tr><td><code id="CrossGene_+3A_gg2">gg2</code></td>
<td>
<p>a gene</p>
</td></tr>
<tr><td><code id="CrossGene_+3A_lf">lF</code></td>
<td>
<p>list of local functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of one gene
</p>

<hr>
<h2 id='CrossRateFactory'>Configure the crossover function of a genetic algorithm.</h2><span id='topic+CrossRateFactory'></span>

<h3>Description</h3>

<p><code>CrossRateFactory()</code> implements selection
of one of the crossover rate functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Const&quot; returns <code>ConstCRate()</code>.
</p>
</li>
<li><p> &quot;IV&quot; returns <code>IACrate()</code>.
This function gives bad genes a higher cross rate.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>CrossRateFactory(method = "Const")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossRateFactory_+3A_method">method</code></td>
<td>
<p>A string specifying a function for the crossover rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Crossover rate function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+AcceptFactory">AcceptFactory</a>()</code>,
<code><a href="#topic+ApplyFactory">ApplyFactory</a>()</code>,
<code><a href="#topic+CoolingFactory">CoolingFactory</a>()</code>,
<code><a href="#topic+MutationRateFactory">MutationRateFactory</a>()</code>,
<code><a href="#topic+xegaConfiguration">xegaConfiguration</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;-CrossRateFactory("Const")
f(10, list(CrossRate1=function() {0.2}))
</code></pre>

<hr>
<h2 id='ExponentialAdditiveCooling'>Exponential additive cooling.</h2><span id='topic+ExponentialAdditiveCooling'></span>

<h3>Description</h3>

<p>This schedule decreases in proportion to the
inverse of <code>exp</code> raised to the 
power of the temperature cycle in
<code>lF$Generations()</code> (= number of generations) fractions 
between the starting temperature <code>temp0</code>
and the final temperature <code>tempN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExponentialAdditiveCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExponentialAdditiveCooling_+3A_k">k</code></td>
<td>
<p>Number of steps to discount.</p>
</td></tr>
<tr><td><code id="ExponentialAdditiveCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$TempN()</code> is the final temperature.
<code>lF$Generations()</code> is the number of generations (time).
</p>


<h3>Value</h3>

<p>The temperature at time k.
</p>


<h3>References</h3>

<p>The-Crankshaft Publishing (2023)
A Comparison of Cooling Schedules for Simulated Annealing.
&lt;https://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/&gt;
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialMultiplicativeCooling">ExponentialMultiplicativeCooling</a>()</code>,
<code><a href="#topic+LogarithmicMultiplicativeCooling">LogarithmicMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerAdditiveCooling">PowerAdditiveCooling</a>()</code>,
<code><a href="#topic+PowerMultiplicativeCooling">PowerMultiplicativeCooling</a>()</code>,
<code><a href="#topic+TrigonometricAdditiveCooling">TrigonometricAdditiveCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), TempN=parm(10), Generations=parm(50))
ExponentialAdditiveCooling(0, lF)
ExponentialAdditiveCooling(2, lF)
</code></pre>

<hr>
<h2 id='ExponentialMultiplicativeCooling'>Exponential multiplicative cooling.</h2><span id='topic+ExponentialMultiplicativeCooling'></span>

<h3>Description</h3>

<p>The temperature at time k is the net present value 
of the starting temperature. The discount factor 
is <code>lF$Alpha()</code>. 
<code>lF$Alpha()</code> should be in <code>[0, 1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExponentialMultiplicativeCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExponentialMultiplicativeCooling_+3A_k">k</code></td>
<td>
<p>Number of steps to discount.</p>
</td></tr>
<tr><td><code id="ExponentialMultiplicativeCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$Alpha()</code> is the discount factor.
</p>


<h3>Value</h3>

<p>Temperature at time k.
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C. D. J, and Vecchi, M. P. (1983):
Optimization by Simulated Annealing. 
Science, 220(4598): 671-680.
&lt;doi:10.1126/science.220.4598.671&gt;
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialAdditiveCooling">ExponentialAdditiveCooling</a>()</code>,
<code><a href="#topic+LogarithmicMultiplicativeCooling">LogarithmicMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerAdditiveCooling">PowerAdditiveCooling</a>()</code>,
<code><a href="#topic+PowerMultiplicativeCooling">PowerMultiplicativeCooling</a>()</code>,
<code><a href="#topic+TrigonometricAdditiveCooling">TrigonometricAdditiveCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), Alpha=parm(0.99))
ExponentialMultiplicativeCooling(0, lF)
ExponentialMultiplicativeCooling(2, lF)
</code></pre>

<hr>
<h2 id='futureLapply'>Future apply of R-package <code>future.apply</code>.</h2><span id='topic+futureLapply'></span>

<h3>Description</h3>

<p>The <code>lapply()</code> function is redefined as as 
<code>future.apply::future_lapply()</code>.
Henrik Bengtsson recommends that the configuration of the 
parallel/distributed programming environment should be kept 
outside the package and left to the user. 
The advantage is that the user may take advantage of all 
parallel/distributed available backends for the Future API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futureLapply(pop, EvalGene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="futureLapply_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="futureLapply_+3A_evalgene">EvalGene</code></td>
<td>
<p>Function for evaluating a gene.</p>
</td></tr>
<tr><td><code id="futureLapply_+3A_lf">lF</code></td>
<td>
<p>Local function factory which provides 
all functions needed in <code>EvalGene</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that
</p>

<ul>
<li> <p><code>future_lapply()</code> assumes that each function evaluation 
need approximately the same time.
</p>
</li>
<li><p> Best results are obtained 
if <code>popsize</code> modulo <code>workers</code> is <code>0</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Fitness vector.
</p>


<h3>References</h3>

<p>Bengtsson H (2021). “A Unifying Framework for Parallel and 
Distributed Processing in R using Futures.” 
The R Journal, 13(2), 208–227. &lt;doi:10.32614/RJ-2021-048&gt;
</p>


<h3>See Also</h3>

<p>Other Execution Model: 
<code><a href="#topic+MClapply">MClapply</a>()</code>,
<code><a href="#topic+PparLapply">PparLapply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop&lt;-xegaInitPopulation(1000, lFxegaGaGene)
library(future)
plan(multisession, workers=2)
popnew&lt;-futureLapply(pop, lFxegaGaGene$EvalGene, lFxegaGaGene)
plan(sequential)

</code></pre>

<hr>
<h2 id='IACRate'>Individually adaptive crossover rate.</h2><span id='topic+IACRate'></span>

<h3>Description</h3>

<p>The basic idea is to apply crossover to a gene whose
fitness is below a threshold value with higher probability 
to give it a chance 
to improve. The threshold value is computed by
<code>lF$CutoffFit()*lF$CBestFitness()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IACRate(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IACRate_+3A_fit">fit</code></td>
<td>
<p>Fitness of gene.</p>
</td></tr>
<tr><td><code id="IACRate_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following constants are used:
<code>lF$CrossRate1()&lt;lF$CrossRate2()</code>, and 
<code>lF$CutoffFit()</code> in [0, 1].
</p>


<h3>Value</h3>

<p>Crossover rate of a gene depending on its fitness.
</p>


<h3>References</h3>

<p>Stanhope, Stephen A. and Daida, Jason M. (1996)
An Individually Variable Mutation-rate Strategy for Genetic Algorithms.
In: Koza, John (Ed.)
Late Breaking Papers at the Genetic Programming 1996 Conference.
Stanford University Bookstore, Stanford, pp. 177-185.
(ISBN:0-18-201-031-7)
</p>


<h3>See Also</h3>

<p>Other Adaptive Rates: 
<code><a href="#topic+IAMRate">IAMRate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list()
lF$CrossRate1&lt;-parm(0.20) 
lF$CrossRate2&lt;-parm(0.40) 
lF$CutoffFit&lt;-parm(0.60)
lF$CBestFitness&lt;-parm(105)
IACRate(100, lF)
IACRate(50, lF)
</code></pre>

<hr>
<h2 id='IAMBitRate'>Individually adaptive mutation rate. (Bit mutation Rate)</h2><span id='topic+IAMBitRate'></span>

<h3>Description</h3>

<p>Adaptivity of a local operator mutation parameter.
Currently not used. Implements a threshold rule.
The rule is implemented directly in IVAdaptiveMutateGene.
in package xegaGaGene. Move?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IAMBitRate(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IAMBitRate_+3A_fit">fit</code></td>
<td>
<p>Fitness of gene.</p>
</td></tr>
<tr><td><code id="IAMBitRate_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO: Move this xegaGaGene and generalize the
bit mutation operator and introduce a factory 
for bit mutation rates. Rationale: Local parameters
are representation dependent.
</p>


<h3>Value</h3>

<p>Mutation rate of a gene depending on its fitness.
</p>

<hr>
<h2 id='IAMRate'>Individually adaptive mutation rate.</h2><span id='topic+IAMRate'></span>

<h3>Description</h3>

<p>The probability of applying a mutation operator
to a gene. The idea is that a gene selected for 
reproduction whose fitness is 
below a threshold value is mutated with a higher 
probability to give it a chance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IAMRate(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IAMRate_+3A_fit">fit</code></td>
<td>
<p>Fitness of gene.</p>
</td></tr>
<tr><td><code id="IAMRate_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability of applying a mutation operator is
determined by a threshold: If the fitness of a gene
is higher than <code>lF$CutoffFit()*lF$CBestFitness()</code>,
than return <code>lF$MutationRate1()</code> 
else <code>lF$MutationRate2()</code>.
</p>
<p>Note that the idea is also applicable to gene specific 
local mutation operators. For example, the bit mutation rate
of mutation operators for binary genes.
</p>


<h3>Value</h3>

<p>Mutation rate of a gene depending on its fitness.
</p>


<h3>References</h3>

<p>Stanhope, Stephen A. and Daida, Jason M. (1996)
An Individually Variable Mutation-rate Strategy for Genetic Algorithms.
In: Koza, John (Ed.)
Late Breaking Papers at the Genetic Programming 1996 Conference.
Stanford University Bookstore, Stanford, pp. 177-185.
(ISBN:0-18-201-031-7)
</p>


<h3>See Also</h3>

<p>Other Adaptive Rates: 
<code><a href="#topic+IACRate">IACRate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list()
lF$MutationRate1&lt;-parm(0.20)
lF$MutationRate2&lt;-parm(0.40)
lF$CutoffFit&lt;-parm(0.60)
lF$CBestFitness=parm(105)
IAMRate(100, lF)
IAMRate(50, lF)
</code></pre>

<hr>
<h2 id='InitGene'>Import for examples.</h2><span id='topic+InitGene'></span>

<h3>Description</h3>

<p>Import for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitGene(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitGene_+3A_lf">lF</code></td>
<td>
<p>a list of local functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new random gene
</p>

<hr>
<h2 id='lFxegaGaGene'>Import for examples.</h2><span id='topic+lFxegaGaGene'></span>

<h3>Description</h3>

<p>Import for examples.
</p>
<p>Import lFxegaGaGene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFxegaGaGene

lFxegaGaGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>
<p>An object of class <code>list</code> of length 29.
</p>

<hr>
<h2 id='LogarithmicMultiplicativeCooling'>Logarithmic multiplicative cooling.</h2><span id='topic+LogarithmicMultiplicativeCooling'></span>

<h3>Description</h3>

<p>This schedule decreases by the inverse proportion of the
natural logarithm 
of <code>k</code>. <code>lF$Alpha()</code> should be larger than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogarithmicMultiplicativeCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogarithmicMultiplicativeCooling_+3A_k">k</code></td>
<td>
<p>Number of steps to discount.</p>
</td></tr>
<tr><td><code id="LogarithmicMultiplicativeCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$Alpha()</code> is a scaling factor.
</p>


<h3>Value</h3>

<p>Temperature at time k.
</p>
<p>Aarts, E., and Korst, J. (1989):
Simulated Annealing and Boltzmann Machines.
A Stochastic Approach to Combinatorial Optimization and
Neural Computing.
John Wiley &amp; Sons, Chichester.
(ISBN:0-471-92146-7)
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialAdditiveCooling">ExponentialAdditiveCooling</a>()</code>,
<code><a href="#topic+ExponentialMultiplicativeCooling">ExponentialMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerAdditiveCooling">PowerAdditiveCooling</a>()</code>,
<code><a href="#topic+PowerMultiplicativeCooling">PowerMultiplicativeCooling</a>()</code>,
<code><a href="#topic+TrigonometricAdditiveCooling">TrigonometricAdditiveCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), Alpha=parm(1.01))
LogarithmicMultiplicativeCooling(0, lF)
LogarithmicMultiplicativeCooling(2, lF)
</code></pre>

<hr>
<h2 id='MClapply'>MultiCore apply of library parallel.</h2><span id='topic+MClapply'></span>

<h3>Description</h3>

<p>The evaluation of the fitness of the genes of the population
is distributed to one worker on each core of the CPU of the 
local machine.
The package of <code>parallel</code> of base R is used.
The number of cores is provided by <code>lF$Cores</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MClapply(pop, EvalGene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MClapply_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="MClapply_+3A_evalgene">EvalGene</code></td>
<td>
<p>Function for evaluating a gene.</p>
</td></tr>
<tr><td><code id="MClapply_+3A_lf">lF</code></td>
<td>
<p>Local function configuration which provides 
all functions needed in <code>EvalGene()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that
</p>

<ul>
<li> <p><code>parallel::mclapply()</code> assumes that each function evaluation 
needs approximately the same time.
</p>
</li>
<li><p> Best results are obtained if <code>popsize</code> modulo <code>cores-1</code> is 0.
</p>
</li>
<li><p> Does not work on Windows.
</p>
</li></ul>



<h3>Value</h3>

<p>Fitness vector.
</p>


<h3>See Also</h3>

<p>Other Execution Model: 
<code><a href="#topic+PparLapply">PparLapply</a>()</code>,
<code><a href="#topic+futureLapply">futureLapply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(parallelly) 
if (supportsMulticore()){
lFxegaGaGene$Cores&lt;-function() {2}
pop&lt;-xegaInitPopulation(1000, lFxegaGaGene)
popnew&lt;-MClapply(pop, lFxegaGaGene$EvalGene, lFxegaGaGene)
}

</code></pre>

<hr>
<h2 id='MetropolisAcceptanceProbability'>Metropolis acceptance probability.</h2><span id='topic+MetropolisAcceptanceProbability'></span>

<h3>Description</h3>

<p>Metropolis acceptance probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetropolisAcceptanceProbability(d, beta, temperature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetropolisAcceptanceProbability_+3A_d">d</code></td>
<td>
<p>Distance between the fitness of the old and the new gene.</p>
</td></tr>
<tr><td><code id="MetropolisAcceptanceProbability_+3A_beta">beta</code></td>
<td>
<p>Constant.</p>
</td></tr>
<tr><td><code id="MetropolisAcceptanceProbability_+3A_temperature">temperature</code></td>
<td>
<p>Temperature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Acceptance probability.
</p>


<h3>See Also</h3>

<p>Other Diagnostic: 
<code><a href="#topic+MetropolisTable">MetropolisTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MetropolisAcceptanceProbability(d=0, beta=1, temperature=10)
MetropolisAcceptanceProbability(d=1, beta=1, temperature=10)
</code></pre>

<hr>
<h2 id='MetropolisTable'>Metropolis acceptance probability table.</h2><span id='topic+MetropolisTable'></span>

<h3>Description</h3>

<p>Metropolis acceptance probability table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetropolisTable(d = 1, beta = 2, temperature = 1000, alpha = 0.9, steps = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetropolisTable_+3A_d">d</code></td>
<td>
<p>Distance between the fitness of the old and the new gene.</p>
</td></tr>
<tr><td><code id="MetropolisTable_+3A_beta">beta</code></td>
<td>
<p>Constant.</p>
</td></tr>
<tr><td><code id="MetropolisTable_+3A_temperature">temperature</code></td>
<td>
<p>Temperature.</p>
</td></tr>
<tr><td><code id="MetropolisTable_+3A_alpha">alpha</code></td>
<td>
<p>Cooling constant in [0, 1].</p>
</td></tr>
<tr><td><code id="MetropolisTable_+3A_steps">steps</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the columns alpha, beta, temperature, 
d (distance between fitness), and probability of acceptance.
</p>


<h3>See Also</h3>

<p>Other Diagnostic: 
<code><a href="#topic+MetropolisAcceptanceProbability">MetropolisAcceptanceProbability</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MetropolisTable(d=2, beta=2, temperature=10, alpha=0.99, steps=10)
</code></pre>

<hr>
<h2 id='MutationRateFactory'>Configure the mutation rate function of a genetic algorithm.</h2><span id='topic+MutationRateFactory'></span>

<h3>Description</h3>

<p>The <code>MutationRateFactory()</code> implements selection
of one of the crossover rate functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Const&quot; returns <code>ConstMRate()</code> (Default).
</p>
</li>
<li><p> &quot;IV&quot; returns <code>IAMrate()</code>.
This function gives bad genes a higher mutation rate.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>MutationRateFactory(method = "Const")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MutationRateFactory_+3A_method">method</code></td>
<td>
<p>A string specifying a function for the mutation rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutation rate function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+AcceptFactory">AcceptFactory</a>()</code>,
<code><a href="#topic+ApplyFactory">ApplyFactory</a>()</code>,
<code><a href="#topic+CoolingFactory">CoolingFactory</a>()</code>,
<code><a href="#topic+CrossRateFactory">CrossRateFactory</a>()</code>,
<code><a href="#topic+xegaConfiguration">xegaConfiguration</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;-MutationRateFactory("Const")
f(10, list(MutationRate1=function() {0.2}))
</code></pre>

<hr>
<h2 id='PowerAdditiveCooling'>Power additive cooling.</h2><span id='topic+PowerAdditiveCooling'></span>

<h3>Description</h3>

<p>This schedule decreases by a power of the
n (= number of generations) linear fractions 
between the starting temperature <code>lF$Temp0</code>
and the final temperature <code>lF$tempN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PowerAdditiveCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PowerAdditiveCooling_+3A_k">k</code></td>
<td>
<p>Number of steps to discount.</p>
</td></tr>
<tr><td><code id="PowerAdditiveCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$TempN()</code> is the final temperature.
<code>lF$CoolingPower()</code> is an exponential factor. 
<code>lF$Generations()</code> is the number of generations (time).
</p>


<h3>Value</h3>

<p>Temperature at time k.
</p>


<h3>References</h3>

<p>The-Crankshaft Publishing (2023)
A Comparison of Cooling Schedules for Simulated Annealing.
&lt;https://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/&gt;
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialAdditiveCooling">ExponentialAdditiveCooling</a>()</code>,
<code><a href="#topic+ExponentialMultiplicativeCooling">ExponentialMultiplicativeCooling</a>()</code>,
<code><a href="#topic+LogarithmicMultiplicativeCooling">LogarithmicMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerMultiplicativeCooling">PowerMultiplicativeCooling</a>()</code>,
<code><a href="#topic+TrigonometricAdditiveCooling">TrigonometricAdditiveCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), TempN=parm(10), Generations=parm(50), CoolingPower=parm(2))
PowerAdditiveCooling(0, lF)
PowerAdditiveCooling(2, lF)
</code></pre>

<hr>
<h2 id='PowerMultiplicativeCooling'>Power multiplicative cooling.</h2><span id='topic+PowerMultiplicativeCooling'></span>

<h3>Description</h3>

<p>This schedule decreases by the inverse proportion of 
a power 
of <code>k</code>. <code>lF$Alpha()</code> should be larger than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PowerMultiplicativeCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PowerMultiplicativeCooling_+3A_k">k</code></td>
<td>
<p>Number of steps to discount.</p>
</td></tr>
<tr><td><code id="PowerMultiplicativeCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
For <code>lF$CoolingPower()==1</code> and 
<code>lF$CoolingPower()==2</code> this results in the 
the linear and quadratic multiplicative cooling schemes 
in A Comparison of Cooling Schedules for Simulated Annealing.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$Alpha()</code> is a scaling factor.
<code>lF$CoolingPower()</code> is an exponential factor.
</p>


<h3>Value</h3>

<p>Temperature at time k.
</p>


<h3>References</h3>

<p>The-Crankshaft Publishing (2023)
A Comparison of Cooling Schedules for Simulated Annealing.
&lt;https://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/&gt;
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialAdditiveCooling">ExponentialAdditiveCooling</a>()</code>,
<code><a href="#topic+ExponentialMultiplicativeCooling">ExponentialMultiplicativeCooling</a>()</code>,
<code><a href="#topic+LogarithmicMultiplicativeCooling">LogarithmicMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerAdditiveCooling">PowerAdditiveCooling</a>()</code>,
<code><a href="#topic+TrigonometricAdditiveCooling">TrigonometricAdditiveCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), Alpha=parm(1.01), CoolingPower=parm(2))
PowerMultiplicativeCooling(0, lF)
PowerMultiplicativeCooling(2, lF)
</code></pre>

<hr>
<h2 id='PparLapply'>uses parLapply of library parallel for using workers on 
machines in a local network.</h2><span id='topic+PparLapply'></span>

<h3>Description</h3>

<p>uses parLapply of library parallel for using workers on 
machines in a local network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PparLapply(pop, EvalGene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PparLapply_+3A_pop">pop</code></td>
<td>
<p>a population of genes.</p>
</td></tr>
<tr><td><code id="PparLapply_+3A_evalgene">EvalGene</code></td>
<td>
<p>the function for evaluating a gene.</p>
</td></tr>
<tr><td><code id="PparLapply_+3A_lf">lF</code></td>
<td>
<p>the local function factory which provides
all functions needed in <code>EvalGene</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitness vector.
</p>


<h3>Warning</h3>

<p>This section has not been properly tested.
Random number generation?
Examples?
</p>


<h3>See Also</h3>

<p>Other Execution Model: 
<code><a href="#topic+MClapply">MClapply</a>()</code>,
<code><a href="#topic+futureLapply">futureLapply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x) {function() {x}}
pop&lt;-xegaInitPopulation(1000, lFxegaGaGene)
library(parallel)
clus&lt;-makeCluster(spec=c("localhost", "localhost"), master="localhost", 
                            port=1250, homogeneous=TRUE)
lFxegaGaGene$cluster&lt;-parm(clus)
popnew&lt;-PparLapply(pop, lFxegaGaGene$EvalGene, lFxegaGaGene)
stopCluster(clus)

</code></pre>

<hr>
<h2 id='ReplicateGene'>Import for examples.</h2><span id='topic+ReplicateGene'></span>

<h3>Description</h3>

<p>Import for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplicateGene(pop, fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReplicateGene_+3A_pop">pop</code></td>
<td>
<p>the population.</p>
</td></tr>
<tr><td><code id="ReplicateGene_+3A_fit">fit</code></td>
<td>
<p>the fitness-</p>
</td></tr>
<tr><td><code id="ReplicateGene_+3A_lf">lF</code></td>
<td>
<p>list of local functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one gene
</p>

<hr>
<h2 id='TrigonometricAdditiveCooling'>Trigonometric additive cooling.</h2><span id='topic+TrigonometricAdditiveCooling'></span>

<h3>Description</h3>

<p>This schedule decreases in proportion to the
cosine of the temperature cycle in
<code>lF$Generations()</code> (= number of generations) fractions 
between the starting temperature <code>lF$Temp0()</code>
and the final temperature <code>lF$TempN()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrigonometricAdditiveCooling(k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrigonometricAdditiveCooling_+3A_k">k</code></td>
<td>
<p>Number of steps (time).</p>
</td></tr>
<tr><td><code id="TrigonometricAdditiveCooling_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature is updated at the end of each generation
in the main loop of the genetic algorithm.
<code>lF$Temp0()</code> is the starting temperature.
<code>lF$TempN()</code> is the final temperature.
<code>lF$Generations()</code> is the number of generations (time).
</p>


<h3>Value</h3>

<p>Temperature at time k.
</p>


<h3>References</h3>

<p>The-Crankshaft Publishing (2023)
A Comparison of Cooling Schedules for Simulated Annealing.
&lt;https://what-when-how.com/artificial-intelligence/a-comparison-of-cooling-schedules-for-simulated-annealing-artificial-intelligence/&gt;
</p>


<h3>See Also</h3>

<p>Other Cooling: 
<code><a href="#topic+ExponentialAdditiveCooling">ExponentialAdditiveCooling</a>()</code>,
<code><a href="#topic+ExponentialMultiplicativeCooling">ExponentialMultiplicativeCooling</a>()</code>,
<code><a href="#topic+LogarithmicMultiplicativeCooling">LogarithmicMultiplicativeCooling</a>()</code>,
<code><a href="#topic+PowerAdditiveCooling">PowerAdditiveCooling</a>()</code>,
<code><a href="#topic+PowerMultiplicativeCooling">PowerMultiplicativeCooling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list(Temp0=parm(100), TempN=parm(10), Generations=parm(50))
TrigonometricAdditiveCooling(0, lF)
TrigonometricAdditiveCooling(2, lF)
</code></pre>

<hr>
<h2 id='xegaBestGeneInPopulation'>Extracts indices of best genes in population.</h2><span id='topic+xegaBestGeneInPopulation'></span>

<h3>Description</h3>

<p><code>BestGeneInPopulation()</code> extracts the indices of
the best genes in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaBestGeneInPopulation(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaBestGeneInPopulation_+3A_fit">fit</code></td>
<td>
<p>Fitness vector of a population of genes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You might use:   
<code>which(max(fit)==fit)</code>. But this is slower!
</p>


<h3>Value</h3>

<p>List of the indices of the best genes in the population.
</p>


<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
xegaBestGeneInPopulation(epop10$fit)

</code></pre>

<hr>
<h2 id='xegaBestInPopulation'>Best solution in the population.</h2><span id='topic+xegaBestInPopulation'></span>

<h3>Description</h3>

<p><code>BestInPopulation()</code> extracts the best
individual of a population and
reports fitness, value, genotype, and phenotype:
</p>

<ol>
<li>
<p><code>fitness</code>:  The fitness value of the genetic algorithm.
</p>
</li>
<li>
<p><code>value</code>:   The function value of the problem environment.
</p>
</li>
<li>
<p><code>genotype</code>:  The gene representation.
</p>
</li>
<li>  
<p><code>phenotype</code>: The problem representation.
E.g. a parameter list, a program, ...
</p>
</li></ol>

<p>We report one of the best solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaBestInPopulation(pop, fit, lF, allsolutions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaBestInPopulation_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="xegaBestInPopulation_+3A_fit">fit</code></td>
<td>
<p>Vector of fitness values of <code>pop</code>.</p>
</td></tr>
<tr><td><code id="xegaBestInPopulation_+3A_lf">lF</code></td>
<td>
<p>Local function configuration.</p>
</td></tr>
<tr><td><code id="xegaBestInPopulation_+3A_allsolutions">allsolutions</code></td>
<td>
<p>If TRUE, also return a list of all solutions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list with the following elements:
</p>

<ul>
<li> <p><code>$name</code>:     The name of the problem environment.
</p>
</li>
<li> <p><code>$fitness</code>:  The fitness value of the best solution.
</p>
</li>
<li> <p><code>$val</code>:      The evaluted best gene. 
</p>
</li>
<li> <p><code>$numberOfSolutions</code>:   The number of solutions.
</p>
</li>
<li> <p><code>$genotype</code>:    The best gene.
</p>
</li>
<li> <p><code>$phenotype</code>:   The parameters of the solution
(the decoded gene).
</p>
</li>
<li> <p><code>$phenotypeValue</code>:  The value of the
function of the parameters of the solution
(the decoded gene).
</p>
</li>
<li> <p><code>$allgenotypes</code>:  The genotypes of all best solutions.
(allsolutions==TRUE)
</p>
</li>
<li> <p><code>$allphenotypes</code>:  The phenotypes of all best solutions.
(allsolutions==TRUE)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
xegaBestInPopulation(epop10$pop, epop10$fit, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaConfiguration'>Remembers R command command with which algorithm has been called.</h2><span id='topic+xegaConfiguration'></span>

<h3>Description</h3>

<p><code>xegaConfiguration()</code> returns the command with which
the genetic algorithm has been called. 
For replicating computational experiments with 
genetic algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaConfiguration(GAname, penv, grammar, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaConfiguration_+3A_ganame">GAname</code></td>
<td>
<p>Name of genetic algorithm's main function.
(Currently: &quot;Run&quot;).</p>
</td></tr>
<tr><td><code id="xegaConfiguration_+3A_penv">penv</code></td>
<td>
<p>The expression for the problem environment <code>penv</code>.
Use: <code>substitute(penv)</code>.</p>
</td></tr>
<tr><td><code id="xegaConfiguration_+3A_grammar">grammar</code></td>
<td>
<p>The grammar <code>grammar</code>.
Use: <code>substitute(grammar)</code>.</p>
</td></tr>
<tr><td><code id="xegaConfiguration_+3A_env">env</code></td>
<td>
<p>Environment with variable value bindings.
Use: <code>environment()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li> <p><code>$GAconf</code>: 
A text string with the call of the genetic algorithm
(the function we want to capture the call).
</p>
</li>
<li> <p><code>$GAenv</code>:   The environment with the arguments bound to the 
values when the genetic algorithm was called.
</p>
</li></ul>



<h3>Warning</h3>


<ul>
<li>
<p>$GAenv is correct only for simple arguments (strings or numbers) 
not for complex objects like problem environments.
</p>
</li>
<li> 
<p><code>future.apply::future_lapply()</code> is configured by a plan 
statement which must be issued before calling the genetic 
algorithm. At the moment, the plan chosen is not remembered.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+AcceptFactory">AcceptFactory</a>()</code>,
<code><a href="#topic+ApplyFactory">ApplyFactory</a>()</code>,
<code><a href="#topic+CoolingFactory">CoolingFactory</a>()</code>,
<code><a href="#topic+CrossRateFactory">CrossRateFactory</a>()</code>,
<code><a href="#topic+MutationRateFactory">MutationRateFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GA&lt;-function(pe, grammar=NULL, nope=1.5, sle="test", ok=TRUE) 
{xegaConfiguration("GA", substitute(pe), substitute(grammar), environment())}
Para&lt;-5
GA(Para)
Cube&lt;-7
GA(Cube, 2, 3, 4)

</code></pre>

<hr>
<h2 id='xegaEvalPopulation'>Evaluates a population of genes in a a problem environment</h2><span id='topic+xegaEvalPopulation'></span>

<h3>Description</h3>

<p><code>EvalPopulation()</code> evaluates a population
of genes in a problem environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaEvalPopulation(pop, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaEvalPopulation_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="xegaEvalPopulation_+3A_lf">lF</code></td>
<td>
<p>Local function configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallelization of the evaluation of fitness functions
is possible by defining <code>lf$evalPopLapply</code>.
</p>


<h3>Value</h3>

<p>List of fitness values.
</p>


<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
lFxegaGaGene[["evalPopLapply"]]&lt;-ApplyFactory(method="Sequential") 
fit&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaInitPopulation'>Initializes a population of genes.</h2><span id='topic+xegaInitPopulation'></span>

<h3>Description</h3>

<p><code>xegaInitPopulation()</code> initializes a population
of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaInitPopulation(popsize, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaInitPopulation_+3A_popsize">popsize</code></td>
<td>
<p>Population size.</p>
</td></tr>
<tr><td><code id="xegaInitPopulation_+3A_lf">lF</code></td>
<td>
<p>Local function configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of genes.
</p>


<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaLogEvalsPopulation'>Combine fitness, generations, and the phentype of the gene.</h2><span id='topic+xegaLogEvalsPopulation'></span>

<h3>Description</h3>

<p>Combine fitness, generations, and the phentype of the gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaLogEvalsPopulation(pop, evallog, generation, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaLogEvalsPopulation_+3A_pop">pop</code></td>
<td>
<p>Population.</p>
</td></tr>
<tr><td><code id="xegaLogEvalsPopulation_+3A_evallog">evallog</code></td>
<td>
<p>Evaluation log.</p>
</td></tr>
<tr><td><code id="xegaLogEvalsPopulation_+3A_generation">generation</code></td>
<td>
<p>Generation logged.</p>
</td></tr>
<tr><td><code id="xegaLogEvalsPopulation_+3A_lf">lF</code></td>
<td>
<p>Local function configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Update of the evaluation log. 
The evaluation log is a list of decoded and evaluated genes.
A list item of the evaluation log has the following 
elements:
</p>

<ul>
<li> <p><code>$generation</code>:   The generation.
</p>
</li>
<li> <p><code>$fit</code>:          The fitness value.
</p>
</li>
<li> <p><code>$phenotype</code>:    The phenotype of the gene.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
logevals&lt;-list()
logevals
logevals&lt;-xegaLogEvalsPopulation(epop10$pop, logevals, 1, lFxegaGaGene)
logevals
</code></pre>

<hr>
<h2 id='xegaNextPopulation'>Computes the next population of genes.</h2><span id='topic+xegaNextPopulation'></span>

<h3>Description</h3>

<p><code>xegaNextPopulation()</code> 
builds the next population by repeatedly
calling <code>ReplicateGene()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaNextPopulation(pop, fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaNextPopulation_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="xegaNextPopulation_+3A_fit">fit</code></td>
<td>
<p>Fitness.</p>
</td></tr>
<tr><td><code id="xegaNextPopulation_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version is sequential.
For parallelization, a restructuring of the 
main loop with an integration of <code>xegaNextPopulation</code>
and <code>xegaEvalPopulation</code> is planned, because
this allows the parallelization of a large part of 
the genetic operations which are sequential in the 
current version.
</p>


<h3>Value</h3>

<p>Population of genes.
</p>


<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lFxegaGaGene$MutationRate&lt;-MutationRateFactory(method="Const")
lFxegaGaGene$ReplicateGene&lt;-ReplicateGene
lFxegaGaGene$Accept&lt;-AcceptFactory(method="All")
pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
newpop&lt;-xegaNextPopulation(epop10$pop, epop10$fit, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaObservePopulation'>Observe summary statistics of the fitness of the population.</h2><span id='topic+xegaObservePopulation'></span>

<h3>Description</h3>

<p><code>xegaObservePopulation()</code> reports
summary statistics of the fitness of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaObservePopulation(fit, v = vector())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaObservePopulation_+3A_fit">fit</code></td>
<td>
<p>Vector of fitness values of a population.</p>
</td></tr>
<tr><td><code id="xegaObservePopulation_+3A_v">v</code></td>
<td>
<p>Vector of population statistic vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Population statistics are used for 
</p>

<ul>
<li><p> implementing individually variable operator rates and
</p>
</li>
<li><p> visualizing the progress of the algorithm.      
</p>
</li></ul>



<h3>Value</h3>

<p>Vector of population statistics. If position
<code>x</code> modulo <code>8</code> equals
</p>

<ol>
<li> <p><code>1</code>:  Mean fitness.
</p>
</li>
<li> <p><code>2</code>:  Min fitness.
</p>
</li>
<li> <p><code>3</code>:  Lower-hinge 
(approx. 1st quartile) of fitness.
</p>
</li>
<li> <p><code>4</code>:  Median fitness.
</p>
</li>
<li> <p><code>5</code>:  Upper-hinge 
(approx. 3rd quartile) of fitness.
</p>
</li>
<li> <p><code>6</code>:  Max fitness.
</p>
</li>
<li> <p><code>7</code>:  Variance.
</p>
</li>
<li> <p><code>8</code>: Mean absolute deviation. 
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaSummaryPopulation">xegaSummaryPopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
popStats&lt;-xegaObservePopulation(epop10$fit)
popStats&lt;-xegaObservePopulation(epop10$fit, popStats)
matrix(popStats, ncol=8, byrow=TRUE)

</code></pre>

<hr>
<h2 id='xegaPopulation'>Package xegaPopulation.</h2><span id='topic+xegaPopulation'></span>

<h3>Description</h3>

<p>Population level functions
</p>


<h3>Details</h3>

<p>The <code>xegaPopulation</code> package provides the representation independent
functions of the population level of the simple genetic 
algorithm xegaX packages: 
</p>

<ul>
<li><p> File xegaPopulation.R:
</p>

<ul>
<li><p> Initializing a population of genes.
</p>
</li>
<li><p> Getting the indices of the best genes in a population of genes
for getting the best solution(s) in a population of genes.
</p>
</li>
<li><p> Configurable summary report of population fitness statistics.
</p>
</li>
<li><p> Observation of the summary statistics of a population of genes.
</p>
</li>
<li><p> Logging of the phenotype and the value of the phenotype.
</p>
</li></ul>

</li>
<li><p> File xegaNextPopulation.R:
</p>

<ul>
<li><p> Computation of the next population of genes.
</p>
</li>
<li><p> Evaluation of the next population of genes.
</p>
</li></ul>

<p><strong>Future</strong>: Improved support for parallelization suggests a 
different division of labor: 
</p>

<ul>
<li><p> Construct a list of abstract task descriptions 
with one element per gene.
</p>
</li>
<li><p> Provide for a parallel execution of these task descriptions. 
This requires changes in the structuring of the 
operator pipelines and the replicate gene functions 
for the different gene representations and algorithms.
</p>
</li>
<li><p> Performance improvement depends on the gene representation 
and on the use of function evaluations in the genetic 
machinery. For example, for the TSP problem, 
function evaluations 
are embedded into most of the mutation operators.
</p>
</li></ul>

</li>
<li><p> File acceptance.R: 
Acceptance rules for new genes and a function factory for configuring
them. 
</p>
</li>
<li><p> File cooling.R: Cooling schedules for temperature reduction.
</p>
</li>
<li><p> File localAdaptivity.R: Unused. 
Move to gene dependent packages planned.
</p>
</li>
<li><p> File adaptivityCrossover.R: 
Functions constant and adaptive crossover rates. 
</p>
</li>
<li><p> File adaptivityMutation.R:
Functions constant and adaptive mutation rates. 
</p>
</li>
<li><p> File parModel.R: Execution models for parallelization.
</p>

<ul>
<li><p> &quot;Sequential&quot;: Configures lapply as <code>lapply()</code>.
</p>
</li>
<li><p> &quot;MultiCore&quot;: Configures lapply as <code>parallel::mclapply()</code>.
The number of cores is set by <code>lF$Core()</code>. 
</p>
</li></ul>

</li>
<li><p> File configuration.R: Documenting how the algorithm was called.
Support for the replication of computational
experiments (replicate and replay).
</p>
</li></ul>



<h3>Interface of Acceptance Rules</h3>

<p><code>newGene&lt;-accept(OperatorPipeline, gene, lF)</code>
</p>

<ol>
<li><p> Accept all new genes: Identity function. For genetic algorithms.
</p>
</li>
<li><p> Accept best: Accepts the gene with the highest fitness.
For greedy and randomized greedy algorithms
(hill-climbing algorithms).
</p>
</li>
<li><p> The Metropolis and the individually variable Metropolis rule:
If the new gene gene is better, accept it.
If the old gene is better, make a biased random choice. 
The probability of accepting a decrease in fitness depends on 
the fitness distance between genes, a constant beta for scaling 
the exponential decay and a temperature parameter and for 
the individually variable Metropolis rule a correction term 
which depends on the distance to the best known fitness of the run. 
</p>
</li></ol>

<p><strong>Constants for Acceptance Rules.</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Beta()         </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> AcceptMetropolis() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                  </td><td style="text-align: center;">       </td><td style="text-align: left;"> AcceptIVMetropolis() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$TempK()        </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> AcceptMetropolis() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                  </td><td style="text-align: center;">       </td><td style="text-align: left;"> AcceptIVMetropolis() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$lFCBestFitness() </td><td style="text-align: center;"> None </td><td style="text-align: left;"> AcceptIVMetropolis() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>Interface of Cooling Schedules</h3>

<p><code>Temperature&lt;-cooling(k, lF)</code>
</p>
<p>Cooling schedules convert the progress of the time in the algorithm
(measured in generations) into a temperature.
The temperature influences the probability of accepting a gene
with less fitness than its parent gene.
</p>
<p><strong>Constants for Cooling Schedules.</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Alpha()         </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> ExponentialMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> LogarithmicMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Temp0()         </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> ExponentialMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> LogarithmicMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> ExponentialAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> TrigonometricAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$TempN()         </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> ExponentialAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> TrigonometricAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CoolingPower()  </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerMultiplicativeCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> PowerAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Generations()   </td><td style="text-align: center;">       </td><td style="text-align: left;"> PowerAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">       </td><td style="text-align: left;"> ExponentialAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> TrigonometricAdditiveCooling() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>Interface of Rates</h3>

<p><code>rate&lt;-rateFunction(fit, lF)</code>
</p>
<p>Crossover and mutation rate functions may be adaptive.
The interface allows for dependencies of the rate 
on fitness and constants in the local configuration.
</p>
<p><strong>Constants for Adaptive Crossover and Mutation Rates</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong>  </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CrossRate1()    </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> IACRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CrossRate2()    </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> IACRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$MutationRate1() </td><td style="text-align: center;">       </td><td style="text-align: left;"> IAMRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$MutationRate2() </td><td style="text-align: center;">       </td><td style="text-align: left;"> IAMRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CutoffFit()     </td><td style="text-align: center;">  ?    </td><td style="text-align: left;"> IACRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CBestFitness()  </td><td style="text-align: center;">       </td><td style="text-align: left;"> IACRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                   </td><td style="text-align: center;">       </td><td style="text-align: left;"> IAMRate() </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split in a representation independent and 
a representation dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler and 
<code>xegaDerivationTrees</code> an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>https://github.com/ageyerschulz/xegaPopulation
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaPopulation')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>

<hr>
<h2 id='xegaSummaryPopulation'>Provide elementary summary statistics of the fitness of the population.</h2><span id='topic+xegaSummaryPopulation'></span>

<h3>Description</h3>

<p><code>SummaryPopulation()</code> reports
on the fitness and the value of the best solution
in the population.
</p>
<p>The value of <code>lF$Verbose()</code> controls the
information displayed:
</p>
 
<ol>
<li> <p><code>== 0</code>: Nothing is displayed.
</p>
</li>
<li> <p><code>== 1</code>: 1 point per generation.
</p>
</li>
<li> <p><code>&gt; 1</code>: Max(fit), number of solutions, indices.
</p>
</li>
<li> <p><code>&gt; 2</code>: and population fitness statistics.
</p>
</li>
<li> <p><code>&gt; 3</code>: and 1 solution.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaSummaryPopulation(pop, fit, lF, iter = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaSummaryPopulation_+3A_pop">pop</code></td>
<td>
<p>Population of genes.</p>
</td></tr>
<tr><td><code id="xegaSummaryPopulation_+3A_fit">fit</code></td>
<td>
<p>Vector of fitness values of <code>pop</code>.</p>
</td></tr>
<tr><td><code id="xegaSummaryPopulation_+3A_lf">lF</code></td>
<td>
<p>Local function configuration.</p>
</td></tr>
<tr><td><code id="xegaSummaryPopulation_+3A_iter">iter</code></td>
<td>
<p>The generation. Default: <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number <code>0</code>.
</p>


<h3>See Also</h3>

<p>Other Population Layer: 
<code><a href="#topic+xegaBestGeneInPopulation">xegaBestGeneInPopulation</a>()</code>,
<code><a href="#topic+xegaBestInPopulation">xegaBestInPopulation</a>()</code>,
<code><a href="#topic+xegaEvalPopulation">xegaEvalPopulation</a>()</code>,
<code><a href="#topic+xegaInitPopulation">xegaInitPopulation</a>()</code>,
<code><a href="#topic+xegaLogEvalsPopulation">xegaLogEvalsPopulation</a>()</code>,
<code><a href="#topic+xegaNextPopulation">xegaNextPopulation</a>()</code>,
<code><a href="#topic+xegaObservePopulation">xegaObservePopulation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-xegaInitPopulation(10, lFxegaGaGene)
epop10&lt;-xegaEvalPopulation(pop10, lFxegaGaGene)
rc&lt;-xegaSummaryPopulation(epop10$pop, epop10$fit, lFxegaGaGene, iter=12)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
