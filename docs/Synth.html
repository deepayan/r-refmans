<!DOCTYPE html><html><head><title>Help for package Synth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Synth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#basque'><p>Panel Data from Spanish Regions to demonstrate the use of the Synthetic Control Method</p></a></li>
<li><a href='#collect.optimx'>
<p>Collect results from optimx optimization methods</p></a></li>
<li><a href='#dataprep'><p>Constructs a list of matrices from panel dataset to be loaded into synth()</p></a></li>
<li><a href='#fn.V'>
<p>Loss Function for nested optimization of W and V weights</p></a></li>
<li><a href='#gaps.plot'><p>Plots Gap in Outcome Trajectories between the Treated its Synthetic Control Unit</p></a></li>
<li><a href='#path.plot'><p>Plots Outcome Trajectories for Treated Unit and its Synthetic Control Unit</p></a></li>
<li><a href='#spec.pred.func'><p>Special Predictor Function for Dataprep</p></a></li>
<li><a href='#synth'>
<p>Constructs synthetic control units for comparative case studies</p></a></li>
<li><a href='#synth.data'><p>Panel Data to demonstrate the use of the Synthetic Control Method</p></a></li>
<li><a href='#synth.tab'><p>Creates Tables that Summarize Results of Synthetic Control Group Method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Synthetic Control Group Method for Comparative Case Studies</td>
</tr>
<tr>
<td>Author:</td>
<td>Jens Hainmueller &lt;jhain@stanford.edu&gt; and Alexis Diamond &lt;adiamond@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jens Hainmueller &lt;jhain@stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the synthetic control group method for comparative case studies as described in Abadie and Gardeazabal (2003) and Abadie, Diamond, and Hainmueller (2010, 2011, 2014). The synthetic control method allows for effect estimation in settings where a single unit (a state, country, firm, etc.) is exposed to an event or intervention. It provides a data-driven procedure to construct synthetic control units based on a weighted combination of comparison units that approximates the characteristics of the unit that is exposed to the intervention. A combination of comparison units often provides a better comparison for the unit exposed to the intervention than any comparison unit alone.</td>
</tr>
<tr>
<td>Imports:</td>
<td>kernlab, optimx,rgenoud</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://web.stanford.edu/~jhain/">https://web.stanford.edu/~jhain/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-01 19:10:32 UTC; jhainmueller</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-02 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='basque'>Panel Data from Spanish Regions to demonstrate the use of the Synthetic Control Method</h2><span id='topic+basque'></span>

<h3>Description</h3>

<p>The dataset contains information from 1955&ndash;1997
on 17 Spanish regions. It was used by Abadie and Gardeazabal (2003), which studied the economic effects of
conflict, using the terrorist conflict in the Basque Country as a case study. This
paper used a combination of other Spanish regions to construct a synthetic
control region resembling many relevant economic characteristics of
the Basque Country before the onset of political terrorism in the 1970s.
The data contains per-capita GDP (the outcome variable), as well as
population density, sectoral production, investment, and human capital
(the predictor variables) for the relevant years, and is used here to demonstrate the implementation
of the synthetic control method with the synth library.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(basque)</code></pre>


<h3>Format</h3>

<p>A panel dataframe made up of 18 units: 1 treated (no 17; the Basque country) and 16 control regions (no. 2-16,18).
Region no. 1 is the average for the whole country of Spain. 1 outcome variable (gdpcap). 13 predictor variables 
(6 sectoral production shares, 6 highest educational attainment categories, population density, and the investment rate).
Region names and numbers are stored in regionno and regionname. 42 time periods (1955 - 1997).
All columns have self-explanatory column names. For reference the variables are:
</p>

<ul>
<li> <pre>regionno</pre><p>: Region Number.
</p>
</li>
<li> <pre>regionname</pre><p>: Region Name.
</p>
</li>
<li> <pre>year</pre><p>: Year.
</p>
</li>
<li> <pre>gdpcap</pre><p>: real GDP per capita (in 1986 USD, thousands).
</p>
</li>
<li> <pre>sec.agriculture</pre><p>: production in agriculture, forestry, and fishing sector as a percentage of
total production.
</p>
</li>
<li> <pre>sec.energy</pre><p>: production in energy and water sector as a percentage of
total production.
</p>
</li>
<li> <pre>sec.industry</pre><p>: production in industrial sector as a percentage of
total production.
</p>
</li>
<li> <pre>sec.construction</pre><p>: production in construction and engineering sector as a percentage of
total production.
</p>
</li>
<li> <pre>sec.energy</pre><p>: production in marketable services sector as a percentage of
total production.
</p>
</li>
<li> <pre>sec.energy</pre><p>: production in Nonmarketable services sector as a percentage of
total production.
</p>
</li>
<li> <pre>school.illit</pre><p>: number of illiterate persons.
</p>
</li>
<li> <pre>school.prim</pre><p>: number of persons with primary education or without studies.
</p>
</li>
<li> <pre>school.med</pre><p>: number of persons with some high school education.
</p>
</li>
<li> <pre>school.high</pre><p>: number of persons with high school degree.
</p>
</li>
<li> <pre>school.post.high</pre><p>: number of persons with tertiary education. 
</p>
</li>
<li> <pre>popdens</pre><p>: population density (persons per square kilometer).
</p>
</li>
<li> <pre>invest</pre><p>: gross total investment as a share of GDP.
</p>
</li></ul>



<h3>Source</h3>

<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>

<hr>
<h2 id='collect.optimx'>
Collect results from optimx optimization methods
</h2><span id='topic+collect.optimx'></span>

<h3>Description</h3>

<p>An internal function that collects the results from the different optimization methods run by optimx. It stores the parameter and function values and extracts the results for the best performing method (minimum or maximum).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect.optimx(res, opt = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect.optimx_+3A_res">res</code></td>
<td>

<p>Output from a call to optimx().
</p>
</td></tr>
<tr><td><code id="collect.optimx_+3A_opt">opt</code></td>
<td>

<p>Either &quot;min&quot; or &quot;max&quot; to extract results for he methods that obtained the minimum or maximum function value 
across the methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out.list</code></td>
<td>
<p>Dataframe with results from the different methods.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>Parameter values from method that attained minimum/maximum across the methods.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Function value from method that attained minimum/maximum across the methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Hainmueller
</p>


<h3>See Also</h3>

<p>Also see <code><a href="optimx.html#topic+optimx">optimx</a></code>.
</p>

<hr>
<h2 id='dataprep'>Constructs a list of matrices from panel dataset to be loaded into synth()</h2><span id='topic+dataprep'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+synth">synth</a></code> function takes a standard panel dataset and produces a list of data objects necessary for running <code><a href="#topic+synth">synth</a></code> and other Synth package functions to construct synthetic control groups according to the methods outlined in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010, 2011, 2014) (see references and example). 
</p>
<p>User supplies a dataframe (&quot;foo&quot;), chooses predictors, special predictors (explained below), the operators that act upon these predictors, the dependent variable, identifies the columns associated with unit numbers, time periods (and unit names, when available), as well as the treated unit, the control units, the time-period over which to select the predictors, the time-period over which to optimize, and the time-period over which outcome data should be plotted.
</p>
<p>The output of <code><a href="#topic+dataprep">dataprep</a></code> contains a list of matrices. This list object can be directly loaded into <code><a href="#topic+synth">synth</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataprep(foo = NULL, predictors = NULL,
          predictors.op = "mean", special.predictors = NULL,
          dependent = NULL, unit.variable = NULL,
          time.variable = NULL, treatment.identifier = NULL,
          controls.identifier = NULL, time.predictors.prior = NULL,
          time.optimize.ssr = NULL, time.plot = time.optimize.ssr,
          unit.names.variable = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataprep_+3A_foo">foo</code></td>
<td>
<p>The dataframe with the panel data.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_predictors">predictors</code></td>
<td>
<p>A vector of column numbers or column-name character
strings that identifies the predictors' columns. All predictors have to be numeric.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_predictors.op">predictors.op</code></td>
<td>
<p>A character string identifying the method (operator) to be used
on the predictors.  Default is &quot;mean&quot;. rm.na = T is hardwired into
the code. See *Details*.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_special.predictors">special.predictors</code></td>
<td>
<p>A list object identifying additional numeric predictors and their associated pre-treatment years and operators (analogous to
&ldquo;predictors.op&rdquo; above).  See *Details*.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_dependent">dependent</code></td>
<td>
<p>A scalar identifying the column number or column-name character string that corresponds to the numeric dependent (outcome) variable.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_unit.variable">unit.variable</code></td>
<td>
<p>A scalar identifying the column number or column-name character string associated unit numbers. The unit.varibale has to be numeric.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_time.variable">time.variable</code></td>
<td>
<p>A scalar identifying column number or column-name character string associated with period (time) data. The time variable has to be numeric.</p>
</td></tr> 
<tr><td><code id="dataprep_+3A_treatment.identifier">treatment.identifier</code></td>
<td>
<p>A scalar identifying the &ldquo;unit.variable&rdquo; number or a character string
giving the &ldquo;unit.name &rdquo;of the treated unit. If a character is supplied, a unit.names.variable also has to be supplied to identify the treated unit.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_controls.identifier">controls.identifier</code></td>
<td>
<p> A scalar identifying the &ldquo;unit.variable&rdquo; numbers or a vector of character strings giving the &ldquo;unit.name&rdquo;s of control units. If a character is supplied, a unit.names.variable also has to be supplied to identify the control units unit.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_time.predictors.prior">time.predictors.prior</code></td>
<td>
<p>A numeric vector identifying the pretreatment periods over which the values for the outcome predictors should be averaged.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_time.optimize.ssr">time.optimize.ssr</code></td>
<td>
<p>A numeric vector identifying the periods of the dependent variable over which the loss function 
should be minimized (i.e. the periods over which mean squared prediction error (MSPE) , that is the sum of squared residuals between treated and the synthetic control unit, are minimized.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_time.plot">time.plot</code></td>
<td>
<p>A vector identifying the periods over which results are to be plotted
with <code><a href="#topic+gaps.plot">gaps.plot</a></code> and <code><a href="#topic+path.plot">path.plot</a></code>.</p>
</td></tr>
<tr><td><code id="dataprep_+3A_unit.names.variable">unit.names.variable</code></td>
<td>
<p>A scalar or column-name character string identifying the column with the names of the units. This variable has to be of mode character. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The predictors.op argument is a character string that provides a
function (eg., &quot;mean&quot;, &quot;median&quot;, etc.) identifying the name of the
operator to be applied to the predictors over the given time period. 
</p>
<p>The special.predictors argument is a list object that contains one or
more lists of length = 3.  The required components of each of these lists are:
</p>
<p>(a) scalar column number associated with that predictor
(b) vector of time-period number(s) desired (eg., 1998:2003)
(c) character-string identifying the name of the operation 
to be applied (ie., &quot;mean&quot;, &quot;median&quot;, etc.)
</p>
<p>eg.,
special.predictors &lt;- list(listc(x1, 1990:2000, &quot;mean&quot;),
listc(x2, 1980:1983, &quot;median&quot;),
listc(x3, 1980, &quot;mean&quot;)   
)
</p>
<p>indicates that predictor x1, should be used with its values averaged over periods 1990:2000; 
predicator x2 should be used with its median values over periods 1980:1983; x3 should be used with the values from period 1980 only.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>X1</code></td>
<td>
<p>matrix of treated predictor data.
nrows = number of predictors and (possibly) special predictors. ncols = one.
</p>
</td></tr>
<tr><td><code>X0</code></td>
<td>
<p>matrix of controls' predictor data. nrows = number of predictors and (possibly) special predictors. ncols = number of control units.
</p>
</td></tr>
<tr><td><code>Z1</code></td>
<td>
<p>matrix of treated outcome data for the pre-treatment periods over which MSPE is to be minimized. nrows = number of pre-treatment periods. ncols = one.
</p>
</td></tr>
<tr><td><code>Z0</code></td>
<td>
<p>matrix of controls' outcome data for the pre-treatment periods over which MSPE is to be minimized.
nrows = number of pre-treatment periods.
ncols = number of control units.
</p>
</td></tr>
<tr><td><code>Y1plot</code></td>
<td>
<p>matrix of outcome data for treated unit to be used for results plotting. nrows = number of periods. ncols = one.
</p>
</td></tr>
<tr><td><code>Y0plot</code></td>
<td>
<p>matrix of outcome data for control units to be used for results plotting. nrows = number of periods. ncols = number of control units. 
</p>
</td></tr>
<tr><td><code>names.and.numbers</code></td>
<td>
<p>dataframe with two columns showing all unit numbers and
corresponding unit names.
</p>
</td></tr>
<tr><td><code>tag</code></td>
<td>
<p>a list of all arguments in initial function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>, <code><a href="#topic+synth.tab">synth.tab</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The usual sequence of commands is:
## 1. dataprep() for matrix-extraction
## 2. synth() for the construction of the synthetic control group
## 3. synth.tab(), gaps.plot(), and path.plot() to summarize the results
## Below we provide two examples.

## First Example: Toy panel dataset

# load data
data(synth.data)

# create matrices from panel data that provide inputs for synth()
dataprep.out&lt;-
  dataprep(
   foo = synth.data,
   predictors = c("X1", "X2", "X3"),
   predictors.op = "mean",
   dependent = "Y",
   unit.variable = "unit.num",
   time.variable = "year",
   special.predictors = list(
      list("Y", 1991, "mean"),
      list("Y", 1985, "mean"),
      list("Y", 1980, "mean")
                            ),
   treatment.identifier = 7,
   controls.identifier = c(29, 2, 13, 17, 32, 38),
   time.predictors.prior = c(1984:1989),
   time.optimize.ssr = c(1984:1990),
   unit.names.variable = "name",
   time.plot = 1984:1996
   )

## run the synth command to identify the weights
## that create the best possible synthetic 
## control unit for the treated.
synth.out &lt;- synth(dataprep.out)

## there are two ways to summarize the results
## we can either access the output from synth.out directly
round(synth.out$solution.w,2)
# contains the unit weights or
synth.out$solution.v 
## contains the predictor weights. 

## the output from synth opt 
## can be flexibly combined with 
## the output from dataprep to 
## compute other quantities of interest
## for example, the period by period 
## discrepancies between the 
## treated unit and its synthetic control unit
## can be computed by typing
gaps&lt;- dataprep.out$Y1plot-(
        dataprep.out$Y0plot%*%synth.out$solution.w
        ) ; gaps

## also there are three convenience functions to summarize results.
## to get summary tables for all information 
## (V and W weights plus balance btw. 
## treated and synthetic control) use the 
## synth.tab() command
synth.tables &lt;- synth.tab(
      dataprep.res = dataprep.out,
      synth.res = synth.out)
print(synth.tables)

## to get summary plots for outcome trajectories 
## of the treated and the synthetic control unit use the 
## path.plot() and the gaps.plot() commands

## plot in levels (treated and synthetic)
path.plot(dataprep.res = dataprep.out,synth.res = synth.out)

## plot the gaps (treated - synthetic)
gaps.plot(dataprep.res = dataprep.out,synth.res = synth.out)



## Second example: The economic impact of terrorism in the
## Basque country using data from Abadie and Gardeazabal (2003)
## see JSS paper in the references details

data(basque)

# dataprep: prepare data for synth
dataprep.out &lt;-
  dataprep(
  foo = basque
  ,predictors= c("school.illit",
                 "school.prim",
                 "school.med",
                 "school.high",
                 "school.post.high"
                 ,"invest"
                 )
   ,predictors.op = c("mean")
   ,dependent     = c("gdpcap")
   ,unit.variable = c("regionno")
   ,time.variable = c("year")
   ,special.predictors = list(
    list("gdpcap",1960:1969,c("mean")),                            
    list("sec.agriculture",seq(1961,1969,2),c("mean")),
    list("sec.energy",seq(1961,1969,2),c("mean")),
    list("sec.industry",seq(1961,1969,2),c("mean")),
    list("sec.construction",seq(1961,1969,2),c("mean")),
    list("sec.services.venta",seq(1961,1969,2),c("mean")),
    list("sec.services.nonventa",seq(1961,1969,2),c("mean")),
    list("popdens",1969,c("mean")))
    ,treatment.identifier  = 17
    ,controls.identifier   = c(2:16,18)
    ,time.predictors.prior = c(1964:1969)
    ,time.optimize.ssr     = c(1960:1969)
    ,unit.names.variable   = c("regionname")
    ,time.plot            = c(1955:1997) 
    )

# 1. combine highest and second highest 
# schooling category and eliminate highest category
dataprep.out$X1["school.high",] &lt;- 
 dataprep.out$X1["school.high",] + 
 dataprep.out$X1["school.post.high",]
dataprep.out$X1                 &lt;- 
 as.matrix(dataprep.out$X1[
  -which(rownames(dataprep.out$X1)=="school.post.high"),])
dataprep.out$X0["school.high",] &lt;- 
 dataprep.out$X0["school.high",] + 
 dataprep.out$X0["school.post.high",]
dataprep.out$X0                 &lt;- 
dataprep.out$X0[
 -which(rownames(dataprep.out$X0)=="school.post.high"),]

# 2. make total and compute shares for the schooling catgeories
lowest  &lt;- which(rownames(dataprep.out$X0)=="school.illit")
highest &lt;- which(rownames(dataprep.out$X0)=="school.high")

dataprep.out$X1[lowest:highest,] &lt;- 
 (100 * dataprep.out$X1[lowest:highest,]) /
 sum(dataprep.out$X1[lowest:highest,])
dataprep.out$X0[lowest:highest,] &lt;-  
 100 * scale(dataprep.out$X0[lowest:highest,],
             center=FALSE,
             scale=colSums(dataprep.out$X0[lowest:highest,])
                                                 )
    
# run synth
synth.out &lt;- synth(data.prep.obj = dataprep.out)

# Get result tables
synth.tables &lt;- synth.tab(
                          dataprep.res = dataprep.out,
                          synth.res = synth.out
                          ) 

# results tables:
print(synth.tables)

# plot results:
# path
path.plot(synth.res = synth.out,
          dataprep.res = dataprep.out,
          Ylab = c("real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(0,13), 
          Legend = c("Basque country","synthetic Basque country"),
          ) 

## gaps
gaps.plot(synth.res = synth.out,
          dataprep.res = dataprep.out, 
          Ylab = c("gap in real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(-1.5,1.5), 
          )
          
## To create the placebo studies simply reassign
## the intervention to other units or times (see references for details)

</code></pre>

<hr>
<h2 id='fn.V'>
Loss Function for nested optimization of W and V weights
</h2><span id='topic+fn.V'></span>

<h3>Description</h3>

<p>Loss function for the nested optimization of W and V weights used for constructing synthetic control groups according to the methods outlined in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010, 2011, 2014) (see references). This function is called by <code><a href="#topic+synth">synth</a></code> internally, and should not be called manually by a normal user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn.V(variables.v = stop("variables.v missing"),
X0.scaled = stop("X0.scaled missing"), 
X1.scaled = stop("X1.scaled missing"), 
Z0 = stop("Z0 missing"), 
Z1 = stop("Z1 missing"), 
margin.ipop = 5e-04, 
sigf.ipop = 5, 
bound.ipop = 10, 
quadopt = "ipop")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn.V_+3A_variables.v">variables.v</code></td>
<td>

<p>1 by k a vector of v weights.
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_x0.scaled">X0.scaled</code></td>
<td>

<p>matrix of controls' predictor data. nrows = number of predictors and (possibly) special predictors. ncols = number of control units.
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_x1.scaled">X1.scaled</code></td>
<td>
<p>matrix of treated predictor data. nrows = number of predictors and (possibly) special predictors. ncols = one.
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_z0">Z0</code></td>
<td>
<p>matrix of controls' outcome data for the pre-treatment periods over which MSPE is to be minimized. nrows = number of pre-treatment periods. ncols = number of control units.
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_z1">Z1</code></td>
<td>

<p>matrix of treated outcome data for the pre-treatment periods over which MSPE is to be minimized. nrows = number of pre-treatment periods. ncols = one.
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_margin.ipop">margin.ipop</code></td>
<td>

<p>setting for ipop optimization routine: how close we get to the constrains (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_sigf.ipop">sigf.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Precision (default: 7 significant figures (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_bound.ipop">bound.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Clipping bound for the variables (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="fn.V_+3A_quadopt">quadopt</code></td>
<td>

<p>string vector that specifies the routine for quadratic optimization over w weights. 
possible values are &quot;ipop&quot;   (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar that contains the function value.
</p>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond
</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>,
<code><a href="#topic+synth.tab">synth.tab</a></code>
</p>

<hr>
<h2 id='gaps.plot'>Plots Gap in Outcome Trajectories between the Treated its Synthetic Control Unit</h2><span id='topic+gaps.plot'></span>

<h3>Description</h3>

<p> This function plots the gaps in the trajectories of the outcome variable for the treated unit and the 
synthetic control group constructed by <code><a href="#topic+synth">synth</a></code> and <code><a href="#topic+dataprep">dataprep</a></code>. The user can specify whether
the whole time period or only the pre-treatment period should be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaps.plot(synth.res = NA,
       dataprep.res = NA,
       Ylab = c("Title"),
       Xlab = c("Time"),
       Main = c("Gaps: Treated - Synthetic"),
       tr.intake = NA,
       Ylim = NA,
       Z.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaps.plot_+3A_synth.res">synth.res</code></td>
<td>
<p>Output list created by <code><a href="#topic+synth">synth</a></code>.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_dataprep.res">dataprep.res</code></td>
<td>
<p>Output list created by <code><a href="#topic+dataprep">dataprep</a></code>.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_tr.intake">tr.intake</code></td>
<td>
<p>Optional scalar to indicate the time of treatment intake with a vertical line.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_ylab">Ylab</code></td>
<td>
<p>Optional label for Y axis.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_xlab">Xlab</code></td>
<td>
<p>Optional label for X axis.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_ylim">Ylim</code></td>
<td>
<p>Optional Ylim.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_main">Main</code></td>
<td>
<p>Optional main title.</p>
</td></tr>
<tr><td><code id="gaps.plot_+3A_z.plot">Z.plot</code></td>
<td>
<p>Flag. If true, only pretreatment period is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The trajectory of the outcome for the synthetic control group is calculated as:
dataprep.res$Y0plot %*% synth.res$solution.w. You can use this calculation to construct custom made plots.
</p>


<h3>Value</h3>

<p>The plot of trajectories.</p>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>, <code><a href="#topic+synth.tab">synth.tab</a></code>
</p>

<hr>
<h2 id='path.plot'>Plots Outcome Trajectories for Treated Unit and its Synthetic Control Unit</h2><span id='topic+path.plot'></span>

<h3>Description</h3>

<p>This function plots the trajectories of the outcome variable for the treated unit and the synthetic control group constructed by <code><a href="#topic+synth">synth</a></code> and <code><a href="#topic+dataprep">dataprep</a></code>. The user can specify whether the whole 
time period or only the pretreatment period should be plotted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.plot(synth.res = NA,
dataprep.res = NA,
tr.intake = NA,
Ylab = c("Y Axis"),
Xlab = c("Time"),
Ylim = NA,
Legend=c("Treated","Synthetic"),
Legend.position=c("topright"),
Main = NA,
Z.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path.plot_+3A_synth.res">synth.res</code></td>
<td>
<p>Output list created by <code><a href="#topic+synth">synth</a></code>.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_dataprep.res">dataprep.res</code></td>
<td>
<p>Output list created by <code><a href="#topic+dataprep">dataprep</a></code>.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_tr.intake">tr.intake</code></td>
<td>
<p>Optional scalar to indicate the time of treatment intake with a vertical line.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_ylab">Ylab</code></td>
<td>
<p>Optional label for Y axis.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_xlab">Xlab</code></td>
<td>
<p>Optional label for X axis.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_ylim">Ylim</code></td>
<td>
<p>Optional Ylim.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_main">Main</code></td>
<td>
<p>Optional main title.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_legend">Legend</code></td>
<td>
<p>Optional legend text (e.g. c(&quot;Treated&quot;,&quot;Synthetic&quot;)); see ?legend for details.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_legend.position">Legend.position</code></td>
<td>
<p>Optional legend position (e.g. &quot;bottomright&quot;); see ?legend for details.</p>
</td></tr>
<tr><td><code id="path.plot_+3A_z.plot">Z.plot</code></td>
<td>
<p>Flag. If true, only pretreatment period is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trajectory of the outcome for the synthetic control group is calculated as:
dataprep.res$Y0plot%*% synth.res$solution.w. You can use this calculation
to construct custom made plots.
</p>


<h3>Value</h3>

<p>The plot of trajectories.
</p>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+synth.tab">synth.tab</a></code>
</p>

<hr>
<h2 id='spec.pred.func'>Special Predictor Function for Dataprep</h2><span id='topic+spec.pred.func'></span>

<h3>Description</h3>

<p> This function is called by <code><a href="#topic+dataprep">dataprep</a></code> to handle special predictors in the process of setting up the dataset to be loaded into <code><a href="#topic+synth">synth</a></code>. It should not be called manually by the normal user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec.pred.func(list.object = NULL,
          tr.numb = NULL,
          co.numb = NULL,
          unit.var = NULL,
          time.var = NULL,
          foo.object = NULL,
          X0.inner = NULL,
          X1.inner = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec.pred.func_+3A_list.object">list.object</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_tr.numb">tr.numb</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_co.numb">co.numb</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_unit.var">unit.var</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_time.var">time.var</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_foo.object">foo.object</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_x0.inner">X0.inner</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="spec.pred.func_+3A_x1.inner">X1.inner</code></td>
<td>
<p>NA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA
</p>


<h3>Value</h3>

<p>NA
</p>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>, <code><a href="#topic+synth.tab">synth.tab</a></code> </p>

<hr>
<h2 id='synth'>
Constructs synthetic control units for comparative case studies
</h2><span id='topic+synth'></span>

<h3>Description</h3>

<p>Implements the synthetic control method for causal inference in comparative case studies as developed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010, 2011, 2014). <code><a href="#topic+synth">synth</a></code> estimates the effect of an intervention by comparing the evolution of an aggregate outcome for a unit affected by the intervention to the evolution of the same aggregate outcome for a synthetic control group.
</p>
<p><code><a href="#topic+synth">synth</a></code> constructs this synthetic control group by searching for a weighted combination of control units chosen to approximate the unit affected by the intervention in terms of characteristics that are predictive of the outcome. The evolution of the outcome for the resulting synthetic control group is an estimate of the counterfactual of what would have been observed for the affected unit in the absence of the intervention. 
</p>
<p><code><a href="#topic+synth">synth</a></code> can also be used to conduct a variety of placebo and permutation tests that produce
informative inference regardless of the number of available comparison units and the number of available time-periods. See Abadie and Gardeazabal (2003), Abadie, Diamond, and Hainmueller (2010, 2011, 2014) for details.
</p>
<p><code><a href="#topic+synth">synth</a></code> requires the user to supply four matrices as its main arguments. These matrices are named X0, X1, Z1, and Z0 accordingly. X1 and X0 contain the predictor values for the treated unit and the control units respectively. Z1 and Z0 contain the outcome variable for the pre-intervention period for the treated unit and the control unit respectively. The pre-intervention period refers to the time period prior to the intervention, over which the mean squared prediction error (MSPE) should be minimized. The MSPE refers to the squared deviations between the outcome for the treated unit and the
synthetic control unit summed over all pre-intervention periods specified in Z1 and Z0.
</p>
<p>Creating the matrices X1, X0, Z1, and Z0 from a (panel) dataset can be tedious. Therefore the <code>Synth</code> library offers a preparatory function called <code><a href="#topic+dataprep">dataprep</a></code> that allows the user to easily create all inputs required for <code><a href="#topic+synth">synth</a></code>. By first calling <code><a href="#topic+dataprep">dataprep</a></code> the user creates a single list object called <code>data.prep.obj</code> that contains all essential data elements to run <code>synth</code>. 
</p>
<p>Accordingly, a usual sequence of commands to implement the synthetic control method is to first call <code><a href="#topic+dataprep">dataprep</a></code> to prepare the data to be loaded into <code><a href="#topic+synth">synth</a></code>. Then 
<code><a href="#topic+synth">synth</a></code> is called to construct the synthetic control group. Finally, results are 
summarized using the functions <code><a href="#topic+synth.tab">synth.tab</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>, or <code><a href="#topic+gaps.plot">gaps.plot</a></code>.
</p>
<p>An example of this sequence is provided in the documentation to <code><a href="#topic+dataprep">dataprep</a></code>. This procedure is strongly recommended. Alternatively, the user may provide his own preprocessed data matrices and load them into <code><a href="#topic+synth">synth</a></code> via the X0, X1, Z1, and Z0 arguments. In this case, no data.prep.obj should be specified.
</p>
<p>The output from <code><a href="#topic+synth">synth</a></code> is a list object that contains the weights on predictors (solution.V) and weights on control units (solution.W) that define contributions 
to the synthetic control unit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth(data.prep.obj = NULL,
X1 = NULL, X0 = NULL, 
Z0 = NULL, Z1 = NULL, 
custom.v = NULL, 
optimxmethod = c("Nelder-Mead", "BFGS"), 
genoud = FALSE, quadopt = "ipop", 
Margin.ipop = 5e-04, 
Sigf.ipop = 5, 
Bound.ipop = 10, 
verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth_+3A_data.prep.obj">data.prep.obj</code></td>
<td>

<p>the object that comes from running <code><a href="#topic+dataprep">dataprep</a></code>. This object contains all information about X0, X1, Z1, and Z0. Therefore, if data.prep.obj is supplied, none of X0, X1, Z1, and Z0 should be manually specified!
</p>
</td></tr>
<tr><td><code id="synth_+3A_x1">X1</code></td>
<td>

<p>matrix of treated predictor data, nrows = number of predictors ncols = ones.
</p>
</td></tr>
<tr><td><code id="synth_+3A_x0">X0</code></td>
<td>

<p>matrix of controls' predictor data. nrows = number of predictors. ncols = number of control units (&gt;=2). 
</p>
</td></tr>
<tr><td><code id="synth_+3A_z1">Z1</code></td>
<td>

<p>matrix of treated outcome data for the pre-treatment periods over which MSPE is to be minimized.
nrows = number of pre-treatment periods. ncols = 1.
</p>
</td></tr>
<tr><td><code id="synth_+3A_z0">Z0</code></td>
<td>

<p>matrix of controls' outcome data for the pre-treatment periods over which MSPE is to be minimized. nrows = number of pre-treatment periods. ncols = number of control units.
</p>
</td></tr>
<tr><td><code id="synth_+3A_custom.v">custom.v</code></td>
<td>

<p>vector of weights for predictors supplied by the user. uses <code>synth</code> to bypass optimization for solution.V. See details.
</p>
</td></tr>
<tr><td><code id="synth_+3A_optimxmethod">optimxmethod</code></td>
<td>

<p>string vector that specifies the optimization algorithms to be used. Permissable values are all optimization algorithms that are currently implemented in the <code><a href="optimx.html#topic+optimx">optimx</a></code> function (see this function for details). This list currently includes c(&quot;Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf&quot;). If multiple algorithms are specified, <code><a href="#topic+synth">synth</a></code> will run the optimization with all chosen algorithms and then return the result for the best performing method. Default is c(&quot;Nelder-Mead&quot;, &quot;BFGS&quot;). As an additional possibility, the user can also specify 'All' which means that <code><a href="#topic+synth">synth</a></code> will run the results over all algorithms in <code><a href="optimx.html#topic+optimx">optimx</a></code>. 
</p>
</td></tr>
<tr><td><code id="synth_+3A_genoud">genoud</code></td>
<td>

<p>Logical flag. If true, <code><a href="#topic+synth">synth</a></code> embarks on a two step optimization. In the first step, <code><a href="rgenoud.html#topic+genoud">genoud</a></code>, an optimization function that combines evolutionary algorithm methods with a derivative-based (quasi-Newton) method to solve difficult optimization problems, is used to obtain a solution. See <code><a href="rgenoud.html#topic+genoud">genoud</a></code> for details. In the second step, the genoud results are passed to the optimization algorithm(s) chosen in <code>optimxmethod</code> for a local optimization within the neighborhood of the genoud solution. This two step optimization procedure will require much more computing time, but may yield lower loss in cases where the search space is highly irregular.
</p>
</td></tr>
<tr><td><code id="synth_+3A_quadopt">quadopt</code></td>
<td>

<p>string vector that specifies the routine for quadratic optimization over w weights. possible values are &quot;ipop&quot; (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details). 
</p>
</td></tr>
<tr><td><code id="synth_+3A_margin.ipop">Margin.ipop</code></td>
<td>

<p>setting for ipop optimization routine: how close we get to the constrains (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="synth_+3A_sigf.ipop">Sigf.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Precision (default: 7 significant figures (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="synth_+3A_bound.ipop">Bound.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Clipping bound for the variables (see <code><a href="kernlab.html#topic+ipop">ipop</a></code> for details)
</p>
</td></tr>
<tr><td><code id="synth_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag. If TRUE then intermediate results will be shown.
</p>
</td></tr>
<tr><td><code id="synth_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code><a href="optimx.html#topic+optimx">optimx</a></code> and or <code><a href="rgenoud.html#topic+genoud">genoud</a></code> to adjust optimization.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010), the <code><a href="#topic+synth">synth</a></code> function routinely searches for the set of weights that generate the best fitting convex combination of the control units. In other words, the predictor weight matrix V is chosen among all positive definite diagonal matrices such that MSPE is minimized for the pre-intervention period. 
</p>
<p>Instead of using this data-driven procedures to search for the best fitting synthetic control group, the
user may supply his own vector of V weights, based on his subjective assessment of the predictive power of the variables in X1 and X0. In this case, the vector of V weights for each variable should be supplied via the <code>custom.V</code> option in <code><a href="#topic+synth">synth</a></code> and the optimization over the V matrices is bypassed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>solution.v</code></td>
<td>
<p>vector of predictor weights.</p>
</td></tr>
<tr><td><code>solution.w</code></td>
<td>
<p>vector of weights across the controls.</p>
</td></tr>
<tr><td><code>loss.v</code></td>
<td>
<p>  MSPE from optimization over v and w weights.</p>
</td></tr>
<tr><td><code>loss.w</code></td>
<td>
<p>  Loss from optimization over w weights.</p>
</td></tr>
<tr><td><code>custom.v</code></td>
<td>
<p>if this argument was specified in the call to <code><a href="#topic+synth">synth</a></code>, this
outputs the weight vector specified.</p>
</td></tr>
<tr><td><code>rgV.optim</code></td>
<td>
<p>Results from optimx() minimization. Could be used for diagnostics.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond
</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>, <code><a href="#topic+synth.tab">synth.tab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## While synth() can be used to construct synthetic control groups
## directly, by providing the X1, X0, Z1, and Z0 matrices, we strongly
## recommend to first run dataprep() to extract these matrices 
## and pass them to synth() as a single object

## The usual sequence of commands is:
## 1. dataprep() for matrix-extraction
## 2. synth() for the construction of the synthetic control group
## 3. synth.tab(), gaps.plot(), and path.plot() to summarize the results
## Below we provide two examples


## First Example: Toy panel dataset

# load data
data(synth.data)

# create matrices from panel data that provide inputs for synth()
dataprep.out&lt;-
  dataprep(
   foo = synth.data,
   predictors = c("X1", "X2", "X3"),
   predictors.op = "mean",
   dependent = "Y",
   unit.variable = "unit.num",
   time.variable = "year",
   special.predictors = list(
      list("Y", 1991, "mean"),
      list("Y", 1985, "mean"),
      list("Y", 1980, "mean")
                            ),
   treatment.identifier = 7,
   controls.identifier = c(29, 2, 13, 17, 32, 38),
   time.predictors.prior = c(1984:1989),
   time.optimize.ssr = c(1984:1990),
   unit.names.variable = "name",
   time.plot = 1984:1996
   )

## run the synth command to identify the weights
## that create the best possible synthetic 
## control unit for the treated.
synth.out &lt;- synth(dataprep.out)

## there are two ways to summarize the results
## we can either access the output from synth.out directly
round(synth.out$solution.w,2)
# contains the unit weights or
synth.out$solution.v 
## contains the predictor weights. 

## the output from synth opt 
## can be flexibly combined with 
## the output from dataprep to 
## compute other quantities of interest
## for example, the period by period 
## discrepancies between the 
## treated unit and its synthetic control unit
## can be computed by typing
gaps&lt;- dataprep.out$Y1plot-(
        dataprep.out$Y0plot%*%synth.out$solution.w
        ) ; gaps

## also there are three convenience functions to summarize results.
## to get summary tables for all information 
## (V and W weights plus balance btw. 
## treated and synthetic control) use the 
## synth.tab() command
synth.tables &lt;- synth.tab(
      dataprep.res = dataprep.out,
      synth.res = synth.out)
print(synth.tables)

## to get summary plots for outcome trajectories 
## of the treated and the synthetic control unit use the 
## path.plot() and the gaps.plot() commands

## plot in levels (treated and synthetic)
path.plot(dataprep.res = dataprep.out,synth.res = synth.out)

## plot the gaps (treated - synthetic)
gaps.plot(dataprep.res = dataprep.out,synth.res = synth.out)



## Second example: The economic impact of terrorism in the
## Basque country using data from Abadie and Gardeazabal (2003)
## see JSS paper in the references details

data(basque)

# dataprep: prepare data for synth
dataprep.out &lt;-
  dataprep(
  foo = basque
  ,predictors= c("school.illit",
                 "school.prim",
                 "school.med",
                 "school.high",
                 "school.post.high"
                 ,"invest"
                 )
   ,predictors.op = c("mean")
   ,dependent     = c("gdpcap")
   ,unit.variable = c("regionno")
   ,time.variable = c("year")
   ,special.predictors = list(
    list("gdpcap",1960:1969,c("mean")),                            
    list("sec.agriculture",seq(1961,1969,2),c("mean")),
    list("sec.energy",seq(1961,1969,2),c("mean")),
    list("sec.industry",seq(1961,1969,2),c("mean")),
    list("sec.construction",seq(1961,1969,2),c("mean")),
    list("sec.services.venta",seq(1961,1969,2),c("mean")),
    list("sec.services.nonventa",seq(1961,1969,2),c("mean")),
    list("popdens",1969,c("mean")))
    ,treatment.identifier  = 17
    ,controls.identifier   = c(2:16,18)
    ,time.predictors.prior = c(1964:1969)
    ,time.optimize.ssr     = c(1960:1969)
    ,unit.names.variable   = c("regionname")
    ,time.plot            = c(1955:1997) 
    )

# 1. combine highest and second highest 
# schooling category and eliminate highest category
dataprep.out$X1["school.high",] &lt;- 
 dataprep.out$X1["school.high",] + 
 dataprep.out$X1["school.post.high",]
dataprep.out$X1                 &lt;- 
 as.matrix(dataprep.out$X1[
  -which(rownames(dataprep.out$X1)=="school.post.high"),])
dataprep.out$X0["school.high",] &lt;- 
 dataprep.out$X0["school.high",] + 
 dataprep.out$X0["school.post.high",]
dataprep.out$X0                 &lt;- 
dataprep.out$X0[
 -which(rownames(dataprep.out$X0)=="school.post.high"),]

# 2. make total and compute shares for the schooling catgeories
lowest  &lt;- which(rownames(dataprep.out$X0)=="school.illit")
highest &lt;- which(rownames(dataprep.out$X0)=="school.high")

dataprep.out$X1[lowest:highest,] &lt;- 
 (100 * dataprep.out$X1[lowest:highest,]) /
 sum(dataprep.out$X1[lowest:highest,])
dataprep.out$X0[lowest:highest,] &lt;-  
 100 * scale(dataprep.out$X0[lowest:highest,],
             center=FALSE,
             scale=colSums(dataprep.out$X0[lowest:highest,])
                                                 )
    
# run synth
synth.out &lt;- synth(data.prep.obj = dataprep.out)

# Get result tables
synth.tables &lt;- synth.tab(
                          dataprep.res = dataprep.out,
                          synth.res = synth.out
                          ) 

# results tables:
print(synth.tables)

# plot results:
# path
path.plot(synth.res = synth.out,
          dataprep.res = dataprep.out,
          Ylab = c("real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(0,13), 
          Legend = c("Basque country","synthetic Basque country"),
          ) 

## gaps
gaps.plot(synth.res = synth.out,
          dataprep.res = dataprep.out, 
          Ylab = c("gap in real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(-1.5,1.5), 
          )


</code></pre>

<hr>
<h2 id='synth.data'>Panel Data to demonstrate the use of the Synthetic Control Method</h2><span id='topic+synth.data'></span>

<h3>Description</h3>

<p>This artificial panel data set is used to demonstrate the use of the 
Synthetic Control Method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(synth.data)</code></pre>


<h3>Format</h3>

<p>A dataframe made up of 8 units: 1 treated (no 7) and 7 control (no. 2,7,13,17,29,32,36,38)
, 3 predictors (X1, X2, X3),  21 time periods (1980 - 2000), a unit.names.variable column (&quot;names&quot;) and an outcome variable column (Y). All columns have column names.</p>

<hr>
<h2 id='synth.tab'>Creates Tables that Summarize Results of Synthetic Control Group Method</h2><span id='topic+synth.tab'></span>

<h3>Description</h3>

<p>This function is called after <code><a href="#topic+dataprep">dataprep</a></code> and <code><a href="#topic+synth">synth</a></code> in order to create tables summarizing the results of the 
run of the synthetic control method. The result tables can be latexed directly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth.tab(synth.res    = NA,
          dataprep.res = NA,
          round.digit  = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth.tab_+3A_synth.res">synth.res</code></td>
<td>
<p>The list resulting from the call to <code><a href="#topic+synth">synth</a></code>.</p>
</td></tr>
<tr><td><code id="synth.tab_+3A_dataprep.res">dataprep.res</code></td>
<td>
<p>The list resulting from the call to <code><a href="#topic+dataprep">dataprep</a></code>.</p>
</td></tr>
<tr><td><code id="synth.tab_+3A_round.digit">round.digit</code></td>
<td>
<p>Integer for rounding in tables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA</p>


<h3>Value</h3>

<table>
<tr><td><code>tab.v</code></td>
<td>
<p>The matrix that contains the table of V-weights and respective variable names.</p>
</td></tr>
<tr><td><code>tab.w</code></td>
<td>
<p>The matrix that contains the table of W-weights and respective unit numbers and possibly names.</p>
</td></tr>
<tr><td><code>tab.loss</code></td>
<td>
<p>The matrix that contains the table of W-loss and V-loss</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Dimaond</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1&ndash;17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493&ndash;505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+dataprep">dataprep</a></code>, <code><a href="#topic+gaps.plot">gaps.plot</a></code>, <code><a href="#topic+path.plot">path.plot</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
