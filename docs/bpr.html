<!DOCTYPE html><html><head><title>Help for package bpr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bpr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bpr-package'><p>bpr: Fitting Bayesian Poisson Regression</p></a></li>
<li><a href='#mcmc_diagnostics'><p>MCMC Convergence Diagnostics</p></a></li>
<li><a href='#merge_sim'><p>Merge Multiple Chains</p></a></li>
<li><a href='#plot.poisreg'><p>Plot Trace and Distribution of Regression Parameters</p></a></li>
<li><a href='#plot.posterior_check'><p>Graphical Posterior Predictive Checks</p></a></li>
<li><a href='#posterior_predictive'><p>Compute Posterior Predictive Distribution</p></a></li>
<li><a href='#sample_bpr'><p>Fitting Bayesian Poisson Regression</p></a></li>
<li><a href='#summary.poisreg'><p>Summarizing Bayesian Poisson Regression Fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Bayesian Poisson Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Laura D'Angelo</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laura D'Angelo &lt;laura.dangelo@live.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Posterior sampling and inference for Bayesian Poisson regression models. The model specification makes use of Gaussian (or conditionally Gaussian) prior distributions on the regression coefficients. Details on the algorithm are found in D'Angelo and Canale (2023) &lt;<a href="https://doi.org/10.1080%2F10618600.2022.2123337">doi:10.1080/10618600.2022.2123337</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), coda, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-15 08:56:04 UTC; laura</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-16 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bpr-package'>bpr: Fitting Bayesian Poisson Regression</h2><span id='topic+bpr'></span><span id='topic+bpr-package'></span>

<h3>Description</h3>

<p>Posterior sampling and inference for Bayesian Poisson regression models. The model specification makes use of Gaussian (or conditionally Gaussian) prior distributions on the regression coefficients. Details on the algorithm are found in D'Angelo and Canale (2021) <a href="https://arxiv.org/abs/2109.09520">arXiv:2109.09520</a>.
</p>

<hr>
<h2 id='mcmc_diagnostics'>MCMC Convergence Diagnostics</h2><span id='topic+mcmc_diagnostics'></span>

<h3>Description</h3>

<p>This function is a method for class <code>poisreg</code>. It prints convergence diagnostics and accuracy statistics of the MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_diagnostics(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_diagnostics_+3A_object">object</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The printed output of <code>mcmc_diagnostics</code> summarizes some common convergence diagnostics for Markov chains. 
The first part recaps the total length, burn-in and thinning used for the simulation.
</p>
<p>The second part is a table with diagnostic statistics about each chain of the regression parameters. The first column is 
the effective sample size computed after removing the burn-in and thinning. 
The last two columns report the value and observed p-value of the Geweke test of equality of the first and last part of the chain.
</p>
<p>The last part is printed only if multiple chains are computed. In this case, it reports the Gelman-Rubin statistics to test convergence to the same stationary  
distribution. Values much larger than 1 suggest lack of convergence to a common distribution.
</p>


<h3>Value</h3>

<p><code>mcmc_diagnostics</code> returns a list with elements:
</p>
<p><code>chain_length</code> : total length of the MCMC chains.
</p>
<p><code>len_burnin</code> : the length of the burn-in used to compute the estimates.
</p>
<p><code>thin</code> : the thinning frequency used (from <code>object</code>).
</p>
<p><code>effSize</code> : effective sample size of each parameter chain after removing burn-in and thinning. See <code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code>.
</p>
<p><code>geweke</code> : Geweke diagnostics of convergence of the chains (value of the test and p-value). See <code><a href="coda.html#topic+geweke.diag">geweke.diag</a></code>
</p>
<p><code>gelman_rubin</code> : if <code>nchains &gt; 1</code>, Gelman-Rubin diagnostics of convergence. See <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.poisreg">summary.poisreg</a></code> , <code><a href="#topic+plot.poisreg">plot.poisreg</a></code> ,
<code><a href="#topic+merge_sim">merge_sim</a></code> , <code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code> , <code><a href="coda.html#topic+geweke.diag">geweke.diag</a></code> , <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For examples see example(sample_bpr)

</code></pre>

<hr>
<h2 id='merge_sim'>Merge Multiple Chains</h2><span id='topic+merge_sim'></span>

<h3>Description</h3>

<p>This function is a method for class <code>poisreg</code>. Merge multiple MCMC chains into a unique chain when sampling with <code>nchains &gt; 1</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_sim(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_sim_+3A_object">object</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>), with <code>nchains &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>poisreg</code> with a single element <code>$sim</code>. 
The returned chains (elements of <code>sim</code>) are obtained by appending the simulated values of each independent chain, 
under the assumption that they all have reached the same stationary distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS) # load the data set
head(epil)

# Simulate multiple chains by setting nchains &gt; 1
fit4 = sample_bpr( y ~  lbase*trt + lage + V4, data = epil, 
                    iter = 1000, 
                    nchains = 4, thin = 2)
# fit4 contains 4 elements with simulation ($sim, $sim2, $sim3, $sim4)

mcmc_diagnostics(fit4)     
# the Gelman-Rubin diagnostics confirms convergence of the 4 
# independent chains to the same stationary distribution

fit4b = merge_sim(fit4) 
str(fit4b$sim)    
# fit 4b contains only one element $sim, of length 1500 
# (which is the result of concatenating the 4 simulations, after removing the first 25% 
# iterations as burn-in and keeping one iteration every two).
</code></pre>

<hr>
<h2 id='plot.poisreg'>Plot Trace and Distribution of Regression Parameters</h2><span id='topic+plot.poisreg'></span>

<h3>Description</h3>

<p>Plot Trace and Distribution of Regression Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poisreg'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.poisreg_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>).</p>
</td></tr>
<tr><td><code id="plot.poisreg_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function calls <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code> on the matrix of sampled regression coefficients, and returns the trace of the sampled outputs and a density estimate for each variable in the chain.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_bpr">sample_bpr</a></code>, <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>
</p>

<hr>
<h2 id='plot.posterior_check'>Graphical Posterior Predictive Checks</h2><span id='topic+plot.posterior_check'></span>

<h3>Description</h3>

<p>This function is a method for class <code>posterior_check</code>. Plot diagnostic statistics for graphical posterior predictive checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'posterior_check'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.posterior_check_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>posterior_check</code>&quot; (usually, the result of a call to <code><a href="#topic+posterior_predictive">posterior_predictive</a></code>).</p>
</td></tr>
<tr><td><code id="plot.posterior_check_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to generate additional plots that compare the posterior predictive distribution of a statistics with the observed value. 
This is done through the parameter <code>stats</code>: it is a list with elements the function names of the statistics one wants to compare. 
Default is <code>stats = list("mean")</code>, other possible values are, e.g., &quot;median&quot;, &quot;sd&quot;, &quot;max&quot; etc.
</p>


<h3>Value</h3>

<p>The function outputs (at least) three plots for graphical posterior predictive check.<br />
The first plot compares the empirical cumulative distribution function (ECDF) with the cumulative distribution function obtained 
with samples from the posterior predictive distribution (median and point-wise 95% credible bands). <br />
The second plot compares the distribution of the observed sample with the predictive distribution obtained using the maximum a posteriori (MAP) 
estimates of the regression parameters.<br />
The third plot compares the predictive distribution of a statistic (default is the mean) with the observed value of the same statistics,
displayed with a red line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_predictive">posterior_predictive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS) # load the data set
head(epil)

fit = sample_bpr( y ~  lbase*trt + lage + V4, data = epil, 
                   iter = 1000)
 plot(posterior_predictive(fit), stats = c("mean", "sd", "max"))   
# plots for posterior predictive check


</code></pre>

<hr>
<h2 id='posterior_predictive'>Compute Posterior Predictive Distribution</h2><span id='topic+posterior_predictive'></span>

<h3>Description</h3>

<p>This function is a method for class <code>poisreg</code>. Compute the posterior predictive distribution and summary statistics for 
posterior check of the model; 
optionally, it also computes
the predictive distribution with new values of the explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_predictive(object, new_X = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predictive_+3A_object">object</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>).</p>
</td></tr>
<tr><td><code id="posterior_predictive_+3A_new_x">new_X</code></td>
<td>
<p>(optional) a data frame in which to look for variables with which to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The call to this function returns an object of S3 class <code>posterior_check</code>. The object is a list with the following elements:
</p>
<p><code>data</code> : the component from <code>object</code> (list with covariates <code>X</code> and response variable <code>y</code>).
</p>
<p><code>y_pred</code> : matrix of dimension <code>[n, iter]</code> (with <code>n</code> sample size), each column is a draw from the posterior predictive distribution.
</p>
<p><code>y_MAP_pred</code> : vector of length <code>n</code> containing a draw from the posterior distribution obtained using the maximum a posteriori estimates (MAP) of the parameters.
</p>
<p><code>diagnostics</code> : list containing 2 elements: <code>CPO</code>, i.e. the Conditional Predictive Ordinate (Gelfand et al. 1992); and <code>LPML</code>, i.e. 
the logarithm of the pseudo-marginal likelihood (Ibrahim et al. 2014).
</p>
<p><code>newdata</code> : if the matrix <code>new_X</code> of new values of the covariates is provided, list of three elements: </p>

<ul>
<li><p><code>new_X</code> : the provided matrix of explanatory variables; 
</p>
</li>
<li><p><code>y_newdata</code> : a matrix of dimension <code>[nrow(new_X), iter]</code>, each column is a draw from the posterior predictive distribution using <code>new_X</code>;
</p>
</li>
<li><p><code>y_MAP_newdata</code> : vector of length <code>nrow(new_X)</code> containing a draw from the posterior distribution obtained using the MAP estimate of the parameters, 
computed on the new data <code>new_X</code>. </p>
</li></ul>

<p><code>perc_burnin</code> : the component from <code>object</code>.
</p>


<h3>References</h3>

<p>Gelfand, A., Dey, D. and Chang, H. (1992), Model determination using predictive distributions with implementation via sampling-based-methods (with discussion), 
in ‘Bayesian Statistics 4’, University Press. <br /><br />
Ibrahim, J. G., Chen, M.H. and Sinha, D. (2014), Bayesian Survival Analysis, American Cancer Society.
</p>

<hr>
<h2 id='sample_bpr'>Fitting Bayesian Poisson Regression</h2><span id='topic+sample_bpr'></span>

<h3>Description</h3>

<p>The function generates draws from the posterior distribution of the coefficients of Poisson regression models. 
The method allows for Gaussian and horseshoe (Carvalho et al, 2010) prior distributions, 
and relies on a Metropolis-Hastings or importance sampler algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_bpr(
  formula = NULL,
  data = NULL,
  iter,
  burnin = NULL,
  prior = list(type = "gaussian", b = NULL, B = NULL, tau = NULL),
  pars = list(method = "MH", max_dist = 50, max_r = NULL, max_dist_burnin = 1e+06),
  state = NULL,
  thin = 1,
  verbose = TRUE,
  seed = NULL,
  nchains = 1,
  perc_burnin = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_bpr_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_data">data</code></td>
<td>
<p>data frame or matrix containing the variables in the model.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_iter">iter</code></td>
<td>
<p>number of algorithm iterations.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_burnin">burnin</code></td>
<td>
<p>(optional) a positive integer specifying the length of the burn-in. 
If a value &gt; 1 is provided, the first <code>burnin</code> iterations use a different tuning parameter in order to better explore the parameter space.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_prior">prior</code></td>
<td>
<p>a named list of parameters to select prior type and parameters, with arguments:
</p>

<ul>
<li> <p><code>type</code> : string specifying whether an informative Gaussian (<code>"gaussian"</code>) or a horseshoe (<code>"horseshoe"</code>) prior should be used. 
Default is <code>"gaussian"</code>.
</p>
</li>
<li> <p><code>b, B</code> : (optional) if a Gaussian prior is used, the mean and covariance matrix passed as prior parameters. 
If not specified, the prior on the regression parameters is centered at zero, with independent N(0,2) components.
</p>
</li>
<li> <p><code>tau</code> : if a horseshoe prior is used, the global shrinkage parameter tau has to be fixed. 
This can be seen as an empirical Bayes approach, and allows to speed convergence and avoid potential convergence issues that often occur when it is sampled.
In general, the parameter can be interpreted as a measure of sparsity, and it should be fixed to small values. See van der Pas et al. (2017) for a discussion.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sample_bpr_+3A_pars">pars</code></td>
<td>
<p>a named list of parameters to select algorithm type and tuning parameters, with arguments:
</p>

<ul>
<li> <p><code>method</code> : the type of algorithm used. Default is a Metropolis-Hastings algorithm (<code>"MH"</code>), 
the alternative is an importance sampler algorithm (<code>"IS"</code>).
</p>
</li>
<li> <p><code>max_dist</code> : tuning parameter controlling the &quot;distance&quot; of the approximation to the true target posterior. 
For the Metropolis-Hastings algorithm, it can be used to balance acceptance rate and autocorrelation of the chains. 
As a general indication, larger values are needed for increasing size/dimension of the data to obtain good results.
#' </p>
</li>
<li> <p><code>max_r</code> : (optional) additional tuning parameter which sets an upper bound for the parameters r controlling the approximation.
</p>
</li>
<li> <p><code>max_dist_burnin</code> : if <code>burnin</code> is specified, the tuning parameter used for the first part of the chain. 
A very large value is sometimes useful to explore the parameter space (especially if the chains are initialized very far from their stationary distribution).
</p>
</li></ul>
</td></tr>
<tr><td><code id="sample_bpr_+3A_state">state</code></td>
<td>
<p>optional vector providing the starting points of the chains.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_thin">thin</code></td>
<td>
<p>a positive integer specifying the period for saving samples. The default is 1.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = TRUE) indicating whether to print messages on the progress of the algorithm and possible convergence issues.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_seed">seed</code></td>
<td>
<p>(optional) positive integer: the seed of random number generator.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_nchains">nchains</code></td>
<td>
<p>(optional) positive integer specifying the number of Markov chains. The default is 1.</p>
</td></tr>
<tr><td><code id="sample_bpr_+3A_perc_burnin">perc_burnin</code></td>
<td>
<p>(default = 0.25) percentage of the chain to be discarded to perform inference. If both burnin and perc_burnin are specified, the most conservative burn-in is considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Bayesian Poisson regression model with Gaussian prior distributions on the regression coefficients:
</p>
<p style="text-align: center;"><code class="reqn"> Y ~ Poisson(\lambda) , \lambda = exp{X \beta} </code>
</p>

<p>where <code class="reqn">Y</code> is a size <code class="reqn">n</code> vector of counts and <code class="reqn">X</code> is a <code class="reqn">n x p</code> matrix of coefficients; and <code class="reqn">(\beta | - )</code> 
has a Gaussian distribution (possibly conditionally on some parameters).
</p>
<p>Specifically, the function allows for informative Gaussian prior distribution on the parameters, 
i.e. <code class="reqn">(\beta_1,...,\beta_p) ~ N_p(b, B)</code>, and for a horseshoe prior distribution (Carvalho et al, 2010). 
The horseshoe prior is a scale mixture of normals, which is typically used in high-dimension settings to induce sparsity and
regularization of the coefficients.
</p>
<p>The implemented Metropolis-Hastings and importance sampler exploit as proposal density a multivariate Gaussian approximation of the 
posterior distribution. Such proposal is based on the convergence of the negative binomial distribution to the Poisson distribution and on
the Polya-gamma data augmentation of Polson et al. (2013).
</p>
<p>The output of the sampling is an object of class <code>poisreg</code> and admits class-specific methods to perform inference.<br />
The function <code><a href="#topic+summary.poisreg">summary.poisreg</a></code> can be used to obtain or print a summary of the results and of the algorithm diagnostics. <br />
The function <code><a href="#topic+mcmc_diagnostics">mcmc_diagnostics</a></code> can be used to obtain or print convergence diagnostics for the sampled chains.  <br />
The function <code><a href="#topic+plot.poisreg">plot.poisreg</a></code> prints the trace of the sampled values and a density estimate of the regression coefficients. 
See <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>.<br />
The function <code><a href="#topic+posterior_predictive">posterior_predictive</a></code> can be used to compute the posterior predictive distributions to check the model. 
See also the related function <code>plot.ppc</code>.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>poisreg</code> containing the results of the sampling. <br />
<code>poisreg</code> is a list containing at least the following elements:
</p>
<p><code>sim</code> : list of the results of the sampling. It contains the following elements: </p>

<ul>
<li> <p><code>beta</code> : <code><a href="coda.html#topic+mcmc">mcmc</a></code> object of posterior draws of the regression coefficients.
</p>
</li>
<li> <p><code>r</code> : the sequence of adaptive tuning parameters used in each iteration. 
</p>
</li>
<li> <p><code>time</code> : the total amount of time to perform the simulation. 
</p>
</li></ul>

<p><code>formula</code>  : the <code>formula</code> object used.
</p>
<p><code>data</code>  : list with elements the matrix of covariates <code>X</code> and response variable <code>y</code>.
</p>
<p><code>state</code>  : the starting points of the chain.
</p>
<p><code>burnin</code>  : length of the used burn-in.
</p>
<p><code>prior</code>  : whether a Gaussian or horseshoe prior was used.
</p>
<p><code>prior_pars</code>  : prior parameters.
</p>
<p><code>thin</code>  : thinning frequency passed to the <code>thin</code> parameter.
</p>
<p><code>nchains</code>  : number of chains. If <code>nchains</code> was chosen &gt;1, the output list will also include additional 
numbered <code>sim</code> elements, one for each sampled chain.
</p>
<p><code>perc_burnin</code> : percentage of the chain used as burn-in.
</p>


<h3>References</h3>

<p>Carvalho, C., Polson, N., &amp; Scott, J. (2010). The horseshoe estimator for sparse signals. Biometrika, 97(2), 465-480.<br /><br />
van der Pas, S., Szabo, B. and van der Vaart, A. (2017), Adaptive posterior contractionrates for the horseshoe, Electronic Journal of Statistics, 11(2), 3196-3225.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.poisreg">summary.poisreg</a></code> , <code><a href="#topic+mcmc_diagnostics">mcmc_diagnostics</a></code> , <code><a href="#topic+plot.poisreg">plot.poisreg</a></code> ,
<code><a href="#topic+merge_sim">merge_sim</a></code> , <code><a href="#topic+posterior_predictive">posterior_predictive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS) # load the data set
head(epil)

fit = sample_bpr( y ~  lbase*trt + lage + V4, data = epil, 
                   iter = 1000)
                   
summary(fit)    # summary of posterior inference
mcmc_diagnostics(fit)    # summary of MCMC convergence diagnostics

plot(fit)    


## Examples with different options
# Select prior parameters and set tuning parameter 
fit2 = sample_bpr( y ~  lbase*trt + lage + V4, data = epil, 
                    iter = 1000, 
                    prior = list( type = "gaussian", b = rep(0, 6), 
                                  B = diag(6) * 3 ),
                    pars = list( max_dist = 10 ))
                    
# Simulate multiple chains and merge outputs after checking convergence
fit3 = sample_bpr( y ~  lbase*trt + lage + V4, data = epil, 
                    iter = 1000, 
                    nchains = 4, thin = 2)
# fit3 now contains additional elements ($sim2, $sim3, $sim4)

mcmc_diagnostics(fit3)     
# the Gelman-Rubin diagnostics confirms convergence of the 4 
# independent chains to the same stationary distribution

fit3b = merge_sim(fit3) 
str(fit3b$sim)    
# fit 3b contains only one MCMC chain of length 1500 
# (after thinning and burn-in)


## introduce more variables and use regularization
epil2 &lt;- epil[epil$period == 1, ]
epil2["period"] &lt;- rep(0, 59); epil2["y"] &lt;- epil2["base"]
epil["time"] &lt;- 1; epil2["time"] &lt;- 4
epil2 &lt;- rbind(epil, epil2)
epil2$pred &lt;- unclass(epil2$trt) * (epil2$period &gt; 0) 
epil2$subject &lt;- factor(epil2$subject)
epil3 &lt;- aggregate(epil2, list(epil2$subject, epil2$period &gt; 0),
                   function(x) if(is.numeric(x)) sum(x) else x[1])
                   epil3$pred &lt;- factor(epil3$pred,
                   labels = c("base", "placebo", "drug"))
contrasts(epil3$pred) &lt;- structure(contr.sdif(3),
                         dimnames = list(NULL, c("placebo-base", "drug-placebo")))
                         
fit4 = sample_bpr(y ~ pred + factor(subject), data = epil3,
                pars = list(max_dist = 0.3),
                prior = list(type = "horseshoe", tau = 2),
                iter = 3000, burnin = 1000)
summary(fit4)
mcmc_diagnostics(fit4)
plot(posterior_predictive(fit4), stats = c("mean", "sd", "max"))


</code></pre>

<hr>
<h2 id='summary.poisreg'>Summarizing Bayesian Poisson Regression Fit</h2><span id='topic+summary.poisreg'></span><span id='topic+print.poisreg'></span>

<h3>Description</h3>

<p>This function is a method for class <code>poisreg</code>. It prints summary statistics and returns posterior estimates of regression quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poisreg'
summary(object, ...)

## S3 method for class 'poisreg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.poisreg_+3A_object">object</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>).</p>
</td></tr>
<tr><td><code id="summary.poisreg_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.poisreg_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>poisreg</code>&quot; (usually, the result of a call to <code><a href="#topic+sample_bpr">sample_bpr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The printed output of <code>summary.poisreg</code> summarizes the main quantities of the fit. 
The first component <code>Call</code> recaps the type of prior and algorithm used.
</p>
<p><code>Coefficients</code> is a table of estimated quantities for the regression parameters. The first three columns report the estimated posterior mean, 
standard errors and medians. The last two columns correspond to the lower and upper bounds of the 0.95 credible intervals. 
If the credible interval does not include zero, a star is printed in correspondence of each parameter 
(similarly to the 'significance stars' of <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>).
All the estimates are computed discarding the first part of the chain as burn-in (more details are printed in the <code>Algorithm</code> section).
</p>
<p><code>Algorithm</code> briefly summarizes the main diagnostics of convergence and efficiency of the algorithm. 
It prints the number of iterations actually used to obtain the estimates, after removing the burn-in and thinning.
If a Metropolis-Hastings algorithm is used, the summary reports the acceptance rate, 
which is the most commonly used indicator to tune the performance of the algorithm, along with the mean effective sample size 
(averaged over all parameters).
If the importance sampler is used, the summary only reports the effective sample size, which is computed as <code class="reqn">\sum_{t} w_t^2 / (\sum_{t} w_t)^2</code>
(where <code class="reqn">w_t</code> is the sequence of weights) and is a measure of the efficiency of the sampler.
</p>


<h3>Value</h3>

<p><code>summary.poisreg</code> returns a list with elements:
</p>
<p><code>formula</code> : the component from <code>object</code>.
</p>
<p><code>data</code> : list with elements the matrix of covariates <code>X</code> and response variable <code>y</code>.
</p>
<p><code>prior</code> : <code>prior$type</code> from <code>object</code>.
</p>
<p><code>prior_pars</code> : prior parameters from <code>object</code>.
</p>
<p><code>coefficients</code> : the matrix of coefficient estimantes, standard errors and 95% credible intervals.
</p>
<p><code>psi2</code> : if a horseshoe prior is selected, the estimate of the local shrinkage parameter.
</p>
<p><code>len_burnin</code> : the length of the burn-in used to compute the estimates.
</p>
<p><code>effSize</code> : the mean effective sample size of the chains used to compute the estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For examples see example(sample_bpr)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
