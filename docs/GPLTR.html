<!DOCTYPE html><html lang="en"><head><title>Help for package GPLTR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPLTR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GPLTR-package'>
<p>Fit a generalized partially linear tree-based regression model</p></a></li>
<li><a href='#bag.aucoob'>
<p>AUC on the Out Of Bag samples</p></a></li>
<li><a href='#bagging.pltr'>
<p>bagging pltr models</p></a></li>
<li><a href='#best.tree.BIC.AIC'>
<p>Prunning the Maximal tree</p></a></li>
<li><a href='#best.tree.bootstrap'>
<p>parametric bootstrap on a pltr model</p></a></li>
<li><a href='#best.tree.CV'>
<p>Prunning the Maximal tree</p></a></li>
<li><a href='#best.tree.permute'>
<p>permutation test on a pltr model</p></a></li>
<li><a href='#burn'>
<p>burn dataset</p></a></li>
<li><a href='#data_pltr'>
<p>gpltr data example</p></a></li>
<li><a href='#nested.trees'>
<p>compute the nested trees</p></a></li>
<li><a href='#p.val.tree'>
<p>Compute the p-value</p></a></li>
<li><a href='#pltr.glm'>
<p>Partially tree-based regression model function</p></a></li>
<li><a href='#predict_bagg.pltr'>
<p>prediction on new features</p></a></li>
<li><a href='#predict_pltr'>
<p>prediction</p></a></li>
<li><a href='#tree2glm'>
<p>tree to GLM</p></a></li>
<li><a href='#tree2indicators'>
<p>From a tree to indicators (or dummy variables)</p></a></li>
<li><a href='#VIMPBAG'>
<p>score of importance for variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Partially Linear Tree-Based Regression Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Cyprien Mbogning &lt;cyprien.mbogning@inserm.fr&gt; and Wilson Toussile</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cyprien Mbogning &lt;cyprien.mbogning@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Combining a generalized linear model with an additional tree part 
          on the same scale. A four-step procedure is proposed to fit the model and test 
          the joint effect of the selected tree part while adjusting on confounding factors. 
          We also proposed an ensemble procedure based on the bagging to improve prediction 
          accuracy and computed several scores of importance for variable selection.
          See 'Cyprien Mbogning et al.'(2014)&lt;<a href="https://doi.org/10.1186%2F2043-9113-4-6">doi:10.1186/2043-9113-4-6</a>&gt; and 
         'Cyprien Mbogning et al.'(2015)&lt;<a href="https://doi.org/10.1159%2F000380850">doi:10.1159/000380850</a>&gt; 
          for an overview of all the methods implemented in this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>rpart , parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 18:15:25 UTC; cypry</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GPLTR-package'>
Fit a generalized partially linear tree-based regression model
</h2><span id='topic+GPLTR-package'></span><span id='topic+GPLTR'></span>

<h3>Description</h3>

<p>Combining a generalized linear model with an additional tree part on the 
same scale. A four-step procedure is proposed to fit the model and test the
joint effect of the selected tree part while adjusting on confounding
factors. 
We also proposed an ensemble procedure based on the bagging to improve  
prediction accuracy and computed several scores of importance for variable 
selection. See 'Cyprien Mbogning et al.'(2014)&lt;doi:10.1186/2043-9113-4-6&gt;,
'Cyprien Mbogning et al.'(2015)&lt;doi:10.1159/000380850&gt; 
for an overview of all the methods implemented in this package. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GPLTR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Cyprien Mbogning  and Wilson Toussile
</p>
<p>Maintainer: Cyprien Mbogning &lt;cyprien.mbogning@gmail.com&gt;
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Broet, P.: A Bagged partially linear tree-based regression procedure for prediction and variable selection. Human Heredity, 79(3-4):1 82-93 (2015)
</p>
<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014) 
</p>
<p>Terry M. Therneau, Elizabeth J. Atkinson (2013) An Introduction to Recursive Partitioning Using the <code>RPART</code> Routines. Mayo Foundation.
</p>
<p>Chen, J., Yu, K., Hsing, A., Therneau, T.M.: A partially linear tree-based regression model for assessing complex joint gene-gene and gene-environment effects. Genetic Epidemiology
31, 238-251 (2007)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
## Example on a public dataset: the burn data 
##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
## The burn data are also displayed in the KMsurv package
##%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 ## Not run: 
 data(burn)

## Build the rpart tree with all the variables

 rpart.burn &lt;-  rpart(D2 ~ Z1  + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8 + Z9 
                          + Z10  + Z11, data = burn, method = "class")
              
 plot(rpart.burn, main = 'rpart tree')
 text(rpart.burn, xpd = TRUE, cex = .6, use.n = TRUE)

## fit the PLTR model after adjusting on gender (Z2) using the proposed method

 args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxcompete = 0, 
                    maxsurrogate = 0)
 family &lt;- "binomial"
 X.names = "Z2"
 Y.name = "D2"
 G.names = c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
 
pltr.burn &lt;- pltr.glm(burn, Y.name, X.names, G.names, args.rpart = args.rpart,
                   family = family, iterMax = 4, iterMin = 3, verbose = FALSE)

## Prunned back the maximal tree using either the BIC or the AIC criterion

pltr.burn_prun &lt;- best.tree.BIC.AIC(xtree = pltr.burn$tree, burn, Y.name, 
                                    X.names, family = family)

## plot the BIC selected tree

plot(pltr.burn_prun$tree$BIC, main = 'BIC selected tree')
text(pltr.burn_prun$tree$BIC, xpd = TRUE, cex = .6, col = 'blue')

## Summary of the selected tree by a BIC criterion

summary(pltr.burn_prun$tree$BIC)

## Summary of the final selected pltr model

summary(pltr.burn_prun$fit_glm$BIC)

## fit the PLTR model after adjusting on gender (Z2) using the parametric 
## bootstrap method

##  set numWorkers = 1 on a windows plateform

 args.parallel = list(numWorkers = 10)
 
best_bootstrap &lt;- best.tree.bootstrap(pltr.burn$tree, burn, Y.name, X.names,
           G.names, B = 2000, BB = 2000, args.rpart = args.rpart, epsi = 0.008,
           iterMax = 6, iterMin = 5, family = family, LEVEL = 0.05, LB = FALSE, 
              args.parallel = args.parallel, verbose = FALSE)
              
 plot(best_bootstrap$selected_model$tree, main = 'original method')
 text(best_bootstrap$selected_model$tree, xpd = TRUE)

## Bagging a set of basic unprunned pltr predictors
# ?bagging.pltr

Bag.burn &lt;-  bagging.pltr(burn, Y.name, X.names, G.names, family, 
              args.rpart,epsi = 0.01, iterMax = 4, iterMin = 3, 
              Bag = 10, verbose = FALSE, doprune = FALSE)

## The thresshold values used

Bag.burn$CUT

## The set of PLTR models in the bagging procedure

PLTR_BAG.burn &lt;- Bag.burn$Glm_BAG

## The set of trees in the bagging procedure

TREE_BAG.burn &lt;- Bag.burn$Tree_BAG

## Use the bagging procedure to predict new features
# ?predict_bagg.pltr

Pred_Bag.burn &lt;- predict_bagg.pltr(Bag.burn, Y.name, newdata = burn, 
                 type = "response", thresshold = seq(0, 1, by = 0.1))

## The confusion matrix for each thresshold value using the majority vote

Pred_Bag.burn$CONF1

## The prediction error for each thresshold value

 Pred_Bag.burn$PRED_ERROR1
 
## Compute the variable importances using the bagging procedure
 
 Var_Imp_BAG.burn &lt;- VIMPBAG(Bag.burn, burn, Y.name)

## Importance score using the permutaion method for each thresshold value

Var_Imp_BAG.burn$PIS

## Shadow plot of three proposed scores 

par(mfrow=c(1,3))
barplot(Var_Imp_BAG.burn$PIS$CUT5, main = 'PIS', horiz = TRUE, las = 1,
        cex.names = .8, col = 'lightblue')
barplot(Var_Imp_BAG.burn$DIS, main = 'DIS', horiz = TRUE, las = 1,
        cex.names = .8, col = 'grey') 
barplot(Var_Imp_BAG.burn$DDIS, main = 'DDIS', horiz = TRUE, las = 1,
        cex.names = .8, col = 'purple')

## End(Not run)
</code></pre>

<hr>
<h2 id='bag.aucoob'>
AUC on the Out Of Bag samples
</h2><span id='topic+bag.aucoob'></span>

<h3>Description</h3>

<p>Compute the AUC on the OOB samples of the bagging procedure for the binomial family. The true and false positive rates are also returned and could be helpfull for plotting the ROC curves.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bag.aucoob(bag_pltr, xdata, Y.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bag.aucoob_+3A_bag_pltr">bag_pltr</code></td>
<td>
<p> The output of the function <code><a href="#topic+bagging.pltr">bagging.pltr</a></code></p>
</td></tr>
<tr><td><code id="bag.aucoob_+3A_xdata">xdata</code></td>
<td>
<p>The learning dataset containing the dependent variable, the confounding variables and the predictors variables</p>
</td></tr>
<tr><td><code id="bag.aucoob_+3A_y.name">Y.name</code></td>
<td>
<p>The name of the binary dependent variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The thresshold values used for computing the AUC are defined when building the bagging predictor. see <code><a href="#topic+bagging.pltr">bagging.pltr</a></code> for the convenient parameterization.  
</p>


<h3>Value</h3>

<p> A list of 4 elements
</p>
<table role = "presentation">
<tr><td><code>AUCOOB</code></td>
<td>
<p>the AUC computed on OOB samples of the Bagging procedure</p>
</td></tr>
<tr><td><code>TPR</code></td>
<td>
<p>the true positive rate for several thresshold values</p>
</td></tr>
<tr><td><code>FPR</code></td>
<td>
<p>the false positive rate for several thresshold values</p>
</td></tr>
<tr><td><code>OOB</code></td>
<td>
<p>the Out Of Bag error for each thresshold value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The plot of the ROC curve is straighforward using the <code>TPR</code> and <code>FPR</code> obtained with the function <code>bag.aucoob</code>
</p>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Broet, P.: A Bagged partially linear tree-based regression procedure for prediction and variable selection (submitted 2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='bagging.pltr'>
bagging pltr models
</h2><span id='topic+bagging.pltr'></span>

<h3>Description</h3>

<p>bagging procedure to agregate several PLTR models for accurate prediction and variable selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagging.pltr(xdata, Y.name, X.names, G.names, family = "binomial", 
args.rpart,epsi = 0.001, iterMax = 5, iterMin = 3, LB = FALSE, 
args.parallel = list(numWorkers = 1),
Bag = 20, Pred_Data = data.frame(), verbose = TRUE, doprune = FALSE
, thresshold = seq(0, 1, by = 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bagging.pltr_+3A_xdata">xdata</code></td>
<td>

<p>the learning data frame 
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the binary dependent variable
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the glm and as offset in the tree part
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid glm.
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_family">family</code></td>
<td>

<p>the glm family considered depending on the type of the dependent variable (only the binomial family works in this function for the moment) .
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ...
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_lb">LB</code></td>
<td>

<p>a binary indicator with values TRUE or FALSE indicating weither the loading is balanced or not in the parallel computing. It is nevertheless useless on a windows platform. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code>
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_args.parallel">args.parallel</code></td>
<td>

<p>a list of two elements containing the number of workers and the type of parallelization to achieve see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_bag">Bag</code></td>
<td>

<p>The number of Bagging samples to consider
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_pred_data">Pred_Data</code></td>
<td>

<p>An optional data frame to validate the bagging procedure (the test dataset)
</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_doprune">doprune</code></td>
<td>

<p>a binary indicator with values TRUE or FALSE indicating weither the set of trees in the bagging procedure are pruned (by a <code>BIC</code> procedure) or not</p>
</td></tr>
<tr><td><code id="bagging.pltr_+3A_thresshold">thresshold</code></td>
<td>
<p>a vector of numerical values between 0 and 1 used as thresshold values for the computation of the OOB error rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p> For the Bagging procedure, it is mendatory to set <code>maxcompete = 0</code> and <code>maxsurrogate = 0</code> within the rpart arguments. This will ensured the correct calculation of the  importance of variables.
</p>


<h3>Value</h3>

<p>A list with eleven elements
</p>
<table role = "presentation">
<tr><td><code>IND_OOB</code></td>
<td>
<p>A list of length <code>Bag</code> containing the Out Of Bag (OOB) individuals for each PLTR model.</p>
</td></tr>
<tr><td><code>EOOB</code></td>
<td>
<p>The vector of OOB errors of the bagging procedure for each thresshold value. </p>
</td></tr>
<tr><td><code>OOB_ERRORS_PBP</code></td>
<td>
<p>A matrix with <code>Bag</code> columns and <code>thresshold</code> rows containing  OOB error of each PLTR model in the bagging sequence for each thresshold value.</p>
</td></tr>
<tr><td><code>OOB_ERROR_PBP</code></td>
<td>
<p>A vector containing the mean of <code>OOB_ERRORS_PBP</code> for each thresshold value.</p>
</td></tr>
<tr><td><code>Tree_BAG</code></td>
<td>
<p>A list of length <code>Bag</code> containing the bagging trees</p>
</td></tr>
<tr><td><code>Glm_BAG</code></td>
<td>
<p>A list of length <code>Bag</code> containing the bagging pltr model; could be helpfull for prediction on new features.</p>
</td></tr>
<tr><td><code>LOST</code></td>
<td>
<p>The 0, 1  lost matrix for OOB observations at each thresshold value</p>
</td></tr>
<tr><td><code>TEST</code></td>
<td>
<p>A value of <code>NULL</code> if <code>Pred_Data</code> is not available. A list of three elements otherwise: <code>PRED_ERROR</code>: the estimated error of the Bagging procedure on the test sample for each thresshold value; <code>PRED_IND</code>: A list of length the length of the thresshold vector, each element containing a matrix with the prediction of the testing data individuals using each  PLTR model of the bagging sequence (column by column); <code>FINAL_PRED_IND</code>: A list  containing the final prediction of each individual of the testing data by the bagging procedure (the modal prediction) for each thresshold value.</p>
</td></tr>
<tr><td><code>Var_IMP</code></td>
<td>
<p>A numeric vector containing the relative variable importance of the bagging procedure</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the bagging  procedure</p>
</td></tr>
<tr><td><code>CUT</code></td>
<td>
<p>The thresshold value used inside the bagging procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Broet, P.: A Bagged partially linear tree-based regression procedure for prediction and variable selection. Human Heredity (To appear) (2015)
</p>
<p>Leo Breiman:  Bagging Predictors. Machine Learning, 24, 123-140 (1996)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_bagg.pltr">predict_bagg.pltr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##load the data set

data(burn)

## set the parameters 

args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxsurrogate = 0)
family &lt;- "binomial"
Y.name &lt;- "D2"
X.names &lt;- "Z2"
G.names &lt;- c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
args.parallel = list(numWorkers = 1)
                     
## Bagging a set of basic unprunned pltr predictors

Bag.burn &lt;-  bagging.pltr(burn, Y.name, X.names, G.names, family, 
             args.rpart,epsi = 0.01, iterMax = 4, iterMin = 3, 
             Bag = 20, verbose = FALSE, doprune = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='best.tree.BIC.AIC'>
Prunning the Maximal tree
</h2><span id='topic+best.tree.BIC.AIC'></span>

<h3>Description</h3>

<p>this function  is set to prune back the maximal tree by using  the <code>BIC</code> or the <code>AIC</code> criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.tree.BIC.AIC(xtree, xdata, Y.name, X.names,
                  family = "binomial", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.tree.BIC.AIC_+3A_xtree">xtree</code></td>
<td>

<p>a tree to prune
</p>
</td></tr>
<tr><td><code id="best.tree.BIC.AIC_+3A_xdata">xdata</code></td>
<td>

<p>the dataset used to build the tree
</p>
</td></tr>
<tr><td><code id="best.tree.BIC.AIC_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable
</p>
</td></tr>
<tr><td><code id="best.tree.BIC.AIC_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent confounding variables to consider in the linear part of the <code>glm</code>
</p>
</td></tr>
<tr><td><code id="best.tree.BIC.AIC_+3A_family">family</code></td>
<td>

<p>the <code>glm</code> family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="best.tree.BIC.AIC_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of four elements:
</p>
<table role = "presentation">
<tr><td><code>best_index</code></td>
<td>
<p>The size of the selected trees by <code>BIC</code> and <code>AIC</code> </p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>The selected trees by <code>BIC</code> and <code>AIC</code> </p>
</td></tr>
<tr><td><code>fit_glm</code></td>
<td>
<p>The fitted pltr models selected with <code>BIC</code>, and <code>AIC</code> </p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the selection procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014)
</p>
<p>Akaike, H.: A new look at the statistical model identification. <code>IEEE Trans. Automat. Control AC-19</code>, 716-723 (1974)
</p>
<p>Schwarz, G.: Estimating the dimension of a model. <code>The Annals of Statistics</code> 6, 461-464 (1978)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.tree.CV">best.tree.CV</a></code>, <code><a href="#topic+pltr.glm">pltr.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burn)

args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxcompete = 0, 
                    maxsurrogate = 0)
 family &lt;- "binomial"
 X.names = "Z2"
 Y.name = "D2"
 G.names = c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
 
pltr.burn &lt;- pltr.glm(burn, Y.name, X.names, G.names, args.rpart = args.rpart,
                   family = family, iterMax = 4, iterMin = 3, verbose = FALSE)

## Prunned back the maximal tree using either the BIC or the AIC criterion

pltr.burn_prun &lt;- best.tree.BIC.AIC(xtree = pltr.burn$tree, burn, Y.name, 
                                    X.names, family = family)

## plot the BIC selected tree

plot(pltr.burn_prun$tree$BIC, main = 'BIC selected tree')
text(pltr.burn_prun$tree$BIC, xpd = TRUE, cex = .6, col = 'blue')

## Not run: 
##load the data set

data(data_pltr)

## Set the parameters

args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                     family = family,iterMax = 5, iterMin = 3)
                     
##prunned back the maximal tree by BIC or AIC criterion

tree_select &lt;- best.tree.BIC.AIC(xtree = fit_pltr$tree,data_pltr,Y.name, 
                                 X.names, family = family)
                            
plot(tree_select$tree$BIC, main = 'BIC TREE')
text(tree_select$tree$BIC, minlength = 0L, xpd = TRUE, cex = .6)


## End(Not run)
</code></pre>

<hr>
<h2 id='best.tree.bootstrap'>
parametric bootstrap on a pltr model
</h2><span id='topic+best.tree.bootstrap'></span>

<h3>Description</h3>

<p>a parametric bootstrap procedure to select and test at the same time the selected tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.tree.bootstrap(xtree, xdata, Y.name, X.names, G.names, B = 10, BB = 10,
args.rpart = list(cp = 0, minbucket = 20, maxdepth = 10), epsi = 0.001,
iterMax = 5, iterMin = 3, family = "binomial", LEVEL = 0.05, LB = FALSE,
args.parallel = list(numWorkers = 1), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.tree.bootstrap_+3A_xtree">xtree</code></td>
<td>

<p>the maximal tree obtained by the function pltr.glm
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_xdata">xdata</code></td>
<td>

<p>the data frame used to build xtree
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the glm
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid glm.
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_b">B</code></td>
<td>

<p>the size of the bootstrap sample
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_bb">BB</code></td>
<td>

<p>the size of the bootstrap sample to compute the adjusted p-value
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ...
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_family">family</code></td>
<td>

<p>the glm family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_level">LEVEL</code></td>
<td>

<p>the level of the test
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_lb">LB</code></td>
<td>

<p>a binary indicator with values TRUE or FALSE indicating weither the loading is balanced or not in the parallel computing. It is useless on a windows platform.
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_args.parallel">args.parallel</code></td>
<td>

<p>parameters of the parallelization. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more details
</p>
</td></tr>
<tr><td><code id="best.tree.bootstrap_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with six elements
</p>
<table role = "presentation">
<tr><td><code>selected_model</code></td>
<td>
<p>a list with the fit of the selected pltr model <code>fit_glm</code>, the selected tree <code>tree</code>, the p-value of the selected tree <code>p.value</code>, the ajusted p-value of the selected tree <code>adj_p.value</code> and an indicator <code>Tree_Selected</code> to assess wether the test is significant or not.</p>
</td></tr>
<tr><td><code>fit_glm</code></td>
<td>
<p>the fitted pltr model under the null hypothesis if the test is not significant</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the <code>parametric bootstrap</code> procedure</p>
</td></tr>
<tr><td><code>comp_p_values</code></td>
<td>
<p>The P-values of the competing trees</p>
</td></tr>
<tr><td><code>Badj</code></td>
<td>
<p>The number of samples used in the inner level of the procedure</p>
</td></tr>
<tr><td><code>BBadj</code></td>
<td>
<p>The number of samples used in the outer level of the procedure </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile 
</p>


<h3>References</h3>

<p>Chen, J., Yu, K., Hsing, A., Therneau, T.M.: A partially linear tree-based regression model for assessing complex joint gene-gene and gene-environment effects. Genetic Epidemiology
31, 238-251 (2007)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.val.tree">p.val.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load the data set
data(data_pltr)
args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")
## Not run: 
## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, 
   args.rpart = args.rpart, family = family, iterMax = 5, iterMin = 3)
                     
## select an test the selected tree by a parametric bootstrap procedure
args.parallel = list(numWorkers = 1, type = "PSOCK")

best_bootstrap &lt;- best.tree.bootstrap(fit_pltr$tree, data_pltr, Y.name, X.names, 
  G.names, B = 10, BB = 10, args.rpart = args.rpart, epsi = 0.001, 
  iterMax = 5, iterMin = 3, family = family, LEVEL = 0.05,LB = FALSE, 
  args.parallel = args.parallel)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='best.tree.CV'>
Prunning the Maximal tree
</h2><span id='topic+best.tree.CV'></span>

<h3>Description</h3>

<p>this function  is set to prune back the maximal tree by using a K-fold <code>cross-validation</code> procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.tree.CV(xtree, xdata, Y.name, X.names, G.names, family = "binomial", 
args.rpart = list(cp = 0, minbucket = 20, maxdepth = 10), epsi = 0.001, 
iterMax = 5, iterMin = 3, ncv = 10, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.tree.CV_+3A_xtree">xtree</code></td>
<td>

<p>a tree to prune
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_xdata">xdata</code></td>
<td>

<p>the dataset used to build the tree
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable 
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the <code>glm</code>
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid <code>glm</code>.
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_family">family</code></td>
<td>

<p>the <code>glm</code> family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ...
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_ncv">ncv</code></td>
<td>

<p>The number of folds to consider for the <code>cross-validation</code>
</p>
</td></tr>
<tr><td><code id="best.tree.CV_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of five elements:
</p>
<table role = "presentation">
<tr><td><code>best_index</code></td>
<td>
<p>The size of the selected tree by the cross-validation procedure</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>The selected tree by <code>CV</code></p>
</td></tr>
<tr><td><code>fit_glm</code></td>
<td>
<p>The fitted gpltr models selected with  <code>CV</code> </p>
</td></tr>
<tr><td><code>CV_ERRORS</code></td>
<td>
<p>A list of two elements containing the cross-validation error of the selected tree by the <code>CV</code> procedure and a
vector of cross-validation errors of all the competing models</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the <code>Cross-Validation</code> procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.tree.BIC.AIC">best.tree.BIC.AIC</a></code>, <code><a href="#topic+pltr.glm">pltr.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##load the data set

data(data_pltr)

## set the parameters

args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                     family = family,iterMax = 5, iterMin = 3)
                     
##prunned back the maximal tree by a cross-validation procedure

tree_selected &lt;- best.tree.CV(fit_pltr$tree, data_pltr, Y.name, X.names, G.names, 
     family = family, args.rpart = args.rpart, epsi = 0.001, iterMax = 5, 
     iterMin = 3, ncv = 10)
     
plot(tree_selected$tree, main = 'CV TREE')
text(tree_selected$tree, minlength = 0L, xpd = TRUE, cex = .6)

## End(Not run)
</code></pre>

<hr>
<h2 id='best.tree.permute'>
permutation test on a pltr model
</h2><span id='topic+best.tree.permute'></span>

<h3>Description</h3>

<p>a unified permutation test procedure to select and test at the same time the selected tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.tree.permute(xtree, xdata, Y.name, X.names, G.names, B = 10,
 args.rpart = list(cp = 0, minbucket = 20, maxdepth = 10), epsi = 0.001,
 iterMax = 5, iterMin = 3, family = "binomial", LEVEL = 0.05, 
 LB = FALSE, args.parallel = list(numWorkers = 1, type = "PSOCK"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.tree.permute_+3A_xtree">xtree</code></td>
<td>

<p>the maximal tree obtained by the function pltr.glm
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_xdata">xdata</code></td>
<td>

<p>the data frame used to build xtree
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the glm. For this function, only a binary variable is supported.
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid glm.
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_b">B</code></td>
<td>

<p>the size of the bootstrap sample
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ...
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_family">family</code></td>
<td>

<p>the binomial family.
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_level">LEVEL</code></td>
<td>

<p>the level of the test
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_lb">LB</code></td>
<td>

<p>a binary indicator with values TRUE or FALSE indicating weither the loading is balanced or not in the parallel computing. It is useless on a windows platform.
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_args.parallel">args.parallel</code></td>
<td>

<p>parameters of the parallelization. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="best.tree.permute_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with six elements:
</p>
<table role = "presentation">
<tr><td><code>p.val_selected</code></td>
<td>
<p>the adjusted p-value of the selected tree</p>
</td></tr>
<tr><td><code>selected_model</code></td>
<td>
<p>a list with the fit of the selected pltr model <code>fit_glm</code>, the selected tree <code>tree</code> and the p-value of the selected tree without adjusting for multiple comparisons <code>p.value</code></p>
</td></tr>
<tr><td><code>fit_glm</code></td>
<td>
<p>the fitted pltr model under the null hypothesis if the test is not significant</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the <code>permutation test</code> procedure</p>
</td></tr>
<tr><td><code>comp_p_values</code></td>
<td>
<p>The P-values of the competing trees</p>
</td></tr>
<tr><td><code>Badj</code></td>
<td>
<p>The number of samples used inside the procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.val.tree">p.val.tree</a></code>, <code><a href="#topic+best.tree.bootstrap">best.tree.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##load the data set

data(data_pltr)

## set the parameters

args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                     family = family,iterMax = 5, iterMin = 3)
                     
## select an test the selected tree by a permutation test procedure

args.parallel = list(numWorkers = 1, type = "PSOCK")

best_permute &lt;- best.tree.permute(fit_pltr$tree, data_pltr, Y.name, X.names,
  G.names, B = 10, args.rpart = args.rpart, epsi = 0.001, iterMax = 5,              
             iterMin = 3, family = family, LEVEL = 0.05,LB = FALSE, 
                                   args.parallel = args.parallel)

## End(Not run)
</code></pre>

<hr>
<h2 id='burn'>
burn dataset
</h2><span id='topic+burn'></span>

<h3>Description</h3>

<p>The burn data frame has 154 rows and 17 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(burn)</code></pre>


<h3>Format</h3>

<p>A data frame with 154 observations on the following 17 variables.
</p>

<dl>
<dt><code>Obs</code></dt><dd><p>Observation number</p>
</dd>
<dt><code>Z1</code></dt><dd><p>Treatment: 0-routine bathing 1-Body cleansing</p>
</dd>
<dt><code>Z2</code></dt><dd><p>Gender (0=male 1=female)</p>
</dd>
<dt><code>Z3</code></dt><dd><p>Race: 0=nonwhite 1=white</p>
</dd>
<dt><code>Z4</code></dt><dd><p>Percentage of total surface area burned</p>
</dd>
<dt><code>Z5</code></dt><dd><p>Burn site indicator: head 1=yes, 0=no</p>
</dd>
<dt><code>Z6</code></dt><dd><p>Burn site indicator: buttock 1=yes, 0=no</p>
</dd>
<dt><code>Z7</code></dt><dd><p>Burn site indicator: trunk 1=yes, 0=no</p>
</dd>
<dt><code>Z8</code></dt><dd><p>Burn site indicator: upper leg 1=yes, 0=no</p>
</dd>
<dt><code>Z9</code></dt><dd><p>Burn site indicator: lower leg 1=yes, 0=no</p>
</dd>
<dt><code>Z10</code></dt><dd><p>Burn site indicator: respiratory tract 1=yes, 0=no</p>
</dd>
<dt><code>Z11</code></dt><dd><p>Type of burn: 1=chemical, 2=scald, 3=electric, 4=flame</p>
</dd>
<dt><code>T1</code></dt><dd><p>Time to excision or on study time</p>
</dd>
<dt><code>D1</code></dt><dd><p>Excision indicator: 1=yes 0=no</p>
</dd>
<dt><code>T2</code></dt><dd><p>Time to prophylactic antibiotic treatment or on study time</p>
</dd>
<dt><code>D2</code></dt><dd><p>Prophylactic antibiotic treatment: 1=yes 0=no</p>
</dd>
<dt><code>T3</code></dt><dd><p>Time to straphylocous aureaus infection or on study time</p>
</dd>
<dt><code>D3</code></dt><dd><p>Straphylocous aureaus infection: 1=yes 0=no</p>
</dd>     
</dl>



<h3>Source</h3>

<p>Klein and Moeschberger (1997) Survival Analysis Techniques for Censored and truncated data, <code>Springer</code>. 
</p>
<p>Ichida et al. <code>Stat. Med.</code> 12 (1993): 301-310.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burn)
## maybe str(burn) ;
</code></pre>

<hr>
<h2 id='data_pltr'>
gpltr data example
</h2><span id='topic+data_pltr'></span>

<h3>Description</h3>

<p>A data frame to test the functions of the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data_pltr)</code></pre>


<h3>Format</h3>

<p>A data frame with 3000 observations on the following 16 variables.
</p>

<dl>
<dt><code>G1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>G2</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>G3</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>G4</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>G5</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>G6</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G7</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G8</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G9</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G10</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G11</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G12</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G13</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G14</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>G15</code></dt><dd><p>a binary numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a binary numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The numeric variable <code>G1</code> is considered as offset in the simulated <code>PLTR</code> model; the variables <code>G2</code>,...,<code>G5</code> are used to simulate the tree part, while <code>G6</code>,...,<code>G15</code> are noise variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_pltr)
## maybe str(data_pltr) ...
</code></pre>

<hr>
<h2 id='nested.trees'>
compute the nested trees
</h2><span id='topic+nested.trees'></span>

<h3>Description</h3>

<p>Compute a sequence of nested competing trees for the prunning step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.trees(xtree, xdata, Y.name, X.names, MaxTreeSize = NULL,
family = "binomial", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested.trees_+3A_xtree">xtree</code></td>
<td>

<p>a tree inheriting to the rpart method
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_xdata">xdata</code></td>
<td>

<p>the dataset used to build the tree
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable in the tree model
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables considered as offset in the tree model
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_maxtreesize">MaxTreeSize</code></td>
<td>

<p>The maximal size of the competing trees
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_family">family</code></td>
<td>

<p>the glm family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="nested.trees_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 4 elements:
</p>
<table role = "presentation">
<tr><td><code>leaves</code></td>
<td>
<p>a list of leaves of the competing trees to consider for the optimal tree</p>
</td></tr>
<tr><td><code>null_deviance</code></td>
<td>
<p>the deviance of the null model (linear part of the glm)</p>
</td></tr>
<tr><td><code>deviances</code></td>
<td>
<p>a vector of deviances of the competing PLTR models</p>
</td></tr>
<tr><td><code>diff_deviances</code></td>
<td>
<p>a vector of the deviance differencies between the competing PLTR models and the null model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data set

data(data_pltr)
args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                     family = family,iterMax = 5, iterMin = 3)
                     
## compute the competing trees

nested_trees &lt;- nested.trees(fit_pltr$tree, data_pltr, Y.name, X.names, 
                            MaxTreeSize = 10, family = family)

## End(Not run)
</code></pre>

<hr>
<h2 id='p.val.tree'>
Compute the p-value
</h2><span id='topic+p.val.tree'></span>

<h3>Description</h3>

<p>Test weither the selected tree by either <code>BIC</code>, <code>AIC</code> or <code>CV</code> procedure is significantly associated to the dependent variable or not, while adjusting for a confounding effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.val.tree(xtree, xdata, Y.name, X.names, G.names, B = 10, args.rpart = 
list(minbucket = 40, maxdepth = 10, cp = 0), epsi = 0.001, iterMax = 5,
iterMin = 3, family = "binomial", LB = FALSE, 
args.parallel = list(numWorkers = 1), index = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.val.tree_+3A_xtree">xtree</code></td>
<td>

<p>the maximal tree obtained by the function pltr.glm
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_xdata">xdata</code></td>
<td>

<p>the data frame used to build xtree
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent confounding variables to consider in the linear part of the <code>glm</code>
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid <code>glm</code>.
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_b">B</code></td>
<td>

<p>the resampling size of the deviance difference
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ...
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_family">family</code></td>
<td>

<p>the glm family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_lb">LB</code></td>
<td>

<p>a binary indicator with values TRUE or FALSE indicating weither the loading are balanced or not in the parallel computing
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_args.parallel">args.parallel</code></td>
<td>

<p>parameters of the parallelization. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more details. 
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_index">index</code></td>
<td>

<p>the size of the selected tree (by the functions <code><a href="#topic+best.tree.BIC.AIC">best.tree.BIC.AIC</a></code> or <code><a href="#topic+best.tree.CV">best.tree.CV</a></code>) using one of the proposed criteria
</p>
</td></tr>
<tr><td><code id="p.val.tree_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list of three elements: 
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>The <code>P-value</code> of the selected tree</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the <code>test</code> procedure</p>
</td></tr>
<tr><td><code>Badj</code></td>
<td>
<p>The number of samples used inside the  the procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014)
</p>
<p>Fan, J., Zhang, C., Zhang, J.: Generalized likelihood ratio statistics and WILKS phenomenon. Annals of Statistics
29(1), 153-193 (2001)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.tree.bootstrap">best.tree.bootstrap</a></code>, <code><a href="#topic+best.tree.permute">best.tree.permute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data set

data(data_pltr)

## set the parameters 

args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                    family = family,iterMax = 5, iterMin = 3)
                     
##prunned back the maximal tree by BIC or AIC criterion

tree_select &lt;- best.tree.BIC.AIC(xtree = fit_pltr$tree,data_pltr,Y.name, 
                                 X.names, family = family)
                     
## Compute the p-value of the selected tree by BIC

args.parallel = list(numWorkers = 10, type = "PSOCK")
index = tree_select$best_index[[1]]
p_value &lt;- p.val.tree(xtree = fit_pltr$tree, data_pltr, Y.name, X.names, G.names,
            B = 100, args.rpart = args.rpart, epsi = 1e-3, 
            iterMax = 5, iterMin = 3, family = family, LB = FALSE, 
            args.parallel = args.parallel, index = index)

## End(Not run)
</code></pre>

<hr>
<h2 id='pltr.glm'>
Partially tree-based regression model function
</h2><span id='topic+pltr.glm'></span>

<h3>Description</h3>

<p>The <code>pltr.glm</code> function is designed to fit an hybrid glm model with  an additive tree part on a glm scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pltr.glm(data, Y.name, X.names, G.names, family = "binomial", 
    args.rpart = list(cp = 0, minbucket = 20, maxdepth = 10), 
    epsi = 0.001, iterMax = 5, iterMin = 3, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pltr.glm_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the <code>glm</code>
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_g.names">G.names</code></td>
<td>

<p>the names of independent variables to consider in the tree part of the hybrid <code>glm</code>.
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_family">family</code></td>
<td>

<p>the <code>glm</code> family considered depending on the type of the dependent variable.
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_args.rpart">args.rpart</code></td>
<td>

<p>a list of options that control details of the rpart algorithm. <code>minbucket</code>: the minimum number of observations in any terminal &lt;leaf&gt; node; <code>cp</code>: complexity parameter (Any split that does not decrease the overall lack of fit by a factor of cp is not attempted); <code>maxdepth</code>:  the maximum depth of any node of the final tree, with the root node counted as depth 0. ... 
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for further details
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_epsi">epsi</code></td>
<td>

<p>a treshold value  to check the convergence of the algorithm
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_itermax">iterMax</code></td>
<td>

<p>the maximal number of iteration to consider
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_itermin">iterMin</code></td>
<td>

<p>the minimum number of iteration to consider
</p>
</td></tr>
<tr><td><code id="pltr.glm_+3A_verbose">verbose</code></td>
<td>
<p>Logical; TRUE for printing progress during the computation (helpful for debugging)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pltr.glm</code> function use an itterative procedure to fit the linear part of the <code>glm</code> and the tree part. The tree obtained at the convergence of the procedure is a maximal tree which overfits the data. It's then mandatory to prunned back this tree by using one of the proposed criteria (<code>BIC</code>, <code>AIC</code> and <code>CV</code>).
</p>


<h3>Value</h3>

<p>A list with four elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>the glm fitted on the confounding factors at the end of the iterative algorithm</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>the maximal tree obtained at the end of the algorithm</p>
</td></tr>
<tr><td><code>nber_iter</code></td>
<td>
<p>the number of iterations used by the algorithm</p>
</td></tr>
<tr><td><code>Timediff</code></td>
<td>
<p>The execution time of the iterative procedure</p>
</td></tr>
</table>


<h3>Note</h3>

<p> The tree obtained at the end of these itterative procedure usually overfits the data. It's therefore mendatory to use either <code><a href="#topic+best.tree.BIC.AIC">best.tree.BIC.AIC</a></code> or <code><a href="#topic+best.tree.CV">best.tree.CV</a></code> to prunne back the tree.
</p>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014)
</p>
<p>Terry M. Therneau, Elizabeth J. Atkinson (2013) An Introduction to Recursive Partitioning Using the <code>RPART</code> Routines. Mayo Foundation.
</p>
<p>Chen, J., Yu, K., Hsing, A., Therneau, T.M.: A partially linear tree-based regression model for assessing complex joint gene-gene and gene-environment effects. Genetic Epidemiology
31, 238-251 (2007)
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+rpart">rpart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burn)

args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxcompete = 0, 
                    maxsurrogate = 0)
 family &lt;- "binomial"
 X.names = "Z2"
 Y.name = "D2"
 G.names = c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
 
pltr.burn &lt;- pltr.glm(burn, Y.name, X.names, G.names, args.rpart = args.rpart,
                   family = family, iterMax = 4, iterMin = 3, verbose = FALSE)


## Not run: 
## load the data set

data(data_pltr)

## set the parameters 

args.rpart &lt;- list(minbucket = 40, maxdepth = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree 

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart, 
                    family = family,iterMax = 5, iterMin = 3)
                    
plot(fit_pltr$tree, main = 'MAXIMAL TREE')
text(fit_pltr$tree, minlength = 0L, xpd = TRUE, cex = .6)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict_bagg.pltr'>
prediction on new features 
</h2><span id='topic+predict_bagg.pltr'></span>

<h3>Description</h3>

<p>Prediction on  new features using a set of bagging pltr models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_bagg.pltr(bag_pltr, Y.name, newdata, type = "response",
                  thresshold = seq(0, 1, by = 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_bagg.pltr_+3A_bag_pltr">bag_pltr</code></td>
<td>

<p>the bagging result obtained with the function <code><a href="#topic+bagging.pltr">bagging.pltr</a></code>
</p>
</td></tr>
<tr><td><code id="predict_bagg.pltr_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the binary dependent variable
</p>
</td></tr>
<tr><td><code id="predict_bagg.pltr_+3A_newdata">newdata</code></td>
<td>

<p>a data frame in which to look for predictors and the dependant variable.
</p>
</td></tr>
<tr><td><code id="predict_bagg.pltr_+3A_type">type</code></td>
<td>

<p>the type of prediction required. <code>type = "response"</code> is the default; It gives the predicted probabilities. At this stage of the package, only this type is take into account. Other types such as <code>"link"</code> and <code>"terms"</code> are useless.
</p>
</td></tr>
<tr><td><code id="predict_bagg.pltr_+3A_thresshold">thresshold</code></td>
<td>

<p>a vector of cutoff values for binary prediction. Could be helpfull for computing the AUC on the test sample.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 8 elements
</p>
<table role = "presentation">
<tr><td><code>FINAL_PRED_IND1</code></td>
<td>

<p>A list of size the length of the thresshold vector, containing the final prediction of each individual of the testing data by the bagging procedure using the majority rule (the modal prediction).
</p>
</td></tr>
<tr><td><code>FINAL_PRED_IND2</code></td>
<td>

<p>A list of size the length of the thresshold vector, containing the final prediction of each individual of the testing data by the bagging procedure using the mean estimated probability.
</p>
</td></tr>
<tr><td><code>PRED_ERROR1</code></td>
<td>
<p>A vector of  estimated errors of the Bagging procedure on the test sample for each thresshold value using <code>FINAL_PRED_IND1</code>.
</p>
</td></tr>
<tr><td><code>PRED_ERROR2</code></td>
<td>
<p>A vector of estimated errors of the Bagging procedure on the test sample for each thresshold value using <code>FINAL_PRED_IND2</code>.
</p>
</td></tr>
<tr><td><code>CONF1</code></td>
<td>
<p>A list of confusion matrix using <code>FINAL_PRED_IND1</code>
</p>
</td></tr>
<tr><td><code>CONF2</code></td>
<td>
<p>A list of confusion matrix using <code>FINAL_PRED_IND2</code>
</p>
</td></tr>
<tr><td><code>PRED_ERRORS_PBP</code></td>
<td>
<p>A list of size the length of the thresshold vector. Each element representing the prediction error obtained via each predictor in the bagging sequence for each thresshold value
</p>
</td></tr>
<tr><td><code>PRED_ERROR_PBP</code></td>
<td>
<p>A vector containing the mean of <code>PRED_ERRORS_PBP</code> for each thresshold value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Broet, P.: A Bagged partially linear tree-based regression procedure for prediction and variable selection. Human Heredity (To appear), (2015)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bagging.pltr">bagging.pltr</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data set

 data(burn)

## set the parameters 

 args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxsurrogate = 0)
 family &lt;- "binomial"
 Y.name &lt;- "D2"
 X.names &lt;- "Z2"
 G.names &lt;- c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
 args.parallel = list(numWorkers = 1)
                     
## Bagging a set of basic unprunned pltr predictors

 Bag.burn &lt;-  bagging.pltr(burn, Y.name, X.names, G.names, family, 
             args.rpart,epsi = 0.01, iterMax = 4, iterMin = 3, 
             Bag = 20, verbose = FALSE, doprune = FALSE)

## Use the bagging procedure to predict new features

# ?predict_bagg.pltr

 Pred_Bag.burn &lt;- predict_bagg.pltr(Bag.burn, Y.name, newdata = burn, 
                type = "response", thresshold = seq(0, 1, by = 0.1))

## The confusion matrix for each thresshold value using the majority vote

Pred_Bag.burn$CONF1

## End(Not run)
</code></pre>

<hr>
<h2 id='predict_pltr'>
prediction
</h2><span id='topic+predict_pltr'></span>

<h3>Description</h3>

<p>prediction on new features using a pltr tree and the name of the confounding variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_pltr(xtree, xdata, Y.name, X.names, newdata, type = "response",
              family = 'binomial', thresshold = seq(0.1, 0.9, by = 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_pltr_+3A_xtree">xtree</code></td>
<td>
<p>a tree obtained with the pltr procedure
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_xdata">xdata</code></td>
<td>
<p>the dataframe used to learn the pltr model
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_y.name">Y.name</code></td>
<td>
<p>the name of the main variable
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_x.names">X.names</code></td>
<td>
<p>the names of the confounding variables
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_newdata">newdata</code></td>
<td>
<p>the new data with all the predictors and the dependent variable
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_type">type</code></td>
<td>
<p>the type of prediction
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_family">family</code></td>
<td>
<p>the glm family considered
</p>
</td></tr>
<tr><td><code id="predict_pltr_+3A_thresshold">thresshold</code></td>
<td>
<p>the thresshold value to consider for binary prediction. It could be a vector, helping to compute the AUC
</p>
</td></tr>   
</table>


<h3>Value</h3>

<p> A list of two element
</p>
<table role = "presentation">
<tr><td><code>predict_glm</code></td>
<td>
<p>the predicted vector, depending on the family used. For the binomial family with a vector of thresshold, a matrix with each column corresponding to a thresshold value</p>
</td></tr>
<tr><td><code>ERR_PRED</code></td>
<td>
<p>either the prediction error of the pltr procedure on the test set or a vector of prediction error when the family is binomial with a vector of thresshold values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Toussile, W., Broet, P.: A novel tree-based procedure for deciphering the genomic spectrum of clinical disease entities. Journal of Clinical Bioinformatics 4:6, (2014)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pltr.glm">pltr.glm</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='tree2glm'>
tree to GLM
</h2><span id='topic+tree2glm'></span>

<h3>Description</h3>

<p>fit the PLTR model for a given tree. The tree is coerced into dummy covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree2glm(xtree, xdata, Y.name, X.names, family = "binomial")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree2glm_+3A_xtree">xtree</code></td>
<td>

<p>a tree inherits from the rpart method
</p>
</td></tr>
<tr><td><code id="tree2glm_+3A_xdata">xdata</code></td>
<td>

<p>a data frame containing the variables in the model
</p>
</td></tr>
<tr><td><code id="tree2glm_+3A_y.name">Y.name</code></td>
<td>

<p>the name  of the dependent variable 
</p>
</td></tr>
<tr><td><code id="tree2glm_+3A_x.names">X.names</code></td>
<td>

<p>the names of independent variables to consider in the linear part of the glm
</p>
</td></tr>
<tr><td><code id="tree2glm_+3A_family">family</code></td>
<td>

<p>the glm family considered depending on the type of the dependent variable.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the pltr fitted model (fit)
</p>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##load the data set

data(data_pltr)

## set the parameters

args.rpart &lt;- list(minbucket = 40, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart,
                     family = family,iterMax = 5, iterMin = 3)
                     
## Coerce a tree into a glm model using the confonding factor                     

fit_glm &lt;- tree2glm(fit_pltr$tree, data_pltr, Y.name, X.names,
                    family = family)
                    
summary(fit_glm)

## End(Not run)      
</code></pre>

<hr>
<h2 id='tree2indicators'>
From a tree to indicators (or dummy variables)
</h2><span id='topic+tree2indicators'></span>

<h3>Description</h3>

<p>Coerces a given tree structure to binary covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree2indicators(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree2indicators_+3A_fit">fit</code></td>
<td>

<p>a tree structure inheriting to the rpart method
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of indicators
</p>


<h3>Author(s)</h3>

<p>Cyprien Mbogning and Wilson Toussile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data set

data(data_pltr)

## set the parameters

args.rpart &lt;- list(minbucket = 40, xval = 10, cp = 0)
family &lt;- "binomial"
Y.name &lt;- "Y"
X.names &lt;- "G1"
G.names &lt;- paste("G", 2:15, sep="")

## build a maximal tree

fit_pltr &lt;- pltr.glm(data_pltr, Y.name, X.names, G.names, args.rpart = args.rpart,
                     family = family,iterMax = 5, iterMin = 3)

## Compute a list of indicator from the leaves of the tree fitted tree

tree2indicators(fit_pltr$tree)

## End(Not run)
</code></pre>

<hr>
<h2 id='VIMPBAG'>
score of importance for variables
</h2><span id='topic+VIMPBAG'></span>

<h3>Description</h3>

<p>Several variable importance scores are computed: the deviance importance score (DIS), the permutation importance score (PIS), the depth deviance importance score (DDIS), the minimal depth importance score (MinDepth) and the occurence score (OCCUR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIMPBAG(BAGGRES, data, Y.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VIMPBAG_+3A_baggres">BAGGRES</code></td>
<td>
<p> The output of the bagging procedure (<code>bagging.pltr</code>)
</p>
</td></tr>
<tr><td><code id="VIMPBAG_+3A_data">data</code></td>
<td>
<p>The learning dataframe used within the bagging procedure
</p>
</td></tr>
<tr><td><code id="VIMPBAG_+3A_y.name">Y.name</code></td>
<td>
<p>The name of the binary dependant variable used in the bagging procedure
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>several choices for variable selection using the bagging procedure are proposed. A discussion about the scores of importance PIS, DIS, and DDIS is available in <code>Mbogning et al. 2015</code>
</p>


<h3>Value</h3>

<p> A list with 9 elements
</p>
<table role = "presentation">
<tr><td><code>PIS</code></td>
<td>
<p>A list of length the length of the thresshold value used in the bagging procedure, containing the permutation importance score displayed in decreasing order for each thresshold value</p>
</td></tr>
<tr><td><code>StdPIS</code></td>
<td>
<p>The standard error of the PIS</p>
</td></tr>
<tr><td><code>OCCUR</code></td>
<td>
<p>The occurence number for each variable in the bagging sequence displayed in decreasing order</p>
</td></tr>
<tr><td><code>DIS</code></td>
<td>
<p>The deviance importance score displayed in decreasing order</p>
</td></tr>
<tr><td><code>DDIS</code></td>
<td>
<p>The depth deviance importance score displayed in decreasing order</p>
</td></tr>
<tr><td><code>MinDepth</code></td>
<td>
<p>The minimal depth score for each variable, displayed in increasing order </p>
</td></tr>
<tr><td><code>dimtrees</code></td>
<td>
<p>A vector containing the dimensions of trees within the baging sequence</p>
</td></tr>
<tr><td><code>EOOB</code></td>
<td>
<p>A vector containing the OOB error of the bagging procedure for each thresshold value</p>
</td></tr>
<tr><td><code>Bagfinal</code></td>
<td>
<p>The number of Bagging iterations used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyprien Mbogning
</p>


<h3>References</h3>

<p>Mbogning, C., Perdry, H., Broet, P.: A Bagged partially linear tree-based regression procedure for prediction and variable selection. Human Heredity (To appear), (2015)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bagging.pltr">bagging.pltr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load the data set

 data(burn)

## set the parameters 

 args.rpart &lt;- list(minbucket = 10, maxdepth = 4, cp = 0, maxsurrogate = 0)
 family &lt;- "binomial"
 Y.name &lt;- "D2"
 X.names &lt;- "Z2"
 G.names &lt;- c('Z1','Z3','Z4','Z5','Z6','Z7','Z8','Z9','Z10','Z11')
 args.parallel = list(numWorkers = 1)
                     
## Bagging a set of basic unprunned pltr predictors

 Bag.burn &lt;-  bagging.pltr(burn, Y.name, X.names, G.names, family, 
             args.rpart,epsi = 0.01, iterMax = 4, iterMin = 3, 
             Bag = 20, verbose = FALSE, doprune = FALSE)

## Several importance scores for variables, using the bagging procedure

 Var_Imp_BAG.burn &lt;- VIMPBAG(Bag.burn, burn, Y.name)

## Importance score using the permutaion method for each thresshold value

 Var_Imp_BAG.burn$PIS
 
## Importance score using the deviance criterion

 Var_Imp_BAG.burn$DIS
 
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
