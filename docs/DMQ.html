<!DOCTYPE html><html><head><title>Help for package DMQ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DMQ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DMQ-package'>
<p>Dynamic Multiple Quantiles model in R</p></a></li>
<li><a href='#EstimateDMQ'>
<p>Estimate the Dynamic Multiple Quantile (DMQ) model.</p></a></li>
<li><a href='#fn.DEoptim'>
<p>A wrapper to the DEoptim function of the <code>DEoptim</code> package of Mullen et al. (2011).</p></a></li>
<li><a href='#fn.optim'>
<p>A wrapper to the optim function.</p></a></li>
<li><a href='#fn.solnp'>
<p>A wrapper to the solnp function of the <code>Rsolnp</code> package of Ghalanos and Theussl (2016).</p></a></li>
<li><a href='#ForecastDMQ'>
<p>Forecast with univariate DMQ model</p></a></li>
<li><a href='#MomentsDMQ'>
<p>Estimate conditional moments using DMQ</p></a></li>
<li><a href='#MSFT'><p>data: Microsoft Corporation logarithmic percentage returns from December 8, 2010 to November 15, 2018 for a total of T = 2000 observation downloaded from Yahoo finance.</p></a></li>
<li><a href='#SimulateDMQ'>
<p>Simulate from the DMQ model</p></a></li>
<li><a href='#UpdateDMQ'>
<p>Update filtered quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Multiple Quantile (DMQ) Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leopoldo Catania &lt;leopoldo.catania@econ.au.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform estimation, prediction, and simulations using the Dynamic Multiple Quantile model of Catania and Luati (2023) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2022.11.002">doi:10.1016/j.jeconom.2022.11.002</a>&gt;. Can be used to estimate a set of conditional time-varying quantiles of a time series that do not cross.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.17)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Rsolnp, DEoptim, MASS, parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-27 15:28:31 UTC; au588008</td>
</tr>
<tr>
<td>Author:</td>
<td>Leopoldo Catania <a href="https://orcid.org/0000-0002-0981-1921"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Alessandra Luati <a href="https://orcid.org/0000-0001-6407-9385"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-28 15:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='DMQ-package'>
Dynamic Multiple Quantiles model in R
</h2><span id='topic+DMQ-package'></span><span id='topic+DMQ'></span>

<h3>Description</h3>

<p>The DMQ package allows us to simulate, estimate and forecast using the Dynamic Multiple Quantile (DMQ) model of Catania, L., &amp; Luati, A. (2022). Semiparametric modeling of multiple quantiles. Journal of Econometrics, see <a href="https://doi.org/10.1016/j.jeconom.2022.11.002">doi:10.1016/j.jeconom.2022.11.002</a>.
</p>


<h3>Note</h3>

<p>Please cite Catania and Luati (2022) in working papers and published papers that use <code>DMQ</code>. Use <code>citation("DMQ")</code>.
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania [aut,cre], Alessandra Luati [aut]
</p>
<p>Maintainer: Leopoldo Catania &lt;leopoldo.catania@econ.au.dk&gt;
</p>


<h3>References</h3>

<p>Catania, L, and Luati, A. (2023). 
&quot;Semiparametric modeling of multiple quantiles.&quot;
Journal of Econometrics
<a href="https://doi.org/10.1016/j.jeconom.2022.11.002">doi:10.1016/j.jeconom.2022.11.002</a>.<br />
</p>

<hr>
<h2 id='EstimateDMQ'>
Estimate the Dynamic Multiple Quantile (DMQ) model.
</h2><span id='topic+EstimateDMQ'></span>

<h3>Description</h3>

<p>Estimate the parameters of the DMQ model using the estimator detailed in Catania and Luati (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateDMQ(vY, vTau, iTau_star = NULL, vPn_Starting = NULL, 
                        FixReference = FALSE, FixOthers = FALSE, 
                        ScalingType = "InvSqrt",
                         vQ_0 = NULL,  
                         fn.optimizer = fn.DEoptim, 
                        cluster = NULL, smooth = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimateDMQ_+3A_vy">vY</code></td>
<td>
<p><code>numeric</code> vector of length Tx1 containing the time series of observations.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_vtau">vTau</code></td>
<td>
<p><code>numeric</code> vector of length Jx1 containing probability levels at which quantiles are estimated.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_itau_star">iTau_star</code></td>
<td>
<p>Integer indicating the position in <code>vTau</code> where the reference quantile is placed. For instance, if <code>vTau = seq(0.01, 0.99, 0.01)</code> then <code>iTau_star = 50</code> means that the median is used as the reference quantile.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_vpn_starting">vPn_Starting</code></td>
<td>
<p><code>numeric</code> named vector of length 4x1 with starting values for the optimizer. For example <code>vPn_Starting = c("phi" = 0.9, "gamma" = 0.05, "alpha" = 0.01, "beta" = 0.7)</code>.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_fixreference">FixReference</code></td>
<td>
<p><code>logical</code>. Should the reference quantile be fixed? By default <code>FixReference = FALSE</code>.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_fixothers">FixOthers</code></td>
<td>
<p><code>logical</code>. Should the quantiles other than the reference quantile be fixed? By default <code>FixOthers = FALSE</code>.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_scalingtype">ScalingType</code></td>
<td>
<p><code>character</code> Indicating the scaling mechanism for the conditional quasi score. Possible choices are <code>"Identity"</code>, <code>"Inv"</code>,<code>"InvSqrt"</code>. When  <code>ScalingType = "InvSqrt"</code> quasi scores are scaled by their standard deviation. When  <code>ScalingType = "Inv"</code> quasi scores are scaled by their variance. When  <code>ScalingType = "Identity"</code> quasi scores are not scaled. Default value <code>ScalingType = "InvSqrt"</code>.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_vq_0">vQ_0</code></td>
<td>
<p><code>numeric</code>. Vector of limiting quantiles evaluated at <code>vTau</code>. By default <code>FixOthers = NULL</code> meaning that empirical unconditional quantilies are used.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_fn.optimizer">fn.optimizer</code></td>
<td>
<p><code>function</code>. This is a generic optimization function that can be provided by the user. By default <code>fn.optimizer = fn.DEoptim</code> where <a href="#topic+fn.DEoptim">fn.DEoptim</a> is a wrapper to the <a href="DEoptim.html#topic+DEoptim">DEoptim</a> function of the package <code>DEoptim</code>. See the Details and Examples sections for user defined optimization routines.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_cluster">cluster</code></td>
<td>
<p>A <code>cluster</code> object created calling using the <code>paralell</code> package. If supplied parallel processing is used to speed up the computations if <code>fn.optimizer</code> makes use of it. When <code>fn.optimizer = fn.DEoptim</code> parallel computation can be used.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_smooth">smooth</code></td>
<td>
<p><code>logical</code>. Should a smooth version of the objective function should be used? If using a gradient based optimizer like <code>fn.optimizer = fn.optim</code> is it advised to set <code>smooth = TRUE</code>. By default, when <code>fn.optimizer = fn.DEoptim</code> we set <code>smooth = FALSE</code> and when <code>fn.optimizer = fn.optim</code> or <code>fn.optimizer = fn.solnp</code> we set <code>smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="EstimateDMQ_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>fn.optimizer</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting values for the optimizer are by default set as <code>c("phi" = 0.94, "gamma" = 0.10, "alpha" = 0.05, "beta" = 0.95)</code>.<br />
The user is free to employ his/her own optimization routine via the <code>fn.optimizer</code> argument. <code>fn.optimizer</code> accepts a <code>function</code> object. The user provided optimizer has to satisfy strict requirements. The arguments of the <code>fn.optimizer</code> are:
</p>

<dl>
<dt><code>par0</code></dt><dd><p> a vector of starting values,</p>
</dd>
<dt><code>vY</code></dt><dd><p> the data provided,</p>
</dd>
<dt><code>FUN</code></dt><dd><p> the objective function,</p>
</dd>
<dt><code>LB</code></dt><dd><p> vector of lower bounds for the parameters,</p>
</dd>
<dt><code>UB</code></dt><dd><p> vector of upper bounds for the parameters.</p>
</dd>
<dt><code>...</code></dt><dd><p> additional arguments.</p>
</dd>
</dl>

<p>The output of <code>fn.optimizer</code> has to be an object of the class <code>list</code> with four named elements:
</p>

<dl>
<dt><code>pars</code></dt><dd><p> a <code>numeric</code> vector where the estimated parameters are stored,</p>
</dd>
<dt><code>value</code></dt><dd><p> a <code>numeric</code> containing the value of the objective function evaluated at its minimum,</p>
</dd>
<dt><code>hessian</code></dt><dd><p> a <code>numeric</code> matrix containing the Hessian matrix evaluated at
the minimum of the objective function, this is used for inferential purposes,</p>
</dd>
<dt><code>convergence</code></dt><dd><p> a <code>numeric</code> variable  reporting information about the convergence of the optimization. <code>convergence = 0</code> has to indicate successful completion.</p>
</dd>
</dl>

<p>The user is allowed to not include the last two elements of the output of the <code>fn.optimizer</code> function, that is, the values <code>hessian = NULL</code> and <code>convergence = NULL</code> are admissible. In the case of <code>hessian = NULL</code>, no standard errors will be computed.
</p>


<h3>Value</h3>

<p>A <code>list</code> with, among others, elements:
</p>
<table>
<tr><td><code>lFilter</code></td>
<td>
<p>A <code>list</code> containing the output from the filtering procedure. For instance filtered quantiles, hit variables, and losses.</p>
</td></tr>
<tr><td><code>vPn</code></td>
<td>
<p><code>numeric</code> named vector of estimated parameters.</p>
</td></tr>
<tr><td><code>optimizer</code></td>
<td>
<p>A <code>list</code> with the output from <code>fn.optimizer</code>.</p>
</td></tr>
<tr><td><code>Inference</code></td>
<td>
<p>A <code>list</code> with output from the inferential procedure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>References</h3>

<p>Catania, L, and Luati, A. (2023). 
&quot;Semiparametric modeling of multiple quantiles.&quot;
Journal of Econometrics
<a href="https://doi.org/10.1016/j.jeconom.2022.11.002">doi:10.1016/j.jeconom.2022.11.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Microsoft Corporation logarithmic percentage returns from December 8, 
# 2010 to November 15, 2018 for a total of T = 2000 observation
data("MSFT")

##############################################################
######################## Estimate DMQ ########################
##############################################################

# Deciles
vTau = seq(0.1, 0.9, 0.1)

# Reference quantile to the median
iTau_star = 5

# Fix the reference quantile to a constant
FixReference = TRUE

# Estimate DMQ
Fit_solnp = EstimateDMQ(vY = vY,
                  vTau = vTau,
                  iTau_star = iTau_star,
                  FixReference = FixReference,
                  fn.optimizer = fn.solnp,
                  cluster = cluster)

Fit_solnp$vPn
Fit_solnp$optimizer$value

## Not run: 
#### Estimate DMQ using different optimizers

# With the DEoptim optimizer

# parallel computation
iG = 7
cluster = makeCluster(iG)

set.seed(123)

# Estimate DMQ
Fit_DEoptim = EstimateDMQ(vY = vY,
                  vTau = vTau,
                  iTau_star = iTau_star,
                  FixReference = FixReference,
                  fn.optimizer = fn.DEoptim,
                  cluster = cluster)

Fit_DEoptim$vPn
Fit_DEoptim$optimizer$value

# Estimate the model with a user defined optimizer.
# Let's use the gosolnp() optimizer from the Rsolnp package.

library("Rsolnp")
fn.gosolnp &lt;- function(par0, vY, FUN, LB, UB, ...) {
  
  foo = list(...)
  if (!is.null(foo$cluster)) {
    cluster = foo$cluster
    clusterEvalQ(cluster, library(DMQ))
  } 
  
  optimiser = gosolnp(
    pars = par0,
    fun = FUN, vY = vY, 
    n.sim = 1000,
    n.restarts = 5,
    LB = LB,
    UB = UB, control = list(trace = 1), 
    ...)
  
  out = list(pars = optimiser$pars,
             value = tail(optimiser$values, 1),
             hessian = optimiser$hessian,
             convergence = optimiser$convergence)
  
  return(out)
  
}

set.seed(123)
# Estimate DMQ
Fit_gosolnp = EstimateDMQ(vY = vY,
                  vTau = vTau,
                  iTau_star = iTau_star,
                  FixReference = FixReference,
                  fn.optimizer = fn.gosolnp,
                  cluster = cluster,
                  smooth = TRUE) 

Fit_gosolnp$vPn
Fit_gosolnp$optimizer$value

stopCluster(cluster)


## End(Not run)
</code></pre>

<hr>
<h2 id='fn.DEoptim'>
A wrapper to the <a href="DEoptim.html#topic+DEoptim">DEoptim</a> function of the <code>DEoptim</code> package of Mullen et al. (2011).
</h2><span id='topic+fn.DEoptim'></span>

<h3>Description</h3>

<p>This function is a wrapper to the <a href="DEoptim.html#topic+DEoptim">DEoptim</a> function of the <code>DEoptim</code> package of Mullen et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> fn.DEoptim(par0, vY, FUN, LB, UB, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn.DEoptim_+3A_par0">par0</code></td>
<td>

<p><code>numeric</code> vector of named model coefficients.</p>
</td></tr>
<tr><td><code id="fn.DEoptim_+3A_vy">vY</code></td>
<td>

<p><code>numeric</code> vector or matrix of data.</p>
</td></tr>
<tr><td><code id="fn.DEoptim_+3A_fun">FUN</code></td>
<td>

<p>A <a href="base.html#topic+function">function</a> to optimize.</p>
</td></tr>
<tr><td><code id="fn.DEoptim_+3A_lb">LB</code></td>
<td>

<p>A vector of lower bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.DEoptim_+3A_ub">UB</code></td>
<td>

<p>A vector of upper bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.DEoptim_+3A_...">...</code></td>
<td>

<p>Additional arguments to provide to <a href="DEoptim.html#topic+DEoptim">DEoptim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following control parameters are used: <code>trace = 0</code>, <code>rho = 1</code>, <code>outer.iter = 400</code>,
<code>inner.iter = 1800</code>, <code>delta = 1e-08</code>, <code>tol = 1e-08</code>. See the documentation of <a href="DEoptim.html#topic+DEoptim">DEoptim</a>.
</p>


<h3>Value</h3>

<p>It returns a named list with four elements: i) <code>pars</code>: a <code>numeric</code> vector where the estimated parameters are stored, ii) <code>value</code>: a <code>numeric</code> containing the value of the objective function evaluated at its minumum, iii) <code>hessian</code>, a <code>numeric</code> matrix containing the Hessian matrix evaluated at the minimum of the objective function, and iv) <code>convergence</code> a <code>numeric</code> element indicating the convergence (convergence is always reached by <a href="DEoptim.html#topic+DEoptim">DEoptim</a>, i.e. <code>convergence = 1</code>).
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>References</h3>

<p>Katharine Mullen, David Ardia, David Gil, Donald Windover, James Cline (2011).
'DEoptim': An R Package for Global Optimization by Differential Evolution. Journal of
Statistical Software, 40(6), 1-26. doi:10.18637/jss.v040.i06.<br />
</p>
<p>Ardia, D., Boudt, K., Carl, P., Mullen, K.M., Peterson, B.G. (2010). Differential
Evolution with 'DEoptim': An Application to Non-Convex Portfolio Optimization. R
Journal, 3(1), 27-34. doi:10.32614/RJ-2011-005.
</p>


<h3>See Also</h3>

<p><code>help(DEoptim)</code>
</p>

<hr>
<h2 id='fn.optim'>
A wrapper to the <a href="stats.html#topic+optim">optim</a> function.
</h2><span id='topic+fn.optim'></span>

<h3>Description</h3>

<p>This function is a wrapper to the standard <a href="stats.html#topic+optim">optim</a>  optimizer with <code>method = "BFGS"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> fn.optim(par0, vY, FUN, LB, UB, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn.optim_+3A_par0">par0</code></td>
<td>

<p><code>numeric</code> vector of named model coefficients.</p>
</td></tr>
<tr><td><code id="fn.optim_+3A_vy">vY</code></td>
<td>

<p><code>numeric</code> vector of data.</p>
</td></tr>
<tr><td><code id="fn.optim_+3A_fun">FUN</code></td>
<td>

<p>A <a href="base.html#topic+function">function</a> to optimize.</p>
</td></tr>
<tr><td><code id="fn.optim_+3A_lb">LB</code></td>
<td>

<p>A vector of lower bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.optim_+3A_ub">UB</code></td>
<td>

<p>A vector of upper bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.optim_+3A_...">...</code></td>
<td>

<p>Additional arguments to provide to <a href="stats.html#topic+optim">optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following control parameters are used for <code>control</code>:
</p>

<ul>
<li> <p><code>trace = 0</code>
</p>
</li>
<li> <p><code>abstol = 1e-8</code>
</p>
</li></ul>

<p>See the documentation of <a href="stats.html#topic+optim">optim</a>.
</p>


<h3>Value</h3>

<p>It returns a named list with four elements: i) <code>pars</code>: a <code>numeric</code> vector where the estimated parameters are stored, ii) <code>value</code>: a <code>numeric</code> containing the value of the objective function evaluated at its minumum, iii) <code>hessian</code>, a <code>numeric</code> matrix containing the Hessian matrix evaluated at the minimum of objective function, iv) <code>convergence</code> a <code>numeric</code> element indicating the convergence results of <a href="stats.html#topic+optim">optim</a>.
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>See Also</h3>

<p><code>help(optim)</code>
</p>

<hr>
<h2 id='fn.solnp'>
A wrapper to the <a href="Rsolnp.html#topic+solnp">solnp</a> function of the <code>Rsolnp</code> package of Ghalanos and Theussl (2016).
</h2><span id='topic+fn.solnp'></span>

<h3>Description</h3>

<p>This function is a wrapper to the <a href="Rsolnp.html#topic+solnp">solnp</a> function of the <code>Rsolnp</code> package of Ghalanos and Theussl (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> fn.solnp(par0, vY, FUN, LB, UB, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn.solnp_+3A_par0">par0</code></td>
<td>

<p><code>numeric</code> vector of named model coefficients.</p>
</td></tr>
<tr><td><code id="fn.solnp_+3A_vy">vY</code></td>
<td>

<p><code>numeric</code> vector or matrix of data.</p>
</td></tr>
<tr><td><code id="fn.solnp_+3A_fun">FUN</code></td>
<td>

<p>A <a href="base.html#topic+function">function</a> to optimize.</p>
</td></tr>
<tr><td><code id="fn.solnp_+3A_lb">LB</code></td>
<td>

<p>A vector of lower bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.solnp_+3A_ub">UB</code></td>
<td>

<p>A vector of upper bounds for the parameters.</p>
</td></tr>
<tr><td><code id="fn.solnp_+3A_...">...</code></td>
<td>

<p>Additional arguments to provide to <a href="Rsolnp.html#topic+solnp">solnp</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following control parameters are used: <code>trace = 0</code>, <code>rho = 1</code>, <code>outer.iter = 400</code>,
<code>inner.iter = 1800</code>, <code>delta = 1e-08</code>, <code>tol = 1e-08</code>. See the documentation of <a href="Rsolnp.html#topic+solnp">solnp</a>.
</p>


<h3>Value</h3>

<p>It returns a named list with four elements: i) <code>pars</code>: a <code>numeric</code> vector where the estimated parameters are stored, ii) <code>value</code>: a <code>numeric</code> containing the value of the objective function evaluated at its minumum, iii) <code>hessian</code>, a <code>numeric</code> matrix containing the Hessian matrix evaluated at the minimum of the objective function, and iv) <code>convergence</code> a <code>numeric</code> element indicating the convergence results of <a href="Rsolnp.html#topic+solnp">solnp</a>.
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>References</h3>

<p>Alexios Ghalanos and Stefan Theussl (2015).
&quot;Rsolnp: General Non-linear Optimization Using Augmented Lagrange
Multiplier Method&quot;. R package version 1.16.<br />
</p>


<h3>See Also</h3>

<p><code>help(solnp)</code>
</p>

<hr>
<h2 id='ForecastDMQ'>
Forecast with univariate DMQ model
</h2><span id='topic+ForecastDMQ'></span>

<h3>Description</h3>

<p>Compute the H-steap ahead prediction of the quantile processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForecastDMQ(Fit, H) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ForecastDMQ_+3A_fit">Fit</code></td>
<td>
<p>The output of the function <a href="#topic+EstimateDMQ">EstimateDMQ</a>.</p>
</td></tr>
<tr><td><code id="ForecastDMQ_+3A_h">H</code></td>
<td>
<p><code>numeric</code>, forecast horizon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> matrix of dimension HxJ, where J is the number of quantiles.
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Microsoft Corporation logarithmic percentage returns from December 8, 
# 2010 to November 15, 2018 for a total of T = 2000 observation
data("MSFT")

##############################################################
######################## Estimate DMQ ########################
##############################################################

# Estimate DMQ at tau_j = 0.05, 0.10, ..., 0.95
# with fixed median as reference quantile.
Fit = EstimateDMQ(vY = vY,
                  vTau = seq(0.05, 0.95, 0.05),
                  iTau_star = 10,
                  FixReference = TRUE,
                  fn.optimizer = fn.solnp)

# Compute 20-step ahead predictions
mQ_pred = ForecastDMQ(Fit, H = 20) 

mQ_pred
</code></pre>

<hr>
<h2 id='MomentsDMQ'>
Estimate conditional moments using DMQ
</h2><span id='topic+MomentsDMQ'></span>

<h3>Description</h3>

<p>Compute DMQ implied conditional moments. At each point in time moments are computed using the discretized distribution implied by the estimated conditional quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MomentsDMQ(Fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MomentsDMQ_+3A_fit">Fit</code></td>
<td>
<p>The output of the function <a href="#topic+EstimateDMQ">EstimateDMQ</a> or <a href="#topic+UpdateDMQ">UpdateDMQ</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Moments are computed using the following approximation: </p>
<p style="text-align: center;"><code class="reqn">\mathbb{E}[g(x)] \approx \sum_{j = 1}^J (\tau_j - \tau_{j-1}) g(\hat q_t^{\tau_j}),</code>
</p>
 
<p>with <code class="reqn">\tau_0 = 0</code>, where <code class="reqn">\hat q_t^{\tau_j}</code> are estimated quantiles.
</p>


<h3>Value</h3>

<p>A <code>list</code> of four elements:
</p>
<table>
<tr><td><code>mMoments</code></td>
<td>
<p> a Tx4 <code>numeric</code> matrix with columns containing first, second, third, and fourth moments.</p>
</td></tr>
<tr><td><code>mCenterdMoments</code></td>
<td>
<p> a Tx4 <code>numeric</code> matrix with columns containing first, second, third, and fourth central moments.</p>
</td></tr>
<tr><td><code>vSkew</code></td>
<td>
<p> a  <code>numeric</code> vector of length T of estimated skewness coefficients.</p>
</td></tr>
<tr><td><code>vKurt</code></td>
<td>
<p> a  <code>numeric</code> vector of length T estimated kurtosis coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load Microsoft Corporation logarithmic percentage returns from December 8, 
# 2010 to November 15, 2018 for a total of T = 2000 observation
data("MSFT")

##############################################################
######################## Estimate DMQ ########################
##############################################################

# Estimate DMQ on the in sample period
Fit = EstimateDMQ(vY = vY,
                  vTau = seq(0.01, 0.99, 0.01),
                  iTau_star = 50,
                  FixReference = TRUE,
                  fn.optimizer = fn.solnp)

# Compute estimated moments

Moments = MomentsDMQ(Fit)

</code></pre>

<hr>
<h2 id='MSFT'>data: Microsoft Corporation logarithmic percentage returns from December 8, 2010 to November 15, 2018 for a total of T = 2000 observation downloaded from Yahoo finance.</h2><span id='topic+MSFT'></span><span id='topic+vY'></span>

<h3>Description</h3>

<p>This dataset is the one used in Catania and Luati (2023).<br />
</p>
<p>Dow Jones 30 Constituents closing value log returns from 1987-03-16 to
2009-02-03 from Yahoo Finance. Note that AIG was replaced by KFT (Kraft Foods)
on September 22, 2008. This is not reflected in this data set as that would
bring the starting date of the data to 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MSFT")</code></pre>


<h3>Format</h3>

<p>An <code>xts</code> object of 2000 logarithmic percentage returns.</p>


<h3>Source</h3>

<p>Yahoo Finance</p>


<h3>References</h3>

<p>Catania, L, and Luati, A. (2023). 
&quot;Semiparametric modeling of multiple quantiles.&quot;
Journal of Econometrics
<a href="https://doi.org/10.1016/j.jeconom.2022.11.002">doi:10.1016/j.jeconom.2022.11.002</a>.
</p>

<hr>
<h2 id='SimulateDMQ'>
Simulate from the DMQ model
</h2><span id='topic+SimulateDMQ'></span>

<h3>Description</h3>

<p>Approximate simulation from the DMQ model. Allows to simulate quantiles and observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateDMQ(iT, vQ_0, vTau, iTau_star, vPn, ScalingType = "InvSqrt", fSim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateDMQ_+3A_it">iT</code></td>
<td>
<p> Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_vq_0">vQ_0</code></td>
<td>
 <p><code>numeric</code> vector of limiting quantiles.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_vtau">vTau</code></td>
<td>
<p><code>numeric</code> vector of length Jx1 containing probability levels at which quantiles are estimated.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_itau_star">iTau_star</code></td>
<td>
<p>Integer indicating the position in <code>vTau</code> where the reference quantile is placed. For instance, if <code>vTau = seq(0.01, 0.99, 0.01)</code> then <code>iTau_star = 50</code> means that the median is used as the reference quantile.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_vpn">vPn</code></td>
<td>
<p><code>numeric</code> named vector of length 4x1 with starting values for the optimizer. For example <code>vPn = c("phi" = 0.9, "gamma" = 0.05, "alpha" = 0.01, "beta" = 0.7)</code>.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_scalingtype">ScalingType</code></td>
<td>
<p><code>character</code> Indicating the scaling mechanism for the conditional quasi score. Possible choices are <code>"Identity"</code>, <code>"Inv"</code>,<code>"InvSqrt"</code>. When  <code>ScalingType = "InvSqrt"</code> quasi scores are scaled by their standard deviation. When  <code>ScalingType = "Inv"</code> quasi scores are scaled by their variance. When  <code>ScalingType = "Identity"</code> quasi scores are not scaled. Default value <code>ScalingType = "InvSqrt"</code>.</p>
</td></tr>
<tr><td><code id="SimulateDMQ_+3A_fsim">fSim</code></td>
<td>
<p><code>function</code> to simulate from the discretized distribution implied by the simulated quantiles. By default <code>fSim = NULL</code> meaning that an internal simulation scheme is employed. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of simulated quantiles a Uniform variable drawn. The discretized quantile function is linearly interpoled at the simulated Uniform draw to obtain an observations. When the Uniform draw is outside the range spanned by <code>vTau</code> a Gaussian quantile function is used. The mean and variance of the Gaussian quantile distribution are set to those implied by the simulated quantiles using the same scheme of <a href="#topic+MomentsDMQ">MomentsDMQ</a>.
</p>


<h3>Value</h3>

<p>A <code>list</code> with two elements:
</p>
<table>
<tr><td><code>vY</code></td>
<td>
<p> A <code>numeric</code> vector of T simulated observations.</p>
</td></tr>
<tr><td><code>mQ</code></td>
<td>
<p> A <code>numeric</code> TxJ matrix of simulated quantiles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# Simulate 500 observations from the DMQ model.

# Use the percentiles
vTau = seq(0.01, 0.99, 0.01)

# Median as reference quantile
iTau_star = 50

# Standard Gaussian limiting distribution
vQ_0 = qnorm(vTau)

# vector of parameters
vPn = c("phi" = 0.95, "gamma" = 0.10, "alpha" = 0.01, "beta" = 0.7)

lSim = SimulateDMQ(iT = 500, vQ_0, vTau, iTau_star, vPn)

plot.ts(lSim$vY)
plot.ts(lSim$mQ, plot.type = "single")
</code></pre>

<hr>
<h2 id='UpdateDMQ'>
Update filtered quantiles
</h2><span id='topic+UpdateDMQ'></span>

<h3>Description</h3>

<p>Filter dynamic quantiles using an estimated model and an updated dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateDMQ(Fit, vY) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateDMQ_+3A_fit">Fit</code></td>
<td>
<p>The output of the function <a href="#topic+EstimateDMQ">EstimateDMQ</a>.</p>
</td></tr>
<tr><td><code id="UpdateDMQ_+3A_vy">vY</code></td>
<td>
<p><code>numeric</code> vector containing past and new observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to compute a sequence of one-step-ahead rolling predictions, without updating the parameters of the model, see Examples.
</p>


<h3>Value</h3>

<p>An output like the one of <a href="#topic+EstimateDMQ">EstimateDMQ</a> with updated quantile estimated.
</p>


<h3>Author(s)</h3>

<p>Leopoldo Catania</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Microsoft Corporation logarithmic percentage returns from December 8, 
# 2010 to November 15, 2018 for a total of T = 2000 observation
data("MSFT")

# Divide the sample in two equal parts
vY_is  = vY[1:1000]

##############################################################
######################## Estimate DMQ ########################
##############################################################

# Estimate DMQ over the deciles on the in sample period
Fit = EstimateDMQ(vY = vY_is,
                  vTau = seq(0.1, 0.9, 0.1),
                  iTau_star = 5,
                  FixReference = TRUE,
                  fn.optimizer = fn.solnp)

# compute a sequence of one-step-ahead rolling predictions over the out of sample

Roll = UpdateDMQ(Fit, vY) 

# one steap ahead predictions from time t = 1001 to 2001 are
mForecast = t(Roll$lFilter$mQ)[1001:2001, ]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
