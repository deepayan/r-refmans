<!DOCTYPE html><html><head><title>Help for package gargle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gargle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AuthState-class'><p>Authorization state</p></a></li>
<li><a href='#bulletize'><p>Abbreviate a bullet list neatly</p></a></li>
<li><a href='#check_is_service_account'><p>Check for a service account</p></a></li>
<li><a href='#cred_funs'><p>Credential function registry</p></a></li>
<li><a href='#credentials_app_default'><p>Load Application Default Credentials</p></a></li>
<li><a href='#credentials_byo_oauth2'><p>Load a user-provided token</p></a></li>
<li><a href='#credentials_external_account'><p>Get a token for an external account</p></a></li>
<li><a href='#credentials_gce'><p>Get a token from the Google metadata server</p></a></li>
<li><a href='#credentials_service_account'><p>Load a service account token</p></a></li>
<li><a href='#credentials_user_oauth2'><p>Get an OAuth token for a user</p></a></li>
<li><a href='#field_mask'><p>Generate a field mask</p></a></li>
<li><a href='#gargle_api_key'><p>API key for demonstration purposes</p></a></li>
<li><a href='#gargle_client'><p>OAuth client for demonstration purposes</p></a></li>
<li><a href='#gargle_map_cli'><p>Map a cli-styled template over an object</p></a></li>
<li><a href='#gargle_oauth_client_from_json'><p>Create an OAuth client for Google</p></a></li>
<li><a href='#gargle_oauth_sitrep'><p>OAuth token situation report</p></a></li>
<li><a href='#gargle_options'><p>Options consulted by gargle</p></a></li>
<li><a href='#gargle_secret'><p>Encrypt/decrypt JSON or an R object</p></a></li>
<li><a href='#Gargle-class'><p>OAuth2 token objects specific to Google APIs</p></a></li>
<li><a href='#gargle-package'><p>gargle: Utilities for Working with Google APIs</p></a></li>
<li><a href='#gargle2.0_token'><p>Generate a gargle token</p></a></li>
<li><a href='#gce_access_token'><p>Fetch access token for a service account on GCE</p></a></li>
<li><a href='#gce_instance_service_accounts'><p>List all service accounts available on this GCE instance</p></a></li>
<li><a href='#GceToken'><p>Token for use on Google Compute Engine instances</p></a></li>
<li><a href='#init_AuthState'><p>Create an AuthState</p></a></li>
<li><a href='#internal-assets'><p>Assets for internal use</p></a></li>
<li><a href='#oauth_app_from_json'><p>Create an OAuth app from JSON</p></a></li>
<li><a href='#oauth_external_token'><p>Generate OAuth token for an external account</p></a></li>
<li><a href='#request_develop'><p>Build a Google API request</p></a></li>
<li><a href='#request_make'><p>Make a Google API request</p></a></li>
<li><a href='#request_retry'><p>Make a Google API request, repeatedly</p></a></li>
<li><a href='#response_process'><p>Process a Google API response</p></a></li>
<li><a href='#token_fetch'><p>Fetch a token for the given scopes</p></a></li>
<li><a href='#token-info'><p>Get info from a token</p></a></li>
<li><a href='#WifToken'><p>Token for use with workload identity federation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities for Working with Google APIs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utilities for working with Google APIs
    <a href="https://developers.google.com/apis-explorer">https://developers.google.com/apis-explorer</a>.  This includes
    functions and classes for handling common credential types and for
    preparing, executing, and processing HTTP requests.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gargle.r-lib.org">https://gargle.r-lib.org</a>, <a href="https://github.com/r-lib/gargle">https://github.com/r-lib/gargle</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/gargle/issues">https://github.com/r-lib/gargle/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.1), fs (&ge; 1.3.1), glue (&ge; 1.3.0), httr (&ge;
1.4.5), jsonlite, lifecycle, openssl, rappdirs, rlang (&ge;
1.1.0), stats, utils, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>aws.ec2metadata, aws.signature, covr, httpuv, knitr,
rmarkdown, sodium, spelling, testthat (&ge; 3.1.7)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 18:17:52 UTC; jenny</td>
</tr>
<tr>
<td>Author:</td>
<td>Jennifer Bryan <a href="https://orcid.org/0000-0002-6983-2759"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Craig Citro [aut],
  Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Google Inc [cph],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer Bryan &lt;jenny@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-20 18:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='AuthState-class'>Authorization state</h2><span id='topic+AuthState-class'></span><span id='topic+AuthState'></span>

<h3>Description</h3>

<p>An <code>AuthState</code> object manages an authorization state, typically on behalf of
a wrapper package that makes requests to a Google API.
</p>
<p>The <code style="white-space: pre;">&#8288;vignette("gargle-auth-in-client-package)&#8288;</code> describes a design for wrapper
packages that relies on an <code>AuthState</code> object. This state can then be
incorporated into the package's requests for tokens and can control the
inclusion of tokens in requests to the target API.
</p>

<ul>
<li> <p><code>api_key</code> is the simplest way to associate a request with a specific
Google Cloud Platform <a href="https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#projects">project</a>.
A few calls to certain APIs, e.g. reading a public Sheet, can succeed
with an API key, but this is the exception.
</p>
</li>
<li> <p><code>client</code> is an OAuth client ID (and secret) associated with a specific
Google Cloud Platform <a href="https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#projects">project</a>.
This is used in the OAuth flow, in which an authenticated user authorizes
the client to access or manipulate data on their behalf.
</p>
</li>
<li> <p><code>auth_active</code> reflects whether outgoing requests will be authorized by an
authenticated user or are unauthorized requests for public resources.
These two states correspond to sending a request with a token versus an
API key, respectively.
</p>
</li>
<li> <p><code>cred</code> is where the current token is cached within a session, once one
has been fetched. It is generally assumed to be an instance of
<code><a href="httr.html#topic+Token-class">httr::TokenServiceAccount</a></code> or
<code><a href="httr.html#topic+Token-class">httr::Token2.0</a></code> (or a subclass thereof), probably
obtained via <code><a href="#topic+token_fetch">token_fetch()</a></code> (or one of its constituent credential
fetching functions).
</p>
</li></ul>

<p>An <code>AuthState</code> should be created through the constructor function
<code><a href="#topic+init_AuthState">init_AuthState()</a></code>, which has more details on the arguments.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>package</code></dt><dd><p>Package name.</p>
</dd>
<dt><code>client</code></dt><dd><p>An OAuth client.</p>
</dd>
<dt><code>app</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>client</code> instead.</p>
</dd>
<dt><code>api_key</code></dt><dd><p>An API key.</p>
</dd>
<dt><code>auth_active</code></dt><dd><p>Logical, indicating whether auth is active.</p>
</dd>
<dt><code>cred</code></dt><dd><p>Credentials.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AuthState-new"><code>AuthState$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-format"><code>AuthState$format()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-set_client"><code>AuthState$set_client()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-set_app"><code>AuthState$set_app()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-set_api_key"><code>AuthState$set_api_key()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-set_auth_active"><code>AuthState$set_auth_active()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-set_cred"><code>AuthState$set_cred()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-clear_cred"><code>AuthState$clear_cred()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-get_cred"><code>AuthState$get_cred()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-has_cred"><code>AuthState$has_cred()</code></a>
</p>
</li>
<li> <p><a href="#method-AuthState-clone"><code>AuthState$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AuthState-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new AuthState
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$new(
  package = NA_character_,
  client = NULL,
  api_key = NULL,
  auth_active = TRUE,
  cred = NULL,
  app = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>package</code></dt><dd><p>Package name.</p>
</dd>
<dt><code>client</code></dt><dd><p>An OAuth client.</p>
</dd>
<dt><code>api_key</code></dt><dd><p>An API key.</p>
</dd>
<dt><code>auth_active</code></dt><dd><p>Logical, indicating whether auth is active.</p>
</dd>
<dt><code>cred</code></dt><dd><p>Credentials.</p>
</dd>
<dt><code>app</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>client</code> instead.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For more details on the parameters, see <code><a href="#topic+init_AuthState">init_AuthState()</a></code>
</p>


<hr>
<a id="method-AuthState-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format an AuthState
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-set_client"></a>



<h4>Method <code>set_client()</code></h4>

<p>Set the OAuth client
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$set_client(client)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>client</code></dt><dd><p>An OAuth client.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-set_app"></a>



<h4>Method <code>set_app()</code></h4>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated method to set
the OAuth client
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$set_app(app)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>app</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>client</code> instead.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-set_api_key"></a>



<h4>Method <code>set_api_key()</code></h4>

<p>Set the API key
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$set_api_key(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>An API key.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-set_auth_active"></a>



<h4>Method <code>set_auth_active()</code></h4>

<p>Set whether auth is (in)active
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$set_auth_active(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>Logical, indicating whether to send requests authorized with
user credentials.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-set_cred"></a>



<h4>Method <code>set_cred()</code></h4>

<p>Set credentials
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$set_cred(cred)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cred</code></dt><dd><p>User credentials.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AuthState-clear_cred"></a>



<h4>Method <code>clear_cred()</code></h4>

<p>Clear credentials
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$clear_cred()</pre></div>


<hr>
<a id="method-AuthState-get_cred"></a>



<h4>Method <code>get_cred()</code></h4>

<p>Get credentials
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$get_cred()</pre></div>


<hr>
<a id="method-AuthState-has_cred"></a>



<h4>Method <code>has_cred()</code></h4>

<p>Report if we have credentials
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$has_cred()</pre></div>


<hr>
<a id="method-AuthState-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AuthState$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='bulletize'>Abbreviate a bullet list neatly</h2><span id='topic+bulletize'></span>

<h3>Description</h3>

<p>For internal use in gargle, googledrive, and googlesheets4 (for now).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletize(x, bullet = "*", n_show = 5, n_fudge = 2)
</code></pre>

<hr>
<h2 id='check_is_service_account'>Check for a service account</h2><span id='topic+check_is_service_account'></span>

<h3>Description</h3>

<p>This pre-checks information provided to a high-level, user-facing auth
function, such as <code>googledrive::drive_auth()</code>, before passing the user's
input along to <code><a href="#topic+token_fetch">token_fetch()</a></code>, which is designed to silently swallow errors.
Some users are confused about the difference between an OAuth client and a
service account and they provide the (path to the) JSON for one, when the
other is what's actually expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_is_service_account(path, hint, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_is_service_account_+3A_path">path</code></td>
<td>
<p>JSON identifying the service account, in one of the forms
supported for the <code>txt</code> argument of <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a
file path or JSON string).</p>
</td></tr>
<tr><td><code id="check_is_service_account_+3A_hint">hint</code></td>
<td>
<p>The relevant function to call for configuring an OAuth client.</p>
</td></tr>
<tr><td><code id="check_is_service_account_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Exists purely to throw an error.
</p>

<hr>
<h2 id='cred_funs'>Credential function registry</h2><span id='topic+cred_funs'></span><span id='topic+cred_funs_list'></span><span id='topic+cred_funs_add'></span><span id='topic+cred_funs_set'></span><span id='topic+cred_funs_clear'></span><span id='topic+cred_funs_list_default'></span><span id='topic+cred_funs_set_default'></span><span id='topic+local_cred_funs'></span><span id='topic+with_cred_funs'></span>

<h3>Description</h3>

<p>Functions to query or manipulate the registry of credential functions
consulted by <code><a href="#topic+token_fetch">token_fetch()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cred_funs_list()

cred_funs_add(...)

cred_funs_set(funs, ls = deprecated())

cred_funs_clear()

cred_funs_list_default()

cred_funs_set_default()

local_cred_funs(
  funs = cred_funs_list_default(),
  action = c("replace", "modify"),
  .local_envir = caller_env()
)

with_cred_funs(
  funs = cred_funs_list_default(),
  code,
  action = c("replace", "modify")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cred_funs_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; One or more credential
functions, in <code>name = value</code> form. Each credential function is subject to a
superficial check that it at least &quot;smells like&quot; a credential function: its
first argument must be named <code>scopes</code>, and its signature must include
<code>...</code>. To remove a credential function, you can use a specification like
<code>name = NULL</code>.</p>
</td></tr>
<tr><td><code id="cred_funs_+3A_funs">funs</code></td>
<td>
<p>A named list of credential functions.</p>
</td></tr>
<tr><td><code id="cred_funs_+3A_ls">ls</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> This argument has been renamed
to <code>funs</code>.</p>
</td></tr>
<tr><td><code id="cred_funs_+3A_action">action</code></td>
<td>
<p>Whether to use <code>funs</code> to replace or modify the registry with
funs:
</p>

<ul>
<li> <p><code>"replace"</code> does <code>cred_funs_set(funs)</code>
</p>
</li>
<li> <p><code>"modify"</code> does <code>cred_funs_add(!!!funs)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="cred_funs_+3A_.local_envir">.local_envir</code></td>
<td>
<p>The environment to use for scoping. Defaults to current
execution environment.</p>
</td></tr>
<tr><td><code id="cred_funs_+3A_code">code</code></td>
<td>
<p>Code to run with temporary credential function registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of credential functions or <code>NULL</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cred_funs_list()</code>: Get the list of registered credential functions.
</p>
</li>
<li> <p><code>cred_funs_add()</code>: Register one or more new credential fetching functions.
Function(s) are added to the <em>front</em> of the list. So:
</p>

<ul>
<li><p> &quot;First registered, last tried.&quot;
</p>
</li>
<li><p> &quot;Last registered, first tried.&quot;
</p>
</li></ul>

<p>Can also be used to <em>remove</em> a function from the registry.
</p>
</li>
<li> <p><code>cred_funs_set()</code>: Register a list of credential fetching functions.
</p>
</li>
<li> <p><code>cred_funs_clear()</code>: Clear the credential function registry.
</p>
</li>
<li> <p><code>cred_funs_list_default()</code>: Return the default list of credential functions.
</p>
</li>
<li> <p><code>cred_funs_set_default()</code>: Reset the registry to the gargle default.
</p>
</li>
<li> <p><code>local_cred_funs()</code>: Modify the credential function registry in the current
scope. It is an example of the <code style="white-space: pre;">&#8288;local_*()&#8288;</code> functions in <span class="pkg">withr</span>.
</p>
</li>
<li> <p><code>with_cred_funs()</code>: Evaluate <code>code</code> with a temporarily modified credential
function registry. It is an example of the <code style="white-space: pre;">&#8288;with_*()&#8288;</code> functions in
<span class="pkg">withr</span>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+token_fetch">token_fetch()</a></code>, which is where the registry is actually used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(cred_funs_list())

creds_one &lt;- function(scopes, ...) {}

cred_funs_add(one = creds_one)
cred_funs_add(two = creds_one, three = creds_one)
names(cred_funs_list())

cred_funs_add(two = NULL)
names(cred_funs_list())

# restore the default list
cred_funs_set_default()

# remove one specific credential fetcher
cred_funs_add(credentials_gce = NULL)
names(cred_funs_list())

# force the use of one specific credential fetcher
cred_funs_set(list(credentials_user_oauth2 = credentials_user_oauth2))
names(cred_funs_list())

# restore the default list
cred_funs_set_default()

# run some code with a temporary change to the registry
# creds_one ONLY
with_cred_funs(
  list(one = creds_one),
  names(cred_funs_list())
)
# add creds_one to the list
with_cred_funs(
  list(one = creds_one),
  names(cred_funs_list()),
  action = "modify"
)
# remove credentials_gce
with_cred_funs(
  list(credentials_gce = NULL),
  names(cred_funs_list()),
  action = "modify"
)
</code></pre>

<hr>
<h2 id='credentials_app_default'>Load Application Default Credentials</h2><span id='topic+credentials_app_default'></span>

<h3>Description</h3>

<p>Loads credentials from a file identified via a search strategy known as
Application Default Credentials (ADC). The hope is to make auth &quot;just work&quot;
for someone working on Google-provided infrastructure or who has used Google
tooling to get started, such as the <a href="https://cloud.google.com/sdk/gcloud"><code>gcloud</code> command line tool</a>.
</p>
<p>A sequence of paths is consulted, which we describe here, with some abuse of
notation. ALL_CAPS represents the value of an environment variable and <code style="white-space: pre;">&#8288;%||%&#8288;</code>
is used in the spirit of a <a href="https://en.wikipedia.org/wiki/Null_coalescing_operator">null coalescing operator</a>.
</p>
<div class="sourceCode"><pre>GOOGLE_APPLICATION_CREDENTIALS
CLOUDSDK_CONFIG/application_default_credentials.json
# on Windows:
(APPDATA %||% SystemDrive %||% C:)\gcloud\application_default_credentials.json
# on not-Windows:
~/.config/gcloud/application_default_credentials.json
</pre></div>
<p>If the above search successfully identifies a JSON file, it is parsed and
ingested as a service account, an external account (&quot;workload identity
federation&quot;), or a user account. Literally, if the JSON describes a service
account, we call <code><a href="#topic+credentials_service_account">credentials_service_account()</a></code> and if it describes an
external account, we call <code><a href="#topic+credentials_external_account">credentials_external_account()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_app_default(scopes = NULL, ..., subject = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_app_default_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_app_default_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
<tr><td><code id="credentials_app_default_+3A_subject">subject</code></td>
<td>
<p>An optional subject claim. Specify this if you wish to use the
service account represented by <code>path</code> to impersonate the <code>subject</code>, who is
a normal user. Before this can work, an administrator must grant the service
account domain-wide authority. Identify the user to impersonate via their
email, e.g. <code>subject = "user@example.com"</code>. Note that gargle automatically
adds the non-sensitive <code>"https://www.googleapis.com/auth/userinfo.email"</code>
scope, so this scope must be enabled for the service account, along with
any other <code>scopes</code> being requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="httr.html#topic+Token-class">httr::TokenServiceAccount</a></code>, a <code><a href="#topic+WifToken">WifToken</a></code>,
an <code><a href="httr.html#topic+Token-class">httr::Token2.0</a></code> or <code>NULL</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://cloud.google.com/docs/authentication#adc">https://cloud.google.com/docs/authentication#adc</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/sdk/docs/">https://cloud.google.com/sdk/docs/</a>
</p>
</li></ul>

<p>Other credential functions: 
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
credentials_app_default()

## End(Not run)
</code></pre>

<hr>
<h2 id='credentials_byo_oauth2'>Load a user-provided token</h2><span id='topic+credentials_byo_oauth2'></span>

<h3>Description</h3>

<p>This function is designed to pass its <code>token</code> input through, after doing a
few checks and some light processing:
</p>

<ul>
<li><p> If <code>token</code> has class <code>request</code>, i.e. it is a token that has been prepared
with <code><a href="httr.html#topic+config">httr::config()</a></code>, the <code>auth_token</code> component is extracted. For
example, such input could be returned by <code>googledrive::drive_token()</code>
or <code>bigrquery::bq_token()</code>.
</p>
</li>
<li><p> If <code>token</code> is an instance of <code>Gargle2.0</code> (so: a gargle-obtained user
token), checks that it appears to be a Google OAuth token, based on its
embedded <code>oauth_endpoint</code>. Refreshes the token, if it's refreshable.
</p>
</li>
<li><p> Returns the <code>token</code>.
</p>
</li></ul>

<p>There is no point in providing <code>scopes</code>. They are ignored because the
<code>scopes</code> associated with the token have already been baked in to the token
itself and gargle does not support incremental authorization. The main point
of <code>credentials_byo_oauth2()</code> is to allow <code>token_fetch()</code> (and packages that
wrap it) to accommodate a &quot;bring your own token&quot; workflow.
</p>
<p>This also makes it possible to obtain a token with one package and then
register it for use with another package. For example, the default scope
requested by googledrive is also sufficient for operations available in
googlesheets4. You could use a shared token like so:
</p>
<div class="sourceCode"><pre>library(googledrive)
library(googlesheets4)
drive_auth(email = "jane_doe@example.com")
gs4_auth(token = drive_token())
# work with both packages freely now, with the same identity
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_byo_oauth2(scopes = NULL, token, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_byo_oauth2_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_byo_oauth2_+3A_token">token</code></td>
<td>
<p>A token with class <a href="httr.html#topic+Token-class">Token2.0</a> or an object of
httr's class <code>request</code>, i.e. a token that has been prepared with
<code><a href="httr.html#topic+config">httr::config()</a></code> and has a <a href="httr.html#topic+Token-class">Token2.0</a> in the
<code>auth_token</code> component.</p>
</td></tr>
<tr><td><code id="credentials_byo_oauth2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="httr.html#topic+Token-class">Token2.0</a>.
</p>


<h3>See Also</h3>

<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# assume `my_token` is a Token2.0 object returned by a function such as
# credentials_user_oauth2()
credentials_byo_oauth2(token = my_token)

## End(Not run)
</code></pre>

<hr>
<h2 id='credentials_external_account'>Get a token for an external account</h2><span id='topic+credentials_external_account'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Workload identity federation is a new (as of April 2021) keyless
authentication mechanism that allows applications running on a non-Google
Cloud platform, such as AWS, to access Google Cloud resources without using a
conventional service account token. This eliminates the dilemma of how to
safely manage service account credential files.
</p>
<p>Unlike service accounts, the configuration file for workload identity
federation contains no secrets. Instead, it holds non-sensitive metadata.
The external application obtains the needed sensitive data &quot;on-the-fly&quot; from
the running instance. The combined data is then used to obtain a so-called
subject token from the external identity provider, such as AWS. This is then
sent to Google's Security Token Service API, in exchange for a very
short-lived federated access token. Finally, the federated access token is
sent to Google's Service Account Credentials API, in exchange for a
short-lived GCP access token. This access token allows the external
application to impersonate a service account and inherit the permissions of
the service account to access GCP resources.
</p>
<p>This feature is still experimental in gargle and <strong>currently only supports
AWS</strong>. It also requires installation of the suggested packages
<span class="pkg">aws.signature</span> and <span class="pkg">aws.ec2metadata</span>. Workload identity federation
<strong>can</strong> be used with other platforms, such as Microsoft Azure or any
identity provider that supports OpenID Connect. If you would like gargle to
support this token flow for additional platforms, please <a href="https://github.com/r-lib/gargle/issues">open an issue on GitHub</a> and describe your use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_external_account(
  scopes = "https://www.googleapis.com/auth/cloud-platform",
  path = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_external_account_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_external_account_+3A_path">path</code></td>
<td>
<p>JSON containing the workload identity configuration for the
external account, in one of the forms supported for the <code>txt</code> argument of
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (probably, a file path, although it could be a JSON
string). The instructions for generating this configuration are given at
<a href="https://cloud.google.com/iam/docs/configuring-workload-identity-federation">Configuring workload identity federation</a>.
</p>
<p>Note that external account tokens are a natural fit for use as Application
Default Credentials, so consider storing the configuration file in one of
the standard locations consulted for ADC, instead of providing <code>path</code>
explicitly. See <code><a href="#topic+credentials_app_default">credentials_app_default()</a></code> for more.</p>
</td></tr>
<tr><td><code id="credentials_external_account_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+WifToken">WifToken()</a></code> or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>There is substantial setup necessary, both on the GCP and AWS side,
to use this authentication method. These two links provide, respectively,
a high-level overview and step-by-step instructions.
</p>

<ul>
<li> <p><a href="https://cloud.google.com/blog/products/identity-security/enable-keyless-access-to-gcp-with-workload-identity-federation/">https://cloud.google.com/blog/products/identity-security/enable-keyless-access-to-gcp-with-workload-identity-federation/</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/iam/docs/configuring-workload-identity-federation">https://cloud.google.com/iam/docs/configuring-workload-identity-federation</a>
</p>
</li></ul>

<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
credentials_external_account()

## End(Not run)
</code></pre>

<hr>
<h2 id='credentials_gce'>Get a token from the Google metadata server</h2><span id='topic+credentials_gce'></span>

<h3>Description</h3>

<p>If your code is running on Google Cloud, we can often obtain a token for an
attached service account directly from a metadata server. This is more secure
than working with an explicit a service account key, as
<code><a href="#topic+credentials_service_account">credentials_service_account()</a></code> does, and is the preferred method of auth for
workloads running on Google Cloud.
</p>
<p>The most straightforward scenario is when you are working in a VM on Google
Compute Engine and it's OK to use the default service account. This should
&quot;just work&quot; automatically.
</p>
<p><code>credentials_gce()</code> supports other use cases (such as GKE Workload Identity),
but may require some explicit setup, such as:
</p>

<ul>
<li><p> Create a service account, grant it appropriate scopes(s) and IAM roles,
attach it to the target resource. This prep work happens outside of R, e.g.,
in the Google Cloud Console. On the R side, provide the email address of this
appropriately configured service account via <code>service_account</code>.
</p>
</li>
<li><p> Specify details for constructing the root URL of the metadata service:
</p>

<ul>
<li><p> The logical option <code>"gargle.gce.use_ip"</code>. If undefined, this defaults to
<code>FALSE</code>.
</p>
</li>
<li><p> The environment variable <code>GCE_METADATA_URL</code> is consulted when
<code>"gargle.gce.use_ip"</code> is <code>FALSE</code>. If undefined, the default is
<code>metadata.google.internal</code>.
</p>
</li>
<li><p> The environment variable <code>GCE_METADATA_IP</code> is consulted when
<code>"gargle.gce.use_ip"</code> is <code>TRUE</code>. If undefined, the default is
<code style="white-space: pre;">&#8288;169.254.169.254&#8288;</code>.
</p>
</li></ul>

</li>
<li><p> Change (presumably increase) the timeout for requests to the metadata
server via the <code>"gargle.gce.timeout"</code> global option. This timeout is given in
seconds and is set to a value (strategy, really) that often works well in
practice. However, in some cases it may be necessary to increase the timeout
with code such as:
</p>
</li></ul>

<div class="sourceCode r"><pre>options(gargle.gce.timeout = 3)
</pre></div>
<p>For details on specific use cases, such as Google Kubernetes Engine (GKE),
see <code>vignette("non-interactive-auth")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_gce(
  scopes = "https://www.googleapis.com/auth/cloud-platform",
  service_account = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_gce_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_gce_+3A_service_account">service_account</code></td>
<td>
<p>Name of the GCE service account to use.</p>
</td></tr>
<tr><td><code id="credentials_gce_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+GceToken">GceToken()</a></code> or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>A related auth flow that can be used on certain non-Google cloud
providers is workload identity federation, which is implemented in
<code><a href="#topic+credentials_external_account">credentials_external_account()</a></code>.
</p>
<p><a href="https://cloud.google.com/compute/docs/access/service-accounts">https://cloud.google.com/compute/docs/access/service-accounts</a>
</p>
<p><a href="https://cloud.google.com/iam/docs/best-practices-service-accounts">https://cloud.google.com/iam/docs/best-practices-service-accounts</a>
</p>
<p>How to attach a service account to a resource:
<a href="https://cloud.google.com/iam/docs/impersonating-service-accounts#attaching-to-resources">https://cloud.google.com/iam/docs/impersonating-service-accounts#attaching-to-resources</a>
</p>
<p><a href="https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity">https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity</a>
</p>
<p><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity">https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity</a>
</p>
<p><a href="https://cloud.google.com/compute/docs/metadata/overview">https://cloud.google.com/compute/docs/metadata/overview</a>
</p>
<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
credentials_gce()

## End(Not run)
</code></pre>

<hr>
<h2 id='credentials_service_account'>Load a service account token</h2><span id='topic+credentials_service_account'></span>

<h3>Description</h3>

<p>Load a service account token
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_service_account(scopes = NULL, path = "", ..., subject = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_service_account_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_service_account_+3A_path">path</code></td>
<td>
<p>JSON identifying the service account, in one of the forms
supported for the <code>txt</code> argument of <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a
file path or JSON string).</p>
</td></tr>
<tr><td><code id="credentials_service_account_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
<tr><td><code id="credentials_service_account_+3A_subject">subject</code></td>
<td>
<p>An optional subject claim. Specify this if you wish to use the
service account represented by <code>path</code> to impersonate the <code>subject</code>, who is
a normal user. Before this can work, an administrator must grant the service
account domain-wide authority. Identify the user to impersonate via their
email, e.g. <code>subject = "user@example.com"</code>. Note that gargle automatically
adds the non-sensitive <code>"https://www.googleapis.com/auth/userinfo.email"</code>
scope, so this scope must be enabled for the service account, along with
any other <code>scopes</code> being requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that fetching a token for a service account requires a
reasonably accurate system clock. For more information, see the
<code>vignette("how-gargle-gets-tokens")</code>.
</p>


<h3>Value</h3>

<p>An <code><a href="httr.html#topic+Token-class">httr::TokenServiceAccount</a></code> or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Additional reading on delegation of domain-wide authority:
</p>

<ul>
<li> <p><a href="https://developers.google.com/identity/protocols/oauth2/service-account#delegatingauthority">https://developers.google.com/identity/protocols/oauth2/service-account#delegatingauthority</a>
</p>
</li></ul>

<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
token &lt;- credentials_service_account(
  scopes = "https://www.googleapis.com/auth/userinfo.email",
  path = "/path/to/your/service-account.json"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='credentials_user_oauth2'>Get an OAuth token for a user</h2><span id='topic+credentials_user_oauth2'></span>

<h3>Description</h3>

<p>Consults the token cache for a suitable OAuth token and, if
unsuccessful, gets a token via the browser flow. A cached token is suitable
if it's compatible with the user's request in this sense:
</p>

<ul>
<li><p> OAuth client must be same.
</p>
</li>
<li><p> Scopes must be same.
</p>
</li>
<li><p> Email, if provided, must be same. If specified email is a glob pattern
like <code>"*@example.com"</code>, email matching is done at the domain level.
</p>
</li></ul>

<p>gargle is very conservative about using OAuth tokens discovered in the user's
cache and will generally seek interactive confirmation. Therefore, in a
non-interactive setting, it's important to explicitly specify the <code>"email"</code>
of the target account or to explicitly authorize automatic discovery. See
<code><a href="#topic+gargle2.0_token">gargle2.0_token()</a></code>, which this function wraps, for more. Non-interactive use
also suggests it might be time to use a <a href="#topic+credentials_service_account">service account token</a> or <a href="#topic+credentials_external_account">workload identity federation</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credentials_user_oauth2(
  scopes = NULL,
  client = gargle_client(),
  package = "gargle",
  ...,
  app = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credentials_user_oauth2_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="credentials_user_oauth2_+3A_client">client</code></td>
<td>
<p>A Google OAuth client, preferably constructed via
<code><a href="#topic+gargle_oauth_client_from_json">gargle_oauth_client_from_json()</a></code>, which returns an instance of
<code>gargle_oauth_client</code>. For backwards compatibility, for a limited time,
gargle will still accept an &quot;OAuth app&quot; created with <code><a href="httr.html#topic+oauth_app">httr::oauth_app()</a></code>.</p>
</td></tr>
<tr><td><code id="credentials_user_oauth2_+3A_package">package</code></td>
<td>
<p>Name of the package requesting a token. Used in messages.</p>
</td></tr>
<tr><td><code id="credentials_user_oauth2_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+gargle2.0_token">gargle2.0_token</a></code>
</p>

<dl>
<dt><code>email</code></dt><dd><p>Optional. If specified, <code>email</code> can take several different
forms:
</p>

<ul>
<li> <p><code>"jane@gmail.com"</code>, i.e. an actual email address. This allows the user to
target a specific Google identity. If specified, this is used for token
lookup, i.e. to determine if a suitable token is already available in the
cache. If no such token is found, <code>email</code> is used to pre-select the targeted
Google identity in the OAuth chooser. (Note, however, that the email
associated with a token when it's cached is always determined from the token
itself, never from this argument).
</p>
</li>
<li> <p><code>"*@example.com"</code>, i.e. a domain-only glob pattern. This can be helpful if
you need code that &quot;just works&quot; for both <code>alice@example.com</code> and
<code>bob@example.com</code>.
</p>
</li>
<li> <p><code>TRUE</code> means that you are approving email auto-discovery. If exactly one
matching token is found in the cache, it will be used.
</p>
</li>
<li> <p><code>FALSE</code> or <code>NA</code> mean that you want to ignore the token cache and force a
new OAuth dance in the browser.
</p>
</li></ul>

<p>Defaults to the option named <code>"gargle_oauth_email"</code>, retrieved by
<code><a href="#topic+gargle_oauth_email">gargle_oauth_email()</a></code> (unless a wrapper package implements different
default behavior).</p>
</dd>
<dt><code>use_oob</code></dt><dd><p>Whether to use out-of-band authentication (or, perhaps, a
variant implemented by gargle and known as &quot;pseudo-OOB&quot;) when first
acquiring the token. Defaults to the value returned by
<code><a href="#topic+gargle_oob_default">gargle_oob_default()</a></code>. Note that (pseudo-)OOB auth only affects
the initial OAuth dance. If we retrieve (and possibly refresh) a
cached token, <code>use_oob</code> has no effect.
</p>
<p>If the OAuth client is provided implicitly by a wrapper package, its type
probably defaults to the value returned by
<code><a href="#topic+gargle_oauth_client_type">gargle_oauth_client_type()</a></code>. You can take control of the client
type by setting <code>options(gargle_oauth_client_type = "web")</code> or
<code>options(gargle_oauth_client_type = "installed")</code>.</p>
</dd>
<dt><code>cache</code></dt><dd><p>Specifies the OAuth token cache. Defaults to the option named
<code>"gargle_oauth_cache"</code>, retrieved via <code><a href="#topic+gargle_oauth_cache">gargle_oauth_cache()</a></code>.</p>
</dd>
<dt><code>credentials</code></dt><dd><p>Advanced use only: allows you to completely customise
token generation.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="credentials_user_oauth2_+3A_app">app</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Replaced by the <code>client</code>
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Gargle2.0">Gargle2.0</a> token.
</p>


<h3>See Also</h3>

<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+token_fetch">token_fetch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Drive scope, built-in gargle demo client
scopes &lt;- "https://www.googleapis.com/auth/drive"
credentials_user_oauth2(scopes, client = gargle_client())

# bring your own client
client &lt;- gargle_oauth_client_from_json(
  path = "/path/to/the/JSON/you/downloaded/from/gcp/console.json",
  name = "my-nifty-oauth-client"
)
credentials_user_oauth2(scopes, client)

## End(Not run)
</code></pre>

<hr>
<h2 id='field_mask'>Generate a field mask</h2><span id='topic+field_mask'></span>

<h3>Description</h3>

<p>Many Google API requests take a field mask, via a <code>fields</code> parameter, in the
URL and/or in the body. <code>field_mask()</code> generates such a field mask from an R
list, typically a list that is destined to be part of the body of a request
that writes or updates a resource. <code>field_mask()</code> is designed to help in the
common case where the attributes you wish to modify are exactly the ones
represented in the object. It is possible to use a &quot;larger&quot; field mask, that
is either less specific or that explicitly includes other attributes, in
which case the attributes covered by the mask but absent from the object are
reset to default values. This is not exactly the use case <code>field_mask()</code> is
designed for, but its output could still be useful as a first step in
constructing such a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_mask(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_mask_+3A_x">x</code></td>
<td>
<p>A named R list, where the requirement for names applies at all
levels, i.e. recursively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Google API field mask, as a string.
</p>


<h3>See Also</h3>

<p>The documentation for the <a href="https://protobuf.dev/reference/protobuf/google.protobuf/#json-encoding-of-field-masks">JSON encoding of a Protocol Buffers FieldMask</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(sheetId = 1234, title = "my_favorite_worksheet")
field_mask(x)

x &lt;- list(
  userEnteredFormat = list(
    backgroundColor = list(
      red = 159 / 255, green = 183 / 255, blue = 196 / 255
    )
  )
)
field_mask(x)

x &lt;- list(
  sheetId = 1234,
  gridProperties = list(rowCount = 5, columnCount = 3)
)
field_mask(x)
</code></pre>

<hr>
<h2 id='gargle_api_key'>API key for demonstration purposes</h2><span id='topic+gargle_api_key'></span>

<h3>Description</h3>

<p>Some APIs accept requests for public resources, in which case
the request must be sent with an API key in lieu of a token. This function
provides an API key for limited use in prototyping and for testing and
documentation of gargle itself. This key may be deleted or rotated at any
time. There are no guarantees about which APIs are enabled. DO NOT USE THIS
IN A PACKAGE or for anything other than interactive, small-scale
experimentation.
</p>
<p>You can get your own API key, without these limitations. See the <a href="https://gargle.r-lib.org/articles/get-api-credentials.html">How to get your own API credentials</a>
vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gargle_api_key()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>gargle_api_key()
</code></pre>

<hr>
<h2 id='gargle_client'>OAuth client for demonstration purposes</h2><span id='topic+gargle_client'></span>

<h3>Description</h3>

<p>Invisibly returns an instance of
<code><a href="#topic+gargle_oauth_client">gargle_oauth_client</a></code> that can be used to test drive
gargle before obtaining your own client ID and secret. This OAuth client may
be deleted or rotated at any time. There are no guarantees about which APIs
are enabled. DO NOT USE THIS IN A PACKAGE or for anything other than
interactive, small-scale experimentation.
</p>
<p>You can get your own OAuth client ID and secret, without these limitations.
See the <code>vignette("get-api-credentials")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gargle_client(type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle_client_+3A_type">type</code></td>
<td>
<p>Specifies the type of OAuth client. The valid values are a subset
of possible Google client types and reflect the key used to describe the
client in its JSON representation:
</p>

<ul>
<li> <p><code>"installed"</code> is associated with a &quot;Desktop app&quot;
</p>
</li>
<li> <p><code>"web"</code> is associated with a &quot;Web application&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An OAuth client, produced by <code><a href="#topic+gargle_oauth_client">gargle_oauth_client()</a></code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gargle_client()

## End(Not run)
</code></pre>

<hr>
<h2 id='gargle_map_cli'>Map a cli-styled template over an object</h2><span id='topic+gargle_map_cli'></span>

<h3>Description</h3>

<p>For internal use in gargle, googledrive, and googlesheets4 (for now).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gargle_map_cli(x, ...)
</code></pre>

<hr>
<h2 id='gargle_oauth_client_from_json'>Create an OAuth client for Google</h2><span id='topic+gargle_oauth_client_from_json'></span><span id='topic+gargle_oauth_client'></span>

<h3>Description</h3>

<p>A <code>gargle_oauth_client</code> consists of:
</p>

<ul>
<li><p> A type. gargle only supports the &quot;Desktop app&quot; and &quot;Web application&quot; client
types. Different types are associated with different OAuth flows.
</p>
</li>
<li><p> A client ID and secret.
</p>
</li>
<li><p> Optionally, one or more redirect URIs.
</p>
</li>
<li><p> A name. This is really a human-facing label. Or, rather, it can be used
that way, but the default is just a hash. We recommend using the same name
here as the name used to label the client ID in the <a href="https://console.cloud.google.com">Google Cloud Platform Console</a>.
</p>
</li></ul>

<p>A <code>gargle_oauth_client</code> is an adaptation of httr's <code><a href="httr.html#topic+oauth_app">oauth_app()</a></code> (currently)
and httr2's <code>oauth_client()</code> (which gargle will migrate to in the future).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gargle_oauth_client_from_json(path, name = NULL)

gargle_oauth_client(
  id,
  secret,
  redirect_uris = NULL,
  type = c("installed", "web"),
  name = hash(id)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle_oauth_client_from_json_+3A_path">path</code></td>
<td>
<p>JSON downloaded from <a href="https://console.cloud.google.com">Google Cloud Console</a>, containing a client id and
secret, in one of the forms supported for the <code>txt</code> argument of
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a file path or JSON string).</p>
</td></tr>
<tr><td><code id="gargle_oauth_client_from_json_+3A_name">name</code></td>
<td>
<p>A label for this specific client, presumably the same name used
to label it in Google Cloud Console. Unfortunately there is no way to
make that true programmatically, i.e. the JSON representation does not
contain this information.</p>
</td></tr>
<tr><td><code id="gargle_oauth_client_from_json_+3A_id">id</code></td>
<td>
<p>Client ID</p>
</td></tr>
<tr><td><code id="gargle_oauth_client_from_json_+3A_secret">secret</code></td>
<td>
<p>Client secret</p>
</td></tr>
<tr><td><code id="gargle_oauth_client_from_json_+3A_redirect_uris">redirect_uris</code></td>
<td>
<p>Where your application listens for the response from
Google's authorization server. If you didn't configure this specifically
when creating the client (which is only possible for clients of the &quot;web&quot;
type), you can leave this unspecified.</p>
</td></tr>
<tr><td><code id="gargle_oauth_client_from_json_+3A_type">type</code></td>
<td>
<p>Specifies the type of OAuth client. The valid values are a subset
of possible Google client types and reflect the key used to describe the
client in its JSON representation:
</p>

<ul>
<li> <p><code>"installed"</code> is associated with a &quot;Desktop app&quot;
</p>
</li>
<li> <p><code>"web"</code> is associated with a &quot;Web application&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An OAuth client: An S3 list with class <code>gargle_oauth_client</code>. For
backwards compatibility reasons, this currently also inherits from the httr
S3 class <code>oauth_app</code>, but that is a temporary measure. An instance of
<code>gargle_oauth_client</code> stores more information than httr's <code>oauth_app</code>, such
as the OAuth client's type (&quot;web&quot; or &quot;installed&quot;).
</p>
<p>There are some redundant fields in this object during the httr-to-httr2
transition period. The legacy fields <code>appname</code> and <code>key</code> repeat the
information in the future-facing fields <code>name</code> and (client) <code>id</code>. Prefer
<code>name</code> and <code>id</code> to <code>appname</code> and <code>key</code> in downstream code. Prefer the
constructors <code>gargle_oauth_client_from_json()</code> and <code>gargle_oauth_client()</code>
to <code><a href="httr.html#topic+oauth_app">httr::oauth_app()</a></code> and <code><a href="#topic+oauth_app_from_json">oauth_app_from_json()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gargle_oauth_client_from_json(
  path = "/path/to/the/JSON/you/downloaded/from/gcp/console.json",
  name = "my-nifty-oauth-client"
)

## End(Not run)

gargle_oauth_client(
  id = "some_long_id",
  secret = "ssshhhhh_its_a_secret",
  name = "my-nifty-oauth-client"
)
</code></pre>

<hr>
<h2 id='gargle_oauth_sitrep'>OAuth token situation report</h2><span id='topic+gargle_oauth_sitrep'></span>

<h3>Description</h3>

<p>Get a human-oriented overview of the existing gargle OAuth tokens:
</p>

<ul>
<li><p> Filepath of the current cache
</p>
</li>
<li><p> Number of tokens found there
</p>
</li>
<li><p> Compact summary of the associated
</p>

<ul>
<li><p> Email = Google identity
</p>
</li>
<li><p> OAuth client (actually, just its nickname)
</p>
</li>
<li><p> Scopes
</p>
</li>
<li><p> Hash (actually, just the first 7 characters)
Mostly useful for the development of gargle and client packages.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gargle_oauth_sitrep(cache = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle_oauth_sitrep_+3A_cache">cache</code></td>
<td>
<p>Specifies the OAuth token cache. Defaults to the option named
<code>"gargle_oauth_cache"</code>, retrieved via <code><a href="#topic+gargle_oauth_cache">gargle_oauth_cache()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per cached token, invisibly. Note this data
frame may contain more columns than it seems, e.g. the <code>filepath</code> column
isn't printed by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gargle_oauth_sitrep()
</code></pre>

<hr>
<h2 id='gargle_options'>Options consulted by gargle</h2><span id='topic+gargle_options'></span><span id='topic+gargle_oauth_email'></span><span id='topic+gargle_oob_default'></span><span id='topic+gargle_oauth_cache'></span><span id='topic+gargle_oauth_client_type'></span><span id='topic+gargle_verbosity'></span><span id='topic+local_gargle_verbosity'></span><span id='topic+with_gargle_verbosity'></span>

<h3>Description</h3>

<p>Wrapper functions around options consulted by gargle, which provide:
</p>

<ul>
<li><p> A place to hang documentation.
</p>
</li>
<li><p> The mechanism for setting a default.
</p>
</li></ul>

<p>If the built-in defaults don't suit you, set one or more of these options.
Typically, this is done in the <code>.Rprofile</code> startup file, with code along
these lines:
</p>
<div class="sourceCode"><pre>options(
  gargle_oauth_email = "jane@example.com",
  gargle_oauth_cache = "/path/to/folder/that/does/not/sync/to/cloud"
)
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>gargle_oauth_email()

gargle_oob_default()

gargle_oauth_cache()

gargle_oauth_client_type()

gargle_verbosity()

local_gargle_verbosity(level, env = caller_env())

with_gargle_verbosity(level, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle_options_+3A_level">level</code></td>
<td>
<p>Verbosity level: &quot;debug&quot; &gt; &quot;info&quot; &gt; &quot;silent&quot;</p>
</td></tr>
<tr><td><code id="gargle_options_+3A_env">env</code></td>
<td>
<p>The environment to use for scoping</p>
</td></tr>
<tr><td><code id="gargle_options_+3A_code">code</code></td>
<td>
<p>Code to execute with specified verbosity level</p>
</td></tr>
</table>


<h3><code>gargle_oauth_email</code></h3>

<p><code>gargle_oauth_email()</code> returns the option named &quot;gargle_oauth_email&quot;, which
is undefined by default. If set, this option should be one of:
</p>

<ul>
<li><p> An actual email address corresponding to your preferred Google identity.
Example:<code>janedoe@gmail.com</code>.
</p>
</li>
<li><p> A glob pattern that indicates your preferred Google domain.
Example:<code style="white-space: pre;">&#8288;*@example.com&#8288;</code>.
</p>
</li>
<li> <p><code>TRUE</code> to allow email and OAuth token auto-discovery, if exactly one
suitable token is found in the cache.
</p>
</li>
<li> <p><code>FALSE</code> or <code>NA</code> to force the OAuth dance in the browser.
</p>
</li></ul>



<h3><code>gargle_oob_default</code></h3>

<p><code>gargle_oob_default()</code> returns <code>TRUE</code> unconditionally on RStudio Server,
Posit Workbench, Posit Cloud, or Google Colaboratory, since it is not
possible to launch a local web server in these contexts. In this case, for
the final step of the OAuth dance, the user is redirected to a specific URL
where they must copy a code and paste it back into the R session.
</p>
<p>In all other contexts, <code>gargle_oob_default()</code> consults the option named
<code>"gargle_oob_default"</code>, then the option named <code>"httr_oob_default"</code>, and
eventually defaults to <code>FALSE</code>.
</p>
<p>&quot;oob&quot; stands for out-of-band. Read more about out-of-band authentication in
the vignette <code>vignette("auth-from-web")</code>.
</p>


<h3><code>gargle_oauth_cache</code></h3>

<p><code>gargle_oauth_cache()</code> returns the option named &quot;gargle_oauth_cache&quot;,
defaulting to <code>NA</code>. If defined, the option must be set to a logical value or
a string. <code>TRUE</code> means to cache using the default user-level cache file,
<code style="white-space: pre;">&#8288;~/.R/gargle/gargle-oauth&#8288;</code>, <code>FALSE</code> means don't cache, and <code>NA</code> means to
guess using some sensible heuristics.
</p>


<h3><code>gargle_oauth_client_type</code></h3>

<p><code>gargle_oauth_client_type()</code> returns the option named
&quot;gargle_oauth_client_type&quot;, if defined. If defined, the option must be either
&quot;installed&quot; or &quot;web&quot;. If the option is not defined, the function returns:
</p>

<ul>
<li><p> &quot;web&quot; on RStudio Server, Posit Workbench, Posit Cloud, or Google
Colaboratory
</p>
</li>
<li><p> &quot;installed&quot; otherwise
</p>
</li></ul>

<p>Primarily intended to help infer the most suitable OAuth client type when a
user is relying on a built-in client, such as the tidyverse client used by
packages like bigrquery, googledrive, and googlesheets4.
</p>


<h3><code>gargle_verbosity</code></h3>

<p><code>gargle_verbosity()</code> returns the option named &quot;gargle_verbosity&quot;, which
determines gargle's verbosity. There are three possible values, inspired by
the logging levels of log4j:
</p>

<ul>
<li><p> &quot;debug&quot;: Fine-grained information helpful when debugging, e.g. figuring out
how <code>token_fetch()</code> is working through the registry of credential
functions. Previously, this was activated by setting an option named
&quot;gargle_quiet&quot; to <code>FALSE</code>.
</p>
</li>
<li><p> &quot;info&quot; (default): High-level information that a typical user needs to see.
Since typical gargle usage is always indirect, i.e. gargle is called by
another package, gargle itself is very quiet. There are very few messages
emitted when <code>gargle_verbosity = "info"</code>.
</p>
</li>
<li><p> &quot;silent&quot;: No messages at all. However, warnings or errors are still thrown
normally.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gargle_oauth_email()
gargle_oob_default()
gargle_oauth_cache()
gargle_oauth_client_type()
gargle_verbosity()
</code></pre>

<hr>
<h2 id='gargle_secret'>Encrypt/decrypt JSON or an R object</h2><span id='topic+gargle_secret'></span><span id='topic+secret_encrypt_json'></span><span id='topic+secret_decrypt_json'></span><span id='topic+secret_make_key'></span><span id='topic+secret_write_rds'></span><span id='topic+secret_read_rds'></span><span id='topic+secret_has_key'></span>

<h3>Description</h3>

<p>These functions help to encrypt and decrypt confidential information that you
might need when deploying gargle-using projects or in CI/CD. They basically
rely on inlined copies of the <a href="https://httr2.r-lib.org/reference/secrets.html">secret functions in the httr2 package</a>. The awkwardness of
inlining code from httr2 can be removed if/when gargle starts to depend on
httr2.
</p>

<ul>
<li><p> The <code>secret_encrypt_json()</code> + <code>secret_decrypt_json()</code> pair is unique to
gargle, given how frequently Google auth relies on JSON files, e.g., service
account tokens and OAuth clients.
</p>
</li>
<li><p> The <code>secret_write_rds()</code> + <code>secret_read_rds()</code> pair is just a copy of
functions from httr2. They are handy if you need to secure a user token.
</p>
</li>
<li> <p><code>secret_make_key()</code> and <code>secret_has_key()</code> are also copies of functions
from httr2. Use <code>secret_make_key</code> to generate a key. Use <code>secret_has_key()</code>
to condition on key availability in, e.g., examples, tests, or apps.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>secret_encrypt_json(json, path = NULL, key)

secret_decrypt_json(path, key)

secret_make_key()

secret_write_rds(x, path, key)

secret_read_rds(path, key)

secret_has_key(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle_secret_+3A_json">json</code></td>
<td>
<p>A JSON file (or string).</p>
</td></tr>
<tr><td><code id="gargle_secret_+3A_path">path</code></td>
<td>
<p>The path to write to (<code>secret_encrypt_json()</code>,
<code>secret_write_rds()</code>) or to read from (<code>secret_decrypt_json()</code>,
<code>secret_read_rds()</code>).</p>
</td></tr>
<tr><td><code id="gargle_secret_+3A_key">key</code></td>
<td>
<p>Encryption key, as implemented by httr2's <a href="https://httr2.r-lib.org/reference/secrets.html">secret functions</a>. This should
almost always be the name of an environment variable whose value was
generated with <code>secret_make_key()</code> (which is an inlined copy of
<code>httr2::secret_make_key()</code>).</p>
</td></tr>
<tr><td><code id="gargle_secret_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>secret_encrypt_json()</code>: The encrypted JSON string, invisibly. In typical
use, this function is mainly called for its side effect, which is to write an
encrypted file.
</p>
</li>
<li> <p><code>secret_decrypt_json()</code>: The decrypted JSON string, invisibly.
</p>
</li>
<li> <p><code>secret_write_rds()</code>: <code>x</code>, invisibly
</p>
</li>
<li> <p><code>secret_read_rds()</code>: the decrypted object.
</p>
</li>
<li> <p><code>secret_make_key()</code>: a random string to use as an encryption key.
</p>
</li>
<li> <p><code>secret_has_key()</code> returns <code>TRUE</code> if the key is available and <code>FALSE</code>
otherwise.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# gargle ships with JSON for a fake service account
# here we put the encrypted JSON into a new file
tmp &lt;- tempfile()
secret_encrypt_json(
  fs::path_package("gargle", "extdata", "fake_service_account.json"),
  tmp,
  key = "GARGLE_KEY"
)

# complete the round trip by providing the decrypted JSON to a credential
# function
credentials_service_account(
 scopes = "https://www.googleapis.com/auth/userinfo.email",
 path = secret_decrypt_json(
   fs::path_package("gargle", "secret", "gargle-testing.json"),
   key = "GARGLE_KEY"
 )
)

file.remove(tmp)

# make an artificial Gargle2.0 token
fauxen &lt;- gargle2.0_token(
  email = "jane@example.org",
  client = gargle_oauth_client(
    id = "CLIENT_ID", secret = "SECRET", name = "CLIENT"
  ),
  credentials = list(token = "fauxen"),
  cache = FALSE
)
fauxen

# store the fake token in an encrypted file
tmp2 &lt;- tempfile()
secret_write_rds(fauxen, path = tmp2, key = "GARGLE_KEY")

# complete the round trip by providing the decrypted token to the "BYO token"
# credential function
rt_fauxen &lt;- credentials_byo_oauth2(
  token  = secret_read_rds(tmp2, key = "GARGLE_KEY")
)
rt_fauxen

file.remove(tmp2)

</code></pre>

<hr>
<h2 id='Gargle-class'>OAuth2 token objects specific to Google APIs</h2><span id='topic+Gargle-class'></span><span id='topic+Gargle2.0'></span>

<h3>Description</h3>

<p><code>Gargle2.0</code> is based on the <code><a href="httr.html#topic+Token-class">Token2.0</a></code> class provided in
httr. The preferred way to create a <code>Gargle2.0</code> token is through the
constructor function <code><a href="#topic+gargle2.0_token">gargle2.0_token()</a></code>. Key differences with <code>Token2.0</code>:
</p>

<ul>
<li><p> The key for a cached <code>Token2.0</code> comes from hashing the endpoint, client,
and scopes. For the <code>Gargle2.0</code> subclass, the identifier or key is expanded
to include the email address associated with the token. This makes it easier
to work with Google APIs with multiple identities.
</p>
</li>
<li> <p><code>Gargle2.0</code> tokens are cached, by default, at the user level, following the
XDG spec for storing user-specific data and cache files. In contrast, the
default location for <code>Token2.0</code> is <code>./.httr-oauth</code>, i.e. in current working
directory. <code>Gargle2.0</code> behaviour makes it easier to reuse tokens across
projects and makes it less likely that tokens are accidentally synced to a
remote location like GitHub or DropBox.
</p>
</li>
<li><p> Each <code>Gargle2.0</code> token is cached in its own file. The token cache is a
directory of such files. In contrast, <code>Token2.0</code> tokens are cached as
components of a list, which is typically serialized to <code>./.httr-oauth</code>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="httr.html#topic+Token">httr::Token</a></code> -&gt; <code><a href="httr.html#topic+Token2.0">httr::Token2.0</a></code> -&gt; <code>Gargle2.0</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>email</code></dt><dd><p>Email associated with the token.</p>
</dd>
<dt><code>package</code></dt><dd><p>Name of the package requesting a token. Used in messages.</p>
</dd>
<dt><code>client</code></dt><dd><p>An OAuth client.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Gargle2.0-new"><code>Gargle2.0$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-format"><code>Gargle2.0$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-print"><code>Gargle2.0$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-hash"><code>Gargle2.0$hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-cache"><code>Gargle2.0$cache()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-load_from_cache"><code>Gargle2.0$load_from_cache()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-refresh"><code>Gargle2.0$refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-init_credentials"><code>Gargle2.0$init_credentials()</code></a>
</p>
</li>
<li> <p><a href="#method-Gargle2.0-clone"><code>Gargle2.0$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="can_refresh"><a href='../../httr/html/Token2.0.html#method-Token2.0-can_refresh'><code>httr::Token2.0$can_refresh()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="revoke"><a href='../../httr/html/Token2.0.html#method-Token2.0-revoke'><code>httr::Token2.0$revoke()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="sign"><a href='../../httr/html/Token2.0.html#method-Token2.0-sign'><code>httr::Token2.0$sign()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="validate"><a href='../../httr/html/Token2.0.html#method-Token2.0-validate'><code>httr::Token2.0$validate()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Gargle2.0-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$new(
  email = gargle_oauth_email(),
  client = gargle_client(),
  package = "gargle",
  credentials = NULL,
  params = list(),
  cache_path = gargle_oauth_cache(),
  app = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>email</code></dt><dd><p>Optional email address. See <code><a href="#topic+gargle2.0_token">gargle2.0_token()</a></code> for full
details.</p>
</dd>
<dt><code>client</code></dt><dd><p>An OAuth consumer application.</p>
</dd>
<dt><code>package</code></dt><dd><p>Name of the package requesting a token. Used in messages.</p>
</dd>
<dt><code>credentials</code></dt><dd><p>Exists largely for testing purposes.</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of parameters for the internal function
<code>init_oauth2.0()</code>, which is a modified version of <code><a href="httr.html#topic+init_oauth2.0">httr::init_oauth2.0()</a></code>.
gargle actively uses <code>scope</code> and <code>use_oob</code>, but does not use <code>user_params</code>,
<code>type</code>, <code>as_header</code> (hard-wired to <code>TRUE</code>), <code>use_basic_auth</code> (accept
default of <code>use_basic_auth = FALSE</code>), <code>config_init</code>, or
<code>client_credentials</code>.</p>
</dd>
<dt><code>cache_path</code></dt><dd><p>Specifies the OAuth token cache. Read more in
<code><a href="#topic+gargle_oauth_cache">gargle_oauth_cache()</a></code>.</p>
</dd>
<dt><code>app</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>client</code> instead.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Gargle2.0 token.
</p>


<hr>
<a id="method-Gargle2.0-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format a Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Gargle2.0-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Gargle2.0-hash"></a>



<h4>Method <code>hash()</code></h4>

<p>Generate the email-augmented hash of a Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$hash()</pre></div>


<hr>
<a id="method-Gargle2.0-cache"></a>



<h4>Method <code>cache()</code></h4>

<p>Put a Gargle2.0 token into the cache
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$cache()</pre></div>


<hr>
<a id="method-Gargle2.0-load_from_cache"></a>



<h4>Method <code>load_from_cache()</code></h4>

<p>(Attempt to) get a Gargle2.0 token from the cache
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$load_from_cache()</pre></div>


<hr>
<a id="method-Gargle2.0-refresh"></a>



<h4>Method <code>refresh()</code></h4>

<p>(Attempt to) refresh a Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$refresh()</pre></div>


<hr>
<a id="method-Gargle2.0-init_credentials"></a>



<h4>Method <code>init_credentials()</code></h4>

<p>Initiate a new Gargle2.0 token
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$init_credentials()</pre></div>


<hr>
<a id="method-Gargle2.0-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gargle2.0$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='gargle-package'>gargle: Utilities for Working with Google APIs</h2><span id='topic+gargle'></span><span id='topic+gargle-package'></span>

<h3>Description</h3>

<p>Provides utilities for working with Google APIs <a href="https://developers.google.com/apis-explorer">https://developers.google.com/apis-explorer</a>. This includes functions and classes for handling common credential types and for preparing, executing, and processing HTTP requests.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jennifer Bryan <a href="mailto:jenny@posit.co">jenny@posit.co</a> (<a href="https://orcid.org/0000-0002-6983-2759">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Craig Citro <a href="mailto:craigcitro@google.com">craigcitro@google.com</a>
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Google Inc [copyright holder]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gargle.r-lib.org">https://gargle.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/gargle">https://github.com/r-lib/gargle</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/gargle/issues">https://github.com/r-lib/gargle/issues</a>
</p>
</li></ul>


<hr>
<h2 id='gargle2.0_token'>Generate a gargle token</h2><span id='topic+gargle2.0_token'></span>

<h3>Description</h3>

<p>Constructor function for objects of class <a href="#topic+Gargle2.0">Gargle2.0</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gargle2.0_token(
  email = gargle_oauth_email(),
  client = gargle_client(),
  package = "gargle",
  scope = NULL,
  use_oob = gargle_oob_default(),
  credentials = NULL,
  cache = if (is.null(credentials)) gargle_oauth_cache() else FALSE,
  ...,
  app = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gargle2.0_token_+3A_email">email</code></td>
<td>
<p>Optional. If specified, <code>email</code> can take several different
forms:
</p>

<ul>
<li> <p><code>"jane@gmail.com"</code>, i.e. an actual email address. This allows the user to
target a specific Google identity. If specified, this is used for token
lookup, i.e. to determine if a suitable token is already available in the
cache. If no such token is found, <code>email</code> is used to pre-select the targeted
Google identity in the OAuth chooser. (Note, however, that the email
associated with a token when it's cached is always determined from the token
itself, never from this argument).
</p>
</li>
<li> <p><code>"*@example.com"</code>, i.e. a domain-only glob pattern. This can be helpful if
you need code that &quot;just works&quot; for both <code>alice@example.com</code> and
<code>bob@example.com</code>.
</p>
</li>
<li> <p><code>TRUE</code> means that you are approving email auto-discovery. If exactly one
matching token is found in the cache, it will be used.
</p>
</li>
<li> <p><code>FALSE</code> or <code>NA</code> mean that you want to ignore the token cache and force a
new OAuth dance in the browser.
</p>
</li></ul>

<p>Defaults to the option named <code>"gargle_oauth_email"</code>, retrieved by
<code><a href="#topic+gargle_oauth_email">gargle_oauth_email()</a></code> (unless a wrapper package implements different
default behavior).</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_client">client</code></td>
<td>
<p>A Google OAuth client, preferably constructed via
<code><a href="#topic+gargle_oauth_client_from_json">gargle_oauth_client_from_json()</a></code>, which returns an instance of
<code>gargle_oauth_client</code>. For backwards compatibility, for a limited time,
gargle will still accept an &quot;OAuth app&quot; created with <code><a href="httr.html#topic+oauth_app">httr::oauth_app()</a></code>.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_package">package</code></td>
<td>
<p>Name of the package requesting a token. Used in messages.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_scope">scope</code></td>
<td>
<p>A character vector of scopes to request.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_use_oob">use_oob</code></td>
<td>
<p>Whether to use out-of-band authentication (or, perhaps, a
variant implemented by gargle and known as &quot;pseudo-OOB&quot;) when first
acquiring the token. Defaults to the value returned by
<code><a href="#topic+gargle_oob_default">gargle_oob_default()</a></code>. Note that (pseudo-)OOB auth only affects
the initial OAuth dance. If we retrieve (and possibly refresh) a
cached token, <code>use_oob</code> has no effect.
</p>
<p>If the OAuth client is provided implicitly by a wrapper package, its type
probably defaults to the value returned by
<code><a href="#topic+gargle_oauth_client_type">gargle_oauth_client_type()</a></code>. You can take control of the client
type by setting <code>options(gargle_oauth_client_type = "web")</code> or
<code>options(gargle_oauth_client_type = "installed")</code>.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_credentials">credentials</code></td>
<td>
<p>Advanced use only: allows you to completely customise
token generation.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_cache">cache</code></td>
<td>
<p>Specifies the OAuth token cache. Defaults to the option named
<code>"gargle_oauth_cache"</code>, retrieved via <code><a href="#topic+gargle_oauth_cache">gargle_oauth_cache()</a></code>.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_...">...</code></td>
<td>
<p>Absorbs arguments intended for use by other credential functions.
Not used.</p>
</td></tr>
<tr><td><code id="gargle2.0_token_+3A_app">app</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Replaced by the <code>client</code>
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+Gargle2.0">Gargle2.0</a>, either new or loaded from the cache.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gargle2.0_token()

## End(Not run)
</code></pre>

<hr>
<h2 id='gce_access_token'>Fetch access token for a service account on GCE</h2><span id='topic+gce_access_token'></span>

<h3>Description</h3>

<p>Fetch access token for a service account on GCE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gce_access_token(
  scopes = "https://www.googleapis.com/auth/cloud-platform",
  service_account = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gce_access_token_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="gce_access_token_+3A_service_account">service_account</code></td>
<td>
<p>Name of the GCE service account to use.</p>
</td></tr>
</table>

<hr>
<h2 id='gce_instance_service_accounts'>List all service accounts available on this GCE instance</h2><span id='topic+gce_instance_service_accounts'></span>

<h3>Description</h3>

<p>List all service accounts available on this GCE instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gce_instance_service_accounts()
</code></pre>


<h3>Value</h3>

<p>A data frame, where each row is a service account. Due to aliasing,
there is no guarantee that each row represents a distinct service account.
</p>


<h3>See Also</h3>

<p>The return value is built from a recursive query of the so-called
&quot;directory&quot; of the instance's service accounts as documented in
<a href="https://cloud.google.com/compute/docs/metadata/default-metadata-values#vm_instance_metadata">https://cloud.google.com/compute/docs/metadata/default-metadata-values#vm_instance_metadata</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
credentials_gce()

</code></pre>

<hr>
<h2 id='GceToken'>Token for use on Google Compute Engine instances</h2><span id='topic+GceToken'></span>

<h3>Description</h3>

<p>Token for use on Google Compute Engine instances
</p>
<p>Token for use on Google Compute Engine instances
</p>


<h3>Details</h3>

<p>This class uses the metadata service available on GCE VMs to fetch access
tokens. Not intended for direct use. See <code><a href="#topic+credentials_gce">credentials_gce()</a></code> instead.
</p>


<h3>Super classes</h3>

<p><code><a href="httr.html#topic+Token">httr::Token</a></code> -&gt; <code><a href="httr.html#topic+Token2.0">httr::Token2.0</a></code> -&gt; <code>GceToken</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GceToken-new"><code>GceToken$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-init_credentials"><code>GceToken$init_credentials()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-refresh"><code>GceToken$refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-can_refresh"><code>GceToken$can_refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-format"><code>GceToken$format()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-print"><code>GceToken$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-cache"><code>GceToken$cache()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-load_from_cache"><code>GceToken$load_from_cache()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-revoke"><code>GceToken$revoke()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-validate"><code>GceToken$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-GceToken-clone"><code>GceToken$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token" data-id="hash"><a href='../../httr/html/Token.html#method-Token-hash'><code>httr::Token$hash()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="sign"><a href='../../httr/html/Token2.0.html#method-Token2.0-sign'><code>httr::Token2.0$sign()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GceToken-new"></a>



<h4>Method <code>new()</code></h4>

<p>Get an access for a GCE service account.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$new(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>A list of parameters for <code>fetch_gce_access_token()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A GceToken.
</p>


<hr>
<a id="method-GceToken-init_credentials"></a>



<h4>Method <code>init_credentials()</code></h4>

<p>Request an access token.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$init_credentials()</pre></div>


<hr>
<a id="method-GceToken-refresh"></a>



<h4>Method <code>refresh()</code></h4>

<p>Refreshes the token. In this case, that just means &quot;ask again
for an access token&quot;.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$refresh()</pre></div>


<hr>
<a id="method-GceToken-can_refresh"></a>



<h4>Method <code>can_refresh()</code></h4>

<p>Placeholder implementation of required method. Returns <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$can_refresh()</pre></div>


<hr>
<a id="method-GceToken-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format a <code><a href="#topic+GceToken">GceToken()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GceToken-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a <code><a href="#topic+GceToken">GceToken()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GceToken-cache"></a>



<h4>Method <code>cache()</code></h4>

<p>Placeholder implementation of required method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$cache()</pre></div>


<hr>
<a id="method-GceToken-load_from_cache"></a>



<h4>Method <code>load_from_cache()</code></h4>

<p>Placeholder implementation of required method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$load_from_cache()</pre></div>


<hr>
<a id="method-GceToken-revoke"></a>



<h4>Method <code>revoke()</code></h4>

<p>Placeholder implementation of required method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$revoke()</pre></div>


<hr>
<a id="method-GceToken-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Placeholder implementation of required method
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$validate()</pre></div>


<hr>
<a id="method-GceToken-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GceToken$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='init_AuthState'>Create an AuthState</h2><span id='topic+init_AuthState'></span>

<h3>Description</h3>

<p>Constructor function for objects of class <a href="#topic+AuthState">AuthState</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_AuthState(
  package = NA_character_,
  client = NULL,
  api_key = NULL,
  auth_active = TRUE,
  cred = NULL,
  app = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_AuthState_+3A_package">package</code></td>
<td>
<p>Package name, an optional string. It is recommended to record
the name of the package whose auth state is being managed. Ultimately, this
may be used in some downstream messaging.</p>
</td></tr>
<tr><td><code id="init_AuthState_+3A_client">client</code></td>
<td>
<p>A Google OAuth client, preferably constructed via
<code><a href="#topic+gargle_oauth_client_from_json">gargle_oauth_client_from_json()</a></code>, which returns an instance of
<code>gargle_oauth_client</code>. For backwards compatibility, for a limited time,
gargle will still accept an &quot;OAuth app&quot; created with <code><a href="httr.html#topic+oauth_app">httr::oauth_app()</a></code>.</p>
</td></tr>
<tr><td><code id="init_AuthState_+3A_api_key">api_key</code></td>
<td>
<p>Optional. API key (a string). Some APIs accept unauthorized,
&quot;token-free&quot; requests for public resources, but only if the request
includes an API key.</p>
</td></tr>
<tr><td><code id="init_AuthState_+3A_auth_active">auth_active</code></td>
<td>
<p>Logical. <code>TRUE</code> means requests should include a token (and
probably not an API key). <code>FALSE</code> means requests should include an API key
(and probably not a token).</p>
</td></tr>
<tr><td><code id="init_AuthState_+3A_cred">cred</code></td>
<td>
<p>Credentials. Typically populated indirectly via <code><a href="#topic+token_fetch">token_fetch()</a></code>.</p>
</td></tr>
<tr><td><code id="init_AuthState_+3A_app">app</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Replaced by the <code>client</code>
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+AuthState">AuthState</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_client &lt;- gargle_oauth_client(
  id = "some_long_client_id",
  secret = "ssshhhhh_its_a_secret",
  name = "my-nifty-oauth-client"
)

init_AuthState(
  package = "my_package",
  client = my_client,
  api_key = "api_key_api_key_api_key",
)
</code></pre>

<hr>
<h2 id='internal-assets'>Assets for internal use</h2><span id='topic+internal-assets'></span><span id='topic+tidyverse_api_key'></span><span id='topic+tidyverse_client'></span><span id='topic+tidyverse_app'></span>

<h3>Description</h3>

<p>Assets for use inside specific packages maintained by the tidyverse team.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyverse_api_key()

tidyverse_client(type = NULL)

tidyverse_app()
</code></pre>

<hr>
<h2 id='oauth_app_from_json'>Create an OAuth app from JSON</h2><span id='topic+oauth_app_from_json'></span><span id='topic+gargle_app'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>oauth_app_from_json()</code> is being replaced with
<code><a href="#topic+gargle_oauth_client_from_json">gargle_oauth_client_from_json()</a></code>, in light of the new
<code>gargle_oauth_client</code> class. Now <code>oauth_app_from_json()</code> potentially warns
about this deprecation and immediately passes its inputs through to
<code><a href="#topic+gargle_oauth_client_from_json">gargle_oauth_client_from_json()</a></code>.
</p>
<p><code>gargle_app()</code> is being replaced with <code><a href="#topic+gargle_client">gargle_client()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_app_from_json(path, appname = NULL)

gargle_app()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_app_from_json_+3A_path">path</code></td>
<td>
<p>JSON downloaded from <a href="https://console.cloud.google.com">Google Cloud Console</a>, containing a client id and
secret, in one of the forms supported for the <code>txt</code> argument of
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (typically, a file path or JSON string).</p>
</td></tr>
<tr><td><code id="oauth_app_from_json_+3A_appname">appname</code></td>
<td>
<p>name of the application.  This is not used for OAuth, but is
used to make it easier to identify different applications.</p>
</td></tr>
</table>

<hr>
<h2 id='oauth_external_token'>Generate OAuth token for an external account</h2><span id='topic+oauth_external_token'></span>

<h3>Description</h3>

<p>Generate OAuth token for an external account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_external_token(
  path = "",
  scopes = "https://www.googleapis.com/auth/cloud-platform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth_external_token_+3A_path">path</code></td>
<td>
<p>JSON containing the workload identity configuration for the
external account, in one of the forms supported for the <code>txt</code> argument of
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> (probably, a file path, although it could be a JSON
string). The instructions for generating this configuration are given at
<a href="https://cloud.google.com/iam/docs/configuring-workload-identity-federation">Configuring workload identity federation</a>.
</p>
<p>Note that external account tokens are a natural fit for use as Application
Default Credentials, so consider storing the configuration file in one of
the standard locations consulted for ADC, instead of providing <code>path</code>
explicitly. See <code><a href="#topic+credentials_app_default">credentials_app_default()</a></code> for more.</p>
</td></tr>
<tr><td><code id="oauth_external_token_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
</table>

<hr>
<h2 id='request_develop'>Build a Google API request</h2><span id='topic+request_develop'></span><span id='topic+request_build'></span>

<h3>Description</h3>

<p>Intended primarily for internal use in client packages that provide
high-level wrappers for users. The <code>vignette("request-helper-functions")</code>
describes how one might use these functions inside a wrapper package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_develop(
  endpoint,
  params = list(),
  base_url = "https://www.googleapis.com"
)

request_build(
  method = "GET",
  path = "",
  params = list(),
  body = list(),
  token = NULL,
  key = NULL,
  base_url = "https://www.googleapis.com"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_develop_+3A_endpoint">endpoint</code></td>
<td>
<p>List of information about the target endpoint or, in
Google's vocabulary, the target &quot;method&quot;. Presumably prepared from the
<a href="https://developers.google.com/discovery/v1/getting_started#background-resources">Discovery Document</a>
for the target API.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_params">params</code></td>
<td>
<p>Named list. Values destined for URL substitution, the query,
or, for <code>request_develop()</code> only, the body. For <code>request_build()</code>, body
parameters must be passed via the <code>body</code> argument.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_base_url">base_url</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_method">method</code></td>
<td>
<p>Character. An HTTP verb, such as <code>GET</code> or <code>POST</code>.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_path">path</code></td>
<td>
<p>Character. Path to the resource, not including the API's
<code>base_url</code>. Examples: <code>drive/v3/about</code> or <code>drive/v3/files/{fileId}</code>. The
<code>path</code> can be a template, i.e. it can include variables inside curly
brackets, such as <code>{fileId}</code> in the example. Such variables are substituted
by <code>request_build()</code>, using named parameters found in <code>params</code>.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_body">body</code></td>
<td>
<p>List. Values to send in the API request body.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_token">token</code></td>
<td>
<p>Token, ready for inclusion in a request, i.e. prepared with
<code><a href="httr.html#topic+config">httr::config()</a></code>.</p>
</td></tr>
<tr><td><code id="request_develop_+3A_key">key</code></td>
<td>
<p>API key. Needed for requests that don't contain a token. For more,
see Google's document Credentials, access, security, and identity
(<code style="white-space: pre;">&#8288;https://support.google.com/googleapi/answer/6158857?hl=en&amp;ref_topic=7013279&#8288;</code>).
A key can be passed as a named component of <code>params</code>, but note that the
formal argument <code>key</code> will clobber it, if non-<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>request_develop()</code>: <code>list()</code> with components <code>method</code>, <code>path</code>, <code>params</code>,
<code>body</code>, and <code>base_url</code>.
</p>
<p><code>request_build()</code>: <code>list()</code> with components <code>method</code>, <code>path</code>
(post-substitution), <code>query</code> (the input <code>params</code> not used in URL
substitution), <code>body</code>, <code>token</code>, <code>url</code> (the full URL, post-substitution,
including the query).
</p>


<h3><code>request_develop()</code></h3>

<p>Combines user input (<code>params</code>) with information about an API endpoint.
<code>endpoint</code> should contain these components:
</p>

<ul>
<li> <p><code>path</code>: See documentation for argument.
</p>
</li>
<li> <p><code>method</code>: See documentation for argument.
</p>
</li>
<li> <p><code>parameters</code>: Compared with <code>params</code> supplied by user. An error is
thrown if user-supplied <code>params</code> aren't named in
<code>endpoint$parameters</code> or if user fails to supply all required
parameters. In the return value, body parameters are separated from
those destined for path substitution or the query.
</p>
</li></ul>

<p>The return value is typically used as input to <code>request_build()</code>.
</p>


<h3><code>request_build()</code></h3>

<p>Builds a request, in a purely mechanical sense. This function does nothing
specific to any particular Google API or endpoint.
</p>

<ul>
<li><p> Use with the output of <code>request_develop()</code> or with hand-crafted input.
</p>
</li>
<li> <p><code>params</code> are used for variable substitution in <code>path</code>. Leftover <code>params</code>
that are not bound by the <code>path</code> template automatically become HTTP
query parameters.
</p>
</li>
<li><p> Adds an API key to the query iff <code>token = NULL</code> and removes the API key
otherwise. Client packages should generally pass their own API key in, but
note that <code><a href="#topic+gargle_api_key">gargle_api_key()</a></code> is available for small-scale experimentation.
</p>
</li></ul>

<p>See <code>googledrive::generate_request()</code> for an example of usage in a client
package. googledrive has an internal list of selected endpoints, derived from
the Drive API Discovery Document
(<code style="white-space: pre;">&#8288;https://www.googleapis.com/discovery/v1/apis/drive/v3/rest&#8288;</code>),
exposed via <code>googledrive::drive_endpoints()</code>. An element from such a list is
the expected input for <code>endpoint</code>. <code>googledrive::generate_request()</code> is a
wrapper around <code>request_develop()</code> and <code>request_build()</code> that inserts a
googledrive-managed API key and some logic about Team Drives. All user-facing
functions use <code>googledrive::generate_request()</code> under the hood.
</p>


<h3>See Also</h3>

<p>Other requests and responses: 
<code><a href="#topic+request_make">request_make</a>()</code>,
<code><a href="#topic+response_process">response_process</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example with a prepared endpoint
ept &lt;- googledrive::drive_endpoints("drive.files.update")[[1]]
req &lt;- request_develop(
  ept,
  params = list(
    fileId = "abc",
    addParents = "123",
    description = "Exciting File"
  )
)
req

req &lt;- request_build(
  method = req$method,
  path = req$path,
  params = req$params,
  body = req$body,
  token = "PRETEND_I_AM_A_TOKEN"
)
req

## Example with no previous knowledge of the endpoint
## List a file's comments
## https://developers.google.com/drive/v3/reference/comments/list
req &lt;- request_build(
  method = "GET",
  path = "drive/v3/files/{fileId}/comments",
  params = list(
    fileId = "your-file-id-goes-here",
    fields = "*"
  ),
  token = "PRETEND_I_AM_A_TOKEN"
)
req

# Example with no previous knowledge of the endpoint and no token
# use an API key for which the Places API is enabled!
API_KEY &lt;- "1234567890"

# get restaurants close to a location in Vancouver, BC
req &lt;- request_build(
  method = "GET",
  path = "maps/api/place/nearbysearch/json",
  params = list(
    location = "49.268682,-123.167117",
    radius = 100,
    type = "restaurant"
  ),
  key = API_KEY,
  base_url = "https://maps.googleapis.com"
)
resp &lt;- request_make(req)
out &lt;- response_process(resp)
vapply(out$results, function(x) x$name, character(1))

## End(Not run)
</code></pre>

<hr>
<h2 id='request_make'>Make a Google API request</h2><span id='topic+request_make'></span>

<h3>Description</h3>

<p>Intended primarily for internal use in client packages that provide
high-level wrappers for users. <code>request_make()</code> does relatively little:
</p>

<ul>
<li><p> Calls an HTTP method.
</p>
</li>
<li><p> Adds a user agent.
</p>
</li>
<li><p> Enforces <code>"json"</code> as the default for <code>encode</code>. This differs from httr's
default behaviour, but aligns better with Google APIs.
</p>
</li></ul>

<p>Typically the input is created with <code><a href="#topic+request_build">request_build()</a></code> and the output is
processed with <code><a href="#topic+response_process">response_process()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_make(x, ..., encode = "json", user_agent = gargle_user_agent())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_make_+3A_x">x</code></td>
<td>
<p>List. Holds the components for an HTTP request, presumably created
with <code><a href="#topic+request_develop">request_develop()</a></code> or <code><a href="#topic+request_build">request_build()</a></code>. Must contain a <code>method</code> and
<code>url</code>. If present, <code>body</code> and <code>token</code> are used.</p>
</td></tr>
<tr><td><code id="request_make_+3A_...">...</code></td>
<td>
<p>Optional arguments passed through to the HTTP method. Currently
neither gargle nor httr checks that all are used, so be aware that unused
arguments may be silently ignored.</p>
</td></tr>
<tr><td><code id="request_make_+3A_encode">encode</code></td>
<td>
<p>If the body is a named list, how should it be encoded? Can be
one of form (application/x-www-form-urlencoded), multipart,
(multipart/form-data), or json (application/json).
</p>
<p>For &quot;multipart&quot;, list elements can be strings or objects created by
<code><a href="httr.html#topic+upload_file">upload_file()</a></code>. For &quot;form&quot;, elements are coerced to strings
and escaped, use <code>I()</code> to prevent double-escaping. For &quot;json&quot;,
parameters are automatically &quot;unboxed&quot; (i.e. length 1 vectors are
converted to scalars). To preserve a length 1 vector as a vector,
wrap in <code>I()</code>. For &quot;raw&quot;, either a character or raw vector. You'll
need to make sure to set the <code><a href="httr.html#topic+content_type">content_type()</a></code> yourself.</p>
</td></tr>
<tr><td><code id="request_make_+3A_user_agent">user_agent</code></td>
<td>
<p>A user agent string, prepared by <code><a href="httr.html#topic+user_agent">httr::user_agent()</a></code>. When
in doubt, a client package should have an internal function that extends
<code>gargle_user_agent()</code> by prepending its return value with the client
package's name and version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>response</code> from <a href="httr.html#topic+httr">httr</a>.
</p>


<h3>See Also</h3>

<p>Other requests and responses: 
<code><a href="#topic+request_develop">request_develop</a>()</code>,
<code><a href="#topic+response_process">response_process</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
req &lt;- gargle::request_build(
  method = "GET",
  path = "path/to/the/resource",
  token = "PRETEND_I_AM_TOKEN"
)
gargle::request_make(req)

## End(Not run)
</code></pre>

<hr>
<h2 id='request_retry'>Make a Google API request, repeatedly</h2><span id='topic+request_retry'></span>

<h3>Description</h3>

<p>Intended primarily for internal use in client packages that provide
high-level wrappers for users. It is a drop-in substitute for
<code><a href="#topic+request_make">request_make()</a></code> that also has the ability to retry the request. Codes that
are considered retryable: 408, 429, 500, 502, 503.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_retry(..., max_tries_total = 5, max_total_wait_time_in_seconds = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_retry_+3A_...">...</code></td>
<td>
<p>Passed along to <code><a href="#topic+request_make">request_make()</a></code>.</p>
</td></tr>
<tr><td><code id="request_retry_+3A_max_tries_total">max_tries_total</code></td>
<td>
<p>Maximum number of tries.</p>
</td></tr>
<tr><td><code id="request_retry_+3A_max_total_wait_time_in_seconds">max_total_wait_time_in_seconds</code></td>
<td>
<p>Total seconds we are willing to
dedicate to waiting, summed across all tries. This is a technical upper
bound and actual cumulative waiting will be less.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider an example where we are willing to make a request up to 5 times.
</p>
<div class="sourceCode"><pre>try  1  2    3        4                5
     |--|----|--------|----------------|
wait  1   2      3           4
</pre></div>
<p>There will be up to 5 - 1 = 4 waits and we generally want the waiting period
to get longer, in an exponential way. Such schemes are called exponential
backoff. <code>request_retry()</code> implements exponential backoff with &quot;full jitter&quot;,
where each waiting time is generated from a uniform distribution, where the
interval of support grows exponentially. A common alternative is &quot;equal
jitter&quot;, which adds some noise to fixed, exponentially increasing waiting
times.
</p>
<p>Either way our waiting times are based on a geometric series, which, by
convention, is usually written in terms of powers of 2:
</p>
<div class="sourceCode"><pre>b, 2b, 4b, 8b, ...
  = b * 2^0, b * 2^1, b * 2^2, b * 2^3, ...
</pre></div>
<p>The terms in this series require knowledge of <code>b</code>, the so-called exponential
base, and many retry functions and libraries require the user to specify
this. But most users find it easier to declare the total amount of waiting
time they can tolerate for one request. Therefore <code>request_retry()</code> asks for
that instead and solves for <code>b</code> internally. This is inspired by the Opnieuw
Python library for retries. Opnieuw's interface is designed to eliminate
uncertainty around:
</p>

<ul>
<li><p> Units: Is this thing given in seconds? minutes? milliseconds?
</p>
</li>
<li><p> Ambiguity around how things are counted: Are we starting at 0 or 1?
Are we counting tries or just the retries?
</p>
</li>
<li><p> Non-intuitive required inputs, e.g., the exponential base.
</p>
</li></ul>

<p>Let <em>n</em> be the total number of tries we're willing to make (the argument
<code>max_tries_total</code>) and let <em>W</em> be the total amount of seconds we're willing
to dedicate to making and retrying this request (the argument
<code>max_total_wait_time_in_seconds</code>). Here's how we determine <em>b</em>:
</p>
<div class="sourceCode"><pre>sum_{i=0}^(n - 1) b * 2^i = W
b * sum_{i=0}^(n - 1) 2^i = W
       b * ( (2 ^ n) - 1) = W
                        b = W / ( (2 ^ n) - 1)
</pre></div>


<h3>Value</h3>

<p>Object of class <code>response</code> from <a href="httr.html#topic+httr">httr</a>.
</p>


<h3>Special cases</h3>

<p><code>request_retry()</code> departs from exponential backoff in three special cases:
</p>

<ul>
<li><p> It actually implements <em>truncated</em> exponential backoff. There is a floor
and a ceiling on random wait times.
</p>
</li>
<li> <p><code>Retry-After</code> header: If the response has a header named <code>Retry-After</code>
(case-insensitive), it is assumed to provide a non-negative integer
indicating the number of seconds to wait. If present, we wait this many
seconds and do not generate a random waiting time. (In theory, this header
can alternatively provide a datetime after which to retry, but we have no
first-hand experience with this variant for a Google API.)
</p>
</li>
<li><p> Sheets API quota exhaustion: In the course of googlesheets4 development,
we've grown very familiar with the <code style="white-space: pre;">&#8288;429 RESOURCE_EXHAUSTED&#8288;</code> error. As of
2023-04-15, the Sheets API v4 has a limit of 300 requests per minute per
project and 60 requests per minute per user per project. Limits for reads
and writes are tracked separately. In our experience, the &quot;60 (read or
write) requests per minute per user&quot; limit is the one you hit most often.
If we detect this specific failure, the first wait time is a bit more than
one minute, then we revert to exponential backoff.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/">https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</a>
</p>
</li>
<li> <p><a href="https://tech.channable.com/posts/2020-02-05-opnieuw.html">https://tech.channable.com/posts/2020-02-05-opnieuw.html</a>
</p>
</li>
<li> <p><a href="https://github.com/channable/opnieuw">https://github.com/channable/opnieuw</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/storage/docs/retry-strategy">https://cloud.google.com/storage/docs/retry-strategy</a>
</p>
</li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc7231#section-7.1.3">https://www.rfc-editor.org/rfc/rfc7231#section-7.1.3</a>
</p>
</li>
<li> <p><a href="https://developers.google.com/sheets/api/limits">https://developers.google.com/sheets/api/limits</a>
</p>
</li>
<li> <p><a href="https://googleapis.dev/python/google-api-core/latest/retry.html">https://googleapis.dev/python/google-api-core/latest/retry.html</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
req &lt;- gargle::request_build(
  method = "GET",
  path = "path/to/the/resource",
  token = "PRETEND_I_AM_TOKEN"
)
gargle::request_retry(req)

## End(Not run)
</code></pre>

<hr>
<h2 id='response_process'>Process a Google API response</h2><span id='topic+response_process'></span><span id='topic+response_as_json'></span><span id='topic+gargle_error_message'></span>

<h3>Description</h3>

<p><code>response_process()</code> is intended primarily for internal use in client
packages that provide high-level wrappers for users. Typically applied as the
final step in this sequence of calls:
</p>

<ul>
<li><p> Request prepared with <code><a href="#topic+request_build">request_build()</a></code>.
</p>
</li>
<li><p> Request made with <code><a href="#topic+request_make">request_make()</a></code>.
</p>
</li>
<li><p> Response processed with <code>response_process()</code>.
</p>
</li></ul>

<p>All that's needed for a successful request is to parse the JSON extracted via
<code>httr::content()</code>. Therefore, the main point of <code>response_process()</code> is to
handle less happy outcomes:
</p>

<ul>
<li><p> Status codes in the 400s (client error) and 500s (server error). The
structure of the error payload varies across Google APIs and we try to
create a useful message for all variants we know about.
</p>
</li>
<li><p> Non-JSON content type, such as HTML.
</p>
</li>
<li><p> Status code in the 100s (information) or 300s (redirection). These are
unexpected.
</p>
</li></ul>

<p>If <code>process_response()</code> results in an error, a redacted version of the <code>resp</code>
input is returned in the condition (auth tokens are removed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_process(
  resp,
  error_message = gargle_error_message,
  remember = TRUE,
  call = caller_env()
)

response_as_json(resp, call = caller_env())

gargle_error_message(resp, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_process_+3A_resp">resp</code></td>
<td>
<p>Object of class <code>response</code> from <a href="httr.html#topic+httr">httr</a>.</p>
</td></tr>
<tr><td><code id="response_process_+3A_error_message">error_message</code></td>
<td>
<p>Function that produces an informative error message from
the primary input, <code>resp</code>. It must return a character vector.</p>
</td></tr>
<tr><td><code id="response_process_+3A_remember">remember</code></td>
<td>
<p>Whether to remember the most recently processed response.</p>
</td></tr>
<tr><td><code id="response_process_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>remember = TRUE</code> (the default), gargle stores the most recently seen
response internally, for <em>post hoc</em> examination. The stored response is
literally just the most recent <code>resp</code> input, but with auth tokens redacted.
It can be accessed via the unexported function
<code>gargle:::gargle_last_response()</code>. A companion function
<code>gargle:::gargle_last_content()</code> returns the content of the last response,
which is probably the most useful form for <em>post mortem</em> analysis.
</p>
<p>The <code>response_as_json()</code> helper is exported only as an aid to maintainers who
wish to use their own <code>error_message</code> function, instead of gargle's built-in
<code>gargle_error_message()</code>. When implementing a custom <code>error_message</code>
function, call <code>response_as_json()</code> immediately on the input in order to
inherit gargle's handling of non-JSON input.
</p>


<h3>Value</h3>

<p>The content of the request, as a list. An HTTP status code of 204 (No
content) is a special case returning <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other requests and responses: 
<code><a href="#topic+request_develop">request_develop</a>()</code>,
<code><a href="#topic+request_make">request_make</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get an OAuth2 token with 'userinfo.email' scope
token &lt;- token_fetch(scopes = "https://www.googleapis.com/auth/userinfo.email")

# see the email associated with this token
req &lt;- gargle::request_build(
  method = "GET",
  path = "v1/userinfo",
  token = token,
  base_url = "https://openidconnect.googleapis.com"
)
resp &lt;- gargle::request_make(req)
response_process(resp)

# make a bad request (this token has incorrect scope)
req &lt;- gargle::request_build(
  method = "GET",
  path = "fitness/v1/users/{userId}/dataSources",
  token = token,
  params = list(userId = 12345)
)
resp &lt;- gargle::request_make(req)
response_process(resp)

## End(Not run)
</code></pre>

<hr>
<h2 id='token_fetch'>Fetch a token for the given scopes</h2><span id='topic+token_fetch'></span>

<h3>Description</h3>

<p>This is a rather magical function that calls a series of concrete
credential-fetching functions, each wrapped in a <code>tryCatch()</code>.
<code>token_fetch()</code> keeps trying until it succeeds or there are no more functions
to try. See the <code>vignette("how-gargle-gets-tokens")</code> for a full description
of <code>token_fetch()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>token_fetch(scopes = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="token_fetch_+3A_scopes">scopes</code></td>
<td>
<p>A character vector of scopes to request. Pick from those listed
at <a href="https://developers.google.com/identity/protocols/oauth2/scopes">https://developers.google.com/identity/protocols/oauth2/scopes</a>.
</p>
<p>For certain token flows, the
<code>"https://www.googleapis.com/auth/userinfo.email"</code> scope is unconditionally
included. This grants permission to retrieve the email address associated
with a token; gargle uses this to index cached OAuth tokens. This grants no
permission to view or send email and is generally considered a low-value
scope.</p>
</td></tr>
<tr><td><code id="token_fetch_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all credential functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="httr.html#topic+Token-class">httr::Token</a></code> (often an instance of something
that inherits from <code>httr::Token</code>) or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cred_funs_list">cred_funs_list()</a></code> reveals the current registry of
credential-fetching functions, in order.
</p>
<p>Other credential functions: 
<code><a href="#topic+credentials_app_default">credentials_app_default</a>()</code>,
<code><a href="#topic+credentials_byo_oauth2">credentials_byo_oauth2</a>()</code>,
<code><a href="#topic+credentials_external_account">credentials_external_account</a>()</code>,
<code><a href="#topic+credentials_gce">credentials_gce</a>()</code>,
<code><a href="#topic+credentials_service_account">credentials_service_account</a>()</code>,
<code><a href="#topic+credentials_user_oauth2">credentials_user_oauth2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
token_fetch(scopes = "https://www.googleapis.com/auth/userinfo.email")

## End(Not run)
</code></pre>

<hr>
<h2 id='token-info'>Get info from a token</h2><span id='topic+token-info'></span><span id='topic+token_userinfo'></span><span id='topic+token_email'></span><span id='topic+token_tokeninfo'></span>

<h3>Description</h3>

<p>These functions send the <code>token</code> to Google endpoints that return info about a
token or a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>token_userinfo(token)

token_email(token)

token_tokeninfo(token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="token-info_+3A_token">token</code></td>
<td>
<p>A token with class <a href="httr.html#topic+Token-class">Token2.0</a> or an object of
httr's class <code>request</code>, i.e. a token that has been prepared with
<code><a href="httr.html#topic+config">httr::config()</a></code> and has a <a href="httr.html#topic+Token-class">Token2.0</a> in the
<code>auth_token</code> component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's hard to say exactly what info will be returned by the &quot;userinfo&quot;
endpoint targetted by <code>token_userinfo()</code>. It depends on the token's scopes.
Where possible, OAuth2 tokens obtained via the gargle package include the
<code style="white-space: pre;">&#8288;https://www.googleapis.com/auth/userinfo.email&#8288;</code> scope, which guarantees we
can learn the email associated with the token. If the token has the
<code style="white-space: pre;">&#8288;https://www.googleapis.com/auth/userinfo.profile&#8288;</code> scope, there will be even
more information available. But for a token with unknown or arbitrary scopes,
we can't make any promises about what information will be returned.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>token_userinfo()</code>: user info
</p>
</li>
<li> <p><code>token_email()</code>: user's email (obtained from a call to <code>token_userinfo()</code>)
</p>
</li>
<li> <p><code>token_tokeninfo()</code>: token info
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# with service account token
t &lt;- token_fetch(
  scopes = "https://www.googleapis.com/auth/drive",
  path   = "path/to/service/account/token/blah-blah-blah.json"
)
# or with an OAuth token
t &lt;- token_fetch(
  scopes = "https://www.googleapis.com/auth/drive",
  email  = "janedoe@example.com"
)
token_userinfo(t)
token_email(t)
tokens_tokeninfo(t)

## End(Not run)
</code></pre>

<hr>
<h2 id='WifToken'>Token for use with workload identity federation</h2><span id='topic+WifToken'></span>

<h3>Description</h3>

<p>Token for use with workload identity federation
</p>
<p>Token for use with workload identity federation
</p>


<h3>Details</h3>

<p>Not intended for direct use. See <code><a href="#topic+credentials_external_account">credentials_external_account()</a></code> instead.
</p>


<h3>Super classes</h3>

<p><code><a href="httr.html#topic+Token">httr::Token</a></code> -&gt; <code><a href="httr.html#topic+Token2.0">httr::Token2.0</a></code> -&gt; <code>WifToken</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WifToken-new"><code>WifToken$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-init_credentials"><code>WifToken$init_credentials()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-refresh"><code>WifToken$refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-format"><code>WifToken$format()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-print"><code>WifToken$print()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-can_refresh"><code>WifToken$can_refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-cache"><code>WifToken$cache()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-load_from_cache"><code>WifToken$load_from_cache()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-validate"><code>WifToken$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-revoke"><code>WifToken$revoke()</code></a>
</p>
</li>
<li> <p><a href="#method-WifToken-clone"><code>WifToken$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token" data-id="hash"><a href='../../httr/html/Token.html#method-Token-hash'><code>httr::Token$hash()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httr" data-topic="Token2.0" data-id="sign"><a href='../../httr/html/Token2.0.html#method-Token2.0-sign'><code>httr::Token2.0$sign()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-WifToken-new"></a>



<h4>Method <code>new()</code></h4>

<p>Get a token via workload identity federation
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$new(params = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>A list of parameters for <code>init_oauth_external_account()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A WifToken.
</p>


<hr>
<a id="method-WifToken-init_credentials"></a>



<h4>Method <code>init_credentials()</code></h4>

<p>Enact the actual token exchange for workload identity
federation.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$init_credentials()</pre></div>


<hr>
<a id="method-WifToken-refresh"></a>



<h4>Method <code>refresh()</code></h4>

<p>Refreshes the token, which means re-doing the entire token
flow in this case.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$refresh()</pre></div>


<hr>
<a id="method-WifToken-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format a <code><a href="#topic+WifToken">WifToken()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WifToken-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a <code><a href="#topic+WifToken">WifToken()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WifToken-can_refresh"></a>



<h4>Method <code>can_refresh()</code></h4>

<p>Placeholder implementation of required method. Returns <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$can_refresh()</pre></div>


<hr>
<a id="method-WifToken-cache"></a>



<h4>Method <code>cache()</code></h4>

<p>Placeholder implementation of required method. Returns self.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$cache()</pre></div>


<hr>
<a id="method-WifToken-load_from_cache"></a>



<h4>Method <code>load_from_cache()</code></h4>

<p>Placeholder implementation of required method. Returns self.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$load_from_cache()</pre></div>


<hr>
<a id="method-WifToken-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Placeholder implementation of required method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$validate()</pre></div>


<hr>
<a id="method-WifToken-revoke"></a>



<h4>Method <code>revoke()</code></h4>

<p>Placeholder implementation of required method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$revoke()</pre></div>


<hr>
<a id="method-WifToken-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WifToken$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
