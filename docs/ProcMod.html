<!DOCTYPE html><html><head><title>Help for package ProcMod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ProcMod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.getPermuteMatrix'><p>Generate permutation matrix according to a schema.</p></a></li>
<li><a href='#.procmod_coerce_value'><p>Internal function coercing the data to a matrix.</p></a></li>
<li><a href='#.rep_matrix'><p>Internal function repeating a matrix.</p></a></li>
<li><a href='#.Trace'><p>Compute the trace of a square matrix.</p></a></li>
<li><a href='#as_procmod_frame'><p>Coerce to a ProcMod Frame.</p></a></li>
<li><a href='#as.data.frame.dist'><p>Converts a <code>dist</code> object to a <code>data.frame</code> object.</p></a></li>
<li><a href='#bicenter'><p>Double centering of a matrix.</p></a></li>
<li><a href='#corls_test'><p>Monte-Carlo Test on the sum of the singular values of a procustean rotation.</p></a></li>
<li><a href='#dim.procmod_frame'><p>Dimensions of a ProcMod Frame.</p></a></li>
<li><a href='#eukaryotes'><p>DNA metabarcoding Australia South-North Gradient</p></a></li>
<li><a href='#is_euclid'><p>Test if the distance matrix is euclidean.</p></a></li>
<li><a href='#is_procmod_frame'><p>Check if an object is a ProcMod Frame.</p></a></li>
<li><a href='#names.procmod_corls'><p>The Names of the elements of a Correlation Matrix</p></a></li>
<li><a href='#names.procmod_varls'><p>The Names of the elements of a Variance / Covariance Matrix.</p></a></li>
<li><a href='#nmds'><p>Project a distance matrix in a euclidean space (NMDS).</p></a></li>
<li><a href='#ortho'><p>Project a dataset in a euclidean space.</p></a></li>
<li><a href='#pca'><p>Project a set of points in a euclidean space (PCA).</p></a></li>
<li><a href='#pcoa'><p>Project a distance matrix in a euclidean space (PCOA).</p></a></li>
<li><a href='#print.procmod_corls'><p>Print a procrustean Correlation Matrix.</p></a></li>
<li><a href='#print.procmod_varls'><p>Print procrustean Variance / Covariance Matrix.</p></a></li>
<li><a href='#procmod'><p>Informative Procrustean Matrix Correlation</p></a></li>
<li><a href='#procmod_frame'><p>The procmod_frame data structure.</p></a></li>
<li><a href='#protate'><p>Rotate the <code>src</code> matrix to fit into the space of the <code>dest</code> matrix.</p></a></li>
<li><a href='#simulate_correlation'><p>Simulate n points of dimension p correlated to a reference matrix.</p></a></li>
<li><a href='#simulate_matrix'><p>Simulate n points of dimension p.</p></a></li>
<li><a href='#subset.procmod_frame'><p>Subsetting Procmod Frames</p></a></li>
<li><a href='#varls'><p>Procrustean Correlation, and Variance / Covariance Matrices.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Informative Procrustean Matrix Correlation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Coissac, Christelle Gonindard-Melodelima</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Coissac &lt;eric.coissac@metabarcoding.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates corrected Procrustean correlation between matrices for removing overfitting effect. Coissac Eric and Gonindard-Melodelima Christelle (2019) &lt;<a href="https://doi.org/10.1101%2F842070">doi:10.1101/842070</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, permute, Matrix, stats, foreach, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, roxygen2, vegan, testthat, ade4, doParallel</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Collate:</td>
<td>'internals.R' 'procmod_frame.R' 'multivariate.R' 'procmod.R'
'covls.R' 'corls_test.R' 'procuste.R' 'simulate.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-11 13:33:05 UTC; coissac</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-12 06:52:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='.getPermuteMatrix'>Generate permutation matrix according to a schema.</h2><span id='topic+.getPermuteMatrix'></span>

<h3>Description</h3>

<p>The permutation schema is defined using the 'how' function.
The implementation of this function is inspired
from the VEGAN package and reproduced here to avoid an extra
dependency on an hidden vegan function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getPermuteMatrix(permutations, n, strata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getPermuteMatrix_+3A_permutations">permutations</code></td>
<td>
<p>a list of control values for the permutations as returned
by the function <code><a href="permute.html#topic+how">how</a></code>, or the number of
permutations required.</p>
</td></tr>
<tr><td><code id=".getPermuteMatrix_+3A_n">n</code></td>
<td>
<p>numeric; the number of observations in the sample set.
May also be any object that nobs knows about;
see <code><a href="permute.html#topic+nobs">nobs</a></code> methods.</p>
</td></tr>
<tr><td><code id=".getPermuteMatrix_+3A_strata">strata</code></td>
<td>
<p>A factor, or an object that can be coerced to a
factor via as.factor, specifying the strata for permutation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Internal function do not use.
</p>

<hr>
<h2 id='.procmod_coerce_value'>Internal function coercing the data to a matrix.</h2><span id='topic+.procmod_coerce_value'></span>

<h3>Description</h3>

<p>Transforme the <code>x</code> value into a <code>numeric matrix</code> of
the correct size or into a <code>dist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.procmod_coerce_value(x, nrows = 0, contrasts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".procmod_coerce_value_+3A_x">x</code></td>
<td>
<p>The data to coerce</p>
</td></tr>
<tr><td><code id=".procmod_coerce_value_+3A_nrows">nrows</code></td>
<td>
<p>an interger value specifying the number of row
of the returned matrix</p>
</td></tr>
<tr><td><code id=".procmod_coerce_value_+3A_contrasts">contrasts</code></td>
<td>
<p>see the <code>contrasts_arg</code> argument
of the <code><a href="#topic+procmod_frame">procmod_frame</a></code>
constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new numeric matrix with correct size.
</p>


<h3>Note</h3>

<p>Internal function do not use.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac &lt;eric.coissac@metabarcoding.org&gt;
</p>
<p>Christelle Gonindard-Melodelima &lt;christelle.gonindard@metabarcoding.org&gt;
</p>

<hr>
<h2 id='.rep_matrix'>Internal function repeating a matrix.</h2><span id='topic+.rep_matrix'></span>

<h3>Description</h3>

<p>repeats several times the rows of a matrix
to create a new matrix with more rows. The
final row count must be a multiple of the
initial row count
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rep_matrix(x, nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rep_matrix_+3A_x">x</code></td>
<td>
<p>The matrix to replicate</p>
</td></tr>
<tr><td><code id=".rep_matrix_+3A_nrow">nrow</code></td>
<td>
<p>an interger value specifying the number of row
of the returned matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new matrix with the same number of columns but with 'nrow'
rows.
</p>


<h3>Note</h3>

<p>Internal function do not use.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac &lt;eric.coissac@metabarcoding.org&gt;
</p>
<p>Christelle Gonindard-Melodelima &lt;christelle.gonindard@metabarcoding.org&gt;
</p>

<hr>
<h2 id='.Trace'>Compute the trace of a square matrix.</h2><span id='topic+.Trace'></span>

<h3>Description</h3>

<p>The trace of a square matrix is defined as the sum
of its diagonal elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Trace(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Trace_+3A_x">X</code></td>
<td>
<p>a square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the trace of X
</p>


<h3>Note</h3>

<p>Internal function do not use.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:16, nrow = 4)
ProcMod:::.Trace(m)
</code></pre>

<hr>
<h2 id='as_procmod_frame'>Coerce to a ProcMod Frame.</h2><span id='topic+as_procmod_frame'></span><span id='topic+as_procmod_frame.list'></span><span id='topic+as_procmod_frame.procmod_frame'></span><span id='topic+as_procmod_frame.array'></span><span id='topic+as_procmod_frame.matrix'></span>

<h3>Description</h3>

<p>Conversion methods are proposed for <code>list</code>,
<code>matrix</code> and <code>array</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_procmod_frame(data, ...)

## S3 method for class 'list'
as_procmod_frame(data, ...)

## S3 method for class 'procmod_frame'
as_procmod_frame(data, ...)

## S3 method for class 'array'
as_procmod_frame(data, ...)

## S3 method for class 'matrix'
as_procmod_frame(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_procmod_frame_+3A_data">data</code></td>
<td>
<p>a R object to coerce.</p>
</td></tr>
<tr><td><code id="as_procmod_frame_+3A_...">...</code></td>
<td>
<p>supplementary parameters used in some
implementation of that method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>procmod_frame</code> object
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Builds a list containing two random matrices
m1 &lt;- simulate_matrix(10,20)
m2 &lt;- simulate_matrix(10,30)
l &lt;- list(m1 = m1, m2 = m2)

# Converts the list to a procmod_frame
pmf1 &lt;- as_procmod_frame(l)

# Builds a procmod_frame from a matrix
m3 &lt;- matrix(1:12,nrow=3)
pmf2 &lt;- as_procmod_frame(matrix(1:12,nrow=3))
# Returns 4, the column count of the input matrix
length(pmf2)

# Builds a 3D array
a &lt;- array(1:24,dim = c(3,4,2))

# The conversion to a procmod_frame makes
# an procmod element from each third dimension
as_procmod_frame(a)

</code></pre>

<hr>
<h2 id='as.data.frame.dist'>Converts a <code>dist</code> object to a <code>data.frame</code> object.</h2><span id='topic+as.data.frame.dist'></span>

<h3>Description</h3>

<p>The created <code>data.frame</code> has a attribute <code>is.dist</code> set to
the logical value <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dist'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.dist_+3A_x">x</code></td>
<td>
<p>the <code>dist</code> object to be converted</p>
</td></tr>
<tr><td><code id="as.data.frame.dist_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a <code>character</code> vector giving the row
names for the data frame. Missing values
are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.dist_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and converting
column names (to syntactic names: see make.names)
is optional. Note that all of R's base package
as.data.frame() methods use optional only for column
names treatment, basically with the meaning of
data.frame(*, check.names = !optional).
See also the make.names argument of the
<code><a href="base.html#topic+matrix">matrix</a></code> method.</p>
</td></tr>
<tr><td><code id="as.data.frame.dist_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")
bacteria_hellinger &lt;- sqrt(bacteria_rel_freq)
bacteria_dist &lt;- dist(bacteria_hellinger)
bdf &lt;- as.data.frame(bacteria_dist)

</code></pre>

<hr>
<h2 id='bicenter'>Double centering of a matrix.</h2><span id='topic+bicenter'></span>

<h3>Description</h3>

<p>colSums and rowSums of the returned matrix are all equal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicenter(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicenter_+3A_m">m</code></td>
<td>
<p>a <code>numeric</code> matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired from the algorithm described in stackoverflow
<a href="https://stackoverflow.com/questions/43639063/double-centering-in-r">https://stackoverflow.com/questions/43639063/double-centering-in-r</a>
</p>


<h3>Value</h3>

<p>a <code>numeric</code> matrix centred by rows
and columns
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
bact_bc &lt;- bicenter(bacteria)
sum(rowSums(bact_bc))
sum(colSums(bact_bc))

</code></pre>

<hr>
<h2 id='corls_test'>Monte-Carlo Test on the sum of the singular values of a procustean rotation.</h2><span id='topic+corls_test'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of the singular values of a
procustean rotation (see <code><a href="ade4.html#topic+procuste.rtest">procuste.rtest</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corls_test(
  ...,
  permutations = permute::how(nperm = 999),
  p_adjust_method = "holm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corls_test_+3A_...">...</code></td>
<td>
<p>the set of matrices or a <code><a href="#topic+procmod_frame">procmod_frame</a></code>
object.</p>
</td></tr>
<tr><td><code id="corls_test_+3A_permutations">permutations</code></td>
<td>
<p>a list of control values for the permutations as returned
by the function <code><a href="permute.html#topic+how">how</a></code>, or the number of
permutations required.</p>
</td></tr>
<tr><td><code id="corls_test_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>the multiple test correction method used
to adjust p values. <code>p_adjust_method</code>
belongs one of the folowing values: <code>"holm"</code>,
<code>"hochberg"</code>, <code>"hommel"</code>, <code>"bonferroni"</code>,
<code>"BH"</code>, <code>"BY"</code>, <code>"fdr"</code>,  <code>"none"</code>.
The default is,set to <code>"holm"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>References</h3>


<p>Jackson DA (1995).
&ldquo;PROTEST: A PROcrustean Randomization TEST of community environment concordance.&rdquo;
<em>Écoscience</em>, <b>2</b>(3), 297&ndash;303.

</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the correlation matrix
data &lt;- procmod_frame(A = A, B = B, C = C)

corls_test(data, permutations = 100)

</code></pre>

<hr>
<h2 id='dim.procmod_frame'>Dimensions of a ProcMod Frame.</h2><span id='topic+dim.procmod_frame'></span>

<h3>Description</h3>

<p>Dimension 1 is the number of rows (individus)
shared by the aggregated matrices. Dimension 2
is the number of aggregated matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_frame'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.procmod_frame_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+procmod_frame">procmod_frame</a></code>
object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Builds a procmod_frame with two random matrices
m1 &lt;- simulate_matrix(10,20)
m2 &lt;- simulate_matrix(10,30)
pmf &lt;- procmod_frame(m1 = m1, m2 = m2)
dim(pmf)

</code></pre>

<hr>
<h2 id='eukaryotes'>DNA metabarcoding Australia South-North Gradient</h2><span id='topic+eukaryotes'></span><span id='topic+bacteria'></span><span id='topic+climat'></span><span id='topic+soil'></span><span id='topic+geography'></span>

<h3>Description</h3>

<p>This data set of five <code>data.frame</code>
is a simplified version of a full data set
describing biodiversity changes along a South-North
gradient on the Australian East Coast, from Sidney to
North Cap using a DNA metabarcoding approach.
The gradient is constituted of 21 locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eukaryotes)

data(bacteria)

data(climat)

data(soil)

data(geography)
</code></pre>


<h3>Format</h3>

<p>five data.frame of 21 rows
</p>
<p>An object of class <code>data.frame</code> with 21 rows and 2150 columns.
</p>
<p>An object of class <code>data.frame</code> with 21 rows and 6 columns.
</p>
<p>An object of class <code>data.frame</code> with 21 rows and 12 columns.
</p>
<p>An object of class <code>data.frame</code> with 21 rows and 2 columns.
</p>


<h3>Details</h3>


<dl>
<dt>bacteria</dt><dd><p>is a 21 x 2150 <code>data.frame</code> describing bacterial
community at each one of the 21 locations.
Each number is the relative frequency of a molecular operational
taxonomy unit (MOTU) at a site after data cleaning  and
averaging of 135 pontual measures.</p>
</dd>
<dt>bacteria</dt><dd><p>is a 21 x 1393 <code>data.frame</code> describing eukariote
community at each one of the 21 locations.
Each number is the relative frequency of a molecular operational
taxonomy unit (MOTU) at a site after data cleaning  and
averaging of 135 pontual measures.</p>
</dd>
<dt>climat</dt><dd><p>is a 21 x 6 <code>data.frame</code> describing climatic conditions
at each site using worldclim descriptors (https://www.worldclim.org).
</p>

<dl>
<dt>Aspect</dt><dd></dd>
<dt>TempSeasonality</dt><dd></dd>
<dt>MaxMonTemp</dt><dd><p>Max Temperature of Warmest Month</p>
</dd>
<dt>MeanMonTempRange</dt><dd></dd>
<dt>AnnMeanTemp</dt><dd></dd>
<dt>Isothemality</dt><dd><p>Mean Diurnal Range / Temperature Annual Range, with
</p>

<dl>
<dt>Mean Diurnal Range</dt><dd><p>Mean of monthly (max temp - min temp)</p>
</dd>
<dt>Temperature Annual Range</dt><dd><p>Max Temperature of Warmest Month - Min Temperature of Coldest Month</p>
</dd>
</dl>

</dd></dl>
</dd>
<dt>soil</dt><dd><p>s a 21 x 6 <code>data.frame</code> describing soil chemistery
at each site.
Each variable is reduced and centered
</p>

<dl>
<dt>KLg</dt><dd><p>Logarithm of the potassium concentration</p>
</dd>
<dt>pH</dt><dd><p>Soil Ph</p>
</dd>
<dt>AlLg</dt><dd><p>Logarithm of the aluminium concentration</p>
</dd>
<dt>FeLg</dt><dd><p>Logarithm of the iron concentration</p>
</dd>
<dt>PLg</dt><dd><p>Logarithm of the phosphorus concentration</p>
</dd>
<dt>SLg</dt><dd><p>Logarithm of the sulphur concentration</p>
</dd>
<dt>CaLg</dt><dd><p>Logarithm of the calcium concentration</p>
</dd>
<dt>MgLg</dt><dd><p>Logarithm of the magnesium concentration</p>
</dd>
<dt>MnLg</dt><dd><p>Logarithm of the manganese concentration</p>
</dd>
<dt>CNratio</dt><dd><p>carbon / nitrogen concentration ratio</p>
</dd>
<dt>CLg</dt><dd><p>Logarithm of the carbon concentration</p>
</dd>
<dt>NLg</dt><dd><p>Logarithm of the nitrogen concentration</p>
</dd>
</dl>
</dd>
<dt>geography</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Christelle Gonindard-Melodelima
</p>
<p>Eric Coissac
</p>

<hr>
<h2 id='is_euclid'>Test if the distance matrix is euclidean.</h2><span id='topic+is_euclid'></span>

<h3>Description</h3>

<p>Actually a simplified version of the ADE4 implementation
(<code><a href="ade4.html#topic+is.euclid">is.euclid</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_euclid(distances, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_euclid_+3A_distances">distances</code></td>
<td>
<p>an object of class 'dist'</p>
</td></tr>
<tr><td><code id="is_euclid_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold : an eigenvalue is
considered positive if it is larger than
-tol*lambda1 where lambda1 is the largest eigenvalue.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(bacteria)

bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")

bacteria_bray &lt;- vegdist(bacteria_rel_freq,method = "bray")
is_euclid(bacteria_bray)

bacteria_chao &lt;- vegdist(floor(bacteria*10000),method = "chao")
is_euclid(bacteria_chao)

</code></pre>

<hr>
<h2 id='is_procmod_frame'>Check if an object is a ProcMod Frame.</h2><span id='topic+is_procmod_frame'></span>

<h3>Description</h3>

<p>Check if an object is a ProcMod Frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_procmod_frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_procmod_frame_+3A_x">x</code></td>
<td>
<p>a R <code>object to test</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>logical</code> value equals to
<code>TRUE</code> if <code>x</code> is a <code>procmod_frame</code>,
<code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Builds a procmod_frame with two random matrices
m1 &lt;- simulate_matrix(10,20)
m2 &lt;- simulate_matrix(10,30)
pmf &lt;- procmod_frame(m1 = m1, m2 = m2)

# Returns TRUE
is_procmod_frame(pmf)

# Returns FALSE
is_procmod_frame(3)

</code></pre>

<hr>
<h2 id='names.procmod_corls'>The Names of the elements of a Correlation Matrix</h2><span id='topic+names.procmod_corls'></span>

<h3>Description</h3>

<p>Returns the names of the elements associated to a <code>procmod_corls</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_corls'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.procmod_corls_+3A_x">x</code></td>
<td>
<p>a <code>procmod_corls</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corls">corls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build Three matrices of 3 rows.
A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the correlation matrix
data &lt;- procmod_frame(A = A, B = B, C = C)
cls &lt;- corls(data, nrand = 100)

names(cls)

</code></pre>

<hr>
<h2 id='names.procmod_varls'>The Names of the elements of a Variance / Covariance Matrix.</h2><span id='topic+names.procmod_varls'></span>

<h3>Description</h3>

<p>Returns the names of the elements associated to a <code>procmod_varls</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_varls'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.procmod_varls_+3A_x">x</code></td>
<td>
<p>a <code>procmod_varls</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varls">varls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build Three matrices of 3 rows.
A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the variance covariance matrix
data &lt;- procmod_frame(A = A, B = B, C = C)
v &lt;- varls(data, nrand = 100)

names(v)

</code></pre>

<hr>
<h2 id='nmds'>Project a distance matrix in a euclidean space (NMDS).</h2><span id='topic+nmds'></span>

<h3>Description</h3>

<p>Project a set of points defined by a distance matrix in
an eucleadean space using the Kruskal's Non-metric
Multidimensional Scaling. This function is mainly a simplified
interface on the <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> function using as
much as possible dimensions to limit the stress. The aims of this
NDMS being only to project point in an orthogonal space therefore
without any correlation between axis. Because a non-metric method
is used no condition is required on the used distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmds(distances, maxit = 100, trace = FALSE, tol = 0.001, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmds_+3A_distances">distances</code></td>
<td>
<p>a <code><a href="stats.html#topic+dist">dist</a></code> object or a
<code><a href="base.html#topic+matrix">matrix</a></code>
object representing a distance matrix.</p>
</td></tr>
<tr><td><code id="nmds_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="nmds_+3A_trace">trace</code></td>
<td>
<p>Logical for tracing optimization. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nmds_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="nmds_+3A_p">p</code></td>
<td>
<p>Power for Minkowski distance in the configuration space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with at most <code>n-1</code> dimensions, with
<code>n</code> the number pf observations. This matrix defines the
coordinates of each point in the orthogonal space.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")
bacteria_hellinger &lt;- sqrt(bacteria_rel_freq)
bacteria_dist &lt;- dist(bacteria_hellinger)

project &lt;- nmds(bacteria_dist)

</code></pre>

<hr>
<h2 id='ortho'>Project a dataset in a euclidean space.</h2><span id='topic+ortho'></span><span id='topic+ortho.dist'></span><span id='topic+ortho.matrix'></span><span id='topic+ortho.data.frame'></span><span id='topic+ortho.procmod_frame'></span>

<h3>Description</h3>

<p>Project a set of points defined by a distance matrix
or a set of variables in an eucleadean space.
If the distance matrix is a metric, this is done using
the <code><a href="#topic+pcoa">pcoa</a></code> function,
for other distance the <code><a href="#topic+nmds">nmds</a></code> is used.
When points are described by a set of variable the
<code><a href="#topic+nmds">nmds</a></code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho(data, ...)

## S3 method for class 'dist'
ortho(data, tol = 1e-07, ...)

## S3 method for class 'matrix'
ortho(data, scale = FALSE, ...)

## S3 method for class 'data.frame'
ortho(data, scale = FALSE, ...)

## S3 method for class 'procmod_frame'
ortho(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho_+3A_data">data</code></td>
<td>
<p>a numeric matrix describing the points</p>
</td></tr>
<tr><td><code id="ortho_+3A_...">...</code></td>
<td>
<p>other parameters specific to some implementation</p>
</td></tr>
<tr><td><code id="ortho_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold : an eigenvalue is
considered positive if it is larger than
-tol*lambda1 where lambda1 is the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="ortho_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> value indicating if the dimensions must be scaled
to force for every column that <code>sd=1</code>. <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with at most <code>n-1</code> dimensions, with
<code>n</code> the number pf observations. This matrix defines the
coordinates of each point in the orthogonal space.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(bacteria)
data(eukaryotes)
data(soil)

dataset &lt;- procmod_frame(euk = vegdist(decostand(eukaryotes,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         bac = vegdist(decostand(bacteria,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         soil = scale(soil,
                                      center = TRUE,
                                      scale  = TRUE))

dp &lt;- ortho(dataset)

bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")
bacteria_hellinger &lt;- sqrt(bacteria_rel_freq)
bacteria_dist &lt;- dist(bacteria_hellinger)

project &lt;- ortho(bacteria_dist)

</code></pre>

<hr>
<h2 id='pca'>Project a set of points in a euclidean space (PCA).</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>Project a set of points defined by a set of numeric variables in
an eucleadean space using the pricipal componant analysis.
This function is mainly a simplified
interface on the <code><a href="stats.html#topic+prcomp">prcomp</a></code> function using as
much as possible dimensions to keep all the variation. The aims of this
PCA being only to project point in an orthogonal space therefore
without any correlation between axis. Data are centered by not scaled by
default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(data, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_data">data</code></td>
<td>
<p>a numeric matrix describing the points</p>
</td></tr>
<tr><td><code id="pca_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> value indicating if the dimensions must be scaled
to force for every column that <code>sd=1</code>. <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with at most <code>n-1</code> dimensions, with
<code>n</code> the number pf observations. This matrix defines the
coordinates of each point in the orthogonal space.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")
bacteria_hellinger &lt;- sqrt(bacteria_rel_freq)

project &lt;- pca(bacteria_hellinger)

</code></pre>

<hr>
<h2 id='pcoa'>Project a distance matrix in a euclidean space (PCOA).</h2><span id='topic+pcoa'></span>

<h3>Description</h3>

<p>Project a set of points defined by a distance matrix in
an eucleadean space using the Principal Coordinates Analysis
method. This function is mainly a simplified
interface on the <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> function using as
much as possible dimensions for the projection. The aims of this
PCoA being only to project point in an orthogonal space therefore
without any correlation between axis. Because a metric method
is used the used distance must be euclidean
(cf <code><a href="#topic+is_euclid">is_euclid</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa(distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa_+3A_distances">distances</code></td>
<td>
<p>a <code><a href="stats.html#topic+dist">dist</a></code> object or a
<code><a href="base.html#topic+matrix">matrix</a></code>
object representing a distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with at most <code>n-1</code> dimensions, with
<code>n</code> the number pf observations. This matrix defines the
coordinates of each point in the orthogonal space.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
bacteria_rel_freq &lt;- sweep(bacteria,
                           1,
                           rowSums(bacteria),
                           "/")
bacteria_hellinger &lt;- sqrt(bacteria_rel_freq)
bacteria_dist &lt;- dist(bacteria_hellinger)

project &lt;- pcoa(bacteria_dist)

</code></pre>

<hr>
<h2 id='print.procmod_corls'>Print a procrustean Correlation Matrix.</h2><span id='topic+print.procmod_corls'></span>

<h3>Description</h3>

<p>Print a procrustean Correlation Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_corls'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.procmod_corls_+3A_x">x</code></td>
<td>
<p>a <code>procmod_corls</code>
object</p>
</td></tr>
<tr><td><code id="print.procmod_corls_+3A_...">...</code></td>
<td>
<p>other parameters passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corls">corls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build Three matrices of 3 rows.
A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the correlation matrix
data &lt;- procmod_frame(A = A, B = B, C = C)
cls &lt;- corls(data, nrand = 100)

print(cls)

</code></pre>

<hr>
<h2 id='print.procmod_varls'>Print procrustean Variance / Covariance Matrix.</h2><span id='topic+print.procmod_varls'></span>

<h3>Description</h3>

<p>Print procrustean Variance / Covariance Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_varls'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.procmod_varls_+3A_x">x</code></td>
<td>
<p>a <code>procmod_varls</code>
object</p>
</td></tr>
<tr><td><code id="print.procmod_varls_+3A_...">...</code></td>
<td>
<p>other parameters passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varls">varls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build Three matrices of 3 rows.
A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the variance covariance matrix
data &lt;- procmod_frame(A = A, B = B, C = C)
v &lt;- varls(data, nrand = 100)

print(v)

</code></pre>

<hr>
<h2 id='procmod'>Informative Procrustean Matrix Correlation</h2><span id='topic+procmod'></span>

<h3>Description</h3>

<p>Estimates corrected Procrustean correlation between
matrices for removing overfitting effect.
</p>


<h3>Details</h3>

<p>The functions in the ProcMod package aims to estimate and to test correlation
between matrices, correcting for the spurious correlations because of the
over-fitting effect.
</p>
<p>The ProcMod package is developed on the metabarcoding.org gitlab
(https://git.metabarcoding.org/lecasofts/ProcMod).
The gitlab of metabarcoding.org provides up-to-date information and
forums for bug reports.
</p>


<h3>Author(s)</h3>

<p>Christelle Gonindard-Melodelima
</p>
<p>Eric Coissac
</p>

<hr>
<h2 id='procmod_frame'>The procmod_frame data structure.</h2><span id='topic+procmod_frame'></span>

<h3>Description</h3>

<p>A <code>procmod_frame</code> can be considered as the analog of a
<code>data.frame</code> for vector data. In a <code>procmod_frame</code>
each element, equivalent to a column in a <code>data.frame</code>
is a numeric matrix or a distance matrix object (<code>dist</code>).
Every element must describe the same number of individuals.
Therefore every numeric matrix must have the same number of row
(<code>nrow</code>) and every distance matrix must have the same size
(<code>attr(d,"Size")</code>). A <code>procmod_frame</code> can simultaneously
contain both types of data, numeric and distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procmod_frame(
  ...,
  row_names = NULL,
  check_rows = TRUE,
  reorder_rows = TRUE,
  contrasts_arg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procmod_frame_+3A_...">...</code></td>
<td>
<p>a set of objects to aggregate into a
<code>procmod_frame</code>. These objects can be
numeric matrices, or dist objects. Every objects
must have the same number of row.</p>
</td></tr>
<tr><td><code id="procmod_frame_+3A_row_names">row_names</code></td>
<td>
<p>a character vector containing names associated
to each row.</p>
</td></tr>
<tr><td><code id="procmod_frame_+3A_check_rows">check_rows</code></td>
<td>
<p>a logical value. When set to <code>TRUE</code>, its
default value, the number of row of every elements of the
<code>procmod_frame</code> are tested for equality. Otherwise no
check is done.</p>
</td></tr>
<tr><td><code id="procmod_frame_+3A_reorder_rows">reorder_rows</code></td>
<td>
<p>a logical value. When set to <code>TRUE</code>, its
default value, every elements of the
<code>procmod_frame</code> are reordered according to the <code>row_names</code>
order. Otherwise nothing is done.</p>
</td></tr>
<tr><td><code id="procmod_frame_+3A_contrasts_arg">contrasts_arg</code></td>
<td>
<p>A list, whose entries are values
(numeric matrices or character strings naming functions)
to be used as replacement values for the contrasts
replacement function and whose names are the names
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>procmod_frame</code> instance.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(bacteria)
data(eukaryotes)
data(soil)

dataset &lt;- procmod_frame(euk = vegdist(decostand(eukaryotes,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         bac = vegdist(decostand(bacteria,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         soil = scale(soil,
                                      center = TRUE,
                                      scale  = TRUE))
length(dataset)
nrow(dataset)
ncol(dataset)
dataset$euk

</code></pre>

<hr>
<h2 id='protate'>Rotate the <code>src</code> matrix to fit into the space of the <code>dest</code> matrix.</h2><span id='topic+protate'></span>

<h3>Description</h3>

<p>The optimal rotation is computed according to the procruste methode.
Rotation is based on singular value decomposition (SVD).
No scaling and no centrering are done, before computing the SVD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protate(src, dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protate_+3A_src">src</code></td>
<td>
<p>a numeric matrix to be rotated</p>
</td></tr>
<tr><td><code id="protate_+3A_dest">dest</code></td>
<td>
<p>a numeric matrix used as reference space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix
</p>


<h3>Author(s)</h3>

<p>Christelle Gonindard-Melodelima
</p>
<p>Eric Coissac
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generates two random matrices of size 10 x 15
m1 &lt;- simulate_matrix(10, 15)
m2 &lt;- simulate_matrix(10, 20)

# Rotates matrix m1 on m2
mr &lt;- protate(m1, m2)

</code></pre>

<hr>
<h2 id='simulate_correlation'>Simulate n points of dimension p correlated to a reference matrix.</h2><span id='topic+simulate_correlation'></span>

<h3>Description</h3>

<p>Simulates a set of point correlated to another set according to the
procrustean correlation definition.
Points are simulated by drawing values of each dimension from a normal
distribution of mean 0 and standard deviation equals to 1.
The mean of each dimension is forced to 0 (data are centred).
By default variable are also scaled to enforce a strandard deviation
strictly equal to 1. Covariances between dimensions are not controled.
Therefore they are expected to be equal to 0 and reflect only the
random distribution of the covariance between two random vectors.
The intensity of the correlation is determined by the <code>r2</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_correlation(reference, p, r2, equal_var = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_correlation_+3A_reference">reference</code></td>
<td>
<p>a numeric matrix to which the simulated data will be correlated</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_p">p</code></td>
<td>
<p>an <code>int</code> value indicating the number of dimensions (variables)
simulated</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_r2">r2</code></td>
<td>
<p>the fraction of variation shared between the <code>reference</code> and the
simulated data</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_equal_var">equal_var</code></td>
<td>
<p>a <code>logical</code> value indicating if the dimensions must be scaled
to force <code>sd=1</code>. <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of <code>nrow(reference)</code> rows and <code>p</code> columns
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim1 &lt;- simulate_matrix(25,10)
class(sim1)
dim(sim1)
sim2 &lt;- simulate_correlation(sim1,20,0.8)
corls(sim1, sim2)^2

</code></pre>

<hr>
<h2 id='simulate_matrix'>Simulate n points of dimension p.</h2><span id='topic+simulate_matrix'></span>

<h3>Description</h3>

<p>Points are simulated by drawing values of each dimension from a normal
distribution of mean 0 and standard deviation equals to 1.
The mean of each dimension is forced to 0 (data are centred).
By default variable are also scaled to enforce a strandard deviation
strictly equal to 1. Covariances between dimensions are not controled.
Therefore they are expected to be equal to 0 and reflect only the
random distribution of the covariance between two random vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_matrix(n, p, equal_var = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_matrix_+3A_n">n</code></td>
<td>
<p>an <code>int</code> value indicating the number of observations.</p>
</td></tr>
<tr><td><code id="simulate_matrix_+3A_p">p</code></td>
<td>
<p>an <code>int</code> value indicating the number of dimensions (variables)
simulated</p>
</td></tr>
<tr><td><code id="simulate_matrix_+3A_equal_var">equal_var</code></td>
<td>
<p>a <code>logical</code> value indicating if the dimensions must be scaled
to force <code>sd=1</code>. <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of <code>n</code> rows and <code>p</code> columns
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim1 &lt;- simulate_matrix(25,10)
class(sim1)
dim(sim1)

</code></pre>

<hr>
<h2 id='subset.procmod_frame'>Subsetting Procmod Frames</h2><span id='topic+subset.procmod_frame'></span>

<h3>Description</h3>

<p>This is the implementation of the <code><a href="base.html#topic+subset">subset</a></code> generic function for
<code>procmod_frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'procmod_frame'
subset(x, subset, select, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.procmod_frame_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.procmod_frame_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or
rows to keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="subset.procmod_frame_+3A_select">select</code></td>
<td>
<p>expression, indicating columns to select from a data frame.</p>
</td></tr>
<tr><td><code id="subset.procmod_frame_+3A_drop">drop</code></td>
<td>
<p>passed on to [ indexing operator.</p>
</td></tr>
<tr><td><code id="subset.procmod_frame_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subset argument works on rows. Note that subset will be evaluated in the
<code>procmod_frame</code>, so columns can be referred to (by name) as variables
in the expression (see the examples).
</p>
<p>The select argument if provided indicates with matrices
have to be conserved.  It works by first replacing column names in the selection
expression with the corresponding column numbers in the <code>procmod_frame</code> and then using
the resulting integer vector to index the columns. This allows the use of the
standard indexing conventions so that for example ranges of columns can
be specified easily, or single columns can be dropped (see the examples). Remember
that each column of a <code>procmod_frame</code> is actually a matrix.
</p>
<p>The drop argument is passed on to the <code>procmod_frame</code> indexing method.
The default value is <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>procmod_frame</code> containing just the selected rows and columns.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(bacteria)
data(eukaryotes)
data(soil)

dataset &lt;- procmod_frame(euk = vegdist(decostand(eukaryotes,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         bac = vegdist(decostand(bacteria,
                                                 method = "hellinger"),
                                       method = "euclidean"),
                         soil = scale(soil,
                                      center = TRUE,
                                      scale  = TRUE))
dim(dataset)

higher_ph = subset(dataset,soil[,"pH"] &gt; 0)
dim(higher_ph)

without_bacteria = subset(dataset,soil[,"pH"] &gt; 0, -bac)
dim(without_bacteria)

</code></pre>

<hr>
<h2 id='varls'>Procrustean Correlation, and Variance / Covariance Matrices.</h2><span id='topic+varls'></span><span id='topic+corls'></span>

<h3>Description</h3>

<p><code>varls</code>, <code>corls</code> compute the procrustean
variance / covariance, or correlation matrices
between a set of real matrices and <code><a href="stats.html#topic+dist">dist</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varls(..., nrand = 100, p_adjust_method = "holm")

corls(..., nrand = 100, p_adjust_method = "holm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varls_+3A_...">...</code></td>
<td>
<p>the set of matrices or a <code><a href="#topic+procmod_frame">procmod_frame</a></code>
object.</p>
</td></tr>
<tr><td><code id="varls_+3A_nrand">nrand</code></td>
<td>
<p>number of randomisation used to estimate the mean
covariance observed between two random matrix.
If rand is <code>NULL</code> or equal to <code>0</code>, no correction
is estimated and the raw procrustean covariances are
estimated.</p>
</td></tr>
<tr><td><code id="varls_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>the multiple test correction method used
to adjust p values. <code>p_adjust_method</code>
belongsone of the folowing values: <code>"holm"</code>,
<code>"hochberg"</code>, <code>"hommel"</code>, <code>"bonferroni"</code>,
<code>"BH"</code>, <code>"BY"</code>, <code>"fdr"</code>,  <code>"none"</code>.
The default is,set to <code>"holm"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Procrustean covariance between two matrices X and Y, is defined as the sum
of the singular values of the X'Y matrix (Gower 1971; Lingoes and Schönemann 1974).
Both the X and Y matrices must have the same number of rows.
</p>
<p>The variances and covariances and correlations are corrected
to avoid over fitting (Coissac and Gonindard-Melodelima 2019).
</p>
<p>The inputs must be numeric matrices or <code><a href="stats.html#topic+dist">dist</a></code> object.
The set of input matrices can be aggregated un a
<code><a href="#topic+procmod_frame">procmod_frame</a></code>.
</p>
<p>Before computing the coefficients, matrices are projected into an
orthogonal space using the <code><a href="#topic+ortho">ortho</a></code> function.
</p>
<p>The denominator n - 1 is used which gives an unbiased estimator of the
(co)variance for i.i.d. observations.
</p>


<h3>Value</h3>

<p>a <code>procmod_varls</code> object which corresponds to a numeric
matrix annotated by several attributes.
</p>
<p>The following attribute is always added:
</p>
<p>- <code>nrand</code> an integer value indicating the number of
randomisations used to estimate the mean of the random
covariance.
</p>
<p>When <code>nrand</code> is greater than 0 a couple of attributes
is added:
</p>
<p>- <code>rcovls</code> a numeric matrix containing the estimation
of the mean of the random covariance.
</p>
<p>- <code>p.value</code> a numeric matrix containing the estimations
of the p.values of tests checking that the observed
covariance is larger than the mean of the random covariance.
p.values are corrected for multiple tests according to the
method specified by the <code>p_adjust_method</code> parameter.
</p>


<h3>Author(s)</h3>

<p>Eric Coissac
</p>
<p>Christelle Gonindard-Melodelima
</p>


<h3>References</h3>


<p>Gower JC (1971).
&ldquo;Statistical methods of comparing different multivariate analyses of the same data.&rdquo;
<em>Mathematics in the archaeological and historical sciences</em>, 138&ndash;149.
</p>
<p>Lingoes JC, Schönemann PH (1974).
&ldquo;Alternative measures of fit for the Schönemann-carroll matrix fitting algorithm.&rdquo;
<em>Psychometrika</em>, <b>39</b>(4), 423&ndash;427.
</p>
<p>Coissac E, Gonindard-Melodelima C (2019).
&ldquo;Assessing the shared variation among high-dimensional data matrices: a modified version of the Procrustean correlation coefficient.&rdquo;
<em>in prep</em>.

</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build Three matrices of 3 rows.
A &lt;- simulate_matrix(10,3)
B &lt;- simulate_matrix(10,5)
C &lt;- simulate_correlation(B,10,r2=0.6)

# Computes the variance covariance matrix
varls(A = A, B = B, C = C)

data = procmod_frame(A = A, B = B, C = C)
varls(data)

# Computes the correlation matrix
corls(data, nrand = 100)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
