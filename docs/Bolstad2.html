<!DOCTYPE html><html lang="en"><head><title>Help for package Bolstad2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bolstad2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AidsSurvival.df'><p>HIV Survival data</p></a></li>
<li><a href='#BayesCPH'><p>Bayesian Cox Proportional Hazards Modelling</p></a></li>
<li><a href='#BayesLogistic'><p>Bayesian Logistic Regression</p></a></li>
<li><a href='#BayesPois'><p>Bayesian Pois Regression</p></a></li>
<li><a href='#bivnormMH'><p>Metropolis Hastings sampling from a Bivariate Normal distribution</p></a></li>
<li><a href='#c10ex16.df'><p>Chapter 10 Example 16 data</p></a></li>
<li><a href='#chd.df'><p>Coronary Heart Disease Chapter 8 Example 11</p></a></li>
<li><a href='#credInt'><p>Calculate a credible interval from a numerically specified posterior CDF or</p>
from a sample from the posterior</a></li>
<li><a href='#credIntNum'><p>Calculate a credible interval from a numerically specified posterior CDF</p></a></li>
<li><a href='#credIntSamp'><p>Calculate a credible interval from a numerically specified posterior CDF</p></a></li>
<li><a href='#describe'><p>Give simple descriptive statistics for a matrix or a data frame</p></a></li>
<li><a href='#GelmanRubin'><p>Calculate the Gelman Rubin statistic</p></a></li>
<li><a href='#hierMeanReg'><p>Hierarchical Normal Means Regression Model</p></a></li>
<li><a href='#hiermeanRegTest.df'><p>Test data for hiermeanReg</p></a></li>
<li><a href='#logisticTest.df'><p>Test data for bayesLogistic</p></a></li>
<li><a href='#normGibbs'><p>Draw a sample from a posterior distribution of data with an unknown mean and</p>
variance using Gibbs sampling</a></li>
<li><a href='#normMixMH'><p>Sample from a normal mixture model using Metropolis-Hastings</p></a></li>
<li><a href='#pNull'><p>Test a one sided hypothesis from a numerically specified posterior CDF or</p>
from a sample from the posterior</a></li>
<li><a href='#pnullNum'><p>Test a one sided hypothesis from a numerically specified posterior CDF</p></a></li>
<li><a href='#pnullSamp'><p>Test a one sided hypothesis using a sample from a posterior density</p></a></li>
<li><a href='#poissonTest.df'><p>A test data set for bayesPois</p></a></li>
<li><a href='#sintegral'><p>Numerical integration using Simpson's Rule</p></a></li>
<li><a href='#thin'><p>Thin an MCMC sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-29</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Bolstad Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of R functions and data sets for the book "Understanding Computational Bayesian Statistics." This book was written by Bill (WM) Bolstad and published in 2009 by John Wiley &amp; Sons (ISBN 978-0470046098).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmcurran/Bolstad2">https://github.com/jmcurran/Bolstad2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-11 05:53:21 UTC; james</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 09:22:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='AidsSurvival.df'>HIV Survival data</h2><span id='topic+AidsSurvival.df'></span>

<h3>Description</h3>

<p>Data from a hypothetical HMO-HIV+ study shown in Table 1.1 of Hosmer, D.W.
and Lemeshow, S. (1998) Applied Survival Analysis: Regression Modeling of
Time to Event Data, John Wiley and Sons Inc., New York, NY
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on 7 variables. </p>

<table>
<tr>
 <td style="text-align: right;">
[,1] </td><td style="text-align: left;"> id </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> l Subject ID code </td>
</tr>
<tr>
 <td style="text-align: right;"> [,2] </td><td style="text-align: left;"> entdate </td><td style="text-align: left;">
date </td><td style="text-align: left;"> Entry date (ddmmyr) </td>
</tr>
<tr>
 <td style="text-align: right;"> [,3] </td><td style="text-align: left;"> enddate </td><td style="text-align: left;"> date </td><td style="text-align: left;"> Entry
date (ddmmyr) </td>
</tr>
<tr>
 <td style="text-align: right;"> [,4] </td><td style="text-align: left;"> time </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Survival Time = days
between Entry date and End date </td>
</tr>
<tr>
 <td style="text-align: right;"> [,5] </td><td style="text-align: left;"> age </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Age in
years </td>
</tr>
<tr>
 <td style="text-align: right;"> [,6] </td><td style="text-align: left;"> drug </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> History of IV drug use (0 = No, 1
= Yes) </td>
</tr>
<tr>
 <td style="text-align: right;"> [,7] </td><td style="text-align: left;"> censor </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Follow-Up Status1 = Death due
to AIDS or AIDS </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> related factors (0 = Alive at study end
or lost to follow-up)</td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>


<hr>
<h2 id='BayesCPH'>Bayesian Cox Proportional Hazards Modelling</h2><span id='topic+BayesCPH'></span>

<h3>Description</h3>

<p>Uses a Metropolis Hastings scheme on the proportional hazards model to draw
sample from posterior. Uses a matched curvature Student's t candidate
generating distribution with 4 degrees of freedom to give heavy tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesCPH(
  y,
  t,
  x,
  steps = 1000,
  priorMean = NULL,
  priorVar = NULL,
  mleMean = NULL,
  mleVar,
  startValue = NULL,
  randomSeed = NULL,
  plots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesCPH_+3A_y">y</code></td>
<td>
<p>the Poisson censored response vector. It has value 0 when the
variable is censored and 1 when it is not censored.</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_t">t</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_x">x</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_steps">steps</code></td>
<td>
<p>the number of steps to use in the Metropolis-Hastings updating</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_priormean">priorMean</code></td>
<td>
<p>the mean of the prior</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_priorvar">priorVar</code></td>
<td>
<p>the variance of the prior</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_mlemean">mleMean</code></td>
<td>
<p>the mean of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_mlevar">mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_startvalue">startValue</code></td>
<td>
<p>a vector of starting values for all of the regression
coefficients including the intercept</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_randomseed">randomSeed</code></td>
<td>
<p>a random seed to use for different chains</p>
</td></tr>
<tr><td><code id="BayesCPH_+3A_plots">plots</code></td>
<td>
<p>Plot the time series and auto correlation functions for each of
the model coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>a data frame containing the sample of the model coefficients
from the posterior distribution</p>
</td></tr> <tr><td><code>mleMean</code></td>
<td>
<p>the mean of the matched
curvature likelihood. This is useful if you've used a training set to
estimate the value and wish to use it with another data set</p>
</td></tr>
<tr><td><code>mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood. See
mleMean for why you'd want this</p>
</td></tr>
</table>

<hr>
<h2 id='BayesLogistic'>Bayesian Logistic Regression</h2><span id='topic+BayesLogistic'></span>

<h3>Description</h3>

<p>Performas Metropolis Hastings on the logistic regression model to draw
sample from posterior. Uses a matched curvature Student's t candidate
generating distribution with 4 degrees of freedom to give heavy tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesLogistic(
  y,
  x,
  steps = 1000,
  priorMean = NULL,
  priorVar = NULL,
  mleMean = NULL,
  mleVar,
  startValue = NULL,
  randomSeed = NULL,
  plots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesLogistic_+3A_y">y</code></td>
<td>
<p>the binary response vector</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_x">x</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_steps">steps</code></td>
<td>
<p>the number of steps to use in the Metropolis-Hastings updating</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_priormean">priorMean</code></td>
<td>
<p>the mean of the prior</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_priorvar">priorVar</code></td>
<td>
<p>the variance of the prior</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_mlemean">mleMean</code></td>
<td>
<p>the mean of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_mlevar">mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_startvalue">startValue</code></td>
<td>
<p>a vector of starting values for all of the regression
coefficients including the intercept</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_randomseed">randomSeed</code></td>
<td>
<p>a random seed to use for different chains</p>
</td></tr>
<tr><td><code id="BayesLogistic_+3A_plots">plots</code></td>
<td>
<p>Plot the time series and auto correlation functions for each of
the model coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>a data frame containing the sample of the model coefficients
from the posterior distribution</p>
</td></tr> <tr><td><code>mleMean</code></td>
<td>
<p>the mean of the matched
curvature likelihood. This is useful if you've used a training set to
estimate the value and wish to use it with another data set</p>
</td></tr>
<tr><td><code>mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood. See
mleMean for why you'd want this</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(logisticTest.df)
BayesLogistic(logisticTest.df$y, logisticTest.df$x)

</code></pre>

<hr>
<h2 id='BayesPois'>Bayesian Pois Regression</h2><span id='topic+BayesPois'></span>

<h3>Description</h3>

<p>Performs Metropolis Hastings on the logistic regression model to draw sample
from posterior. Uses a matched curvature Student's t candidate generating
distribution with 4 degrees of freedom to give heavy tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesPois(
  y,
  x,
  steps = 1000,
  priorMean = NULL,
  priorVar = NULL,
  mleMean = NULL,
  mleVar,
  startValue = NULL,
  randomSeed = NULL,
  plots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesPois_+3A_y">y</code></td>
<td>
<p>the binary response vector</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_x">x</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_steps">steps</code></td>
<td>
<p>the number of steps to use in the Metropolis-Hastings updating</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_priormean">priorMean</code></td>
<td>
<p>the mean of the prior</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_priorvar">priorVar</code></td>
<td>
<p>the variance of the prior</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_mlemean">mleMean</code></td>
<td>
<p>the mean of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_mlevar">mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_startvalue">startValue</code></td>
<td>
<p>a vector of starting values for all of the regression
coefficients including the intercept</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_randomseed">randomSeed</code></td>
<td>
<p>a random seed to use for different chains</p>
</td></tr>
<tr><td><code id="BayesPois_+3A_plots">plots</code></td>
<td>
<p>Plot the time series and auto correlation functions for each of
the model coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>a data frame containing the sample of the model coefficients
from the posterior distribution</p>
</td></tr> <tr><td><code>mleMean</code></td>
<td>
<p>the mean of the matched
curvature likelihood. This is useful if you've used a training set to
estimate the value and wish to use it with another data set</p>
</td></tr>
<tr><td><code>mleVar</code></td>
<td>
<p>the covariance matrix of the matched curvature likelihood. See
mleMean for why you'd want this</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(poissonTest.df)
results = BayesPois(poissonTest.df$y, poissonTest.df$x)

</code></pre>

<hr>
<h2 id='bivnormMH'>Metropolis Hastings sampling from a Bivariate Normal distribution</h2><span id='topic+bivnormMH'></span>

<h3>Description</h3>

<p>This function uses the MetropolisHastings algorithm to draw a sample from a
correlated bivariate normal target density using a random walk candidate and
an independent candidate density respectively where we are drawing both
parameters in a single draw. It can also use the blockwise Metropolis
Hastings algorithm and Gibbs sampling respectively to draw a sample from the
correlated bivariate normal target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivnormMH(rho, rho1 = 0.9, sigma = c(1.2, 1.2), steps = 1000, type = "ind")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivnormMH_+3A_rho">rho</code></td>
<td>
<p>the correlation coefficient for the bivariate normal</p>
</td></tr>
<tr><td><code id="bivnormMH_+3A_rho1">rho1</code></td>
<td>
<p>the correlation of the candidate distribution. Only used when
type = 'ind'</p>
</td></tr>
<tr><td><code id="bivnormMH_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviations of the marginal distributions of the
independent candidate density. Only used when type = 'ind'</p>
</td></tr>
<tr><td><code id="bivnormMH_+3A_steps">steps</code></td>
<td>
<p>the number of Metropolis Hastings steps</p>
</td></tr>
<tr><td><code id="bivnormMH_+3A_type">type</code></td>
<td>
<p>the type of candidate generation to use. Can be one of 'rw' =
random walk, 'ind' = independent normals, 'gibbs' = Gibbs sampling or
'block' = blockwise. It is sufficient to use 'r','i','g', or 'b'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list which contains a data frame called targetSample with
members x and y. These are the samples from the target density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## independent chain
chain1.df=bivnormMH(0.9)$targetSample

## random walk chain
chain2.df=bivnormMH(0.9, type = 'r')$targetSample


## blockwise MH chain
chain3.df=bivnormMH(0.9, type = 'b')$targetSample

## Gibbs sampling chain
chain4.df=bivnormMH(0.9, type = 'g')$targetSample

oldPar = par(mfrow=c(2,2))
plot(y ~ x, type = 'l', chain1.df, main = 'Independent')
plot(y ~ x, type = 'l', chain2.df, main = 'Random Walk')
plot(y ~ x, type = 'l', chain3.df, main = 'Blockwise')
plot(y ~ x, type = 'l', chain4.df, main = 'Gibbs')
par(oldPar)

</code></pre>

<hr>
<h2 id='c10ex16.df'>Chapter 10 Example 16 data</h2><span id='topic+c10ex16.df'></span><span id='topic+ex16.df'></span>

<h3>Description</h3>

<p>A random sample of size 10 from a <code class="reqn">N(\mu, \sigma^{2})</code> distribution
where both mu and sigma are unknown parameters.
</p>


<h3>Format</h3>

<p>A data frame with 10 observations in a single variable called y
</p>

<hr>
<h2 id='chd.df'>Coronary Heart Disease Chapter 8 Example 11</h2><span id='topic+chd.df'></span>

<h3>Description</h3>

<p>The age and coronory heart disease status of 100 individuals taken from
Hosmer and Lemeshow (1989).
</p>


<h3>Format</h3>

<p>A data frame with 100 observations in two columns </p>

<table>
<tr>
 <td style="text-align: left;">
[,1] </td><td style="text-align: right;"> age </td><td style="text-align: right;"> numeric </td><td style="text-align: right;"> age in years </td>
</tr>
<tr>
 <td style="text-align: left;"> [,2] </td><td style="text-align: right;"> chd </td><td style="text-align: right;"> numeric
factor </td><td style="text-align: right;"> coronary heat disease status. Levels (1 = Yes), (0 = No) </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>


<hr>
<h2 id='credInt'>Calculate a credible interval from a numerically specified posterior CDF or
from a sample from the posterior</h2><span id='topic+credInt'></span>

<h3>Description</h3>

<p>Calculates a lower, upper, or two-sided credible interval from the numerical
posterior CDF or from a sample from the posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credInt(theta, cdf = NULL, conf = 0.95, type = "twosided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credInt_+3A_theta">theta</code></td>
<td>
<p>either a sample from the posterior density or the values over
which the the posterior CDF is specified</p>
</td></tr>
<tr><td><code id="credInt_+3A_cdf">cdf</code></td>
<td>
<p>the values of the CDF, <code class="reqn">F(\theta) =
\int_{-\infty}^{\theta}f(t).df</code> where <code class="reqn">f(t)</code> is the PDF. This only needs
to be specified if a numerically specified posterior is being used</p>
</td></tr>
<tr><td><code id="credInt_+3A_conf">conf</code></td>
<td>
<p>the desired 'confidence' level</p>
</td></tr>
<tr><td><code id="credInt_+3A_type">type</code></td>
<td>
<p>the type of interval to return, 'lower' = one sided lower bound,
'two-sided' = two - sided, or 'upper' = one sided upper bound. It is
sufficient to use 'l','t' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the elements lower.bound, uppper.bound or both
depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## commands for calculating a numerical posterior CDF.
## In this example, the likelihood is proportional to
## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
theta = seq(from = 0.001, to = 40, by = 0.001)
prior = dnorm(theta,6,3)
ppnLike = theta^1.5*exp(-theta/4)
ppnPost = prior*ppnLike
scaleFactor = sintegral(theta, ppnPost)$int
posterior = ppnPost/scaleFactor
cdf = sintegral(theta, posterior)$y
ci = credInt(theta, cdf)
par(mfrow=c(2,2))
plot(prior ~ theta, type = 'l',  main = 'Prior N(6, 9)')
plot(ppnLike ~ theta, type = 'l', main = 'Proportional likelihood')
plot(posterior ~ theta, type = 'l', main = 'Posterior')
abline(v=c(unlist(ci)))

## Use an inverse method to take a random sample of size 1000
## from the posterior
suppressWarnings({Finv = approxfun(cdf,theta)})
thetaSample = Finv(runif(1000))
ci = credInt(thetaSample)

</code></pre>

<hr>
<h2 id='credIntNum'>Calculate a credible interval from a numerically specified posterior CDF</h2><span id='topic+credIntNum'></span>

<h3>Description</h3>

<p>Calculates a lower, upper, or two-sided credible interval from the numerical
posterior CDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credIntNum(theta, cdf, conf = 0.95, type = "twosided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credIntNum_+3A_theta">theta</code></td>
<td>
<p>the values over which the the posterior CDF is specified</p>
</td></tr>
<tr><td><code id="credIntNum_+3A_cdf">cdf</code></td>
<td>
<p>the values of the CDF, <code class="reqn">F(\theta) =
\int_{-\infty}^{\theta}f(t).df</code> where <code class="reqn">f(t)</code> is the PDF.</p>
</td></tr>
<tr><td><code id="credIntNum_+3A_conf">conf</code></td>
<td>
<p>the desired 'confidence' level</p>
</td></tr>
<tr><td><code id="credIntNum_+3A_type">type</code></td>
<td>
<p>the type of interval to return, 'lower' = one sided lower bound,
'two-sided' = two - sided, or 'upper' = one sided upper bound. It is
sufficient to use 'l','t' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the elements lower.bound, uppper.bound or both
depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## commands for calculating a numerical posterior CDF.
## In this example, the likelihood is proportional to
## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
theta = seq(from = 0.001, to = 40, by = 0.001)
prior = dnorm(theta,6,3)
ppnLike = theta^1.5*exp(-theta/4)
ppnPost = prior*ppnLike
scaleFactor = sintegral(theta, ppnPost)$int
posterior = ppnPost/scaleFactor
cdf = sintegral(theta, posterior)$y
ci=credIntNum(theta, cdf)
par(mfrow=c(2,2))
plot(prior ~ theta, type = 'l',  main = 'Prior N(6, 9)')
plot(ppnLike ~ theta, type = 'l', main = 'Proportional likelihood')
plot(posterior ~ theta, type = 'l', main = 'Posterior')
abline(v=c(unlist(ci)))

</code></pre>

<hr>
<h2 id='credIntSamp'>Calculate a credible interval from a numerically specified posterior CDF</h2><span id='topic+credIntSamp'></span>

<h3>Description</h3>

<p>Calculates a lower, upper, or two-sided credible interval from the numerical
posterior CDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credIntSamp(theta, conf = 0.95, type = "twosided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credIntSamp_+3A_theta">theta</code></td>
<td>
<p>a sample from the posterior density</p>
</td></tr>
<tr><td><code id="credIntSamp_+3A_conf">conf</code></td>
<td>
<p>the desired 'confidence' level</p>
</td></tr>
<tr><td><code id="credIntSamp_+3A_type">type</code></td>
<td>
<p>the type of interval to return, 'lower' = one sided lower bound,
'two-sided' = two - sided, or 'upper' = one sided upper bound. It is
sufficient to use 'l','t' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the elements lower.bound, uppper.bound or both
depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## posterior is N(0,1)
theta = rnorm(1000)
ci=credIntSamp(theta)
plot(density(theta))
abline(v=c(unlist(ci)))

</code></pre>

<hr>
<h2 id='describe'>Give simple descriptive statistics for a matrix or a data frame</h2><span id='topic+describe'></span>

<h3>Description</h3>

<p>This function is designed to emulate the Minitab function DESCRIBE. It gives
simple descriptive statistics for a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe(x, varNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="describe_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame with numeric entries. Different variables
are represented by columns.</p>
</td></tr>
<tr><td><code id="describe_+3A_varnames">varNames</code></td>
<td>
<p>A vector of variable names for each of the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the following elements: </p>
<table role = "presentation">
<tr><td><code>N</code></td>
<td>
<p>The number
of observations for each variable</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>The sample mean for each
variable</p>
</td></tr> <tr><td><code>stdev</code></td>
<td>
<p>The sample standard deviation</p>
</td></tr> <tr><td><code>sterr</code></td>
<td>
<p>The
standard error of the mean</p>
</td></tr> <tr><td><code>min</code></td>
<td>
<p>The minimum</p>
</td></tr> <tr><td><code>q1</code></td>
<td>
<p>The lower
quartile</p>
</td></tr> <tr><td><code>med</code></td>
<td>
<p>The median</p>
</td></tr> <tr><td><code>q3</code></td>
<td>
<p>The upper quartile</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>The maximum</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(poissonTest.df)
describe(poissonTest.df)

</code></pre>

<hr>
<h2 id='GelmanRubin'>Calculate the Gelman Rubin statistic</h2><span id='topic+GelmanRubin'></span><span id='topic+GR'></span>

<h3>Description</h3>

<p>Calculate the Gelman Rubin statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GelmanRubin(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GelmanRubin_+3A_theta">theta</code></td>
<td>
<p>A matrix containing samples from at least two chains on a
parameter theta. Each chain should 2n iterations. The last n iterations will
be used to calculate the statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing n, the between chain variance B, the within chain
variance W, the estimated variance of the parameter vHat, and the Gelman
Rubin statistic <code class="reqn">R = \sqrt{vHat/W}</code>
</p>


<h3>References</h3>

<p>Gelman, A. and Rubin, D.B. (1992) 'Inference from iterative
simulations using multiple sequences with discussion.' Statistical Science
8, pp. 457-511
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## take four chains sampling from a normal mixture density
theta0 = c(0,1)
theta1 = c(3,2)
p = 0.6
candidate = c(0, 3)

v1 = normMixMH(theta0, theta1, p, candidate, steps = 200)
v2 = normMixMH(theta0, theta1, p, candidate, steps = 200)
v3 = normMixMH(theta0, theta1, p, candidate, steps = 200)
v4 = normMixMH(theta0, theta1, p, candidate, steps = 200)

theta=cbind(v1,v2,v3,v4)
GelmanRubin(theta)

</code></pre>

<hr>
<h2 id='hierMeanReg'>Hierarchical Normal Means Regression Model</h2><span id='topic+hierMeanReg'></span>

<h3>Description</h3>

<p>fits a hierarchical normal model of the form <code class="reqn">E[y_{ij}] = \mu_{j} +
\beta_{1}x_{i1}+\dots+\beta_{p}x_{ip}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierMeanReg(
  design,
  priorTau,
  priorPsi,
  priorVar,
  priorBeta = NULL,
  steps = 1000,
  startValue = NULL,
  randomSeed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierMeanReg_+3A_design">design</code></td>
<td>
<p>a list with elements y = response vector, group = grouping
vector, x = matrix of covariates or NULL if there are no covariates</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_priortau">priorTau</code></td>
<td>
<p>a list with elements tau0 and v0</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_priorpsi">priorPsi</code></td>
<td>
<p>a list with elements psi0 and eta0</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_priorvar">priorVar</code></td>
<td>
<p>a list with elements s0 and kappa0</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_priorbeta">priorBeta</code></td>
<td>
<p>a list with elements b0 and bMat or NULL if x is NULL</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_steps">steps</code></td>
<td>
<p>the number of Gibbs sampling steps to take</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_startvalue">startValue</code></td>
<td>
<p>a list with possible elements tau, psi, mu, sigmasq and
beta. tau, psi and sigmasq must all be scalars. mu and beta must be vectors
with as many elements as there are groups and covariates respectively</p>
</td></tr>
<tr><td><code id="hierMeanReg_+3A_randomseed">randomSeed</code></td>
<td>
<p>a random seed for the random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with variables: </p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>Samples from the posterior
distribution of tau</p>
</td></tr> <tr><td><code>psi</code></td>
<td>
<p>Samples from the posterior distribution of
psi</p>
</td></tr> <tr><td><code>mu</code></td>
<td>
<p>Samples from the posterior distribution of mu</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Samples from the posterior distribution of beta if there are any
covariates</p>
</td></tr> <tr><td><code>sigmaSq</code></td>
<td>
<p>Samples from the posterior distribution of
<code class="reqn">\sigma^2</code></p>
</td></tr> <tr><td><code>sigma</code></td>
<td>
<p>Samples from the posterior distribution of
sigma</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
priorTau = list(tau0 = 0, v0 = 1000)
priorPsi = list(psi0 = 500, eta0 = 1)
priorVar = list(s0 = 500, kappa0 = 1)
priorBeta = list(b0 = c(0,0), bMat = matrix(c(1000,100,100,1000), ncol = 2))

data(hiermeanRegTest.df)
data.df = hiermeanRegTest.df
design = list(y = data.df$y, group = data.df$group,
               x = as.matrix(data.df[,3:4]))
r=hierMeanReg(design, priorTau, priorPsi, priorVar, priorBeta)

oldPar = par(mfrow = c(3,3))
plot(density(r$tau))
plot(density(r$psi))
plot(density(r$mu.1))
plot(density(r$mu.2))
plot(density(r$mu.3))
plot(density(r$beta.1))
plot(density(r$beta.2))
plot(density(r$sigmaSq))
par(oldPar)

## example with no covariates
priorTau = list(tau0 = 0, v0 = 1000)
priorPsi = list(psi0 = 500, eta0 = 1)
priorVar = list(s0 = 500, kappa0 = 1)

data(hiermeanRegTest.df)
data.df = hiermeanRegTest.df
design = list(y = data.df$y, group = data.df$group, x = NULL)
r=hierMeanReg(design, priorTau, priorPsi, priorVar)

oldPar = par(mfrow = c(3,2))
plot(density(r$tau))
plot(density(r$psi))
plot(density(r$mu.1))
plot(density(r$mu.2))
plot(density(r$mu.3))
plot(density(r$sigmaSq))
par(oldPar)


</code></pre>

<hr>
<h2 id='hiermeanRegTest.df'>Test data for hiermeanReg</h2><span id='topic+hiermeanRegTest.df'></span>

<h3>Description</h3>

<p>Data for testing hiermeanReg which uses Gibbs sampling on a hierarchical
normal mean model with regression on covariates
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on 4 variables.  </p>

<table>
<tr>
 <td style="text-align: right;">\
[1,] </td><td style="text-align: left;"> y </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the response vector </td>
</tr>
<tr>
 <td style="text-align: right;"> [2,] </td><td style="text-align: left;"> group </td><td style="text-align: left;">
factor </td><td style="text-align: left;"> the grouping factor levels 1-3 </td>
</tr>
<tr>
 <td style="text-align: right;"> [3,] </td><td style="text-align: left;"> x1 </td><td style="text-align: left;"> numeric
</td><td style="text-align: left;"> the first covariate </td>
</tr>
<tr>
 <td style="text-align: right;"> [4,] </td><td style="text-align: left;"> x2 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the second
covariate </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>



<h3>See Also</h3>

<p>hiermeanReg
</p>

<hr>
<h2 id='logisticTest.df'>Test data for bayesLogistic</h2><span id='topic+logisticTest.df'></span>

<h3>Description</h3>

<p>A test data set for bayesLogisticReg
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on 6 variables.  </p>

<table>
<tr>
 <td style="text-align: right;">
[1,] </td><td style="text-align: left;"> x </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the covariate </td>
</tr>
<tr>
 <td style="text-align: right;"> [2,] </td><td style="text-align: left;"> eps </td><td style="text-align: left;"> numeric
</td><td style="text-align: left;"> the error in the response </td>
</tr>
<tr>
 <td style="text-align: right;"> [3,] </td><td style="text-align: left;"> logit.p </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the
logit of the probability of success given x = 2 + 3*x + eps </td>
</tr>
<tr>
 <td style="text-align: right;"> [4,] </td><td style="text-align: left;"> p
</td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the probability of success given x </td>
</tr>
<tr>
 <td style="text-align: right;"> [5,] </td><td style="text-align: left;"> u </td><td style="text-align: left;">
numeric </td><td style="text-align: left;"> a U[0,1] random variable </td>
</tr>
<tr>
 <td style="text-align: right;"> [6,] </td><td style="text-align: left;"> y </td><td style="text-align: left;"> binary </td><td style="text-align: left;"> if
u[i]&lt;p[i] = 1, otherwise 0 </td>
</tr>

</table>



<h3>See Also</h3>

<p>bayesLogistic
</p>

<hr>
<h2 id='normGibbs'>Draw a sample from a posterior distribution of data with an unknown mean and
variance using Gibbs sampling</h2><span id='topic+normGibbs'></span>

<h3>Description</h3>

<p>normGibbs draws a Gibbs sample from the posterior distribution of the
parameters given the data fron normal distribution with unknown mean and
variance.  The prior for <code class="reqn">\mu</code> given <code class="reqn">var</code> is prior mean <code class="reqn">m0</code>
and prior variance <code class="reqn">var/n0</code> .  That means <code class="reqn">n0</code> is the 'equivalent
sample size.' The prior distribution of the variance is <code class="reqn">s0</code> times an
inverse chi-squared with <code class="reqn">kappa0</code> degrees of freedom. The joint prior is
the product <code class="reqn">g(var)g(mu|var)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normGibbs(y, steps = 1000, type = "ind", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normGibbs_+3A_y">y</code></td>
<td>
<p>A vector containing the data</p>
</td></tr>
<tr><td><code id="normGibbs_+3A_steps">steps</code></td>
<td>
<p>The number of iterations of Gibbs sampling to carry out</p>
</td></tr>
<tr><td><code id="normGibbs_+3A_type">type</code></td>
<td>
<p>Either 'ind' for sampling from an independent conjugate prior or
'joint' for sampling from a joint conjugate prior. 'i' and 'j' can be used
as compact notation</p>
</td></tr>
<tr><td><code id="normGibbs_+3A_...">...</code></td>
<td>
<p>If type = 'ind' then the user can specify the prior for
<code class="reqn">\mu</code> with a parameter priorMu which can either be a single number m0,
or m0 and n0. if m0 and n0 are not specified then m0 and n0 are 0 by
default. The user can also specify priorVar, which if given, must be a
vector with two elements s0 and kappa0. If s0 and kappa0 are not given then
they are zero by default. If type = 'joint' then priorMu must be a vector of
length two with elements m0 and sd0.  The user can also specify priorVar,
which if given, must be a vector with two elements s0 and kappa0. If s0 and
kappa0 are not given then they are zero by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing three variables </p>

<table>
<tr>
 <td style="text-align: right;"> [1,] </td><td style="text-align: left;"> mu
</td><td style="text-align: left;"> a sample from the posterior distribution of the mean </td>
</tr>
<tr>
 <td style="text-align: right;"> [2,] </td><td style="text-align: left;"> sig
</td><td style="text-align: left;"> a sample from the posterior distribution of the standard deviation </td>
</tr>
<tr>
 <td style="text-align: right;">
[3,] </td><td style="text-align: left;"> mu </td><td style="text-align: left;"> a sample from the posterior distribution of the variance =
sig^2 </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## firstly generate some random data
mu = rnorm(1)
sigma = rgamma(1,5,1)
y = rnorm(100, mu, sigma)

## A \eqn{N(10,3^2)} prior for \eqn{\mu} and a 25 times inverse chi-squared
## with one degree of freedom prior for \eqn{\sigma^2}
MCMCSampleInd = normGibbs(y, steps = 5000, priorMu = c(10,3),
                           priorVar = c(25,1))


## We can also use a joint conjugate prior for \eqn{\mu} and \eqn{\sigma^2}.
## This will be a \emph{normal}\eqn{(m,\sigma^2/n_0)} prior for \eqn{\mu} given
## the variance \eqn{\sigma^2}, and an \eqn{s0} times an \emph{inverse
## chi-squared} prior for \eqn{\sigma^2}.
MCMCSampleJoint = normGibbs(y, steps = 5000, type = 'joint',
                             priorMu = c(10,3), priorVar = c(25,1))

## Now plot the results
oldPar = par(mfrow=c(2,2))

plot(density(MCMCSampleInd$mu),xlab=expression(mu), main =
'Independent')
abline(v=mu)
plot(density(MCMCSampleInd$sig),xlab=expression(sig), main =
'Independent')
abline(v=sigma)

plot(density(MCMCSampleJoint$mu),xlab=expression(mu), main =
'Joint')
abline(v=mu)
plot(density(MCMCSampleJoint$sig),xlab=expression(sig), main =
'Joint')
abline(v=sigma)


</code></pre>

<hr>
<h2 id='normMixMH'>Sample from a normal mixture model using Metropolis-Hastings</h2><span id='topic+normMixMH'></span>

<h3>Description</h3>

<p>normMixMH uses the Metropolis-Hastings algorithm to draw a sample from a
univariate target distribution that is a mixture of two normal distributions
using an independent normal candidate density or a random walk normal
candidate density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normMixMH(
  theta0,
  theta1,
  p,
  candidate,
  steps = 1000,
  type = "ind",
  randomSeed = NULL,
  startValue = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normMixMH_+3A_theta0">theta0</code></td>
<td>
<p>A vector of length two containing the mean and standard
deviation of the first component of the normal mixture</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_theta1">theta1</code></td>
<td>
<p>A vector of length two containing the mean and standard
deviation of the second component of the normal mixture</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_p">p</code></td>
<td>
<p>A value between 0 and 1 representing the mixture proportion, so
that the true density is <code class="reqn">p\times f(\mu1,\sigma1) + (1-p)\times
f(\mu_2,\sigma_2)</code></p>
</td></tr>
<tr><td><code id="normMixMH_+3A_candidate">candidate</code></td>
<td>
<p>A vector of length two containing the mean and standard
deviation of the candidate density</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_steps">steps</code></td>
<td>
<p>The number of steps to be used in the Metropolis-Hastings
algorithm. steps must be greater than 100</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_type">type</code></td>
<td>
<p>Either 'ind' or 'rw' depending on whether a independent
candidate density or random walk candidate density is to be used. 'i' and
'r' may be used as alternative compact notation</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_randomseed">randomSeed</code></td>
<td>
<p>A seed for the random number generator. Only used when you
want the same sequence of random numbers in the chain</p>
</td></tr>
<tr><td><code id="normMixMH_+3A_startvalue">startValue</code></td>
<td>
<p>A starting value for the chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing a sample from the normal mixture distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Set up the normal mixture
theta0 = c(0,1)
theta1 = c(3,2)
p = 0.8

## Sample from an independent N(0,3^2) candidate density
candidate = c(0, 3)
MCMCsampleInd = normMixMH(theta0, theta1, p, candidate)


## If we wish to use the alternative random walk N(0, 0.5^2)
## candidate density
candidate = c(0, 0.5)
MCMCsampleRW = normMixMH(theta0, theta1, p, candidate, type = 'rw')

</code></pre>

<hr>
<h2 id='pNull'>Test a one sided hypothesis from a numerically specified posterior CDF or
from a sample from the posterior</h2><span id='topic+pNull'></span>

<h3>Description</h3>

<p>Calculates the probability of a one sided null hypothesis from a numerically
calculated posterior CDF or from a sample from the posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pNull(theta0, theta, cdf = NULL, type = "upper")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pNull_+3A_theta0">theta0</code></td>
<td>
<p>the hypothesized value, i.e. H0: theta &lt;= theta0</p>
</td></tr>
<tr><td><code id="pNull_+3A_theta">theta</code></td>
<td>
<p>a sample of values from the posterior density, or, if cdf is
not NULL then the values over which the the posterior CDF is specified</p>
</td></tr>
<tr><td><code id="pNull_+3A_cdf">cdf</code></td>
<td>
<p>the values of the CDF, <code class="reqn">F(\theta) =
\int_{-\infty}^{\theta}f(t).df</code> where <code class="reqn">f(t)</code> is the PDF.</p>
</td></tr>
<tr><td><code id="pNull_+3A_type">type</code></td>
<td>
<p>the type of probability to return, 'lower' = Pr(theta &lt;= theta0)
or 'upper' = Pr(theta &gt;= theta0). It is sufficient to use 'l' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the element prob which will be the upper or lower
tail probability depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## commands for calculating a numerical posterior CDF.
## In this example, the likelihood is proportional to
## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
theta = seq(from = 0.001, to = 40, by = 0.001)
prior = dnorm(theta,6,3)
ppnLike = theta^1.5*exp(-theta/4)
ppnPost = prior*ppnLike
scaleFactor = sintegral(theta, ppnPost)$int
posterior = ppnPost/scaleFactor
cdf = sintegral(theta, posterior)$y
pNull(15, theta, cdf)

## Use an inverse method to take a random sample of size 1000
## from the posterior
suppressWarnings({Finv = approxfun(cdf, theta)})
thetaSample = Finv(runif(1000))
pNull(15, thetaSample)

</code></pre>

<hr>
<h2 id='pnullNum'>Test a one sided hypothesis from a numerically specified posterior CDF</h2><span id='topic+pnullNum'></span>

<h3>Description</h3>

<p>Calculates the probability of a one sided null hypothesis from a numerically
calculated posterior CDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnullNum(theta0, theta, cdf, type = "upper")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnullNum_+3A_theta0">theta0</code></td>
<td>
<p>the hypothesized value, i.e. H0: theta &lt;= theta0</p>
</td></tr>
<tr><td><code id="pnullNum_+3A_theta">theta</code></td>
<td>
<p>the values over which the the posterior CDF is specified</p>
</td></tr>
<tr><td><code id="pnullNum_+3A_cdf">cdf</code></td>
<td>
<p>the values of the CDF, <code class="reqn">F(\theta) =
\int_{-\infty}^{\theta}f(t).df</code> where <code class="reqn">f(t)</code> is the PDF.</p>
</td></tr>
<tr><td><code id="pnullNum_+3A_type">type</code></td>
<td>
<p>the type of probability to return, 'lower' = Pr(theta &lt;= theta0)
or 'upper' = Pr(theta &gt;= theta0). It is sufficient to use 'l' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the element prob which will be the upper or lower
tail probability depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## commands for calculating a numerical posterior CDF.
## In this example, the likelihood is proportional to
## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
theta = seq(from = 0.001, to = 40, by = 0.001)
prior = dnorm(theta,6,3)
ppnLike = theta^1.5*exp(-theta/4)
ppnPost = prior*ppnLike
scaleFactor = sintegral(theta, ppnPost)$int
posterior = ppnPost/scaleFactor
cdf = sintegral(theta, posterior)$y
pnullNum(1, theta, cdf)

</code></pre>

<hr>
<h2 id='pnullSamp'>Test a one sided hypothesis using a sample from a posterior density</h2><span id='topic+pnullSamp'></span>

<h3>Description</h3>

<p>Calculates the probability of a one sided null hypothesis from a sample from
a posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnullSamp(theta, theta0 = 0, type = "upper")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnullSamp_+3A_theta">theta</code></td>
<td>
<p>a sample of values from a posterior density</p>
</td></tr>
<tr><td><code id="pnullSamp_+3A_theta0">theta0</code></td>
<td>
<p>the hypothesized value, i.e. H0: theta &lt;= theta0</p>
</td></tr>
<tr><td><code id="pnullSamp_+3A_type">type</code></td>
<td>
<p>the type of probability to return, 'lower' = Pr(theta &lt;= theta0)
or 'upper' = Pr(theta &gt;= theta0). It is sufficient to use 'l' or 'u'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses linear interpolation to calculate bounds for points that
may not be specified by CDF
</p>


<h3>Value</h3>

<p>a list containing the element prob which will be the upper or lower
tail probability depending on type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The posterior density is N(3,1)
theta = rnorm(1000,3)

## test whether the true mean is greater than 0 (it is obviously!)
pnullSamp(theta)

</code></pre>

<hr>
<h2 id='poissonTest.df'>A test data set for bayesPois</h2><span id='topic+poissonTest.df'></span>

<h3>Description</h3>

<p>A test data set for bayesPois. The data come from the equation
<code class="reqn">\log(\lambda_{i}) = 1 + 5x_{i} + \epsilon_{i}</code> where <code class="reqn">\epsilon_{i}</code>
comes from N(0,0.01).
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on 5 variables.  </p>

<table>
<tr>
 <td style="text-align: right;">
[1,] </td><td style="text-align: left;"> x </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> the covariate </td>
</tr>
<tr>
 <td style="text-align: right;"> [2,] </td><td style="text-align: left;"> eps </td><td style="text-align: left;"> numeric
</td><td style="text-align: left;"> the error in the log response </td>
</tr>
<tr>
 <td style="text-align: right;"> [3,] </td><td style="text-align: left;"> log.lam </td><td style="text-align: left;"> numeric </td><td style="text-align: left;">
<code class="reqn">\log(\lambda_{i}) = 1 + 5x_{i} + \epsilon_{i}</code> where <code class="reqn">\epsilon_{i}</code>
</td>
</tr>
<tr>
 <td style="text-align: right;"> [4,] </td><td style="text-align: left;"> lam </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> <code class="reqn">\exp(\log(\lambda))</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> [5,] </td><td style="text-align: left;">
y </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> a Poisson random variate with mean <code class="reqn">\lambda_{i}</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p>bayesPois
</p>

<hr>
<h2 id='sintegral'>Numerical integration using Simpson's Rule</h2><span id='topic+sintegral'></span>

<h3>Description</h3>

<p>Takes a vector of <code class="reqn">x</code> values and a corresponding set of postive
<code class="reqn">f(x)=y</code> values and evaluates the area under the curve: </p>
<p style="text-align: center;"><code class="reqn">
\int{f(x)dx} </code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sintegral(x, fx, n.pts = 256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sintegral_+3A_x">x</code></td>
<td>
<p>a sequence of <code class="reqn">x</code> values.</p>
</td></tr>
<tr><td><code id="sintegral_+3A_fx">fx</code></td>
<td>
<p>the value of the function to be integrated at <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="sintegral_+3A_n.pts">n.pts</code></td>
<td>
<p>the number of points to be used in the integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the following elements </p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the x-values at
which the integral has been evaluated</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>the cummulative integral</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>the value of the integral over the whole range</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## integrate the normal density from -3 to 3
x=seq(-3,3,length=100)
fx=dnorm(x)
estimate=sintegral(x,fx)$int
true.val=diff(pnorm(c(-3,3)))
cat(paste('Absolute error :',round(abs(estimate-true.val),7),'\n'))
cat(paste('Relative percentage error :', 100*round((abs(estimate-true.val)/true.val),6),'%\n'))

</code></pre>

<hr>
<h2 id='thin'>Thin an MCMC sample</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p>Thins the output from an MCMC process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thin_+3A_x">x</code></td>
<td>
<p>A vector, matrix or data.frame containing output from an MCMC
sampling scheme</p>
</td></tr>
<tr><td><code id="thin_+3A_k">k</code></td>
<td>
<p>An integer. This function takes every kth element from x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note this function does not check to see if k is sensible.
</p>


<h3>Value</h3>

<p>A thinned vector, matrix or data frame containing every kth element
of x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A blockwise Metropolis-Hastings chain of 1000 elements, thinned to
## 5th element
##

MCMCSampleBW = bivnormMH(0.9, type = 'block')
MCMCSampleBW = thin(MCMCSampleBW, 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
