<!DOCTYPE html><html><head><title>Help for package gRaven</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRaven}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gRaven-package'><p>Bayes Nets: 'RHugin' Emulation with 'gRain'</p></a></li>
<li><a href='#add.edge'><p>Add or Delete Edge(s) in a gRaven domain</p></a></li>
<li><a href='#add.node'><p>Add or Delete Node in a gRaven domain</p></a></li>
<li><a href='#compile.gRaven'><p>Compile a gRaven domain</p></a></li>
<li><a href='#compress'><p>Dummy network compression routine</p></a></li>
<li><a href='#get.belief'><p>Get beliefs in a gRaven domain</p></a></li>
<li><a href='#get.nodes'><p>Get the nodes of a gRaven domain</p></a></li>
<li><a href='#get.normalization.constant'><p>Get the normalisation constant of a gRaven domain</p></a></li>
<li><a href='#get.parents'><p>Get the parents of a node in a gRaven domain</p></a></li>
<li><a href='#get.states'><p>Get states, edges and children in a gRaven domain</p></a></li>
<li><a href='#hugin.domain'><p>Create or Clone a gRaven Domain</p></a></li>
<li><a href='#initialize.domain'><p>Re-initialise a gRaven domain</p></a></li>
<li><a href='#list.domains'><p>List gRaven domain Objects</p></a></li>
<li><a href='#map.configurations'><p>Get belief in a gRaven domain</p></a></li>
<li><a href='#print.gRaven'><p>Print a gRaven domain</p></a></li>
<li><a href='#propagate.gRaven'><p>Propagate method for a gRaven domain</p></a></li>
<li><a href='#set.finding'><p>Set, retract and inspect findings</p></a></li>
<li><a href='#set.table'><p>Set or get CPT in a gRaven domain</p></a></li>
<li><a href='#simulate.gRaven'><p> method for a gRaven domain</p></a></li>
<li><a href='#summary.gRaven'><p>Summary method for a gRaven domain</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayes Nets: 'RHugin' Emulation with 'gRain'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Green &lt;P.J.Green@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrappers for functions in the 'gRain' package to emulate some 'RHugin' 
  functionality, allowing the building of Bayesian networks consisting on discrete 
  chance nodes incrementally, through   adding nodes, edges and conditional probability 
  tables, the setting of evidence,   both 'hard' (boolean) or 'soft' (likelihoods), 
  querying marginal probabilities   and normalizing constants, and generating sets of
  high-probability configurations. Computations will typically not be so fast as they are
  with 'RHugin', but this package should assist users without access to 'Hugin' to use
  code written to use 'RHugin'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>gRain (&ge; 1.3.12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gRbase, methods, rlang</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-21 12:39:24 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Green [aut, cre],
  Therese Graversen [ctb],
  Soren Hojsgaard [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-21 23:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='gRaven-package'>Bayes Nets: 'RHugin' Emulation with 'gRain'</h2><span id='topic+gRaven-package'></span><span id='topic+gRaven'></span>

<h3>Description</h3>

<p>Wrappers for functions in the 'gRain' package to emulate some 'RHugin' 
  functionality, allowing the building of Bayesian networks consisting on discrete 
  chance nodes incrementally, through   adding nodes, edges and conditional probability 
  tables, the setting of evidence,   both 'hard' (boolean) or 'soft' (likelihoods), 
  querying marginal probabilities   and normalizing constants, and generating sets of
  high-probability configurations. Computations will typically not be so fast as they are
  with 'RHugin', but this package should assist users without access to 'Hugin' to use
  code written to use 'RHugin'.</p>


<h3>Author(s)</h3>

<p>Maintainer: Peter Green &lt;P.J.Green@bristol.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gRaven)
rm(list=ls(all=TRUE))

yn &lt;- c("yes","no")
chest&lt;-hugin.domain()

add.node(chest,"asia",states=yn)
add.node(chest,"tub",states=yn)
add.node(chest,"smoke",states=yn)
add.node(chest,"lung",states=yn)
add.node(chest,"bronc",states=yn)
add.node(chest,"either",states=yn)
add.node(chest,"xray",states=yn)
add.node(chest,"dysp",states=yn)

add.edge(chest,"tub","asia")
add.edge(chest,"lung","smoke")
add.edge(chest,"bronc","smoke")
add.edge(chest,"either","lung")
add.edge(chest,"either","tub")
add.edge(chest,"xray","either")
add.edge(chest,"dysp","bronc")
add.edge(chest,"dysp","either")

set.table(chest,"asia",c(0.01,0.99))
set.table(chest,"tub",c(0.05,0.95,0.01,0.99))
set.table(chest,"smoke",c(0.5,0.5))
set.table(chest,"lung",c(0.1,0.9,0.01,0.99))
set.table(chest,"bronc",c(0.6,0.4,0.3,0.7))
set.table(chest,"either",c(1,0,1,0,1,0,0,1))
set.table(chest,"xray",c(0.98,0.02,0.05,0.95))
set.table(chest,"dysp",c(0.9,0.1,0.7,0.3,0.8,0.2,0.1,0.9))

chest
get.nodes(chest)
chest$states
sapply(get.nodes(chest),function(x) get.parents(chest,x))
compile(chest)
chest
get.belief(chest,"asia")
get.belief(chest,"tub")
get.belief(chest,"lung")
get.belief(chest,"bronc")
sapply(get.nodes(chest),function(x) get.belief(chest,x)) 

c2&lt;-clone.domain(chest)

set.finding(chest,"asia","yes")
set.finding(chest,"dysp","yes")
propagate(chest)

get.belief(chest,"asia")
get.belief(chest,"tub")
get.belief(chest,"lung")
get.belief(chest,"bronc")

pEvidence(chest$net)
get.normalization.constant(chest)

pEvidence(c2$net,evidence=list(asia="yes",dysp="yes"))
get.normalization.constant(c2)
</code></pre>

<hr>
<h2 id='add.edge'>Add or Delete Edge(s) in a gRaven domain</h2><span id='topic+add.edge'></span><span id='topic+delete.edge'></span>

<h3>Description</h3>

<p>Add or delete a directed edge from one or more parents.</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.edge(domain, child, parent)
delete.edge(domain, child, parent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.edge_+3A_domain">domain</code></td>
<td>
<p>name of a gRaven domain</p>
</td></tr>
<tr><td><code id="add.edge_+3A_child">child</code></td>
<td>
<p>a character string containing the name of the child node.</p>
</td></tr>
<tr><td><code id="add.edge_+3A_parent">parent</code></td>
<td>
<p>a character string specifying by name the parent nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates function of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Differences from RHugin</h3>

<p>Deleting an edge nullifies the CPT for node n, if any.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(chest.setup,package="gRaven")
chest
delete.edge(chest,"tub","asia")
add.edge(chest,"bronc","asia")
chest
</code></pre>

<hr>
<h2 id='add.node'>Add or Delete Node in a gRaven domain</h2><span id='topic+add.node'></span><span id='topic+delete.node'></span>

<h3>Description</h3>

<p>Add or delete a node in a gRaven domain.</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.node(domain, name, category = c("chance", 
    "decision", "utility", "function"), kind = c("discrete", "continuous", "other"), 
    subtype, states)
delete.node(domain, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.node_+3A_domain">domain</code></td>
<td>
<p>name of a gRaven domain</p>
</td></tr>
<tr><td><code id="add.node_+3A_name">name</code></td>
<td>
<p>a character string containing the name of the node to be added or deleted</p>
</td></tr>
<tr><td><code id="add.node_+3A_category">category</code></td>
<td>
<p>a character string specifying the category of the node</p>
</td></tr>
<tr><td><code id="add.node_+3A_kind">kind</code></td>
<td>
<p>a character string specifying the kind of the node</p>
</td></tr>
<tr><td><code id="add.node_+3A_subtype">subtype</code></td>
<td>
<p>a character string, 'labeled', 'numbered' or 'boolean'</p>
</td></tr>
<tr><td><code id="add.node_+3A_states">states</code></td>
<td>
<p>a character, numeric or logical vector listing the states for this node</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates functions of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions, <code>delete.node</code> deletes the specified node and all incident edges; nullifies all corresponding CPTs.</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Differences from RHugin</h3>

<p>Only discrete chance nodes are currently handled in <code>gRaven</code>.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(chest.setup,package="gRaven")
chest
add.node(chest,'dummy',states=1:3)
delete.node(chest,'either')
chest
</code></pre>

<hr>
<h2 id='compile.gRaven'>Compile a gRaven domain</h2><span id='topic+compile.gRaven'></span><span id='topic+check.compiled'></span>

<h3>Description</h3>

<p>Compile a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gRaven'
compile(object, ...)
check.compiled(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile.gRaven_+3A_object">object</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="compile.gRaven_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="compiler.html#topic+compile">compile</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check.compiled</code> compiles the domain if necessary, having first ensured that necessary information such as <code>cptables</code> is in place. If the domain is already compiled, <code>compile</code> triggers a warning, but proceeds to re-initialise the <code>grain</code> object <code>domain$net</code>, in particular deleting any evidence set.
</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>chest&lt;-hugin.domain()
add.node(chest,"asia",states=c("yes","no"))
add.node(chest,"tub",states=c("yes","no"))
add.edge(chest,"tub","asia")
chest
compile(chest)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)
chest$nodes
chest$states
chest$parents
</code></pre>

<hr>
<h2 id='compress'>Dummy network compression routine</h2><span id='topic+compress'></span>

<h3>Description</h3>

<p>Dummy routine.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress(domain)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>compression in the sense used in Hugin is not available in
gRain, so this function has no effect.</p>


<h3>Value</h3>

<p>1</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
compile(chest)
compress(chest)
</code></pre>

<hr>
<h2 id='get.belief'>Get beliefs in a gRaven domain</h2><span id='topic+get.belief'></span><span id='topic+get.marginal'></span>

<h3>Description</h3>

<p>Get beliefs (marginal joint probabilities) in a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.belief(domain, nodes)
get.marginal(domain, nodes, class = c("data.frame", "table", "ftable", "numeric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.belief_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="get.belief_+3A_nodes">nodes</code></td>
<td>
<p>character vector of names of nodes</p>
</td></tr>
<tr><td><code id="get.belief_+3A_class">class</code></td>
<td>
<p>desired class of output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates functions of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions. Unlike with <code>RHugin</code>, <code>gRaven</code> conditions on all entered evidence in reporting probabilities, not only propagated evidence.</p>


<h3>Value</h3>

<p>For <code>get.marginal</code>, a list with one component &quot;table&quot; which is a data frame, table, flat table or numeric vector of marginal joint probabilities, as specified by <code>class</code>. 
For <code>get.belief</code>, a vector in the case of a single node (if there is no evidence on that node. a vector of ones), otherwise as <code>get.marginal</code>. </p>


<h3>Differences from RHugin</h3>

<p><code>get.belief</code> handles more than one node at a time. </p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
compile(chest)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)
get.belief(chest,"asia")
get.belief(chest,"tub")
get.marginal(chest,c('asia','xray','tub'))
</code></pre>

<hr>
<h2 id='get.nodes'>Get the nodes of a gRaven domain</h2><span id='topic+get.nodes'></span>

<h3>Description</h3>

<p>Get the nodes of a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.nodes(domain)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.nodes_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates function of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions</p>


<h3>Value</h3>

<p>Character vector of node names.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
get.nodes(chest)
chest$states
sapply(get.nodes(chest),function(x) get.parents(chest,x))
</code></pre>

<hr>
<h2 id='get.normalization.constant'>Get the normalisation constant of a gRaven domain</h2><span id='topic+get.normalization.constant'></span>

<h3>Description</h3>

<p>Get the normalisation constant of a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.normalization.constant(domain, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.normalization.constant_+3A_domain">domain</code></td>
<td>

<p>name of a gRaven domain
</p>
</td></tr>
<tr><td><code id="get.normalization.constant_+3A_log">log</code></td>
<td>

<p>logical, should constant be returned on log scale?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the value of the normalisation constant (or its logarithm). If no evidence has been entered, the constant is defined as 1.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>yn &lt;- c("yes","no")
chest&lt;-hugin.domain()

add.node(chest,"asia",states=yn)
add.node(chest,"tub",states=yn)
add.node(chest,"smoke",states=yn)
add.node(chest,"lung",states=yn)
add.node(chest,"bronc",states=yn)
add.node(chest,"either",states=yn)
add.node(chest,"xray",states=yn)
add.node(chest,"dysp",states=yn)

add.edge(chest,"tub","asia")
add.edge(chest,"lung","smoke")
add.edge(chest,"bronc","smoke")
add.edge(chest,"either","lung")
add.edge(chest,"either","tub")
add.edge(chest,"xray","either")
add.edge(chest,"dysp","bronc")
add.edge(chest,"dysp","either")

set.table(chest,"asia",c(0.01,0.99))
set.table(chest,"tub",c(0.05,0.95,0.01,0.99))
set.table(chest,"smoke",c(0.5,0.5))
set.table(chest,"lung",c(0.1,0.9,0.01,0.99))
set.table(chest,"bronc",c(0.6,0.4,0.3,0.7))
set.table(chest,"either",c(1,0,1,0,1,0,0,1))
set.table(chest,"xray",c(0.98,0.02,0.05,0.95))
set.table(chest,"dysp",c(0.9,0.1,0.7,0.3,0.8,0.2,0.1,0.9))

compile(chest)
get.normalization.constant(chest)

set.finding(chest,"asia","yes")
set.finding(chest,"dysp","yes")
get.normalization.constant(chest)
</code></pre>

<hr>
<h2 id='get.parents'>Get the parents of a node in a gRaven domain</h2><span id='topic+get.parents'></span>

<h3>Description</h3>

<p>Get the parents of a node in a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.parents(domain, n, type = "parents")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.parents_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="get.parents_+3A_n">n</code></td>
<td>
<p>name of node</p>
</td></tr>
<tr><td><code id="get.parents_+3A_type">type</code></td>
<td>
<p>only &quot;parents&quot; is currently accepted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of character vectors of names of parents.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
get.nodes(chest)
chest$states
sapply(get.nodes(chest),function(x) get.parents(chest,x))
</code></pre>

<hr>
<h2 id='get.states'>Get states, edges and children in a gRaven domain</h2><span id='topic+get.states'></span><span id='topic+get.children'></span><span id='topic+get.edges'></span>

<h3>Description</h3>

<p>Get states, edges and children in a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.states(domain, nodes=domain$nodes)
get.children(domain, nodes)
get.edges(domain, nodes=domain$nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.states_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="get.states_+3A_nodes">nodes</code></td>
<td>
<p>name of node(s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates functions of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions</p>


<h3>Value</h3>

<p>For <code>get.states</code>, vector of state values. For <code>get.edges</code>,
a list with one element for each node in <code>domain</code>. Each element is in turn a list with a single element <code>edges</code> which is a character vector of names of the node's children.
An empty vector indicates that the node has no children. For <code>get.children</code>,
character vector of children's node names in the case of a single node, otherwise list of children of each node, each element being a character vector of names of the node's children.
</p>


<h3>Differences from RHugin</h3>

<p>get.states and get.children allow more than one node; get.edges allows selecting nodes.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
get.states(chest,"asia")
get.children(chest,"asia")
get.edges(chest)
</code></pre>

<hr>
<h2 id='hugin.domain'>Create or Clone a gRaven Domain</h2><span id='topic+hugin.domain'></span><span id='topic+clone.domain'></span>

<h3>Description</h3>

<p>Create or Clone a gRaven domain object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hugin.domain()
clone.domain(domain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hugin.domain_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates functions of the same name in the <code>RHugin</code> package. A gRaven domain is an environment, with additional class attribute 'gRaven'. The environment holds structures such as <code>nodes</code>, <code>states</code>, <code>parents</code> and <code>cptables</code>, populated incrementally by functions in the package, preparing the information needed by the <code>gRain</code> package to create and manipulate the structure <code>net</code> in the domain, which is a <code>grain</code> object.</p>


<h3>Value</h3>

<p>character string naming a gRaven domain</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>chest&lt;-hugin.domain()

yn &lt;- c("yes","no")
add.node(chest,"asia",states=yn)
add.node(chest,"smoke",states=yn)
add.node(chest,"tub",states=yn)
add.node(chest,"lung",states=yn)
add.node(chest,"either",states=yn)

add.edge(chest,"tub","asia")
add.edge(chest,"lung","smoke")
add.edge(chest,"either",c("lung","tub"))

set.table(chest,"asia",c(0.01,0.99))
set.table(chest,"tub",c(0.05,0.95,0.01,0.99))
set.table(chest,"smoke",c(0.5,0.5))
set.table(chest,"lung",c(0.1,0.9,0.01,0.99))
set.table(chest,"either",c(1,0,1,0,1,0,0,1))

chest

chest2&lt;-clone.domain(chest)

add.node(chest2,"bronc",states=yn)
add.node(chest2,"dysp",states=yn)
add.node(chest2,"xray",states=yn)

add.edge(chest2,"bronc","smoke")
add.edge(chest2,"dysp",c("bronc","either"))
add.edge(chest2,"xray","either")

set.table(chest2,"bronc",c(0.6,0.4,0.3,0.7))
set.table(chest2,"dysp",c(0.9,0.1,0.7,0.3,0.8,0.2,0.1,0.9))
set.table(chest2,"xray",c(0.98,0.02,0.05,0.95))

chest2
</code></pre>

<hr>
<h2 id='initialize.domain'>Re-initialise a gRaven domain</h2><span id='topic+initialize.domain'></span>

<h3>Description</h3>

<p>Re-initialise a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize.domain(domain)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize.domain_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates function of the same name in the <code>RHugin</code> package.
Restores the domain to the state it was in after the call to <code>compile</code>, in particular erasing all entered evidence.</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
compile(chest)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)
sapply(get.nodes(chest),function(x) get.belief(chest,x)) 
get.normalization.constant(chest)

initialize.domain(chest)
sapply(get.nodes(chest),function(x) get.belief(chest,x)) 
get.normalization.constant(chest)
</code></pre>

<hr>
<h2 id='list.domains'>List gRaven domain Objects</h2><span id='topic+list.domains'></span>

<h3>Description</h3>

<p>List gRaven domain Objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.domains(print=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.domains_+3A_print">print</code></td>
<td>
<p>logical, should list of domains be output to console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gRaven domains are R environment objects, with named slots typically including nodes, parents, cptables and net, where the net component is a <code>gRain</code> <code>grain</code> object. The domains that this function finds and lists are all the objects in .GlobalEnv of class &quot;gRaven&quot;, and all those objects in this class that are components of a component named 'domains' of a list object in .GlobalEnv.</p>


<h3>Value</h3>

<p>The function invisibly returns a character vector of the domain names found.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(chest,package="gRaven")
chest
chest2&lt;-clone.domain(chest)
chest2

set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)
get.belief(chest,"asia")
get.belief(chest,"tub")

propagate(chest2)
get.belief(chest2,"asia")
get.belief(chest2,"tub")

list.domains()
</code></pre>

<hr>
<h2 id='map.configurations'>Get belief in a gRaven domain</h2><span id='topic+map.configurations'></span>

<h3>Description</h3>

<p>Find the configurations of the specified nodes that occur with probability <code>pmin</code> or greater. These configurations are known as most probable configurations or maximum a posteriori (MAP) configurations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.configurations(domain, nodes, pmin)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.configurations_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="map.configurations_+3A_nodes">nodes</code></td>
<td>
<p>character vector of names of nodes</p>
</td></tr>
<tr><td><code id="map.configurations_+3A_pmin">pmin</code></td>
<td>
<p>a single numeric value between 0 and 1 specifying the minimum probability for the most probable configurations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emulates function of the same name in the <code>RHugin</code> package by calls to <code>gRain</code> functions</p>


<h3>Value</h3>

<p>Data.frame with one column for each node in <code>nodes</code>. Each row contains a most probable configuration. The final column of the data.frame (<code>Prob</code>) gives the probability of the configuration.</p>


<h3>Author(s)</h3>

<p>Therese Graversen, <a href="mailto:theg@itu.dk">theg@itu.dk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
map.configurations(chest,c("lung","bronc"),0.0001)
</code></pre>

<hr>
<h2 id='print.gRaven'>Print a gRaven domain</h2><span id='topic+print.gRaven'></span>

<h3>Description</h3>

<p>Print method for a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gRaven'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gRaven_+3A_x">x</code></td>
<td>
<p>gRaven domain</p>
</td></tr>
<tr><td><code id="print.gRaven_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints summary information describing the domain.</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(chest,package="gRaven")
print(chest)
</code></pre>

<hr>
<h2 id='propagate.gRaven'>Propagate method for a gRaven domain</h2><span id='topic+propagate.gRaven'></span>

<h3>Description</h3>

<p>Propagate method for a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gRaven'
propagate(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagate.gRaven_+3A_object">object</code></td>
<td>
<p>character string, name of gRaven domain</p>
</td></tr>
<tr><td><code id="propagate.gRaven_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="gRbase.html#topic+propagate">propagate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Propagates all previously entered evidence through the network. This call is required by functions such as <code>get.belief</code> and <code>map.configurations</code>, but not before <code>get.normalization.constant</code>. In the implementation, findings will have been accumulated in the variable net$cache in the domain, by calls to <code>set.finding</code>, and are moved to net$evid by the <code>propagate</code> function.</p>


<h3>Value</h3>

<p>a NULL value is invisibly returned.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
compile(chest)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)
get.belief(chest,"asia")
get.belief(chest,"tub")
</code></pre>

<hr>
<h2 id='set.finding'>Set, retract and inspect findings</h2><span id='topic+set.finding'></span><span id='topic+retract'></span><span id='topic+get.finding'></span>

<h3>Description</h3>

<p>Set, retract and inspect findings</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.finding(domain, node, finding)
retract(domain, nodes=domain$nodes)
get.finding(domain, nodes=domain$nodes, type = c("entered", "propagated"), 
	namestates=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.finding_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="set.finding_+3A_node">node</code></td>
<td>
<p>name of node</p>
</td></tr>
<tr><td><code id="set.finding_+3A_nodes">nodes</code></td>
<td>
<p>character vector naming one or mode nodes</p>
</td></tr>
<tr><td><code id="set.finding_+3A_finding">finding</code></td>
<td>
<p>either a state of node <code>node</code> or a probability distribution over the states, or other non-negative vector of that length.</p>
</td></tr>
<tr><td><code id="set.finding_+3A_type">type</code></td>
<td>
<p>character vector of one or more options to select between evidence entered before or after most recent propagation</p>
</td></tr>
<tr><td><code id="set.finding_+3A_namestates">namestates</code></td>
<td>
<p>logical, should output have the states labelled</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type</code>, partial matching is used.
</p>


<h3>Value</h3>

<p>For <code>set.finding</code> and <code>retract</code>, a NULL value is invisibly returned. For <code>get.finding</code>, the likelihood vector is invisibly returned for each specified node, in a format governed by <code>namestates</code>. This is a named vector in the case of a single node, otherwise a list of such vectors. For a single node, in the absence of any evidence, a named vectors of 1's is returned.</p>


<h3>Differences from RHugin</h3>

<p>Findings (or evidence) are handled differently in <code>gRaven</code> (and <code>gRain</code>) than in <code>RHugin</code>, and that is reflected in differences in results from these functions, especially <code>get.finding</code>. For <code>set.finding</code> in <code>gRaven</code>, the <code>case</code> argument is not supported. For <code>get.finding</code> in both packages, previously-set evidence is displayed as a non-negative vector indexed by the states, typically a probability distribution; two enhancements in <code>gRaven</code> are that findings on more than one node can be displayed, and that the format of the output can be controlled by <code>namestates</code>. In <code>gRaven</code> when new evidence is set by <code>set.finding</code>, it replaces any existing evidence on the same node, and all existing evidence on all nodes is &quot;unpropagated&quot;. Evidence is held in a data structure <code>cache</code> until propagation, when it is moved to <code>evid</code>; these names are used in labelling the output from <code>get.finding</code>. Finally if no evidence has been entered on a node, <code>RHugin</code> reports a vector of all ones, while <code>gRaven</code> returns such a vector invisibly.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(chest,package="gRaven",echo=FALSE)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
propagate(chest)

get.belief(chest,"asia")
get.belief(chest,"tub")
get.finding(chest)

retract(chest,"dysp")
get.belief(chest,"tub")
get.finding(chest)
</code></pre>

<hr>
<h2 id='set.table'>Set or get CPT in a gRaven domain</h2><span id='topic+set.table'></span><span id='topic+get.table'></span>

<h3>Description</h3>

<p>Set or get CPT in a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.table(domain, n, tab = 1, type = c("cpt", "experience", 
    "fading"))
get.table(domain, n, type = c("cpt", "experience", 
    "fading"), class = c("data.frame", "table", 
    "ftable", "numeric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.table_+3A_domain">domain</code></td>
<td>
<p>name of gRaven domain</p>
</td></tr>
<tr><td><code id="set.table_+3A_n">n</code></td>
<td>
<p>name of node</p>
</td></tr>
<tr><td><code id="set.table_+3A_tab">tab</code></td>
<td>
<p>values of conditional probabilties</p>
</td></tr>  
<tr><td><code id="set.table_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of table to set.</p>
</td></tr>
<tr><td><code id="set.table_+3A_class">class</code></td>
<td>
<p>a character string specifying the class of the returned table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>set.table</code>, a NULL value is invisibly returned; for <code>get.table</code>, an object of required class.</p>


<h3>Differences from RHugin</h3>

<p>Only type=&quot;cpt&quot; and class=&quot;data.frame&quot; are currently implemented in <code>gRaven</code>.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>chest&lt;-hugin.domain()
add.node(chest,"asia",states=c("yes","no"))
add.node(chest,"tub",states=c("yes","no"))
add.edge(chest,"tub","asia")
compile(chest)
chest
get.table(chest,"asia")
set.table(chest,"asia",c(0.01,0.99))
get.table(chest,"asia")
</code></pre>

<hr>
<h2 id='simulate.gRaven'> method for a gRaven domain</h2><span id='topic+simulate.gRaven'></span>

<h3>Description</h3>

<p>Simulate method for a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gRaven'
simulate(object, nsim = 1, seed = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gRaven_+3A_object">object</code></td>
<td>
<p>character string, name of gRaven domain</p>
</td></tr>
<tr><td><code id="simulate.gRaven_+3A_nsim">nsim</code></td>
<td>
<p>Number of cases to simulate</p>
</td></tr>
<tr><td><code id="simulate.gRaven_+3A_seed">seed</code></td>
<td>
<p>An optional integer controlling the random number generatation</p>
</td></tr>
<tr><td><code id="simulate.gRaven_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="stats.html#topic+simulate">simulate</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame.</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
compile(chest)
chest
set.finding(chest,"asia","yes")
set.finding(chest,"dysp","no")
newdata&lt;-simulate(chest,100)
head(newdata)
</code></pre>

<hr>
<h2 id='summary.gRaven'>Summary method for a gRaven domain</h2><span id='topic+summary.gRaven'></span>

<h3>Description</h3>

<p>Summary method for a gRaven domain</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gRaven'
summary(object, domain = TRUE, nodes = FALSE, jt = FALSE, print.cliques = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gRaven_+3A_object">object</code></td>
<td>
<p>character string, name of gRaven domain</p>
</td></tr>
<tr><td><code id="summary.gRaven_+3A_domain">domain</code></td>
<td>
<p>Logical, should domain be summarised</p>
</td></tr>
<tr><td><code id="summary.gRaven_+3A_jt">jt</code></td>
<td>
<p>Logical, should junction tree be summarised</p>
</td></tr>
<tr><td><code id="summary.gRaven_+3A_nodes">nodes</code></td>
<td>
<p>Logical, should nodes be summarised</p>
</td></tr>
<tr><td><code id="summary.gRaven_+3A_print.cliques">print.cliques</code></td>
<td>
<p>Logical, should cliques be printed</p>
</td></tr>
<tr><td><code id="summary.gRaven_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+summary">summary</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame.</p>


<h3>Differences from RHugin</h3>

<p>In <code>gRaven</code>, not all of the options are yet implemented, and generally the information delivered is less detailed than in the <code>RHugin</code> version.
</p>


<h3>Author(s)</h3>

<p>Peter J. Green, <a href="mailto:P.J.Green@bristol.ac.uk">P.J.Green@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>demo("chest",package="gRaven",echo=FALSE)
chest
summary(chest,jt=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
