<!DOCTYPE html><html><head><title>Help for package samplingbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {samplingbook}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#samplingbook-package'>
<p>Survey Sampling Procedures</p></a></li>
<li><a href='#election'><p>German Parliament Election Data</p></a></li>
<li><a href='#htestimate'><p>Horvitz-Thompson Estimator</p></a></li>
<li><a href='#influenza'>
<p>Population and Cases of Influenza for Administrative Districts of Germany</p></a></li>
<li><a href='#mbes'><p>Model Based Estimation</p></a></li>
<li><a href='#money'>
<p>Money Data Frame</p></a></li>
<li><a href='#pop'><p>Small Suppositious Sampling Example</p></a></li>
<li><a href='#pps.sampling'><p>Sampling with Probabilities Proportional to Size</p></a></li>
<li><a href='#sample.size.mean'><p>Sample Size Calculation for Mean Estimation</p></a></li>
<li><a href='#sample.size.prop'><p>Sample Size Calculation for Proportion Estimation</p></a></li>
<li><a href='#Smean'><p>Sampling Mean Estimation</p></a></li>
<li><a href='#Sprop'><p>Sampling Proportion Estimation</p></a></li>
<li><a href='#stratamean'><p>Stratified Sample Mean Estimation</p></a></li>
<li><a href='#stratasamp'><p>Sample Size Calculation for Stratified Sampling</p></a></li>
<li><a href='#stratasize'><p>Sample Size Determination for Stratified Sampling</p></a></li>
<li><a href='#submean'><p>Sub-sample Mean Estimation</p></a></li>
<li><a href='#tax'><p>Hypothetical Tax Refund Data Frame</p></a></li>
<li><a href='#wage'>
<p>Chinese wage data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Survey Sampling Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Juliane Manitz [aut,cre], Mark Hempelmann [ctb], Goeran Kauermann [ctb], Helmut Kuechenhoff [aut],  Shuai Shao [ctb], Cornelia Oberhauser [ctb], Nina Westerheide [ctb], Manuel Wiesenfarth [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juliane Manitz &lt;r@manitz.org&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.samplingbook.manitz.org">https://www.samplingbook.manitz.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmanitz/samplingbook/issues">https://github.com/jmanitz/samplingbook/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>pps, sampling, survey</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Sampling procedures from the book 'Stichproben - Methoden und praktische Umsetzung mit R' by Goeran Kauermann and Helmut Kuechenhoff (2010).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-02 21:23:24 UTC; M254773</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-02 21:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='samplingbook-package'>
Survey Sampling Procedures
</h2><span id='topic+samplingbook-package'></span><span id='topic+samplingbook'></span>

<h3>Description</h3>

<p>Sampling procedures from the book 'Stichproben - Methoden und praktische Umsetzung mit R' by Goeran Kauermann and Helmut Kuechenhoff (2010).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Samplingbook</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-07-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index:
</p>

<table>
<tr>
 <td style="text-align: left;">
election</td><td style="text-align: left;"> German Parliament Election Data</td>
</tr>
<tr>
 <td style="text-align: left;">
htestimate</td><td style="text-align: left;"> Horvitz-Thompson Estimator</td>
</tr>
<tr>
 <td style="text-align: left;">
influenza</td><td style="text-align: left;"> Population and Cases of Influenza in Administrative Districts of Germany</td>
</tr>
<tr>
 <td style="text-align: left;">
mbes</td><td style="text-align: left;"> Model Based Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
money</td><td style="text-align: left;"> Money Data Frame</td>
</tr>
<tr>
 <td style="text-align: left;">
pop</td><td style="text-align: left;"> Small Suppositious Sampling Example</td>
</tr>
<tr>
 <td style="text-align: left;">
pps.sampling </td><td style="text-align: left;"> Sampling with Probabilities Proportional to Size</td>
</tr>
<tr>
 <td style="text-align: left;">
sample.size.mean </td><td style="text-align: left;"> Sample Size Calculation for Mean Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
sample.size.prop </td><td style="text-align: left;"> Sample Size Calculation for Proportion Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Samplingbook-package </td><td style="text-align: left;"> Survey Sampling Procedures</td>
</tr>
<tr>
 <td style="text-align: left;">
Smean </td><td style="text-align: left;"> Sampling Mean Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Sprop </td><td style="text-align: left;"> Sampling Proportion Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
stratamean </td><td style="text-align: left;"> Stratified Sample Mean Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
stratasamp </td><td style="text-align: left;"> Sample Size Calculation for Stratified Sampling</td>
</tr>
<tr>
 <td style="text-align: left;">
tax </td><td style="text-align: left;"> Hypothetical Tax Refund Data Frame</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Author: Juliane Manitz &lt;r@manitz.org&gt;,
contributions by <br />
Mark Hempelmann &lt;mark.hempelmann@o2online.de&gt;, <br />
Goeran Kauermann &lt;gkauermann@wiwi.uni-bielefeld.de&gt;, <br />
Helmut Kuechenhoff &lt;kuechenhoff@stat.uni-muenchen.de&gt;, <br />
Shuai Shao &lt;shuai.shao@campus.lmu.de&gt;, <br />
Cornelia Oberhauser &lt;conny.oberhauser@gmx.de&gt;, <br />
Nina Westerheide &lt;nwesterheide@wiwi.uni-bielefeld.de&gt;, <br />
Manuel Wiesenfarth &lt;m.wiesenfarth@uni-goettingen.de&gt; <br /><br />
Maintainer: Juliane Manitz  &lt;r@manitz.org&gt;
</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>

<hr>
<h2 id='election'>German Parliament Election Data</h2><span id='topic+election'></span>

<h3>Description</h3>

<p>Data frame with number of citizens eligible to vote and results of the elections in 2002 and 2005 for the German Bundestag, the first chamber of the German
parliament.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(election)</code></pre>


<h3>Format</h3>

<p>A data frame with 299 observations (corresponding to constituencies) on the following 13 variables.
</p>

<dl>
<dt><code>state</code></dt><dd><p>factor, the 16 German federal states</p>
</dd>
<dt><code>eligible_02</code></dt><dd><p>number of citizens eligible to vote in 2002</p>
</dd> 
<dt><code>SPD_02</code></dt><dd><p>a numeric vector, percentage for the Social Democrats SPD in 2002</p>
</dd>
<dt><code>UNION_02</code></dt><dd><p>a numeric vector, percentage for the conservative Christian Democrats CDU/CSU in 2002</p>
</dd>
<dt><code>GREEN_02</code></dt><dd><p>a numeric vector, percentage for the Greens in 2002</p>
</dd>
<dt><code>FDP_02</code></dt><dd><p>a numeric vector, percentage for the Liberal Party FDP in 2002</p>
</dd>
<dt><code>LEFT_02</code></dt><dd><p>a numeric vector, percentage for the Left Party PDS in 2002</p>
</dd>
<dt><code>eligible_05</code></dt><dd><p>number of citizens eligible to vote in 2005</p>
</dd> 
<dt><code>SPD_05</code></dt><dd><p>a numeric vector, percentage for the Social Democrats SPD in 2005</p>
</dd>
<dt><code>UNION_05</code></dt><dd><p>a numeric vector, percentage for the conservative Christian Democrats CDU/CSU in 2005</p>
</dd>
<dt><code>GREEN_05</code></dt><dd><p>a numeric vector, percentage for the Greens in 2005</p>
</dd>
<dt><code>FDP_05</code></dt><dd><p>a numeric vector, percentage for the Liberal Party FDP in 2005</p>
</dd>
<dt><code>LEFT_05</code></dt><dd><p>a numeric vector, percentage for the Left Party in 2005</p>
</dd>
</dl>



<h3>Details</h3>

<p>German Federal Elections
</p>
<p>Half of the Members of the German Bundestag are elected directly from Germany's 299 constituencies,
the other half one on the parties' land lists. Accordingly, each voter has two votes in the elections
to the German Bundestag. The first vote, allowing voters to elect their local representatives to the
Bundestag, decides which candidates are sent to Parliament from the constituencies.
The second vote is cast for a party list. And it is this second vote that determines the relative
strengths of the parties represented in the Bundestag. At least 598 Members of the German Bundestag
are elected in this way. In addition to this, there are certain circumstances in which some
candidates win what are known as 'overhang mandates' when the seats are being distributed.
</p>
<p>The data set provides the percentage of second votes for each party, which determines the number of
seats each party gets in parliament. These percentages are calculated by the number of votes for a party divided by number
of valid votes.
</p>


<h3>Source</h3>

<p>The data is provided by the R package flexclust.
</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>
<p>Homepage of the Bundestag: http://www.bundestag.de.
</p>
<p>Friedrich Leisch. A Toolbox for K-Centroids Cluster Analysis. Computational Statistics and Data Analysis, 51 (2), 526-544, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(election)
summary(election)

# 1) Draw a simple sample of size n=20
n &lt;- 20
set.seed(67396)
index &lt;- sample(1:nrow(election), size=n)
sample1 &lt;- election[index,]
Smean(sample1$SPD_02, N=nrow(election))
# true mean
mean(election$SPD_02)

# 2) Estimate sample size to forecast proportion of SPD in election of 2005
sample.size.prop(e=0.01, P=mean(election$SPD_02), N=Inf)

# 3) Usage of previous knowledge by model based estimation
# draw sample of size n = 20
N &lt;- nrow(election)
set.seed(67396)
sample &lt;- election[sort(sample(1:N, size=20)),]
# secondary information SPD in 2002
X.mean &lt;- mean(election$SPD_02)
# forecast proportion of SPD in election of 2005
mbes(SPD_05 ~ SPD_02, data=sample, aux=X.mean, N=N, method='all')
# true value
Y.mean &lt;- mean(election$SPD_05)
Y.mean
# Use a second predictor variable
X.mean2 &lt;- c(mean(election$SPD_02),mean(election$GREEN_02))
# forecast proportion of SPD in election of 2005 with two predictors
mbes(SPD_05 ~ SPD_02+GREEN_02, data=sample, aux=X.mean2, N=N, method= 'regr')
</code></pre>

<hr>
<h2 id='htestimate'>Horvitz-Thompson Estimator</h2><span id='topic+htestimate'></span>

<h3>Description</h3>

<p>Calculates Horvitz-Thompson estimate with different methods for variance estimation such as Yates and Grundy, Hansen-Hurwitz and Hajek.</p>


<h3>Usage</h3>

<pre><code class='language-R'>htestimate(y, N, PI, pk, pik, method = 'yg')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htestimate_+3A_y">y</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="htestimate_+3A_n">N</code></td>
<td>
<p>integer for population size</p>
</td></tr>     
<tr><td><code id="htestimate_+3A_pi">PI</code></td>
<td>
<p>square matrix of second order inclusion probabilities with <code>n</code> rows and cols. It is necessary to be specified for variance estimation by methods <code>'ht'</code> and <code>'yg'</code>.</p>
</td></tr>
<tr><td><code id="htestimate_+3A_pk">pk</code></td>
<td>
<p>vector of first order inclusion probabilities of length <code>n</code> for the sample elements. It is necessary to be specified for variance estimation by methods <code>'hh'</code> and <code>'ha'</code>.</p>
</td></tr>
<tr><td><code id="htestimate_+3A_pik">pik</code></td>
<td>
<p>an optional vector of first order inclusion probabilities of length <code>N</code> for the population elements . It can be used for variance estimation by method <code>'ha'</code>.</p>
</td></tr>
<tr><td><code id="htestimate_+3A_method">method</code></td>
<td>
<p>method to be used for variance estimation. Options are <code>'yg'</code> (Yates and Grundy) and <code>'ht'</code> (Horvitz-Thompson), approximate options are <code>'hh'</code> (Hansen-Hurwitz) and <code>'ha'</code> (Hajek).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For using methods <code>'yg'</code> or <code>'ht'</code> has to be provided matrix <code>PI</code>, and for <code>'hh'</code> and <code>'ha'</code> has to be specified vector <code>pk</code> of inclusion probabilities. 
Additionally, for Hajek method <code>'ha'</code> can be specified <code>pik</code>. Unless, an approximate Hajek method is used.
</p>


<h3>Value</h3>

<p>The function <code>htestimate</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>y</code> observations, <code>N</code> population size, <code>PI</code> inclusion probabilities, <code>pk</code> inclusion probabilities of sample, <code>pik</code> full inclusion probabilities and <code>method</code> method for variance estimation</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean estimate</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of the mean estimate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pps.sampling">pps.sampling</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(influenza)
summary(influenza)

# pps.sampling()
set.seed(108506)
pps &lt;- pps.sampling(z=influenza$population,n=20,method='midzuno')
sample &lt;- influenza[pps$sample,]
# htestimate()
N &lt;- nrow(influenza)
# exact variance estimate
PI &lt;- pps$PI
htestimate(sample$cases, N=N, PI=PI, method='yg')
htestimate(sample$cases, N=N, PI=PI, method='ht')
# approximate variance estimate
pk &lt;- pps$pik[pps$sample]
htestimate(sample$cases, N=N, pk=pk, method='hh')
pik &lt;- pps$pik
htestimate(sample$cases, N=N, pk=pk, pik=pik, method='ha')
# without pik just approximate calculation of Hajek method
htestimate(sample$cases, N=N, pk=pk, method='ha') 
# calculate confidence interval based on normal distribution for number of cases
est.ht &lt;- htestimate(sample$cases, N=N, PI=PI, method='ht')
est.ht$mean*N  
lower &lt;- est.ht$mean*N - qnorm(0.975)*N*est.ht$se
upper &lt;- est.ht$mean*N + qnorm(0.975)*N*est.ht$se
c(lower,upper) 
# true number of influenza cases
sum(influenza$cases)
</code></pre>

<hr>
<h2 id='influenza'>
Population and Cases of Influenza for Administrative Districts of Germany
</h2><span id='topic+influenza'></span>

<h3>Description</h3>

<p>The data frame <code>influenza</code> provides cases of influenza and inhabitants for administrative districts of Germany in 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(influenza)</code></pre>


<h3>Format</h3>

<p>A data frame with 424 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>district</code></dt><dd><p>a factor with levels <code>LK Aachen</code>, <code>LK Ahrweiler</code>, ..., <code>SK Zweibruecken</code>, names of administrative districts in Germany</p>
</dd> 
<dt><code>population</code></dt><dd><p>a numeric vector specifying the number of inhabitants in the specific administrative district</p>
</dd>
<dt><code>cases</code></dt><dd><p>a numeric vector specifying the number of influenza cases in the specific administrative district</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data of 2007. If you want to use the population numbers in the future, be aware of local governmental reorganizations, e.g. district unions.
</p>


<h3>Source</h3>

<p>Database SurvStat of Robert Koch-Institute. Many thanks to Hermann Claus.
</p>


<h3>References</h3>

<p>Database of Robert Koch-Institute http://www3.rki.de/SurvStat/
</p>
<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(influenza)
summary(influenza)

# 1) Usage of pps.sampling
set.seed(108506)
pps &lt;- pps.sampling(z=influenza$population,n=20,method='midzuno')
pps
sample &lt;- influenza[pps$sample,]
sample

# 2) Usage of htestimate
set.seed(108506)
pps &lt;- pps.sampling(z=influenza$population,n=20,method='midzuno')
sample &lt;- influenza[pps$sample,]
# htestimate()
N &lt;- nrow(influenza)
# exact variance estimate
PI &lt;- pps$PI
htestimate(sample$cases, N=N, PI=PI, method='ht')
htestimate(sample$cases, N=N, PI=PI, method='yg')
# approximate variance estimate
pk &lt;- pps$pik[pps$sample]
htestimate(sample$cases, N=N, pk=pk, method='hh')
pik &lt;- pps$pik
htestimate(sample$cases, N=N, pk=pk, pik=pik, method='ha')
# without pik just approximative calculation of Hajek method
htestimate(sample$cases, N=N, pk=pk, method='ha') 
# calculate confidence interval based on normal distribution for number of cases
est.ht &lt;- htestimate(sample$cases, N=N, PI=PI, method='ht')
est.ht$mean*N  
lower &lt;- est.ht$mean*N - qnorm(0.975)*N*est.ht$se
upper &lt;- est.ht$mean*N + qnorm(0.975)*N*est.ht$se
c(lower,upper) 
# true number of influenza cases
sum(influenza$cases)
</code></pre>

<hr>
<h2 id='mbes'>Model Based Estimation</h2><span id='topic+mbes'></span>

<h3>Description</h3>

<p>mbes is used for model based estimation of population means using auxiliary variables. Difference, ratio and regression estimates are available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbes(formula, data, aux, N = Inf, method = 'all', level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbes_+3A_formula">formula</code></td>
<td>
<p>object of class <code>formula</code> (or one that can be coerced to that class): symbolic description for connection between primary and secondary information</p>
</td></tr>
<tr><td><code id="mbes_+3A_data">data</code></td>
<td>
<p>data frame containing variables in the model</p>
</td></tr>
<tr><td><code id="mbes_+3A_aux">aux</code></td>
<td>
<p>known mean of auxiliary variable, which provides secondary information</p>
</td></tr>
<tr><td><code id="mbes_+3A_n">N</code></td>
<td>
<p>positive integer for population size. Default is <code>N=Inf</code>, which means that calculations are carried out without finite population correction.</p>
</td></tr>
<tr><td><code id="mbes_+3A_method">method</code></td>
<td>
<p>estimation method. Options are <code>'simple','diff','ratio','regr','all'</code>. Default is <code>method='all'</code>.</p>
</td></tr>
<tr><td><code id="mbes_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
<tr><td><code id="mbes_+3A_...">...</code></td>
<td>
<p>further options for linear regression model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>method='simple'</code> calculates the simple sample estimation without using the auxiliary variable. 
The option <code>method='diff'</code> calculates the difference estimate, <code>method='ratio'</code> the ratio estimate, and <code>method='regr'</code> the regression estimate which is based on the selected model. The option <code>method='all'</code> calculates the simple and all model based estimates. 
For methods <code>'diff'</code>, <code>'ratio'</code> and <code>'all'</code> the formula has to be <code>y~x</code> with <code>y</code> primary and <code>x</code> secondary information. 
For method <code>'regr'</code>, it is the symbolic description of the linear regression model. In this case, it can be used more than one auxiliary variable. Thus, <code>aux</code> has to be a vector of the same length as the number of auxiliary variables in order as specified in the formula.
</p>


<h3>Value</h3>

<p>The function <code>mbes</code> returns an object, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>formula</code> formula, <code>data</code> data frame, <code>aux</code> given value for mean of auxiliary variable, <code>N</code> population size, <code>type</code> type of model based estimation and <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>is a list of further information components: <code>N</code> population size, <code>n</code> sample size, <code>p</code> number of auxiliary variables, <code>aux</code> true mean of auxiliary variables in population and <code>x.mean</code> sample means of auxiliary variables</p>
</td></tr>
<tr><td><code>simple</code></td>
<td>
<p>is a list of result components, if <code>method='simple'</code> or <code>method='all'</code> is selected: <code>mean</code> mean estimate of population mean for primary information, <code>se</code> standard error of the mean estimate, and <code>ci</code> vector of confidence interval boundaries</p>
</td></tr> 
<tr><td><code>diff</code></td>
<td>
<p>is a list of result components, if <code>method='diff'</code> or <code>method='all'</code> is selected: <code>mean</code> mean estimate of population mean for primary information, <code>se</code> standard error of the mean estimate, and <code>ci</code> vector of confidence interval boundaries</p>
</td></tr> 
<tr><td><code>ratio</code></td>
<td>
<p>is a list of result components, if <code>method='ratio'</code> or <code>method='all'</code> is selected: <code>mean</code> mean estimate of population mean for primary information, <code>se</code> standard error of the mean estimate, and <code>ci</code> vector of confidence interval boundaries</p>
</td></tr> 
<tr><td><code>regr</code></td>
<td>
<p>is a list of result components, if <code>type='regr'</code> or <code>type='all'</code> is selected: <code>mean</code> mean estimate of population mean for primary information, <code>se</code> standard error of mean estimate, <code>ci</code> vector of confidence interval boundaries, and <code>model</code> underlying linear regression model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smean">Smean</a></code>, <code><a href="#topic+Sprop">Sprop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1) simple suppositious example
data(pop)
# Draw a random sample of size=3
set.seed(802016)
data &lt;- pop[sample(1:5, size=3),]
names(data) &lt;- c('id','x','y')
# difference estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='diff', level=0.95)
# ratio estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='ratio', level=0.95)
# regression estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='regr', level=0.95)

## 2) Bundestag election
data(election)
# draw sample of size n = 20
N &lt;- nrow(election)
set.seed(67396)
sample &lt;- election[sort(sample(1:N, size=20)),]
# secondary information SPD in 2002
X.mean &lt;- mean(election$SPD_02)
# forecast proportion of SPD in election of 2005
mbes(SPD_05 ~ SPD_02, data=sample, aux=X.mean, N=N, method='all')
# true value
Y.mean &lt;- mean(election$SPD_05)
Y.mean
# Use a second predictor variable
X.mean2 &lt;- c(mean(election$SPD_02),mean(election$GREEN_02))
# forecast proportion of SPD in election of 2005 with two predictors
mbes(SPD_05 ~ SPD_02+GREEN_02, data=sample, aux=X.mean2, N=N, method= 'regr')

## 3) money sample
data(money)
mu.X &lt;-  mean(money$X)
x &lt;- money$X[which(!is.na(money$y))]
y &lt;- na.omit(money$y)
# estimation
mbes(y~x, aux=mu.X, N=13, method='all')

## 4) model based two-phase sampling with mbes() 
id &lt;- 1:1000
x &lt;- rep(c(1,0,1,0),times=c(10,90,70,830))
y &lt;- rep(c(1,0,NA),times=c(15,85,900))
phase &lt;- rep(c(2,1), times=c(100,900))
data &lt;- data.frame(id,x,y,phase)
# mean of x out of first phase
mean.x &lt;- mean(data$x)
mean.x
N1 &lt;- length(data$x) 
# calculation of estimation for y 
est.y &lt;- mbes(y~x, data=data, aux=mean.x, N=N1, method='ratio')
est.y
# correction of standard error with uncertaincy in first phase
v.y &lt;- var(data$y, na.rm=TRUE)
se.y &lt;- sqrt(est.y$ratio$se^2 + v.y/N1)
se.y
# corrected confidence interval
lower &lt;- est.y$ratio$mean - qnorm(0.975)*se.y
upper &lt;- est.y$ratio$mean + qnorm(0.975)*se.y
c(lower, upper)
</code></pre>

<hr>
<h2 id='money'>
Money Data Frame
</h2><span id='topic+money'></span>

<h3>Description</h3>

<p>Data provides guesses and true values for students wallet money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(money)</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations (corresponding to the students) on the following 3 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector of identification number</p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector of secondary information, guesses of money in the wallet</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector of primary information, counted money in the wallet. <code>NA</code> means subject was not included into the sample.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In a lesson an experiment was made, in which the students were asked to guess the current amount of money in their wallet. A simple sample of these students was drawn, who counted the money in their wallet exactly. Using this secondary information, model based estimation of the population mean is possible.
</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(money)
print(money)

# Usage of mbes()
mu.X &lt;-  mean(money$X)
x &lt;- money$X[which(!is.na(money$y))]
y &lt;- na.omit(money$y)
# estimation
mbes(y~x, aux=mu.X, N=13, method='all')
</code></pre>

<hr>
<h2 id='pop'>Small Suppositious Sampling Example</h2><span id='topic+pop'></span>

<h3>Description</h3>

<p><code>pop</code> is a suppositious data frame for a small population with 5 elements. It is used for simple illustration of survey sampling
estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pop)</code></pre>


<h3>Format</h3>

<p>A data frame with 5 observations on the following 3 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector of individual identification values</p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector of first characteristic</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector of second characteristic</p>
</dd>
</dl>



<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pop)
print(pop)

## 1) Usage of Smean()
data(pop)
Y &lt;- pop$Y
Y
# Draw a random sample pop size=3
set.seed(93456)
y &lt;- sample(x = Y, size = 3)
sort(y)
# Estimation with infiniteness correction
est &lt;- Smean(y = y, N = length(pop$Y))
est

## 2) Usage of mbes()
data(pop)
# Draw a random sample of size=3
set.seed(802016)
data &lt;- pop[sample(1:5, size=3),]
names(data) &lt;- c('id','x','y')
# difference estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='diff', level=0.95)
# ratio estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='ratio', level=0.95)
# regression estimator
mbes(formula=y~x, data=data, aux=15, N=5, method='regr', level=0.95)
</code></pre>

<hr>
<h2 id='pps.sampling'>Sampling with Probabilities Proportional to Size</h2><span id='topic+pps.sampling'></span>

<h3>Description</h3>

<p>The function provides sample techniques with sampling probabilities which are proportional to the size of a quantity z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pps.sampling(z, n, id = 1:N, method = 'sampford', return.PI = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pps.sampling_+3A_z">z</code></td>
<td>
<p>vector of quantities which determine the sampling probabilities in the population</p>
</td></tr>
<tr><td><code id="pps.sampling_+3A_n">n</code></td>
<td>
<p>positive integer for sample size</p>
</td></tr>
<tr><td><code id="pps.sampling_+3A_id">id</code></td>
<td>
<p>an optional vector with identification values for population elements. Default is <code>'id = 1:N'</code>, where <code>'N'</code> is length of <code>'z'</code>.</p>
</td></tr>
<tr><td><code id="pps.sampling_+3A_method">method</code></td>
<td>
<p>the sampling method to be used. Options are <code>'sampford'</code>, <code>'tille'</code>, <code>'midzuno'</code> or <code>'madow'</code>.</p>
</td></tr>
<tr><td><code id="pps.sampling_+3A_return.pi">return.PI</code></td>
<td>
<p>logical. If <code>TRUE</code> the pairwise inclusion probabilities for all individuals in the population are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different methods vary in their run time. Therefore, <code>method='sampford'</code> is stopped if <code>N &gt; 200</code> or if <code>n/N &lt; 0.3</code>. <code>method='tille'</code> is stopped if <code>N &gt; 500</code>. 
In case of large populations use <code>method='midzuno'</code> or <code>method='madow'</code>.
</p>


<h3>Value</h3>

<p>The function <code>pps.sampling</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>z</code> vector of quantity data, <code>n</code> sample size, <code>id</code> identification values, and <code>method</code> sampling method</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>resulted sample</p>
</td></tr>
<tr><td><code>pik</code></td>
<td>
<p>inclusion probabilities</p>
</td></tr>
<tr><td><code>PI</code></td>
<td>
<p>sample second order inclusion probabilities</p>
</td></tr>
<tr><td><code>PI.full</code></td>
<td>
<p>full second order inclusion probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htestimate">htestimate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1) simple suppositious example
data &lt;- data.frame(id = 1:7, z = c(1.8, 2 ,3.2 ,2.9 ,1.5 ,2.0 ,2.2))
# Usage of pps.sampling for Sampford method
set.seed(178209)
pps.sample_sampford &lt;- pps.sampling(z=data$z, n=2, method='sampford', return.PI=FALSE)
pps.sample_sampford
# sampling elements
id.sample &lt;- pps.sample_sampford$sample
id.sample
# other methods
set.seed(178209)
pps.sample_tille &lt;- pps.sampling(z=data$z, n=2, method='tille')
pps.sample_tille
set.seed(178209)
pps.sample_midzuno &lt;- pps.sampling(z=data$z, n=2, method='midzuno')
pps.sample_midzuno
set.seed(178209)
pps.sample_madow &lt;- pps.sampling(z=data$z, n=2, method='madow')
pps.sample_madow

## 2) influenza
data(influenza)
summary(influenza)

set.seed(108506)
pps &lt;- pps.sampling(z=influenza$population,n=20,method='midzuno')
pps
sample &lt;- influenza[pps$sample,]
sample
</code></pre>

<hr>
<h2 id='sample.size.mean'>Sample Size Calculation for Mean Estimation</h2><span id='topic+sample.size.mean'></span>

<h3>Description</h3>

<p>The function <code>sample.size.mean</code> returns the sample size needed for mean estimations either with or without consideration of finite population correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.size.mean(e, S, N = Inf, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.size.mean_+3A_e">e</code></td>
<td>
<p>positive number specifying the precision which is half width of confidence interval</p>
</td></tr>
<tr><td><code id="sample.size.mean_+3A_s">S</code></td>
<td>
<p>standard deviation in population</p>
</td></tr>
<tr><td><code id="sample.size.mean_+3A_n">N</code></td>
<td>
<p>positive integer for population size. Default is <code>N=Inf</code>, which means that calculations are carried out without finite population correction.</p>
</td></tr>
<tr><td><code id="sample.size.mean_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>sample.size.mean</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>e</code> precision, <code>S</code> standard deviation in population, and <code>N</code> integer for population size</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>estimate of sample size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smean">Smean</a></code>, <code><a href="#topic+sample.size.prop">sample.size.prop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># sample size for precision e=4
sample.size.mean(e=4,S=10,N=300)
# sample size for precision e=1
sample.size.mean(e=1,S=10,N=300)
</code></pre>

<hr>
<h2 id='sample.size.prop'>Sample Size Calculation for Proportion Estimation</h2><span id='topic+sample.size.prop'></span>

<h3>Description</h3>

<p>The function <code>sample.size.prop</code> returns the sample size needed for proportion estimation either with or without consideration of finite population correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.size.prop(e, P = 0.5, N = Inf, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.size.prop_+3A_e">e</code></td>
<td>
<p>positive number specifying the precision which is half width of confidence interval</p>
</td></tr>
<tr><td><code id="sample.size.prop_+3A_p">P</code></td>
<td>
<p>expected proportion of events with domain between values 0 and 1. Default is <code>P=0.5</code>.</p>
</td></tr>
<tr><td><code id="sample.size.prop_+3A_n">N</code></td>
<td>
<p>positive integer for population size. Default is <code>N=Inf</code>, which means that calculations are carried out without finite population correction.</p>
</td></tr>
<tr><td><code id="sample.size.prop_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For meaningful calculation, precision <code>e</code> should be chosen smaller than 0.5, because the domain of <code>P</code> is between values 0 and 1. Furthermore, precision <code>e</code> should be smaller than proportion <code>P</code>, respectively <code>(1-P)</code>.
</p>


<h3>Value</h3>

<p>The function <code>sample.size.prop</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components <code>e</code> precision, <code>P</code> expected proportion, <code>N</code> population size, and <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>estimate of sample size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sprop">Sprop</a></code>, <code><a href="#topic+sample.size.mean">sample.size.mean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1) examples with different precisions
# precision 1% for election forecast of SPD in 2005
sample.size.prop(e=0.01, P=0.5, N=Inf)
data(election)
sample.size.prop(e=0.01, P=mean(election$SPD_02), N=Inf)
# precision 5% for questionnaire
sample.size.prop(e=0.05, P=0.5, N=300)
sample.size.prop(e=0.05, P=0.5, N=Inf)
# precision 10%
sample.size.prop(e=0.1, P=0.5, N=300)
sample.size.prop(e=0.1, P=0.5, N=1000)

## 2) tables in the book
# table 2.2
P_vector &lt;- c(0.2, 0.3, 0.4, 0.5)
N_vector &lt;- c(10, 100, 1000, 10000)
results &lt;- matrix(NA, ncol=4, nrow=4)
for (i in 1:length(P_vector)){
  for (j in 1:length(N_vector)){
    x &lt;- try(sample.size.prop(e=0.1, P=P_vector[i], N=N_vector[j]))
    if (class(x)=='try-error') {results[i,j] &lt;- NA}
    else {results[i,j] &lt;- x$n}
  }
}
dimnames(results) &lt;- list(paste('P=',P_vector, sep=''), paste('N=',N_vector, sep=''))
results
# table 2.3
P_vector &lt;- c(0.5, 0.1)
e_vector &lt;- c(0.1, 0.05, 0.03, 0.02, 0.01)
results &lt;- matrix(NA, ncol=2, nrow=5)
for (i in 1:length(e_vector)){
  for (j in 1:length(P_vector)){
    x &lt;- try(sample.size.prop(e=e_vector[i], P=P_vector[j], N=Inf))
    if (class(x)=='try-error') {results[i,j] &lt;- NA}
    else {results[i,j] &lt;- x$n}
  }
}
dimnames(results) &lt;- list(paste('e=',e_vector, sep=''), paste('P=',P_vector, sep=''))
results

</code></pre>

<hr>
<h2 id='Smean'>Sampling Mean Estimation</h2><span id='topic+Smean'></span>

<h3>Description</h3>

<p>The function <code>Smean</code> estimates the population mean out of simple samples either with or without consideration of finite population correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smean(y, N = Inf, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smean_+3A_y">y</code></td>
<td>
<p>vector of sample data</p>
</td></tr>
<tr><td><code id="Smean_+3A_n">N</code></td>
<td>
<p>positive integer specifying population size. Default is <code>N=Inf</code>, which means that calculations are carried out without finite population correction.</p>
</td></tr>
<tr><td><code id="Smean_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>Smean</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>y</code> vector with sample data, <code>n</code> sample size, <code>N</code> population size, <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean estimate</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of the mean estimate</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>vector of confidence interval boundaries</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sprop">Sprop</a></code>, <code><a href="#topic+sample.size.mean">sample.size.mean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pop)
Y &lt;- pop$Y
Y
# Draw a random sample of size=3
set.seed(93456)
y &lt;- sample(x = Y, size = 3)
sort(y)
# Estimation with infiniteness correction
est &lt;- Smean(y = y, N = length(pop$Y))
est
</code></pre>

<hr>
<h2 id='Sprop'>Sampling Proportion Estimation</h2><span id='topic+Sprop'></span>

<h3>Description</h3>

<p>The function <code>Sprop</code> estimates the proportion out of samples either with or without
consideration of finite population correction. Different methods for calculating 
confidence intervals for example based on binomial distribution (Agresti and 
Coull or Clopper-Pearson) or based on hypergeometric distribution are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sprop(y, m, n = length(y), N = Inf, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sprop_+3A_y">y</code></td>
<td>
<p>vector of sample data containing values 0 and 1</p>
</td></tr>
<tr><td><code id="Sprop_+3A_m">m</code></td>
<td>
<p>an optional non-negative integer for number of positive events</p>
</td></tr>
<tr><td><code id="Sprop_+3A_n">n</code></td>
<td>
<p>an optional positive integer for sample size. Default is <code>n=length(y)</code>.</p>
</td></tr>
<tr><td><code id="Sprop_+3A_n">N</code></td>
<td>
<p>positive integer for population size. Default is <code>N=Inf</code>, which means calculations are carried out without finite population correction.</p>
</td></tr>
<tr><td><code id="Sprop_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Sprop</code> can be called by usage of a data vector <code>y</code> with the observations 1 for event and 0 for failure. Moreover, it can be called by specifying the number of events <code>m</code> and trials <code>n</code>. 
</p>


<h3>Value</h3>

<p>The function <code>Sprop</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>y</code> sample data, <code>m</code> number of positive events in the sample, <code>n</code> sample size, <code>N</code> population size, <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>proportion estimate</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of the proportion estimate</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>is a list of confidence interval boundaries for proportion. <br />
In case of a finite population of size <code>N</code>, it is given <code>approx</code>, the hypergeometric confidence interval with normal distribution approximation, and <code>exact</code>, the exact hypergeometric confidence interval. <br />
If the population is very large <code>N=Inf</code>, it is calculated <code>bin</code>, the binomial confidence interval, which is asymptotic, <code>cp</code> the exact confidence interval based on binomial distribution (Clopper-Pearson), and <code>ac</code>, the asymptotic confidence interval based on binomial distribution by Wilson (Agresti and Coull (1998)).</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>In case of finite population of size <code>N</code>, it is given a list of confidence interval boundaries for number in population with <code>approx</code>, the hypergeometric confidence interval with normal distribution approximation, and <code>exact</code>, the exact hypergeometric confidence interval.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>
<p>Agresti, Alan/Coull, Brent A. (1998): Approximate Is Better than 'Exact' for Interval Estimation of Binomial Proportions. The American Statistician, Vol. 52, No. 2 , pp. 119-126.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smean">Smean</a></code>, <code><a href="#topic+sample.size.prop">sample.size.prop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) Survey in company to upgrade office climate
Sprop(m=45, n=100, N=300)
Sprop(m=2, n=100, N=300)

# 2) German opinion poll for 03/07/09 with 
# (http://www.wahlrecht.de/umfragen/politbarometer.htm)
# a) 302 of 1206 respondents who would elect SPD.
# b) 133 of 1206 respondents who would elect the Greens.
Sprop(m=302, n=1206, N=Inf)
Sprop(m=133, n=1206, N=Inf)

# 3) Rare disease of animals (sample size n=500 of N=10.000 animals, one infection)
# for 95% one sided confidence level use level=0.9
Sprop(m=1, n=500, N=10000, level=0.9)

# 4) call with data vector y
y &lt;- c(0,0,1,0,1,0,0,0,1,1,0,0,1)
Sprop(y=y, N=200)
# is the same as
Sprop(m=5, n=13, N=200)
</code></pre>

<hr>
<h2 id='stratamean'>Stratified Sample Mean Estimation</h2><span id='topic+stratamean'></span>

<h3>Description</h3>

<p>The function <code>stratamean</code> estimates the population mean out of stratified samples either with or without consideration of finite population correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratamean(y, h, Nh, wh, level = 0.95, eae = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratamean_+3A_y">y</code></td>
<td>
<p>vector of target variable.</p>
</td></tr>
<tr><td><code id="stratamean_+3A_h">h</code></td>
<td>
<p>vector of stratifying variable.</p>
</td></tr>
<tr><td><code id="stratamean_+3A_nh">Nh</code></td>
<td>
<p>vector of sizes of every stratum, which has to be supplied in alphabetical or numerical order of the categories of h.</p>
</td></tr>
<tr><td><code id="stratamean_+3A_wh">wh</code></td>
<td>
<p>vector of weights of every stratum, which has to be supplied in alphabetical or numerical order of the categories of h.</p>
</td></tr>
<tr><td><code id="stratamean_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
<tr><td><code id="stratamean_+3A_eae">eae</code></td>
<td>
<p><code>TRUE</code> for extensive output with the result in each and every stratum. Default is <code>eae=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the absolute stratum sizes <code>Nh</code> are given, the variances are calculated with finite population correction. Otherwise, if the stratum weights <code>wh</code> are given, the variances are calculated without finite population correction.
</p>


<h3>Value</h3>

<p>The function <code>stratamean</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>y</code> target variable in sample data, <code>h</code> stratifying variable in sample data, <code>Nh</code> sizes of every stratum, <code>wh</code> weights of every stratum, <code>fpc</code> finite population correction, <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean estimate for population</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of the mean estimate for population</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>vector of confidence interval boundaries for population</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shuai Shao and Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smean">Smean</a></code>, <code><a href="#topic+Sprop">Sprop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># random data
testy &lt;- rnorm(100)
testh &lt;- c(rep("male",40), rep("female",60))
stratamean(testy, testh, wh=c(0.5, 0.5))
stratamean(testy, testh, wh=c(0.5, 0.5), eae=TRUE)

# tax data
data(tax)
summary(tax)

nh &lt;- as.vector(table(tax$Class))
wh &lt;- nh/sum(nh)
stratamean(y=tax$diff, h=as.vector(tax$Class), wh=wh, eae=TRUE)
</code></pre>

<hr>
<h2 id='stratasamp'>Sample Size Calculation for Stratified Sampling</h2><span id='topic+stratasamp'></span>

<h3>Description</h3>

<p>The function <code>stratasamp</code> calculates the sample size for each stratum depending on type of allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratasamp(n, Nh, Sh = NULL, Ch = NULL, type = 'prop')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratasamp_+3A_n">n</code></td>
<td>
<p>positive integer specifying sampling size.</p>
</td></tr>
<tr><td><code id="stratasamp_+3A_nh">Nh</code></td>
<td>
<p>vector of population sizes of each stratum.</p>
</td></tr>
<tr><td><code id="stratasamp_+3A_sh">Sh</code></td>
<td>
<p>vector of standard deviation in each stratum.</p>
</td></tr>
<tr><td><code id="stratasamp_+3A_ch">Ch</code></td>
<td>
<p>vector of cost for a sample in each stratum.</p>
</td></tr>
<tr><td><code id="stratasamp_+3A_type">type</code></td>
<td>
<p>type of allocation. Default is <code>type='prop'</code> for proportional, alternatives are <code>type='opt'</code> for optimal and <code>type='costopt'</code> for cost-optimal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>stratasamp</code> returns a matrix, which lists the strata and the sizes of observation depending on type of allocation.
</p>


<h3>Author(s)</h3>

<p>Shuai Shao and Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratamean">stratamean</a></code>, <code><a href="#topic+stratasize">stratasize</a></code>, <code><a href="#topic+sample.size.mean">sample.size.mean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#random proportional stratified sample
stratasamp(n=500, Nh=c(5234,2586,649,157))
stratasamp(n=500, Nh=c(5234,2586,649,157), Sh=c(251,1165,8035,24725), type='opt')
</code></pre>

<hr>
<h2 id='stratasize'>Sample Size Determination for Stratified Sampling</h2><span id='topic+stratasize'></span>

<h3>Description</h3>

<p>The function <code>stratasize</code> determinates the total size of stratified samples depending on type of allocation and determinated by specified precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratasize(e, Nh, Sh, level = 0.95, type = 'prop')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratasize_+3A_e">e</code></td>
<td>
<p>positive number specifying sampling precision.</p>
</td></tr>
<tr><td><code id="stratasize_+3A_nh">Nh</code></td>
<td>
<p>vector of population sizes in each stratum.</p>
</td></tr>
<tr><td><code id="stratasize_+3A_sh">Sh</code></td>
<td>
<p>vector of standard deviation in each stratum.</p>
</td></tr>
<tr><td><code id="stratasize_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
<tr><td><code id="stratasize_+3A_type">type</code></td>
<td>
<p>type of allocation. Default is <code>type='prop'</code> for proportional, alternative is <code>type='opt'</code> for optimal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>stratasize</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>e</code> specified precision, <code>Nh</code> population sizes of every stratum, <code>Sh</code> standard diviation of every stratum, <code>method</code> type of allocation, <code>level</code> coverage probability for confidence intervals.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>determinated total sample size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shuai Shao</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2011): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratasamp">stratasamp</a></code>, <code><a href="#topic+stratamean">stratamean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#random proportional stratified sample
stratasize(e=0.1, Nh=c(100000,300000,600000), Sh=c(1,2,3))

#random optimal stratified sample
stratasize(e=0.1, Nh=c(100000,300000,600000), Sh=c(1,2,3), type="opt")
</code></pre>

<hr>
<h2 id='submean'>Sub-sample Mean Estimation</h2><span id='topic+submean'></span>

<h3>Description</h3>

<p>The function <code>submean</code> estimates the population mean out of sub-samples (two-stage samples) either with or without consideration of finite population correction in both stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submean(y, PSU, N, M, Nl, m.weight, n.weight, method = 'simple', level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submean_+3A_y">y</code></td>
<td>
<p>vector of target variable.</p>
</td></tr>
<tr><td><code id="submean_+3A_psu">PSU</code></td>
<td>
<p>vector of grouping variable which indicates the primary unit for each sample element.</p>
</td></tr>
<tr><td><code id="submean_+3A_n">N</code></td>
<td>
<p>positive integer specifying population size</p>
</td></tr>
<tr><td><code id="submean_+3A_m">M</code></td>
<td>
<p>positive integer specifying the number of primary units in the  population.</p>
</td></tr>
<tr><td><code id="submean_+3A_nl">Nl</code></td>
<td>
<p>vector of sample sizes in each primary unit, which has to be specified in alphabetical or numerical order of the categories of l.</p>
</td></tr>
<tr><td><code id="submean_+3A_m.weight">m.weight</code></td>
<td>
<p>vector of primary sample unit weights, which has to be specified in alphabetical or numerical order of the categories of l.</p>
</td></tr>
<tr><td><code id="submean_+3A_n.weight">n.weight</code></td>
<td>
<p>vector of secondary sample unit weights in each primary sample unit, which has to be specified in alphabetical or numerical order of the categories of l.</p>
</td></tr>
<tr><td><code id="submean_+3A_method">method</code></td>
<td>
<p>estimation method. Default is &quot;simple&quot;, alternative is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="submean_+3A_level">level</code></td>
<td>
<p>coverage probability for confidence intervals. Default is <code>level=0.95</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the absolute sizes <code>M</code> and <code>Nl</code> are given, the variances are calculated with finite population correction. Otherwise, if the weights <code>m.weight</code> and <code>n.weight</code> are given, the variances are calculated without finite population correction.
</p>


<h3>Value</h3>

<p>The function <code>submean</code> returns a value, which is a list consisting of the components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>is a list of call components: <code>y</code> target variable in sample data, <code>PSU</code> gouping variable in sample data, <code>N</code> population size, <code>M</code> number of primary population units, <code>fpc</code> finite population correction, <code>method</code> estimation method, <code>level</code> coverage probability for confidence intervals</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean estimate for population</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error of the mean estimate for population</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>vector of confidence interval boundaries for population</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shuai Shao and Juliane Manitz</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2011): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smean">Smean</a></code>, <code><a href="#topic+stratamean">stratamean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(23,33,24,25,72,74,71,37,42)
psu &lt;- as.factor(c(1,1,1,1,2,2,2,3,3))
# with finite population correction
submean(y, PSU=psu, N=700, M=23, Nl=c(100,50,75), method='ratio')
# without finite population correction
submean(y, PSU=psu, N=700, m.weight=3/23, n.weight=c(4/100,3/50,2/75), method='ratio')

# Chinese wage data
data(wage)
summary(wage)
submean(wage$Wage,PSU=wage$Region, N=990, M=33, Nl=rep(30,14))
</code></pre>

<hr>
<h2 id='tax'>Hypothetical Tax Refund Data Frame</h2><span id='topic+tax'></span>

<h3>Description</h3>

<p>Simulated tax refund data frame including the estimated and actual refund value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tax)</code></pre>


<h3>Format</h3>

<p>A data frame with 9083 observations on the following 5 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector indicating the tax payer</p>
</dd>
<dt><code>estRefund</code></dt><dd><p>a numeric vector representing the estimated value of tax refund by the tax payer</p>
</dd>
<dt><code>actRefund</code></dt><dd><p>a numeric vector representing the actual tax refund calculated by the financial authority</p>
</dd>
<dt><code>diff</code></dt><dd><p>difference between estimated and acture tax refund</p>
</dd>
<dt><code>Class</code></dt><dd><p>a factor with levels <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code> indicating the strata</p>
</dd>
</dl>


<h3>Source</h3>

<p>Due to data protection this is a simulated data set reflecting the real data.
</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tax)
summary(tax)

# illustration of stratamean
nh &lt;- as.vector(table(tax$Class))
wh &lt;- nh/sum(nh)
stratamean(y=tax$diff, h=as.vector(tax$Class), wh=wh, eae=TRUE)
</code></pre>

<hr>
<h2 id='wage'>
Chinese wage data
</h2><span id='topic+wage'></span>

<h3>Description</h3>

<p>A data frame with hypothetical Chinese wages differenciated by region and industrial sector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wage)</code></pre>


<h3>Format</h3>

<p>A data frame with 231 observations on the following 3 variables.
</p>

<dl>
<dt><code>Region</code></dt><dd><p>factor, Chinese regions with 14 levels.</p>
</dd>
<dt><code>Sector</code></dt><dd><p>factor, industrial sector with 30 levels.</p>
</dd>
<dt><code>Wage</code></dt><dd><p>a numeric vector, average wage in the region and sector measured in Chinese yuan.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is hypothetical. Its structure imitates the data in the Chinese Statistical Yearbook. The values are simulated corresponding to the distribution of the real data which are not publicly accessible.
</p>


<h3>References</h3>

<p>Kauermann, Goeran/Kuechenhoff, Helmut (2010): Stichproben. Methoden und praktische Umsetzung mit R. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Chinese wage data
data(wage)
summary(wage)
submean(wage$Wage,PSU=wage$Region, N=990, M=33, Nl=rep(30,14))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
