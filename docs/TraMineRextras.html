<!DOCTYPE html><html><head><title>Help for package TraMineRextras</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TraMineRextras}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convert'><p>Converting between graphical formats</p></a></li>
<li><a href='#createdatadiscrete'><p>Transform time to event data into a discrete data format</p></a></li>
<li><a href='#dissindic'>
<p>Sequence marginality and gain indicators.</p>
</a></li>
<li><a href='#dissvar.grp'>
<p>Discrepancy by group.</p></a></li>
<li><a href='#FCE_to_TSE'>
<p>Data conversion from Fixed Column Event format to TSE.</p></a></li>
<li><a href='#group.p'><p>Adds proportion of occurrences to each level names</p></a></li>
<li><a href='#HSPELL_to_STS'>
<p>Data conversion from Horizontal Spell to STS.</p></a></li>
<li><a href='#pamward'><p>PAM from k-solution of hierarchical clustering</p></a></li>
<li><a href='#plot.dynin'><p>Dynamic index plot</p>
</a></li>
<li><a href='#plot.emlt'><p>Emlt Plots</p>
</a></li>
<li><a href='#plot.stslist.surv'><p>Plot method for objects produced by the seqsurv function</p></a></li>
<li><a href='#polyads'><p>Polyadic data example</p></a></li>
<li><a href='#rowmode'><p>Modal state of a variable</p></a></li>
<li><a href='#seqauto'>
<p>Auto-association between states</p></a></li>
<li><a href='#seqCompare'><p>BIC and Likelihood ratio test for comparing two sequence data</p></a></li>
<li><a href='#seqcta'>
<p>Competing Trajectory Analysis (CTA)</p></a></li>
<li><a href='#seqe2stm'>
<p>Definition of an events to states matrix.</p></a></li>
<li><a href='#seqedist'><p>Distances between event sequences</p></a></li>
<li><a href='#seqedplot'>
<p>Graphical representation of a set of events sequences.</p></a></li>
<li><a href='#seqemlt'><p>Euclidean Coordinates for Longitudinal Timelines</p></a></li>
<li><a href='#seqentrans'><p>Event sequence length and number of events</p></a></li>
<li><a href='#seqerulesdisc'><p>Extract association rules using discrete time regression models</p></a></li>
<li><a href='#seqgen.missing'>
<p>Generate random missing states within a state sequence object</p></a></li>
<li><a href='#seqgranularity'>
<p>Changing sequence time granularity by aggregating positions</p></a></li>
<li><a href='#seqimplic'>
<p>Position wise group-typical states</p>
</a></li>
<li><a href='#seqindic.dyn'><p>Dynamic index</p>
</a></li>
<li><a href='#seqplot.rf'>
<p>Relative Frequency Sequence Plots.</p></a></li>
<li><a href='#seqplot.tentrop'><p>Plotting superposed transversal-entropy curves</p></a></li>
<li><a href='#seqpolyads'><p>Measuring the Degree of Within-Polyadic Similarities</p></a></li>
<li><a href='#seqrep.grp'>
<p>Finding representative sets by group and their quality statistics.</p></a></li>
<li><a href='#seqsamm'>
<p>Sequence Analysis Multistate Model (SAMM) procedure</p></a></li>
<li><a href='#seqsha'>
<p>Sequence History Analysis (SHA)</p></a></li>
<li><a href='#seqsplot'><p>Plot survival curves of the states in sequences</p></a></li>
<li><a href='#seqstart'>
<p>Aligning sequence data on a new start time.</p></a></li>
<li><a href='#seqsurv'><p>Generate a survfit object for state survival times.</p></a></li>
<li><a href='#seqtabstocc'><p>Frequencies of state co-occurrence patterns</p></a></li>
<li><a href='#sortv'><p>Sort sequences by states at the successive positions</p></a></li>
<li><a href='#toPersonPeriod'><p>Converting into person-period format.</p></a></li>
<li><a href='#TraMineRextras-package'><p> TraMineR Extension</p></a></li>
<li><a href='#TSE_to_STS'>
<p>Converting TSE data into STS (state sequences) format.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Title:</td>
<td>TraMineR Extension</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), TraMineR (&ge; 2.2-5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, survival, cluster, RColorBrewer,
colorspace, doParallel, parallel, foreach</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of ancillary functions and utilities to be used in conjunction with the 'TraMineR' package for sequence data exploration. Includes, among others, specific functions such as state survival plots, position-wise group-typical states, dynamic sequence indicators, and dissimilarities between event sequences. Also includes contributions by non-members of the TraMineR team such as the relative frequency plot and methods for polyadic data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://traminer.unige.ch/">http://traminer.unige.ch/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gilbert Ritschard &lt;gilbert.ritschard@unige.ch&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 14:17:03 UTC; grits</td>
</tr>
<tr>
<td>Author:</td>
<td>Gilbert Ritschard <a href="https://orcid.org/0000-0001-7776-0903"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, ths, cph],
  Matthias Studer <a href="https://orcid.org/0000-0002-6269-1412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Reto Buergin <a href="https://orcid.org/0000-0002-6212-1567"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tim F. Liao <a href="https://orcid.org/0000-0002-1296-7660"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Alexis Gabadinho [ctb],
  Pierre-Alexandre Fonta [ctb],
  Nicolas S. Muller [ctb],
  Patrick Rousset [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='convert'>Converting between graphical formats</h2><span id='topic+convert.g'></span>

<h3>Description</h3>

<p>Wrapper function for converting graphics with ImageMagick</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.g(path = NULL, fileroot= "*", from = "pdf",
    to = "png", create.path = TRUE, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_path">path</code></td>
<td>
<p>String: Path to the from graphic files. If <code>NULL</code> (default), the current path is used.</p>
</td></tr>
<tr><td><code id="convert_+3A_fileroot">fileroot</code></td>
<td>
<p>String: Graphic root name; default is &quot;*&quot; for all files with the <code>from</code> extension.</p>
</td></tr>
<tr><td><code id="convert_+3A_from">from</code></td>
<td>
<p>String: File type extension specifying the from format.</p>
</td></tr>
<tr><td><code id="convert_+3A_to">to</code></td>
<td>
<p>String: File type extension specifying the to format.</p>
</td></tr>
<tr><td><code id="convert_+3A_create.path">create.path</code></td>
<td>
<p>Logical: Should the output files be placed in a <code>to</code> subfolder.</p>
</td></tr>
<tr><td><code id="convert_+3A_options">options</code></td>
<td>
<p>Additional options to be passed to the ImageMagick <code>mogrify</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conversion is done through a call to ImageMagick <code>mogrify</code> function. This means that ImageMagick should be installed on your system. It must also be listed in the path.
</p>
<p>For values such as <code>"pdf"</code> and <code>"eps"</code> of the <code>from</code> or <code>to</code> arguments ImageMagick works in conjunction with Gostscript. The latter should, therefore, also be accessible.
</p>
<p>ImageMagick is not suited for vector to vector format conversion because it rasterizes the image before the conversion. Therefore, <code>convert.g</code> is not suited too for such conversions.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+png">png</a></code>, <code><a href="grDevices.html#topic+pdf">pdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Convert all .pdf graphics in the "figSW" directory
## into .png files and put the files in a "png" subfolder.
convert.g(path="figSW", from="pdf", to="png")

## Same, but convert to .jpg files.
convert.g(path="figSW", to="jpg")

## convert file "example.jpg" in current path to ".pdf"
## and put it in same folder.
convert.g(fileroot = "example", from = "jpg", create.path=FALSE)

## End(Not run)


</code></pre>

<hr>
<h2 id='createdatadiscrete'>Transform time to event data into a discrete data format</h2><span id='topic+createdatadiscrete'></span>

<h3>Description</h3>

<p>Transform time to event data (in a specific format, see the details below) into a person-period data format suitable for automatic sequential association rules extraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createdatadiscrete(ids, data, vars, agemin, agemax,
    supvar=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createdatadiscrete_+3A_ids">ids</code></td>
<td>
<p>a vector containing an unique identification number for each case</p>
</td></tr>
<tr><td><code id="createdatadiscrete_+3A_data">data</code></td>
<td>
<p>a data frame containing time to event data, with variables containing the durations named as in the vars argument, and those with the censoring indicators named as in the vars argument followed by &quot;ST&quot; (for example column A is duration until event A, and column AST is the censoring indicator). This data frame must contain an unique identification variable named &quot;IDPERS&quot;.</p>
</td></tr>
<tr><td><code id="createdatadiscrete_+3A_vars">vars</code></td>
<td>
<p>a vector with the names of the duration variables</p>
</td></tr>
<tr><td><code id="createdatadiscrete_+3A_agemin">agemin</code></td>
<td>
<p>a data frame with two variables : &quot;IDPERS&quot; for the unique identification variable, and &quot;AGE&quot; for the starting time of the observation</p>
</td></tr>
<tr><td><code id="createdatadiscrete_+3A_agemax">agemax</code></td>
<td>
<p>a data frame with two variables : &quot;IDPERS&quot; for the unique identification variable, and &quot;AGE&quot; for the ending time of the observation</p>
</td></tr>
<tr><td><code id="createdatadiscrete_+3A_supvar">supvar</code></td>
<td>
<p>a vector of variables to add to the resulting person-period data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame from the <code>data</code> argument must contain two variables for each event: a duration variable that indicates the time when the event occurred, and a status variable that indicates if the event occurred (1) or not (0). If the event did not occur, the observation for this individual will go until the age specified through the <code>agemax</code> argument. Each status variable must have the name of the corresponding duration variable suffixed by &quot;ST&quot;. For example, if the duration variable for an event &quot;divorce&quot; is called &quot;div&quot;, then the status variable has to be named &quot;divST&quot;. <br />
</p>
<p>The result from this function is a list with one person-period data frame by event, where the dependent event is different each time. Please see the attached data file and code for an example.
</p>
<p>The resulting object is one of the required argument for the <code>seqerulesdisc</code> function that computes the association rules, the hazard ratios and the p-values, using discrete-time regressions. Unlike the method presented in Müller et al. 2010, this function does not use Cox proportional hazard models, but discrete-time regression models with a complementary log-log link function, which gives similar results.
</p>


<h3>Value</h3>

<p>a list with one person-period data frame by event, where the dependent event is different each time. Please see the attached data file and code for an example.</p>


<h3>Author(s)</h3>

<p>Nicolas S. Müller</p>


<h3>References</h3>

<p>Müller, N.S., M. Studer, G. Ritschard et A. Gabadinho (2010), Extraction de règles d'association séquentielle à l'aide de modèles semi-paramétriques à risques proportionnels, <em>Revue des Nouvelles Technologies de l'Information</em>, <b>Vol. E-19</b>, EGC 2010, pp. 25-36
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqerulesdisc">seqerulesdisc</a></code> to compute the association rules.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='dissindic'>
Sequence marginality and gain indicators.

</h2><span id='topic+dissindic'></span>

<h3>Description</h3>

<p>The marginality and gain indicators measure the contribution of each observation to a quantitative relationship between a covariate and the sequences using a distance matrix.  These indicators allow situating cases according to this quantitative relationship. The marginality indicator quantifies the typicality of each case within each group of the explanatory covariate using a measure of distance between cases and gravity centers. The gain indicator aims to identify cases that are either illustrative of, or discordant with, the quantitative association. It is computed as the contribution of each case to the explained sum of squares, i.e. the sum of squares explained by the covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissindic(diss, group, gower = FALSE, squared = FALSE, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissindic_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="dissindic_+3A_group">group</code></td>
<td>
<p>A categorical variable.</p>
</td></tr>
<tr><td><code id="dissindic_+3A_gower">gower</code></td>
<td>
<p>Logical: Is the dissimilarity matrix already a Gower matrix?</p>
</td></tr>
<tr><td><code id="dissindic_+3A_squared">squared</code></td>
<td>
<p>Logical: Should we square the provided dissimilarities?</p>
</td></tr>
<tr><td><code id="dissindic_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector of case weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two indicators are computed within the discrepancy analysis framework (see <code><a href="TraMineR.html#topic+dissmfacw">dissmfacw</a></code>). The marginality is computed as the &quot;residual&quot; of the discrepancy analysis. A high value means that a sequence (or another object) is far from the center of gravity of its group, i.e. the most typical situation. A low value indicates a sequence (or another object) close to this gravity center. 
</p>
<p>By combining the &quot;residuals&quot; of the null model (without covariate) and the marginality, we can identify sequences that are better represented when using the covariate than without it. These values measure the contributions of a sequence to the between or explained sums of squares, a concept directly linked to the explained discrepancy. The gain therefore measures the statistical gain of information for each case when taking the covariate into account.
</p>
<p>The so-called Gower matrix is a transformation of the distance matrix required to compute the explained, residual and total sum of squares. The distance matrix (argument <code>diss</code>) is automatically transformed to a Gower matrix unless the argument <code>gower=TRUE</code>. This option can be used to avoid multiple transformation of the distance matrix to the Gower matrix which can be time-consuming, but it requires the user to provide a Gower matrix using the <code>diss</code> argument. The function <code>gower_matrix</code> in the TraMineR package can be used to compute it from a distance matrix.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing three columns: 
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>The categorical variable used.</p>
</td></tr>
<tr><td><code>marginality</code></td>
<td>
<p>The value of the marginality indicator.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p>The value of the gain indicator .</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer</p>


<h3>References</h3>

<p>Le Roux, G., M. Studer, A. Bringé, C. Bonvalet (2023). Selecting Qualitative Cases Using Sequence Analysis: A Mixed-Method for In-Depth Understanding of Life Course Trajectories, <em>Advances in Life Course Research</em>, <a href="https://doi.org/10.1016/j.alcr.2023.100530">doi:10.1016/j.alcr.2023.100530</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+dissvar">dissvar</a></code> to compute a pseudo variance from dissimilarities and for a basic introduction to concepts of discrepancy analysis.
<br />
<code><a href="TraMineR.html#topic+dissassoc">dissassoc</a></code> to test association between objects represented by their dissimilarities and a covariate.
<br />
<code><a href="TraMineR.html#topic+dissmfacw">dissmfacw</a></code> to perform multi-factor analysis of variance from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a state sequence object
data(mvad)
mvad &lt;- mvad[1:100, ] ## Use a subsample to avoid long computation time
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Building dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")

## Study association with 
di &lt;- dissindic(mvad.ham, group=mvad$gcse5eq)

## Plot sequences sorted by gain, illustrative trajectories at the top 
## and counterexample at the bottom
seqIplot(mvad.seq, group=mvad$gcse5eq, sortv=di$gain)

## Plot sequences sorted by marginality, central trajectories at the bottom
seqIplot(mvad.seq, group=mvad$gcse5eq, sortv=di$marginality)

##Scatterplot of the indicators separated by group value 
## as in Le Roux, et al. 2023
par(mfrow=c(1, 2))
## Plot for the "no" category
plot(di$gain[mvad$gcse5eq=="no"], di$marginality[mvad$gcse5eq=="no"], main="No gcseq5q", 
	xlim=range(di$gain), ylim=range(di$marginality))
abline(h=mean(di$marginality), v=0) ## Draw reference lines
plot(di$gain[mvad$gcse5eq=="yes"], di$marginality[mvad$gcse5eq=="yes"], main="Yes gcseq5q", 
	xlim=range(di$gain), ylim=range(di$marginality))
abline(h=mean(di$marginality), v=0) ## Draw reference lines

</code></pre>

<hr>
<h2 id='dissvar.grp'>
Discrepancy by group.
</h2><span id='topic+dissvar.grp'></span>

<h3>Description</h3>

<p>This function computes the dissimilarity-based discrepancy measure of the groups defined by the group variable. The function is a wrapper for the TraMineR <code><a href="TraMineR.html#topic+dissvar">dissvar</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissvar.grp(diss, group=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissvar.grp_+3A_diss">diss</code></td>
<td>

<p>a dissimilarity matrix or a <code>dist</code> object.
</p>
</td></tr>
<tr><td><code id="dissvar.grp_+3A_group">group</code></td>
<td>

<p>group variable. If <code>NULL</code> a single group is assumed.
</p>
</td></tr>
<tr><td><code id="dissvar.grp_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code><a href="TraMineR.html#topic+dissvar">dissvar</a></code> .
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for running <code><a href="TraMineR.html#topic+dissvar">dissvar</a></code> on the different groups defined by the <code>group</code> variable.
</p>


<h3>Value</h3>

<p>A vector with the group discrepancy measures.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+dissvar">dissvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create the biofam.seq state sequence object from the biofam data.
data(biofam)
biofam &lt;- biofam[1:100,]
biofam.seq &lt;- seqdef(biofam[,10:25])
dist &lt;- seqdist(biofam.seq, method="HAM")

## discrepancy based on non-squared dissimilarities
dissvar.grp(dist, biofam$plingu02)
## square root of discrepancy based on squared dissimilarities
sqrt(dissvar.grp(dist, biofam$plingu02, squared=TRUE))
</code></pre>

<hr>
<h2 id='FCE_to_TSE'>
Data conversion from Fixed Column Event format to TSE.
</h2><span id='topic+FCE_to_TSE'></span>

<h3>Description</h3>

<p>Data conversion from Fixed Column Event format to TSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCE_to_TSE(seqdata, id = NULL, cols, eventlist = NULL, firstEvent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCE_to_TSE_+3A_seqdata">seqdata</code></td>
<td>

<p>data frame or matrix containing event sequence data in FCE format.
</p>
</td></tr>
<tr><td><code id="FCE_to_TSE_+3A_id">id</code></td>
<td>

<p>column containing the identification numbers for the sequences.
</p>
</td></tr>
<tr><td><code id="FCE_to_TSE_+3A_cols">cols</code></td>
<td>
<p> Real. Column containing the timing of the event. A missing value is interpreted as a non-occurrence of the event.</p>
</td></tr>
<tr><td><code id="FCE_to_TSE_+3A_eventlist">eventlist</code></td>
<td>
<p>Event names, specified in the same order as <code>cols</code> argument. If <code>NULL</code> (default), column names are used.</p>
</td></tr>
<tr><td><code id="FCE_to_TSE_+3A_firstevent">firstEvent</code></td>
<td>
<p>Character. The name of an event to be added at the beginning of each event sequences. This allows to include individuals with no events. If <code>NULL</code> (default), no event is added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual data format for event sequence is TSE (see <code><a href="TraMineR.html#topic+seqecreate">seqecreate</a></code>).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with three columns: &quot;id&quot;, &quot;timestamp&quot; and &quot;event&quot;.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.</p>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqecreate">seqecreate</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a ramdom data set
fce &lt;- data.frame(id=1:100, event1=runif(100), event2=runif(100))

## Add missing values (ie non-occurrences)
fce[runif(100)&lt;0.1, "event1"] &lt;- NA
fce[runif(100)&lt;0.1, "event2"] &lt;- NA

tse &lt;- FCE_to_TSE(fce, id="id", cols=c("event1", "event2"),
       eventlist=c("Marriage", "Child birth"), firstEvent="Birth")

seq &lt;- seqecreate(tse)
print(seq[1:10])

</code></pre>

<hr>
<h2 id='group.p'>Adds proportion of occurrences to each level names</h2><span id='topic+group.p'></span>

<h3>Description</h3>

<p>Adds the proportion of occurrences of each level to the corresponding level name.</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.p(group, weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group.p_+3A_group">group</code></td>
<td>
<p>A group variable.</p>
</td></tr>
<tr><td><code id="group.p_+3A_weights">weights</code></td>
<td>
<p>Vector of weights of same length as the group variable.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>group</code> variable can be a factor or a numerical variable. In the latter case it is transformed to a factor.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal &lt;- actcal[1:100,]
actcal.seq &lt;- seqdef(actcal[,13:24])
seqdplot(actcal.seq, group=group.p(actcal$sex))

levels(group.p(actcal$sex, weights=runif(length(actcal$sex))))
</code></pre>

<hr>
<h2 id='HSPELL_to_STS'>
Data conversion from Horizontal Spell to STS.
</h2><span id='topic+HSPELL_to_STS'></span>

<h3>Description</h3>

<p>Convert data from Horizontal Spell to STS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSPELL_to_STS(seqdata, begin, end, status = NULL,
    fixed.status = NULL, pvar = NULL, overwrite = TRUE,
    fillblanks = NULL, tmin = NULL, tmax = NULL, id = NULL,
    endObs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HSPELL_to_STS_+3A_seqdata">seqdata</code></td>
<td>

<p>a data frame or matrix containing sequence data.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_begin">begin</code></td>
<td>

<p>Vector containing the columns (name or number) with the beginning position of each spell.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_end">end</code></td>
<td>

<p>Vector containing the columns (name or number) with the end position of each spell.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_status">status</code></td>
<td>

<p>Vector containing the columns (name or number) with the status of each spell.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_fixed.status">fixed.status</code></td>
<td>
<p> Default status (for period not covered by any spell.)
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_pvar">pvar</code></td>
<td>
<p> names or numbers of the column containing the 'birth' time.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the most recent episode overwrite the older one when they overlap? If <code>FALSE</code>, the most recent episode starts from the end of the previous one.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_fillblanks">fillblanks</code></td>
<td>
<p>If not <code>NULL</code>, character used for filling gaps between episodes.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_tmin">tmin</code></td>
<td>

<p>If sequences are to be defined on a calendar time axis, it defines the starting time of the axis. If set as NULL, the start time is set as the minimum of the 'begin' column in the data.</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_tmax">tmax</code></td>
<td>

<p>If year sequences are wanted, defines the ending year of the sequences. If set to NULL, it is guessed from the data (not so accurately!).
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_id">id</code></td>
<td>

<p>column containing the identification numbers for the sequences.
</p>
</td></tr>
<tr><td><code id="HSPELL_to_STS_+3A_endobs">endObs</code></td>
<td>
<p>An optional end of observation date. Usefull for retrospective survey.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hortizontal spell data format has the following caracteristics:
- One row per individual
- Each spell is specified with three consecutive variables: a begin date, an end date, and the status.
- For unused spells, begin and end values should be set as <code>NA</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sequence in STS format.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.</p>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>See Also</h3>

<p>See Also <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hspell &lt;- data.frame(begin1=rep(1, 5), end1=c(2:5, NA), status1=1:5,
                     begin2=c(3:6, NA), end2=rep(NA, 5), status2=5:1)
sts &lt;- HSPELL_to_STS(hspell, begin=c("begin1", "begin2"), end=c("end1", "end2"),
                     status=c("status1", "status2"))
</code></pre>

<hr>
<h2 id='pamward'>PAM from k-solution of hierarchical clustering</h2><span id='topic+pamward'></span>

<h3>Description</h3>

<p>Runs a pam clustering (<code><a href="cluster.html#topic+pam">pam</a></code>) from the solution in k groups of a hierarchical clustering (<code><a href="cluster.html#topic+agnes">agnes</a></code>) .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamward(diss, k=3, method="ward", dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pamward_+3A_diss">diss</code></td>
<td>
<p>Distance matrix or object.</p>
</td></tr>
<tr><td><code id="pamward_+3A_k">k</code></td>
<td>
<p>Integer. Number of clusters.</p>
</td></tr>
<tr><td><code id="pamward_+3A_method">method</code></td>
<td>
<p>Method for the hierarchical clustering (see <code><a href="cluster.html#topic+agnes">agnes</a></code>).</p>
</td></tr>
<tr><td><code id="pamward_+3A_dist">dist</code></td>
<td>
<p>Deprecated. Use <code>diss</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first runs the hierarchical clustering, retrieves the medoids of the solution for the provided <code>k</code> and uses those medoids as start centers for the <code>pam</code> partitioning.
</p>


<h3>Value</h3>

<p>An object of class <code>"pam"</code>. See <code><a href="cluster.html#topic+pam.object">pam.object</a></code> for details.   </p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+agnes">agnes</a></code> and <code><a href="cluster.html#topic+pam">pam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(actcal)
actcal.seq &lt;- seqdef(actcal[1:200,13:24])
actcal.ham &lt;- seqdist(actcal.seq, method = "HAM")
clust &lt;- pamward(actcal.ham, k = 4)
table(clust$clustering)
</code></pre>

<hr>
<h2 id='plot.dynin'>Dynamic index plot

</h2><span id='topic+plot.dynin'></span>

<h3>Description</h3>

<p>Plot of dynamic (i.e. successive) cross-sectional summaries of an individual index. The successive values of the individual index for all sequences should be collected in a <code>dynin</code> table as produced by <code><a href="#topic+seqindic.dyn">seqindic.dyn</a></code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynin'
plot(x, fstat=weighted.mean, group=NULL, conf=FALSE,
     main="auto", col=NULL, lty=NULL, lwd=3.5, ylim=NULL,
     ylab=NULL, xlab=NULL, xtlab=NULL, xtstep=NULL, tick.last=NULL,
     with.legend=TRUE, glabels=NULL, legend.pos="topright",
     horiz=FALSE, cex.legend=1, bcol=NULL, na.rm=FALSE, ret=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dynin_+3A_x">x</code></td>
<td>
<p>object of class <code>dynin</code> as produced by <code><a href="#topic+seqindic.dyn">seqindic.dyn</a></code>
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_fstat">fstat</code></td>
<td>
<p>function: summary function to compute the values plotted. Default is <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code> with weights taken from the <code>weights</code> attribute of <code>x</code>. When <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code> and <code>x</code> has no weights, <code>mean</code> is used instead.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_group">group</code></td>
<td>
<p>factor or discrete vector: group membership; a curve is drawn for each group. If <code>NULL</code> (default) a single curve for the whole set is drawn.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_conf">conf</code></td>
<td>
<p>logical or numeric: If logical, should confidence bands be displayed? If numeric, confidence probability. <code>TRUE</code> is equivalent to .95. Applies only when <code>fstat=mean</code> or <code>fstat=weighted.mean</code>.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_main">main</code></td>
<td>
<p>character string: Plot title. Default is &quot;auto&quot; that prints a default title. Set as <code>NULL</code> to suppress the title.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_col">col</code></td>
<td>
<p>color vector. Group line colors. If <code>NULL</code> (default), colors are automatically assigned using <code>qualitative_hcl</code> with the <code>'Dark 3'</code> palette (see <code><a href="colorspace.html#topic+hcl_palettes">hcl_palettes</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_lty">lty</code></td>
<td>
<p>string vector. Group line types (see <code><a href="graphics.html#topic+lines">lines</a></code>). If <code>NULL</code> (default), types are automatically assigned.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_lwd">lwd</code></td>
<td>
<p>integer vector: Group line widths (see <code><a href="graphics.html#topic+lines">lines</a></code>). If <code>NULL</code> (default), set as 3.5.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_ylim">ylim</code></td>
<td>
<p>pair of numerics defining the range for the y-axis. If left <code>NULL</code>, the limits are defined from the data.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_ylab">ylab</code></td>
<td>
<p>character string: y axis label.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_xlab">xlab</code></td>
<td>
<p>character string: x axis label.
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_xtlab">xtlab</code></td>
<td>
<p>vector of strings defining the x-axis tick labels. If <code>NULL</code>, column names of the <code>x</code> table are used.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_xtstep">xtstep</code></td>
<td>
<p>integer: step between tick marks on the x-axis. If unspecified, attribute <code>xtstep</code> of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_tick.last">tick.last</code></td>
<td>
<p>logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, attribute <code>tick.last</code> of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_glabels">glabels</code></td>
<td>
<p>a vector of strings with the curve labels. If <code>NULL</code> curves are labeled with the levels of the group variable</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_with.legend">with.legend</code></td>
<td>
<p>logical: Should the legend be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_legend.pos">legend.pos</code></td>
<td>
<p>legend position: default is <code>"topright"</code>. See<code><a href="graphics.html#topic+legend">legend</a> </code>.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_horiz">horiz</code></td>
<td>
<p>logical: Should the legend be displayed horizontally. Set as <code>FALSE</code> by default, i.e., legend is displayed vertically.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Scale factor for the legend.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_bcol">bcol</code></td>
<td>
<p>color vector. For confidence bands. If <code>NULL</code> (default), colors are automatically assigned using <code>qualitative_hcl</code>  with the <code>'Pastel 1'</code> palette (see <code><a href="colorspace.html#topic+hcl_palettes">hcl_palettes</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. When <code>fstat</code> is <code>mean</code> or <code>weighted.mean</code>, should <code>NA</code>'s be stripped before computation? Ignored for any other <code>fstat</code> function.</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_ret">ret</code></td>
<td>
<p>logical: Should the plotted values be returned?</p>
</td></tr>
<tr><td><code id="plot.dynin_+3A_...">...</code></td>
<td>
<p>additional plot parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Together with <code><a href="#topic+seqindic.dyn">seqindic.dyn</a></code> this function implements the dynamic sequence analysis approach of <cite>Pelletier et al. (2020)</cite>.

</p>
<p>The function first computes the summary table using the <code>fstat</code> function. Each row of the summary table is then plotted as a line, except rows that contain <code>NA</code>s. Setting <code>na.rm=TRUE</code> helps sometimes to prevent some <code>NA</code>s in the summary table.
</p>
<p>Confidence bands are computed for a confidence level of 95% and assuming a normal distribution.
</p>


<h3>Value</h3>

<p>If <code>ret=TRUE</code>, a matrix with the successive group summaries (One row per group) and, when <code>conf=TRUE</code>, the matrices with the lower and upper bounds of the confidence intervals as attributes <code>L.grp</code> and <code>U.grp</code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>References</h3>

<p>Pelletier, D., Bignami-Van Assche, S., &amp; Simard-Gendron, A. (2020) Measuring Life Course Complexity with Dynamic Sequence Analysis, <em>Social Indicators Research</em> <a href="https://doi.org/10.1007/s11205-020-02464-y">doi:10.1007/s11205-020-02464-y</a>.
</p>



<h3>See Also</h3>

<p>See Also <code><a href="#topic+seqindic.dyn">seqindic.dyn</a></code> (with examples)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples on 'seqindic.dyn' help page
</code></pre>

<hr>
<h2 id='plot.emlt'>Emlt Plots

</h2><span id='topic+plot.emlt'></span>

<h3>Description</h3>

<p>Plots static and dynamic state structure from the outcome of <code>seqemlt</code>. Two types of plot are proposed: The evolution in time of the correlation between states, and the projection of situations (time-indexed states) on their principal planes.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emlt'
plot(x, from, to, delay=NULL, leg=TRUE, type="cor", cex=0.7, compx=1, compy=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.emlt_+3A_x">x</code></td>
<td>
<p>an object of class <code>emlt</code> as produced by <code><a href="#topic+seqemlt">seqemlt</a></code>
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_type">type</code></td>
<td>
<p>character string: type of plot to be drawn. Possible types are
<code>"cor"</code> for the evolution in time of the correlation between states, and
<code>"pca"</code> for the projection of states/situations on their principal planes
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_from">from</code></td>
<td>
<p>vector of state labels: for type <code>"cor"</code>, origin state(s) to be considered.
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_to">to</code></td>
<td>
<p>state label: for type &quot;cor&quot;, destination state.
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_delay">delay</code></td>
<td>
<p>for type &quot;cor&quot;, the delay (number of time periods) between <code>"from"</code> and <code>"to"</code> arguments. The correlation between state <code>"from"</code> at time t and <code>"to"</code> at t+<code>delay</code>. By default <code>delay</code> is 0.
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_compx">compx</code></td>
<td>
<p>integer: for type <code>"pca"</code> first component, axis x
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_compy">compy</code></td>
<td>
<p>integer: for type <code>"pca"</code> second component, axis y
</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_leg">leg</code></td>
<td>
<p>logical: should the legend be included</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_cex">cex</code></td>
<td>
<p>numerical value: amount by which plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot.emlt_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The evolution of the correlation reveals the evolution of the emlt Euclidean distance between the situations (time-indexed states) along the timeframe.
</p>
<p>The <code>"pca"</code> components are the principal components of the emlt numerical coordinates of the sequences, see <code><a href="#topic+seqemlt">seqemlt</a></code>.

</p>


<h3>Author(s)</h3>

<p>Patrick Rousset and Matthias Studer
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+seqemlt">seqemlt</a></code> (with examples)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples on 'seqemlt' help page
</code></pre>

<hr>
<h2 id='plot.stslist.surv'>Plot method for objects produced by the seqsurv function</h2><span id='topic+plot.stslist.surv'></span>

<h3>Description</h3>

<p>This is the plot method for objects of class <em>stslist.surv</em> produced by
the <code><a href="#topic+seqsurv">seqsurv</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.surv'
plot(x, cpal = NULL, ylab = NULL, xlab = NULL,
  xaxis = TRUE, yaxis = TRUE, xtstep = NULL, tick.last = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.surv_+3A_x">x</code></td>
<td>

<p>An object of class <code>stslist.surv</code> as produced by the
<code><a href="#topic+seqsurv">seqsurv</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_cpal">cpal</code></td>
<td>
<p>Vector of colors. Alternative color palette to be used for the drawn lines. The vector should be of length equal to the number of drawn survival curves, i.e., the number of selected states or number of groups when <code>x</code> was obtained with <code>per.state=TRUE</code>. When <code>cpal=NULL</code>, the default colors assigned to the <code>cpal</code> attribute of <code>x</code> are used.
</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_ylab">ylab</code></td>
<td>

<p>Optional label for the y axis. If set as <code>NA</code>, no label is displayed. If <code>NULL</code>, a default label is used.
</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_xlab">xlab</code></td>
<td>

<p>Optional label for the x axis. If set as <code>NA</code>, no label is displayed. If <code>NULL</code>, a default label is used.
</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical. Should the y-axis be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_xtstep">xtstep</code></td>
<td>

<p>Optional interval at which the tick-marks of the x-axis are
displayed. For example, with <code>xtstep = 3</code> a tick-mark is drawn at
position 1, 4, 7, etc... The display of the corresponding labels depends on
the available space and is dealt with automatically. If unspecified, the
<code>xtstep</code> attribute of the <code>x</code> object is used.
</p>
</td></tr>
<tr><td><code id="plot.stslist.surv_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>





<tr><td><code id="plot.stslist.surv_+3A_...">...</code></td>
<td>

<p>Further graphical parameters. For more details about the graphical parameter
arguments, see <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code> and
<code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for the output produced by the <code><a href="#topic+seqsurv">seqsurv</a></code>
function, i.e., objects of class <em>stslist.surv</em>. It displays the survival
curves fitted for states in sequences.
</p>







<h3>Author(s)</h3>

<p>Matthias Studer, Gilbert Ritschard, Pierre-Alexandre Fonta</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqsurv">seqsurv</a></code>, <code><a href="#topic+seqsplot">seqsplot</a></code>, <code><a href="survival.html#topic+survfit">survfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## State survival plot
biofam.surv &lt;- seqsurv(biofam.seq)
plot(biofam.surv)
</code></pre>

<hr>
<h2 id='polyads'>Polyadic data example</h2><span id='topic+polyads'></span>

<h3>Description</h3>

<p>This data set contains a data frame with 10 triads. The 10 first rows correspond to the 1st generation members, the next 10 to the second generation members and the last 10 to the third generation members.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(polyads)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 11 columns.</p>


<h3>Details</h3>

<p>The first column is the generation variable Gen. The sequences of length 10 are in columns 2 to 11 named X1 to X10.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>

<hr>
<h2 id='rowmode'>Modal state of a variable</h2><span id='topic+rowmode'></span>

<h3>Description</h3>

<p>Returns the modal state of a variable, e.g., the modal state in a sequence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowmode(v, except = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowmode_+3A_v">v</code></td>
<td>
<p>A numerical or factor variable.</p>
</td></tr>
<tr><td><code id="rowmode_+3A_except">except</code></td>
<td>
<p>Vector of values that should be ignored; e.g., set <code>except="*"</code> to ignore missing states with default coding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function tabulates the variable and returns the most frequent value.
</p>


<h3>Value</h3>

<p>The modal value
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal[1:10,13:24])
actcal.mod &lt;- apply(as.matrix(actcal.seq), 1, rowmode)
head(actcal.mod)

</code></pre>

<hr>
<h2 id='seqauto'>
Auto-association between states
</h2><span id='topic+seqauto'></span>

<h3>Description</h3>

<p>Computes auto-associations of order k = 1 to <code>order</code>, between current states and states lagged by k positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqauto(seqdata, order = 1, measure = "cv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqauto_+3A_seqdata">seqdata</code></td>
<td>

<p>A state sequence object or a data frame with sequential data in STS format.
</p>
</td></tr>
<tr><td><code id="seqauto_+3A_order">order</code></td>
<td>

<p>Maximum wanted order of auto-association.
</p>
</td></tr>
<tr><td><code id="seqauto_+3A_measure">measure</code></td>
<td>

<p>Character string. Currently only <code>"cv"</code> (Cramer's v) is accepted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function puts the data in <code>"SRS"</code> form by means of the <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code> function.</p>


<h3>Value</h3>

<p>A matrix with <code>order</code> rows and  two columns: the auto-association and its p-value.
</p>


<h3>Warning </h3>

<p>Function in development, not fully checked.</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

biofam.seq &lt;- seqdef(biofam[1:100,10:25])
aa &lt;- seqauto(biofam.seq, order=5)
aa
</code></pre>

<hr>
<h2 id='seqCompare'>BIC and Likelihood ratio test for comparing two sequence data</h2><span id='topic+seqCompare'></span><span id='topic+seqLRT'></span><span id='topic+seqBIC'></span>

<h3>Description</h3>

<p>The function <code>seqCompare</code> computes the likelihood ratio test (LRT) and Bayesian Information Criterion (BIC) for comparing two groups within each of a series of set. The functions <code>seqBIC</code> and <code>seqLRT</code> are aliases that return only the BIC or the LRT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqCompare(seqdata, seqdata2=NULL, group=NULL, set=NULL,
    s=100, seed=36963, stat="all", squared="LRTonly",
    weighted=TRUE, opt=NULL, BFopt=NULL, method, ...)

seqLRT(seqdata, seqdata2=NULL, group=NULL, set=NULL, s=100,
    seed=36963, squared="LRTonly", weighted=TRUE, opt=NULL,
    BFopt=NULL, method, ...)

seqBIC(seqdata, seqdata2=NULL, group=NULL, set=NULL, s=100,
    seed=36963, squared="LRTonly", weighted=TRUE, opt=NULL,
    BFopt=NULL, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqCompare_+3A_seqdata">seqdata</code></td>
<td>
<p>Either a state sequence object (<code>stslist</code> created with <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) or a list of state sequence objects, e.g., <code>list(cohort1.seq,cohort2.seq,cohort3.seq)</code>.


</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_seqdata2">seqdata2</code></td>
<td>
<p>Either a state sequence object (<code>stslist</code> or a list of state sequence objects. Must be <code>NULL</code> when <code>group</code> is not <code>NULL</code>. If not <code>NULL</code>, must be of same type than <code>seqdata</code>. See details.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_group">group</code></td>
<td>
<p>Vector of length equal to number of sequences in <code>seqdata</code>. A dichotomous grouping variable. See details.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_set">set</code></td>
<td>
<p>Vector of length equal to number of sequences in <code>seqdata</code>. Variable defining the sets. See details.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_s">s</code></td>
<td>
<p>Integer. Default 100. The size of random samples of sequences. When 0, no sampling is done.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_seed">seed</code></td>
<td>
<p>Integer. Default 36963. Using the same seed number guarantees the same results
each time. Set <code>s=NULL</code> if you don't want to set a seed.
The random generator can be chosen with <code><a href="base.html#topic+RNGkind">RNGkind</a></code>.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_stat">stat</code></td>
<td>
<p>String. The requested statistics. One of <code>"LRT"</code>, <code>"BIC"</code>, or <code>"all"</code>
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_squared">squared</code></td>
<td>
<p>Logical. Should squared distances be used? Can also be <code>"LRTonly"</code>, in which case the distances to the centers are computed using non-squared distances and LRT is computed with squared distances.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_weighted">weighted</code></td>
<td>
<p>Logical or String. Should weights be taken into account when available? Can also be <code>"by.group"</code>, in which case weights are used and normalized to respect group sizes.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_opt">opt</code></td>
<td>
<p>Integer or <code>NULL</code>. Either 1 or 2. Computation option. When 1, the distance matrix is computed successively for each pair of samples of size s. When 2, the distances are computed only once for each pair of sets of observed sequences and the distances for the samples are extracted from that matrix. When <code>NULL</code> (default), 1 is chosen when the sum of sizes of the two groups is larger than 2*s and 2 otherwise.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_bfopt">BFopt</code></td>
<td>
<p>Integer or <code>NULL</code>. Either 1 or 2. Applies only when BIC is computed on multiple samples. When 1 the displayed Bayes Factor (BF) is the averaged BF. When 2, the displayed BF is obtained from the averaged BIC. When <code>NULL</code> both BFs are displayed.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_method">method</code></td>
<td>
<p>String. Method for computing sequence distances. See documentation for <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>. Additional arguments may be required depending on the method chosen.
</p>
</td></tr>
<tr><td><code id="seqCompare_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>group</code> and <code>set</code> arguments can only be used when <code>seqdata</code> is an <code>stslist</code> object (a state sequence object).
</p>
<p>When <code>seqdata</code> and <code>seqdata2</code> are both provided, the LRT and BIC statistics are computed for comparing these two sets. In that case both <code>group</code> and <code>set</code> should be left at their default <code>NULL</code> value.
</p>
<p>When <code>seqdata</code> is a list of <code>stslist</code> objects, <code>seqdata2</code> must be a list of the same number of <code>stslist</code> objects.
</p>
<p>The default option <code>squared="LRTonly"</code> corresponds to the initial proposition of Liao and Fasang (2021). With that option, the distances to the virtual center are obtained from the pairwise non-squared dissimilarities and the resulting distances to the virtual center are  squared when computing the LRT (which is in turn used to compute the BIC). With <code>squared=FALSE</code>, non-squared distances are used in both cases, and with <code>squared=TRUE</code>, squared distances are used in both cases.
</p>
<p>The computation is based on the pairwise distances between the sequences. The <code>opt</code> argument permits to choose between two strategies. With <code>opt=1</code>, the matrix of distances is computed successively for each pair of samples of size s. When <code>opt=2</code>, the matrix of distances is computed once for the observed sequences and the distances for the samples are extracted from that matrix. Option 2 is often more efficient, especially for distances based on spells. It may be slower for methods such as OM or LCS when the number of observed sequences becomes large.
</p>


<h3>Value</h3>

<p>The function <code>seqLRT</code> (and seqCompare with the default <code>"LRT"</code> stat value) outputs two variables, <var>LRT</var> and <var>p.LRT</var>.
</p>
<table>
<tr><td><code>LRT</code></td>
<td>
<p>This is the likelihood ratio test statistic for comparing the two groups.
</p>
</td></tr>
<tr><td><code>p.LRT</code></td>
<td>
<p>This is the upper tail probability associated with the LRT.
</p>
</td></tr>
</table>
<p>The function <code>seqBIC</code> (and <code>seqLRT</code> with the <code>"BIC"</code> stat value) outputs two variables, <var>BIC</var> and <var>BF</var>.
</p>
<table>
<tr><td><code>BIC</code></td>
<td>
<p>This is the difference between two BICs for comparing the two groups.
</p>
</td></tr>
<tr><td><code>BF</code></td>
<td>
<p>This is the Bayes factor associated with the BIC difference.
</p>
</td></tr>
</table>
<p><code>seqCompare</code> with <code>stat="all"</code> outputs all four indicators.
</p>


<h3>Author(s)</h3>

<p>Tim Liao and Gilbert Ritschard</p>


<h3>References</h3>

<p>Tim F. Liao &amp; Anette E. Fasang (2021). &quot;Comparing Groups of Life Course Sequences Using the Bayesian Information Criterion and the Likelihood Ratio Test.” <em>Sociological Methodology</em>, 55 (1), 44-85. <a href="https://doi.org/10.1177/0081175020959401">doi:10.1177/0081175020959401</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
                "Child", "Left+Child", "Left+Marr+Child", "Divorced")
alph &lt;- seqstatl(biofam[10:25])
## To illustrate, we use only a sample of 150 cases
set.seed(10)
biofam &lt;- biofam[sample(nrow(biofam),150),]
biofam.seq &lt;- seqdef(biofam, 10:25, alphabet=alph, labels=biofam.lab)

## Defining the grouping variable
lang &lt;- as.vector(biofam[["plingu02"]])
lang[is.na(lang)] &lt;- "unknown"
lang &lt;- factor(lang)

## Chronogram by language group
seqdplot(biofam.seq, group=lang)

## Extracting the sequence subsets by language
lev &lt;- levels(lang)
l &lt;- length(lev)
seq.list &lt;- list()
for (i in 1:l){
  seq.list[[i]] &lt;- biofam.seq[lang==lev[i],]
}

seqCompare(list(seq.list[[1]]),list(seq.list[[2]]), stat="all", method="OM", sm="CONSTANT")
seqBIC(biofam.seq, group=biofam$sex, method="HAM")
seqLRT(biofam.seq, group=biofam$sex, set=lang, s=80, method="HAM")

</code></pre>

<hr>
<h2 id='seqcta'>
Competing Trajectory Analysis (CTA)
</h2><span id='topic+seqcta'></span>

<h3>Description</h3>

<p>Competing Trajectory Analysis (CTA) aims to simultaneously study the occurrence of an event and the trajectory following it over a pre-defined period of time. The <code>seqcta</code> function convert the data to run the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqcta(seqdata, subseq = 5, time = NULL, event = NULL, initial.state = NULL, covar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqcta_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function. The whole trajectory followed by individuals.</p>
</td></tr>
<tr><td><code id="seqcta_+3A_subseq">subseq</code></td>
<td>
<p>Numeric. The length of the trajectory following the event to be considered.</p>
</td></tr>
<tr><td><code id="seqcta_+3A_time">time</code></td>
<td>
<p>Numeric. The time of occurrence of the event, can be <code>NA</code> for censored observations.  If <code>NULL</code> (default), <code>initial.state</code> should be provided.</p>
</td></tr>
<tr><td><code id="seqcta_+3A_event">event</code></td>
<td>
<p>Logical. Whether the event occur for each trajectory. If <code>NULL</code> (default) and <code>time</code> is provided, <code>NA</code> <code>time</code> values are used to detect censored observations.</p>
</td></tr>
<tr><td><code id="seqcta_+3A_initial.state">initial.state</code></td>
<td>
<p>Character. Only used if <code>time</code> is not provided. If provided, the end of the first spell of the sequence, but only  in <code>initial.state</code> state, is used as the event of interest to compute the <code>time</code> argument.</p>
</td></tr>
<tr><td><code id="seqcta_+3A_covar">covar</code></td>
<td>
<p>Optional <code>data.frame</code> storing covariates of interest. These covariates are added to the final data set. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Competing Trajectory Analysis (CTA) works as follows. First, the sequence following the studied event are clustered. Second, the type of trajectory followed is linked with covariates using a competing risks model.
</p>
<p>The <code>seqcta</code> function reorganizes the data to run CTA. More precisely, it provides a person-period data frame until the occurrence of the event. When the event occurs, the trajectory following it is also stored. Covariates specified using the <code>covar</code> arguments are also stored.
</p>
<p>The example section below provides a step by step example of the whole procedure.
</p>


<h3>Value</h3>

<p>A data frame with the following variables
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Numeric. The ID of the observation as the row number in the original <code>seqdata</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Numeric. The time unit from the beginning of the original sequence until the occurence of the event.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Logical. Whether the event occured within this time unit.</p>
</td></tr>
<tr><td><code>lastobs</code></td>
<td>
<p>Logical. Whether this is the last observation for an individual observation, censored or not. This is useful when one want only one row per individual, for instance to plot survival curves (see example).</p>
</td></tr>
<tr><td><code>T1 until T...</code></td>
<td>
<p>The state sequence following the event starting from 1 (time unit after the event) until <code>subseq</code> time units after the event. Only available for the rows where <code>event=TRUE</code>.</p>
</td></tr>
<tr><td><code>Optional covariate list</code></td>
<td>
<p>The covariates provided with the <code>covar</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>M. Studer, A. C. Liefbroer and J. E. Mooyaart, 2018. Understanding trends in family formation trajectories: An application of Competing Trajectories Analysis (CTA), <em>Advances in Life Course Research</em> 36, pp 1-12.  <a href="https://doi.org/10.1016/j.alcr.2018.02.003">doi:10.1016/j.alcr.2018.02.003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqsamm">seqsamm</a></code>, <code><a href="#topic+seqsha">seqsha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create seq object for biofam data.
data(biofam)
bf.shortlab &lt;- c("P","L","M","LM","C","LC", "LMC", "D")
bf.seq &lt;- seqdef(biofam[,10:25], states=bf.shortlab)

## We focus on the occurrence of ending the first "P" spell and the trajectory that follows
## For the next subseq=5 years
## We also store the covariate sex and birthyr
## seqcta will transform the data to person-period until the end of the first "P" spell
## and store the following trajectory

cta &lt;- seqcta(bf.seq, subseq=5, initial.state="P", covar=biofam[, c("sex", "birthyr")])
summary(cta)

## If the studied event is not a first state of the trajectory
## One can also provide the event using the time and event arguments
## Here we compute the time spent in "P" ourselves before providing it to seqcta

dur &lt;- seqdur(bf.seq)
## If "P" is the first state, we use the time in this state (dur[, 1])
## Otherwise we use 0 (started immediatly at the beginning)
timeP &lt;- ifelse(bf.seq[, 1]=="P", dur[, 1], 0)

## The event occured if timeP is inferior to the length of the sequence
## Otherwise they never left their parents.
eventP &lt;- timeP &lt; 16

cta2 &lt;- seqcta(bf.seq, subseq=5, time=timeP, event=eventP, covar=biofam[, c("sex", "birthyr")])
##Identical results
summary(cta2)


## Not run to save computation time
## Not run: 
library(survival)

## To plot a survival curve, we only need the last observation for each individual.
## Kaplan Meier curve for the occurrence of the event
ss &lt;- survfit(Surv(time, event)~sex, data=cta, subset=lastobs)
plot(ss, col=1:2)

## Now we cluster the trajectories following the event
## Therefore we only keep lines where the event occured.
clusterTraj &lt;- seqdef(cta[cta$event, 5:9])
##Compute distances
diss &lt;- seqdist(clusterTraj, method="HAM")
##Clustering with pam
library(cluster)
pclust &lt;- pam(diss, diss=TRUE, k=5, cluster.only=TRUE)
#Naming the clusters
pclustname &lt;- paste("Type", pclust)
##Plotting the clusters to make senses of them.
seqdplot(clusterTraj, pclustname)

##Now we store back the clustering in the original person-period data
## We start by adding a variable storing "no event" for all lines
cta$traj.event &lt;- "No event"
## Then we store the type of following trajectory
## only for those having experienced the event
cta$traj.event[cta$event] &lt;- pclustname


## Checking the results
summary(cta)

## Now we can estimate a competing risk model
## Several strategies are available.
## Here we use multinomial model on the person period.

library(mlogit)
summary(mlogit(traj.event~1|time+sex, data=cta, shape="wide", reflevel="No event"))
library(nnet)
summary(multinom(traj.event~time+sex+scale(birthyr), data=cta))

## The model can also be estimated with cox regression
## However, we need to estimate one model for each competing risk
## ie. the type of following trajectory in our case.

## Compute the event variable for "Type 1"

cta$eventType1 &lt;- cta$traj.event=="Type 1"
summary(coxph(Surv(time, eventType1)~sex+scale(birthyr), data=cta, subset=lastobs))



## End(Not run)
</code></pre>

<hr>
<h2 id='seqe2stm'>
Definition of an events to states matrix.
</h2><span id='topic+seqe2stm'></span>

<h3>Description</h3>

<p>This function creates a matrix specifying for each state (given in row) to which state we fall when the event given in column happens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqe2stm(events, dropMatrix = NULL, dropList = NULL, firstState = "None")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqe2stm_+3A_events">events</code></td>
<td>
<p>Character. The vector of all possible events.</p>
</td></tr>
<tr><td><code id="seqe2stm_+3A_dropmatrix">dropMatrix</code></td>
<td>
<p>Logical matrix. Specifying the events to forget once a given event has occurred.</p>
</td></tr>
<tr><td><code id="seqe2stm_+3A_droplist">dropList</code></td>
<td>
<p>List. Same as <code>dropMatrix</code> but using a list (often more convenient).</p>
</td></tr>
<tr><td><code id="seqe2stm_+3A_firststate">firstState</code></td>
<td>
<p>Character. Name of the first state, before any event has occurred.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a matrix with in each cell the new state which results when the column event (column name) occurs while we are in the corresponding row state (row name). Such a matrix is required by <code><a href="#topic+TSE_to_STS">TSE_to_STS</a></code>.
By default, a new state is created for each combination of events that already has occurred.
</p>
<p><code>dropMatrix</code> and <code>dropList</code> allow to specify which events should be &quot;forgotten&quot; once a given event has occurred.
For instance, we may want to forget the &quot;marriage&quot; event once the event &quot;divorce&quot; has occurred.
</p>
<p><code>dropMatrix</code> specifies for each event given in row, the previous events, given in column that should be forgotten.
<code>dropList</code> uses a list to specify the same thing. The form is list(event1=c(..., events to forget), event2=c(..., events to forget)).
See example below.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.</p>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>Ritschard, G., Gabadinho, A., Studer, M. &amp; Müller, N.S. (2009), &quot;Converting between various sequence representations&quot;,
In Ras, Z. &amp; Dardzinska, A. (eds) <em>Advances in Data Management</em>. Series: <em>Studies in Computational Intelligence</em>. Volume 223, pp. 155-175. Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSE_to_STS">TSE_to_STS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Achieving same result using dropMatrix or dropList.
## List of possible events.
events &lt;- c("marr", "child", "div")
dm &lt;- matrix(FALSE, 3,3, dimnames=list(events, events))
dm[3, ] &lt;- c(TRUE, TRUE, FALSE)
dm[1, 3] &lt;- TRUE
## Using the matrix, we forget "marriage" and "child" events when "divorce" occurs.
## We also forget "divorce" after "marriage" occurs.
print(dm)
stm &lt;- seqe2stm(events, dropMatrix=dm)

## Get same result with the dropList argument.
stmList &lt;- seqe2stm(events, dropList=list("div"=c("marr", "child"), "marr"="div"))

## test that the results are the same
all.equal(stm, stmList)
</code></pre>

<hr>
<h2 id='seqedist'>Distances between event sequences</h2><span id='topic+seqedist'></span>

<h3>Description</h3>

<p>Compute Optimal-Matching-like distances between event sequences. The distance measure is described in <cite>Studer et al. 2010</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqedist(seqe, idcost, vparam, interval="No", norm="YujianBo")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqedist_+3A_seqe">seqe</code></td>
<td>
<p>An event sequence <code>seqelist</code> object as defined by the <code><a href="TraMineR.html#topic+seqecreate">seqecreate</a></code> function.</p>
</td></tr>
<tr><td><code id="seqedist_+3A_idcost">idcost</code></td>
<td>
<p>Insertion/deletion cost of the different events (one entry per element of the event alphabet).</p>
</td></tr>
<tr><td><code id="seqedist_+3A_vparam">vparam</code></td>
<td>
<p>Positive real. The cost for a one-unit change in the time stamp of an event.</p>
</td></tr>
<tr><td><code id="seqedist_+3A_norm">norm</code></td>
<td>
<p>Character. One of <code>"YujianBo"</code> (respects triangle inequality), <code>"max"</code> (maximum distance) or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="seqedist_+3A_interval">interval</code></td>
<td>
<p>Character. One of <code>"No"</code> (absolute ages), <code>"previous"</code> (time spent since previous event) or <code>"next"</code> (time spent until next event).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix.</p>


<h3>Author(s)</h3>

<p>Matthias Studer</p>


<h3>References</h3>

<p>Studer, M., Müller, N.S., Ritschard, G. &amp; Gabadinho, A. (2010), &quot;Classer, discriminer et visualiser des séquences d'événements&quot;,
In Extraction et gestion des connaissances (EGC 2010), <em>Revue des nouvelles technologies de l'information RNTI</em>. Vol. E-19, pp. 37-48.
</p>
<p>Ritschard, G., Bürgin, R., and Studer, M. (2014), &quot;Exploratory Mining of Life Event Histories&quot;, In McArdle, J.J. &amp; Ritschard, G. (eds) <em>Contemporary Issues in Exploratory Data Mining in the Behavioral Sciences</em>. Series: Quantitative Methodology, pp. 221-253. New York: Routledge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.seqe &lt;- seqecreate(actcal.tse[1:200,])[1:6,]
## We have 8 different events in this dataset
idcost &lt;- rep(1, 8)
dd &lt;- seqedist(actcal.seqe, idcost=idcost, vparam=.1)
</code></pre>

<hr>
<h2 id='seqedplot'>
Graphical representation of a set of events sequences.
</h2><span id='topic+seqedplot'></span>

<h3>Description</h3>

<p>This function provides two ways to represent a set of events.
The first one (<code>type="survival"</code>) plots the survival curves of the first occurrence of each event.
The second one (<code>type="hazard"</code>) plots the mean counts of each event in the successive periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqedplot(seqe,
    group=NULL, breaks=20, ages=NULL,
    main="auto", type="survival", ignore=NULL,
	with.legend="auto",cex.legend=1,
    use.layout=(!is.null(group) | with.legend!=FALSE), legend.prop=NA,
    rows=NA, cols=NA,
    xaxis="all", xlab="time",
    yaxis="all", 
    ylab=ifelse(type=="survival", "survival probability", "mean number of events"),
    cpal=NULL,
    title, withlegend, axes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqedplot_+3A_seqe">seqe</code></td>
<td>
<p>an event sequence object as defined by the <code><a href="TraMineR.html#topic+seqecreate">seqecreate</a></code> function.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_group">group</code></td>
<td>
<p>Plots one plot for each level of the factor given as argument.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_breaks">breaks</code></td>
<td>
<p>Number of breaks defining a period.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_ages">ages</code></td>
<td>
<p>Two numeric values representing minimum and maximum ages to be represented.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_main">main</code></td>
<td>
<p>String. Title of the graphic. Default is <code>"auto"</code>, i.e., group levels. Set as <code>NULL</code> to suppress titles.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_type">type</code></td>
<td>
<p>String. Type of One of <code>"survival"</code> or <code>"hazard"</code>. If <code>type="survival"</code>, survival curves of the first occurrence of each event are plotted. If <code>type="hazard"</code>, mean numbers of each event in the successive periods are plotted.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_ignore">ignore</code></td>
<td>
<p>Character vector. An optional list of events that should not be plotted.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Logical or string. Defines if and where the legend of the state colors is plotted.
The default value <code>"auto"</code> sets the position of the legend automatically.
Other possible values are <code>"right"</code> or <code>FALSE</code>. Obsolete value <code>TRUE</code> is equivalent to &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>expansion factor for setting the size of the font for the labels in the legend. The default value is 1. Values lesser than 1 will reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_use.layout">use.layout</code></td>
<td>
<p>if <code>TRUE</code>, layout is used to arrange plots when using the group option or plotting a legend.
When layout is activated, the standard <code>par(mfrow=....)</code> for arranging plots does not work. With <code>with.legend=FALSE</code> and <code>group=NULL</code>,
layout is automatically deactivated and <code>par(mfrow=....)</code> can be used.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_legend.prop">legend.prop</code></td>
<td>
<p>proportion of the graphic area used for plotting the legend when <code>use.layout=TRUE</code> and <code>with.legend=TRUE</code>.
Default value is set according to the place (bottom or right of the graphic area) where the legend is plotted. Values from 0 to 1.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_rows">rows</code></td>
<td>
<p>optional arguments to arrange plots when use.layout=TRUE.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_cols">cols</code></td>
<td>
<p>optional arguments to arrange plots when use.layout=TRUE.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> and <code>"bottom"</code>. If set as <code>TRUE</code> or &quot;all&quot; (default value) x-axes are drawn on each plot in the graphic. If set as &quot;bottom&quot; and group is used, x-axes are drawn under the plots of the bottom panel only. If FALSE, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"left"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value) y-axes are drawn on each plot in the graphic. If <code>"left"</code> and <code>group</code> is used, the y-axis is displayed on plots of the left panel only. If <code>FALSE</code> no y-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_xlab">xlab</code></td>
<td>
<p>an optional label for the x-axis. If set to <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_ylab">ylab</code></td>
<td>
<p>an optional label for the y-axis. If set to <code>NA</code>, no label is drawn. Can be a vector of labels by group level.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_cpal">cpal</code></td>
<td>
<p>Color palette used for the events. If <code>NULL</code>, a new color palette is generated.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_title">title</code></td>
<td>
<p>Deprecated. Use <code>main</code> instead.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_axes">axes</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="seqedplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>, <code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>, and/or <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer</p>


<h3>References</h3>

<p>Studer, M., Müller, N.S., Ritschard, G. &amp; Gabadinho, A. (2010), &quot;Classer, discriminer et visualiser des séquences d'événements&quot;,
In Extraction et gestion des connaissances (EGC 2010), <em>Revue des nouvelles technologies de l'information RNTI</em>. Vol. E-19, pp. 37-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.tse &lt;- actcal.tse[1:200,]
iseq &lt;- unique(actcal.tse$id)
nseq &lt;- length(iseq)
data(actcal)
actcal &lt;- actcal[rownames(actcal) %in% iseq,]
actcal.seqe &lt;- seqecreate(actcal.tse)
seqelength(actcal.seqe) &lt;- rep(12, nseq)
seqedplot(actcal.seqe, type="hazard", breaks=6, group=actcal$sex, lwd=3)
seqedplot(actcal.seqe, type="survival", group=actcal$sex, lwd=3)
</code></pre>

<hr>
<h2 id='seqemlt'>Euclidean Coordinates for Longitudinal Timelines</h2><span id='topic+seqemlt'></span>

<h3>Description</h3>

<p>Computes the Euclidean coordinates of sequences from which we get the EMLT  distance between sequences introduced in Rousset et al (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqemlt(seqdata, a = 1, b = 1, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqemlt_+3A_seqdata">seqdata</code></td>
<td>
<p> a state sequence object defined with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function.

</p>
</td></tr>
<tr><td><code id="seqemlt_+3A_a">a</code></td>
<td>
<p>optional argument for the weighting mechanism that controls the balancing between short term/long term transitions. The weighting function is <code class="reqn">1/(a*s+b)</code> where <code class="reqn">s</code> is the transition step.

</p>
</td></tr>
<tr><td><code id="seqemlt_+3A_b">b</code></td>
<td>
<p>see argument <code>a</code>.

</p>
</td></tr>
<tr><td><code id="seqemlt_+3A_weighted">weighted</code></td>
<td>
<p>Logical: Should weights in the sequence object <code>seqdata</code> be used?

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EMLT distance is the sum of the dissimilarity between the pairs of states observed at the successive positions, where the dissimilarity between states is defined at each position as the Chi-squared distance between the normalized vectors of transition probabilities (profiles of situations) from the current state to the next observed states in the sequence.
Transition probabilities are down-weighted with the time distance to avoid exaggerated importance of transitions over long periods. The adjustment weight is <code class="reqn">1/a*s+b</code>, where <code class="reqn">s</code> is the period length over which the transition probability is measured.
</p>
<p>The EMLT distance between two sequences is obtained as the Euclidean distance between the returned numerical sequence coordinates. So, providing <code>coord</code> as the data input to any clustering algorithm that uses the Euclidean metric is equivalent to cluster with the EMLT metric.
</p>
<p>Each time-indexed state is called a situation, and the distance between two states at a position <code class="reqn">t</code> is derived from the transition probabilities to other observed situations.


The distance between any situation and a situation that does not occur is coded as <code>NA</code>. Such non-occurring situations have no influence on the distance between sequences.

</p>
<p>The obtained numerical representations of sequences may be used as input to any Euclidean algorithm (clustering algorithms, ...).
</p>


<h3>Value</h3>

<p>An object of class <code>emlt</code> with the following components:
</p>
<table>
<tr><td><code>coord</code></td>
<td>
<p>Matrix with in each row the EMLT numerical coordinates of the corresponding sequence.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>list of states</p>
</td></tr>
<tr><td><code>situations</code></td>
<td>
<p>list of situations (timestamped states)</p>
</td></tr>
<tr><td><code>sit.freq</code></td>
<td>
<p>Situation frequencies</p>
</td></tr>
<tr><td><code>sit.transrate</code></td>
<td>
<p>matrix of transition probabilities from each situation to future situations</p>
</td></tr>
<tr><td><code>sit.profil</code></td>
<td>
<p>profiles of situations. Each profile is the normalized vector of transition probabilities to future situations adjusted to down weight transitions over longer periods.</p>
</td></tr>
<tr><td><code>sit.cor</code></td>
<td>
<p>Matrix of correlations between situations. Two situations are highly correlated when their profiles are similar (i.e., when their transitions towards future are similar). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Rousset and Matthias Studer. Help page by Gilbert Ritschard.
</p>


<h3>References</h3>

<p>Rousset, Patrick and  Jean-François Giret (2007), Classifying Qualitative Time Series with SOM: The Typology of Career Paths in France, in F. Sandoval, A. Prieto and M. Grana (Eds) <em>Computational and Ambient Intelligence</em>, Lecture Notes in Computer science, vol 4507,  Berlin: Springer, pp 757-764.
</p>
<p>Rousset, Patrick and  Jean-François Giret (2008) A longitudinal Analysis of  Labour Market Data with SOM, in J. Rabuñal Dopico, J. Dorado, &amp; A. Pazos (Eds.) <em>Encyclopedia of Artificial Intelligence</em>, Hershey, PA: Information Science Reference, pp 1029-1035.
</p>
<p>Rousset, Patrick, Jean-François Giret and Yvette Grelet (2012) Typologies De Parcours et Dynamique Longitudinale, <em>Bulletin de méthodologie sociologique</em>, 114(1), 5-34.
</p>
<p>Studer, Matthias  and Gilbert Ritschard (2014) A comparative review of sequence dissimilarity measures. LIVES Working Paper, 33
<a href="https://doi.org/10.12682/lives.2296-1658.2014.33">doi:10.12682/lives.2296-1658.2014.33</a>

</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.emlt">plot.emlt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mvad)
mvad.seq &lt;- seqdef(mvad[1:100, 17:41])
alphabet(mvad.seq)
head(labels(mvad.seq))
## Computing distance
mvad.emlt &lt;- seqemlt(mvad.seq)

## typology1 with kmeans in 3 clusters
km &lt;- kmeans(mvad.emlt$coord, 3)

##Plotting by clusters of typology1
seqdplot(mvad.seq, group=km$cluster)

## typology2: 3 clusters by applying hierarchical ward
##   on the centers of the 25 group kmeans solution
km&lt;-kmeans(mvad.emlt$coord, 25)
hc&lt;-hclust(dist(km$centers, method="euclidean"), method="ward")
zz&lt;-cutree(hc, k=3)

##Plotting by clusters of typology2
seqdplot(mvad.seq, group=zz[km$cluster])

## Plotting the evolution of the correlation between states
plot(mvad.emlt, from="employment", to="joblessness", type="cor")
plot(mvad.emlt, from=c("employment","HE", "school", "FE"), to="joblessness", delay=0, leg=TRUE)
plot(mvad.emlt, from="joblessness", to="employment", delay=6)
plot(mvad.emlt, type="pca", cex=0.4, compx=1, compy=2)

</code></pre>

<hr>
<h2 id='seqentrans'>Event sequence length and number of events</h2><span id='topic+seqentrans'></span>

<h3>Description</h3>

<p>Adds the sequence length (number of transitions) and total number of events of event sequences to the data attribute of a <code>subseqelist</code> event sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqentrans(fsubseq, avg.occ = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqentrans_+3A_fsubseq">fsubseq</code></td>
<td>
<p> A <code>subseqelist</code> object as returned by <code><a href="TraMineR.html#topic+seqefsub">seqefsub</a></code>.</p>
</td></tr>
<tr><td><code id="seqentrans_+3A_avg.occ">avg.occ</code></td>
<td>
<p> Logical: Should a column with average number of occurrences also be added?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An event sequence object is an ordered list of transitions, with each transition a non-ordered list of events occurring at a same position.
</p>
<p>Average occurrences by sequence may be useful when counts report number of occurrences rather than number of sequences containing the subsequence.
</p>


<h3>Value</h3>

<p>The object <code>fsubseq</code> updated with the additional information.
</p>


<h3>Author(s)</h3>

<p>Nicolas Müller and Gilbert
Ritschard</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.seqe &lt;- seqecreate(actcal.tse[1:500,])

##Searching for frequent subsequences appearing at least 10 times
fsubseq &lt;- seqefsub(actcal.seqe, min.support=10)
fsubseq &lt;- seqentrans(fsubseq)
## dispaying only those with at least 3 transitions
fsubseq[fsubseq$data$ntrans&gt;2]
## dispaying only those with at least 3 events
fsubseq[fsubseq$data$nevent&gt;2]

## Average occurrences when counting distinct occurrences
ct &lt;- seqeconstraint(count.method="CDIST_O")
fsb &lt;- seqefsub(actcal.seqe, min.support=10, constraint=ct)
fsb &lt;- seqentrans(fsb, avg.occ=TRUE)
fsb[1:10,]

</code></pre>

<hr>
<h2 id='seqerulesdisc'>Extract association rules using discrete time regression models</h2><span id='topic+seqerulesdisc'></span>

<h3>Description</h3>

<p>Extract association rules from an object created by the <code>createdatadiscrete</code> function, using discrete time regression models to assess the significance of the extracted rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqerulesdisc(fsubseq, datadiscr, tsef, pvalue=0.1, supvars=NULL, 
   adjust=TRUE, topt=FALSE, link="cloglog", dep=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqerulesdisc_+3A_fsubseq">fsubseq</code></td>
<td>
<p>an object created using the <code>seqefsub</code> function and that contains the list of subsequences to be tested for an association</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_datadiscr">datadiscr</code></td>
<td>
<p>the object created by the <code>createdatadiscrete</code> function and that contains the person-period data</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_tsef">tsef</code></td>
<td>
<p>the data frame containing the original time-to-event dataset (equivalent to the <code>data</code> argument from the <code>createdatadiscrete</code> function)</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_pvalue">pvalue</code></td>
<td>
<p>the default threshold p-value to consider an association rule as significative, default is 0.1</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_supvars">supvars</code></td>
<td>
<p>a vector of variable names to be used as control variables in the regression models (experimental)</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_adjust">adjust</code></td>
<td>
<p>if set to TRUE, a Bonferroni adjustment is applied to the p-value threshold specified in the <code>pvalue</code> argument</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_topt">topt</code></td>
<td>
<p>if set to TRUE, use an alternative algorithm to extract the rules (very experimental) ; default to FALSE</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_link">link</code></td>
<td>
<p>the link function to be used in the generalized linear regression model. To obtain hazard ratios, use the complementary log-log link function (&quot;cloglog&quot;, as default). The other choice is to use a logit link function (&quot;logit&quot;).</p>
</td></tr>
<tr><td><code id="seqerulesdisc_+3A_dep">dep</code></td>
<td>
<p>if set to NULL, test all possible association rules. If an event is set, the function will only test association rules ending with this event</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a list of subsequences created by the <code>seqefsub</code> function from the TraMineR package and tests each possible association rules. It then shows the association rules whose significance, assessed using a discrete time regression model, is higher than the specified p-value threshold.
</p>
<p>The algorithm is described in the Müller et al. (2010) article, even though this function uses a discrete time regression model instead of the Cox regression model described in the article. A more complete explanation of the method is available in Müller (2011).
</p>


<h3>Value</h3>

<p>a list with one person-period data frame by event, where the dependent event is different each time. Please see the attached data file and code for an example.</p>


<h3>Author(s)</h3>

<p>Nicolas S. Müller</p>


<h3>References</h3>

<p>Müller, N.S., M. Studer, G. Ritschard et A. Gabadinho (2010), Extraction de règles d'association séquentielle à l'aide de modèles semi-paramétriques à risques proportionnels, <em>Revue des Nouvelles Technologies de l'Information</em>, <b>Vol. E-19</b>, EGC 2010, pp. 25-36.
</p>
<p>Müller, N.S. (2011), Inégalités sociales et effets cumulés au cours de la vie : concepts et méthodes, <em>Thèse de doctorat, Faculté des sciences économiques et sociales, Université de Genève</em>, http://archive-ouverte.unige.ch/unige:17746.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createdatadiscrete">createdatadiscrete</a></code> to create the object needed as the <code>datadiscr</code> argument.
<code><a href="TraMineR.html#topic+seqefsub">seqefsub</a></code> to create the object needed as the <code>fsubseq</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='seqgen.missing'>
Generate random missing states within a state sequence object
</h2><span id='topic+seqgen.missing'></span>

<h3>Description</h3>

<p>The function assigns missing values (<code>nr</code> attribute of the object, which is <code>"*"</code> by default) to randomly selected positions in randomly selected cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqgen.missing(seqdata, p.cases = 0.1, p.left = 0.2, p.gaps = 0, p.right = 0.3,
          mt.left="nr", mt.gaps="nr", mt.right="nr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgen.missing_+3A_seqdata">seqdata</code></td>
<td>

<p>A state sequence object
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_p.cases">p.cases</code></td>
<td>

<p>Proportion of cases with missing values.
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_p.left">p.left</code></td>
<td>

<p>Proportion of left missing values.
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_p.gaps">p.gaps</code></td>
<td>

<p>Proportion of gap missing values.
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_p.right">p.right</code></td>
<td>

<p>Proportion of right missing values.
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_mt.left">mt.left</code></td>
<td>

<p>Type of left missing. One of <code>"nr"</code> (non response state) or <code>"void"</code>
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_mt.gaps">mt.gaps</code></td>
<td>

<p>Type of gap missing. One of <code>"nr"</code> (non response state) or <code>"void"</code>
</p>
</td></tr>
<tr><td><code id="seqgen.missing_+3A_mt.right">mt.right</code></td>
<td>

<p>Type of right missing. One of <code>"nr"</code> (non response state) or <code>"void"</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of the function is essentially pedagogical. It may serve to illustrate how results of a sequential analysis may be affected by the presence of random missing states.
</p>
<p>States in the sequences are randomly replaced with missing values. For each selected sequence, first, a random proportion between 0 and <code>p.gaps</code> of gaps are randomly inserted, then a random proportion between 0 and <code>p.left</code> of positions from the start of the sequence are set as missing, and finally a random proportion between 0 and <code>p.right</code> of positions from the end of the sequence are set as missing. Left missing values may possibly overlap gaps, and right missing values may overlap gaps and/or right missing values.
</p>


<h3>Value</h3>

<p>The resulting state sequence object.
</p>


<h3>Warning </h3>

<p>This function needs further testing.</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create the biofam.seq state sequence object from the biofam data.
data(biofam)
biofam.seq &lt;- seqdef(biofam[1:100,10:25])

## Generate missing states within 60% of the sequences.
biofamm.seq &lt;- seqgen.missing(biofam.seq, p.cases=.6,
      p.left=.4, p.gaps=.2, p.right=.5)

## compare the rendering of the sequences before and after
##   introducing missing states.
par(mfrow=c(2,2))
seqIplot(biofam.seq, sortv="from.end", with.legend=FALSE)
seqIplot(biofamm.seq, sortv="from.end", with.legend=FALSE)
seqdplot(biofam.seq, with.missing=TRUE, border=NA, with.legend=FALSE)
seqdplot(biofamm.seq, with.missing=TRUE, border=NA, with.legend=FALSE)
dev.off()
</code></pre>

<hr>
<h2 id='seqgranularity'>
Changing sequence time granularity by aggregating positions
</h2><span id='topic+seqgranularity'></span>

<h3>Description</h3>

<p>Changes time granularity of a state sequence object by aggregating successive positions into groups of a user-defined time length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqgranularity(seqdata, tspan = 3, method = "last")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgranularity_+3A_seqdata">seqdata</code></td>
<td>

<p>A state sequence object.
</p>
</td></tr>
<tr><td><code id="seqgranularity_+3A_tspan">tspan</code></td>
<td>

<p>Integer. Number of successive positions grouped together.
</p>
</td></tr>
<tr><td><code id="seqgranularity_+3A_method">method</code></td>
<td>

<p>Character string. Aggregating method. One of <code>"first"</code>, <code>"first.valid"</code>, <code>"last"</code> (default), <code>"last.valid"</code>, \ or <code>"mostfreq"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Successive positions are aggregated by group of <code>tspan</code> states. The aggregated state is, depending of the <code>method</code> chosen, either the first (<code>"first"</code>), the first valid (<code>"first.valid"</code>), the last (<code>"last"</code>), the last valid (<code>"last.valid"</code>), or the most frequent (<code>"mostfreq"</code>) state of the <code>tspan</code> long spell. The same applies to the last spell, even when it is shorter than <code>tspan</code>.
</p>
<p>Methods (<code>"first"</code>) and (<code>"last"</code>) differ from (<code>"first.valid"</code>) and (<code>"last.valid"</code>) only when sequences contain missing values and/or have different lengths.
</p>
<p>When there are (void or non void) missings, method <code>"mostfreq"</code> replaces each interval with the most frequent valid state on the interval or the missing state when there are no valid state.
</p>
<p>End missings are set as void when there are voids in <code>seqdata</code> and as the <code>nr</code> attribute otherwise.
</p>


<h3>Value</h3>

<p>A <code>stslist</code> object: The compacted state sequence object.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer and Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad &lt;- mvad[1:100,]
mvad.seq &lt;- seqdef(mvad[,17:86], xtstep=12)
mvadg.seq &lt;- seqgranularity(mvad.seq, tspan=6, method="first")
par(mfrow=c(2,1))
seqdplot(mvad.seq, with.legend=FALSE, border=NA)
seqdplot(mvadg.seq, with.legend=FALSE)

</code></pre>

<hr>
<h2 id='seqimplic'>
Position wise group-typical states

</h2><span id='topic+seqimplic'></span><span id='topic+print.seqimplic'></span><span id='topic+plot.seqimplic'></span>

<h3>Description</h3>

<p>Visualization and identification of the states that best characterize a group of sequences versus the others at each position (time point). The typical states are identified at each position as those for which we have a high implication strength to be in when belonging to the group.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqimplic(seqdata, group, with.missing = FALSE, weighted = TRUE, na.rm = TRUE)
## S3 method for class 'seqimplic'
plot(x, main = NULL, ylim = NULL, xaxis = TRUE,
    ylab = "Implication", yaxis = TRUE, axes = "all", xtlab = NULL,
    xtstep = NULL, tick.last = NULL, cex.axis = 1, with.legend = "auto",
    ltext = NULL, cex.legend = 1, legend.prop = NA, rows = NA, cols = NA,
    conf.level = 0.95, lwd = 1, only.levels = NULL, ...)
## S3 method for class 'seqimplic'
print(x, xtstep = NULL, tick.last = NULL, round = NULL,
    conf.level = NULL, na.print = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqimplic_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_group">group</code></td>
<td>

<p>a factor giving the group membership of each sequence in <code>seqdata</code>.
</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), missing values are discarded. If <code>TRUE</code>, missing values are coded as a specific state.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the implicative strength of the rules are computed using the weights assigned to the state sequence object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).
Set as <code>FALSE</code> to ignore the weights.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), observations with missing values on the <code>group</code> variable are discarded. If <code>FALSE</code>, the missing group value defines a specific group.
</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_x">x</code></td>
<td>

<p>A sequence of typical state object as generated by <code>seqimplic</code>.
</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_xtstep">xtstep</code></td>
<td>
<p>Integer. Optional interval at which the tick-marks and labels of the x-axis are displayed. For example, with <code>xtstep=3</code> a tick-mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_main">main</code></td>
<td>
<p>title for the graphic. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.
</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis (time) be plotted?.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for the y-axis. If set as <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical. Should the y axis be plotted?. When set as <code>TRUE</code>, sequence indexes are displayed. </p>
</td></tr>
<tr><td><code id="seqimplic_+3A_axes">axes</code></td>
<td>
<p>If set as <code>"all"</code> (default value) x-axes are drawn for each plot in the graphic. If set as <code>"bottom"</code>, axes are drawn only under the plots located at the bottom of the graphic area. If <code>FALSE</code>, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_xtlab">xtlab</code></td>
<td>
<p>optional labels for the x-axis ticks labels. If unspecified, the column names of the <code>seqdata</code> sequence object are used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor for setting the size of the font for the axis labels and names. The default value is 1. Values lesser than 1 will reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_with.legend">with.legend</code></td>
<td>
<p>One of <code>"auto"</code> (default), <code>"right"</code> or <code>FALSE</code>. Defines if and where the legend of the state colors is plotted. With <code>"auto"</code> sets the position of the legend is set automatically. The obsolete value <code>TRUE</code> is equivalent to <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_ltext">ltext</code></td>
<td>
<p>optional description of the states to appear in the legend. Must be a vector of character strings with number of elements equal to the size of the alphabet. If unspecified, the <code>label</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_cex.legend">cex.legend</code></td>
<td>
<p>expansion factor for setting the size of the font for the labels in the legend. The default value is 1. Values smaller than 1 reduce the size of the font, values greater than 1 increase the size.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Proportion (between 0 and 1) of the graphic area used for plotting the legend when <code>use.layout=TRUE</code> and <code>withlegend=TRUE</code>. The default value is set according to the place (bottom or right of the graphic area) where the legend is plotted. </p>
</td></tr>
<tr><td><code id="seqimplic_+3A_rows">rows</code>, <code id="seqimplic_+3A_cols">cols</code></td>
<td>
<p>optional arguments to arrange plots when <code>use.layout=TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_lwd">lwd</code></td>
<td>
<p>The line width, a positive number. See <code><a href="graphics.html#topic+lines">lines</a></code></p>
</td></tr>
<tr><td><code id="seqimplic_+3A_only.levels">only.levels</code></td>
<td>
<p>Optional list of levels of the <code>group</code> variable to be plotted. By default all levels are plotted.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_round">round</code></td>
<td>
<p>Optional number of decimals when printing a <code>seqimplic</code> object.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence levels thresholds (default is 0.95).</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_na.print">na.print</code></td>
<td>
<p>Character string (or <code>NULL</code>) used for <code>NA</code> values in printed output, see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="seqimplic_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code> (for <code>print</code> method) or <code><a href="graphics.html#topic+lines">lines</a></code> (for <code>plot</code> method).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqimplic</code> function builds an object with the position wise typical states. It can be used to visualize or identify the differences between each group of trajectories and the other ones.
It presents at each time point the typical states of a subpopulation (for instance women, as opposed to men).
A state at a given time point is considered to be typical of a group if the rule &quot;Being in this group implies to be in that state at this time point&quot; is relevant according to the implicative statistic.
</p>
<p>The implicative statistic assesses the statistical relevance of a rule of the form &quot;A implies B&quot; (Gras et al., 2008).
It does so by measuring the gap between the expected and observed numbers of counter examples.
The rule is considered to be strongly implicative if we observe much less counter examples than expected under the independence assumption.
This gap and its significance are computed using adjusted residuals of a contingency table with continuity correction as proposed by Ritschard (2005).
In order to improve the readability of the graphs, we use here the opposite of the implicative statistic, which is highly negative for significant rules.
The statistic  <code class="reqn">I(A\rightarrow B)</code> measuring the relevance of the rule  &quot;A implies B&quot; reads as follows:
</p>
<p style="text-align: center;"><code class="reqn">I(A\rightarrow B)=-\frac{n_{\bar{B}A}+0.5-n^e_{\bar{B}A}}{\sqrt{n^{e}_{\bar{B}A}(n_{B.}/n)(1-n_{.A}/n)}}</code>
</p>

<p>Where <code class="reqn">n_{\bar{B}A}</code> is the observed number of counter-examples, <code class="reqn">n^{e}_{\bar{B}A}</code> the expected number of counter-examples under the independence assumption,
<code class="reqn">n_{B.}</code> the number of times that B is observed, <code class="reqn">n_{.A}</code> the number of times that A is observed and <code class="reqn">n</code> the total number of cases.
</p>
<p>The plot function can be used to visualize the results. It produces a separate plot for each level of the <code>group</code> variable.
In each plot, it presents at each time point <code class="reqn">t</code>, the relevance of the rule &quot;Being in this group implies to be in this state at this time point&quot;.
The higher the plotted value, the higher the relevance of the rule.
The horizontal dashed lines indicate the confidence thresholds. A rule is considered as statistically significant at the 5% level if it exceeds the 95% confidence horizontal line.
The strength of rules with negative implicative statistic are not displayed because they have no meaningful interpretation.
</p>


<h3>Value</h3>

<p><code>seqimplic</code> returns a <code>"seqimplic"</code> object that can be plotted and printed. The values of the implicative statistics at each time point are in the element <code>indices</code> of the object.</p>


<h3>Author(s)</h3>

<p>Matthias Studer.
</p>


<h3>References</h3>

<p>Studer, Matthias (2015), Comment: On the Use of Globally Interdependent Multiple Sequence Analysis, Sociological Methodology 45, <a href="https://doi.org/10.1177/0081175015588095">doi:10.1177/0081175015588095</a>.
</p>
<p>Gras, Régis and Kuntz, Pascale. (2008), An overview of the Statistical Implicative Analysis (SIA) development, in Gras, R., Suzuki, E., Guillet, F. and Spagnolo, F. (eds), Statistical Implicative Analysis: Theory and application, Series Studies in Computational Intelligence, Vol 127, Berlin: Springer-Verlag, pp 11-40.
</p>
<p>Ritschard, G. (2005). De l'usage de la statistique implicative dans les arbres de classification. In Gras, R., Spagnolo, F., and David, J., editors, Actes des Troisièmes Rencontres Internationale ASI Analyse Statistique Implicative, volume Secondo supplemento al N.15 of Quaderni di Ricerca in Didattica, pages 305–314. Università a degli Studi di Palermo, Palermo.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)

## Building a state sequence object
mvad.seq &lt;- seqdef(mvad, 17:86)
## Sequence of typical states
mvad.si.gcse5eq &lt;- seqimplic(mvad.seq, group=mvad$gcse5eq)

##Plotting the typical states
plot(mvad.si.gcse5eq, lwd=3, conf.level=c(0.95, 0.99))

## Printing the results
print(mvad.si.gcse5eq, xtstep=12)
</code></pre>

<hr>
<h2 id='seqindic.dyn'>Dynamic index

</h2><span id='topic+seqindic.dyn'></span><span id='topic+print.dynin'></span>

<h3>Description</h3>

<p>Dynamic (i.e. successive) values of an individual index. For each sequence, the values of the selected index is computed on sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqindic.dyn(seqdata, indic="cplx", window.size = .2, sliding=TRUE,
      wstep=1, with.missing=FALSE, endmiss.as.void=FALSE, silent.indic=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqindic.dyn_+3A_seqdata">seqdata</code></td>
<td>
<p>state sequence object (<code>stslist</code>) as produced by <code>seqdef</code>
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_indic">indic</code></td>
<td>
<p>character string: the individual index. Can be any value supported by <code><a href="TraMineR.html#topic+seqindic">seqindic</a></code> except index group names.
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_window.size">window.size</code></td>
<td>
<p>integer or real. If an integer &gt; 1, window size in number of positions. If real number in the range ]0,1), the window size is set as that proportion of the length of the longest sequence.
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_sliding">sliding</code></td>
<td>
<p>logical: Should indic be computed on sliding windows? If <code>FALSE</code>, windows are incremented starting with a window of size <code>window.size</code>.
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_wstep">wstep</code></td>
<td>
<p>integer: size of position gap between successive windows.
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_with.missing">with.missing</code></td>
<td>
<p>logical. Should the missing state be treated as a state of the alphabet?
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_endmiss.as.void">endmiss.as.void</code></td>
<td>
<p>logical. When <code>with.missing=FALSE</code>, should missings at end of windows be considered as voids, i.e. should the sequence end before end missings? When <code>FALSE</code> (default), the index is set as <code>NA</code> for windows that end with a void and, when <code>TRUE</code>, for windows that end with a void or a missing. Ignored when <code>with.missing=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_silent.indic">silent.indic</code></td>
<td>
<p>logical. Should messages issued during computation of indic be suppressed?
</p>
</td></tr>
<tr><td><code id="seqindic.dyn_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="TraMineR.html#topic+seqindic">seqindic</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the dynamic sequence analysis approach of <cite>Pelletier et al. (2020)</cite> and generalizes the method to any of the over 20 indicators provided by <code><a href="TraMineR.html#topic+seqindic">seqindic</a></code>.
</p>
<p>The values of the <code>indic</code> index are computed for each sequence either on sliding windows of size <code>window.size</code> or on incremental windows starting from a first window of size <code>window.size</code>.
</p>
<p>Column names refer to the end the windows.
</p>


<h3>Value</h3>

<p>A matrix of class <code>dynin</code> with attributes <code>xtstep</code>, <code>tick.last</code>, <code>weights</code>, <code>window.size</code>, <code>sliding</code>, and <code>indic</code>. The first three as well as the row and column names are taken from <code>seqdata</code>.
</p>
<p>There are <code>print</code> and <code>plot</code> methods for <code>dynin</code> objects. See <code><a href="#topic+plot.dynin">plot.dynin</a></code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>References</h3>

<p>Pelletier, D., Bignami-Van Assche, S., &amp; Simard-Gendron, A. (2020) Measuring Life Course Complexity with Dynamic Sequence Analysis, <em>Social Indicators Research</em> <a href="https://doi.org/10.1007/s11205-020-02464-y">doi:10.1007/s11205-020-02464-y</a>.
</p>



<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqindic">seqindic</a></code>, <code><a href="#topic+plot.dynin">plot.dynin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
cases &lt;- 1:100
actcal &lt;- actcal[cases,] ## Here, only a subset
actcal.seq &lt;- seqdef(actcal[,13:24], alphabet=c('A','B','C','D'))

## Using windows every three positions
a.dyn &lt;- seqindic.dyn(actcal.seq, indic='cplx', with.missing=FALSE, wstep=3)
plot(a.dyn, group=actcal[cases,'sex'])

## Trimmed mean (to illustrate fstat with specific arguments) 
plot(a.dyn, group=actcal[cases,'sex'], fstat=function(x)mean(x, trim=.02))

## Incremental windows
ai.dyn &lt;- seqindic.dyn(actcal.seq, indic='cplx', with.missing=FALSE, wstep=3, 
                sliding=FALSE)
plot(ai.dyn, group=actcal[cases,'sex'])

#############
## Sequences of different lengths, and with missing values and weights
data(ex1)
s.ex1 &lt;- seqdef(ex1[,1:13],weights=ex1[,"weights"])
seqlength(s.ex1)
seqlength(s.ex1, with.missing=FALSE)
group &lt;- c(1,1,1,2,2,2,2)

ind.d &lt;- seqindic.dyn(s.ex1, indic='cplx', with.missing=FALSE)
plot(ind.d, group=group, fstat=weighted.mean, na.rm=TRUE, conf=TRUE, ret=TRUE)

## Treating 'missing' as a regular state
ind.dm &lt;- seqindic.dyn(s.ex1, indic='cplx', with.missing=TRUE)
plot(ind.dm, group=group, fstat=weighted.mean, na.rm=TRUE, conf=TRUE, ret=TRUE)
</code></pre>

<hr>
<h2 id='seqplot.rf'>
Relative Frequency Sequence Plots.
</h2><span id='topic+seqplot.rf'></span>

<h3>Description</h3>

<p>Relative Frequency Sequence Plots (RFS plots) plot a selection of representative sequences as sequence index plots (see <code><a href="TraMineR.html#topic+seqIplot">seqIplot</a></code>). RFS plots proceed in several steps. First a set of sequences is ordered according to a substantively meaningful principle, e.g. according to their score on the first factor derived by applying Multidimensional scaling (default) or a user defined sorting variable, such as the timing of a transition of interest. Then the sorted set of sequences is partitioned in to k equal sized frequency groups. For each frequency group the medoid sequence is selected as a representative. The selected representatives are plotted as sequence index plots. RFS plots come with an additional distance-to-medoid box plot that visualizes the distances of all sequences in a frequency group to their respective medoid. Further, an R2 and F-statistic are given that indicate how well the selected medoids represent a given set of sequences. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplot.rf(seqdata, k = floor(nrow(seqdata)/10), diss, sortv = NULL,
    ylab=NA, yaxis=FALSE, main=NULL, which.plot="both",
    grp.meth = "first", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplot.rf_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_k">k</code></td>
<td>
<p>integer: Number of groupings (frequency groups?)</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_diss">diss</code></td>
<td>
<p>matrix of pairwise dissimilarities between sequences in <code>seqdata</code> (see <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>).</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_sortv">sortv</code></td>
<td>
<p>an optional sorting variable that may be used to compute the frequency groups. If <code>NULL</code>, an MDS is used. Ties are randomly ordered.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_ylab">ylab</code></td>
<td>
<p>string. An optional label for the y-axis. If set as <code>NA</code> (default), no label is drawn. Does not apply to <code>which.plot="both"</code>.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_yaxis">yaxis</code></td>
<td>
<p>logical. Controls whether a y-axis is plotted. When set as <code>TRUE</code>, the indexes of the sequences are displayed.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_main">main</code></td>
<td>
<p>main graphic title. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_which.plot">which.plot</code></td>
<td>
<p>string. One of <code>"both"</code>, <code>"medoids"</code>, <code>"diss.to.med"</code>. When <code>"medoids"</code>, only the index plot of the medoids is displayed, when <code>"diss.to.med"</code>, the grouped boxplots of the distances to the medoids is displayed, and when <code>"both"</code> a combined plot of the two is displayed.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_grp.meth">grp.meth</code></td>
<td>
<p>character string. One of <code>"first"</code> or <code>"random"</code>. When the number of sequences is not a multiple of the number groups, which groups should have their size augmented by one unit? If <code>"first"</code>, the first groups, and if <code>"random"</code> a random selection of groups.</p>
</td></tr>
<tr><td><code id="seqplot.rf_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RFS plots are useful to visualize large sets of sequences that cannot be plotted with sequence index plots due to overplotting (see <code><a href="TraMineR.html#topic+seqIplot">seqIplot</a></code>). Due to the partitioning into equal sized frequency groups each selected sequence represents an equal portion of the original sample and thereby visually maintains the relative proportion of different types of sequences along the sorting criterion. The ideal number of <code class="reqn">k</code> fequency groups depends on the size of the original sample and the empirical distribution of the sequences. The larger the sample and the more heterogeneous the sequences, higher numbers of <code class="reqn">k</code> will be advisable. To avoid overplotting <code class="reqn">k</code> should generally not be  higher than 200.
</p>
<p>Note that distance-to-medoid plots are meaningful only if there are at least 5-10 sequences in each frequency group. The distance-to-medoid plot is not only a quality criterion of how well the medoids represent a respective frequency group. They also provide additional substantive information about how large the variation of sequences is at a given location of the ordered sequences (see Fasang and Liao 2014).
</p>
<p>Since ties in <code>sortv</code> or mds are randomly ordered (see argument <code>ties.method="random"</code> of function <code><a href="base.html#topic+rank">rank</a></code>), one has to set the seed to reproduce exactly the same plot (see <code><a href="base.html#topic+set.seed">set.seed</a></code>).
</p>
<p>Unlike the other <code><a href="TraMineR.html#topic+TraMineR">TraMineR</a></code> plotting functions, the <code>seqplot.rf</code> function ignores the <code>weights</code> and does not support the <code>group</code> argument.
</p>


<h3>Value</h3>

<p>A vector with the group membership (medoid of the group) of each sequence.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Anette Eva Fasang, Tim Liao, and Gilbert Ritschard.
</p>


<h3>References</h3>

<p>Fasang, Anette Eva and Tim F. Liao. 2014. &quot;Visualizing Sequences in the Social Sciences: Relative Frequency Sequence Plots.&quot; Sociological Methods &amp; Research 43(4):643-676.
</p>


<h3>See Also</h3>

<p>See also <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>, <code><a href="TraMineR.html#topic+seqrf">seqrf</a></code>, <code><a href="TraMineR.html#topic+seqrep">seqrep</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")

## Here, we use only 100 cases selected such that all elements
## of the alphabet be present.
## (More cases and a larger k would be necessary to get a meaningful example.)
biofam.seq &lt;- seqdef(biofam[501:600, ], 10:25, labels=biofam.lab)
diss &lt;- seqdist(biofam.seq, method="LCS")

## Using 12 groups and default MDS sorting
seqplot.rf(biofam.seq, diss=diss, k=12,
   main="Non meaningful example (n=100)")


## With a user specified sorting variable
## Here time spent in parental home: there are ties
## We set a seed because of random order in ties
set.seed(123)
parentTime &lt;- seqistatd(biofam.seq)[, 1]
seqplot.rf(biofam.seq, diss=diss, k=12, sortv=parentTime,
   main="Sorted by parent time")

</code></pre>

<hr>
<h2 id='seqplot.tentrop'>Plotting superposed transversal-entropy curves</h2><span id='topic+seqplot.tentrop'></span><span id='topic+seqplot.tentrop.m'></span>

<h3>Description</h3>

<p>Functions to plot, in a same frame, transversal-entropy curves by group or multiple curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplot.tentrop(seqdata, group, main="auto",
    col=NULL, lty=NULL, lwd=3.5, ylim=NULL, xtlab=NULL,
    xtstep=NULL, tick.last=NULL, with.legend=TRUE, glabels=NULL,
    legend.pos="topright", horiz=FALSE, cex.legend=1, ...)

seqplot.tentrop.m(seqdata.list, main="auto",
    col=NULL, lty=NULL, lwd=3.5, ylim=NULL, xtlab=NULL,
    xtstep=NULL, tick.last=NULL, with.legend=TRUE,
    glabels=names(seqdata.list),
    legend.pos="topright", horiz=FALSE, cex.legend=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplot.tentrop_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_seqdata.list">seqdata.list</code></td>
<td>
<p>a list of state sequence objects.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_group">group</code></td>
<td>
<p>a factor giving the group membership of each sequence in <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_main">main</code></td>
<td>
<p>a character string giving the title of the graphic; if <code>"auto"</code>, a default title is printed.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_col">col</code></td>
<td>
<p>a vector of colors for the different curves.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_lty">lty</code></td>
<td>
<p>a vector of line types for the different curves. See <code><a href="graphics.html#topic+lines">lines</a></code>. </p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_lwd">lwd</code></td>
<td>
<p>numeric or vector of numerics: width of curve lines. See <code><a href="graphics.html#topic+lines">lines</a></code>. </p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_ylim">ylim</code></td>
<td>
<p>pair of numerics defining the range for the y-axis. If left <code>NULL</code>, the limits are defined from the data.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_xtlab">xtlab</code></td>
<td>
<p>vector of strings defining the x-axis tick labels.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_xtstep">xtstep</code></td>
<td>
<p>integer: step between tick marks on the x-axis. If unspecified, attribute <code>xtstep</code> of (first) <code>seqdata</code> is used.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_tick.last">tick.last</code></td>
<td>
<p>logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, attribute <code>tick.last</code> of (first) <code>seqdata</code> is used.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_glabels">glabels</code></td>
<td>
<p>a vector of strings with the curve labels. If <code>NULL</code> curves are labeled with the levels of the group variable or, for <code>seqplot.tentrop.m</code>, as <code>seq1, seq2, ...</code></p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_with.legend">with.legend</code></td>
<td>
<p>logical: Should the legend be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_legend.pos">legend.pos</code></td>
<td>
<p>legend position: default is <code>"topright"</code>. See<code><a href="graphics.html#topic+legend">legend</a> </code>.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_horiz">horiz</code></td>
<td>
<p>logical: Should the legend be displayed horizontally. Set as <code>FALSE</code> by default, i.e., legend is displayed vertically.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Scale factor for the legend.</p>
</td></tr>
<tr><td><code id="seqplot.tentrop_+3A_...">...</code></td>
<td>
<p>additional plot parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>seqplot.tentrop</code> to plot curves of transversal entropies by groups of a same set of sequences, e.g. professional careers by sex.
</p>
<p>Use <code>seqplot.tentrop.m</code> to plot multiple curves of transversal entropies corresponding to different sets of sequences such as sequences describing cohabitational and sequences describing occupational trajectories.
</p>


<h3>Value</h3>

<p>Number <code>k</code> of survival curves plotted.
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqHtplot">seqHtplot</a></code> for an alternative way of plotting the transversal entropies and <code><a href="TraMineR.html#topic+seqstatd">seqstatd</a> </code> to get the values of the entropies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the biofam data which has sequences from
## ages 15 to 30 years in columns 10 to 25
data(biofam)
biofam &lt;- biofam[1:200,]
biofam.seq &lt;- seqdef(biofam[,10:25], xtlab=as.character(15:30), xtstep=3)

## Plotting transversal entropies by sex
seqplot.tentrop(biofam.seq, group=biofam$sex, legend.pos="bottomright")

slist &lt;- list(woman = biofam.seq[biofam$sex=="woman",],
                man = biofam.seq[biofam$sex=="man",])
seqplot.tentrop.m(slist, legend.pos="bottomright")

## Plotting transversal entropies for women
## by father's social status
group &lt;- biofam$cspfaj[biofam$sex=="woman"]
seqplot.tentrop(biofam.seq[biofam$sex=="woman",], group=group,
    main="Women, by father's social status", legend.pos="bottomright")

</code></pre>

<hr>
<h2 id='seqpolyads'>Measuring the Degree of Within-Polyadic Similarities</h2><span id='topic+seqpolyads'></span>

<h3>Description</h3>

<p>The function computes measures of the degree of similarities within polyadic member sequences compared to randomly assigned polyadic member sequences.</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqpolyads(seqlist, a=1, method="HAM", ...,
    w=rep(1,ncol(combn(1:length(seqlist),2))),
    s=36963, T=1000, core=1, replace=TRUE, weighted=TRUE,
    with.missing=FALSE, rand.weight.type=1, role.weights=NULL,
    show.time=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqpolyads_+3A_seqlist">seqlist</code></td>
<td>
<p>A list of <var>J&gt;1</var> state sequence <code>stslist</code> objects. List of input sets (polyads) of polyadic sequences. The state sequence objects in the list must all have the same number <var>N</var> of sequences and the same alphabet.  The state sequence objects should be created with <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> and the list with <code><a href="base.html#topic+list">list</a></code>. E.g., <code>list(gen1.seq,</code><code>gen2.seq,</code><code>gen3.seq)</code>.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_a">a</code></td>
<td>
<p>Integer, 1 or 2. Random generation mechanism. If 1 (default), draws from the observed set of sequences, and if 2, in addition random draws of states from each randomly drawn sequence. See reference below for detail.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_method">method</code></td>
<td>
<p>String. Method for computing sequence distances. See <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>. Additional arguments may be required depending on the method chosen.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="TraMineR.html#topic+seqdist">seqdist</a></code>
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_s">s</code></td>
<td>
<p>Integer. Default 36963. Using the same seed number on the same computer guarantees the same results each time. Set <code>s=NULL</code> if you don't want to set a seed. The random generator can be chosen with <code><a href="base.html#topic+RNGkind">RNGkind</a></code>.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_w">w</code></td>
<td>
<p>Integer vector. Default 1. The weights assigned to between-polyadic member sets in the weight matrix. For example, for dyadic sequences, no weight is necessary and the distance computation takes on the default of 1. For triadic sequences, there are three weights between the first and the second members, the first and the third members, and the second and the third members, in a row-wise order. See reference below.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_t">T</code></td>
<td>
<p>Integer. Default 1,000. The number of randomized computations.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_core">core</code></td>
<td>
<p>Integer. Default 1. Number of cores for the computation. When greater than 1, the procedure utilizes parallel processing.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_replace">replace</code></td>
<td>
<p>Logical. When <code>a=2</code>, should state sampling in each sequence be done with replacement? Default is <code>TRUE</code>. Ignored when <code>a=1</code>.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should we account for the weights when present in the sequence objects? See details. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should the missing state be considered as a regular state? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_rand.weight.type">rand.weight.type</code></td>
<td>
<p>Integer, 1 or 2. Ignored when <code>weighted=FALSE</code>. If 1 (default), weight of each randomized polyad is the average of original weights of its members. If 2, member weights are adjusted by dividing them by the sum of weights of all drawn members of the same type.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_role.weights">role.weights</code></td>
<td>
<p><code>NULL</code> or vector of non-negative weights of same length as the list <code>seqlist</code>. Ignored when <code>weighted=FALSE</code>. If non null, role weights for determining the weights of the randomized polyads.
</p>
</td></tr>
<tr><td><code id="seqpolyads_+3A_show.time">show.time</code></td>
<td>
<p>Logical. Should elapsed time be displayed? Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the polyadic distance of the observed polyads, i.e., the (weighted) mean of the pairwise distances between members of the polyad. In addition, the following statistics are computed:
</p>
<p>The <var>U</var> statistic measures for each observed polyad by how much its polyadic distance differs from the mean polyadic distance of <code>T</code> randomized polyads. <var>U.tp</var> is the <var>p</var>-value for a two-tailed <var>t</var>-test of the <var>U</var> statistic.
</p>
<p>The <var>V</var> statistic is, for each observed polyad, the proportion of <code>T</code> randomized polyads that have a greater polyadic distance. <var>V.95</var> is an associated dummy that takes value 1 when the proportion <var>V</var> is greater than 95% and 0 otherwise.
</p>
<p>When the sequence objects in <code>seqlist</code> have weights and <code>weighted=TRUE</code>, the randomized sequences are sampled using the weights of the first element in the list. Each member of an observed polyad is supposed to have the same weight. This does not hold for the randomized polyads that are obtained by sampling their members independently. The weights of each randomized sequence is set as the average of the weights of its members.  When role weights are provided with <code>role.weights</code>, a weighted average of the member weights is used. When <code>rand.weight.type=1</code>, original member weights are used. When <code>rand.weight.type=2</code>, the weights of randomly selected members are adjusted by the sum of weights of all randomly drawn members of the same type.
</p>
<p>When <code>core &gt; 1</code>, the function uses the <code>doParallel</code> package for parallel computation.
</p>


<h3>Value</h3>

<p>The function outputs a list of seven objects:
</p>
<table>
<tr><td><code>mean.dist</code></td>
<td>
<p>Vector of length 2 with the average observed and random within-polyadic distances.
</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Vector of <var>N</var> number of <var>U</var> statistics (see reference).
</p>
</td></tr>
<tr><td><code>U.tp</code></td>
<td>
<p>Vector of <var>N</var> number of <var>p</var>-values for a two-tailed <var>t</var>-test of the <var>U</var> statistic.
</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>Vector of <var>N</var> number of <var>V</var> statistics (see reference).
</p>
</td></tr>
<tr><td><code>V.95</code></td>
<td>
<p>Vector of <var>N</var> number of 1s or 0s: 1 if a <var>V</var> value is at least 95 percent confident, 0 otherwise.
</p>
</td></tr>
<tr><td><code>observed.dist</code></td>
<td>
<p>Vector of within-polyadic distances for the observed  polyadic members.
</p>
</td></tr>
<tr><td><code>random.dist</code></td>
<td>
<p>Vector of within-polyadic distances for the <var>T</var> number of randomly matched polyadic members.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Liao and Gilbert Ritschard</p>


<h3>References</h3>

<p>Tim F. Liao (2021), &quot;Using Sequence Analysis to Quantify How Strongly Life Courses Are Linked.” <em>Sociological Science</em> <b>8</b>, 48-72, <a href="https://doi.org/10.15195/v8.a3">doi:10.15195/v8.a3</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(polyads)
Gen &lt;- polyads$Gen
seqGrandP &lt;- seqdef(polyads[Gen=="1st Generation",2:11])
seqParent &lt;- seqdef(polyads[Gen=="2nd Generation",2:11])
seqChild &lt;- seqdef(polyads[Gen=="3rd Generation",2:11])
Seq &lt;- rbind(seqGrandP,seqParent,seqChild)
slgth &lt;- ncol(Seq)
colnames(Seq) &lt;- 21:30
seqIplot(Seq,group=Gen,idxs=10:1,ylab="Triad",xlab="Age")
seqL &lt;- list(seqGrandP,seqParent,seqChild)
core=1
seqG2.Tim &lt;- seqpolyads(seqL[1:2],method="HAM",a=1,core=core,T=100)
seqG3.Tim &lt;- seqpolyads(seqL,method="HAM",a=1,core=core,T=100)
seqG2.Dur &lt;- seqpolyads(seqL[1:2],method="CHI2",step=slgth,core=core,T=100)
seqG3.Dur &lt;- seqpolyads(seqL,method="CHI2",step=slgth,core=core,T=100)

</code></pre>

<hr>
<h2 id='seqrep.grp'>
Finding representative sets by group and their quality statistics.
</h2><span id='topic+seqrep.grp'></span>

<h3>Description</h3>

<p>This function determines representative sequences by group and returns the representatives by group and/or the quality statistics of the representative sets. The function is a wrapper for the TraMineR <code><a href="TraMineR.html#topic+seqrep">seqrep</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqrep.grp(seqdata, group = NULL, diss = NULL, ret = "stat",
    with.missing = FALSE, mdis, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqrep.grp_+3A_seqdata">seqdata</code></td>
<td>

<p>state sequence object as defined by <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>.
</p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_group">group</code></td>
<td>

<p>group variable. If <code>NULL</code> a single group is assumed.
</p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_diss">diss</code></td>
<td>

<p>dissimilarity matrix. If <code>NULL</code> the &ldquo;LCS&rdquo; dissimilarity matrix is computed.
</p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_ret">ret</code></td>
<td>

<p>What should be returned? One of <code>"stat"</code> (default), <code>"rep"</code> or <code>"both"</code>.
</p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_with.missing">with.missing</code></td>
<td>

<p>Logical. When <code>diss = NULL</code>. Are there missing values in the sequences? Default is <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_mdis">mdis</code></td>
<td>
<p>Deprecated. Use <code>diss</code> instead.</p>
</td></tr>
<tr><td><code id="seqrep.grp_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code><a href="TraMineR.html#topic+seqrep">seqrep</a></code> .
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for running <code><a href="TraMineR.html#topic+seqrep">seqrep</a></code> on the different groups defined by the <code>group</code> variable.
</p>
<p>When <code>diss = NULL</code>, <code>seqdist</code> is used to compute the dissimilarities.

</p>


<h3>Value</h3>

<p>If <code>ret="stat"</code>, a list with the quality statistics for the set of representatives of each group.
</p>
<p>If <code>ret="rep"</code>, a list with the set of representatives of each group. Each element of the list is an object of class <code>stslist.rep</code> returned by <code><a href="TraMineR.html#topic+seqrep">seqrep</a></code>.
</p>
<p>If <code>ret="both"</code>, a list with the two previous outcomes.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqrep">seqrep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
biofam &lt;- biofam[1:100,]
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.short &lt;- c("P","L","M","LM","C","LC","LMC","D")
biofam.seq &lt;- seqdef(biofam[,10:25], alphabet=0:7, 
  states=biofam.short, labels=biofam.lab)
dist &lt;- seqdist(biofam.seq, method="HAM")

seqrep.grp(biofam.seq, group=biofam$plingu02, diss=dist, coverage=.2, pradius=.1)
seqrep.grp(biofam.seq, group=biofam$plingu02, diss=dist, ret="rep", coverage=.2, pradius=.1)

## sequences with missing values
data(ex1)
sqex1 &lt;- seqdef(ex1[,1:13])
nrow(ex1)
gp &lt;- rep(1,7)
gp[5:7] &lt;- 2
seqrep.grp(sqex1, group=gp, method="LCS", ret="rep", 
  coverage=.2, pradius=.1, with.missing=TRUE)

</code></pre>

<hr>
<h2 id='seqsamm'>
Sequence Analysis Multistate Model (SAMM) procedure
</h2><span id='topic+seqsamm'></span><span id='topic+seqsammseq'></span><span id='topic+seqsammeha'></span><span id='topic+plot.SAMM'></span>

<h3>Description</h3>

<p>Sequence Analysis Multistate Model (SAMM) procedure aims to simultaneously study the occurrence of transitions  out of (an exit from) a spell in a given state along trajectories and the subsequence (or subtrajectory) immediately following it over a pre-defined period of time. This strategy allows including time-varying covariates in the sequence analysis framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqsamm(seqdata, sublength, covar = NULL)
## S3 method for class 'SAMM'
plot(x, type="d", ...)
seqsammseq(samm, spell)
seqsammeha(samm, spell, typology, persper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsamm_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function. Sequences representing any temporal process can be of different length.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_sublength">sublength</code></td>
<td>
<p>Numeric. The length of the subsequence (or subtrajectory) following a transition to be considered.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_covar">covar</code></td>
<td>
<p>Optional <code>data.frame</code> storing covariates of interest. These covariates are added to the final data set and can be used in subsequent analyses.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_x">x</code></td>
<td>
<p>A SAMM object produced by <code>seqsamm</code></p>
</td></tr>
<tr><td><code id="seqsamm_+3A_samm">samm</code></td>
<td>
<p>A SAMM object produced by <code>seqsamm</code>.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_type">type</code></td>
<td>
<p>the type of the plot <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>. Default &quot;d&quot; for state distribution plots (chronograms).</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_spell">spell</code></td>
<td>
<p>Character. The (ending) spell in a given spell to consider. It should be one of the states of the <code><a href="TraMineR.html#topic+alphabet">alphabet</a></code> of the sequences. A spell is a series of time points in the same state.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_typology">typology</code></td>
<td>
<p>Factor or character. The typology of the trajectories out of the specified ending <code>spell</code> generated by a cluster analyses (see example). It should contain one observation per observed ending spell.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_persper">persper</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the data are returned in person-period format. Otherwise, only one line per observed spell is returned.</p>
</td></tr>
<tr><td><code id="seqsamm_+3A_...">...</code></td>
<td>
<p>additional plot parameters passed to <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sequence Analysis Multistate Model (SAMM) procedure works in three steps. First, the substrings over a given time span <code>sublength</code> following any transition out of (exit from) a spell in a given state of the alphabet are extracted from the trajectories <code>seqdata</code>. This step is achieved using the <code>seqsamm</code> function. Each substring starts with the last time-point of the spell in the state. Second, these substrings are clustered using SA to identify typical substrings of medium-term changes. This is achieved separately for each ending spell (see <code>spell</code> argument). The <code>seqsammseq</code> function can be used to retrieve the sub-trajectories following each ending spell. Third, multistate models are used to estimate the chance (or risk) to end a spell in a given spell by distinguishing the type of trajectory that follows (and identified with cluster analysis). This allows estimating the effect of covariates on the chances to start each type of sub-sequence. The <code>seqsammeha</code> prepare the data to estimate the competing risk models for each ending spell. Then usual competing risks models can be used.
</p>
<p>Generally speaking, the SAMM procedure allows studying the time spent in each state as well as the patterns of medium-term changes after an exit from that state appears along the trajectories. The example section below provides a step by step example of how to use it.
</p>


<h3>Value</h3>

<p>A <code>SAMM</code> object (data.frame), storing the reorganized data in person period form. Column variables are:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Numeric. The ID of the observation as the row number in the original <code>seqdata</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Numeric. The time unit of the current observation (from the beginning of the original sequence).</p>
</td></tr>
<tr><td><code>begin</code></td>
<td>
<p>Numeric. The time of the beginning of the current spell (from the beginning of the original sequence).</p>
</td></tr>
<tr><td><code>spell.time</code></td>
<td>
<p>Numeric. The time elapsed from the beginning of the current spell.</p>
</td></tr>
<tr><td><code>transition</code></td>
<td>
<p>Logical. Whether a transition out of the current spell occurred within this time unit.</p>
</td></tr>
<tr><td><code>s.1 until s.sublength</code></td>
<td>
<p>The state sequence following the current observation starting from 1 (current state) until <code>sublength</code> time units after the current observation.</p>
</td></tr>
<tr><td><code>lastobs</code></td>
<td>
<p>Logical. Whether this is the last observation of the current spell, censored or not. This is useful when one wants only one row per individual, for instance to plot survival curves (see example).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>object of class <code>SAMM</code> as produced by <code>seqsamm</code></p>
</td></tr>
<tr><td><code>Optional covariate list</code></td>
<td>
<p>The covariates provided with the <code>covar</code> argument.</p>
</td></tr>
</table>
<p>The function <code>seqsammseq</code> returns an <code>stslist</code> sequence object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) of the trajectories following an ending spell.
</p>
<p>The function <code>seqsammeha</code> returns a <code>data.frame</code> storing the person period data of a specific ending <code>spell</code> (see <code>spell</code> argument) considering the given <code>typology</code> as competing risks (see <code>typology</code> argument). Several variables are added to the <code>SAMM</code> objects (see above):
</p>
<table>
<tr><td><code>SAMMtypology</code></td>
<td>
<p>Factor. The events ending the specified spell using <code>"None"</code> when no event occurs.</p>
</td></tr>
<tr><td><code>SAMM...</code></td>
<td>
<p>Logical. A logical vector specifying whether the current observation ends the spell with the following <code>...</code> type of trajectory.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>Studer, M., Struffolino, E., &amp; Fasang, A. E. (2018). Estimating the Relationship between Time-varying Covariates and Trajectories: The Sequence Analysis Multistate Model Procedure. <em>Sociological Methodology</em>, 48(1), 103–135. <a href="https://doi.org/10.1177/0081175017747122">doi:10.1177/0081175017747122</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqcta">seqcta</a></code>, <code><a href="#topic+seqsha">seqsha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad.seq &lt;- seqdef(mvad, 17:86)

## For sake of simplicity we recode all "education" states to only one common state.
mvad.seq  &lt;- seqrecode(mvad.seq, list("education"=c("FE", "HE", "school", "training")))
## We now have three states
seqdplot(mvad.seq)

###########################################################################
##  STEP I: Subsequence extraction
###########################################################################

## We start by extracting all subsequence of length 6
## We also add covariates from the mvad data frame
mvad.samm &lt;- seqsamm(mvad.seq, 6, covar=mvad[, c("Grammar", "funemp", "gcse5eq")])
## Plotting the results to visualize the transitions out of each states.
plot(mvad.samm)
## Descriptive information on the seqsamm object
summary(mvad.samm)


###########################################################################
### STEP II: Typology of trajectory out of joblessness
###########################################################################
## We retrieve the subsequences following a transition out of a joblessness spell
jlseq &lt;- seqsammseq(mvad.samm, "joblessness")


## Now we create a typology of these subsequences.

## Compute the clustering using LCS
jldist &lt;- seqdist(jlseq, method="LCS")
## For sake of simplicity, use only 2 groups
library(cluster)
jlclust &lt;- pam(jldist, diss=TRUE, k=2, cluster.only=TRUE)
## Specify the names of the types in the 2-cluster typology (here joblessness1 or joblessness2).
jltype &lt;- paste0("joblessness", jlclust)


###########################################################################
### STEP III: Competing risks model of trajectories out of joblessness
###########################################################################

## Get the data to estimate competing risks models of the kind of trajectory
## out of jobjlessness
## We specify the SAMM object, the ending spell (joblessness) and our typology.
jleha &lt;- seqsammeha(mvad.samm, "joblessness", jltype)

## Not run: 
## Now jleha stores the data in person period format for competing risks
## Discrete time model using multinomial regression
## SAMMtypology and spell.time are variables created and stored in the jleha dataset
library(nnet)
multinom(SAMMtypology~spell.time+Grammar+funemp+gcse5eq, data=jleha)

## We can also have only one line per ending spell
## Plot the results
library(survival)
jleha &lt;- seqsammeha(mvad.samm, "joblessness", jltype, persper=FALSE)
plot(survfit(Surv(spell.time, SAMMjoblessness1)~1, data=jleha))
## Cox model
summary(coxph(Surv(spell.time, SAMMjoblessness1)~gcse5eq+Grammar+funemp, data=jleha))
## Most of the time methods for recurrent events should be used.
## See for instance the coxme library to do so.

library(coxme)
summary(coxme(Surv(spell.time, SAMMjoblessness1)~gcse5eq+Grammar+funemp+(1|id), data=jleha))

## End(Not run)

###########################################################################
### Now repeat steps II and III for employment and then education
### (Not shown here)
###########################################################################

</code></pre>

<hr>
<h2 id='seqsha'>
Sequence History Analysis (SHA)
</h2><span id='topic+seqsha'></span>

<h3>Description</h3>

<p>Sequence History Analysis (SHA) aims to study how a previous trajectory is linked to an upcoming event. This procedure relies on sequence analysis typologies to identify the type of previous trajectory as a time-varying covariate and uses discrete-time survival models to estimate its relationship with the upcoming event under consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqsha(seqdata, time, event, include.present = FALSE, align.end = FALSE, covar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsha_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function. The whole trajectory followed by individuals.</p>
</td></tr>
<tr><td><code id="seqsha_+3A_time">time</code></td>
<td>
<p>Numeric. The time of occurrence of the event or the observation time for censored observations.</p>
</td></tr>
<tr><td><code id="seqsha_+3A_event">event</code></td>
<td>
<p>Logical. Whether the event occured or not (censored observations).</p>
</td></tr>
<tr><td><code id="seqsha_+3A_include.present">include.present</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the state occurring at the current time is not included in the previous trajectory.</p>
</td></tr>
<tr><td><code id="seqsha_+3A_align.end">align.end</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the previous trajectories are aligned at the beginning of the trajectory. If <code>TRUE</code>, the previous trajectories are aligned on the end.</p>
</td></tr>
<tr><td><code id="seqsha_+3A_covar">covar</code></td>
<td>
<p>Optional <code>data.frame</code> storing covariates of interest. These covariates are added to the final data set. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>SHA works in four steps. First, it makes use of a discrete-time representation of the data also known as person-period file. In this format, one observation is generated for each individual  at each time point. Second, the previous trajectory at each time point is coded as the sequence of states from the beginning (t=1 in our example) until the previous position t-1. Third, a typology of the previous trajectory is created using standard sequence analysis procedure. This results in a new time-varying covariate coding the type of previous trajectory at each time point. Fourth, the relationship between the previous trajectory and the subsequent event is estimated using a discrete-time model, which includes the past trajectory type as a covariate. In this step, other covariates can be included as well.
</p>
<p>The <code>seqsha</code> function can be used to automatically reorganize the data according to the first two steps described above. Then, a standard procedure can be applied on the resulting data set. The example section below provides an example of the whole procedure.
</p>


<h3>Value</h3>

<p>A data frame with the following variables:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Numeric. The ID of the observation as the row number in the original <code>seqdata</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Numeric. The time unit from the beginning of the original sequence until the occurence of the event.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Logical. Whether the event occured within this time unit.</p>
</td></tr>
<tr><td><code>T1 until T...</code></td>
<td>
<p>The state sequence coding the previous trajectory. Columns names depends on <code>seqdata</code> and <code>aligne.end</code>.</p>
</td></tr>
<tr><td><code>Optional covariate list</code></td>
<td>
<p>The covariates provided with the <code>covar</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>Rossignon F., Studer M., Gauthier JA., Le Goff JM. (2018). Sequence History Analysis (SHA): Estimating the Effect of Past Trajectories on an Upcoming Event. In: Ritschard G., Studer M. (eds) <em>Sequence Analysis and Related Approaches</em>. Life Course Research and Social Policies, vol 10. Springer: Cham. <a href="https://doi.org/10.1007/978-3-319-95420-2_6">doi:10.1007/978-3-319-95420-2_6</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqcta">seqcta</a></code>, <code><a href="#topic+seqsamm">seqsamm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create seq object for biofam data.
data(biofam)
## Reduce the biofam data to accelerate example
biofam &lt;- biofam[100:300,]
bf.shortlab &lt;- c("P","L","M","LM","C","LC", "LMC", "D")
bf.seq &lt;- seqdef(biofam[,10:25], states=bf.shortlab)

## We focus on the occurrence the start of a LMC spell
## The code below aims to find when this event occurred (and whether it occurred).
bf.seq2 &lt;- seqrecode(bf.seq, recodes=list(LMC="LMC"), otherwise = "Other")
dss &lt;- seqdss(bf.seq2)
## Time until LMC spell
time &lt;- ifelse(dss[, 1]=="LMC", 1, seqdur(bf.seq2)[, 1])
## Whether the event (start of LMC spell) started or not
event &lt;- dss[, 1]=="LMC"|dss[, 2]=="LMC"

## The seqsha function will convert the data to person period.
## At each time point, the previous trajectory until that point is stored
sha &lt;- seqsha(bf.seq, time, event, covar=biofam[, c("sex", "birthyr")])
summary(sha)

## Not run: 
## Now we build a sequence object for the previous trajectory
previousTraj &lt;- seqdef(sha[, 4:19])
seqdplot(previousTraj)
## Now we cluster the previous trajectories
##Compute distances using only the dss
## Ensure high sensitivity to ordering of the states
diss &lt;- seqdist(seqdss(previousTraj), method="LCS")
##Clustering with pam
library(cluster)
pclust &lt;- pam(diss, diss=TRUE, k=4, cluster.only=TRUE)
#Naming the clusters
sha$pclustname &lt;- factor(paste("Type", pclust))
##Plotting the clusters to make senses of them.
seqdplot(previousTraj, sha$pclustname)


## Now we use a discrete time model include the type of previous trajectory as covariate.
summary(glm(event~time+pclustname+sex, data=sha, family=binomial))

## End(Not run)

</code></pre>

<hr>
<h2 id='seqsplot'>Plot survival curves of the states in sequences</h2><span id='topic+seqsplot'></span>

<h3>Description</h3>

<p>High level plot function for state sequence objects that produces survival curves of states in sequences. Usage is similar to the generic <code>seqplot</code> function of TraMineR, with a special handling of the <code>group</code> argument when <code>per.state=TRUE</code> is included in the <code>...</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqsplot(seqdata, group = NULL, main = "auto",
  cpal = NULL, missing.color = NULL,
  ylab = NULL, yaxis = "all",
  xaxis = "all", xtlab = NULL,
  cex.axis = 1, with.legend = "auto", ltext = NULL, cex.legend = 1,
  use.layout = (!is.null(group) | with.legend != FALSE), legend.prop = NA,
  rows = NA, cols = NA, which.states = NULL,
  title, cex.plot, withlegend, axes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsplot_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_group">group</code></td>
<td>
<p>Grouping variable of length equal to the number of sequences. When <code>per.state = FALSE</code> (default), a distinct plot is generated for each level of <code>group</code>. When <code>per.state = TRUE</code>, the curves for each group level are drawn in a same plot for each distinct value of <code>alphabet(seqdata)</code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_main">main</code></td>
<td>
<p>Character string. Title for the graphic. Default is <code>"auto"</code>, i.e., group levels or, when <code>per.state=TRUE</code>, the state labels. If a single string, the string is pasted with the group or state label. Set as <code>NULL</code> to suppress titles. Can also be a vector.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_cpal">cpal</code></td>
<td>
<p>Vector. Color palette used for the states or the groups when <code>per.state=TRUE</code> is given along the <code>...</code> list. Default is <code>NULL</code>, in which case the <code>cpal</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) or the default colors assigned to groups when <code>type="s"</code> and <code>per.state=TRUE</code>. If user specified, a vector of colors of length and order corresponding to <code>alphabet(seqdata)</code> or, if for groups, the number of levels of the group variable.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_missing.color">missing.color</code></td>
<td>
<p>Color for representing missing values inside the sequences. By default, this color is taken from the <code>missing.color</code> attribute of <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_ylab">ylab</code></td>
<td>
<p>Character string or vector of strings. Optional label of the y-axis. If a vector, y-axis label of each group (or state) level. If set as <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"left"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default), the y-axis is displayed on all plots. In case of multiple plots (when <code>per.state=TRUE</code> or <code>group</code> is used), if set as <code>"left"</code>, the y-axis is only displayed on plots of the left panel. If <code>FALSE</code> no y-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"bottom"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value) the x-axis is drawn on each plot in the graphic. In case of multiple plots (when <code>per.state=TRUE</code> or <code>group</code> is used), if set as <code>"bottom"</code>, the x-axis is drawn only under the plots of the bottom panel. If <code>FALSE</code>, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_xtlab">xtlab</code></td>
<td>
<p>Vector of length equal to the number of columns of <code>seqdata</code>. Optional labels for the x-axis tick labels. If unspecified, the column names of the <code>seqdata</code> sequence object are used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Real. Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Character string or logical. Defines if and where the legend of the state colors is plotted. The default value <code>"auto"</code> sets the position of the legend automatically. Other possible value is <code>"right"</code>. Obsolete value <code>TRUE</code> is equivalent to <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_ltext">ltext</code></td>
<td>
<p>Vector of character strings of length and order corresponding to  <code>alphabet(seqdata)</code> or, when for groups, to the levels of the group variable. Optional description for the color legend. If unspecified, the <code>label</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) or, when for groups, the levels of the group variable.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Real. Legend magnification. See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_use.layout">use.layout</code></td>
<td>
<p>Logical. Should <code><a href="graphics.html#topic+layout">layout</a></code> be used to arrange plots when using the group option or plotting a legend? When layout is activated, the standard '<code><a href="graphics.html#topic+par">par</a>(mfrow=....)</code>' for arranging plots does not work. With <code>with.legend=FALSE</code> and <code>group=NULL</code>, layout is automatically deactivated and '<code>par(mfrow=....)</code>' can be used.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Real in range [0,1]. Proportion of the graphic area devoted to the legend plot when <code>use.layout=TRUE</code> and <code>with.legend=TRUE</code>. Default value is set according to the place (bottom or right of the graphic area) where the legend is plotted.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_rows">rows</code>, <code id="seqsplot_+3A_cols">cols</code></td>
<td>
<p>Integers. Number of rows and columns of the plot panel when <code>use.layout=TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_which.states">which.states</code></td>
<td>
<p>Vector of short state names. List of the states for which survival curves should be plotted.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_title">title</code></td>
<td>
<p>Deprecated. Use <code>main</code> instead.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_axes">axes</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="seqsplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function called to produce the appropriate statistics and the associated plot method (see details), or other graphical parameters. For example <code>per.spell</code> argument will typically be used for survival plots. Can also include arguments of <code><a href="graphics.html#topic+legend">legend</a></code> such as <code>bty="n"</code> to suppress the box surrounding the legend.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a specific version of <code>seqplot</code> for type=&quot;s&quot;. It implements a dedicated handling of the group variable passed as <code>group</code> argument when <code>per.sate=TRUE</code> is included in the <code>...</code> list.
</p>
<p>Invalid or non observed states are removed the list given as <code>which.states</code> argument. When <code>which.states = NULL</code>, <code>which.states</code> will be defined as the list of states present in the data.
</p>
<p>When <code>per.sate=TRUE</code>, a distinct plot is generated for each state in the <code>which.states</code> list and, when a grouping variable is provided, the survival curves of all groups are plotted in each plot.
</p>
<p>When <code>per.state=FALSE</code>, a distinct plot is generated for each group and the survival curves of all states listed as <code>which.states</code> are plotted in each plot.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard (based on TraMineR seqplot function)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.surv">plot.stslist.surv</a></code>, <code><a href="#topic+seqsurv">seqsurv</a></code>, <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>, </p>


<h3>Examples</h3>

<pre><code class='language-R'>## ======================================================
## Creating state sequence objects from example data sets
## ======================================================

data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
                "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.short &lt;- c("P","L","M","LM","C","LC","LMC","D")

sple &lt;- 1:200  ## only the first 200 sequences
seqstatl(biofam[sple,10:25]) ## state 4 not present
biofam &lt;- biofam[sple,]

biofam.seq &lt;- seqdef(biofam[,10:25], alphabet=0:7, states=biofam.short, labels=biofam.lab)

## defining two birth cohorts
biofam$wwii &lt;- factor(biofam$birthyr &gt; 1945,
  labels=c("Born Before End of Word War II","Born After Word War II"))

## ==============================
## Plots of state survival curves
## ==============================

seqsplot(biofam.seq) ## all states, no group
seqsplot(biofam.seq, group=biofam$wwii, lwd=2) ## all states for each group
seqsplot(biofam.seq, group=biofam$wwii, per.state=TRUE, lwd=2) ## groups for each state

## For a selection of states only

seqsplot(biofam.seq, group=biofam$wwii, which.states= c('LM'), lwd=2)
## changing default color
seqsplot(biofam.seq, group=biofam$wwii, which.states= c('LM'),
  cpal="orange", lwd=2)
seqsplot(biofam.seq, group=biofam$wwii, which.states= c('LM','LMC'),
  cpal=c("orange","brown"), lwd=2)
seqsplot(biofam.seq, group=biofam$wwii, which.states= c('LM','LMC'), per.state=TRUE)
</code></pre>

<hr>
<h2 id='seqstart'>
Aligning sequence data on a new start time.
</h2><span id='topic+seqstart'></span>

<h3>Description</h3>

<p>Changing the position alignment of a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqstart(seqdata, data.start, new.start, tmin = NULL, tmax = NULL, missing = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqstart_+3A_seqdata">seqdata</code></td>
<td>
<p>a data frame or matrix containing sequence data.</p>
</td></tr>
<tr><td><code id="seqstart_+3A_data.start">data.start</code></td>
<td>
<p>Integer. The actual starting date of the sequences. In case of sequence-dependent start dates, should be a vector of length equal to the number of rows of seqdata.</p>
</td></tr>
<tr><td><code id="seqstart_+3A_new.start">new.start</code></td>
<td>
<p>Integer. The new starting date. In case of sequence-dependent start dates, should be a vector of length equal to the number of rows of seqdata.</p>
</td></tr>
<tr><td><code id="seqstart_+3A_tmin">tmin</code></td>
<td>
<p>Integer. Start position on new position axis. If <code>NULL</code>, it is guessed from the data.</p>
</td></tr>
<tr><td><code id="seqstart_+3A_tmax">tmax</code></td>
<td>
<p>Integer. End position on new position axis. If <code>NULL</code>, it is guessed from the data.</p>
</td></tr>
<tr><td><code id="seqstart_+3A_missing">missing</code></td>
<td>
<p>Character. Code used to fill missing data in the new time axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.</p>


<h3>Note</h3>

<p>Warning: This function needs further testing.</p>


<h3>Author(s)</h3>

<p>Matthias Studer</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#An example data set
paneldata &lt;- matrix(c("A" ,"A" , "B" , "B" , "B",
"A" , "A" , "B" , "B" , "B",
"A" , "A",  "B" , "B" , "B" ,
"A"  ,"A" , "A" , "B"  ,"B" ,
"A"  ,"A" , "A" , "A" , "B"), byrow=TRUE, ncol=5)
colnames(paneldata) &lt;- 2000:2004

print(paneldata)

## Assuming data are aligned on calendar years, starting in 2000
## Change from calendar date to age alignment
startyear &lt;- 2000
birthyear &lt;- 1995:1999
agedata &lt;- seqstart(paneldata, data.start=startyear, new.start=birthyear)
colnames(agedata) &lt;- 1:ncol(agedata)
print(agedata)

## Retaining only ages between 3 and 7 (4th and 8th year after birthyear).
seqstart(paneldata, data.start=startyear, new.start=birthyear, tmin=4, tmax=8, missing="*")

## Changing back from age to calendar time alignment
ageatstart &lt;- startyear - birthyear
seqstart(agedata, data.start=1,  new.start=ageatstart)
## Same but dropping right columns filled with NA's
seqstart(agedata, data.start=1,  new.start=ageatstart, tmax=5)

</code></pre>

<hr>
<h2 id='seqsurv'>Generate a survfit object for state survival times.</h2><span id='topic+seqsurv'></span>

<h3>Description</h3>

<p>The function considers the spells in the different states in sequences and fits survival curves for each state. Alternatively, for a selected state, it fits the survival curves for each level of a stratifying group variable.
</p>
<p>Survival curves are fitted with the <code><a href="survival.html#topic+survfit">survfit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqsurv(seqdata, groups = NULL, per.state = FALSE, state = NULL,
    with.missing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsurv_+3A_seqdata">seqdata</code></td>
<td>
<p>A sequence <code>stslist</code> object as defined by the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqsurv_+3A_groups">groups</code></td>
<td>
<p>A stratifying group variable of length equal to the number of sequences.</p>
</td></tr>
<tr><td><code id="seqsurv_+3A_per.state">per.state</code></td>
<td>
<p>Logical. Should the survival probabilites be computed for the state specified as <code>state</code> argument? If set as <code>TRUE</code>, the <code>state</code> argument must also be specified.</p>
</td></tr>
<tr><td><code id="seqsurv_+3A_state">state</code></td>
<td>
<p>Single state value or a vector. The short name of the state for which to compute survival probabilities. If a vector of state names, survival probabilities are computed for the subset defined by those states. If <code>NULL</code>, survival probabilities are computed for all cases.</p>
</td></tr>
<tr><td><code id="seqsurv_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should the missing state be accounted for? (Not yet implemented!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function considers the spells in the different states of a state sequence object (of class <code>stslist</code>).
</p>
<p>When <code>per.state = FALSE</code>, it fits survival curves for each state in the alphabet.
Currently, <code>per.state = FALSE</code> cannot be used with a non-<code>NULL</code> <code>groups</code> argument.
However, <code><a href="#topic+seqsplot">seqsplot</a></code> handles this case.

</p>
<p>When <code>per.state = TRUE</code>, the survival curve is fitted only for the state provided as <code>state</code> argument. This is done for each level of the <code>groups</code> variable.
</p>
<p>Survival curves are fitted with the <code><a href="survival.html#topic+survfit">survfit</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <em>stslist.surv</em>. There is a <code>plot</code> method for such
objects.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Gilbert Ritschard, Pierre-Alexandre Fonta</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.surv">plot.stslist.surv</a></code> for basic plots of <em>stslist.surv</em> objects
and <code><a href="#topic+seqsplot">seqsplot</a></code> for more elaborated plots.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
                "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.short &lt;- c("P","L","M","LM","C","LC","LMC","D")

sple &lt;- 500:700  ## want a sample with all elements of the alphabet
##seqstatl(biofam[sple,10:25])
biofam &lt;- biofam[sple,]

## creating the state sequence object
biofam.seq &lt;- seqdef(biofam[,10:25], alphabet=0:7, states=biofam.short, labels=biofam.lab)

## Spell survival curves
(biofam.surv &lt;- seqsurv(biofam.seq))

## Cohort distinguishing between those born before or after World War II
biofam$wwii &lt;- biofam$birthyr &lt;= 1945

## Separate survival curves in a given state (here LMC "Left+Marr+Child") according to wwii
(biofam.surv &lt;- seqsurv(biofam.seq, groups=biofam$wwii, per.state=TRUE, state="LMC"))
plot(biofam.surv)
</code></pre>

<hr>
<h2 id='seqtabstocc'>Frequencies of state co-occurrence patterns</h2><span id='topic+seqtabstocc'></span>

<h3>Description</h3>

<p>Computes the frequencies of co-occurring state patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqtabstocc(seqdata, with.missing=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtabstocc_+3A_seqdata">seqdata</code></td>
<td>
<p> A state sequence (<code>stslist</code>) object as returned by <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqtabstocc_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should the missing state be considered as a regular state?</p>
</td></tr>
<tr><td><code id="seqtabstocc_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed to <code><a href="TraMineR.html#topic+seqtab">seqtab</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts the list of states co-occurring in each sequence. For each sequence, the co-occurring states are extracted as the sequence of the alphabetically sorted distinct states. The frequencies of the extracted sets of states is then obtained by means of the  TraMineR <code><a href="TraMineR.html#topic+seqtab">seqtab</a></code> function.
</p>
<p>Returned patterns with a single state correspond to sequences that contain only that state.
</p>


<h3>Value</h3>

<p>A <code>stslist.freq</code> object with co-occurrence patterns sorted in descending frequency order.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqtab">seqtab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from the first 500 actcal data.
data(actcal)
actcal.seq &lt;- seqdef(actcal[1:500,13:24])

## 10 most frequent state patterns in the data
seqtabstocc(actcal.seq)

## All state patterns
seqtabstocc(actcal.seq, idxs=0)

## Example with missing states
data(ex1)
ex1 &lt;- ex1[,1:13] ## dropping last weight column
## adding 3 sequences with no gap and left missing state
ex1 &lt;- rbind(ex1,c(rep("A",4),rep(NA,9)))
ex1 &lt;- rbind(ex1,c(rep("A",4),rep(NA,9)))
ex1 &lt;- rbind(ex1,rep("A",13))
s.ex1 &lt;- seqdef(ex1)
seqtabstocc(s.ex1, with.missing=TRUE)

</code></pre>

<hr>
<h2 id='sortv'>Sort sequences by states at the successive positions</h2><span id='topic+sortv'></span><span id='topic+sorti'></span>

<h3>Description</h3>

<p>Returns a sorting vector to sort state sequences in a TraMineR sequence object (<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) by the states at the successive positions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sorti(seqdata, start = "end", sort.index=TRUE)

sortv(seqdata, start = "end")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortv_+3A_seqdata">seqdata</code></td>
<td>
<p>A state sequence object as returned by <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="sortv_+3A_start">start</code></td>
<td>
<p>Where to start the sort. One of <code>"beg"</code> (beginning) or <code>"end"</code>.</p>
</td></tr>
<tr><td><code id="sortv_+3A_sort.index">sort.index</code></td>
<td>
<p>Should the function return sort indexes? If <code>FALSE</code>, sort values are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>start = "end"</code> (default), the primary sort key is the final state, then the previous one and so on. With <code>start = "beg"</code>, the primary sort key is the state at the first position, then at the next one and so on.
</p>
<p>With <code>sort.index = FALSE</code>, the function returns a vector of values whose order will determine the wanted order. This should be used as <code>sortv</code> argument of the <code><a href="TraMineR.html#topic+seqiplot">seqiplot</a></code> function. With <code>sort.index = TRUE</code>, the function returns a vector of indexes to be used for indexing.
</p>
<p>The <code>sortv</code> form is an alias for <code>sorti(..., sort.index = FALSE)</code>.
</p>


<h3>Value</h3>

<p>If <code>sort.index = FALSE</code>, the vector of sorting values.<br />
Otherwise the vector of sorting indexes.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p>Details about <code>type = "i"</code> or <code>type = "I"</code> in
<code><a href="TraMineR.html#topic+seqplot">seqplot</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal[1:100,13:24])
par(mfrow=c(1,2))
seqIplot(actcal.seq, sortv=sortv(actcal.seq), with.legend = FALSE)
seqIplot(actcal.seq, sortv=sortv(actcal.seq, start="beg"), with.legend = FALSE)
actcal.seq[sorti(actcal.seq)[90:100],]

data(mvad)
mvad.seq &lt;- seqdef(mvad[1:100,17:86])
par(mfrow=c(1,2))
seqIplot(mvad.seq, sortv=sortv(mvad.seq, start="end"), with.legend = FALSE)
seqIplot(mvad.seq, sortv=sortv(mvad.seq, start="beg"), with.legend = FALSE)
print( mvad.seq[sorti(mvad.seq,start="beg")[90:100],], format="SPS")

</code></pre>

<hr>
<h2 id='toPersonPeriod'>Converting into person-period format.</h2><span id='topic+toPersonPeriod'></span>

<h3>Description</h3>

<p>Converts the STS sequences of a state sequence object into person-period format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>toPersonPeriod(seqdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toPersonPeriod_+3A_seqdata">seqdata</code></td>
<td>
<p>A state sequence object as returned by <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: <code>id</code>, <code>state</code> and <code>timestamp</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer</p>


<h3>See Also</h3>

<p><code><a href="TraMineR.html#topic+seqformat">seqformat</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad.labels &lt;- c("employment", "further education", "higher education",
    "joblessness", "school", "training")
mvad.scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad.seq &lt;- seqdef(mvad, 15:86, states = mvad.scodes, labels = mvad.labels)

mvad2 &lt;- toPersonPeriod(mvad.seq[1:20,])
</code></pre>

<hr>
<h2 id='TraMineRextras-package'> TraMineR Extension </h2><span id='topic+TraMineRextras-package'></span><span id='topic+TraMineRextras'></span>

<h3>Description</h3>

<p>(Version: 0.7.7) Collection of ancillary functions and utilities to be used in conjunction with the 'TraMineR' package for sequence data exploration. Includes, among others, specific functions such as state survival plots, position-wise group-typical states, dynamic sequence indicators, and dissimilarities between event sequences. Also includes contributions by non-members of the TraMineR team such as the relative frequency plot and methods for polyadic data.
</p>


<h3>Author(s)</h3>

<p> Gilbert Ritschard, Matthias Studer, Reto Buergin
</p>

<hr>
<h2 id='TSE_to_STS'>
Converting TSE data into STS (state sequences) format.
</h2><span id='topic+TSE_to_STS'></span>

<h3>Description</h3>

<p>Conversion from TSE (time stamped event sequences) vertical format into STS (state sequences) data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSE_to_STS(seqdata, id = 1, timestamp = 2, event = 3, stm = NULL, tmin = 1,
    tmax = NULL, firstState = "None")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSE_to_STS_+3A_seqdata">seqdata</code></td>
<td>
<p>a data frame or matrix with event sequence data in TSE format.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_id">id</code></td>
<td>
<p>Name or index of the column containing the id's of the sequences.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_timestamp">timestamp</code></td>
<td>
<p>Name or index of the column containing the timestamps of the events.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_event">event</code></td>
<td>
<p>Name or index of the column containing the events.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_stm">stm</code></td>
<td>
<p>An event to state transition matrix (See <code><a href="#topic+seqe2stm">seqe2stm</a></code>).</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_tmin">tmin</code></td>
<td>
<p>Integer. Starting time of the state sequence.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_tmax">tmax</code></td>
<td>
<p>Integer. Ending time of the state sequence.</p>
</td></tr>
<tr><td><code id="TSE_to_STS_+3A_firststate">firstState</code></td>
<td>
<p>Character. The name of the state before any events has occurred.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert TSE (time stamped event sequences) data into STS (state sequences) format. By default, the states are defined has the combination of events that already occurred.
Different schemes may be specified using function <code><a href="#topic+seqe2stm">seqe2stm</a></code> and the <code>stm</code> argument.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sequences in STS format.
</p>


<h3>Note</h3>

<p>This function is a pre-release and further testing is still needed, please report any problems.</p>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>Ritschard, G., Gabadinho, A., Studer, M. &amp; Müller, N.S. (2009), &quot;Converting between various sequence representations&quot;,
In Ras, Z. &amp; Dardzinska, A. (eds) <em>Advances in Data Management</em>. Series: <em>Studies in Computational Intelligence</em>. Volume 223, pp. 155-175. Berlin: Springer.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+seqe2stm">seqe2stm</a></code>, <code><a href="TraMineR.html#topic+seqformat">seqformat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
events &lt;- c("PartTime", "NoActivity", "FullTime", "LowPartTime")
## Dropping all previous events.
stm &lt;- seqe2stm(events, dropList=list(PartTime=events[-1],
   NoActivity=events[-2], FullTime=events[-3], LowPartTime=events[-4]))
mysts &lt;- TSE_to_STS(actcal.tse[1:100,], id=1, timestamp=2, event=3,
   stm=stm, tmin=1, tmax=12, firstState="None")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
