<!DOCTYPE html><html><head><title>Help for package dispRity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dispRity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dispRity-package'><p>Measuring Disparity in R</p></a></li>
<li><a href='#add.tree'><p>Add, remove or get trees (or subtrees)</p></a></li>
<li><a href='#adonis.dispRity'><p>adonis dispRity (from <code>vegan::adonis2</code>)</p></a></li>
<li><a href='#apply.NA'><p>Apply inapplicable characters to a matrix.</p></a></li>
<li><a href='#as.covar'><p>as.covar</p></a></li>
<li><a href='#BeckLee'><p>Beck and Lee 2014 datasets</p></a></li>
<li><a href='#BeckLee_disparity'><p>BeckLee_disparity</p></a></li>
<li><a href='#bhatt.coeff'><p>Bhattacharyya Coefficient</p></a></li>
<li><a href='#boot.matrix'><p>Bootstraps and rarefies data.</p></a></li>
<li><a href='#char.diff'><p>Character differences</p></a></li>
<li><a href='#charadriiformes'><p>Charadriiformes</p></a></li>
<li><a href='#check.morpho'><p>Check a morphological matrix consistency levels.</p></a></li>
<li><a href='#chrono.subsets'><p>Separating data in chronological subsets.</p></a></li>
<li><a href='#Claddis.ordination'><p>Imports data from Claddis</p></a></li>
<li><a href='#clean.data'><p>Cleaning phylogenetic data</p></a></li>
<li><a href='#covar.plot'><p>covar.plot</p></a></li>
<li><a href='#covar.utilities'><p>Utilities for a dispRity object with covariance matrices</p></a></li>
<li><a href='#crown.stem'><p>Separates stem and crown species</p></a></li>
<li><a href='#custom.subsets'><p>Separating data into custom subsets.</p></a></li>
<li><a href='#demo_data'><p>Demo datasets</p></a></li>
<li><a href='#disparity'><p>disparity</p></a></li>
<li><a href='#dispRity'><p>Calculates disparity from a matrix.</p></a></li>
<li><a href='#dispRity.covar.projections'><p>Covar projection analyses wrapper</p></a></li>
<li><a href='#dispRity.fast'><p>Fast dispRity</p></a></li>
<li><a href='#dispRity.metric'><p>Disparity metrics</p></a></li>
<li><a href='#dispRity.per.group'><p>Disparity in different groups.</p></a></li>
<li><a href='#dispRity.through.time'><p>Disparity through time.</p></a></li>
<li><a href='#distance.randtest'><p>Randtest distance</p></a></li>
<li><a href='#dtt.dispRity'><p>dtt dispRity (from <code>geiger::dtt</code>)</p></a></li>
<li><a href='#extinction.subsets'><p>Getting the time subsets before and after an extinction event</p></a></li>
<li><a href='#geomorph.ordination'><p>Imports data from geomorph</p></a></li>
<li><a href='#get.bin.ages'><p>Get time bins ages</p></a></li>
<li><a href='#get.contrast.matrix'><p>Generates a contrast matrix.</p></a></li>
<li><a href='#get.matrix'><p>Extract elements from a <code>dispRity</code> object.</p></a></li>
<li><a href='#get.subsets'><p>Extracts or modify subsets from a <code>dispRity</code> object.</p></a></li>
<li><a href='#make.dispRity'><p>Make and fill <code>dispRity</code>.</p></a></li>
<li><a href='#make.metric'><p>Creating disparity metrics</p></a></li>
<li><a href='#match.tip.edge'><p>Match tips or nodes edge vector</p></a></li>
<li><a href='#MCMCglmm.subsets'><p>MCMCglmm.subsets</p></a></li>
<li><a href='#MCMCglmm.utilities'><p>MCMCglmm object utility functions</p></a></li>
<li><a href='#model.test'><p>Model Test</p></a></li>
<li><a href='#model.test.sim'><p>Simulate Model Test</p></a></li>
<li><a href='#model.test.wrapper'><p>Model test wrapper</p></a></li>
<li><a href='#multi.ace'><p>Ancestral states estimations with multiple trees</p></a></li>
<li><a href='#null.test'><p>Testing a null hypothesis on multidimensional data.</p></a></li>
<li><a href='#pair.plot'><p>Plots pairwise comparisons</p></a></li>
<li><a href='#pgls.dispRity'><p>phylolm dispRity (from <code>phylolm::phylolm</code>)</p></a></li>
<li><a href='#plot.char.diff'><p>Plots character differences</p></a></li>
<li><a href='#plot.dispRity'><p>dispRity object plotting</p></a></li>
<li><a href='#print.dispRity'><p>Prints a <code>dispRity</code> object.</p></a></li>
<li><a href='#random.circle'><p>Random circle</p></a></li>
<li><a href='#randtest.dispRity'><p>Random (permutation) test</p></a></li>
<li><a href='#reduce.matrix'><p>Reduce a matrix</p></a></li>
<li><a href='#reduce.space'><p>Reduce space</p></a></li>
<li><a href='#remove.zero.brlen'><p>Remove zero branch length</p></a></li>
<li><a href='#scale.dispRity'><p>Rescaling and centering disparity results.</p></a></li>
<li><a href='#select.axes'><p>Selects ordination axes</p></a></li>
<li><a href='#sim.morpho'><p>Simulates morphological data.</p></a></li>
<li><a href='#slice.tree'><p>Time slicing a tree.</p></a></li>
<li><a href='#slide.nodes'><p>Stretching a tree</p></a></li>
<li><a href='#sort.dispRity'><p>Sorting or ordering a <code>dispRity</code> object.</p></a></li>
<li><a href='#space.maker'><p>Creating multidimensional spaces</p></a></li>
<li><a href='#summary.dispRity'><p>dispRity object summary</p></a></li>
<li><a href='#test.dispRity'><p>Testing disparity hypotheses</p></a></li>
<li><a href='#test.metric'><p>Test disparity metric</p></a></li>
<li><a href='#tree.age'><p>Extracting the age of nodes and tips in a tree.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Measuring Disparity</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Guillerme &lt;guillert@tcd.ie&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Description:</td>
<td>A modular package for measuring disparity (multidimensional space occupancy). Disparity can be calculated from any matrix defining a multidimensional space. The package provides a set of implemented metrics to measure properties of the space and allows users to provide and test their own metrics. The package also provides functions for looking at disparity in a serial way (e.g. disparity through time) or per groups as well as visualising the results. Finally, this package provides several statistical tests for disparity analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), ape, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, castor, Claddis, ellipse, geometry, GET, graphics,
grDevices, MASS, methods, mnormt, parallel, phangorn, phyclust,
phylolm, utils, vegan, scales, zoo,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MCMCglmm, geoscale, testthat, knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TGuillerme/dispRity">https://github.com/TGuillerme/dispRity</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 14:58:05 UTC; tguillerme</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Guillerme <a href="https://orcid.org/0000-0003-4325-1275"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Mark Puttick [aut, cph],
  Jack Hadfield [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 15:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='dispRity-package'>Measuring Disparity in R</h2><span id='topic+dispRity-package'></span>

<h3>Description</h3>

<p>A modular package for measuring disparity (multidimensional space occupancy). Disparity can be calculated from any matrix defining a multidimensional space. The package provides a set of implemented metrics to measure properties of the space and allows users to provide and test their own metrics (Guillerme (2018) &lt;doi:10.1111/2041-210X.13022&gt;). The package also provides functions for looking at disparity in a serial way (e.g. disparity through time - Guillerme and Cooper (2018) &lt;doi:10.1111/pala.12364&gt;) or per groups as well as visualising the results. Finally, this package provides several statistical tests for disparity analysis.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme &lt;guillert@tcd.ie&gt;
</p>

<hr>
<h2 id='add.tree'>Add, remove or get trees (or subtrees)</h2><span id='topic+add.tree'></span><span id='topic+remove.tree'></span><span id='topic+get.tree'></span>

<h3>Description</h3>

<p>Adding, extracting or removing the tree component from a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.tree(data, tree, replace = FALSE)

get.tree(data, subsets = FALSE, to.root = FALSE)

remove.tree(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.tree_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> or <code>mutiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_replace">replace</code></td>
<td>
<p>Logical, whether to replace any existing tree (<code>TRUE</code>) or add to it (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="add.tree_+3A_subsets">subsets</code></td>
<td>
<p>Either a logical whether to extract the tree for each subset (<code>TRUE</code>) or not (<code>FALSE</code>; default) or specific subset names or numbers.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_to.root">to.root</code></td>
<td>
<p>Logical, whether to return the subset tree including the root of the tree (<code>TRUE</code>) or only containing the elements in the subset (and their most recent common ancestor; <code>FALSE</code>; default). If <code>data</code> contains time bins (from <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> with <code>method = "discrete"</code>), and <code>to.root = FALSE</code> it returns the subtrees containing only what's in the bin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.tree</code> allows to extract the trees specific to each subsets.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme and Jack Hadfield
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading a dispRity object
data(disparity)
## Loading a tree
data(BeckLee_tree)

## Removing  the tree from the dispRity object
(tree_data &lt;- remove.tree(disparity))

## Extracting the tree
get.tree(tree_data) # is null

## Adding a tree to the disparity object
tree_data &lt;- add.tree(tree_data, tree = BeckLee_tree)

## Extracting the tree
get.tree(tree_data) # is a "phylo" object

## Adding the same tree again
tree_data &lt;- add.tree(tree_data, tree = BeckLee_tree)
get.tree(tree_data) # is a "multiPhylo" object (2 trees)

## Replacing the two trees by one tree
tree_data &lt;- add.tree(tree_data, tree = BeckLee_tree, replace = TRUE)
get.tree(tree_data) # is a "phylo" object

</code></pre>

<hr>
<h2 id='adonis.dispRity'>adonis dispRity (from <code>vegan::adonis2</code>)</h2><span id='topic+adonis.dispRity'></span>

<h3>Description</h3>

<p>Passing <code>dispRity</code> objects to the <code><a href="vegan.html#topic+adonis2">adonis2</a></code> function from the <code>vegan</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adonis.dispRity(
  data,
  formula = matrix ~ group,
  method = "euclidean",
  ...,
  warn = TRUE,
  matrix = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adonis.dispRity_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object with subsets</p>
</td></tr>
<tr><td><code id="adonis.dispRity_+3A_formula">formula</code></td>
<td>
<p>The model formula (default is <code>matrix ~ group</code>, see details)</p>
</td></tr>
<tr><td><code id="adonis.dispRity_+3A_method">method</code></td>
<td>
<p>The distance method to be passed to <code><a href="vegan.html#topic+adonis2">adonis2</a></code> and eventually to <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (see details - default <code>method ="euclidean"</code>)</p>
</td></tr>
<tr><td><code id="adonis.dispRity_+3A_...">...</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="vegan.html#topic+adonis2">adonis2</a></code></p>
</td></tr>
<tr><td><code id="adonis.dispRity_+3A_warn">warn</code></td>
<td>
<p><code>logical</code>, whether to print internal warnings (<code>TRUE</code>; default - advised) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="adonis.dispRity_+3A_matrix">matrix</code></td>
<td>
<p><code>numeric</code>, which matrix to use (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first element of the formula (the response) must be called <code>matrix</code> and the predictors must be existing in the subsets of the <code>dispRity</code> object.
</p>
<p>If <code>data$matrix[[1]]</code> is not a distance matrix, distance is calculated using the <code><a href="stats.html#topic+dist">dist</a></code> function. The type of distance can be passed via the standard <code>method</code> argument that will be recycled by <code><a href="vegan.html#topic+adonis2">adonis2</a></code>.
</p>
<p>If the <code>dispRity</code> data has custom subsets with a single group, the formula is set to <code>matrix ~ group</code>.
</p>
<p>If the <code>dispRity</code> data has custom subsets with multiple group categories (separated by a dot, e.g. <code>c("group1.cat1", "group1.cat2", "group2.catA", "group2.catB")</code> being two groups with two categories each), the default formula is <code>matrix ~ first_group</code> but can be set to any combination (e.g. <code>matrix ~ first_group + second_group</code>).
</p>
<p>If the <code>dispRity</code> data has time subsets, the predictor is automatically set to <code>time</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+adonis2">adonis2</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Adonis with one groups 

## Generating a random character matrix
character_matrix &lt;- sim.morpho(rtree(20), 50, rates = c(rnorm, 1, 0))
## Calculating the distance matrix
distance_matrix &lt;- as.matrix(dist(character_matrix))
## Creating two groups
random_groups &lt;- list("group1" = 1:10, "group2" = 11:20)

## Generating a dispRity object
random_disparity &lt;- custom.subsets(distance_matrix, random_groups)
## Running a default NPMANOVA
adonis.dispRity(random_disparity)


## Adonis with multiple groups

## Creating a random matrix
random_matrix &lt;- matrix(data = rnorm(90), nrow = 10, 
                     dimnames = list(letters[1:10]))
## Creating two groups with two states each
groups &lt;- as.data.frame(matrix(data = c(rep(1,5), rep(2,5), rep(c(1,2), 5)),
         nrow = 10, ncol = 2, dimnames = list(letters[1:10], c("g1", "g2"))))

## Creating the dispRity object
multi_groups &lt;- custom.subsets(random_matrix, groups)

## Running the NPMANOVA
adonis.dispRity(multi_groups, matrix ~ g1 + g2)

## Adonis with time

## Creating time series
data(BeckLee_mat50)
data(BeckLee_tree)
data(BeckLee_ages)
time_subsets &lt;- chrono.subsets(BeckLee_mat50, BeckLee_tree, 
     method = "discrete", inc.nodes = FALSE, time = c(100, 85, 65, 0),
     FADLAD = BeckLee_ages)

## Running the NPMANOVA with time as a predictor
adonis.dispRity(time_subsets, matrix ~ time)

## Running the NPMANOVA with each time bin as a predictor
adonis.dispRity(time_subsets, matrix ~ chrono.subsets)


</code></pre>

<hr>
<h2 id='apply.NA'>Apply inapplicable characters to a matrix.</h2><span id='topic+apply.NA'></span>

<h3>Description</h3>

<p>Apply inapplicable characters to discrete morphological matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.NA(matrix, NAs, tree, invariant = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply.NA_+3A_matrix">matrix</code></td>
<td>
<p>A discrete morphological matrix.</p>
</td></tr>
<tr><td><code id="apply.NA_+3A_nas">NAs</code></td>
<td>
<p>Either a numeric value of how many characters to make inapplicable or vector of characters inapplicability source (either <code>"character"</code> or <code>"clade"</code>; see details). The length of this vector must be at maximum half the total number of characters.</p>
</td></tr>
<tr><td><code id="apply.NA_+3A_tree">tree</code></td>
<td>
<p>If any inapplicable source is <code>"clade"</code>, a tree from where to select the clades.</p>
</td></tr>
<tr><td><code id="apply.NA_+3A_invariant">invariant</code></td>
<td>
<p>Whether to allow invariant sites among the characters with inapplicable data. If <code>invariant = FALSE</code> the algorithm will try to remove such characters (if possible).</p>
</td></tr>
<tr><td><code id="apply.NA_+3A_verbose">verbose</code></td>
<td>
<p>Whether to be verbose or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>NAs</code> argument is a numeric value n, generates n characters with inapplicable data based on the <code>"clade"</code> source.
</p>
<p>The <code>NAs</code> argument intakes a vector of character inapplicability source rendering a number of characters inapplicable using the following sources:
</p>
<p><code>"character"</code> draws inapplicable characters directly from the character matrix, ignoring the phylogeny (i.e. for a random character X, an other random character Y will have inapplicable characters for each character states 0 for character X).
</p>
<p><code>"clade"</code> draws inapplicable characters from the phylogeny: it will randomly apply inapplicable characters states for some characters by randomly selecting clades from the provided tree. The algorithm randomly assigns an inapplicable token for this character for all taxa in this clade or all taxa outside this clade.
</p>
<p>For example <code>NAs = c(rep("character", 2), rep("clade", 2))</code> will generate 4 characters with inapplicable data, two using previous characters and two other using random clades.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.morpho">sim.morpho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
## A random tree with 15 tips
tree &lt;- rcoal(15)
## setting up the parameters
my_rates = c(rgamma, rate = 10, shape = 5)
my_substitutions = c(runif, 2, 2)

## A Mk matrix (10*50)
matrixMk &lt;- sim.morpho(tree, characters = 100, model = "ER",
     states = c(0.85, 0.15), rates = my_rates, invariant = FALSE)

## Setting the number and source of inapplicable characters
my_inapplicables &lt;- c(rep("character", 5), rep("clade", 5))

## Apply some inapplicable characters to the matrix
matrix &lt;- apply.NA(matrixMk, my_inapplicables, tree, verbose = TRUE)

</code></pre>

<hr>
<h2 id='as.covar'>as.covar</h2><span id='topic+as.covar'></span>

<h3>Description</h3>

<p>Changes a dispRity metric to use the covar element from a dispRity object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.covar(fun, ..., VCV = TRUE, loc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.covar_+3A_fun">fun</code></td>
<td>
<p>a <code>function</code> to apply to the <code>$covar</code> element of <code>dispRity</code>.</p>
</td></tr>
<tr><td><code id="as.covar_+3A_...">...</code></td>
<td>
<p>any additional arguments to pass to fun.</p>
</td></tr>
<tr><td><code id="as.covar_+3A_vcv">VCV</code></td>
<td>
<p>logical, whether to use the <code>$VCV</code> component of the elements in <code>dispRity$covar</code> (<code>TRUE</code>; default) or not (<code>FALSE</code>) (see details).</p>
</td></tr>
<tr><td><code id="as.covar_+3A_loc">loc</code></td>
<td>
<p>logical, whether to use the <code>$loc</code> component of the elements in <code>dispRity$covar</code> (<code>TRUE</code>) or not (<code>FALSE</code>; default) (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function effectively transforms the input argument from <code>matrix</code> (or <code>matrix2</code>) to <code>matrix = matrix$VCV</code> and adds a evaluation after the return call to indicate that the function works on a <code>$covar</code> element.
Note that if the function does not have an argument called <code>matrix</code>, the first argument is estimated as being the one to be transformed (e.g. if the function has its first argument <code>x</code>, it will transform it to <code>x = x$VCV</code>).
</p>
<p>You can toggle between using the <code>$VCV</code> or the <code>$loc</code> argument in the <code>$covar</code> matrix by using either <code>VCV = TRUE, loc = FALSE</code> (to access only <code>fun(matrix = matrix$VCV, ...)</code>), <code>VCV = FALSE, loc = TRUE</code> (to access only <code>matrix = matrix(matrix$loc, nrow = 1), ...</code>) or <code>VCV = TRUE, loc = TRUE</code> (to access <code>fun(matrix = matrix$VCV, loc = matrix$loc, ...)</code>; provided <code>fun</code> has an extra <code>loc</code> argument).
</p>
<p>For <code>between.groups</code> metrics with <code>matrix</code> and <code>matrix2</code> arguments, you can provide multiple logicals for <code>VCV</code> and <code>loc</code> to be applied repspectively to <code>matrix</code> and <code>matrix2</code>. For example <code>VCV = TRUE</code> will reinterpret <code>matrix</code> and <code>matrix2</code> as <code>matrix$VCV</code> and <code>matrix2$VCV</code> but <code>loc = c(TRUE, FALSE)</code> will only reinterpret <code>matrix</code> as <code>matrix$loc</code> (and <code>matrix2</code> will not be reinterpreted).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code> <code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a dispRity
data(charadriiformes)

## Creating a dispRity object from the charadriiformes model
covar_data &lt;- MCMCglmm.subsets(data       = charadriiformes$data,
                               posteriors = charadriiformes$posteriors)

## Get one matrix and one covar matrix
one_matrix &lt;- get.matrix(covar_data, subsets = 1)
one_covar  &lt;- get.covar(covar_data, subsets = 1, n = 1)[[1]][[1]]

## Measure the centroids
centroids(one_matrix)

## Measure the centroids on the covar matrix
as.covar(centroids)(one_covar)
## Is the same as:
centroids(one_covar$VCV)

## Apply the measurement on a dispRity object:
## On the traitspace:
summary(dispRity(covar_data, metric = c(sum, centroids))) 
## On the covariance matrices:
summary(dispRity(covar_data, metric = c(sum, as.covar(centroids))))
## The same but with additional options (centre = 100)
summary(dispRity(covar_data,
                 metric = c(sum, as.covar(centroids)),
                 centre = 100))

## Example with the VCV and loc options
## A metric that works with both VCV and loc
## (the sum of the variances minus the distance from the location)
sum.var.dist &lt;- function(matrix, loc = rep(0, ncol(matrix))) {
    ## Get the sum of the diagonal of the matrix
    sum_diag &lt;- sum(diag(matrix))
    ## Get the distance between 0 and the loc
    dist_loc &lt;- dist(matrix(c(rep(0, ncol(matrix)), loc), nrow = 2, byrow = TRUE))[1]
    ## Return the sum of the diagonal minus the distance
    return(sum_diag - dist_loc)
}
## Changing the $loc on one_covar for the demonstration
one_covar$loc &lt;- c(1, 2, 3)
## Metric on the VCV part only
as.covar(sum.var.dist, VCV = TRUE, loc = FALSE)(one_covar)
## Metric on the loc part only
as.covar(sum.var.dist, VCV = FALSE, loc = TRUE)(one_covar)
## Metric on both parts
as.covar(sum.var.dist, VCV = TRUE, loc = TRUE)(one_covar)

</code></pre>

<hr>
<h2 id='BeckLee'>Beck and Lee 2014 datasets</h2><span id='topic+BeckLee'></span><span id='topic+BeckLee_tree'></span><span id='topic+BeckLee_mat50'></span><span id='topic+BeckLee_mat99'></span><span id='topic+BeckLee_ages'></span>

<h3>Description</h3>

<p>Example datasets from Beck and Lee 2014.
</p>


<h3>Format</h3>

<p>three matrices and one phylogenetic tree.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>BeckLee_tree</code> A phylogenetic tree with 50 living and fossil taxa
</p>
</li>
<li> <p><code>BeckLee_mat50</code> The ordinated matrix based on the 50 taxa cladistic distances
</p>
</li>
<li> <p><code>BeckLee_mat99</code> The ordinated matrix based on the 50 taxa + 49 nodes cladistic distances
</p>
</li>
<li> <p><code>BeckLee_ages</code> A list of first and last occurrence data for fossil taxa
</p>
</li>
<li> <p><code>BeckLee_disparity</code> a <code>dispRity</code> object with estimated sum of variances in 120 time bins, boostrapped 100 times from the Beck and Lee data
</p>
</li></ul>



<h3>References</h3>

<p>Beck RMD &amp; Lee MSY. 2014. Ancient dates or accelerated rates?
Morphological clocks and the antiquity of placental mammals.
Proc. R. Soc. B 2014 281 20141278; DOI: 10.1098/rspb.2014.1278
</p>


<h3>See Also</h3>

<p>BeckLee_disparity disparity
</p>

<hr>
<h2 id='BeckLee_disparity'>BeckLee_disparity</h2><span id='topic+BeckLee_disparity'></span>

<h3>Description</h3>

<p>An example of a <code>dispRity</code> object.
</p>


<h3>Format</h3>

<p>one <code>dispRity</code> object.
</p>


<h3>Details</h3>

<p>This matrix is based on the <code><a href="#topic+BeckLee">BeckLee</a></code> dataset and split into 120 continuous subsets (<code><a href="#topic+chrono.subsets">chrono.subsets</a></code>).
It was bootstrapped 100 times (<code><a href="#topic+boot.matrix">boot.matrix</a></code>) with four rarefaction levels.
Disparity was calculated as the <code><a href="base.html#topic+sum">sum</a></code> of the <code><a href="#topic+variances">variances</a></code> (<code><a href="#topic+dispRity">dispRity</a></code>).
</p>


<h3>See Also</h3>

<p>BeckLee disparity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Loading the data
data(BeckLee_mat99)
data(BeckLee_tree)
data(BeckLee_ages)

## Creating the 7 subsets
subsets &lt;- chrono.subsets(BeckLee_mat99, BeckLee_tree,
                          time = seq(from = 0, to = 120, by = 1),
                          method = "continuous", model = "proximity",
                          FADLAD = BeckLee_ages)

## Bootstrapping and rarefying
bootstraps &lt;- boot.matrix(subsets, bootstraps = 100)

## Calculating disparity
BeckLee_disparity &lt;- dispRity(bootstraps, metric = c(sum, variances))

## End(Not run)
</code></pre>

<hr>
<h2 id='bhatt.coeff'>Bhattacharyya Coefficient</h2><span id='topic+bhatt.coeff'></span>

<h3>Description</h3>

<p>Calculates the probability of overlap between two distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bhatt.coeff(x, y, bw = bw.nrd0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bhatt.coeff_+3A_x">x</code>, <code id="bhatt.coeff_+3A_y">y</code></td>
<td>
<p>two distributions.</p>
</td></tr>
<tr><td><code id="bhatt.coeff_+3A_bw">bw</code></td>
<td>
<p>the bandwidth size, either a <code>numeric</code> or a <code>function</code> (see <code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>).</p>
</td></tr>
<tr><td><code id="bhatt.coeff_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the <code>bw</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Bhattacharyya A. <b>1943</b>. On a measure of divergence between two statistical populations defined by their probability distributions. Bull. Calcutta Math. Soc., 35, pp. 99-109
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="#topic+null.test">null.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two dummy distributions
x &lt;- rnorm(1000, 0, 1)
y &lt;- rnorm(1000, 1, 2)

## What is the probability of overlap of these distributions?
bhatt.coeff(x, y)

</code></pre>

<hr>
<h2 id='boot.matrix'>Bootstraps and rarefies data.</h2><span id='topic+boot.matrix'></span>

<h3>Description</h3>

<p>Bootstraps and rarefies either a matrix or a list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.matrix(
  data,
  bootstraps = 100,
  rarefaction = FALSE,
  dimensions = NULL,
  verbose = FALSE,
  boot.type = "full",
  prob = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.matrix_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or a list of matrices (typically output from <a href="#topic+chrono.subsets">chrono.subsets</a> or <a href="#topic+custom.subsets">custom.subsets</a> - see details).</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_bootstraps">bootstraps</code></td>
<td>
<p>The number of bootstrap pseudoreplicates (<code>default = 100</code>).</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_rarefaction">rarefaction</code></td>
<td>
<p>Either a <code>logical</code> value whether to fully rarefy the data, a set of <code>numeric</code> values used to rarefy the data or <code>"min"</code> to rarefy at the minimum level (see details).</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_dimensions">dimensions</code></td>
<td>
<p>Optional, a vector of <code>numeric</code> value(s) or the proportion of the dimensions to keep.</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value indicating whether to be verbose or not.</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_boot.type">boot.type</code></td>
<td>
<p>The bootstrap algorithm to use (<code>default = "full"</code>; see details).</p>
</td></tr>
<tr><td><code id="boot.matrix_+3A_prob">prob</code></td>
<td>
<p>Optional, a <code>matrix</code> or a <code>vector</code> of probabilities for each element to be selected during the bootstrap procedure. The <code>matrix</code> or the <code>vector</code> must have a row names or names attribute that corresponds to the elements in <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code>: The data is considered as the multidimensional space and is not transformed (e.g. if ordinated with negative eigen values, no correction is applied to the matrix).
</p>
<p><code>rarefaction</code>: when the input is <code>numeric</code>, the number of elements is set to the value(s) for each bootstrap. If some subsets have fewer elements than the rarefaction value, the subsets is not rarefied.
When the input is <code>"min"</code>, the smallest number of elements is used (or 3 if some subsets have less than 3 elements).
</p>
<p><code>boot.type</code>: the different bootstrap algorithms are:
</p>

<ul>
<li> <p><code>"full"</code>: resamples all the rows of the matrix and replaces them with a new random sample of rows (with <code>replace = TRUE</code>, meaning all the elements can be duplicated in each bootstrap).
</p>
</li>
<li> <p><code>"single"</code>: resamples only one row of the matrix and replaces it with a new randomly sampled row (with <code>replace = FALSE</code>, meaning that only one element can be duplicated in each bootstrap).
</p>
</li>
<li> <p><code>"null"</code>: resamples all rows of the matrix across subsets. I.e. for each subset of <em>n</em> elements, this algorithm resamples <em>n</em> elements across <em>ALL</em> subsets. If only one subset (or none) is used, this does the same as the <code>"full"</code> algorithm.
</p>
</li></ul>

<p><code>prob</code>: This option allows to attribute specific probability to each element to be drawn.
A probability of 0 will never sample the element, a probability of 1 will always allow it to be sampled.
This can also be useful for weighting elements: an element with a weight of 10 will be sampled ten times more.
If the argument is a <code>matrix</code>, it must have rownames attributes corresponding to the element names.
If the argument is a <code>vector</code>, it must have names attributes corresponding to the element names.
</p>
<p>Multiple trees: If the given <code>data</code> is a <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> based on multiple trees, the sampling is proportional to the presence of each element in each tree: <code class="reqn">\sum (1/n) / T</code> (with <em>n</em> being the maximum number of elements among the trees and <em>T</em> being the total numbers of trees).
For example, for a slice through two trees resulting in the selection of elements <code>A</code> and <code>B</code> in the first tree and <code>A</code>, <code>B</code> and <code>C</code> in the second tree, the <code>"full"</code> bootstrap algorithm will select three elements (with replacement) between <code>A</code>, <code>B</code> and <code>C</code> with a probability of respectively <code class="reqn">p(A) = 1/3</code> (<code class="reqn">p(A) = (1/3 + 1/3) / 2</code>), <code class="reqn">p(B) = 1/3</code> and <code class="reqn">p(C) = 1/6</code> (<code class="reqn">p(C) = (0 + 1/3) / 2</code>).
</p>


<h3>Value</h3>

<p>This function outputs a <code>dispRity</code> object containing:
</p>
<table>
<tr><td><code>matrix</code></td>
<td>
<p>the multidimensional space (a <code>matrix</code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>A <code>list</code> containing the called arguments.</p>
</td></tr>
<tr><td><code>subsets</code></td>
<td>
<p>A <code>list</code> containing matrices pointing to the elements present in each subsets.</p>
</td></tr>
</table>
<p>Use <a href="#topic+summary.dispRity">summary.dispRity</a> to summarise the <code>dispRity</code> object.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cust.subsets">cust.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 matrix
data(BeckLee_mat50)

## Bootstrapping a matrix
## Bootstrapping an ordinated matrix 20 times
boot.matrix(BeckLee_mat50, bootstraps = 20)
## Bootstrapping an ordinated matrix with rarefaction
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = TRUE)
## Bootstrapping an ordinated matrix with only elements 7, 10 and 11 sampled
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = c(7, 10, 11))
## Bootstrapping an ordinated matrix with only 3 dimensions
boot.matrix(BeckLee_mat50, bootstraps = 20, dimensions = 3)
## Bootstrapping an the matrix but without sampling Cimolestes and sampling Maelestes 10x more
boot.matrix(BeckLee_mat50, bootstraps = 20, prob = c("Cimolestes" = 0, "Maelestes" = 10))

## Bootstrapping a subsets of matrices
## Generating a dummy subsets of matrices
ordinated_matrix &lt;- matrix(data = rnorm(90), nrow = 10, ncol = 9,
                           dimnames = list(letters[1:10]))
matrix_list &lt;- custom.subsets(ordinated_matrix, list(A = 1:5, B = 6:10))
## Bootstrapping the subsets of matrices 20 times (each)
boot.matrix(matrix_list, bootstraps = 20)

</code></pre>

<hr>
<h2 id='char.diff'>Character differences</h2><span id='topic+char.diff'></span>

<h3>Description</h3>

<p>Calculates the character difference from a discrete matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char.diff(
  matrix,
  method = "hamming",
  translate = TRUE,
  special.tokens,
  special.behaviours,
  order = FALSE,
  by.col = TRUE,
  correction
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char.diff_+3A_matrix">matrix</code></td>
<td>
<p>A discrete matrix or a list containing discrete characters. The differences is calculated between the columns (usually characters). Use <code>t(matrix)</code> or <code>by.col = FALSE</code> to calculate the differences between the rows.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_method">method</code></td>
<td>
<p>The method to measure difference: <code>"hamming"</code> (default; Hamming 1950), <code>"manhattan"</code>, <code>"comparable"</code>, <code>"euclidean"</code>, <code>"maximum"</code>, <code>"mord"</code> (Lloyd 2016), <code>"none"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_translate">translate</code></td>
<td>
<p><code>logical</code>, whether to translate the characters following the <em>xyz</em> notation (<code>TRUE</code> - default; see details - Felsenstein 2004) or not (<code>FALSE</code>). Translation works for up to 26 tokens per character.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_special.tokens">special.tokens</code></td>
<td>
<p>optional, a named <code>vector</code> of special tokens to be passed to <code><a href="base.html#topic+grep">grep</a></code> (make sure to protect the character with <code>"\\"</code>). By default <code>special.tokens &lt;- c(missing = "\\?", inapplicable = "\\-", polymorphism = "\\&amp;", uncertainty = "\\/")</code>. Note that <code>NA</code> values are not compared and that the symbol &quot;@&quot; is reserved and cannot be used.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_special.behaviours">special.behaviours</code></td>
<td>
<p>optional, a <code>list</code> of one or more functions for a special behaviour for <code>special.tokens</code>. See details.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_order">order</code></td>
<td>
<p><code>logical</code>, whether the character should be treated as order (<code>TRUE</code>) or not (<code>FALSE</code> - default). This argument can be a <code>logical</code> vector equivalent to the number of rows or columns in <code>matrix</code> (depending on <code>by.col</code>) to specify ordering for each character.</p>
</td></tr>
<tr><td><code id="char.diff_+3A_by.col">by.col</code></td>
<td>
<p><code>logical</code>, whether to measure the distance by columns (<code>TRUE</code> - default) or by rows (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="char.diff_+3A_correction">correction</code></td>
<td>
<p>optional, an eventual <code>function</code> to apply to the matrix after calculating the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each method for calculating distance is expressed as a function of <code class="reqn">d(x, y)</code> where <code class="reqn">x</code> and <code class="reqn">y</code> are a pair of columns (if <code>by.col = TRUE</code>) or rows in the matrix and <em>n</em> is the number of comparable rows (if <code>by.col = TRUE</code>) or columns between them and <em>i</em> is any specific pair of rows (if <code>by.col = TRUE</code>) or columns.
The different methods are:
</p>

<ul>
<li> <p><code>"hamming"</code> The relative distance between characters. This is equal to the Gower distance for non-numeric comparisons (e.g. character tokens; Gower 1966).
<code class="reqn">d(x,y) = \sum[i,n](abs(x[i] - y[i])/n</code>
</p>
</li>
<li> <p><code>"manhattan"</code> The &quot;raw&quot; distance between characters:
<code class="reqn">d(x,y) = \sum[i,n](abs(x[i] - y[i])</code>
</p>
</li>
<li> <p><code>"comparable"</code> The number of comparable characters (i.e. the number of tokens that can be compared):
<code class="reqn">d(x,y) = \sum[i,n]((x[i] - y[i])/(x[i] - y[i]))</code>
</p>
</li>
<li> <p><code>"euclidean"</code> The euclidean distance between characters:
<code class="reqn">d(x,y) = \sqrt(\sum[i,n]((x[i] - y[i])^2))</code>
</p>
</li>
<li> <p><code>"maximum"</code> The maximum distance between characters:
<code class="reqn">d(x,y) = max(abs(x[i] - y[i]))</code>
</p>
</li>
<li> <p><code>"mord"</code> The maximum observable distance between characters (Lloyd 2016):
<code class="reqn">d(x,y) =  \sum[i,n](abs(x[i] - y[i])/\sum[i,n]((x[i] - y[i])/(x[i] - y[i])</code>
</p>
</li>
<li> <p><code>"none"</code> Returns the matrix with eventual converted and/or translated tokens.
</p>
</li>
<li> <p><code>"binary"</code> Returns the matrix with the binary characters.
</p>
</li></ul>

<p>When using <code>translate = TRUE</code>, the characters are translated following the <em>xyz</em> notation where the first token is translated to 1, the second to 2, etc. For example, the character <code>0, 2, 1, 0</code> is translated to <code>1, 2, 3, 1</code>. In other words when <code>translate = TRUE</code>, the character tokens are not interpreted as numeric values. When using <code>translate = TRUE</code>, scaled metrics (i.e <code>"hamming"</code> and <code>"gower"</code>) are divide by <code class="reqn">n-1</code> rather than <code class="reqn">n</code> due to the first character always being equal to 1.
</p>
<p><code>special.behaviours</code> allows to generate a special rule for the <code>special.tokens</code>. The functions should can take the arguments <code>character, all_states</code> with <code>character</code> being the character that contains the special token and <code>all_states</code> for the character (which is automatically detected by the function). By default, missing data returns and inapplicable returns <code>NA</code>, and polymorphisms and uncertainties return all present states.
</p>

<ul>
<li><p><code>missing = function(x,y) NA</code>
</p>
</li>
<li><p><code>inapplicable = function(x,y) NA</code>
</p>
</li>
<li><p><code>polymorphism = function(x,y) strsplit(x, split = "\\&amp;")[[1]]</code>
</p>
</li>
<li><p><code>uncertainty = function(x,y) strsplit(x, split = "\\/")[[1]]</code>
</p>
</li></ul>

<p>Functions in the list must be named following the special token of concern (e.g. <code>missing</code>), have only <code>x, y</code> as inputs and a single output a single value (that gets coerced to <code>integer</code> automatically). For example, the special behaviour for the special token <code>"?"</code> can be coded as: <code>special.behaviours = list(missing = function(x, y) return(y)</code> to make all comparisons containing the special token containing <code>"?"</code> return any character state <code>y</code>.
</p>
<p>IMPORTANT: Note that for any distance method, <code>NA</code> values are skipped in the distance calculations (e.g. distance(<code>A = {1, NA, 2}, B = {1, 2, 3}</code>) is treated as distance(<code>A = {1, 2}, B = {1, 3}</code>)).
</p>
<p>IMPORTANT: Note that the number of symbols (tokens) per character is limited by your machine's word-size (32 or 64 bits). If you have more than 64 tokens per character, you might want to use continuous data.
</p>


<h3>Value</h3>

<p>A character difference value or a matrix of class <code>char.diff</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Felsenstein, J. <b>2004</b>. Inferring phylogenies vol. 2. Sinauer Associates Sunderland.
Gower, J.C. <b>1966</b>. Some distance properties of latent root and vector methods used in multivariate analysis. Biometrika 53:325-338.
Hamming, R.W. <b>1950</b>. Error detecting and error correcting codes. The Bell System Technical Journal. DOI: 10.1002/j.1538-7305.1950.tb00463.x.
Lloyd, G.T. <b>2016</b>. Estimating morphological diversity and tempo with discrete character-taxon matrices: implementation, challenges, progress, and future directions. Biological Journal of the Linnean Society. DOI: 10.1111/bij.12746.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.char.diff">plot.char.diff</a></code>, <code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="Claddis.html#topic+calculate_morphological_distances">calculate_morphological_distances</a></code>, <code><a href="cluster.html#topic+daisy">daisy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparing two binary characters
char.diff(list(c(0, 1, 0, 1), c(0, 1, 1, 1)))

## Pairwise comparisons in a morphological matrix
morpho_matrix &lt;- matrix(sample(c(0,1), 100, replace = TRUE), 10)
char.diff(morpho_matrix)

## Adding special tokens to the matrix
morpho_matrix[sample(1:100, 10)] &lt;- c("?", "0&amp;1", "-")
char.diff(morpho_matrix)

## Modifying special behaviours for tokens with "&amp;" to be treated as NA
char.diff(morpho_matrix,
          special.behaviours = list(polymorphism = function(x,y) return(NA)))

## Adding a special character with a special behaviour (count "%" as "100")
morpho_matrix[sample(1:100, 5)] &lt;- "%"
char.diff(morpho_matrix,
          special.tokens = c("paragraph" = "\\%"),
          special.behaviours = list(paragraph = function(x,y) as.integer(100)))

## Comparing characters with/without translation
char.diff(list(c(0, 1, 0, 1), c(1, 0, 1, 0)), method = "manhattan")
# no character difference
char.diff(list(c(0, 1, 0, 1), c(1, 0, 1, 0)), method = "manhattan",
          translate = FALSE)
# all four character states are different

</code></pre>

<hr>
<h2 id='charadriiformes'>Charadriiformes</h2><span id='topic+charadriiformes'></span>

<h3>Description</h3>

<p>An example of a <code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code> model.
</p>


<h3>Format</h3>

<p>one <code>data.frame</code>, one <code>phylo</code> and one <code>MCMCglmm</code>.
</p>


<h3>Details</h3>

<p>This dataset is based on a random subset of 359 Charadriiformes (gulls, plovers and sandpipers) from Cooney et al 2017 and trees from Jetz et al 2012.
It contains:
</p>

<ul>
<li> <p><code>data</code> A <code>"data.frame"</code> .
</p>
</li>
<li> <p><code>tree</code> A consensus tree of 359 charadriiformes species (<code>"phylo"</code>).
</p>
</li>
<li> <p><code>posteriors</code> The posteriors from a <code>"MCMCglmm"</code> model (see example below).
</p>
</li>
<li> <p><code>tree_distribution</code> A random distribution of 10 trees of the 359 charadriiformes species (<code>"multiPhylo"</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Cooney CR, Bright JA, Capp EJ, Chira AM,Hughes EC, Moody CJ, Nouri LO, Varley ZK, Thomas GH. Mega-evolutionary dynamics of the adaptive radiation of birds. Nature. 2017 Feb;542(7641):344-7.
</p>
<p>Jetz W, Thomas GH, Joy JB, Hartmann K, Mooers AO. The global diversity of birds in space and time. Nature. 2012 Nov;491(7424):444-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Reproducing the MCMCglmm model
require(MCMCglmm)
data(charadriiformes)

## Setting up the model parameters:
## 1 - The formula (the first three PC axes)
model_formula &lt;- cbind(PC1, PC2, PC3) ~ trait:clade-1
## 2 - The residual term
model_residuals &lt;- ~us(trait):units
## 3 - The random terms
## (one per clade and one for the whole phylogeny)
model_randoms &lt;- ~ us(at.level(clade,1):trait):animal
                 + us(at.level(clade,2):trait):animal
                 + us(at.level(clade,3):trait):animal
                 + us(trait):animal

## Flat priors for the residuals and random terms
flat_priors &lt;- list(
     ## The residuals priors
     R = list(
         R1 = list(V = diag(3), nu = 0.002)), 
     ## The random priors (the phylogenetic terms)
     G = list(
         G1 = list(V = diag(3), nu = 0.002),
         G2 = list(V = diag(3), nu = 0.002),
         G3 = list(V = diag(3), nu = 0.002),
         G4 = list(V = diag(3), nu = 0.002)))

## Run the model for 110000 iterations
## sampled every 100 with a burnin (discard)
## of the first 10000 iterations)
model &lt;- MCMCglmm(formula  = model_formula,
                  rcov     = model_residual,
                  random   = model_randoms,
                  family   = rep("gaussian", 3),
                  prior    = flat_priors,
                  nitt     = 110000,
                  burnin   = 10000,
                  thin     = 100,
                  pedigree = charadriiformes$tree,
                  data     = charadriiformes$data)

## End(Not run)
</code></pre>

<hr>
<h2 id='check.morpho'>Check a morphological matrix consistency levels.</h2><span id='topic+check.morpho'></span>

<h3>Description</h3>

<p>Performs a fast check of the phylogenetic signal in a morphological matrix using parsimony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.morpho(
  matrix,
  orig.tree,
  parsimony = "fitch",
  first.tree = c(phangorn::dist.hamming, phangorn::NJ),
  distance = phangorn::RF.dist,
  ...,
  contrast.matrix,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.morpho_+3A_matrix">matrix</code></td>
<td>
<p>A discrete morphological matrix.</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_orig.tree">orig.tree</code></td>
<td>
<p>Optional, the input tree to measure the distance between the parsimony and the original tree.</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_parsimony">parsimony</code></td>
<td>
<p>Either the parsimony algorithm to be passed to <code><a href="phangorn.html#topic+optim.parsimony">optim.parsimony</a></code> or a parsimony function that can take a <code><a href="phangorn.html#topic+phyDat">phyDat</a></code> object as an input (<code>default = "fitch"</code>).</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_first.tree">first.tree</code></td>
<td>
<p>A list of functions to generate the first most parsimonious tree (default = <code>c(<a href="phangorn.html#topic+dist.hamming">dist.hamming</a>, <a href="phangorn.html#topic+NJ">NJ</a>)</code>; see details).</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_distance">distance</code></td>
<td>
<p>Optional, if orig.tree is provided, the function to use for measuring distance between the trees (default = <code>link[phangorn]{RF.dist}</code>).</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to the parsimony algorithm.</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_contrast.matrix">contrast.matrix</code></td>
<td>
<p>An optional contrast matrix. By default, the function recognises any character state token as different apart from <code>?</code> that is treated as all characters.</p>
</td></tr>
<tr><td><code id="check.morpho_+3A_verbose">verbose</code></td>
<td>
<p>Whether to be verbose or not (<code>default = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The <code>first.tree</code> argument must be a list of functions to be used in a cascade to transform the matrix (as a <code><a href="phangorn.html#topic+phyDat">phyDat</a></code> object) into a tree using the functions iteratively.
For example the default <code>c(<a href="phangorn.html#topic+dist.hamming">dist.hamming</a>, <a href="phangorn.html#topic+NJ">NJ</a>)</code> will apply the following to the matrix: <code><a href="phangorn.html#topic+NJ">NJ</a>(<a href="phangorn.html#topic+dist.hamming">dist.hamming</a>(matrix))</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns the parsimony score (using <code><a href="phangorn.html#topic+parsimony">parsimony</a></code>), the consistency and retention indices (using <code><a href="phangorn.html#topic+CI">CI</a></code> and <code><a href="phangorn.html#topic+RI">RI</a></code>) from the most parsimonious tree obtained from the matrix.
Can also return the topological distance from the original tree if provided.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.morpho">sim.morpho</a></code>, <code><a href="#topic+get.contrast.matrix">get.contrast.matrix</a></code>, <code><a href="phangorn.html#topic+optim.parsimony">optim.parsimony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating a random tree
random_tree &lt;- rcoal(10)

## Generating a random matrix
random_matrix &lt;- sim.morpho(random_tree, characters = 50, model = "ER",
     rates = c(rgamma, 1, 1))

## Checking the matrix scores
check.morpho(random_matrix, orig.tree = random_tree)

</code></pre>

<hr>
<h2 id='chrono.subsets'>Separating data in chronological subsets.</h2><span id='topic+chrono.subsets'></span><span id='topic+time.series'></span><span id='topic+time.subsets'></span>

<h3>Description</h3>

<p>Splits the data into a chronological (time) subsets list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrono.subsets(
  data,
  tree = NULL,
  method,
  time,
  model,
  inc.nodes = FALSE,
  FADLAD = NULL,
  verbose = FALSE,
  t0 = FALSE,
  bind.data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chrono.subsets_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or a <code>list</code> of matrices.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_tree">tree</code></td>
<td>
<p><code>NULL</code> (default) or an optional <code>phylo</code> or <code>multiPhylo</code> object matching the data and with a <code>root.time</code> element. This argument can be left missing if <code>method = "discrete"</code> and all elements are present in the optional <code>FADLAD</code> argument.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_method">method</code></td>
<td>
<p>The time subsampling method: either <code>"discrete"</code> (or <code>"d"</code>) or <code>"continuous"</code> (or <code>"c"</code>).</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_time">time</code></td>
<td>
<p>Either a single <code>integer</code> for the number of discrete or continuous samples or a <code>vector</code> containing the age of each sample.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_model">model</code></td>
<td>
<p>One of the following models: <code>"acctran"</code>, <code>"deltran"</code>, <code>"random"</code>, <code>"proximity"</code>, <code>"equal.split"</code> or <code>"gradual.split"</code>. Is ignored if <code>method = "discrete"</code>.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_inc.nodes">inc.nodes</code></td>
<td>
<p>A <code>logical</code> value indicating whether nodes should be included in the time subsets. Is ignored if <code>method = "continuous"</code>.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_fadlad">FADLAD</code></td>
<td>
<p><code>NULL</code> (default) or an optional <code>data.frame</code> or <code>list</code> of <code>data.frame</code>s containing the first and last occurrence data.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value indicating whether to be verbose or not. Is ignored if <code>method = "discrete"</code>.</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_t0">t0</code></td>
<td>
<p>If <code>time</code> is a number of samples, whether to start the sampling from the <code>tree$root.time</code> (<code>TRUE</code>), or from the first sample containing at least three elements (<code>FALSE</code> - default) or from a fixed time point (if <code>t0</code> is a single <code>numeric</code> value).</p>
</td></tr>
<tr><td><code id="chrono.subsets_+3A_bind.data">bind.data</code></td>
<td>
<p>If <code>data</code> contains multiple matrices and <code>tree</code> contains the same number of trees, whether to bind the pairs of matrices and the trees (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is considered as the multidimensional space with rows as elements and columns as dimensions and is not transformed (e.g. if ordinated with negative eigen values, no correction is applied to the matrix).
</p>
<p>If <code>method = "continuous"</code> and when the sampling is done along an edge of the tree, the data selected for the time subsets can be one of the following:
</p>

<ul>
<li><p> Punctuated models:
</p>

<ul>
<li> <p><code>"acctran"</code>: always selecting the value from the ancestral node.
</p>
</li>
<li> <p><code>"deltran"</code>: always selecting the value from the descendant node or tip.
</p>
</li>
<li> <p><code>"random"</code>: randomly selecting between the ancestral node or the descendant node/tip.
</p>
</li>
<li> <p><code>"proximity"</code>: selecting the ancestral node or the descendant node/tip with a probability relative to branch length.
</p>
</li></ul>

</li>
<li><p> Gradual models:
</p>

<ul>
<li> <p><code>"equal.split"</code>: randomly selecting from the ancestral node or the descendant node or tip with a 50% probability each.
</p>
</li>
<li> <p><code>"gradual.split"</code>: selecting the ancestral node or the descendant with a probability relative to branch length.
</p>
</li></ul>

</li></ul>

<p>N.B. <code>"equal.split"</code> and <code>"gradual.split"</code> differ from the punctuated models by outputting a node/tip probability table rather than simply the node and the tip selected. In other words, when bootstrapping using <code><a href="#topic+boot.matrix">boot.matrix</a></code>, the two former models will properly integrate the probability to the bootstrap procedure (i.e. different tips/nodes can be drawn) and the two latter models will only use the one node/tip determined by the model before the bootstrapping.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Guillerme T. &amp; Cooper N. <b>2018</b>. Time for a rethink: time sub-sampling methods in disparity-through-time analyses. Palaeontology. DOI: 10.1111/pala.12364.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.age">tree.age</a></code>, <code><a href="#topic+slice.tree">slice.tree</a></code>, <code><a href="#topic+cust.subsets">cust.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_tree) ; data(BeckLee_mat50)
data(BeckLee_mat99) ; data(BeckLee_ages)

## Time binning (discrete method)
## Generate two discrete time bins from 120 to 40 Ma every 40 Ma
chrono.subsets(data = BeckLee_mat50, tree = BeckLee_tree, method = "discrete",
     time = c(120, 80, 40), inc.nodes = FALSE, FADLAD = BeckLee_ages)
## Generate the same time bins but including nodes
chrono.subsets(data = BeckLee_mat99, tree = BeckLee_tree, method = "discrete",
     time = c(120, 80, 40), inc.nodes = TRUE, FADLAD = BeckLee_ages)

## Time slicing (continuous method)
## Generate five equidistant time slices in the dataset assuming a proximity
## evolutionary model
chrono.subsets(data = BeckLee_mat99, tree = BeckLee_tree,
     method = "continuous", model = "acctran", time = 5,
     FADLAD = BeckLee_ages)

</code></pre>

<hr>
<h2 id='Claddis.ordination'>Imports data from Claddis</h2><span id='topic+Claddis.ordination'></span>

<h3>Description</h3>

<p>Takes Claddis data and computes both the distance and the ordination matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Claddis.ordination(data, distance = "mord", ..., k, add = TRUE, arg.cmdscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Claddis.ordination_+3A_data">data</code></td>
<td>
<p>Data from <code><a href="Claddis.html#topic+read_nexus_matrix">read_nexus_matrix</a></code> or the path to a file to be read by <code><a href="ape.html#topic+read.nexus.data">read.nexus.data</a></code> (see details).</p>
</td></tr>
<tr><td><code id="Claddis.ordination_+3A_distance">distance</code></td>
<td>
<p>Distance type to be computed by <code><a href="Claddis.html#topic+calculate_morphological_distances">calculate_morphological_distances</a></code>. Can be either <code>"gc"</code>, <code>"ged"</code>, <code>"red"</code>, <code>"mord"</code>. <code>distance</code> can also be set to <code>NULL</code> to convert a matrix in <code><a href="Claddis.html#topic+read_nexus_matrix">read_nexus_matrix</a></code> list type (see details).</p>
</td></tr>
<tr><td><code id="Claddis.ordination_+3A_...">...</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="Claddis.html#topic+calculate_morphological_distances">calculate_morphological_distances</a></code>.</p>
</td></tr>
<tr><td><code id="Claddis.ordination_+3A_k">k</code></td>
<td>
<p>The number of dimensions in the ordination. If left empty, the number of dimensions is set to number of rows - 1.</p>
</td></tr>
<tr><td><code id="Claddis.ordination_+3A_add">add</code></td>
<td>
<p>whether to use the Cailliez correction for negative eigen values (<code>add = TRUE</code>; default - see <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) or not (<code>add = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Claddis.ordination_+3A_arg.cmdscale">arg.cmdscale</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> (as a named list such as <code>list(x.ret = TRUE)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is a file path, the function will use a modified version of <code><a href="ape.html#topic+read.nexus.data">read.nexus.data</a></code> (that handles polymorphic and ambiguous characters). The file content will then be converted into a <code><a href="Claddis.html#topic+read_nexus_matrix">read_nexus_matrix</a></code> type list treating all characters as unordered.
If the <code>distance</code> is set to <code>NULL</code>, <code>data</code> will be only converted into a <code><a href="Claddis.html#topic+read_nexus_matrix">read_nexus_matrix</a></code> type list.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="Claddis.html#topic+calculate_morphological_distances">calculate_morphological_distances</a></code>, <code><a href="Claddis.html#topic+read_nexus_matrix">read_nexus_matrix</a></code>, <code><a href="Claddis.html#topic+build_cladistic_matrix">build_cladistic_matrix</a></code>, <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>, <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(Claddis)

## Ordinating the distance matrix of Claddis example data
Claddis.ordination(Claddis::michaux_1989)

## Creating simple discrete morphological matrix (with polymorphisms)
cat(
"#NEXUS
BEGIN DATA;
DIMENSIONS  NTAX=5 NCHAR=5;
FORMAT SYMBOLS= \" 0 1 2\" MISSING=? GAP=- ;
MATRIX
     t1  {01}1010
     t2  02120
     t3  1210(01)
     t4  01111
     t5  00101
;
END;", file = "morpho_matrix.nex")

## Ordinating the matrix (using a distance matrix)
Claddis.ordination("morpho_matrix.nex")

## Only converting the nexus matrix into a Claddis format
Claddis_data &lt;- Claddis.ordination("morpho_matrix.nex", distance = NULL)

file.remove("morpho_matrix.nex")

## End(Not run)

</code></pre>

<hr>
<h2 id='clean.data'>Cleaning phylogenetic data</h2><span id='topic+clean.data'></span>

<h3>Description</h3>

<p>Cleans a table/tree to match with a given table/tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.data(data, tree, inc.nodes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean.data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> with the elements names as row names.</p>
</td></tr>
<tr><td><code id="clean.data_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> or <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="clean.data_+3A_inc.nodes">inc.nodes</code></td>
<td>
<p>Logical, whether to check if the nodes in <code>tree</code> are also present in <code>data</code> (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note if <code>inc.nodes</code> is set to <code>TRUE</code>, the function outputs an error message if there is no matching.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing the cleaned data and tree(s) and information on the eventual dropped tips and rows.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.age">tree.age</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Creating a set of different trees
trees_list &lt;- list(rtree(5, tip.label = LETTERS[1:5]), rtree(4,
     tip.label = LETTERS[1:4]), rtree(6, tip.label = LETTERS[1:6]))
class(trees_list) &lt;- "multiPhylo"

##Creating a matrix
dummy_data &lt;- matrix(c(rnorm(5), runif(5)), 5, 2,
    dimnames = list(LETTERS[1:5], c("var1", "var2")))

##Cleaning the trees and the data
cleaned &lt;- clean.data(data = dummy_data, tree = trees_list)
##The taxa that where dropped (tips and rows):
c(cleaned$dropped_tips, cleaned$dropped_rows)
##The cleaned trees:
cleaned$tree
##The cleaned data set:
cleaned$data

</code></pre>

<hr>
<h2 id='covar.plot'>covar.plot</h2><span id='topic+covar.plot'></span><span id='topic+sauron.plot'></span>

<h3>Description</h3>

<p>Visualising components of a <code>dispRity</code> object with covar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar.plot(
  data,
  n,
  points = TRUE,
  major.axes = FALSE,
  ellipses = FALSE,
  level = 0.95,
  dimensions = c(1, 2),
  centres = colMeans,
  scale,
  transparent.scale,
  add = FALSE,
  apply.to.VCV = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covar.plot_+3A_data">data</code></td>
<td>
<p>an <code>dispRity</code> object with a covar component.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_n">n</code></td>
<td>
<p>optional, a number of random posteriors to use.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_points">points</code></td>
<td>
<p>logical, whether to plot the observed elements (<code>TRUE</code>; default) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_major.axes">major.axes</code></td>
<td>
<p>can be either logical for plotting all (or <code>n</code>) major.axes (<code>TRUE</code>) or none (<code>FALSE</code>; default) or a <code>function</code> for displaying one summarised major axis. See details.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_ellipses">ellipses</code></td>
<td>
<p>can be either logical for plotting all (or <code>n</code>) ellipses (<code>TRUE</code>) or none (<code>FALSE</code>; default) or a <code>function</code> for displaying one summarised ellipse. See details.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_level">level</code></td>
<td>
<p>the confidence interval level of the major axes and ellipses (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_dimensions">dimensions</code></td>
<td>
<p>which dimensions (default is <code>c(1,2)</code>).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_centres">centres</code></td>
<td>
<p>optional, a way to determine ellipses or major axes positions. Can be either a <code>function</code> (default is <code>colMeans</code>), a <code>vector</code> or a <code>list</code> of coordinates vectors or <code>"intercept"</code>. See details.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_scale">scale</code></td>
<td>
<p>optional, the name of a group from <code>data</code> on which to scale the ellipses and major axis to be the same size.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_transparent.scale">transparent.scale</code></td>
<td>
<p>optional, if multiple major axes and/or ellipses are plotted, a scaling factor for the transparency. If left empty, the transparency is set to <code>1/n</code> or <code>0.1</code> (whichever is higher).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_add">add</code></td>
<td>
<p>logical, whether to add the plot to an existing plot (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_apply.to.vcv">apply.to.VCV</code></td>
<td>
<p>logical, if <code>ellipse</code> and/or <code>major.axes</code> is a <code>function</code>, whether to apply it on all the estimated ellipses/major axes (<code>FALSE</code>; default) or on the variance covariance matrices directly (<code>TRUE</code>). In other words, whether to apply the function to the ellipses/major axis or the the VCV first (e.g. the average ellipses or the ellipse of the average VCV).</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_...">...</code></td>
<td>
<p>any graphical options to be passed to <code>plot</code>, <code>lines</code> or <code>points</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying optional arguments with <code>...</code> in a graph with multiple elements (e.g. <code>points</code>, <code>lines</code>, etc...) you can specify which specific element to affect using the syntax <code>&lt;element&gt;.&lt;argument&gt;</code>. For example if you want everything in the plot to be in blue at the exception of the points to be red, you can use <code>covar.plot(..., col = "blue", points.col = "red")</code>. 
</p>
<p>The arguments <code>major.axes</code> and <code>ellipses</code> can intake a <code>function</code> for summarising the display of multiple variance covariance matrices (if <code>n</code> is missing or greater than one). This can be any central tendency function such as <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code> or <code><a href="#topic+mode.val">mode.val</a></code>.
</p>
<p>The argument <code>centres</code> allows to determine how to calculate the centre of each ellipses or major axes. The argument can be either:
</p>

<ul>
<li><p> A <code>function</code> to calculate the centre from a group like the default <code>colMeans</code> function that calculates the centroid coordinates of each group;
</p>
</li>
<li><p> A <code>numeric</code> value to be replicated as the coordinates for the centre of each group (e.g. <code>centres = 0</code> sets all the centres at the coordinates <code>c(0,0,0,...)</code>); or a vector of numeric values to be directly used as the coordinates for each group (e.g. <code>centres = c(1,2,3)</code> sets all the centres at the coordinates <code>c(1,2,3)</code>); or a list of numeric values or numeric vectors to be used as the coordinates for the centres of each group;
</p>
</li>
<li> <p><code>"intercept"</code> for using the estimated posterior intercept for each sample.
</p>
</li></ul>

<p><em>NOTE</em> that if the input contains more dimensions than the visualised dimensions (by default <code>dimensions = c(1,2)</code>) the ellipses and major axes are projected from an n-dimensional space onto a 2D space which might make them look incorrect.
<em>NOTE</em> also that the ellipses and major axes are measured independently, when summarising both parameters (e.g. by using <code>ellipses = mean</code> and <code>major.axes = mean</code>), the displayed summarised major axes is not calculated from the summarised ellipse but from the coordinates of all major axes (and therefore might not match the coordinates of the ellipse).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code> <code><a href="#topic+covar.utilities">covar.utilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(charadriiformes)

## Creating a dispRity object from the charadriiformes model
covar &lt;- MCMCglmm.subsets(data       = charadriiformes$data,
                          posteriors = charadriiformes$posteriors,
                          group      = MCMCglmm.levels(
                                         charadriiformes$posteriors)[1:4],
                          rename.groups = c("gulls", "plovers",
                                            "sandpipers", "phylogeny"))

## Default plot
covar.plot(covar)

## Same plot with more options
covar.plot(covar, n = 50, ellipses = mean, major.axes = TRUE, 
           col = c("orange", "blue", "darkgreen", "grey", "grey"),
           legend = TRUE, points = TRUE, points.cex = 0.2,
           main = "Charadriiformes shapespace")

</code></pre>

<hr>
<h2 id='covar.utilities'>Utilities for a dispRity object with covariance matrices</h2><span id='topic+covar.utilities'></span><span id='topic+get.covar'></span><span id='topic+axis.covar'></span>

<h3>Description</h3>

<p>Different utility functions to extract aspects of a <code>MCMCglmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.covar(data, subsets, sample, n, dimensions)

axis.covar(data, subsets, sample, n, dimensions, level = 0.95, axis = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covar.utilities_+3A_data">data</code></td>
<td>
<p>a <code>dispRity</code> object with a <code>covar</code> element.</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_subsets">subsets</code></td>
<td>
<p>optional, a <code>numeric</code> or <code>character</code> for which subsets to get (if missing, the value for all subsets are given).</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_sample">sample</code></td>
<td>
<p>optional, one or more specific posterior sample IDs (is ignored if n is used) or a function to summarise all axes.</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_n">n</code></td>
<td>
<p>optional, a random number of covariance matrices to sample (if left empty, all are used).</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_dimensions">dimensions</code></td>
<td>
<p>optional, which dimensions to use. If missing the dimensions from <code>data</code> are used.</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_level">level</code></td>
<td>
<p>which confidence interval level to use (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="covar.utilities_+3A_axis">axis</code></td>
<td>
<p>which major axis to calculate (default is <code>1</code>, the first one).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Charadriiformes dataset
data(charadriiformes)
## Making a dispRity object with covar data
covar_data &lt;- MCMCglmm.subsets(data       = charadriiformes$data,
                               posteriors = charadriiformes$posteriors)

## Get the two first covar matrices for each level
get.covar(covar_data, sample = c(1,2))
## Get 2 random covar matrices in 2D for each level
get.covar(covar_data, n = 2, dimensions = c(1,2))
## Get mean covar matrix for each level
get.covar(covar_data, sample = mean)

## Get the 0.95 major axis for the 42th covar matrix
axis.covar(covar_data, sample = 42)
## Get the 0.5 major axis for 2 random samples
axis.covar(covar_data, n = 1, level = 0.5)
## Get the median 0.95 minor axis of the 2D ellipse
axis.covar(covar_data, sample = mean, dimensions = c(1,2), axis = 2)

</code></pre>

<hr>
<h2 id='crown.stem'>Separates stem and crown species</h2><span id='topic+crown.stem'></span>

<h3>Description</h3>

<p>Selects the crown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crown.stem(tree, inc.nodes = TRUE, output.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crown.stem_+3A_tree">tree</code></td>
<td>
<p>a <code>"phylo"</code> object</p>
</td></tr>
<tr><td><code id="crown.stem_+3A_inc.nodes">inc.nodes</code></td>
<td>
<p>whether to include the nodes (<code>TRUE</code>; default) or not (<code>FALSE</code>) in the output.</p>
</td></tr>
<tr><td><code id="crown.stem_+3A_output.names">output.names</code></td>
<td>
<p>whether to output the taxa names (<code>TRUE</code>; default) or two phylogenetic trees (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+tree.age">tree.age</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A tree with fossil taxa
data(BeckLee_tree)

## Getting both crown and stem taxa lists
crown.stem(BeckLee_tree)

## Splitting the tree into two subtrees
crown_stem_trees &lt;- crown.stem(BeckLee_tree, output.names = FALSE)
## Graphical parameters
op &lt;- par(mfrow = c(1,3))
## Plotting the trees
plot(BeckLee_tree, main = "Full tree")
plot(crown_stem_trees$crown, main = "Crown group")
plot(crown_stem_trees$stem, main = "Stem group")

</code></pre>

<hr>
<h2 id='custom.subsets'>Separating data into custom subsets.</h2><span id='topic+custom.subsets'></span><span id='topic+cust.series'></span><span id='topic+custom.series'></span><span id='topic+cust.subsets'></span>

<h3>Description</h3>

<p>Splits the data into a customized subsets list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.subsets(data, group, tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom.subsets_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or a <code>list</code> of matrices.</p>
</td></tr>
<tr><td><code id="custom.subsets_+3A_group">group</code></td>
<td>
<p>Either a <code>list</code> of row numbers or names to be used as different groups, a <code>data.frame</code> with the same <code class="reqn">k</code> elements as in <code>data</code> as rownames or a <code>factor</code> vector. If <code>group</code> is a <code>phylo</code> object matching <code>data</code>, groups are automatically generated as clades (and the tree is attached to the resulting <code>dispRity</code> object).</p>
</td></tr>
<tr><td><code id="custom.subsets_+3A_tree">tree</code></td>
<td>
<p><code>NULL</code> (default) or an optional <code>phylo</code> or <code>multiPhylo</code> object to be attached to the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that every element from the input data can be assigned to multiple groups!
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+crown.stem">crown.stem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating a dummy ordinated matrix
ordinated_matrix &lt;- matrix(data = rnorm(90), nrow = 10)

## Splitting the ordinated matrix into two groups using row numbers
custom.subsets(ordinated_matrix, list(c(1:4), c(5:10)))

## Splitting the ordinated matrix into three groups using row names
ordinated_matrix &lt;- matrix(data = rnorm(90), nrow = 10,
     dimnames = list(letters[1:10]))
custom.subsets(ordinated_matrix,
     list("A" = c("a", "b", "c", "d"), "B" = c("e", "f", "g", "h", "i", "j"),
          "C" = c("a", "c", "d", "f", "h")))

## Splitting the ordinated matrix into four groups using a dataframe
groups &lt;- as.data.frame(matrix(data = c(rep(1,5), rep(2,5), rep(c(1,2), 5)),
     nrow = 10, ncol = 2, dimnames = list(letters[1:10], c("g1", "g2"))))
custom.subsets(ordinated_matrix, groups)

## Splitting a matrix by clade
data(BeckLee_mat50)
data(BeckLee_tree)
custom.subsets(BeckLee_mat50, group = BeckLee_tree)


</code></pre>

<hr>
<h2 id='demo_data'>Demo datasets</h2><span id='topic+demo_data'></span>

<h3>Description</h3>

<p>A set six trait spaces with different groups and different dimensions.
</p>


<h3>Details</h3>

<p>The content of these datasets and the pipeline to build them is described in details in Guillerme et al 2020.
</p>

<ul>
<li> <p><code>beck</code> A palaeobiology study of mammals. The data is a 105 dimensions ordination (PCO) of the distances between 106 mammals based on discrete morphological characters.
</p>
</li>
<li> <p><code>wright</code> A palaeobiology study of crinoids. The data is a 41 dimensions ordination (PCO) of the distances between 42 crinoids based on discrete morphological characters.
</p>
</li>
<li> <p><code>marcy</code> A geometric morphometric study of gophers (rodents). The data is a 134 dimensions ordination (PCA) the Procrustes superimposition of landmarks from 454 gopher skulls.
</p>
</li>
<li> <p><code>hopkins</code> A geometric morphometric study of trilobites. The data is a 134 dimensions ordination (PCA) the Procrustes superimposition of landmarks from 46 trilobites cephala.
</p>
</li>
<li> <p><code>jones</code> An ecological landscape study. The data is a 47 dimensions ordination (PCO) of the Jaccard distances between 48 field sites based on species composition.
</p>
</li>
<li> <p><code>healy</code> A life history analysis of the pace of life in animals. The data is a 6 dimensions ordination (PCA) of 6 life history traits from 285 animal species.
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.6452">doi:10.1002/ece3.6452</a>
</p>


<h3>References</h3>

<p>Guillerme T, Puttick MN, Marcy AE, Weisbecker V. <b>2020</b> Shifting spaces: Which disparity or dissimilarity measurement best summarize occupancy in multidimensional spaces?. Ecol Evol. 2020;00:1-16. (doi:10.1002/ece3.6452)
</p>
<p>Beck, R. M., &amp; Lee, M. S. (2014). Ancient dates or accelerated rates? Morphological clocks and the antiquity of placental mammals. Proceedings of the Royal Society B: Biological Sciences, 281(1793), 20141278.
</p>
<p>Wright, D. F. (2017). Bayesian estimation of fossil phylogenies and the evolution of early to middle Paleozoic crinoids (Echinodermata). Journal of Paleontology, 91(4), 799-814.
</p>
<p>Marcy, A. E., Hadly, E. A., Sherratt, E., Garland, K., &amp; Weisbecker, V. (2016). Getting a head in hard soils: convergent skull evolution and divergent allometric patterns explain shape variation in a highly diverse genus of pocket gophers (Thomomys). BMC evolutionary biology, 16(1), 207.
</p>
<p>Hopkins, M.J. and Pearson, J.K., 2016. Non-linear ontogenetic shape change in Cryptolithus tesselatus (Trilobita) using three-dimensional geometric morphometrics. Palaeontologia Electronica, 19(3), pp.1-54.
</p>
<p>Jones, N. T., Germain, R. M., Grainger, T. N., Hall, A. M., Baldwin, L., &amp; Gilbert, B. (2015). Dispersal mode mediates the effect of patch size and patch connectivity on metacommunity diversity. Journal of Ecology, 103(4), 935-944.
</p>
<p>Healy, K., Ezard, T.H., Jones, O.R., Salguero-Gomez, R. and Buckley, Y.M., 2019. Animal life history is shaped by the pace of life and the distribution of age-specific mortality and reproduction. Nature ecology &amp; evolution, p.1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo_data)

## Loading the Beck and Lee 2014 demo data
demo_data$beck

## Loading the Wright 2017 demo data
demo_data$wright

## Loading the Marcy et al. 2015 demo data
demo_data$marcy

## Loading the Hopkins and Pearson 2016 demo data
demo_data$hopkins

## Loading the Jones et al. 2015 demo data
demo_data$jones

## Loading the Healy et al. 2019 demo data
demo_data$healy
</code></pre>

<hr>
<h2 id='disparity'>disparity</h2><span id='topic+disparity'></span>

<h3>Description</h3>

<p>An example of a <code>dispRity</code> object.
</p>


<h3>Format</h3>

<p>one <code>dispRity</code> object.
</p>


<h3>Details</h3>

<p>This matrix is based on the <code><a href="#topic+BeckLee">BeckLee</a></code> dataset and split into seven continuous subsets (<code><a href="#topic+chrono.subsets">chrono.subsets</a></code>).
It was bootstrapped 100 times (<code><a href="#topic+boot.matrix">boot.matrix</a></code>) with four rarefaction levels.
Disparity was calculated as the <code><a href="stats.html#topic+median">median</a></code> of the <code><a href="#topic+centroids">centroids</a></code> (<code><a href="#topic+dispRity">dispRity</a></code>).
</p>


<h3>See Also</h3>

<p>BeckLee_disparity BeckLee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Loading the data
data(BeckLee_mat99)
data(BeckLee_tree)
data(BeckLee_ages)

## Creating the 7 subsets
subsets &lt;- chrono.subsets(BeckLee_mat99, BeckLee_tree,
                          time = seq(from = 30, to = 90, by = 10),
                          method = "continuous", model = "ACCTRAN",
                          FADLAD = BeckLee_ages)

## Bootstrapping and rarefying
bootstraps &lt;- boot.matrix(subsets, bootstraps = 100,
                          rarefaction = c(20, 15, 10, 5))

## Calculating disparity
disparity &lt;- dispRity(bootstraps, metric = c(median, centroids))

## End(Not run)
</code></pre>

<hr>
<h2 id='dispRity'>Calculates disparity from a matrix.</h2><span id='topic+dispRity'></span>

<h3>Description</h3>

<p>Calculates disparity from a matrix, a list of matrices or subsets of a matrix, where the disparity metric can be user specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRity(
  data,
  metric,
  dimensions = NULL,
  ...,
  between.groups = FALSE,
  verbose = FALSE,
  tree = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity_+3A_data">data</code></td>
<td>
<p>A matrix or a <code>dispRity</code> object (see details).</p>
</td></tr>
<tr><td><code id="dispRity_+3A_metric">metric</code></td>
<td>
<p>A vector containing one to three functions. At least of must be a dimension-level 1 or 2 function (see details).</p>
</td></tr>
<tr><td><code id="dispRity_+3A_dimensions">dimensions</code></td>
<td>
<p>Optional, a vector of <code>numeric</code> value(s) or the proportion of the dimensions to keep.</p>
</td></tr>
<tr><td><code id="dispRity_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the metric.</p>
</td></tr>
<tr><td><code id="dispRity_+3A_between.groups">between.groups</code></td>
<td>
<p>A <code>logical</code> value indicating whether to run the calculations between groups (<code>TRUE</code>) or not (<code>FALSE</code> - default) or a <code>numeric</code> list of pairs of groups to run (see details).</p>
</td></tr>
<tr><td><code id="dispRity_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value indicating whether to be verbose or not.</p>
</td></tr>
<tr><td><code id="dispRity_+3A_tree">tree</code></td>
<td>
<p><code>NULL</code> (default) or an optional <code>phylo</code> or <code>multiPhylo</code> object to be attached to the data. If this argument is not null, it will be recycled by <code>metric</code> when possible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dispRity</code> object given to the <code>data</code> argument can be: a list of matrices (typically output from the functions <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> or <code><a href="#topic+custom.subsets">custom.subsets</a></code>), a bootstrapped matrix output from <code><a href="#topic+boot.matrix">boot.matrix</a></code>, a list of disparity measurements calculated from the <code>dispRity</code> function or a <code>matrix</code> object with rows as elements and columns as dimensions. In any of these cases, the data is considered as the multidimensional space and is not transformed (e.g. if ordinated with negative eigen values, no correction is applied to the matrix).
</p>
<p><code>metric</code> should be input as a vector of functions.
The functions are sorted and used by dimension-level from 3 to 1 (see <code><a href="#topic+dispRity.metric">dispRity.metric</a></code> and <code><a href="#topic+make.metric">make.metric</a></code>).
Typically dimension-level 3 functions take a <code>matrix</code> and output a <code>matrix</code>; dimension-level 2 functions take a <code>matrix</code> and output a <code>vector</code> and dimension-level 1 functions take a <code>matrix</code> or a <code>vector</code> and output a single value.
When more than one function is input, they are treated first by dimension-level (i.e. 3, 2 and finally 1).
Note that the functions can only take one metric of each dimension-level and thus can only take a maximum of three arguments!
</p>
<p>Some metric functions are built into the <code>dispRity</code> package: see <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>
For user specified metrics, please use <code><a href="#topic+make.metric">make.metric</a></code> to ensure that the metric will work.
</p>
<p><em>HINT:</em> if using more than three functions you can always create your own function that uses more than one function (e.g. <code>my_function &lt;- function(matrix) cor(var(matrix))</code> is perfectly valid and allows one to use two dimension-level 3 functions - the correlation of the variance-covariance matrix in this case).
</p>
<p>The <code>between.groups</code> argument runs the disparity between groups rather within groups. If <code>between.groups = TRUE</code>, the disparity will be calculated using the following inputs:
</p>

<ul>
<li><p> if the input is an output from <code><a href="#topic+custom.subsets">custom.subsets</a></code>, the series are run in a pairwise manner using <code>metric(matrix, matrix2)</code>. For example for a <code>custom.subset</code> contains 3 subsets m1, m2 and m3, the code loops through: <code>metric(m1, m2)</code>, <code>metric(m2, m3)</code> and <code>metric(m1, m3)</code> (looping through <code>list(c(1,2), c(2,3), c(3,1))</code>).
</p>
</li>
<li><p> if the input is an output from <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, the series are run in a paired series manner using <code>metric(matrix, matrix2)</code>. For example for a <code>chrono.subsets</code> contains 3 subsets m1, m2, m3 and m4, the code loops through: <code>metric(m1, m2)</code> and <code>metric(m2, m3)</code> (looping through <code>list(c(1,2), c(2,3), c(3,4))</code>).
</p>
</li></ul>

<p>In both cases it is also possible to specify the input directly by providing the list to loop through. For example using <code>between.groups = list(c(1,2), c(2,1), c(4,8))</code> will apply the <code>metric</code> to the 1st and 2nd subsets, the 2nd and first and the 4th and 8th (in that specific order).
</p>


<h3>Value</h3>

<p>This function outputs a <code>dispRity</code> object containing at least the following:
</p>
<table>
<tr><td><code>matrix</code></td>
<td>
<p>the multidimensional space (a list of <code>matrix</code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>A <code>list</code> containing the called arguments.</p>
</td></tr>
<tr><td><code>subsets</code></td>
<td>
<p>A <code>list</code> containing matrices pointing to the elements present in each subsets.</p>
</td></tr>
<tr><td><code>disparity</code></td>
<td>
<p>A <code>list</code> containing the disparity in each subsets.</p>
</td></tr>
</table>
<p>Use <a href="#topic+summary.dispRity">summary.dispRity</a> to summarise the <code>dispRity</code> object.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_mat50)

## Calculating the disparity as the sum of variances from a single matrix
sum_of_variances &lt;- dispRity(BeckLee_mat50, metric = c(sum, variances))
summary(sum_of_variances)
## Bootstrapping this value
bootstrapped_data &lt;- boot.matrix(BeckLee_mat50, bootstraps = 100)
dispRity(bootstrapped_data, metric = c(sum, variances))

## Calculating the disparity from a customised subset
## Generating the subsets
customised_subsets &lt;- custom.subsets(BeckLee_mat50,
     list(group1 = 1:(nrow(BeckLee_mat50)/2),
          group2 = (nrow(BeckLee_mat50)/2):nrow(BeckLee_mat50)))
## Bootstrapping the data
bootstrapped_data &lt;- boot.matrix(customised_subsets, bootstraps = 100)
## Calculating the sum of variances
sum_of_variances &lt;- dispRity(bootstrapped_data, metric = c(sum, variances))
summary(sum_of_variances)

## Calculating disparity with different metrics of different dimension-levels
## Disparity is calculated as the distribution of the variances in each
## dimension (output are distributions)
disparity_level2 &lt;- dispRity(BeckLee_mat50, metric = variances)
## Disparity is calculated as the mean of the variances in each dimension 
## (output are single values)
disparity_level1 &lt;- dispRity(disparity_level2, metric = mean)
## Both disparities have the same means but dimension-level 1 has no quantiles
summary(disparity_level2)
summary(disparity_level1)


</code></pre>

<hr>
<h2 id='dispRity.covar.projections'>Covar projection analyses wrapper</h2><span id='topic+dispRity.covar.projections'></span>

<h3>Description</h3>

<p>Wrapper function for a covar projection analyses on dispRity objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRity.covar.projections(
  data,
  type,
  base,
  sample,
  n,
  major.axis = 1,
  level = 0.95,
  output = c("position", "distance", "degree"),
  inc.base = FALSE,
  ...,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity.covar.projections_+3A_data">data</code></td>
<td>
<p>a <code>dispRity</code> object containing a <code>$covar</code> component(e.g. from <code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code>)</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_type">type</code></td>
<td>
<p>either <code>"groups"</code> for the projections between groups or <code>"elements"</code> for the projections of elements onto groups.</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_base">base</code></td>
<td>
<p>optional, a specific group to project the elements or the groups onto or a list of pairs of groups to compare (see <code>between.groups</code> argument in <code><a href="#topic+dispRity">dispRity</a></code>). If left empty, the groups are projected onto each other in a pairwise manner and the elements are projected onto their respective groups.</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_sample">sample</code></td>
<td>
<p>optional, one or more specific posterior sample IDs (is ignored if n is used) or a function to summarise all axes.</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_n">n</code></td>
<td>
<p>optional, a random number of covariance matrices to sample (if left empty, all are used).</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_major.axis">major.axis</code></td>
<td>
<p>which major axis to use (default is <code>1</code>; see <code><a href="#topic+axis.covar">axis.covar</a></code> for more details).</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_level">level</code></td>
<td>
<p>the confidence interval to estimate the major axis (default is <code>0.95</code>; see <code><a href="#topic+axis.covar">axis.covar</a></code> for more details)).</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_output">output</code></td>
<td>
<p>which values to output from the projection. By default, the three values <code>c("position", "distance", "degree")</code> are used to respectively output the projection, rejection and angle values (see <code><a href="#topic+projections">projections</a></code> for more details). The argument <code>"orthogonality"</code> can also be added to this vector.</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_inc.base">inc.base</code></td>
<td>
<p>logical, when using <code>type = "elements"</code> with a supplied <code>base</code> argument, whether to also calculate the projections for the base group (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_...">...</code></td>
<td>
<p>any optional arguments to pass to <code><a href="#topic+projections">projections</a></code> (such as <code>centre</code> or <code>abs</code>). <em>NOTE that this function uses by default <code>centre = TRUE</code> and <code>abs = TRUE</code> which are not the defaults for <code><a href="#topic+projections">projections</a></code></em>.</p>
</td></tr>
<tr><td><code id="dispRity.covar.projections_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to be verbose (<code>TRUE</code>) or not (<code>FALSE</code>, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effectively, the wrapper runs either of the following function (simplified here):
</p>

<ul>
<li><p> if <code>type = "groups"</code>: <code>dispRity(data, metric = as.covar(projections.between), between.groups = TRUE, )</code> for the projections group in <code>data</code> onto each other. 
</p>
</li>
<li><p> if <code>type = "elements"</code>: <code>dispRity(data, metric = as.covar(projections), ...)</code> for the projections of each element in <code>data</code> onto their main axis.
</p>
</li></ul>

<p>If <code>base</code> is specified:
</p>

<ul>
<li> <p><code>type = "groups"</code> will run pairs elements each subset and <code>base</code> (instead of the full pairwise analyses).
</p>
</li>
<li> <p><code>type = "elements"</code> will run the projection of each subset onto the major axis from <code>base</code> rather than its own.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>list</code> of class <code>"dispRity"</code> and <code>"projection"</code> which contains <code>dispRity</code> objects corresponding to each projection value from <code>output</code>.
The elements of the <code>list</code> can be accessed and analysed individually by selecting them by name (e.g. <code>output$position</code>) or by ID (e.g. <code>output[[1]]</code>).
Alternatively, the list can be summarised and plotted using <code><a href="#topic+summary.dispRity">summary.dispRity</a></code> <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projections">projections</a></code> <code><a href="#topic+projections.between">projections.between</a></code> <code><a href="#topic+axis.covar">axis.covar</a></code> <code><a href="#topic+dispRity">dispRity</a></code> <code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(charadriiformes)

## Creating a dispRity object with a covar component
my_covar &lt;-MCMCglmm.subsets(
                 data       = charadriiformes$data,
                 posteriors = charadriiformes$posteriors,
                 tree       = charadriiformes$tree,
                 group      = MCMCglmm.levels(
                                 charadriiformes$posteriors)[1:4],
                 rename.groups = c("gulls", "plovers", "sandpipers", "phylo"))

## Running a projection analyses between groups (on 100 random samples)
between_groups &lt;- dispRity.covar.projections(my_covar, type = "groups", base = "phylo", n = 100)
## Summarising the results
summary(between_groups)

## Measuring the projection of the elements on their own average major axis
elements_proj &lt;- dispRity.covar.projections(my_covar, type = "elements", sample = mean,
                                            output = c("position", "distance"))
## Visualising the results
plot(elements_proj)

## Visualising the correlation
plot(elements_proj, speicfic.args = list(correlation.plot = c("position", "distance")))

</code></pre>

<hr>
<h2 id='dispRity.fast'>Fast dispRity</h2><span id='topic+dispRity.fast'></span>

<h3>Description</h3>

<p>Fast disparity calculations. THIS FUNCTION IS LESS SAFE TO USE THAN <code><a href="#topic+dispRity">dispRity</a></code> (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRity.fast(group, space, metric, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity.fast_+3A_group">group</code></td>
<td>
<p>a logical vector for grouping</p>
</td></tr>
<tr><td><code id="dispRity.fast_+3A_space">space</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="dispRity.fast_+3A_metric">metric</code></td>
<td>
<p>a metric dispRity style (up to two levels)</p>
</td></tr>
<tr><td><code id="dispRity.fast_+3A_...">...</code></td>
<td>
<p>any additional arguments to be passed to <code>metric</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>IN DOUBT, USE <code><a href="#topic+dispRity">dispRity</a></code> INSTEAD OF THIS FUNCTION.</em>
This function should only be used in very specific cases requiring advanced optimisation or embedded customised functions.
This function is simply applying <code>metric(space[group,])</code> for each group and returns a list of results.
It does not check the validity of the data, metric and groups.
It does not handle specific data (e.g. multiple matrices), specific metrics (e.g. no optional arguments), does not produce meaningful error messages and does not intake nor returns a dispRity object.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random space
space &lt;- matrix(rnorm(25), 5, 5)

## A metric
metric &lt;- c(sum, variances)

## A group of four observations
group &lt;- c(TRUE, TRUE, TRUE, TRUE, FALSE)

## The disparity
dispRity.fast(group, space, metric)


</code></pre>

<hr>
<h2 id='dispRity.metric'>Disparity metrics</h2><span id='topic+dispRity.metric'></span><span id='topic+dimension.level3.fun'></span><span id='topic+dimension.level2.fun'></span><span id='topic+dimension.level1.fun'></span><span id='topic+between.groups.fun'></span><span id='topic+variances'></span><span id='topic+ranges'></span><span id='topic+centroids'></span><span id='topic+mode.val'></span><span id='topic+ellipsoid.volume'></span><span id='topic+ellipse.volume'></span><span id='topic+edge.length.tree'></span><span id='topic+convhull.surface'></span><span id='topic+convhull.volume'></span><span id='topic+diagonal'></span><span id='topic+ancestral.dist'></span><span id='topic+pairwise.dist'></span><span id='topic+span.tree.length'></span><span id='topic+n.ball.volume'></span><span id='topic+radius'></span><span id='topic+neighbours'></span><span id='topic+displacements'></span><span id='topic+quantiles'></span><span id='topic+func.eve'></span><span id='topic+func.div'></span><span id='topic+angles'></span><span id='topic+deviations'></span><span id='topic+group.dist'></span><span id='topic+point.dist'></span><span id='topic+projections'></span><span id='topic+projections.tree'></span><span id='topic+projections.between'></span><span id='topic+disalignment'></span><span id='topic+roundness'></span>

<h3>Description</h3>

<p>Different implemented disparity metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimension.level3.fun(matrix, ...)
dimension.level2.fun(matrix, ...)
dimension.level1.fun(matrix, ...)
between.groups.fun(matrix, matrix2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity.metric_+3A_matrix">matrix</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="dispRity.metric_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the function. Usual optional arguments are <code>method</code> for specifying the method for calculating distance passed to <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (e.g. <code>method = "euclidean"</code> - default - or <code>method = "manhattan"</code>) or <code>k.root</code> to scale the result using the <code class="reqn">kth</code> root. See details below for available optional arguments for each function.</p>
</td></tr>
<tr><td><code id="dispRity.metric_+3A_matrix2">matrix2</code></td>
<td>
<p>Optional, a second matrix for metrics between groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are inbuilt functions for calculating disparity. See <code><a href="#topic+make.metric">make.metric</a></code> for details on <code>dimension.level3.fun</code>, <code>dimension.level2.fun</code>, <code>dimension.level1.fun</code> and <code>between.groups.fun</code>. The dimensions levels (1, 2 and 3) can be seen as similar to ranks in linear algebra.
</p>
<p>The currently implemented dimension-level 1 metrics are:
</p>

<ul>
<li> <p><code>convhull.volume</code>: calculates the convex hull hypervolume of a matrix (calls <code><a href="geometry.html#topic+convhulln">convhulln</a>(x, options = "FA")$vol</code>).
</p>

<ul>
<li><p> Both <code>convhull</code> functions call the <code><a href="geometry.html#topic+convhulln">convhulln</a></code> function with the <code>"FA"</code> option (computes total area and volume).
</p>
</li>
<li><p> WARNING: both <code>convhull</code> functions can be computationally intensive above 10 dimensions!
</p>
</li></ul>

</li>
<li> <p><code>convhull.surface</code>: calculates the convex hull hypersurface of a matrix (calls <code><a href="geometry.html#topic+convhulln">convhulln</a>(x, options = "FA")$area</code>).
</p>
</li>
<li> <p><code>diagonal</code>: calculates the longest distance in the ordinated space.
</p>

<ul>
<li><p> WARNING: This function is the generalisation of Pythagoras' theorem and thus <b>works only if each dimensions are orthogonal to each other</b>.
</p>
</li></ul>

</li>
<li> <p><code>ellipsoid.volume</code>: calculates the ellipsoid volume of a matrix. This function tries to determine the nature of the input matrix and uses one of these following methods to calculate the volume. You can always specify the method using <code>method = "my_choice"</code> to overrun the automatic method choice.
</p>

<ul>
<li> <p><code>"eigen"</code>: this method directly calculates the eigen values from the input matrix (using <code><a href="base.html#topic+eigen">eigen</a></code>). This method is automatically selected if the input matrix is &quot;distance like&quot; (i.e. square with two mirrored triangles and a diagonal).
</p>
</li>
<li> <p><code>"pca"</code>: this method calculates the eigen values as the sum of the variances of the matrix (<code>abs(apply(var(matrix),2, sum))</code>). This is automatically selected if the input matrix is NOT &quot;distance like&quot;. Note that this method is faster than <code>"eigen"</code> but only works if the input matrix is an ordinated matrix from a PCA, PCO, PCoA, NMDS or MDS.
</p>
</li>
<li> <p><code>"axes"</code>: this method calculates the actual semi axes length using the input matrix. It is never automatically selected. By default this method calculates the length of the major axes based on the 0.95 confidence interval ellipse but this can be modified by providing additional arguments from <code><a href="#topic+axis.covar">axis.covar</a></code>.
</p>
</li>
<li> <p><code>&lt;a numeric vector&gt;</code>: finally, you can directly provide a numeric vector of eigen values. This method is never automatically selected and overrides any other options.
</p>
</li></ul>

</li>
<li> <p><code>func.div</code>: The functional divergence (Villeger et al. 2008): the ratio of deviation from the centroid (this is similar to <code>FD::dbFD()$FDiv</code>).
</p>
</li>
<li> <p><code>func.eve</code>: The functional evenness (Villeger et al. 2008): the minimal spanning tree distances evenness (this is similar to <code>FD::dbFD()$FEve</code>). If the matrix used is not a distance matrix, the distance method can be passed using, for example <code>method = "euclidean"</code> (default).
</p>
</li>
<li> <p><code>mode.val</code>: calculates the modal value of a vector.
</p>
</li>
<li> <p><code>n.ball.volume</code>: calculate the volume of the minimum n-ball (if <code>sphere = TRUE</code>) or of the ellipsoid (if <code>sphere = FALSE</code>).
</p>
</li>
<li> <p><code>roundness</code>: calculate the roundness of an elliptical representation of a variance-covariance matrix as the integral of the ranked distribution of the major axes. A value of 1 indicates a sphere, a value between 1 and 0.5 indicates a more pancake like representation and a value between 0.5 and 0 a more cigar like representation. You can force the variance-covariance calculation by using the option <code>vcv = TRUE</code> (default) that will calculate the variance-covariance matrix if the input is not one.
</p>
</li></ul>

<p>See also <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code>, <code><a href="base.html#topic+sum">sum</a></code> or <code><a href="base.html#topic+prod">prod</a></code> for commonly used summary metrics.
</p>
<p>The currently implemented dimension-level 2 metrics are:
</p>

<ul>
<li> <p><code>ancestral.dist</code>: calculates the distance between each elements coordinates in the matrix and their ancestors' coordinates (if <code>to.root = FALSE</code>; default) or to the root coordinates (if <code>to.root = TRUE</code>) for a given <code>tree</code>. The distance is calculate as Euclidean by default but can be changed through the <code>methods</code> argument (<code>method = "euclidean"</code>; default). Note that the matrix must contain data for both tips and nodes in the <code>tree</code>, otherwise you must provide a matrix to the argument <code>reference.data</code> that contains them. Note that if the function is used in <code><a href="#topic+dispRity">dispRity</a></code>, both the <code>tree</code> and <code>reference.data</code> can be automatically recycled from the <code>dispRity</code> object (if present).
</p>
</li>
<li> <p><code>angles</code>: calculates the angles of the main axis of variation per dimension in a <code>matrix</code>. The angles are calculated using the least square algorithm from the <code><a href="stats.html#topic+lm">lm</a></code> function. The unit of the angle can be changed through the <code>unit</code> argument (either <code>"degree"</code> (default), <code>radian</code> or <code>slope</code>) and a base angle to measure the angle from can be passed through the <code>base</code> argument (by default <code>base = 0</code>, measuring the angle from the horizontal line (note that the <code>base</code> argument has to be passed in the same unit as <code>unit</code>). When estimating the slope through <code><a href="stats.html#topic+lm">lm</a></code>, you can use the option <code>significant</code> to only consider significant slopes (<code>TRUE</code>) or not (<code>FALSE</code> - default).
</p>
</li>
<li> <p><code>centroids</code>: calculates the distance between each row and the centroid of the matrix (Laliberte 2010). This function can take an optional arguments <code>centroid</code> for defining the centroid (if missing (default), the centroid of the matrix is used). This argument can be either a subset of coordinates matching the matrix's dimensions (e.g. <code>c(0, 1, 2)</code> for a matrix with three columns) or a single value to be the coordinates of the centroid (e.g. <code>centroid = 0</code> will set the centroid coordinates to <code>c(0, 0, 0)</code> for a three dimensional matrix). NOTE: distance is calculated as <code>"euclidean"</code> by default, this can be changed using the <code>method</code> argument.
</p>
</li>
<li> <p><code>deviations</code>: calculates the minimal Euclidean distance between each element in and the hyperplane (or line if 2D, or a plane if 3D). You can specify equation of hyperplane of <em>d</em> dimensions in the <code class="reqn">intercept + ax + by + ... + nd = 0</code> format. For example the line <code class="reqn">y = 3x + 1</code> should be entered as <code>c(1, 3, -1)</code> or the plane <code class="reqn">x + 2y - 3z = 44</code> as <code>c(44, 1, 2, -3)</code>. If missing the <code>hyperplane</code> (default) is calculated using a least square regression using a gaussian <code><a href="stats.html#topic+glm">glm</a></code>. Extra arguments can be passed to <code><a href="stats.html#topic+glm">glm</a></code> through <code>...</code>. When estimating the hyperplane, you can use the option <code>significant</code> to only consider significant slopes (<code>TRUE</code>) or not (<code>FALSE</code> - default).
</p>
</li>
<li> <p><code>displacements</code>: calculates the ratio between the distance to the centroid (see <code>centroids</code> above) and the distance from a reference (by default the origin of the space). The reference can be changed through the <code>reference</code> argument. NOTE: distance is calculated as <code>"euclidean"</code> by default, this can be changed using the <code>method</code> argument.
</p>
</li>
<li> <p><code>edge.length.tree</code>: calculates the edge length from a given tree for each elements present in the matrix. Each edge length is either measured between the element and the root of the tree (<code>to.root = TRUE</code> ; default) or between the element and its last ancestor (<code>to.root = FALSE</code>))
</p>
</li>
<li> <p><code>neighbours</code>: calculates the distance to a neighbour (Foote 1990). By default this is the distance to the nearest neighbour (<code>which = min</code>) but can be set to any dimension level - 1 function (e.g. <code>which = mean</code> gives the distance to the most average neighbour). NOTE: distance is calculated as <code>"euclidean"</code> by default, this can be changed using the <code>method</code> argument. 
</p>
</li>
<li> <p><code>pairwise.dist</code>: calculates the pairwise distance between elements - calls <code>vegdist(matrix, method = method, diag = FALSE, upper = FALSE, ...)</code>. The distance type can be changed via the <code>method</code> argument (see <code><a href="vegan.html#topic+vegdist">vegdist</a></code> - default: <code>method = "euclidean"</code>). This function outputs a vector of pairwise comparisons in the following order: d(A,B), d(A,C), d(B,C) for three elements A, B and C. NOTE: distance is calculated as <code>"euclidean"</code> by default, this can be changed using the <code>method</code> argument.
</p>
</li>
<li> <p><code>projections</code>: projects each element on a vector defined as (<code>point1</code>, <code>point2</code>) and measures some aspect of this projection. The different aspects that can be measured are:
</p>

<ul>
<li> <p><code>measure = "position"</code> (default), the distance of each element <em>on</em> the vector (<code>point1</code>, <code>point2</code>). Negative values means the element projects on the opposite direction of the vector (<code>point1</code>, <code>point2</code>).
</p>
</li>
<li> <p><code>measure = "distance"</code>, the euclidean distance of each element <em>from</em> the vector (<code>point1</code>, <code>point2</code>).
</p>
</li>
<li> <p><code>measure = "degree"</code>, the angle between the vector (<code>point1</code>, <code>point2</code>) and any vector (<code>point1</code>, <code>element</code>) in degrees.
</p>
</li>
<li> <p><code>measure = "radian"</code>, the angle between the vector (<code>point1</code>, <code>point2</code>) and any vector (<code>point1</code>, <code>element</code>) in radians.
</p>
</li>
<li> <p><code>measure = "orthogonality"</code>, the angle between the vector (<code>point1</code>, <code>point2</code>) and any vector (<code>point1</code>, <code>element</code>) expressed in right angle ranging between 0 (non angle) and 1 (right angle).
</p>
</li></ul>

<p>By default, <code>point1</code> is the centre of the space (coordinates <code>0, 0, 0, ...</code>) and <code>point2</code> is the centroid of the space (coordinates <code>colMeans(matrix)</code>). Coordinates for <code>point1</code> and <code>point2</code> can be given as a single value to be repeated (e.g. <code>point1 = 1</code> is translated into <code>point1 = c(1, 1, ...)</code>) or a specific set of coordinates.
Furthermore, by default, the space is scaled so that the vector (<code>point1</code>, <code>point2</code>) becomes the unit vector (distance (<code>point1</code>, <code>point2</code>) is set to 1; option <code>scale = TRUE</code>; default). You can use the unit vector of the space using the option <code>scale = FALSE</code>.
Other options include the centering of the projections on 0.5 (<code>centre = TRUE</code>; default is set to <code>FALSE</code>) ranging the projection onto the vector (<code>point1</code>, <code>point2</code>) between -1 and 1 (higher or lower values project beyond the vector); and whether to output the projection values as absolute values (<code>abs = FALSE</code>; default is set to <code>FALSE</code>). These two last options only affect the results from <code>measure = "position"</code>.
</p>
</li>
<li> <p><code>projections.tree</code>: calculates the <code>projections</code> metric but drawing the vectors from a phylogenetic tree. This metric can intake any argument from <code>projections</code> (see above) but for <code>point1</code> and <code>point2</code> that are replaced by the argument <code>type</code>. <code>type</code> is a <code>vector</code> or a <code>list</code> of two elements that designates which vector to draw and can be any pair of the following options (the first element being the origin of the vector and the second where the vector points to):
</p>

<ul>
<li> <p><code>"root"</code>: the root of the tree (the first element in tree$node.label);
</p>
</li>
<li> <p><code>"ancestor"</code>: the element's most recent ancestor;
</p>
</li>
<li> <p><code>"tips"</code>: the centroid of the tips;
</p>
</li>
<li> <p><code>"nodes"</code>: the centroid of all the nodes;
</p>
</li>
<li> <p><code>"livings"</code>: the centroid of the tips the furthest from the root;
</p>
</li>
<li> <p><code>"fossils"</code>: the centroid of all the tips that are not the furthest from the root;
</p>
</li>
<li><p> any numeric values that can be interpreted as <code>point1</code> and <code>point2</code> in <code><a href="#topic+projections">projections</a></code>;
</p>
</li>
<li><p> or a user defined function that with the inputs <code>matrix</code> and <code>tree</code> and <code>row</code> (the element's ID, i.e. the row number in <code>matrix</code>). 
</p>
</li></ul>

<p><em>NOTE:</em> the elements to calculate the origin and end points of the vector are calculated by default on the provided input <code>matrix</code> which can be missing data from the tree if used with <code><a href="#topic+custom.subsets">custom.subsets</a></code> or <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>. You can always provide the full matrix using the option <code>reference.data = my_matrix</code>. Additional arguments include any arguments to be passed to <code><a href="#topic+projections">projections</a></code> (e.g. <code>centre</code> or <code>abs</code>).
</p>
</li>
<li> <p><code>quantiles</code>: calculates the quantile range of each axis of the matrix. The quantile can be changed using the <code>quantile</code> argument (default is <code>quantile = 95</code>, i.e. calculating the range on each axis that includes 95% of the data). An optional argument, <code>k.root</code>, can be set to <code>TRUE</code> to scale the ranges by using its <code class="reqn">kth</code> root (where <code class="reqn">k</code> are the number of dimensions). By default, <code>k.root = FALSE</code>.
</p>
</li>
<li> <p><code>radius</code>: calculates a distance from the centre of each axis. The <code>type</code> argument is the function to select which distance to calculate. By default <code>type = max</code> calculates the maximum distance between the elements and the centre for each axis (i.e. the radius for each dimensions)
</p>
</li>
<li> <p><code>ranges</code>: calculates the range of each axis of the matrix (Wills 2001). An optional argument, <code>k.root</code>, can be set to <code>TRUE</code> to scale the ranges by using its <code class="reqn">kth</code> root (where <code class="reqn">k</code> are the number of dimensions). By default, <code>k.root = FALSE</code>.
</p>
</li>
<li> <p><code>variances</code>: calculates the variance of each axis of the matrix (Wills 2001). This function can also take the <code>k.root</code> optional argument described above.
</p>
</li>
<li> <p><code>span.tree.length</code>: calculates the length of the minimum spanning tree (see <code><a href="vegan.html#topic+spantree">spantree</a></code>). This function can get slow with big matrices. To speed it up, one can directly use distance matrices as the multidimensional space.
</p>
</li></ul>

<p>The currently implemented between.groups metrics are:
</p>

<ul>
<li> <p><code>disalignment</code>: calculates the rejection of a point from <code>matrix</code> from the major axis of <code>matrix2</code>. Options are, <code>axis</code> to choose which major axis to reject from (default is <code>axis = 1</code>); <code>level</code> for the ellipse' confidence interval (to calculate the axis) (default is <code>level = 0.95</code>) and <code>point.to.reject</code>, a numeric value for designating which point in <code>matrix</code> to use or a function for calculating it (default is <code>point.to.reject = colMeans</code> for <code>matrix</code>'s centroid).
</p>
</li>
<li> <p><code>group.dist</code>: calculates the distance between two groups (by default, this is the minimum euclidean vector norm distance between groups). Negative distances are considered as 0. This function must intake two matrices (<code>matrix</code> and <code>matrix2</code>) and the quantiles to consider. For the minimum distance between two groups, the 100th quantiles are considered (default: <code>probs = c(0,1)</code>) but this can be changed to any values (e.g. distance between the two groups accounting based on the 95th CI: <code>probs = c(0.025, 0.975)</code>; distance between centroids: <code>probs = c(0.5)</code>, etc...). This function is the linear algebra equivalent of the <code>hypervolume::hypervolume_distance</code> function.
</p>
</li>
<li> <p><code>point.dist</code>: calculates the distance between <code>matrix</code> and a point calculated from <code>matrix2</code>. By default, this point is the centroid of <code>matrix2</code>. This can be changed by passing a function to be applied to <code>matrix2</code> through the <code>point</code> argument (for example, for the centroid: <code>point.dist(..., point = colMeans)</code>). NOTE: distance is calculated as <code>"euclidean"</code> by default, this can be changed using the <code>method</code> argument.
</p>
</li>
<li> <p><code>projections.between</code>: calculates the projection of the major axis between two matrices. It allows the same arguments as <code>projections</code>. This function measures the major axis from both input matrices, centre their origins and projects the end of the vector of <code>matrix</code> onto the vector from <code>matrix2</code>. Which axis to measure can be changed with the option <code>axis</code> (for the major axis, <code>axis = 1</code>; default) and the confidence interval can be changed using <code>level</code> (for the 95 confidence interval, <code>level = 0.95</code>; default - see <code><a href="#topic+axis.covar">axis.covar</a></code> for more details).
</p>
</li></ul>

<p>When used in the <code><a href="#topic+dispRity">dispRity</a></code> function, optional arguments are declared after the <code>metric</code> argument: for example
<code>dispRity(data, metric = centroids, centroid = 0, method = "manhattan")</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Donohue I, Petchey OL, Montoya JM, Jackson AL, McNally L, Viana M, Healy K, Lurgi M, O'Connor NE, Emmerson MC. 2013. On the dimensionality of ecological stability. Ecology letters. 16(4):421-9.
</p>
<p>Lalibert'e E, Legendre P. 2010. A distance-based framework for measuring functional diversity from multiple traits. Ecology, 91(1), pp.299-305.
</p>
<p>Vill'eger S, Mason NW, Mouillot D. 2008. New multidimensional functional diversity indices for a multifaceted framework in functional ecology. Ecology. 89(8):2290-301.
</p>
<p>Wills MA. 2001. Morphological disparity: a primer. In Fossils, phylogeny, and form (pp. 55-144). Springer, Boston, MA.
</p>
<p>Foote, M. 1990. Nearest-neighbor analysis of trilobite morphospace. Systematic Zoology, 39(4), pp.371-382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code> and <code><a href="#topic+make.metric">make.metric</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random matrix
dummy_matrix &lt;- matrix(rnorm(90), 9, 10)

## ancestral.dist
## A random tree with node labels
rand_tree &lt;- rtree(5) ; rand_tree$node.label &lt;- paste0("n", 1:4)
## Adding the tip and node names to the matris
rownames(dummy_matrix) &lt;- c(rand_tree$tip.label, rand_tree$node.label)
## Calculating the distances to the ancestors
ancestral.dist(dummy_matrix, tree = rand_tree)
## Calculating the manhattan distances to the root
ancestral.dist(dummy_matrix, tree = rand_tree,
               to.root = TRUE, method = "manhattan")

## angles
## The angles in degrees of each axis
angles(dummy_matrix)
## The angles in slope from the 1:1 slope (Beta = 1)
angles(dummy_matrix, unit = "slope", base = 1)

## centroids
## Distances between each row and centroid of the matrix
centroids(dummy_matrix)
## Distances between each row and an arbitrary point
centroids(dummy_matrix, centroid = c(1,2,3,4,5,6,7,8,9,10))
## Distances between each row and the origin
centroids(dummy_matrix, centroid = 0)

## convhull.surface
## Making a matrix with more elements than dimensions (for convhull)
thinner_matrix &lt;- matrix(rnorm(90), 18, 5)
## Convex hull hypersurface of a matrix
convhull.surface(thinner_matrix)

## convhull.volume
## Convex hull volume of a matrix
convhull.volume(thinner_matrix)

## deviations
## The deviations from the least square hyperplane
deviations(dummy_matrix)
## The deviations from the plane between the x and y axis
deviations(dummy_matrix, hyperplane = c(0,1,1,0,0,0,0,0,0,0,0))

## diagonal
## Matrix diagonal
diagonal(dummy_matrix) # WARNING: only valid if the dimensions are orthogonal

## disalignment
## Two dummy matrices
matrix_1 &lt;- matrix(rnorm(16), 4, 4)
matrix_2 &lt;- matrix(rnorm(16), 4, 4)
## Measuring the disalignment of matrix_1 from matrix_2
disalignment(matrix_1, matrix_2)
## Same but using the 2nd major axis of the 0.75 CI ellipse
## from matrix_2 and the first point from matrix_1.
disalignment(matrix_1, matrix_2,
             axis = 2, level = 0.75,
             point.to.reject = 1)

## displacements
## displacement ratios (from the centre)
displacements(dummy_matrix)
## displacement ratios (from an arbitrary point)
displacements(dummy_matrix, reference = c(1,2,3,4,5,6,7,8,9,10))
## displacement ratios from the centre (manhattan distance)
displacements(dummy_matrix, method = "manhattan")

## edge.length.tree
## Making a dummy tree with node labels
dummy_tree &lt;- makeNodeLabel(rtree((nrow(dummy_matrix)/2)+1))
## Naming the elements in the matrix
named_matrix &lt;- dummy_matrix
rownames(named_matrix) &lt;- c(dummy_tree$tip.label,
                            dummy_tree$node.label)
## The total edge length of each element in the matrix (to the root)
edge.length.tree(named_matrix, tree = dummy_tree)

## The edge lengths for each edge leading to the elements in the matrix
edge.length.tree(named_matrix, tree = dummy_tree, to.root = FALSE)

## ellipsoid.volume
## Ellipsoid volume of a matrix
ellipsoid.volume(dummy_matrix)
## Calculating the same volume with provided eigen values
ordination &lt;- prcomp(dummy_matrix)
## Calculating the ellipsoid volume by providing your own eigen values
ellipsoid.volume(ordination$x, method = ordination$sdev^2)

## func.div
## Functional divergence
func.div(dummy_matrix)

## func.eve
## Functional evenness
func.eve(dummy_matrix) 
## Functional evenness (based on manhattan distances)
func.eve(dummy_matrix, method = "manhattan")

## group.dist
## The distance between groups
dummy_matrix2 &lt;- matrix(runif(40, min = 2, max = 4), 4, 10)
## The minimum distance between both groups
group.dist(dummy_matrix, dummy_matrix2)
## The distance between both groups' centroids
group.dist(dummy_matrix, dummy_matrix2, probs = 0.5)
## The minimum distance between the 50% CI of each group
group.dist(dummy_matrix, dummy_matrix2, probs = c(0.25, 0.75))

## mode.val
## Modal value of a vector
mode.val(dummy_matrix)

## neighbours
## The nearest neighbour euclidean distances
neighbours(dummy_matrix)
## The furthest neighbour manhattan distances
neighbours(dummy_matrix, which = max, method = "manhattan")

## pairwise.dist
## The pairwise distance
pairwise.dist(dummy_matrix)
## The average squared pairwise distance
mean(pairwise.dist(dummy_matrix)^2)
## equal to:
# geiger::disparity(data = dummy_matrix)

## point.dist
## The distances from the rows dummy_matrix
## to the centroids of dummy_matrix2
point.dist(dummy_matrix, dummy_matrix2)
## The average distances from dummy_matrix
## to the centroids of dummy_matrix2
mean(point.dist(dummy_matrix, dummy_matrix2))
## The manhattan distance from the rows dummy_matrix
## to the standard deviation of dummy_matrix2
point.dist(dummy_matrix, dummy_matrix2, point = sd, method = "manhattan")

## projections
## The distances on the vector defined from the centre of
## the matrix to its centroid (default)
projections(dummy_matrix)
## The distances from the vector defined from the third
## element of the matrix to the point of coordinated
## c(1,1,1, ...) the matrix to its centroid (default)
projections(dummy_matrix, measure = "distance",
            point1 = dummy_matrix[3, ],
            point2 = 1)

## projections.tree
## Making a dummy tree with node labels
dummy_tree &lt;- makeNodeLabel(rtree((nrow(dummy_matrix)/2)+1))
## Naming the elements in the matrix
named_matrix &lt;- dummy_matrix
rownames(named_matrix) &lt;- c(dummy_tree$tip.label,
                            dummy_tree$node.label)
## The projection on the vector defined from the root of
## the tree to the ancestor of each element in the matrix
projections.tree(named_matrix, dummy_tree,
                  type = c("root", "ancestor"))
## The rejection from the vector defined from the centroid
## of the nodes to the centroids of the tips
projections.tree(named_matrix, dummy_tree,
                  type = c("nodes", "tips"),
                  measure = "distance")
## A user function that define coordinates based on the 
## centroid of the three first nodes
user.fun &lt;- function(matrix, tree, row = NULL) {
     return(colMeans(matrix[tree$node.label[1:3], ]))
}
## The projection on the vector defined by the coordinates
## 0,0,0 and a user defined function
projections.tree(named_matrix, dummy_tree,
                  type = c(0, user.fun))

## projections.between
## Two dummy matrices
matrix_1 &lt;- matrix(rnorm(16), 4, 4)
matrix_2 &lt;- matrix(rnorm(16), 4, 4)
## Projecting the major axis of matrix_2 onto the one from matrix_1
projections.between(matrix_1, matrix_2)
## Projecting both second major 0.75 axes
## and getting the rejections (see projections() for option details)
projections.between(matrix_1, matrix_2,
                    measure = "distance",
                    axis = 2, level = 0.75)

## quantiles
## The 95 quantiles
quantiles(dummy_matrix)
## The 100 quantiles (which are equal to the ranges)
quantiles(dummy_matrix, quantile = 100) == ranges(dummy_matrix) # All TRUE

## radius
## The maximal radius of each axis (maximum distance from centre of each axis)
radius(dummy_matrix)

## ranges
## ranges of each column in a matrix
ranges(dummy_matrix)
## ranges of each column in the matrix corrected using the kth root
ranges(dummy_matrix, k.root = TRUE)

## roundness
## calculating the variance-covariance of the dummy_matrix
vcv &lt;- var(dummy_matrix)
## calculating the roundness of it
roundness(vcv)
## calculating the roundness of the dummy matrix by calculating the vcv
roundness(dummy_matrix, vcv = TRUE)

## span.tree.length
## Minimum spanning tree length (default)
span.tree.length(dummy_matrix)
## Minimum spanning tree length from a distance matrix (faster)
distance &lt;- as.matrix(dist(dummy_matrix))
span.tree.length(distance)
## Minimum spanning tree length based on Manhattan distance
span.tree.length(dummy_matrix, method = "manhattan")
span.tree.length(as.matrix(dist(dummy_matrix, method = "manhattan"))) # Same

## variances
## variances of a each column in the matrix
variances(dummy_matrix)
## variances of a each column in the matrix corrected using the kth root
variances(dummy_matrix, k.root = TRUE)


</code></pre>

<hr>
<h2 id='dispRity.per.group'>Disparity in different groups.</h2><span id='topic+dispRity.per.group'></span>

<h3>Description</h3>

<p>Performs a disparity analysis between groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRity.per.group(data, group, metric = c(median, centroids), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity.per.group_+3A_data">data</code></td>
<td>
<p>An ordinated <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="dispRity.per.group_+3A_group">group</code></td>
<td>
<p>A <code>list</code> of row numbers for each group.</p>
</td></tr>
<tr><td><code id="dispRity.per.group_+3A_metric">metric</code></td>
<td>
<p>A vector containing one to three functions (default = <code>c(median, centroids)</code>) (see <code><a href="#topic+dispRity">dispRity</a></code> for details).</p>
</td></tr>
<tr><td><code id="dispRity.per.group_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code> and <code><a href="#topic+dispRity">dispRity</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is a wrapper function that allows users to run a basic disparity among groups analysis without too much effort. 
As such it has a lot of defaults described in the functions that make up the analysis. 
See <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code> for more details of the defaults used in each of these functions.
Note that any of these defaults can be changed within the <code>disparity.through.time</code> function.
</p>


<h3>Value</h3>

<p>A <code>dispRity</code> object that can be passed to <code>summary</code> or <code>plot</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_mat50)

## Run a simple disparity per group analysis comparing stem and crown mammals
result &lt;- dispRity.per.group(BeckLee_mat50, list(crown = c(16, 19:41, 45:50),
                             stem = c(1:15, 17:18, 42:44)))
summary(result) ; plot(result)

## This is equivalent to run the following decomposed code
dispRity(boot.matrix(custom.subsets(BeckLee_mat50, list(crown = c(16, 19:41, 45:50),
                                                        stem = c(1:15, 17:18, 42:44))),
                     bootstraps = 100),
         metric = c(median, centroids))

</code></pre>

<hr>
<h2 id='dispRity.through.time'>Disparity through time.</h2><span id='topic+dispRity.through.time'></span>

<h3>Description</h3>

<p>Performs a disparity through time analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispRity.through.time(data, tree, time, metric = c(median, centroids), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispRity.through.time_+3A_data">data</code></td>
<td>
<p>An ordinated <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="dispRity.through.time_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="dispRity.through.time_+3A_time">time</code></td>
<td>
<p>A <code>numeric</code> value for the number of subsets to create.</p>
</td></tr>
<tr><td><code id="dispRity.through.time_+3A_metric">metric</code></td>
<td>
<p>A vector containing one to three functions (default = <code>c(median, centroids)</code>) (see <code><a href="#topic+dispRity">dispRity</a></code> for details).</p>
</td></tr>
<tr><td><code id="dispRity.through.time_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code> and <code><a href="#topic+dispRity">dispRity</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the time subsets use <code>method = "discrete"</code>, the matrix is bootstrapped 100 times.
</p>
<p>Note that this is a wrapper function that allows users to run a basic disparity-through-time analysis without too much effort. 
As such it has a lot of defaults described in the functions that make up the analysis. 
See <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code> for more details of the defaults used in each of these functions.
Note that any of these defaults can be changed within the <code>disparity.through.time</code> function.
</p>


<h3>Value</h3>

<p>A <code>dispRity</code> object that can be passed to <code>summary</code> or <code>plot</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_mat50) ; data(BeckLee_tree)

## Run a simple disparity through time analysis (with three time bins)
result &lt;- dispRity.through.time(BeckLee_mat50, BeckLee_tree, 3)
summary(result) ; plot(result)

## This is equivalent to run the following decomposed code
dispRity(boot.matrix(chrono.subsets(BeckLee_mat50, BeckLee_tree, time = 3, method = "discrete"),
                     bootstraps = 100),
         metric = c(median, centroids))

</code></pre>

<hr>
<h2 id='distance.randtest'>Randtest distance</h2><span id='topic+distance.randtest'></span>

<h3>Description</h3>

<p>Measures the distance between the observed statistic from a <code>"randtest"</code> object and some specific quantile of the simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.randtest(xtest, quantile = c(0.025, 0.975), abs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance.randtest_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>"randtest"</code></p>
</td></tr>
<tr><td><code id="distance.randtest_+3A_quantile">quantile</code></td>
<td>
<p>a <code>numeric</code> value for the quantile edges to compare the observed data to on either sides (by default <code>quantile = c(0.025. 0.975)</code>).</p>
</td></tr>
<tr><td><code id="distance.randtest_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>, whether to calculate the distance as an absolute value (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compare the observed value to the simulated median value, you can use <code>quantile = 0.5</code>.
Also note that when using <code>abs = FALSE</code> (default), a negative value means that the observed statistic is within the request quantiles.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="ade4.html#topic+randtest">randtest</a></code> <code><a href="#topic+randtest.dispRity">randtest.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example
dummy_matrix &lt;- matrix(rnorm(500), 100, 5)

## Testing whether the mean of a random subset
## is different than the means of 100 subsets
dummy_test &lt;- randtest.dispRity(dummy_matrix,
                                subset = sample(1:100, 20),
                                metric = mean)
dummy_test ; plot(dummy_test)

## The distance between the observed data and the 95% quantile
distance.randtest(dummy_test)

## The absolute distance from the median
distance.randtest(dummy_test, quantile = 0.5, abs = TRUE)

</code></pre>

<hr>
<h2 id='dtt.dispRity'>dtt dispRity (from <code>geiger::dtt</code>)</h2><span id='topic+dtt.dispRity'></span>

<h3>Description</h3>

<p>A wrapper for the <code>geiger::dtt</code> function working with any disparity metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtt.dispRity(
  data,
  metric,
  tree,
  nsim = 0,
  model = "BM",
  alternative = "two-sided",
  scale.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtt.dispRity_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object or a <code>matrix</code></p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_metric">metric</code></td>
<td>
<p>The disparity metric to be passed to <code><a href="#topic+dispRity">dispRity</a></code>.</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object matching the data and with a <code>root.time</code> element. Can be missing if <code>data</code> has a <code>tree</code> component.</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to calculate null disparity-through-time.</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_model">model</code></td>
<td>
<p>A evolutionary model for the simulations (see <code>geiger::sim.char</code> - default is <code>"BM"</code>).</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_alternative">alternative</code></td>
<td>
<p>The H1 alternative (for calculating the p-value). Can be <code>"two-sided"</code> (default), <code>"greater"</code> or <code>"lesser"</code>; see details.</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_scale.time">scale.time</code></td>
<td>
<p>Optional, whether to scale the time (between 0 and 1; <code>TRUE</code>, default) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dtt.dispRity_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code>geiger::dtt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>geiger::dtt</code> for details.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Loading morphological data and a tree
data(BeckLee_mat50)
data(BeckLee_tree)

## The average squared pairwise distance metric (used in geiger::dtt)
average.sq &lt;- function(X) mean(pairwise.dist(X)^2)

## Calculate the disparity of the dataset using dtt.dispRity
dispRity_dtt &lt;- dtt.dispRity(data = BeckLee_mat50, metric = average.sq,
                             tree = BeckLee_tree, nsim = 20)

## Plotting the results
plot(dispRity_dtt)


</code></pre>

<hr>
<h2 id='extinction.subsets'>Getting the time subsets before and after an extinction event</h2><span id='topic+extinction.subsets'></span>

<h3>Description</h3>

<p>Getting the reference (pre-extinction) and the comparison (post-extinction) time subsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extinction.subsets(data, extinction, lag = 1, names = FALSE, as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extinction.subsets_+3A_data">data</code></td>
<td>
<p>a <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="extinction.subsets_+3A_extinction">extinction</code></td>
<td>
<p><code>numerical</code>, the time at the extinction event.</p>
</td></tr>
<tr><td><code id="extinction.subsets_+3A_lag">lag</code></td>
<td>
<p><code>numerical</code>, the lag effect (i.e. how many subsets after the extinction to consider - default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="extinction.subsets_+3A_names">names</code></td>
<td>
<p><code>logical</code>, whether to display the bins names (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="extinction.subsets_+3A_as.list">as.list</code></td>
<td>
<p><code>logical</code>, whether to output the results as a list for <code><a href="#topic+test.dispRity">test.dispRity</a></code> (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading some disparity data
data(disparity)

## Time subsets for the K-Pg extinction (66 Mya)
extinction.subsets(disparity, 66, names = TRUE)

## Extinction with a lag effect of 3 slices
extinction_time &lt;- extinction.subsets(disparity, 66, lag = 3, as.list = TRUE)

## Testing the extinction effect with a lag
test.dispRity(disparity, wilcox.test, comparisons = extinction_time,
              correction = "bonferroni")

</code></pre>

<hr>
<h2 id='geomorph.ordination'>Imports data from geomorph</h2><span id='topic+geomorph.ordination'></span>

<h3>Description</h3>

<p>Takes geomorph Procrustes object or a geomorph.data.frame object and ordinates it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomorph.ordination(data, ordinate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomorph.ordination_+3A_data">data</code></td>
<td>
<p>An array (p x k x n) typically obtained from a Procrustes superimposition <code>geomorph::gpagen</code> or a <code>geomorph::geomorph.data.frame</code> object.</p>
</td></tr>
<tr><td><code id="geomorph.ordination_+3A_ordinate">ordinate</code></td>
<td>
<p>Logical, whether to ordinate the data using <code><a href="stats.html#topic+prcomp">prcomp</a></code> (<code>TRUE</code>; default) or not (<code>FALSE</code>; the code then returns the raw coordinates matrix).</p>
</td></tr>
<tr><td><code id="geomorph.ordination_+3A_...">...</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="stats.html#topic+prcomp">prcomp</a></code> (is ignored if <code>ordinate = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is a <code>geomorph.data.frame</code> object containing factors, directly performs a <code><a href="#topic+custom.subsets">custom.subsets</a></code> using these factors.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> or a <code>dispRity</code> object.
</p>


<h3>See Also</h3>

<p><code>geomorph::gpagen</code>, <code>geomorph::morphol.disparity</code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(geomorph)
## Loading the plethodon dataset
data(plethodon)

## Performing a Procrustes transform
procrustes &lt;- geomorph::gpagen(plethodon$land, PrinAxes = FALSE)

## Obtaining the ordination matrix
geomorph.ordination(procrustes)

## Using a geomorph.data.frame
geomorph_df &lt;- geomorph.data.frame(procrustes, species = plethodon$species)

geomorph.ordination(geomorph_df)

## Calculating disparity from dispRity or geomorph::morphol.disparity
geomorph_disparity &lt;- geomorph::morphol.disparity(coords ~ 1,
                      groups= ~ species, data = geomorph_df)
dispRity_disparity &lt;- dispRity(geomorph.ordination(geomorph_df),
                      metric = function(X) return(sum(X^2)/nrow(X)))

## Extracting the raw disparity values
geomorph_val &lt;- round(as.numeric(geomorph_disparity$Procrustes.var), 15)
dispRity_val &lt;- as.vector(summary(dispRity_disparity, digits = 15)$obs)

## Comparing the values (to the 15th decimal!)
geomorph_val == dispRity_val # all TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='get.bin.ages'>Get time bins ages</h2><span id='topic+get.bin.ages'></span>

<h3>Description</h3>

<p>Gets time bins for a specific tree using stratigraphy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.bin.ages(tree, what = "End", type = "Age", ICS = 2015)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.bin.ages_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object with a <code>$root.time</code> component</p>
</td></tr>
<tr><td><code id="get.bin.ages_+3A_what">what</code></td>
<td>
<p>Which data to output. Can be <code>"Start"</code>, <code>"End"</code> (default), <code>"Range"</code> or <code>"Midpoint"</code>.</p>
</td></tr>
<tr><td><code id="get.bin.ages_+3A_type">type</code></td>
<td>
<p>The type of stratigraphic frame. Can be <code>"Age"</code> (default), <code>"Eon"</code>, <code>"Epoch"</code>, <code>"Era"</code> or <code>"Period"</code>.</p>
</td></tr>
<tr><td><code id="get.bin.ages_+3A_ics">ICS</code></td>
<td>
<p>The reference year of the International Commission on Stratigraphy (default = <code>2015</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chrono.subsets">chrono.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the data
data(BeckLee_tree)
data(BeckLee_mat50)

## Getting the stratigraphic data
stratigraphy &lt;- get.bin.ages(BeckLee_tree)

## Making stratigraphic time subsets
chrono.subsets(BeckLee_mat50, tree = BeckLee_tree, method = "discrete",
                time = stratigraphy)

</code></pre>

<hr>
<h2 id='get.contrast.matrix'>Generates a contrast matrix.</h2><span id='topic+get.contrast.matrix'></span>

<h3>Description</h3>

<p>Creates a contrast matrix using the observed character states in an input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.contrast.matrix(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.contrast.matrix_+3A_matrix">matrix</code></td>
<td>
<p>a discrete morphological character matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.morpho">check.morpho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random multistate matrix
random_matrix &lt;- matrix(sample(c(0,1,2), 100, TRUE), 10, 10)

## Get the contrast matrix
get.contrast.matrix(random_matrix)

## Adding inapplicable and missing data to the matrix
random_matrix[sample(1:100, 10)] &lt;- "?"
random_matrix[sample(1:100, 10)] &lt;- "-"

## Get the contrast matrix
get.contrast.matrix(random_matrix)

</code></pre>

<hr>
<h2 id='get.matrix'>Extract elements from a <code>dispRity</code> object.</h2><span id='topic+get.matrix'></span><span id='topic+get.disparity'></span><span id='topic+matrix.dispRity'></span><span id='topic+extract.dispRity'></span>

<h3>Description</h3>

<p>Extract a matrix or the disparity results from a <code>dispRity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.matrix(data, subsets, rarefaction, bootstrap, matrix)

get.disparity(data, subsets, rarefaction, observed, concatenate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.matrix_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_subsets">subsets</code></td>
<td>
<p>Optional, a <code>numeric</code> or <code>character</code> for which subsets to get (if missing, the value for all subsets are given).</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_rarefaction">rarefaction</code></td>
<td>
<p>Optional, a single <code>numeric</code> value corresponding to the rarefaction level (as the number of elements; if missing, the non-rarefied values are output).</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Optional, a <code>numeric</code> value to select a specific bootstrap draw (<code>0</code> is no bootstrap).</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_matrix">matrix</code></td>
<td>
<p>A <code>numeric</code> value of which matrix to select (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_observed">observed</code></td>
<td>
<p>A <code>logical</code> value indicating whether to output the observed (<code>TRUE</code> (default)) or the bootstrapped values (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="get.matrix_+3A_concatenate">concatenate</code></td>
<td>
<p>When the disparity metric is a distribution, whether to concatenate it returning the median (<code>TRUE</code>; default) or to return each individual values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+get.subsets">get.subsets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## To get the original matrix
get.matrix(disparity)

## To get the un-bootstrapped matrix from the subset called "80"
get.matrix(disparity, subsets = "80")

## To get the 52nd bootstrap draw of the second rarefaction level (15) of the
## same subset
get.matrix(disparity, subsets = 2, rarefaction = 2, bootstrap = 52)

## Extracting the observed disparity
get.disparity(disparity)

## Extracting the bootstrapped disparity
boot_disp &lt;- get.disparity(disparity, observed = FALSE)
str(boot_disp)
## Or only the rarefied (5) data
boot_disp_rare &lt;- get.disparity(disparity, observed = FALSE,
     rarefaction = 5)

</code></pre>

<hr>
<h2 id='get.subsets'>Extracts or modify subsets from a <code>dispRity</code> object.</h2><span id='topic+get.subsets'></span><span id='topic+n.subsets'></span><span id='topic+name.subsets'></span><span id='topic+size.subsets'></span><span id='topic+combine.subsets'></span>

<h3>Description</h3>

<p>Extracting or modify some subsets' data and information from a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.subsets(data)

name.subsets(data)

size.subsets(data)

get.subsets(data, subsets)

combine.subsets(data, subsets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.subsets_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="get.subsets_+3A_subsets">subsets</code></td>
<td>
<p>Either a <code>vector</code> of the number or name of the subsets to merge or a single. But see details for <code>combine.subsets</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the function <code>combine.subsets</code>, the argument <code>subsets</code> can ALSO be a <code>numeric</code> value of the minimum of elements for each series.
If <code>subset</code> is a vector, the subsets are merged in the given input order. <code>c(1, 3, 4)</code> will merge subsets 1 and 3 into 4, while the opposite, <code>c(3, 4, 1)</code> will merge subsets 3 and 4 into 1.
When a single numeric value is given, subsets are merged with the next subset until the correct number of elements for each subset is reached (apart from the last subset that gets merged with the previous one).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+get.disparity">get.disparity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## How many subsets are in disparity?
n.subsets(disparity)

## What are the subset names
name.subsets(disparity)

## What are the number of elements per subsets?
size.subsets(disparity)

## Get one subset
get.subsets(disparity, "60")

## Get two subsets
get.subsets(disparity, c(1,5))

## Generate subsets from a dummy matrix
dummy_matrix &lt;- matrix(rnorm(120), 40, dimnames = list(c(1:40)))
dummy_subsets &lt;- custom.subsets(dummy_matrix,
     group = list("a" = c(1:5), "b" = c(6:10), "c" = c(11:20),
                  "d" = c(21:24), "e" = c(25:30), "f" = c(31:40)))

## Merging the two first subsets
combine.subsets(dummy_subsets, c(1,2))

## Merging the three subsets by name
combine.subsets(dummy_subsets, c("d", "c", "e"))

## Merging the subsets to contain at least 20 taxa
combine.subsets(dummy_subsets, 10)

</code></pre>

<hr>
<h2 id='make.dispRity'>Make and fill <code>dispRity</code>.</h2><span id='topic+make.dispRity'></span><span id='topic+fill.dispRity'></span>

<h3>Description</h3>

<p>Creating an empty <code>dispRity</code> object from a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.dispRity(data, tree, call, subsets)

fill.dispRity(data, tree, check)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.dispRity_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="make.dispRity_+3A_tree">tree</code></td>
<td>
<p>Optional, a <code>phylo</code> or <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="make.dispRity_+3A_call">call</code></td>
<td>
<p>Optional, a <code>list</code> to be a <code>dispRity</code> call.</p>
</td></tr>
<tr><td><code id="make.dispRity_+3A_subsets">subsets</code></td>
<td>
<p>Optional, a <code>list</code> to be a <code>dispRity</code> subsets list.</p>
</td></tr>
<tr><td><code id="make.dispRity_+3A_check">check</code></td>
<td>
<p>Logical, whether to check the data (<code>TRUE</code>; default, highly advised) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An empty dispRity object
make.dispRity()

## Still an empty dispRity object (with a matrix)
(empty &lt;- make.dispRity(data = matrix(rnorm(12), ncol = 3)))

## A dispRity object with a matrix of 4*3
fill.dispRity(empty)

## A dispRity object with a tree
my_tree &lt;- rtree(4, tip.label = c(1:4))
fill.dispRity(empty, tree = my_tree)

</code></pre>

<hr>
<h2 id='make.metric'>Creating disparity metrics</h2><span id='topic+make.metric'></span>

<h3>Description</h3>

<p>Testing the dimension-level of disparity metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.metric(
  fun,
  ...,
  silent = FALSE,
  check.between.groups = FALSE,
  data.dim,
  tree = NULL,
  covar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.metric_+3A_fun">fun</code></td>
<td>
<p>A <code>function</code>.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_...">...</code></td>
<td>
<p>Some arguments to be passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_silent">silent</code></td>
<td>
<p><code>logical</code>; if <code>FALSE</code> (default), the function will be verbose and give no output; if <code>TRUE</code>, the function will only output the function's dimension-level.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_check.between.groups">check.between.groups</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, the function will output a named list containing the metric level and a logical indicating whether the metric can be used between groups or not. If <code>FALSE</code> (default) the function only outputs the metric level.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_data.dim">data.dim</code></td>
<td>
<p>optional, two <code>numeric</code> values for the dimensions of the matrix to run the test function testing. If missing, a default 5 rows by 4 columns matrix is used.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_tree">tree</code></td>
<td>
<p>optional, a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="make.metric_+3A_covar">covar</code></td>
<td>
<p><code>logical</code>, whether to treat the metric as applied the a <code>data$covar</code> component (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests:
</p>

<ul>
<li><p> 1: if your function can deal with a matrix as an <code>input</code>.
</p>
</li>
<li><p> 2: which dimension-level is your function (1, 2 or 3, see <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>).
</p>
</li>
<li><p> 3: whether the function can properly be implemented in the <code>dispRity</code> function.
</p>
</li></ul>

<p>The three different metric levels correspond to the dimensions of the output and are:
</p>

<ul>
<li><p> &quot;dimension-level 1&quot;: for functions that decompose a <code>matrix</code> into a single value.
</p>
</li>
<li><p> &quot;dimension-level 2&quot;: for functions that decompose a <code>matrix</code> into a <code>vector</code>.
</p>
</li>
<li><p> &quot;dimension-level 3&quot;: for functions that transform the <code>matrix</code> into another <code>matrix</code>.
</p>
</li></ul>

<p>For example, the disparity metric <code><a href="base.html#topic+sum">sum</a></code> of <code><a href="#topic+variances">variances</a></code> is composed of two metric dimension-levels:
</p>

<ul>
<li><p> The <code><a href="#topic+variances">variances</a></code> (dimension-level 2) that calculates the variances for each column in a matrix (aggregates a <code>matrix</code> into a <code>vector</code>).
</p>
</li>
<li><p> The <code><a href="base.html#topic+sum">sum</a></code> (dimension-level 1) that transforms the <code>vector</code> of variances into a single value.
</p>
</li></ul>

<p>See function example for a concrete illustration (three different dimension-levels of the function <code><a href="base.html#topic+sum">sum</a></code>).
</p>
<p><em>HINT:</em> it is better practice to name the first argument of <code>fun</code> <code>matrix</code> to avoid potential argument conflicts down the line (the <code><a href="#topic+dispRity">dispRity</a></code> function assumes the <code>matrix</code> argument for the parsing the metrics).
</p>
<p>The input <code>fun</code> can be a &quot;normal&quot; metric function (i.e. that takes a matrix as first argument) or a &quot;between.groups&quot; metric (i.e. that takes two matrix as arguments). If the arguments are named <code>matrix</code> and <code>matrix2</code>, the metric will be assumed to be &quot;between.groups&quot; and be run in a <code>for</code> loop rather than a <code>apply</code> loop in <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+dispRity.metric">dispRity.metric</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A dimension-level 1 function
my_fun &lt;- function(matrix) sum(matrix)
make.metric(my_fun)

## A dimension-level 2 function
my_fun &lt;- function(matrix) apply(matrix, 2, sum)
make.metric(my_fun)

## A dimension-level 3 function
my_fun &lt;- function(matrix) (matrix + sum(matrix))
make.metric(my_fun)

</code></pre>

<hr>
<h2 id='match.tip.edge'>Match tips or nodes edge vector</h2><span id='topic+match.tip.edge'></span>

<h3>Description</h3>

<p>Match a vector of tips or tips and nodes with the an edge list from a <code>"phylo"</code> or <code>"multiPhylo"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.tip.edge(vector, phylo, replace.na, use.parsimony = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.tip.edge_+3A_vector">vector</code></td>
<td>
<p>a vector of variables (equal to the number of tips or to the number of tips and nodes).</p>
</td></tr>
<tr><td><code id="match.tip.edge_+3A_phylo">phylo</code></td>
<td>
<p>a phylo or multiPhylo object.</p>
</td></tr>
<tr><td><code id="match.tip.edge_+3A_replace.na">replace.na</code></td>
<td>
<p>optional, what to replace NAs with.</p>
</td></tr>
<tr><td><code id="match.tip.edge_+3A_use.parsimony">use.parsimony</code></td>
<td>
<p>logical, whether to also colour internal edges parsimoniously (<code>TRUE</code> - default; i.e. if two nodes have the same unique ancestor node and the same variable, the ancestor node is assume to be the of the same value as its descendants) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variables equal to the number of edges in the tree (or a list of vectors if the <code>phylo</code> input is of class <code>"multiPhylo"</code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random tree
tree &lt;- rtree(20)

## A random vector of two variables for each tips
tip_values &lt;- sample(c("blue", "red"), 20, replace = TRUE)

## Matching the colors (blue and red) to the tips descendants
edge_colors &lt;- match.tip.edge(tip_values, tree, replace.na = "grey")

## Plotting the results
plot(tree, show.tip.label = FALSE, edge.color = edge_colors)
tiplabels(1:20, bg = tip_values)

## Same but without assuming parsimony for the internal nodes
plot(tree, show.tip.label = FALSE,
     edge.color = match.tip.edge(tip_values, tree,
                                 use.parsimony = FALSE,
                                 replace.na = "grey"))

## Matching the tips and nodes colors with the edges
node_values &lt;- sample(c("blue", "red"), 19, replace = TRUE)
edge_colors &lt;- match.tip.edge(c(tip_values, node_values), tree)
plot(tree, show.tip.label = FALSE, edge.color = edge_colors) 
tiplabels(1:20, bg = tip_values)
nodelabels(1:19, bg = node_values)
</code></pre>

<hr>
<h2 id='MCMCglmm.subsets'>MCMCglmm.subsets</h2><span id='topic+MCMCglmm.subsets'></span>

<h3>Description</h3>

<p>Creating a dispRity object from a MCMCglmm posterior output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCglmm.subsets(
  data,
  posteriors,
  group,
  tree,
  rename.groups,
  set.loc = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCglmm.subsets_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> or <code>matrix</code> used for the <code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code> model.</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_posteriors">posteriors</code></td>
<td>
<p>A <code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code> object, the posteriors of the model.</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_group">group</code></td>
<td>
<p>Optional, a named vector of which group to include from the posteriors (if left empty the random and residual terms are used). See details.</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_tree">tree</code></td>
<td>
<p>Optional, the tree(s) used in the MCMCglmm analyses.</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_rename.groups">rename.groups</code></td>
<td>
<p>Optional, a vector of group names for renaming them. See details.</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_set.loc">set.loc</code></td>
<td>
<p>Optional, if no location is available for a subset (<code>$Sol = 0</code>), set the location of the subset from <code>data</code> (the centroid of the group) (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="MCMCglmm.subsets_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+MCMCglmm.covars">MCMCglmm.covars</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For the <code>group</code> option, the group names must be ones found in the <code>posteriors</code> formula in the format <em>&lt;Type = Term:FactorLevel&gt;</em> as returned by <code>MCMCglmm.levels(posteriors)</code>. For example, for returning two random effect, the phylogenetic one (<code>"animal"</code>) and one for a specific clade (say the 2nd clade) as well as two residual terms for a specific factor (say level 1 and 4) you can use <code>group = c(random = "animal", random = "animal:clade2", residual = "units:myfactor1", residual = "units:myfactor4")</code>.
</p>
</li>
<li><p> For the <code>rename.groups</code> option, the vector must be of class <code>"character"</code> and must of the same length as the number of random and residual terms in <code>posteriors</code> or of <code>group</code> argument (if used). If the <code>group</code> argument is left empty, the groups are extracted from the <code>posteriors</code> in the following order: the random terms first then the residual terms as specified in the <code>posteriors</code> object formulas (respectively <code>posteriors$Random$formula</code> and <code>posteriors$Residual$formula</code>).
</p>
</li></ul>

<p><em>NOTE</em> that the output <code>dispRity</code> inherits the dimensions used in the <code>posteriors</code> argument. You can always check the selected dimensions using:
<code>data$call$dimensions</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>  <code><a href="#topic+covar.plot">covar.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(charadriiformes)

## Creating a dispRity object from the charadriiformes model
MCMCglmm.subsets(data       = charadriiformes$data,
                 posteriors = charadriiformes$posteriors)

## Same but selecting only the three first random terms
MCMCglmm.subsets(data       = charadriiformes$data,
                 posteriors = charadriiformes$posteriors,
                 tree       = charadriiformes$tree,
                 group      = MCMCglmm.levels(
                                 charadriiformes$posteriors)[1:3],
                 rename.groups = c("gulls", "plovers", "sandpipers"))


</code></pre>

<hr>
<h2 id='MCMCglmm.utilities'>MCMCglmm object utility functions</h2><span id='topic+MCMCglmm.utilities'></span><span id='topic+MCMCglmm.levels'></span><span id='topic+MCMCglmm.traits'></span><span id='topic+MCMCglmm.sample'></span><span id='topic+MCMCglmm.covars'></span><span id='topic+MCMCglmm.variance'></span>

<h3>Description</h3>

<p>Different utility functions to extract aspects of a <code>MCMCglmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCglmm.traits(MCMCglmm)

MCMCglmm.levels(MCMCglmm, convert)

MCMCglmm.sample(MCMCglmm, n)

MCMCglmm.covars(MCMCglmm, n, sample)

MCMCglmm.variance(MCMCglmm, n, sample, levels, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCglmm.utilities_+3A_mcmcglmm">MCMCglmm</code></td>
<td>
<p>A <code>MCMCglmm</code> object.</p>
</td></tr>
<tr><td><code id="MCMCglmm.utilities_+3A_convert">convert</code></td>
<td>
<p>Logical, whether to return the raw term names names as expressed in the model column names (<code>FALSE</code>) or to convert it to something more reader friendly (<code>TRUE</code>; default).</p>
</td></tr>
<tr><td><code id="MCMCglmm.utilities_+3A_n">n</code></td>
<td>
<p>Optional, a number of random samples to extract.</p>
</td></tr>
<tr><td><code id="MCMCglmm.utilities_+3A_sample">sample</code></td>
<td>
<p>Optional, the specific samples to extract (is ignored if <code>n</code> is present).</p>
</td></tr>
<tr><td><code id="MCMCglmm.utilities_+3A_levels">levels</code></td>
<td>
<p>Optional, a vector <code>"character"</code> values (matching <code>MCMCglmm.levels(..., convert = TRUE)</code>) or of <code>"numeric"</code> values designating which levels to be used to calculate the variance (if left empty, all the levels are used).</p>
</td></tr>
<tr><td><code id="MCMCglmm.utilities_+3A_scale">scale</code></td>
<td>
<p>Logical, whether to scale the variance relative to all the levels (<code>TRUE</code>; default) or not (<code>FALSE</code>)/</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>MCMCglmm.levels</code> returns the different random and residual terms levels of a <code>MCMCglmm</code> object. This function uses the default option <code>convert = TRUE</code> to convert the names into something more readable. Toggle to <code>convert = FALSE</code> for the raw names.
</p>
</li>
<li> <p><code>MCMCglmm.traits</code> returns the column names of the different traits of a <code>MCMCglmm</code> formula object.
</p>
</li>
<li> <p><code>MCMCglmm.sample</code> returns a vector of sample IDs present in the <code>MCMCglmm</code> object. If <code>n</code> is missing, all the samples IDs are returned. Else, a random series of sample IDs are returned (with replacement if n greater than the number of available samples).
</p>
</li>
<li> <p><code>MCMCglmm.covars</code> returns a list of covariance matrices and intercepts from a <code>MCMCglmm</code> object (respectively from <code>MCMCglmm$VCV</code> and <code>MCMCglmm$Sol</code>). By default, all the covariance matrices and intercepts are returned but you can use either of the arguments <code>sample</code> to return specific samples (e.g. <code>MCMCglmm.covars(data, sample = c(1, 42))</code> for returning the first and 42nd samples) or <code>n</code> to return a specific number of random samples (e.g. <code>MCMCglmm.covars(data, n = 42)</code> for returning 42 random samples).
</p>
</li>
<li> <p><code>MCMCglmm.variance</code> returns a list of covariance matrices and intercepts from a <code>MCMCglmm</code> object (respectively from <code>MCMCglmm$VCV</code> and <code>MCMCglmm$Sol</code>). By default, all the covariance matrices and intercepts are returned but you can use either of the arguments <code>sample</code> to return specific samples (e.g. <code>MCMCglmm.covars(data, sample = c(1, 42))</code> for returning the first and 42nd samples) or <code>n</code> to return a specific number of random samples (e.g. <code>MCMCglmm.covars(data, n = 42)</code> for returning 42 random samples). 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm.subsets">MCMCglmm.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the charadriiformes model
data(charadriiformes)
model &lt;- charadriiformes$posteriors
class(model) # is MCMCglmm

## Get the list of levels from the model
MCMCglmm.levels(model)
## The raw levels names (as they appear in the MCMCglmm object)
MCMCglmm.levels(model, convert = FALSE)

## Get the traits names from the model
MCMCglmm.traits(model)

## Get all the available samples in the model
length(MCMCglmm.sample(model))
## Get 5 random sample IDs from the model
MCMCglmm.sample(model, n = 5)

## Get one specific samples from the model
MCMCglmm.covars(model, sample = 42)
## Get two random samples from the model
MCMCglmm.covars(model, n = 2)
</code></pre>

<hr>
<h2 id='model.test'>Model Test</h2><span id='topic+model.test'></span>

<h3>Description</h3>

<p>Fit models of disparity change through time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.test(
  data,
  model,
  pool.variance = NULL,
  time.split = NULL,
  fixed.optima = FALSE,
  control.list = list(fnscale = -1),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.test_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object used to test models of evolution through time.</p>
</td></tr>
<tr><td><code id="model.test_+3A_model">model</code></td>
<td>
<p>The model(s) of evolution to allow for changes in disparity-through-time using a homogenous or hetergenous model, either using a single input or a list containing different models (See <b>Details</b>). If a vector with multiple modes is supplied then the model will test for shifts in modes at the time supplied by <code>time.split</code>.</p>
</td></tr>
<tr><td><code id="model.test_+3A_pool.variance">pool.variance</code></td>
<td>
<p>If <code>NULL</code> (default) the difference in variances will be calculated using <code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code> of equal variances. If there is no significant difference among variances, then variance in samples will be pooled and the same variance will be used for all samples. A significance difference will not pool variances and the original variance will be used for model-testing. If argument <code>TRUE</code> or <code>FALSE</code> are used, Bartlett's test will be ignored and the analyses will use the user-set pooling of variances.</p>
</td></tr>
<tr><td><code id="model.test_+3A_time.split">time.split</code></td>
<td>
<p>The age of the change in mode (<code>numeric</code>). The age is measured in positive units as the time before the most recent sample, and multiple ages can be supplied in a vector. If no age is supplied for models then all possible time shifts are fit in the model, and the highest likelihood model is returned. Note this only applies to heterogenous models (See <b>Details</b>).</p>
</td></tr>
<tr><td><code id="model.test_+3A_fixed.optima">fixed.optima</code></td>
<td>
<p>A <code>logical</code> value, whether to use an estimated optimum value in OU models (<code>FALSE</code> - default), or whether to set the OU optimum to the ancestral value (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="model.test_+3A_control.list">control.list</code></td>
<td>
<p>A <code>list</code> of fine-tune control inputs for the <code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="model.test_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>, whether to display the model results while they are computed (<code>TRUE</code> - default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DISCLAIMER: this function is working properly (i.e. it does what it is supposed to do), however, the interpretation of the results has not yet been thought through, discussed and peer-reviewed (what does a Brownian motion like disparity curve means biologically?).
</p>
<p>The models are fit using maximum likelihood optimisation using the function optim. Fine-tuning of the search algorithms can be applied using the <code>control.list</code> argument. Models can be fit using a homogenous model with the same process applied to the entire sequence or models with time splits that represent a change in parameters or a shift in mode. When a heterogeneous and/or a time-shift model is specified with a specified <code>time.split</code> then the shift is tested at that value only. If no time shift is supplied then multiple shift times are tested, with all bins that allow for at least 10 bins either side of the split. If the entire sample is fewer than 30 samples long then no time splits are searched for (unless a time split is supplied by the user). Parameters are shared across different modes. For example, <code>c("BM", "OU")</code> would fit a model in which the process starts with a BM model and shifts to an OU process. The ancestral value at the start of the sequence and sigma squared value are shared across the models. Any combination of the following homogenous models (with the exception of <code>"multi.OU"</code>) can be fit to the data:
</p>

<ul>
<li><p> BM: Fits a unbiased random walk model of Brownian motion evolution (Felsenstein 1973; 1985; Hunt 2006). The model optimises the ancestral state and the 'step-variance' (sigma-squared).
</p>
</li>
<li><p> OU: The Ornstein-Uhlenbeck model of evolution in which the change in variance is constrained to an optimum value (Hansen 1997). In this model there are three parameters: optima, alpha, and ancestral state. The strength of attraction based on the parameter alpha and the ancestral state is estimated from the data. The optima value is estimated from the data, and this can lead to optima being found outside the known data values, and thus the model can resemble a trend. If the argument <code>fixed.optima = TRUE</code>, the model will not estimate optima but constrain it to the first (ancestral) value in the sequence as is done in phylogenetic OU models.
</p>
</li>
<li><p> Trend: Fits a Brownian motion model with a directional component. This model is also known as the General Random Walk (Hunt 2006). This model has three parameters: the ancestral state, the 'step-variance' (sigma-squared), and the positive or negative trend.
</p>
</li>
<li><p> Stasis: Fits a model in which traits evolve with variance (omega) around a mean (theta). This model is time-independent in that the model is guided only by the variance and attraction to the mean (Hunt 2006).
</p>
</li>
<li><p> EB: Early-Burst, trait variance accumulates early in the evolution of a trait and decreases exponentially through time (Blomberg et al. 2003; Harmon et al. 2010). This model has three parameters: ancestral state, sigma-squared, and the exponential rate of decrease. Note this model expects the mean to remain unchanged through the model, so does not explicitly model a rapid change to a new mean or optimum value.
</p>
</li>
<li><p> multi.OU: Fits a model in which the value of the optima shifts at one or more time splits. The values of the 'step-variance' (sigma squared) and attraction to the optima (alpha) are shared across all the samples. This model can not be fit with other models - the multi.OU system can be fit to the model only.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>dispRity</code> and <code>model.test</code> that can be plotted and summarised via <code><a href="#topic+summary.dispRity">summary.dispRity</a></code> and <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
The list is composed of:
</p>

<ul>
<li> <p><code>$aic.models</code> summary for each model's small sample Akaike Information Criterion (AICc), delta AICc, and AICc weight
</p>
</li>
<li> <p><code>$full.models</code> the list of the full models outputs from <code><a href="stats.html#topic+optim">optim</a></code> with the estimated parameters, log-likelihood, convergence statistics, and the split.time if applicable
</p>
</li>
<li> <p><code>$call</code> the model input
</p>
</li>
<li> <p><code>$models.data</code> input data used by the model(s)
</p>
</li>
<li> <p><code>$fixed.optima</code> Logical indicating whether a fixed optima was assumed for OU model(s)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mark N Puttick and Thomas Guillerme
</p>


<h3>References</h3>

<p>Blomberg SP, Garland T Jr, &amp; Ives AR. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. Evolution. <b>57</b>, 717-745.
</p>
<p>Hansen TF. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution. <b>51</b>, 1341-1351.
</p>
<p>Harmon LJ, <em>et al</em>. 2010. Early bursts of body size and shape evolution are rare in comparative data. <b>64</b>, 2385-2396.
</p>
<p>Hunt G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond. Paleobiology. <b>32</b>, 578-601. DOI: 10.1666/05070.1.
</p>
<p>Hunt G, Hopkins MJ &amp; Lidgard S. 2015. Simple versus complex models of trait evolution and stasis as a response to environmental change. Proceedings of the National Academy of Sciences. <b>112</b>, 4885-4890. DOI: 10.1073/pnas.1403662111
</p>
<p>Felsenstein J. 1973. Maximum-likelihood estimation of evolutionary trees from continuous characters. American Journal of Human Genetics. <b>25</b>, 471-492.
</p>
<p>Felsenstein J. 1985. Phylogenies and the comparative method. The American Naturalist. <b>51</b>, 1-15.
</p>
<p>Murrell DJ. 2018. A global envelope test to detect non-random bursts of trait evolution. Methods in Ecology and Evolution. DOI: 10.1111/2041-210X.13006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.test.wrapper">model.test.wrapper</a></code>, <code><a href="#topic+model.test.sim">model.test.sim</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code> and <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Mammal disparity through time
data(BeckLee_disparity)

## The four models to fit
models &lt;- list("BM", "OU", "multi.OU", c("BM", "OU"))

## Fitting the four models to the disparity data
tests &lt;- model.test(BeckLee_disparity, models, time.split = 66)

## Summarising the models
summary(tests)

## Plotting only the models support
plot(tests)

## End(Not run)

</code></pre>

<hr>
<h2 id='model.test.sim'>Simulate Model Test</h2><span id='topic+model.test.sim'></span>

<h3>Description</h3>

<p>Simulate models of disparity change through time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.test.sim(
  sim = 1,
  model,
  model.rank = 1,
  alternative = "two-sided",
  time.split = NULL,
  time.span = 100,
  variance = 1,
  sample.size = 100,
  parameters = list(),
  fixed.optima = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.test.sim_+3A_sim">sim</code></td>
<td>
<p>The number of separate simulations to run.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_model">model</code></td>
<td>
<p>Either (i) the named model of evolution to simulate for changes in disparity-through-time using a homogenous or hetergenous model (see list in <code><a href="#topic+model.test">model.test</a></code>) or (ii) an object of class <code>dispRity</code> returned from <code>model.test</code> function. If a <code>dispRity</code> object is supplied, all remaining arguments apart from <code>sim</code> and <code>model.rank</code> and <code>alternative</code> are ignored as the model specified by the input model is used.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_model.rank">model.rank</code></td>
<td>
<p>If a <code>dispRity</code> object is supplied, which model is used for simulation. The rank refers to the order of models as specified by AICc, so if <code>model.rank = 1</code> (default) the best-fitting model is used for simulation.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_alternative">alternative</code></td>
<td>
<p>If the simulation is based on a <code>dispRity</code> object, what is the alternative hypothesis: can be <code>"two-sided"</code> (default), <code>"greater"</code> or <code>"lesser"</code>.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_time.split">time.split</code></td>
<td>
<p>The age of the change in mode. The age is measured as the time before the most recent sample, and multiple ages can be supplied in a vector. Note this only applies to heterogenous models.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_time.span">time.span</code></td>
<td>
<p>The length of the sequence (<code>numeric</code>). If one number is supplied this is treated as the length of the sequence and the time span is treated as sequence from 0 to <code>time.span</code> in unit increments. If a vector of length &gt; 1 is supplied, this is treated as the the age of each sample in the sequence.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_variance">variance</code></td>
<td>
<p>The variance of each sample (<code>numeric</code>). If one number is supplied this is the variance for all samples in the sequence. If a vector of equal length to the <code>time.span</code> vector is supplied, this is used for the variance of each sample in the sequence</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_sample.size">sample.size</code></td>
<td>
<p>The sample size of each sample (<code>numeric</code>). If one number is supplied this is the sample size for all samples in the sequence. If a vector of equal length to the <code>time.span</code> vector is supplied, this is used for the sample size of each sample in the sequence</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_parameters">parameters</code></td>
<td>
<p>A <code>list</code> of model parameters used for simulations. See details.</p>
</td></tr>
<tr><td><code id="model.test.sim_+3A_fixed.optima">fixed.optima</code></td>
<td>
<p>A <code>logical</code> value, whether to use an estimated optimum value in OU models (<code>FALSE</code> - default), or whether to set the OU optimum to the ancestral value (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DISCLAIMER: this function is working properly (i.e. it does what it is supposed to do), however, the interpretation of the results has not yet been thought through, discussed and peer-reviewed (what does a Brownian motion like disparity curve means biologically?).
</p>
<p>The <code>parameters</code> is a list of arguments to be passed to the models.
These arguments can be:
</p>

<ul>
<li><p><code>ancestral.state</code>, ancestral value of the disparity applicable to all models (default = <code>0.01</code>).
</p>
</li>
<li><p><code>sigma.squared</code>, rate of step variance to all models except Stasis (default = <code>1</code>).
</p>
</li>
<li><p><code>alpha</code>, strength of attraction to the optimum in OU models (default = <code>1</code>).
</p>
</li>
<li><p><code>optima.1</code>, the value of the optimum in a OU model, or the first bin optimum in a multi-OU model (default = <code>0.15</code>).
</p>
</li>
<li><p><code>optima.2</code>, the second bin optimum in a multi-OU model (default = <code>0.15</code>).
</p>
</li>
<li><p><code>optima.3</code>, the third bin optimum in a multi-OU model (default = <code>0.15</code>).
</p>
</li>
<li><p><code>theta.1</code>, the mean in a Stasis model, or the first bin mean in a multi-Stasis model (default = <code>1</code>).
</p>
</li>
<li><p><code>theta.2</code>, the second bin optimum in a multi-OU model (default = <code>1</code>).
</p>
</li>
<li><p><code>theta.3</code>, the third bin optimum in a multi-OU model (default = <code>1</code>).
</p>
</li>
<li><p><code>omega</code>, the variance in a Stasis model (default = <code>1</code>).
</p>
</li>
<li><p><code>trend</code>, the trend parameter in the Trend model (default = <code>0.5</code>).
</p>
</li>
<li><p><code>eb.rate</code>, the rate of exponential rate decrease in the EB model (default = <code>-0.1</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>dispRity</code> and <code>model.sim</code>. Each list element contains the simulated central tendency, as well as the variance, sample size, and subsets used to simulate the data.
</p>


<h3>Author(s)</h3>

<p>Mark N Puttick and Thomas Guillerme
</p>


<h3>References</h3>

<p>Blomberg SP, Garland T Jr, &amp; Ives AR. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. Evolution.  <b>57</b>, 717-745.
</p>
<p>Hansen TF. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution. <b>51</b>, 1341-1351.
</p>
<p>Harmon LJ, <em>et al</em>. 2010. Early bursts of body size and shape evolution are rare in comparative data. <b>64</b>, 2385-2396.
</p>
<p>Hunt G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond. Paleobiology. <b>32</b>, 578-601. DOI: 10.1666/05070.1.
</p>
<p>Hunt G, Hopkins MJ &amp; Lidgard S. 2015. Simple versus complex models of trait evolution and stasis as a response to environmental change. Proceedings of the National Academy of Sciences. <b>112</b>, 4885-4890. DOI: 10.1073/pnas.1403662111
</p>
<p>Felsenstein J. 1973. Maximum-likelihood estimation of evolutionary trees from continuous characters. American Journal of Human Genetics. <b>25</b>, 471-492.
</p>
<p>Felsenstein J. 1985. Phylogenies and the comparative method. The American Naturalist. <b>51</b>, 1-15.
</p>
<p>Murrell DJ. 2018. A global envelope test to detect non-random bursts of trait evolution. Methods in Ecology and Evolution. DOI: 10.1111/2041-210X.13006
</p>
<p>Citation for the envelope code:
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.test">model.test</a></code>, <code><a href="#topic+model.test.wrapper">model.test.wrapper</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code> and <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Disparity through time data
data(BeckLee_disparity)

## List of models to test
models &lt;- list("Trend", "BM")

## Testing the models on the observed disparity
model_test_output &lt;- model.test(BeckLee_disparity, models, time.split = 66)
 
## simulations using the output from model.test
model_test_sim_output &lt;- model.test.sim(sim = 100, model= model_test_output)
 
## Plot the simulated best model
plot(model_test_sim_output)
## Add the observed data
plot(BeckLee_disparity, add = TRUE, col = c("pink", "#ff000050", "#ff000050"))

## Simulating a specific model with specific parameters parameters
model_simulation &lt;- model.test.sim(sim = 100, model = "BM", time.span = 120, variance = 0.1,
                                   sample.size = 100, parameters = list(ancestral.state = 0,
                                   sigma.squared = 0.1))

## Summarising the results
plot(model_simulation, main = "A simple Brownian motion")

## End(Not run)

</code></pre>

<hr>
<h2 id='model.test.wrapper'>Model test wrapper</h2><span id='topic+model.test.wrapper'></span>

<h3>Description</h3>

<p>A wrapper function for <code><a href="#topic+model.test">model.test</a></code> to perform a model fitting analysis on disparity through time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.test.wrapper(
  data,
  model,
  pool.variance = NULL,
  time.split = NULL,
  fixed.optima = FALSE,
  control.list = list(fnscale = -1),
  verbose = TRUE,
  sim = 1000,
  plot.sim = TRUE,
  col.sim,
  col.obs = "hotpink",
  lwd.obs = 2,
  show.p = FALSE,
  cex.p,
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.test.wrapper_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object used to test models of evolution through time.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_model">model</code></td>
<td>
<p>The model(s) of evolution to allow for changes in disparity-through-time using a homogenous or hetergenous model, either using a single input or a list containing different models (see list in <code><a href="#topic+model.test">model.test</a></code>). If a vector with multiple modes is supplied then the model will test for shifts in modes at the time supplied by <code>time.split</code>.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_pool.variance">pool.variance</code></td>
<td>
<p>If <code>NULL</code> (default) the difference in variances will be calculated using <code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code> of equal variances. If there is no significant difference among variances, then variance in samples will be pooled and the same variance will be used for all samples. A significance difference will not pool variances and the original variance will be used for model-testing. If argument <code>TRUE</code> or <code>FALSE</code> are used, Bartlett's test will be ignored and the analyses will use the user-set pooling of variances.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_time.split">time.split</code></td>
<td>
<p>The age of the change in mode (<code>numeric</code>). The age is measured in positive units as the time before the most recent sample, and multiple ages can be supplied in a vector. If no age is supplied for models then all possible time shifts are fit in the model, and the highest likelihood model is returned. Note this only applies to heterogenous models (See <b>Details</b>).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_fixed.optima">fixed.optima</code></td>
<td>
<p>A <code>logical</code> value, whether to use an estimated optimum value in OU models (<code>FALSE</code> - default), or whether to set the OU optimum to the ancestral value (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_control.list">control.list</code></td>
<td>
<p>A <code>list</code> of fine-tune control inputs for the optim function.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>, whether to display the model results as computed (<code>TRUE</code> - default).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_sim">sim</code></td>
<td>
<p>The number of separate simulations (default = 1000).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_plot.sim">plot.sim</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) the plots of the simulated and observed disparity are returned for all models.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_col.sim">col.sim</code></td>
<td>
<p>Colour options used for the plotting of simulated values. See <code><a href="#topic+plot.dispRity">plot.dispRity</a></code> for more details. If missing, the default colours <code>c("black", "lightgrey", "grey")</code> are used.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_col.obs">col.obs</code></td>
<td>
<p>Colour of the observed data on the plot. Default colour is <code>"hotpink"</code></p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_lwd.obs">lwd.obs</code></td>
<td>
<p>Line width of the observed value.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_show.p">show.p</code></td>
<td>
<p>Logical, when <code>plot.sim = TRUE</code>, whether to display the p-value of rank envelope tests (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_cex.p">cex.p</code></td>
<td>
<p>A numerical value for the the font size of the displayed p-value (if <code>show.p = TRUE</code>). If missing, the value is set to 1.</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_legend">legend</code></td>
<td>
<p>Logical, when <code>plot.sim = TRUE</code>, whether to display the legend in the first panel (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="model.test.wrapper_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed to <code><a href="#topic+plot.dispRity">plot.dispRity</a></code> or <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives the relative fit of <code>model.test</code> output using log-likelihood and AICc values, as well as the Rank Envelope Test significance to elucidate if empirical data is significantly different to simulated data modelled using the estimated model parameters from <code><a href="#topic+model.test.sim">model.test.sim</a></code>. This is equivalent to running <code>test &lt;- model.test.sim(sim = 1000, model = model.test(data, model)); summary(test) ; plot(test) ; plot(data, add = TRUE)</code>.
</p>
<p>DISCLAIMER: this function is working properly (i.e. it does what it is supposed to do), however, the interpretation of the results has not yet been thought through, discussed and peer-reviewed (what does a Brownian motion like disparity curve means biologically?).
</p>


<h3>Value</h3>

<p>A matrix with the relative fit, parameter values, and Rank Envelope test p values for each model, and a plot of simulated data from each model alongside observed data for each model if plot.sim is <code>TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Mark N Puttick and Thomas Guillerme
</p>


<h3>References</h3>

<p>Blomberg SP, Garland T Jr, &amp; Ives AR. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. Evolution.  <b>57</b>, 717-745.
</p>
<p>Hansen TF. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution. <b>51</b>, 1341-1351.
</p>
<p>Harmon LJ, <em>et al</em>. 2010. Early bursts of body size and shape evolution are rare in comparative data. <b>64</b>, 2385-2396.
</p>
<p>Hunt G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond. Paleobiology. <b>32</b>, 578-601. DOI: 10.1666/05070.1.
</p>
<p>Hunt G, Hopkins MJ &amp; Lidgard S. 2015. Simple versus complex models of trait evolution and stasis as a response to environmental change. Proceedings of the National Academy of Sciences. <b>112</b>, 4885-4890. DOI: 10.1073/pnas.1403662111
</p>
<p>Felsenstein J. 1973. Maximum-likelihood estimation of evolutionary trees from continuous characters. American Journal of Human Genetics. <b>25</b>, 471-492.
</p>
<p>Felsenstein J. 1985. Phylogenies and the comparative method. The American Naturalist. <b>51</b>, 1-15.
</p>
<p>Murrell DJ. 2018. A global envelope test to detect non-random bursts of trait evolution. Methods in Ecology and Evolution. DOI: 10.1111/2041-210X.13006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.test">model.test</a></code>, <code><a href="#topic+model.test.sim">model.test.sim</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code> and <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Mammal disparity through time
data(BeckLee_disparity)

## The models to be fit to disparity data
models &lt;- list("BM", "OU", "multi.OU", "Trend")

## test all models, and assess the significance of simulated data
## against the empirical distribution for each
model.test.wrapper(data = BeckLee_disparity, model = models, fixed.optima = TRUE,
                   time.split = 66, show.p = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='multi.ace'>Ancestral states estimations with multiple trees</h2><span id='topic+multi.ace'></span>

<h3>Description</h3>

<p>Fast ancestral states estimations run on multiple trees using the Mk model from castor::asr_mk_model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.ace(
  data,
  tree,
  models = "ER",
  threshold = TRUE,
  special.tokens,
  special.behaviours,
  brlen.multiplier,
  verbose = FALSE,
  parallel = FALSE,
  output,
  castor.options,
  estimation.details = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi.ace_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or <code>list</code> with the characters for each taxa.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> or <code>mutiPhylo</code> object (if the <code>tree</code> argument contains node labels, they will be used to name the output).</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_models">models</code></td>
<td>
<p>A <code>vector</code> of models to be passed to <code>castor::asr_mk_model</code>.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_threshold">threshold</code></td>
<td>
<p>either <code>logical</code> for applying a relative threshold (<code>TRUE</code> - default) or no threshold (<code>FALSE</code>) or a <code>numeric</code> value of the threshold (e.g. 0.95). See details.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_special.tokens">special.tokens</code></td>
<td>
<p>optional, a named <code>vector</code> of special tokens to be passed to <code><a href="base.html#topic+grep">grep</a></code> (make sure to protect the character with <code>"\\"</code>). By default <code>special.tokens &lt;- c(missing = "\\?", inapplicable = "\\-", polymorphism = "\\&amp;", uncertainty = "\\/")</code>. Note that <code>NA</code> values are not compared and that the symbol &quot;@&quot; is reserved and cannot be used.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_special.behaviours">special.behaviours</code></td>
<td>
<p>optional, a <code>list</code> of one or more functions for a special behaviour for <code>special.tokens</code>. See details.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_brlen.multiplier">brlen.multiplier</code></td>
<td>
<p>optional, a vector of branch length modifiers (e.g. to convert time branch length in changes branch length) or a list of vectors (the same length as <code>tree</code>).</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>, whether to be verbose (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code>, whether to use parallel algorithm (<code>TRUE</code>) or not (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_output">output</code></td>
<td>
<p>optional, see Value section below.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_castor.options">castor.options</code></td>
<td>
<p>optional, a named list of options to be passed to function called by <code>castor::asr_mk_model</code>.</p>
</td></tr>
<tr><td><code id="multi.ace_+3A_estimation.details">estimation.details</code></td>
<td>
<p>optional, whether to also return the details for each estimation as returned by <code>castor::asr_mk_model</code>. This argument can be left <code>NULL</code> (default) or be any combination of the elements returned by <code>castor::asr_mk_model</code> (e.g. <code>c("loglikelihood", "transition_matrix")</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>models</code> argument can be a single or a list of transition <code>matrix</code>, a single or a a vector of built-in model(s) (see below) or a list of both matrices and built-in models:
The available built-in models in <code>castor::asr_mk_model</code> are:
</p>

<ul>
<li> <p><code>"ER"</code> for all equal rates
</p>
</li>
<li> <p><code>"SYM"</code> for symmetric rates
</p>
</li>
<li> <p><code>"ARD"</code> all rates are different
</p>
</li>
<li> <p><code>"SUEDE"</code> equal stepwise transitions (e.g. for meristic/counting characters)
</p>
</li>
<li> <p><code>"SRD"</code> different stepwise transitions 
</p>
</li></ul>

<p>See directly <code>castor::asr_mk_model</code> for more models.
</p>
<p>The <code>threshold</code> option allows to convert ancestral states likelihoods into discrete states. When <code>threshold = FALSE</code>, the ancestral state estimated is the one with the highest likelihood (or at random if likelihoods are equal). When <code>threshold = TRUE</code>, the ancestral state estimated are all the ones that are have a scaled likelihood greater than the maximum observed scaled likelihood minus the inverse number of possible states (i.e. <code>select_state &gt;= (max(likelihood) - 1/n_states)</code>). This option makes the threshold selection depend on the number of states (i.e. if there are more possible states, a lower scaled likelihood for the best state is expected). Finally using a numerical value for the threshold option (e.g. <code>threshold = 0.95</code>) will simply select only the ancestral states estimates with a scaled likelihood equal or greater than the designated value. This option makes the threshold selection absolute. Regardless, if more than one value is select, the uncertainty token (<code>special.tokens["uncertainty"]</code>) will be used to separate the states. If no value is selected, the uncertainty token will be use between all observed characters (<code>special.tokens["uncertainty"]</code>).
</p>
<p><code>special.behaviours</code> allows to generate a special rule for the <code>special.tokens</code>. The functions should can take the arguments <code>character, all_states</code> with <code>character</code> being the character that contains the special token and <code>all_states</code> for the character (which is automatically detected by the function). By default, missing data returns and inapplicable returns all states, and polymorphisms and uncertainties return all present states.
</p>

<ul>
<li><p><code>missing = function(x,y) y</code>
</p>
</li>
<li><p><code>inapplicable = function(x,y) y</code>
</p>
</li>
<li><p><code>polymorphism = function(x,y) strsplit(x, split = "\\&amp;")[[1]]</code>
</p>
</li>
<li><p><code>uncertainty = function(x,y) strsplit(x, split = "\\/")[[1]]</code>
</p>
</li></ul>

<p>Functions in the list must be named following the special token of concern (e.g. <code>missing</code>), have only <code>x, y</code> as inputs and a single output a single value (that gets coerced to <code>integer</code> automatically). For example, the special behaviour for the special token <code>"?"</code> can be coded as: <code>special.behaviours = list(missing = function(x, y) return(NA)</code> to make ignore the character for taxa containing <code>"?"</code>. 
</p>
<p>When using the parallel option (either through using <code>parallel = TRUE</code> by using the number of available cores minus on or manually setting the number of cores - e.g. <code>parallel = 5</code>), the <code>castor::asr_mk_model</code> function will use the designated number of cores (using the option <code>Nthreads = &lt;requested_number_of_cores&gt;</code>). Additionally, if the input <code>tree</code> is a <code>"multiPhylo"</code> object, the trees will be run in parallel for each number of cores, thus decreasing computation time accordingly (e.g. if 3 cores are requested and <code>tree</code> contains 12 <code>"phylo"</code> objects, 4 different <code>"phylo"</code> objects will be run in parallel on the 3 cores making the calculation around 3 times faster).
</p>


<h3>Value</h3>

<p>Returns a <code>"matrix"</code> or <code>"list"</code> of ancestral states. By default, the function returns the ancestral states in the same format as the input <code>matrix</code>. This can be changed using the option <code>output = "matrix"</code> or <code>"list"</code> to force the class of the output.
To output the combined ancestral states and input, you can use <code>"combined"</code> (using the input format) or <code>"combined.matrix"</code> or <code>"combined.list"</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code>castor::asr_mk_model</code>, <code>char.diff</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
## A simple example:
## A random tree with 10 tips
tree &lt;- rcoal(10)
## Setting up the parameters
my_rates = c(rgamma, rate = 10, shape = 5)

## A random Mk matrix (10*50)
matrix_simple &lt;- sim.morpho(tree, characters = 50, model = "ER", rates = my_rates,
                            invariant = FALSE)

## Run a basic ancestral states estimations
ancestral_states &lt;- multi.ace(matrix_simple, tree)
ancestral_states[1:5, 1:5]

## A more complex example
## Create a multiple list of 5 trees
multiple_trees &lt;- rmtree(5, 10)

## Modify the matrix to contain missing and special data
matrix_complex &lt;- matrix_simple
matrix_complex[sample(1:length(matrix_complex), 50)] &lt;- "-"
matrix_complex[sample(1:length(matrix_complex), 50)] &lt;- "0%2"
matrix_complex[sample(1:length(matrix_complex), 50)] &lt;- "?"
matrix_complex[1:5,1:5]

## Set a list of extra special tokens
my_spec_tokens &lt;- c("weirdtoken" = "%")

## Set some special behaviours for the "weirdtoken" and for "-" and "?"
my_spec_behaviours &lt;- list()
## Inapplicable tokens "-" are ignored
my_spec_behaviours$inapplicable &lt;- function(x,y) return(NA)
## Missing tokens "?" are considered as all states
my_spec_behaviours$missing      &lt;- function(x,y) return(y)
## Weird tokens are considered as state 0 and 3
my_spec_behaviours$weirdtoken   &lt;- function(x,y) return(c(1,2))

## Create a random branch length modifier to apply to each tree
branch_lengths &lt;- rnorm(18)^2

## Setting a list of model ("ER" for the 25 first characters and then "SYM")
my_models &lt;- c(rep("ER", 25), rep("SYM", 25))

## Run the ancestral states on all the tree with multiple options
ancestral_states &lt;- multi.ace(matrix_complex, multiple_trees,
                              verbose = TRUE,
                              models = my_models,
                              threshold = 0.95,
                              special.tokens = my_spec_tokens,
                              special.behaviours = my_spec_behaviours,
                              brlen.multiplier = branch_lengths,
                              output = "combined.matrix")

## The results for the the two first characters for the first tree
ancestral_states[[1]][, 1:2]

## Not run: 
## The same example but running in parallel
ancestral_states &lt;- multi.ace(matrix_complex, multiple_trees,
                              verbose = TRUE,
                              models = my_models,
                              threshold = 0.95,
                              special.tokens = my_spec_tokens,
                              special.behaviours = my_spec_behaviours,
                              brlen.multiplier = branch_lengths,
                              output = "combined.matrix",
                              parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='null.test'>Testing a null hypothesis on multidimensional data.</h2><span id='topic+null.test'></span>

<h3>Description</h3>

<p>Testing the difference between the observed disparity and disparity under a null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.test(
  data,
  replicates = 100,
  null.distrib,
  null.args = NULL,
  null.cor = NULL,
  null.scree = NULL,
  alter = "two-sided",
  scale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.test_+3A_data">data</code></td>
<td>
<p>a <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="null.test_+3A_replicates">replicates</code></td>
<td>
<p>the number of replicates for the test (default = <code>100</code>).</p>
</td></tr>
<tr><td><code id="null.test_+3A_null.distrib">null.distrib</code></td>
<td>
<p>one or more distribution functions to generate the null model to be passed to <code><a href="#topic+space.maker">space.maker</a></code>.</p>
</td></tr>
<tr><td><code id="null.test_+3A_null.args">null.args</code></td>
<td>
<p>any additional distribution arguments to be passed to <code><a href="#topic+space.maker">space.maker</a></code> (see <code>arguments</code> within; <code>default = NULL</code>).</p>
</td></tr>
<tr><td><code id="null.test_+3A_null.cor">null.cor</code></td>
<td>
<p>an additional correlation matrix to be passed to <code><a href="#topic+space.maker">space.maker</a></code> (see <code>cor.matrix</code> within; <code>default = NULL</code>).</p>
</td></tr>
<tr><td><code id="null.test_+3A_null.scree">null.scree</code></td>
<td>
<p>an additional vector of variance per axis (equivalent to <a href="stats.html#topic+screeplot">screeplot</a> output); <code>default = NULL</code>).</p>
</td></tr>
<tr><td><code id="null.test_+3A_alter">alter</code></td>
<td>
<p>the type of alternative hypothesis (H1) as used in <code><a href="ade4.html#topic+randtest">randtest</a></code> (<code>default = "two-sided"</code>).</p>
</td></tr>
<tr><td><code id="null.test_+3A_scale">scale</code></td>
<td>
<p>whether to scale the simulated and the observed data.</p>
</td></tr>
<tr><td><code id="null.test_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="ade4.html#topic+as.randtest">as.randtest</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Diaz, S., Kattge, J., Cornelissen, J.H., Wright, I.J., Lavorel, S., Dray, S., Reu, B., Kleyer, M., Wirth, C., Prentice, I.C. and Garnier, E., <b>2016</b>. The global spectrum of plant form and function. Nature, 529(7585), pp.167-171.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+space.maker">space.maker</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_mat50)
## Calculating the disparity as the ellipsoid volume
obs_disparity &lt;- dispRity(BeckLee_mat50, metric = ellipsoid.volume)
## Testing against normal distribution
results &lt;- null.test(obs_disparity, replicates = 100, null.distrib = rnorm)
results ; plot(results)

## Running the test on multiple subsets (may take some time!)
## Generating the subsets
groups &lt;- as.data.frame(matrix(data = c(rep(1, 12), rep(2, 13), rep(3, 12),
     rep(4, 13)), dimnames = list(rownames(BeckLee_mat50))), ncol = 1)
customised_subsets &lt;- custom.subsets(BeckLee_mat50, groups)
## Bootstrapping the data
bootstrapped_data &lt;- boot.matrix(customised_subsets, bootstraps = 100)
## Calculating variances of each dimension
sum_variances &lt;- dispRity(bootstrapped_data, metric = c(sum, variances))
## Testing against normal distribution
results &lt;- null.test(sum_variances, replicates = 100, null.distrib = rnorm)
summary(results) ; plot(results)

</code></pre>

<hr>
<h2 id='pair.plot'>Plots pairwise comparisons</h2><span id='topic+pair.plot'></span>

<h3>Description</h3>

<p>Plots pairwise comparisons from a data frame (typically output from <code><a href="#topic+test.dispRity">test.dispRity</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.plot(
  data,
  what,
  col = c("black", "white"),
  legend = FALSE,
  binary,
  diag,
  add,
  lower = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.plot_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or a <code>data.frame</code> object with comparisons' pair names as row names. The number of rows must be equal to a pairwise combination of <code>n</code> elements (see details).</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_what">what</code></td>
<td>
<p>A <code>numeric</code> or <code>character</code> value designating which column to plot.</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_col">col</code></td>
<td>
<p>The two extremes of a color gradient (default = <code>c("black", "white")</code>).</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_legend">legend</code></td>
<td>
<p>Logical, whether to plot the legend or not.</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_binary">binary</code></td>
<td>
<p>Optional, if the results must be binary, a <code>numeric</code> value for the threshold of acceptance (values greater will be 1, lower will be 0).</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_diag">diag</code></td>
<td>
<p>Optional, can be <code>"max"</code> or <code>"min"</code> or a single <code>numeric</code> value.</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_add">add</code></td>
<td>
<p>Optional, whether to add significance tokens can be <code>numeric</code> for a point type to print (<code>pch</code>) or <code>"character"</code> to print (e.g. <code>"*"</code>).</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_lower">lower</code></td>
<td>
<p>Optional, logical, whether to add tokens for values lower than <code>binary</code> (default is <code>TRUE</code>; <code>FALSE</code> will add tokens for values bigger than <code>binary</code>).</p>
</td></tr>
<tr><td><code id="pair.plot_+3A_...">...</code></td>
<td>
<p>Any other options to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of rows (i.e. comparisons) in <code>matrix</code> must be equal to the results of a pairwise combination.
In general, the number of rows <code>x</code> must satisfy the equation: <code class="reqn">x  = n^2 / 2 - n / 2</code> where <code>n</code> must be an integer greater or equal than 2.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.dispRity">test.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A small matrix of two pairwise comparisons of seven elements (2*21 comparisons)
data &lt;- matrix(data = runif(42), ncol = 2)

## Plotting the first column as a pairwise comparisons
pair.plot(data, what = 1, col = c("orange", "blue"), legend = TRUE, diag = 1)

## Adding some tokens for each value below 0.2 in the second column
pair.plot(data, what = 2, binary = 0.2, add = "*", cex = 2)

## Loading disparity data
data(disparity)

## Testing the pairwise difference between slices
tests &lt;- test.dispRity(disparity, test = wilcox.test, correction = "bonferroni")

## Plotting the significance
pair.plot(as.data.frame(tests), what = "p.value", binary = 0.05)

</code></pre>

<hr>
<h2 id='pgls.dispRity'>phylolm dispRity (from <code>phylolm::phylolm</code>)</h2><span id='topic+pgls.dispRity'></span>

<h3>Description</h3>

<p>Passing <code>dispRity</code> objects to the <code><a href="phylolm.html#topic+phylolm">phylolm</a></code> function from the <code>phylolm</code> package. Typically to run some PGLS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.dispRity(data, tree, formula, model = "BM", ..., optim = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.dispRity_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object with a metric of dimension level 2 at least</p>
</td></tr>
<tr><td><code id="pgls.dispRity_+3A_tree">tree</code></td>
<td>
<p>If <code>data</code> does not contain a tree component, a <code>"phylo"</code> or <code>"multiPhylo"</code> object to be used as the tree. If <code>data</code> already contains a tree component and the <code>tree</code> argument is not missing, the provided <code>tree</code> will replace any contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="pgls.dispRity_+3A_formula">formula</code></td>
<td>
<p>The PGLS formula. If left empty, runs either <code>disparity ~ 1</code> or <code>disparity ~ subsets</code> if <code>data</code> contains subsets.</p>
</td></tr>
<tr><td><code id="pgls.dispRity_+3A_model">model</code></td>
<td>
<p>The covariance model (default is <code>"BM"</code>). For more details (including the models available) see the manual for <code><a href="phylolm.html#topic+phylolm">phylolm</a></code>.</p>
</td></tr>
<tr><td><code id="pgls.dispRity_+3A_...">...</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="phylolm.html#topic+phylolm">phylolm</a></code></p>
</td></tr>
<tr><td><code id="pgls.dispRity_+3A_optim">optim</code></td>
<td>
<p>An optional named list of arguments to be passed to the function <code>optim</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> needs to be expressed by always naming the response variable <code>disparity</code> to use the calculated disparity data from <code>data</code>.
</p>
<p>Optional arguments <code>...</code> correspond to all the non-ambiguous named arguments from the <code><a href="phylolm.html#topic+phylolm">phylolm</a></code>. Optional arguments for the internal <code>optim</code> function can be passed as a named list to the <code>optim</code> argument.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="phylolm.html#topic+phylolm">phylolm</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example
data(BeckLee_mat50)
data(BeckLee_tree)
disparity &lt;- dispRity(BeckLee_mat50, metric = centroids, tree = BeckLee_tree)

## Running a simple PGLS
model &lt;- pgls.dispRity(disparity)
summary(model)

## More complex example running a PGLS
## on multiple trees and using groups as a predictor 

</code></pre>

<hr>
<h2 id='plot.char.diff'>Plots character differences</h2><span id='topic+plot.char.diff'></span>

<h3>Description</h3>

<p>Plots a character difference matrix from a discrete character matrix or its character differences density profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'char.diff'
plot(
  x,
  ...,
  type = "matrix",
  legend = TRUE,
  legend.title = "Difference",
  legend.pos = "topleft",
  legend.round = 0,
  axis = TRUE,
  xlim,
  ylim,
  xlab,
  ylab,
  col,
  main
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.char.diff_+3A_x">x</code></td>
<td>
<p>A discrete matrix or an already computed character difference matrix of class <code>char.diff</code>.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_...">...</code></td>
<td>
<p>Any additional graphical arguments to be passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_type">type</code></td>
<td>
<p>Either <code>"matrix"</code> (or <code>"m"</code>) or <code>"density"</code> (or <code>"d"</code>) for respectively plotting the matrix of character differences or its character differences density profile.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_legend">legend</code></td>
<td>
<p>A logical value stating whether to print the legend or not (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_legend.title">legend.title</code></td>
<td>
<p>A <code>character</code> string to be displayed as the title of the legend (default = <code>Difference</code>).</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_legend.pos">legend.pos</code></td>
<td>
<p>The position of the legend. Can be two <code>numeric</code>. Default is <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_legend.round">legend.round</code></td>
<td>
<p>A <code>numeric</code> value for digits up legend values. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_axis">axis</code></td>
<td>
<p>A logical value stating whether to print the axis or not (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_xlim">xlim</code></td>
<td>
<p>Two <code>numeric</code> values to determine the x axis limits. If missing (default), the limits are calculated automatically to fit the plot window.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> values to determine the y axis limits. If missing (default), the limits are calculated automatically to fit the plot window.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_xlab">xlab</code></td>
<td>
<p>A <code>character</code> string for the the x axis. Can be missing.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_ylab">ylab</code></td>
<td>
<p>A <code>character</code> string for the the y axis. Can be missing.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_col">col</code></td>
<td>
<p>Two colors for forming the gradient if <code>type = "correlation"</code> or for the density lines colors if <code>type = "density"</code>.</p>
</td></tr>
<tr><td><code id="plot.char.diff_+3A_main">main</code></td>
<td>
<p>An overall title for the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+char.diff">char.diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparing two characters
char.diff(list(c(0, 1, 0, 1), c(0, 1, 1, 1)))

## Pairwise comparisons in a morphological matrix
morpho_matrix &lt;- matrix(sample(c(0,1), 100, replace = TRUE), 10)

## Plotting a matrix
plot.char.diff(morpho_matrix)

## Plotting the density profile of a char.diff object
char.diff_matrix &lt;- char.diff(morpho_matrix)
plot(char.diff_matrix, type = "density")

</code></pre>

<hr>
<h2 id='plot.dispRity'>dispRity object plotting</h2><span id='topic+plot.dispRity'></span>

<h3>Description</h3>

<p>Plots a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
plot(
  x,
  ...,
  type,
  quantiles = c(50, 95),
  cent.tend = median,
  rarefaction = NULL,
  elements = FALSE,
  observed = FALSE,
  add = FALSE,
  density = NULL,
  specific.args
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dispRity_+3A_x">x</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_...">...</code></td>
<td>
<p>Any optional arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>. See details.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_type">type</code></td>
<td>
<p>Either <code>"continuous"</code>, <code>"box"</code>, <code>"line"</code>, <code>"polygon"</code> or <code>"space"</code>. When unspecified, if no disparity was calculated, <code>"preview"</code> is used. If disparity was calculated, <code>"continuous"</code> is used for <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> and <code>"box"</code> for <code><a href="#topic+custom.subsets">custom.subsets</a></code>. See details.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to display (default is <code>quantiles = c(50, 95)</code>; is ignored if the <code>dispRity</code> object is not bootstrapped).</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_cent.tend">cent.tend</code></td>
<td>
<p>A function for summarising the bootstrapped disparity values (default is <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_rarefaction">rarefaction</code></td>
<td>
<p>Either <code>NULL</code> (default) or <code>FALSE</code> for not using the rarefaction scores; a <code>numeric</code> value of the level of rarefaction to plot; or <code>TRUE</code> for plotting the rarefaction curves.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_elements">elements</code></td>
<td>
<p><code>logical</code> whether to plot the number of elements per subsets (default is <code>FALSE</code>) or a <code>list</code> of any of the graphical arguments <code>"col"</code>, <code>"pch"</code> and/or <code>"cex"</code>.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_observed">observed</code></td>
<td>
<p><code>logical</code> whether to add the observed values on the plot as crosses (default is <code>FALSE</code>) or a <code>list</code> of any of the graphical arguments <code>"col"</code>, <code>"pch"</code> and/or <code>"cex"</code>.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_add">add</code></td>
<td>
<p><code>logical</code> whether to add the new plot an existing one (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_density">density</code></td>
<td>
<p>the density of shading lines to be passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>. Is ignored if <code>type = "box"</code> or <code>type = "line"</code>.</p>
</td></tr>
<tr><td><code id="plot.dispRity_+3A_specific.args">specific.args</code></td>
<td>
<p>optional, a named list of arguments to be passed for some specific plot types. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying optional arguments with <code>...</code> in a graph with multiple elements (e.g. <code>points</code>, <code>lines</code>, etc...) you can specify which specific element to affect using the syntax <code>&lt;element&gt;.&lt;argument&gt;</code>. For example if you want everything in the plot to be in blue at the exception of the points to be red, you can use <code>plot(..., col = "blue", points.col = "red")</code>. 
</p>
<p>The different <code>type</code> arguments are:
</p>

<ul>
<li> <p><code>"continuous"</code>: plots the results as a continuous line.
</p>
</li>
<li> <p><code>"box"</code>: plots the results as discrete box plots (note that this option ignores the user set quantiles and central tendency).
</p>
</li>
<li> <p><code>"line"</code>: plots the results as discrete vertical lines with the user's set quantiles and central tendency.
</p>
</li>
<li> <p><code>"polygon"</code>: identical as <code>"line"</code> but using polygons rather than vertical lines.
</p>
</li>
<li> <p><code>"preview"</code>: plots two dimensional preview of the space (default is <code>c(1,2)</code>). WARNING: the plotted dimensions might not be representative of the full multi-dimensional space!
</p>
</li></ul>

<p>The different <code>specific.args</code> arguments for the following options are:
</p>

<ul>
<li><p> if <code>type = "preview"</code>, the specific arguments can be:
</p>

<ul>
<li> <p><code>dimensions</code>: two specific dimensions to plot (default is <code>specific.args = list(dimensions = c(1,2)</code>);
</p>
</li>
<li> <p><code>matrix</code>: which specific matrix to plot the data from (by default, all the matrices are used).
</p>
</li>
<li> <p><code>tree</code>: whether to plot the underlying tree(s) or not. Can be either logical, whether to plot no tree (default is <code>specific.args = list(tree = FALSE)</code>), all trees (<code>specific.args = list(tree = TRUE)</code>) or a specific set of trees (e.g. <code>specific.args = list(tree = c(1,2))</code>)
</p>
</li></ul>
 
</li>
<li><p> if data is a <code>"test.metric"</code> result that was obtained with the option <code>save.steps = TRUE</code> (see <code><a href="#topic+test.metric">test.metric</a></code>), it is possible to specify which steps to by specifying the following specific argument: <code>specific.args = list(visualise.steps = c(1,4,5))</code> for visualising steps 1, 4 and 5 of the different shifts. By default, if the <code>"test.metric"</code> was obtained with the option <code>save.steps = TRUE</code>, four steps are displayed.
</p>
</li>
<li><p> if data is a <code>"dispRity"</code> and <code>"projection"</code> object (from <code><a href="#topic+dispRity.covar.projections">dispRity.covar.projections</a></code>), it is possible to plot either the boxplot of disparity values for each projection (using <code>correlation.plot = NULL</code>; default) or to plot the correlation between two calculated elements (e.g. <code>correlation.plot = c("position", "distance")</code>).
</p>
</li></ul>

<p>When plotting <code>"randtest"</code> or <code>"test.metric"</code> data or when using <code>type = "preview"</code> a legend is plotted by default. To remove the legend you can use the argument <code>legend = FALSE</code>. You can control specific arguments for the legend using the <code>...</code> optional arguments preceded by <code>legend.</code>. For example, to change the legend position you can use <code>legend.x = "topleft"</code> or <code>legend.x = 4.2</code> and <code>legend.y = 1.23</code>. General <code>legend</code> arguments such as <code>col</code>, <code>legend</code>, <code>pch</code>, etc... are recycled by the function but can always be specified using this syntax.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>, <code><a href="#topic+null.test">null.test</a></code>, <code><a href="#topic+dtt.dispRity">dtt.dispRity</a></code>, <code><a href="#topic+model.test">model.test</a></code>, <code><a href="#topic+model.test.sim">model.test.sim</a></code>, <code><a href="#topic+test.metric">test.metric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## Discrete plotting
plot(disparity, type = "box")

## Using polygons rather than boxes (quantiles and central tendency can be
## set by the user)
plot(disparity, type = "polygon", quantiles = c(10, 50, 95),
     cent.tend = mean)

## Using different options
plot(disparity, type = "line", elements = TRUE, ylim = c(0, 3),
     xlab = ("Time (Ma)"), ylab = "disparity")

## Continuous plotting (all default options)
plot(disparity, type = "continuous")
 
## Rarefactions plots
plot(disparity, rarefaction = TRUE)

## Observed data
plot(disparity, observed = TRUE)

## Observed data with graphical details
plot(disparity, observed = list("pch" = 19, col = "blue", cex = 4))

## For plotting dispRity objects with the dual classes "randtest", "dtt",
## "model.test", "model.sim" and "test.metric" see the examples
## in the specific function manuals from the "See also" section above

</code></pre>

<hr>
<h2 id='print.dispRity'>Prints a <code>dispRity</code> object.</h2><span id='topic+print.dispRity'></span>

<h3>Description</h3>

<p>Summarises the content of a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
print(x, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dispRity_+3A_x">x</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="print.dispRity_+3A_all">all</code></td>
<td>
<p><code>logical</code>; whether to display the entire object (<code>TRUE</code>) or just summarise its contents (<code>FALSE</code> - default).</p>
</td></tr>
<tr><td><code id="print.dispRity_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>print</code> or to <code>print.dispRity</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>, <code><a href="#topic+boot.matrix">boot.matrix</a></code>, <code><a href="#topic+dispRity">dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## Displaying the summary of the object content
disparity
print(disparity) # the same
print.dispRity(disparity) # the same

## Displaying the full object
print.dispRity(disparity, all = TRUE)

</code></pre>

<hr>
<h2 id='random.circle'>Random circle</h2><span id='topic+random.circle'></span>

<h3>Description</h3>

<p>Creates coordinates for a random circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.circle(n, distribution, inner = 0, outer = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.circle_+3A_n">n</code></td>
<td>
<p>The number of pairs x,y of coordinates.</p>
</td></tr>
<tr><td><code id="random.circle_+3A_distribution">distribution</code></td>
<td>
<p>The distribution from which the coordinates are sampled.</p>
</td></tr>
<tr><td><code id="random.circle_+3A_inner">inner</code></td>
<td>
<p>Optional, the radius for an empty inner circle.</p>
</td></tr>
<tr><td><code id="random.circle_+3A_outer">outer</code></td>
<td>
<p>Optional, the maximum radius for the circle.</p>
</td></tr>
<tr><td><code id="random.circle_+3A_...">...</code></td>
<td>
<p>Any additional argument to be passed to <code>distribution</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+space.maker">space.maker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple uniform circle
plot(random.circle(1000, runif), pch = 20)

## A normal ring with inner and outer boundaries
plot(random.circle(1000, rnorm, inner = 0.5, outer = 5), pch = 20)

</code></pre>

<hr>
<h2 id='randtest.dispRity'>Random (permutation) test</h2><span id='topic+randtest.dispRity'></span>

<h3>Description</h3>

<p>Performs a random test (aka permutation test) on a <code>matrix</code> or a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
randtest(
  xtest,
  subsets,
  metric,
  replicates = 100,
  resample = TRUE,
  alter = "two-sided",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.dispRity_+3A_xtest">xtest</code></td>
<td>
<p>The <code>matrix</code> or a <code>dispRity</code> object to draw from.</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_subsets">subsets</code></td>
<td>
<p>A <code>vector</code> of elements to test (or a <code>list</code> of <code>vectors</code> - see details).</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_metric">metric</code></td>
<td>
<p>A <code>function</code> to be the statistic to apply to the subset.</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_replicates">replicates</code></td>
<td>
<p>A <code>numeric</code> value for the number of replicates (<code>default = 100</code>).</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_resample">resample</code></td>
<td>
<p><code>logical</code> whether to resample the full distribution (<code>TRUE</code>; default) or the distribution without the subset (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_alter">alter</code></td>
<td>
<p>The alternative hypothesis. Can be <code>"two-sided"</code> (default), <code>"greater"</code> or <code>"lesser"</code>.</p>
</td></tr>
<tr><td><code id="randtest.dispRity_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>metric</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test checks whether the metric calculated on a given subset of the data is significantly different from the metric calculated on any random subset of the same size.
In other words: does the given subset have a clearly different disparity value than the rest of the data?
</p>
<p>First, the <code>metric</code> (statistic) is applied to the <code>subset</code> sampled from the <code>data</code> (population).
Second, the <code>metric</code> is applied to random equally sized subsets from the <code>data</code>.
If the observed difference falls out of the random differences distribution, the differences are significant.
This algorithm is based on a similar procedure than in <code>link[ade4]{rantest}</code>.
</p>
<p>If <code>data</code> is a <code>dispRity</code> object, the <code>subsets</code>, <code>metric</code> and <code>replicates</code> can be left missing and are automatically inherited from the <code>dispRity</code> if it contains respectively subsets (from <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> or <code><a href="#topic+custom.subsets">custom.subsets</a></code>) a <code>metric</code> (from <code><a href="#topic+dispRity">dispRity</a></code>) and bootstrap draws (from <code>boot.matrix</code>).
</p>
<p>If <code>data</code> is a <code>dispRity</code> object subsets can be a list of subsets to compare for example <code>list(c("A", "B"), c("B", "A"))</code> will run two tests comparing respectively sample A to B and B to A. <em>Note</em> that it will only compare these two samples and use their combined size as the population size, if you want to compare a subset to all the subsets you can use <code>list(c("A")</code> or write down the specific subsets to be used.
</p>


<h3>Value</h3>

<p>This function returns a <code>"randtest"</code> object that can be passed to the generic S3 functions <code><a href="ade4.html#topic+print.randtest">print.randtest</a></code> or <code><a href="ade4.html#topic+plot.randtest">plot.randtest</a></code>.
The output also contains to extra elements <code>output$observed</code> and <code>output$random</code> containing the raw results of respectively the observed and random tests.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="ade4.html#topic+randtest">randtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example
dummy_matrix &lt;- matrix(rnorm(500), 100, 5)

## Testing whether the mean of a random subset
## is different than the means of 100 subsets
dummy_test &lt;- randtest.dispRity(dummy_matrix,
                                subset = sample(1:100, 20),
                                metric = mean)
dummy_test ; plot(dummy_test)

## Applying this on dispRity objects
data(disparity)
test_disparity &lt;- test.dispRity(disparity,
                                test = randtest.dispRity)

## The summarised results
summary(test_disparity)

## Plotting the results
plot(test_disparity)

## Applying this on a dispRity object with specific subset comparisons
test_disparity2 &lt;- randtest.dispRity(disparity, subsets = list(
     ## Comparing subset 90 to the whole population (traitspace)
     c(observed = "90"),
     ## Comparing subset "70" to "90", "70" and "30"
     c(observed = "70", random = c("90", "70", "30"))))

## Summarising and plotting the results
summary(test_disparity2)
plot(test_disparity2)

</code></pre>

<hr>
<h2 id='reduce.matrix'>Reduce a matrix</h2><span id='topic+reduce.matrix'></span>

<h3>Description</h3>

<p>Reduce the number of rows/columns in a matrix to optimise overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.matrix(matrix, distance = "gower", by.row = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.matrix_+3A_matrix">matrix</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="reduce.matrix_+3A_distance">distance</code></td>
<td>
<p>which distance to consider (passed to <code><a href="vegan.html#topic+vegdist">vegdist</a></code>, default = <code>"gower"</code>)</p>
</td></tr>
<tr><td><code id="reduce.matrix_+3A_by.row">by.row</code></td>
<td>
<p>Whether to do it by rows (<code>TRUE</code> - default), or by columns (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="reduce.matrix_+3A_verbose">verbose</code></td>
<td>
<p>Whether to do be verbose (<code>TRUE</code>) or not (<code>FALSE</code> - default)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## A 10*5 matrix
na_matrix &lt;- matrix(rnorm(50), 10, 5)
## Making sure some rows don't overlap
na_matrix[1, 1:2] &lt;- NA
na_matrix[2, 3:5] &lt;- NA
## Adding 50% NAs
na_matrix[sample(1:50, 25)] &lt;- NA
## Illustrating the gappy matrix
image(t(na_matrix), col = "black")

## Reducing the matrix by row
(reduction &lt;- reduce.matrix(na_matrix))
## Illustrating the overlapping matrix
image(t(na_matrix[-as.numeric(reduction$rows.to.remove), ]), col = "black")

## Reducing the matrix by columns (and being verbose)
reduce.matrix(na_matrix, by.row = FALSE, verbose = TRUE)

</code></pre>

<hr>
<h2 id='reduce.space'>Reduce space</h2><span id='topic+reduce.space'></span>

<h3>Description</h3>

<p>Remove elements from a multidimensional space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.space(
  space,
  type,
  remove,
  parameters,
  tuning,
  verbose = FALSE,
  return.optim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.space_+3A_space">space</code></td>
<td>
<p>the trait space</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_type">type</code></td>
<td>
<p>how to reduce the space (either <code>"random"</code>, <code>"size"</code>, <code>"density"</code>, <code>"evenness"</code> or <code>"position"</code>)</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_remove">remove</code></td>
<td>
<p>the proportion of elements to be removed (in probability)</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_parameters">parameters</code></td>
<td>
<p>the parameter(s) for removal selection (see details). If left empty, the <code>parameters</code> is estimated to reach the amount set by <code>remove</code>.</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_tuning">tuning</code></td>
<td>
<p>Optinal parameters for tuning the parameter estimations (if remove is required and parameters is missing) a list of three parameters: &quot;max&quot; for the maximum of operations, &quot;tol&quot; for the tuning (e.g. 0.1 close), &quot;inc.steps&quot; for the initial increment value during optimisation (default = 2 - the bigger the value, the slower the increment).</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_verbose">verbose</code></td>
<td>
<p>wether to be verbose or not</p>
</td></tr>
<tr><td><code id="reduce.space_+3A_return.optim">return.optim</code></td>
<td>
<p>logical, whether to also return the optimal value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type of reductions algorithms select the proportion of elements to remove (from the <code>remove</code> parameter). The different algorithms are:
</p>

<ul>
<li> <p><code>"random"</code> for randomly selecting a proportion of data points (using <code>sample(..., replace = FALSE)</code>).
</p>
</li>
<li> <p><code>"size"</code> for selecting the proportion of data points closer to the centre.
</p>
</li>
<li> <p><code>"density"</code> for selecting the proportion of data points with the lower nearest neigbhour distances.
</p>
</li>
<li> <p><code>"evenness"</code> for randomly selecting the proportion of data points from the regions with most density.
</p>
</li></ul>

<p>The parameters for each reduction type algorithms are:
</p>

<ul>
<li> <p><code>"size"</code> parameters: a list of <code>parameters$centre</code>, the centre from which to count the radius (if missing, is set to <code>0</code>); and <code>parameters$radius</code>, the radius for removal.
</p>
</li>
<li> <p><code>"density"</code> parameters: a list of <code>parameters$what</code> &quot;close&quot; (default) for close neighbours or &quot;distant&quot; for distant ones; <code>parameters$diameter</code> the diameter for considering closeness or distance; <code>parameters$output</code> either &quot;singles&quot; or &quot;pairs&quot; to return the pairs of neighbours or one of them only (the first).
</p>
</li>
<li> <p><code>"position"</code> parameters: a list of <code>parameters$value</code>, value the threshold value from which to remove elements.
</p>
</li>
<li> <p><code>"evenness"</code> parameters: a list of <code>parameters$bw</code>, a bandwith selector function (<code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code> by default); and <code>parameters$power</code> a scaling factor for exaggerating the flatting/narrowing of the curve (the counts are set to this parameter exponent: default is <code>1</code>).
</p>
</li></ul>

<p>See Guillerme et al. 2020 and https://github.com/TGuillerme/moms for details.
</p>


<h3>Value</h3>

<p>A vector of <code>logical</code> values of the rows to remove selected by the function. <code>TRUE</code> corresponds to the following (and <code>FALSE</code> to the opposite):
</p>

<ul>
<li><p>&quot;random&quot;: the randomly selected points.
</p>
</li>
<li><p>&quot;size&quot;: the points closer to the centre of the space.
</p>
</li>
<li><p>&quot;density&quot;: the points closer to each other.
</p>
</li>
<li><p>&quot;position&quot;: the points on the &quot;positive&quot; side of the space (typically upper right corner in 2D).
</p>
</li>
<li><p>&quot;evenness&quot;: the randomly select points from the higher density regions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Guillerme T, Puttick MN, Marcy AE, Weisbecker V. <b>2020</b> Shifting spaces: Which disparity or dissimilarity measurement best summarize occupancy in multidimensional spaces?. Ecol Evol. 2020;00:1-16. (doi:10.1002/ece3.6452)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.metric">test.metric</a></code> <code><a href="#topic+dispRity">dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Creating a two dimensional space
space &lt;- space.maker(100, 2, distribution = stats::rnorm)

## Generating the four types of reductions
random &lt;- reduce.space(space, "random", remove = 0.5)
size &lt;- reduce.space(space, "size", remove = 0.5)
density &lt;- reduce.space(space, "density", remove = 0.5)
position &lt;- reduce.space(space, "position", remove = 0.5)
evenness &lt;- reduce.space(space, "evenness", remove = 0.5)

## Plotting the four different results
par(mfrow = c(3,2))
plot(space, pch = 19, col = c("grey", "black")[as.factor(random)],
     main = "Random removal") 
plot(space, pch = 19, col = c("grey", "black")[as.factor(size)],
     main = "Size removal")
plot(space, pch = 19, col = c("grey", "black")[as.factor(density)],
     main = "Density removal")
plot(space, pch = 19, col = c("grey", "black")[as.factor(position)],
     main = "Position removal")
plot(space, pch = 19, col = c("grey", "black")[as.factor(evenness)],
     main = "Evenness removal")

## The space reduction with specific parameters:
# Using the point with coordinates (2,2) as the centre 
# Running over a maximum of 300 iterations
# With a tolerance of 0.05 (5%)
reduce.space(space, "size", remove = 0.2,
             parameters = list("centre" = c(2,2)), 
             tuning = list("max" = 300, "tol" = 0.05))

## Remove a specific amount to match a specific parameter
reduce.space(space, type = "size", parameters = list("radius" = 1.206866))


</code></pre>

<hr>
<h2 id='remove.zero.brlen'>Remove zero branch length</h2><span id='topic+remove.zero.brlen'></span>

<h3>Description</h3>

<p>Remove zero or negative branch lengths on trees by sliding nodes randomly in a postorder traversal based on <code><a href="#topic+slide.nodes">slide.nodes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.zero.brlen(tree, slide, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.zero.brlen_+3A_tree">tree</code></td>
<td>
<p>A <code>"phylo"</code> or <code>"multiPhylo"</code> object with edge lengths</p>
</td></tr>
<tr><td><code id="remove.zero.brlen_+3A_slide">slide</code></td>
<td>
<p>An optional sliding <code>numeric</code> values. If left empty, 1% of the shortest branch length is used.</p>
</td></tr>
<tr><td><code id="remove.zero.brlen_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value indicating whether to be verbose or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sliding value will be used to slide the nodes up and down to remove zero branch lengths by minimising the amount of branch changes.
The algorithm slides the nodes up and down (when possible) on each node in a recursive way while there is still zero or negative branch lengths.
If two recursions produce the same series of zero branches (e.g. by sliding node A towards node B equally so that the distance A:B becomes 0), the sliding value is divided by two until the next slide.
</p>


<h3>Value</h3>

<p>A <code>"phylo"</code> object with a postorder edge table and no zero branch lengths.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slide.nodes">slide.nodes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
## Generating a tree
tree &lt;- rtree(20)
## Adding some zero branch lengths (5)
tree$edge.length[sample(1:Nedge(tree), 5)] &lt;- 0
any(tree$edge.length == 0) # TRUE

## And now removing these zero branch lengths!
tree_no_zero &lt;- remove.zero.brlen(tree)
any(tree_no_zero$edge.length == 0) # FALSE

## Exaggerating the removal (to make it visible)
tree_exaggerated &lt;- remove.zero.brlen(tree, slide = 1)

## Plot the differences
par(mfrow = c(3,1))
plot(tree, main = "zero branch length")
plot(tree_no_zero, main = "no zero branch length")
plot(tree_exaggerated, main = "exaggerated slidding")

## Removing negative branch lengths
## Generating a tree with negative branch length
set.seed(3)
tree_negative &lt;- chronoMPL(rtree(10))
## Removing the negative branch length (and make it non-zero)
tree_positive &lt;- remove.zero.brlen(tree_negative)
## Plot the differences
par(mfrow = c(2, 1))
plot(tree_negative, main = "Negative branch lengths")
plot(tree_positive, main = "Positive branch lengths")

</code></pre>

<hr>
<h2 id='scale.dispRity'>Rescaling and centering disparity results.</h2><span id='topic+scale.dispRity'></span><span id='topic+rescale.dispRity'></span>

<h3>Description</h3>

<p>Scales or/and centers the disparity measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
scale(x, center = FALSE, scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale.dispRity_+3A_x">x</code></td>
<td>
<p>a <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="scale.dispRity_+3A_center">center</code></td>
<td>
<p>either a <code>logical</code> value or a <code>numeric</code> vector of length equal to the number of elements of <code>data</code> (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scale.dispRity_+3A_scale">scale</code></td>
<td>
<p>either a <code>logical</code> value or a <code>numeric</code> vector of length equal to the number of elements of <code>data</code> (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="scale.dispRity_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>scale</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To scale or and center using the full distribution (i.e. all the disparity values) or only the distribution within each subsets of bootstraps you can use the optional argument <code>use.all</code> as a logical. By default is <code>use.all = TRUE</code> and uses all the disparity values not only the ones in the subset.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="base.html#topic+scale">scale</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## Scaling the data
summary(scale.dispRity(disparity, scale = TRUE)) # Dividing by the maximum
## Multiplying by 10 (dividing by 0.1)
summary(scale.dispRity(disparity, scale = 0.1))

</code></pre>

<hr>
<h2 id='select.axes'>Selects ordination axes</h2><span id='topic+select.axes'></span>

<h3>Description</h3>

<p>Selects the axes required to explain a cumulative threshold amount of variance in an ordination (e.g. &gt; 95%).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.axes(data, group, threshold = 0.95, inc.threshold = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.axes_+3A_data">data</code></td>
<td>
<p>The trait space to analyse. This can be either a <code>"matrix"</code>, <code>"prcomp"</code>, <code>"princomp"</code> or a <code>"dispRity"</code> object.</p>
</td></tr>
<tr><td><code id="select.axes_+3A_group">group</code></td>
<td>
<p>Optional, either a <code>list</code> of row numbers or names to be used as different groups or a <code>data.frame</code> with the same <code class="reqn">k</code> elements as in <code>data</code> as rownames. If <code>data</code> is a <code>"dispRity"</code> object that already contains groups, the <code>group</code> argument is recycled.</p>
</td></tr>
<tr><td><code id="select.axes_+3A_threshold">threshold</code></td>
<td>
<p>The arbitrary threshold amount of variance (by default this is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="select.axes_+3A_inc.threshold">inc.threshold</code></td>
<td>
<p>Logical, whether to output the axes that contain the threshold value (<code>TRUE</code>; default) or not (<code>FALSE</code>). See details.
</p>
<p>, i.e. the axes necessary to include at least the threshold value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>inc.threshold = TRUE</code>, the returned axes are the ones that contains at least the threshold value (e.g. if the threshold is <code>0.95</code>, all the returned axes contain at least <code>0.95</code> of the variance, potentially more). If <code>inc.threshold = FALSE</code>, the returned axes are the ones before reaching this threshold (e.g. the cumulative variance returned is strictly less or equal to <code>0.95</code>).
</p>


<h3>Value</h3>

<p>A <code>"dispRity"</code>, <code>"axes"</code> object that can be printed, summarised and plot through generic <code>print</code>, <code>summary</code> and <code>plot</code> functions.
The object is a list containing:
</p>

<ul>
<li> <p><code>$dimensions</code>: the maximum number of dimensions selected across all groups;
</p>
</li>
<li> <p><code>$dim.list</code>: the selected dimensions per group;
</p>
</li>
<li> <p><code>$var</code>: the variance per axes per group;
</p>
</li>
<li> <p><code>$scaled.var</code>: the variance scaled variance per axes per group;
</p>
</li>
<li> <p><code>$cumsum.var</code>: the cumulative scaled variance per axes per group;
</p>
</li>
<li> <p><code>$call</code>: a list containing the <code>$threshold</code> value and the <code>$inc.threshold</code> option used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.subsets">custom.subsets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Ordinating the USArrests dataset
ordination &lt;- princomp(USArrests, cor = TRUE)
## Which dimensions to select?
(selected &lt;- select.axes(ordination))
## The selected dimensions
selected$dimensions
## Visualising the results
plot(selected)

## Same but by grouping the data into three groups
states_groups &lt;- list("Group1" = c("Mississippi","North Carolina",
                                   "South Carolina", "Georgia", "Alabama",
                                   "Alaska", "Tennessee", "Louisiana"),
                      "Group2" = c("Florida", "New Mexico", "Michigan",
                                   "Indiana", "Virginia", "Wyoming", "Montana",
                                   "Maine", "Idaho", "New Hampshire", "Iowa"),
                      "Group3" = c("Rhode Island", "New Jersey", "Hawaii",
                                   "Massachusetts"))
(selected &lt;- select.axes(ordination, group = states_groups))
## Note that the required number of axes is now 4 (instead of 3)
plot(selected)

## Loading some example dispRity data
data(demo_data)
## How many axes are required to explain 99% of the variance
## for each group in the Healy et al 2019 data?
(how_many &lt;- select.axes(demo_data$healy, threshold = 0.99))
summary(how_many)
plot(how_many)


</code></pre>

<hr>
<h2 id='sim.morpho'>Simulates morphological data.</h2><span id='topic+sim.morpho'></span>

<h3>Description</h3>

<p>Generates a morphological matrix using <code><a href="ape.html#topic+rTraitDisc">rTraitDisc</a></code> or <code><a href="phyclust.html#topic+gen.seq.HKY">gen.seq.HKY</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.morpho(
  tree,
  characters,
  states = 1,
  model = "ER",
  rates,
  substitution = c(stats::runif, 2, 2),
  invariant = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.morpho_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree to use for generating the characters.</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_characters">characters</code></td>
<td>
<p>The number of morphological characters to generate.</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_states">states</code></td>
<td>
<p>A <code>numeric</code> string of probabilities for the number of states for each character (<code>default = 1</code>; i.e. 100% binary state characters; see details).</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_model">model</code></td>
<td>
<p>Either an implemented (<code>"ER"</code>, <code>"HKY"</code> or <code>"MIXED"</code>) or user defined model (see details).</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_rates">rates</code></td>
<td>
<p>A function an its parameters for the rates distribution (see details).</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_substitution">substitution</code></td>
<td>
<p>A function an its parameters for the substitutions distribution (see details; <code>default = c(runif, 2, 2)</code>).</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_invariant">invariant</code></td>
<td>
<p><code>logical</code>, whether to allow any invariant sites (<code>default = TRUE</code>).</p>
</td></tr>
<tr><td><code id="sim.morpho_+3A_verbose">verbose</code></td>
<td>
<p>Whether to be verbose or not (<code>default = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The <code>model</code> arguments must be either a user's defined function for generating the discrete morphological characters (that takes the states, rates and substitution arguments) or one of the two following:
</p>

<ul>
<li> <p><code>"ER"</code> uses the <code>ape::rTraitDisc</code> function with the <code>"ER"</code> model argument (= Mk model).
</p>
</li>
<li> <p><code>"HKY"</code> uses the <code>phyclust::gen.seq.HKY</code> function with <code>kappa</code> sampled from the <code>substitution</code> argument, <code>pi = runif(4)</code> (divided by <code>sum(runif(4))</code>), <code>rate.scale</code> sampled from the <code>rates</code> distribution and <code>L</code> being the number of <code>characters</code> and transforms the purines (A, G) into 0 and the pyrimidines (C, T) into 1.
</p>
</li>
<li> <p><code>"MIXED"</code> randomly uses <code>"ER"</code> or <code>"HKY"</code> for binary characters and <code>"ER"</code> for any character with more than two states.
</p>
</li>
<li><p> the user defined model must be a <code>function</code> that generates <em>a single</em> discrete morphological character and takes one element from at least the following arguments: <code>tree</code>, <code>states</code>, <code>rates</code>, <code>substitution</code>.
</p>
</li></ul>

</li>
<li><p> The <code>states</code> argument attributes a number of states to each character by using the given probability vector for each number of states starting from two.
For example <code>states = c(0.7, 0.2, 0.1)</code> will generate 70% of characters with two states, 20% of characters with three states and 10% of characters with four states. 
</p>
</li>
<li><p> The <code>rates</code> and <code>substitution</code> arguments require a function that outputs a distribution and its optional parameters. For example <code>rates = c(runif, 1, 10)</code> creates a uniform distribution between 1 and 10 for the rates distribution.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.morpho">check.morpho</a></code>, <code><a href="#topic+apply.NA">apply.NA</a></code>, <code><a href="ape.html#topic+rTraitDisc">rTraitDisc</a></code>, <code><a href="phyclust.html#topic+gen.seq.HKY">gen.seq.HKY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(4)
## A random tree with 15 tips
tree &lt;- rcoal(15)
## Setting up the parameters
my_rates = c(rgamma, rate = 10, shape = 5)
my_substitutions = c(runif, 2, 2)

## HKY binary (15*50)
matrixHKY &lt;- sim.morpho(tree, characters = 50, model = "HKY",
     rates = my_rates, substitution = my_substitutions)

## Mk matrix (15*50) (for Mkv models)
matrixMk &lt;- sim.morpho(tree, characters = 50, model = "ER", rates = my_rates) 

## Mk invariant matrix (15*50) (for Mk models)
matrixMk &lt;- sim.morpho(tree, characters = 50, model = "ER", rates = my_rates,
     invariant = FALSE)

## MIXED model invariant matrix (15*50)
matrixMixed &lt;- sim.morpho(tree, characters = 50, model = "MIXED",
     rates = my_rates, substitution = my_substitutions,  invariant = FALSE,
     verbose = TRUE)

</code></pre>

<hr>
<h2 id='slice.tree'>Time slicing a tree.</h2><span id='topic+slice.tree'></span>

<h3>Description</h3>

<p>Time slicing through a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice.tree(tree, age, model, FAD, LAD, keep.all.ancestors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice.tree_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object with a <code>root.time</code> element.</p>
</td></tr>
<tr><td><code id="slice.tree_+3A_age">age</code></td>
<td>
<p>A single <code>numeric</code> value indicating where to perform the slice.</p>
</td></tr>
<tr><td><code id="slice.tree_+3A_model">model</code></td>
<td>
<p>One of the following models: <code>"acctran"</code>, <code>"deltran"</code>, <code>"random"</code>, <code>"proximity"</code>, <code>"equal.split"</code> or <code>"gradual.split"</code>. Is ignored if <code>method = "discrete"</code>. See <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> for the models description.</p>
</td></tr>
<tr><td><code id="slice.tree_+3A_fad">FAD</code>, <code id="slice.tree_+3A_lad">LAD</code></td>
<td>
<p>The first and last occurrence data.</p>
</td></tr>
<tr><td><code id="slice.tree_+3A_keep.all.ancestors">keep.all.ancestors</code></td>
<td>
<p>Optional, whether to also include the ancestors of the tree slice (<code>TRUE</code>) or just the ones linking the elements present at the slice (<code>FALSE</code>; default)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Guillerme T. &amp; Cooper N. <b>2018</b>. Time for a rethink: time sub-sampling methods in disparity-through-time analyses. Palaeontology. DOI: 10.1111/pala.12364.
</p>


<h3>See Also</h3>

<p><code>paleotree::timeSliceTree</code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Generate a random ultrametric tree
tree &lt;- rtree(20)

## Add some node labels
tree$node.label &lt;- letters[1:19]

## Add its root time
tree$root.time &lt;- max(tree.age(tree)$ages)

## Slice the tree at age 1.5
tree_slice &lt;- slice.tree(tree, age = 1.5, "deltran")

## The slice at age 0.5 but keeping all the ancestors
deep_slice &lt;- slice.tree(tree, age = 0.5, "deltran",
                            keep.all.ancestors = TRUE)

## Visualising the trees
old_par &lt;- par(mfrow = c(2,2))
plot(ladderize(tree), main = "full tree"); axisPhylo()
abline(v =  tree$root.time - 1.5)
plot(ladderize(tree_slice), main = "tree slice"); axisPhylo()
plot(ladderize(deep_slice), main = "slice with ancestors"); axisPhylo()

par(old_par)

</code></pre>

<hr>
<h2 id='slide.nodes'>Stretching a tree</h2><span id='topic+slide.nodes'></span>

<h3>Description</h3>

<p>Stretches a phylogenetic tree at a particular node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide.nodes(nodes, tree, slide, allow.negative.root = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide.nodes_+3A_nodes">nodes</code></td>
<td>
<p>A list of the ID nodes to slide (<code>"integer"</code>) or names (<code>"character"</code>). The first node is <code>ape::Ntip(tree) + 1</code>, etc.</p>
</td></tr>
<tr><td><code id="slide.nodes_+3A_tree">tree</code></td>
<td>
<p>a <code>"phylo"</code> object.</p>
</td></tr>
<tr><td><code id="slide.nodes_+3A_slide">slide</code></td>
<td>
<p>the sliding value.</p>
</td></tr>
<tr><td><code id="slide.nodes_+3A_allow.negative.root">allow.negative.root</code></td>
<td>
<p>logical, whether to allow negative branch lengths and moving the root node (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sliding works by subtracting the slide value to the branch leading to the node and adding it to the descendant branches.
Note that the slide value can be negative to slide nodes the other way (up); the only requirement is that the slide does not lead to negative branch length values.
</p>


<h3>Value</h3>

<p>A <code>"phylo"</code> object.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove.zero.brlen">remove.zero.brlen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
## Generating a coalescent tree
tree &lt;- rcoal(5)

## Stretching node 8 up and down
tree_slide_up &lt;- slide.nodes(8, tree, slide = 0.075)
tree_slide_down &lt;- slide.nodes(8, tree, slide = -0.075)

## Display the results
par(mfrow = c(3,1))
plot(tree) ; axisPhylo() ; nodelabels()
plot(tree_slide_up) ; axisPhylo() ; nodelabels()
plot(tree_slide_down) ; axisPhylo() ; nodelabels()

## Stretching many nodes
set.seed(42)
tree &lt;- rtree(50)
move_nodes &lt;- c(99, 93, 53, 86, 58, 63, 60, 84)
tree_slided &lt;- slide.nodes(move_nodes, tree, slide = 0.07)

## Display the results
par(mfrow = c(2, 1))
node_colors &lt;- c("lightblue", "orange")[((1:Nnode(tree))+Ntip(tree)) %in% move_nodes + 1]
plot(tree, show.tip.label = FALSE) ; axisPhylo()
nodelabels(bg = node_colors, cex = 0.5)
plot(tree_slided, show.tip.label = FALSE) ; axisPhylo()
nodelabels(bg = node_colors, cex = 0.5)

</code></pre>

<hr>
<h2 id='sort.dispRity'>Sorting or ordering a <code>dispRity</code> object.</h2><span id='topic+sort.dispRity'></span>

<h3>Description</h3>

<p>Sort (or order) the subsets of a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
sort(x, decreasing = FALSE, sort, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.dispRity_+3A_x">x</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="sort.dispRity_+3A_decreasing">decreasing</code></td>
<td>
<p><code>logical</code>. Should the sort be in ascending or descending order? Is ignored if <code>sort</code> is used.</p>
</td></tr>
<tr><td><code id="sort.dispRity_+3A_sort">sort</code></td>
<td>
<p>An optional <code>vector</code> of <code>numeric</code> values corresponding to the order in which to return the subsets.</p>
</td></tr>
<tr><td><code id="sort.dispRity_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>sort</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>, <code><a href="#topic+get.subsets">get.subsets</a></code>, <code><a href="#topic+get.disparity">get.disparity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## Sorting the data
summary(disparity)
summary(sort(disparity, decreasing = TRUE))
summary(sort(disparity, sort = c(7,1,3,4,5,2,6)))

</code></pre>

<hr>
<h2 id='space.maker'>Creating multidimensional spaces</h2><span id='topic+space.maker'></span>

<h3>Description</h3>

<p>Creates a multidimensional space with a given number of elements and dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space.maker(
  elements,
  dimensions,
  distribution,
  arguments = NULL,
  cor.matrix = NULL,
  scree = NULL,
  elements.names = NULL,
  replicates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="space.maker_+3A_elements">elements</code></td>
<td>
<p>An <code>numeric</code> value.</p>
</td></tr>
<tr><td><code id="space.maker_+3A_dimensions">dimensions</code></td>
<td>
<p>An <code>numeric</code> value smaller than <code>elements</code>.</p>
</td></tr>
<tr><td><code id="space.maker_+3A_distribution">distribution</code></td>
<td>
<p>One or more <code>functions</code> to determine the distribution of the <code>elements</code> along each <code>dimension</code>. The function must have a single input: <code>elements</code>.</p>
</td></tr>
<tr><td><code id="space.maker_+3A_arguments">arguments</code></td>
<td>
<p>Optional <code>list</code> of arguments to be passed to the distributions functions in the order they appear (<code>default = NULL</code>, see details).</p>
</td></tr>
<tr><td><code id="space.maker_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>An optional correlation <code>matrix</code> of size <code>dimensions * dimensions</code> (<code>default = NULL</code>, see details).</p>
</td></tr>
<tr><td><code id="space.maker_+3A_scree">scree</code></td>
<td>
<p>An optional proportional <code>numeric</code> vector for approximating the <code>dimensions</code> variance (<code>default = NULL</code>, see details).</p>
</td></tr>
<tr><td><code id="space.maker_+3A_elements.names">elements.names</code></td>
<td>
<p>Optional, a <code>character</code> or <code>integer</code> string for naming the elements in the matrix.</p>
</td></tr>
<tr><td><code id="space.maker_+3A_replicates">replicates</code></td>
<td>
<p>Optional, an <code>integer</code> to replicate the simulations and generating multiple spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When passing additional arguments to different distributions, these must be given as a <code>list</code> to each function in the order they appear.
For example if <code>distribution = c(runif, rnorm, rgamma)</code> and one wants the distributions to be <code>runif(elements, min = 1, max = 10)</code>, <code>rnorm(elements, mean = 8)</code> and <code>rgamma(elements, shape = 1, log = TRUE)</code>, the additional arguments should be passed as
<code>c(list(min = 1, max = 10), list(mean = 8), list(shape = 1, log = TRUE)</code>. If no arguments have to be passed to a certain function, it can be left as <code>NULL</code> (e.g. <code>c(list(min = 1, max = 10), list(NULL), list(shape = 1, log = TRUE)</code>).
</p>
<p>The <code>cor.matrix</code> argument should be a correlation matrix between the dimensions.
If not <code>NULL</code>, the multidimensional space is multiplied by the the Choleski decomposition (<code><a href="base.html#topic+chol">chol</a></code>) of the correlation matrix.
The <code>scree</code> argument is simply a value multiplier for each dimension to adjust their variance to approximate the <code>scree</code> one.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null.test">null.test</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A square space
plot(space.maker(5000, 2, runif), pch = 20)

## A circular space
plot(space.maker(5000, 2, rnorm), pch = 20)

## A 2-dimensional cylindrical space
plot(space.maker(5000, 2, c(rnorm, runif)), pch = 20)

## A 4-dimensional space with different distributions
space.maker(5, 4, c(runif, runif, rnorm, rgamma),
     arguments = list(list(min = 1, max = 10), list(min = 1, max = 2),
     list(mean = 8), list(shape = 1)))

## A 3-dimensional correlated space
cor_matrix &lt;- matrix(cbind(1, 0.8 ,0.2, 0.8, 1, 0.7, 0.2, 0.7, 1), nrow = 3)
space &lt;- space.maker(10000, 3, rnorm, cor.matrix = cor_matrix)
round(cor(space), 1) ; cor_matrix ## Both should be really similar matrices

## A 3-dimensional space with a priori approximated variance for each dimension
space &lt;- space.maker(10000, 3, rnorm, scree = c(0.6, 0.3, 0.1))
## The resulting screeplot
barplot(apply(space, 2, var))

## Generate 3 2D normal spaces with rownames 
space.maker(10, 2, rnorm, elements.names = letters[1:10], replicates = 3)

## Not run: 
require(scatterplot3d)
## A cube space
scatterplot3d(space.maker(5000, 3, runif), pch = 20)

## A plane space
scatterplot3d(space.maker(5000, 3, c(runif, runif, runif),
     arguments = list(list(min = 0, max = 0), NULL, NULL)), pch = 20)

## A sphere space
scatterplot3d(space.maker(5000, 3, rnorm), pch = 20)

## A 3D cylindrical space
scatterplot3d(space.maker(5000, 3, c(rnorm, rnorm, runif)), pch = 20)

## Generating a doughnut space
doughnut &lt;- space.maker(5000, 3, c(rnorm, random.circle),
     arguments = list(list(mean = 0), list(runif, inner = 0.5, outer = 1)))
## Reodering the axis for projecting the dougnut in 2D
scatterplot3d(doughnut[,c(2,1,3)], pch = 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.dispRity'>dispRity object summary</h2><span id='topic+summary.dispRity'></span>

<h3>Description</h3>

<p>Creates a summary of a <code>dispRity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dispRity'
summary(
  object,
  ...,
  quantiles = c(50, 95),
  cent.tend = median,
  recall = FALSE,
  digits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dispRity_+3A_object">object</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="summary.dispRity_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="base.html#topic+summary">summary</a></code> or <code>cent.tend</code>.</p>
</td></tr>
<tr><td><code id="summary.dispRity_+3A_quantiles">quantiles</code></td>
<td>
<p>The quantiles to display (default is <code>quantiles = c(50, 95)</code>; is ignored if the <code>dispRity</code> object is not bootstrapped).</p>
</td></tr>
<tr><td><code id="summary.dispRity_+3A_cent.tend">cent.tend</code></td>
<td>
<p>A function for summarising the bootstrapped disparity values (default is <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="summary.dispRity_+3A_recall">recall</code></td>
<td>
<p><code>logical</code> value specifying whether to recall the <code>dispRity</code> parameters input (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="summary.dispRity_+3A_digits">digits</code></td>
<td>
<p>Optional, a value for digits the values in the output table (default = 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>dispRity</code> object to summarise comes from a <code><a href="#topic+chrono.subsets">chrono.subsets</a></code> using a <code>"multiPhylo"</code> object, the displayed number of observations (<code>n</code>) corresponds to the maximum number of observation at the specific time slice (some slices through some trees might have less observations).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with:
</p>
<table>
<tr><td><code>subsets</code></td>
<td>
<p>the subset names.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the maximum number of elements in each subset (see details).</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>the observed disparity or the the observed central tendency (&lt;cent_tend&gt;) of disparity (<code>obs.&lt;cent_tend&gt;</code>).</p>
</td></tr>
<tr><td><code>bootstraps...</code></td>
<td>
<p>if <code>data</code> is bootstrapped, the bootstrapped disparity's central tendency (<code>bs.&lt;cent_tend&gt;</code>) and the quantiles of the bootstrapped disparities (or, if <code>data</code> is not bootstrapped but disparity is calculated as a distribution - see <code><a href="#topic+dispRity">dispRity</a></code>) - the quantiles of the observed disparity are displayed).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the disparity data based on Beck &amp; Lee 2014
data(disparity)

## Summarising the results
summary(disparity) # default
## Using different options
summary(disparity, quantiles = 75, cent.tend = mean, digits = 8,
     recall = TRUE)

</code></pre>

<hr>
<h2 id='test.dispRity'>Testing disparity hypotheses</h2><span id='topic+test.dispRity'></span>

<h3>Description</h3>

<p>Applying statistical tests to dispRity objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.dispRity(
  data,
  test,
  comparisons = "pairwise",
  rarefaction = NULL,
  correction = "none",
  concatenate = TRUE,
  conc.quantiles = c(mean, c(95, 50)),
  details = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.dispRity_+3A_data">data</code></td>
<td>
<p>A <code>dispRity</code> object.</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_test">test</code></td>
<td>
<p>A test <code>function</code> to apply to the data.</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_comparisons">comparisons</code></td>
<td>
<p>If data contains more than two subsets, the type of comparisons to apply: either <code>"pairwise"</code> (default), <code>"referential"</code>, <code>"sequential"</code>, <code>"all"</code> or a list of pairs of subset names/number to compare (see details).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_rarefaction">rarefaction</code></td>
<td>
<p>A <code>numeric</code> value indicating whether to use a specific rarefaction level (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_correction">correction</code></td>
<td>
<p>Which p-value correction to apply to <code>htest</code> category test (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>; default = <code>"none"</code>).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_concatenate">concatenate</code></td>
<td>
<p>Logical, whether to concatenate bootstrapped disparity values (<code>TRUE</code>; default) or to apply the test to each bootstrapped value individually (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_conc.quantiles">conc.quantiles</code></td>
<td>
<p>If <code>concatenate = TRUE</code>, must be a central tendency function and a vector of quantiles (default = <code>c(mean, c(95, 50))</code>).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_details">details</code></td>
<td>
<p>Whether to output the details of each test (non-formatted; default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="test.dispRity_+3A_...">...</code></td>
<td>
<p>Additional options to pass to the test <code>function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>comparison</code> argument can be:
</p>

<ul>
<li> <p><code>"pairwise"</code>: pairwise comparisons of all the subsets (default).
</p>
</li>
<li> <p><code>"referential"</code>: compares the first subset to all the others.
</p>
</li>
<li> <p><code>"sequential"</code>: compares each subset sequentially (e.g. first against second, second against third, etc.).
</p>
</li>
<li> <p><code>"all"</code>: compares all the subsets simultaneously to the data (i.e. <code>bootstrapped disparity ~ subsets names</code>). This argument is used for <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> type tests.
</p>
</li>
<li><p> A list of pairs of number of subsets to compare. Each element of the list must contain two elements
(e.g. <code>list(c("a","b"), ("b", "a"))</code> to compare &quot;a&quot; to &quot;b&quot; and then &quot;b&quot; to &quot;a&quot;).
</p>
</li>
<li> <p>If the called test is <code><a href="#topic+null.test">null.test</a></code>, the comparison argument is ignored. 
</p>
</li></ul>

<p>IMPORTANT: if you are performing multiple comparisons (e.g. when using <code>"pairwise"</code>, <code>"referential"</code> or <code>"sequential"</code>),  don't forget about the Type I error rate inflation. You might want to use a <em>p-value</em> correction (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dispRity">dispRity</a></code>, <code><a href="#topic+null.test">null.test</a></code>, <code><a href="#topic+bhatt.coeff">bhatt.coeff</a></code>, <code><a href="#topic+pair.plot">pair.plot</a></code>, <code><a href="#topic+adonis.dispRity">adonis.dispRity</a></code>, <code><a href="#topic+randtest.dispRity">randtest.dispRity</a></code>, <code><a href="#topic+test.dispRity">test.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the Beck &amp; Lee 2014 data
data(BeckLee_mat50)
data(BeckLee_tree)

## Calculating the disparity from customised subsets
## Generating the subsets
groups &lt;- crown.stem(BeckLee_tree, inc.nodes = FALSE)
customised_subsets &lt;- custom.subsets(BeckLee_mat50, groups)
## Bootstrapping the data
bootstrapped_data &lt;- boot.matrix(customised_subsets, bootstraps = 100)
## Calculating the sum of variances
sum_of_variances &lt;- dispRity(bootstrapped_data, metric = c(sum, variances))

## Measuring the subset overlap
test.dispRity(sum_of_variances, bhatt.coeff, "pairwise")

## Measuring differences from a reference subset
test.dispRity(sum_of_variances, wilcox.test, "referential")

## Measuring disparity as a distribution
disparity_var &lt;- dispRity(bootstrapped_data, metric = variances)
## Differences between the concatenated bootstrapped values of the subsets
test.dispRity(disparity_var, test = t.test, comparisons = "pairwise",
     concatenate = TRUE, correction = "bonferroni")
## Differences between the subsets bootstrapped
test.dispRity(disparity_var, test = t.test, comparisons = "pairwise",
     concatenate = FALSE, correction = "bonferroni",
     conc.quantiles = c(mean, c(95, 5)))

</code></pre>

<hr>
<h2 id='test.metric'>Test disparity metric</h2><span id='topic+test.metric'></span>

<h3>Description</h3>

<p>Test whether a metric captures changes trait space size, density and position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.metric(
  data,
  metric,
  ...,
  shifts,
  shift.options,
  model,
  replicates = 3,
  steps = 10,
  dimensions,
  verbose = FALSE,
  save.steps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.metric_+3A_data">data</code></td>
<td>
<p>A matrix or a <code>dispRity</code> object (see details).</p>
</td></tr>
<tr><td><code id="test.metric_+3A_metric">metric</code></td>
<td>
<p>A vector containing one to three functions. At least of must be a dimension-level 1 or 2 function (see details). If <code>data</code> is a <code>dispRity</code> object with disparity already calculated, this argument can be left empty (and the one from <code>data</code> is recycled)</p>
</td></tr>
<tr><td><code id="test.metric_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the metric.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_shifts">shifts</code></td>
<td>
<p>The types of shits to test, can be <code>"random"</code>, <code>"size"</code>, <code>"density"</code>, <code>"evenness"</code> and <code>"position"</code>. See details.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_shift.options">shift.options</code></td>
<td>
<p>Optional, a <code>list</code> of named arguments to be passed to <code><a href="#topic+reduce.space">reduce.space</a></code></p>
</td></tr>
<tr><td><code id="test.metric_+3A_model">model</code></td>
<td>
<p>Optional, which model to fit for testing the metric. See details.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_replicates">replicates</code></td>
<td>
<p>A <code>numeric</code> number of replicates to increase variance. By default <code>replicates = 3</code>. If <code>replicates = 1</code>, the <code>model</code> is not run.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_steps">steps</code></td>
<td>
<p>The number of steps in the space reduction to output between 10% and 100%. By default <code>steps = 10</code>.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_dimensions">dimensions</code></td>
<td>
<p>Optional, a <code>numeric</code> value or proportion of the dimensions to keep.</p>
</td></tr>
<tr><td><code id="test.metric_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value indicating whether to be verbose (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="test.metric_+3A_save.steps">save.steps</code></td>
<td>
<p>A <code>logical</code> value indicating whether to save the data for visualising the the shift steps if plotting the results (<code>TRUE</code>) or not (<code>FALSE</code>; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the three non-random shifts: <code>"size"</code>, <code>"density"</code>, <code>"evenness"</code> and <code>"position"</code>, the function returns both of shifts as:
</p>

<ul>
<li> <p><code>"size.inner"</code> and <code>"size.outer"</code> removing data from the edges or the centre respectively (contracting the size and &quot;hollowing&quot; it respectively).
</p>
</li>
<li> <p><code>"density.higher"</code> and <code>"density.lower"</code> removing data to increase or decrease density respectively (increasing/decreasing nearest neighbour distance).
</p>
</li>
<li> <p><code>"evenness.flattened"</code> and <code>"evenness.compacted"</code> removing data to from the centre of the distribution or from the edges to resepectively &quot;flatten&quot; or &quot;condense&quot; the distribution.
</p>
</li>
<li> <p><code>"position.top"</code> and <code>"position.bottom"</code> removing data from one side or the other of the space (the sides are selected from the point with lowest/highest scores on each dimensions respectively).
</p>
</li></ul>

<p>See figure 2 in Guillerme et al. 2020 for more details.
</p>
<p>The default <code>model</code> is a linear model using the following function:
<code>model = function(data) lm(disparity ~ reduction, data)</code>
You can provide your own as long as it is a single function with <code>data</code> as a single argument. The two terms from data should be called <code>reduction</code> for the variable on the x axis and <code>disparity</code> for the variable on the y axis. For example:
<code>model = function(data) nls(disparity ~ a*reduction/(b+reduction), data)</code>
Note that models (like this example) should be specific to the dataset. Any type of model can be fitted but only the ones with an associated <code>summary</code> function will be correctly displayed by <code><a href="#topic+summary.dispRity">summary.dispRity</a></code>.
To not run any model, use <code>model = NULL</code>.
</p>


<h3>Value</h3>

<p>This function outputs a <code>dispRity</code> object containing a list of simulated reductions in trait space. The results can be accessed through the usual S3 methods (<code>print</code>, <code>summary</code>, <code>plot</code>) or accessed directly through <code>x$&lt;name_of_the_shift&gt;</code> (e.g. <code>x$random</code> for the random shift results).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>References</h3>

<p>Guillerme T, Puttick MN, Marcy AE, Weisbecker V. <b>2020</b> Shifting spaces: Which disparity or dissimilarity measurement best summarize occupancy in multidimensional spaces?. Ecol Evol. 2020;00:1-16. (doi:10.1002/ece3.6452)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce.space">reduce.space</a></code> <code><a href="#topic+dispRity">dispRity</a></code> <code><a href="#topic+plot.dispRity">plot.dispRity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a 2D uniform space
space &lt;- space.maker(300, 2, runif)

## A simple test with only 1 replicate for two shifts (random and size):
simple_test &lt;- test.metric(space, metric = c(prod, ranges),
                           replicates = 1, shifts = c("random", "size")) 

## Summarising the tests
summary(simple_test)

## Visualising the test
plot(simple_test)

## Applying the test directly on a disparity object
data(disparity)
median_centroid_test &lt;- test.metric(disparity, shifts = "size")

## Summarising the tests
summary(median_centroid_test)

## Visualising the test
plot(median_centroid_test)

## Not run: 
## Note that the tests can take several minutes to run.

## Testing the sum of variance on all shifts 
sum_var_test &lt;- test.metric(space, metric = c(sum, variances),
                            shifts = c("random", "size", "density", "position"))

## Summarising the tests
summary(sum_var_test)

## Visualising the test
plot(sum_var_test)

## Creating a 2D uniform space
space &lt;- space.maker(300, 2, runif)

## Re-running the test on two shifts with data saving for visualisation
median_centroid_test &lt;- test.metric(space,
                                    metric = c(median, centroids),
                                    shifts = c("random", "size"),
                                    save.steps = TRUE)

## Visualising the tests results and display the shifts visualisation
plot(median_centroid_test)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='tree.age'>Extracting the age of nodes and tips in a tree.</h2><span id='topic+tree.age'></span>

<h3>Description</h3>

<p>Extracting the age of each node and tip in a tree give the height of the tree or some specified age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.age(tree, age, order = "past", fossil = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.age_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree.age_+3A_age">age</code></td>
<td>
<p>The age of the tree. If missing the age is set to be the tree height.</p>
</td></tr>
<tr><td><code id="tree.age_+3A_order">order</code></td>
<td>
<p>Either &quot;past&quot; if the units express time since the present (e.g. million years ago), or &quot;present&quot; if the unit is expressed in time since the root.</p>
</td></tr>
<tr><td><code id="tree.age_+3A_fossil">fossil</code></td>
<td>
<p><code>logical</code>, whether to always consider the tree as containing at least one living taxa (<code>TRUE</code>) or allowing only fossil taxa (<code>FALSE</code> - default), see details.</p>
</td></tr>
<tr><td><code id="tree.age_+3A_digits">digits</code></td>
<td>
<p>A <code>numeric</code> value or <code>integer</code> for the precision of the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>fossil = TRUE</code>, if the <code>tree</code> contains a <code>tree$root.time</code> element (for tree's root age), and that <code>order</code> is set to <code>"past"</code>, the output ages are adjusted to be starting from the root.time. Else, if no <code>tree$root.time</code> exists or <code>fossil = FALSE</code>, tips and nodes age is relative from the tip furthest away from the root. <em>THIS FUNCTION DOES NOT ESTIMATE TREE AGES</em>, it just extracts branch length information and converts it into time units. For basic dating functions in R, check <code><a href="ape.html#topic+chronos">chronos</a></code>, <code><a href="ape.html#topic+chronopl">chronopl</a></code>,  <code><a href="ape.html#topic+chronoMPL">chronoMPL</a></code> or use more specialised dating software (e.g. MrBayes, BEAST, RAxML, etc.).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice.tree">slice.tree</a></code>, <code><a href="#topic+chrono.subsets">chrono.subsets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A dated random phylogeny with a root 50 units of time old.
tree.age(rtree(10), age = 50)
## A random tree with the distance since the root.
tree.age(rtree(10), order = 'present')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
