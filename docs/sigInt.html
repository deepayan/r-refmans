<!DOCTYPE html><html lang="en"><head><title>Help for package sigInt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sigInt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#generate.eq'><p>Equilibrium analysis of the empirical crisis signaling game</p></a></li>
<li><a href='#plot.sigProb'><p>Plot predicted probabilities from a <code>sigProb</code> object.</p></a></li>
<li><a href='#predict.sigfit'><p>Predicted probabilities and comparative statics for signaling games</p></a></li>
<li><a href='#print.summary.sigfit'><p>Print the summary table for a <code>sigfit</code> object.</p></a></li>
<li><a href='#sanctionsData'><p>Economic Sanctions Threats and Outcomes</p></a></li>
<li><a href='#sigint'><p>Estimating the parameters of the canonical discrete crisis bargaining game.</p></a></li>
<li><a href='#summary.sigfit'><p>Summarize a fitted crisis signaling model</p></a></li>
<li><a href='#toLatexTable'><p>Export a <code>sigfit</code> object into paper-ready LaTeX table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate the Parameters of a Discrete Crisis-Bargaining Game</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides pseudo-likelihood methods for empirically analyzing common signaling games in international relations as described in Crisman-Cox and Gibilisco (2019) &lt;<a href="https://doi.org/10.1017%2Fpsrm.2019.58">doi:10.1017/psrm.2019.58</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ccrismancox/sigint">https://github.com/ccrismancox/sigint</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Casey Crisman-Cox &lt;ccrismancox@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Casey Crisman-Cox [aut, cre],
  Michael Gibilisco [aut]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>randomForest, stringr, pbivnorm, Formula, maxLik, xtable, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>Collate:</td>
<td>'convergence.r' 'doc.r' 'estimationfunctions.r'
'generate.eq.r' 'grfunctions.r' 'plot.sigProb.r'
'predict.sigfit.r' 'print.sigfit.r' 'sigint.r'
'summary.sigfit.r' 'toLatex.sigfit.r'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-12 21:40:39 UTC; cox</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-17 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='generate.eq'>Equilibrium analysis of the empirical crisis signaling game</h2><span id='topic+generate.eq'></span>

<h3>Description</h3>

<p>This method uses a formula and fixed data/parameters to allow for analysis 
of the crisis signaling game under specific settings.
This function is very similar to <code>predict.sigfit</code>, but it is designed 
for analysis outside of conducting counterfactuals on a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.eq(
  formulas,
  data,
  theta,
  type = c("actions", "outcomes"),
  na.action = na.omit,
  control = list(),
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate.eq_+3A_formulas">formulas</code></td>
<td>
<p>a Formula object with no left-hand side and 
seven separate (7) right-hand sides. See &quot;Details&quot; and examples below.</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model
Each row of the data frame describes an individual game
<code class="reqn">d = 1, 2, ..., D</code>. Each row <code class="reqn">d</code>  should be a summary of all of the
within-game observations for game <code class="reqn">d</code>.  If the model is all constants, 
then this argument should be left empty.</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_theta">theta</code></td>
<td>
<p>a data frame with one or more rows where each row is a parameter vector.</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_type">type</code></td>
<td>
<p>whether to provide probabilities over actions 
(default, returns <code class="reqn">p_C</code>, <code class="reqn">p_R</code>, and <code class="reqn">p_F</code>) 
or outcomes (returns <code class="reqn">SQ</code>, <code class="reqn">CD</code>, <code class="reqn">SF</code>, and  <code class="reqn">BD</code>).</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_na.action">na.action</code></td>
<td>
<p>how to deal with <code>NA</code>s in <code>data</code>.</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_control">control</code></td>
<td>
<p>list of options describing the grid search method. See &quot;Details&quot; for more information</p>
</td></tr>
<tr><td><code id="generate.eq_+3A_parallel">parallel</code></td>
<td>
<p>logical. Should the comparative statics be computed in parallel, requires the
<code><a href="parallel.html#topic+parallel">parallel</a></code>
package be installed. Parallelization is done using <code><a href="parallel.html#topic+parSapply">parSapply</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to consider comparative statics in the crisis signaling game, where the model
of interest has pre-defined parameters.
As such, it requires, at minimum, a seven-part formula and parameters.
How this function behaves has to do with how <code>data</code> and <code>theta</code> are specified.
</p>
<p>When the model is all constants (every part of the <code>formula</code> argument is either <code>0</code> or <code>1</code>),
then <code>data</code> is ignored.
In these cases, equilibria are computed for every parameter vector, which are supplied 
as rows in a data frame to <code>theta</code>.
</p>
<p>When there is one or more covariate in the model, then a data frame must be supplied to <code>data</code>.
In these cases both <code>data</code> or <code>theta</code> must have at least one row.
However, only one of these arguments can have multiple rows.  In other words, only
<code>data</code> or <code>theta</code> may vary, but not both.
</p>
<p>For additional implementation details see <code><a href="#topic+predict.sigfit">predict.sigfit</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>sigProb</code> containing three elements:
</p>

<dl>
<dt><code>predicted</code></dt><dd><p>data frame of predicted probabilities. The first column of this data frame is 
called <code>Row</code>, which corresponds to the rows in either <code>model</code> or <code>par</code>.
In the event of multiple equilibria, this column allows for mapping data and parameters to 
all computed equilibria.
</p>
</dd>
<dt><code>model</code></dt><dd><p>data frame of covariates used to produce the predicted probabilities.</p>
</dd>
<dt><code>par</code></dt><dd><p>data frame of parameters used to produce the predicted probabilities.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot.sigProb">plot.sigProb</a></code>, <code><a href="#topic+predict.sigfit">predict.sigfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An example with one covariate
ftest1 &lt;-  ~ 0 | #SA
             1 | #VA
             0 | #CB
             1 | #barWA
             x1 | #barWB
             1| #bara
             1 #VB
             
theta &lt;- data.frame(VA = 1, barWA = -1.9, barWB = -2.9,
                    barWB1 = 0.1, bara = -1.2, VB = 1)
data &lt;- data.frame(x1 = seq(from = -1,to = 2, length.out = 101))
test &lt;- generate.eq(ftest1, data = data, theta = theta)
plot(test, prob = "pr")

## An example with all constants
ftest2 &lt;-  ~ 0 | #SA
             1 | #VA
             0 | #CB
             1 | #barWA
             1 | #barWB  
             1 | #bara
             1 #VB
             
theta &lt;- data.frame(VA = 1, barWA = -1.9, 
                    barWB = seq(-2.9, -2.2, length.out = 15),
                    bara = -1.2,
                    VB = 1)
test &lt;- generate.eq(ftest2, theta = theta)
plot(test, prob = "pr")

</code></pre>

<hr>
<h2 id='plot.sigProb'>Plot predicted probabilities from a <code>sigProb</code> object.</h2><span id='topic+plot.sigProb'></span>

<h3>Description</h3>

<p>This method takes a <code>sigProb</code> object produced by
<code><a href="#topic+predict.sigfit">predict.sigfit</a></code> and plots the comparative static(s) of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sigProb'
plot(x, prob, xvar, main = "", ylab, xlab, col = "blue", pch = 16, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sigProb_+3A_x">x</code></td>
<td>
<p>an object of class <code>sigProb</code>, which is obtained by using <code><a href="#topic+predict.sigfit">predict.sigfit</a></code> on a model fit using <code><a href="#topic+sigint">sigint</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_prob">prob</code></td>
<td>
<p>A string providing the column name for the column of <code>object$predicted</code> should be used as the outcome or probability of interest.</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_xvar">xvar</code></td>
<td>
<p>A string providing the column name of the column (from either object$model or object$par) that provides the &quot;x-variable&quot; in the plot.</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_main">main</code></td>
<td>
<p>The title of the plot</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_col">col</code></td>
<td>
<p>The color of the plot</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_pch">pch</code></td>
<td>
<p>An integer or character used to choose the type of points used in the plot</p>
</td></tr>
<tr><td><code id="plot.sigProb_+3A_...">...</code></td>
<td>
<p>Additional arguments and graphical parameters used by <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.sigfit">predict.sigfit</a></code> <code><a href="#topic+generate.eq">generate.eq</a></code> <code><a href="base.html#topic+plot">plot</a></code> <code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sanctionsData)

f1 &lt;- sq+cd+sf+bd ~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
                    anticipatedsendercosts|#VA
                    sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
                    sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
                    targetdemocracy + lncaprat| #barWB
                    senderdemocracy| #bara
                    -1#VB
## Outcome probabilities for first five using NPL probabilities
Phat &lt;- list(PRhat=sanctionsData$PRnpl, PFhat=sanctionsData$PFnpl)
fit2 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat)

## comparative static on \bar{a}, compute more precise equilibria with uniroot
new.theta &lt;- data.frame(t(replicate(25, coef(fit2))))
new.theta[,19] &lt;- seq(-6, 0, length=25)
pout &lt;- predict(fit2, newdata=sanctionsData[93,], new.theta=new.theta, 
                control=list(gridsize=500))


plot(pout, prob="pc", ylab="Pr Challenge", xlab="Audience Costs")



</code></pre>

<hr>
<h2 id='predict.sigfit'>Predicted probabilities and comparative statics for signaling games</h2><span id='topic+predict.sigfit'></span>

<h3>Description</h3>

<p>This method uses a fitted model of class <code>sigfit</code> to compute
predicted probabilities or comparative statics. 
Users can provide either new data or a new parameters to generate 
counterfactuals of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sigfit'
predict(
  object,
  newdata,
  new.theta,
  type = c("actions", "outcomes"),
  na.action = na.pass,
  control = list(),
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sigfit_+3A_object">object</code></td>
<td>
<p>a fitted model of class <code>sigfit</code>.</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_newdata">newdata</code></td>
<td>
<p>data frame of covariates used to produce the predicted probabilities.
If this is left empty, the entire original data set is used.
When <code>newdata</code> is specified, <code>new.theta</code> should be either missing (use the coefficients
from the <code>sigfit</code> object) or a one row data frame. See &quot;Details&quot; for more information.
As with other <code><a href="stats.html#topic+predict">predict</a></code> methods, variable names must match those used to fit the model.</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_new.theta">new.theta</code></td>
<td>
<p>a data frame of alternative parameters for comparative statics.
When missing, the coefficients from the <code>object</code> are used.
When specified, each row should be a complete parameter vector. 
If <code>new.theta</code> is specified, then <code>newdata</code> must be a data frame with only one row.
Unlike other <code><a href="stats.html#topic+predict">predict</a></code> methods, column names do not matter here.
Instead, the columns must be the same order as the coefficients in <code>object</code>.
See &quot;Details&quot; and &quot;Examples&quot; for more information.</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_type">type</code></td>
<td>
<p>whether to provide probabilities over actions 
(default, returns <code class="reqn">p_C</code>, <code class="reqn">p_R</code>, and <code class="reqn">p_F</code>) 
or outcomes (returns <code class="reqn">SQ</code>, <code class="reqn">CD</code>, <code class="reqn">SF</code>, and  <code class="reqn">BD</code>).</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_na.action">na.action</code></td>
<td>
<p>how to deal with <code>NA</code>s in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_control">control</code></td>
<td>
<p>list of options describing the grid search method. See &quot;Details&quot; for more information</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_parallel">parallel</code></td>
<td>
<p>logical. Should the comparative statics be computed in parallel, requires the
<code><a href="parallel.html#topic+parallel">parallel</a></code>
package be installed. Parallelization is done using <code><a href="parallel.html#topic+parSapply">parSapply</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sigfit_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to consider comparative statics in the crisis signaling game.
The model of interest is fit using <code><a href="#topic+sigint">sigint</a></code>.
How this function behaves largely depends on  how <code>newdata</code> and <code>new.theta</code> are
specified.
</p>
<p>When both <code>newdata</code> and <code>new.theta</code> are missing, all equilibria for every
observation used to fit the model are computed.
These equilibria are then used to calculated either choice probabilities (default,
<code>type = "action"</code>) the distribution over outcomes (<code>type = "outcomes"</code>).
</p>
<p>When only <code>newdata</code> is specified, then all equilibria are computed using the
data frame in <code>newdata</code> and the coefficients from <code>object</code>. This produces
standard comparative statics with respect to observed covariates.
</p>
<p>When <code>newdata</code> is specified and <code>new.theta</code> is a one row data frame,
then all equilibria are computed using the data frame in <code>newdata</code> and the
coefficients from <code>new.theta</code>.
</p>
<p>When <code>newdata</code> is a one row data frame and <code>new.theta</code> is specified,
then all equilibria are computed using the data frame in <code>newdata</code> and the
coefficients from <code>new.theta</code>. This is a comparative static on changing a
structural parameter in the model.
</p>
<p>If <code>new.theta</code> has more than one row, then <code>newdata</code> must be specified as a
data frame with only one row.  Anything else returns an error.
</p>
<p>Equilibria are computed using a line search method.
The <code>control</code> argument allows for user control over this process.
Users can specify a list with the following named elements
</p>

<dl>
<dt>gridsize</dt><dd><p>Integer. The number of points considered in the line search (default, 1e4).
More points makes it more likely that all equilibria are discovered, but can slow down the
search. </p>
</dd>
<dt>comp</dt><dd><p>Logical. Should an equilibrium be computed when discovered?
When <code>comp = FALSE</code> (default), the mean of the grid points surrounding the
equilibrium is used as an approximate solution.
When <code>comp = TRUE</code> the function <code><a href="stats.html#topic+uniroot">uniroot</a></code>
is called to find a more precise solution to the equilibrium constraint problem.</p>
</dd>
<dt>tol</dt><dd><p>Numeric. When <code>comp = TRUE</code>, this is the tolerance used by
<code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</dd></dl>
<p>.

</p>
<p>When dealing with a larger problem, such as computing all equilibria for every observation,
it can be helpful to parallelize process.  If the user has the
(suggested) <code><a href="parallel.html#topic+parallel">parallel</a></code> package, then the option <code>parallel = TRUE</code>
will use the function <code><a href="parallel.html#topic+parSapply">parSapply</a></code> is used.
</p>


<h3>Value</h3>

<p>An object of class <code>sigProb</code> containing three elements:
</p>

<dl>
<dt><code>predicted</code></dt><dd><p>data frame of predicted probabilities. The first column of this data frame is 
called <code>Row</code>, which corresponds to the rows in either <code>model</code> or <code>par</code>.
In the event of multiple equilibria, this column allows for mapping data and parameters to 
all computed equilibria.
</p>
</dd>
<dt><code>model</code></dt><dd><p>data frame of covariates used to produce the predicted probabilities.</p>
</dd>
<dt><code>par</code></dt><dd><p>data frame of parameters used to produce the predicted probabilities.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot.sigProb">plot.sigProb</a></code>, <code><a href="#topic+generate.eq">generate.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sanctionsData)

f1 &lt;- sq+cd+sf+bd ~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
                    anticipatedsendercosts|#VA
                    sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
                    sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
                    targetdemocracy + lncaprat| #barWB
                    senderdemocracy| #bara
                    -1#VB
## Using Nested-Pseudo Likelihood  with default first stage    
## Not run:              
fit1 &lt;- sigint(f1, data=sanctionsData, npl.trace=TRUE)
p.out &lt;- predict(fit2, parallel=TRUE) #fitted choice probabilites for all observations

## End(Not run)

## Outcome probabilities for first five using PL method
Phat &lt;- list(PRhat=sanctionsData$PRhat, PFhat=sanctionsData$PFhat)
fit2 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat)
p1 &lt;- predict(fit2, newdata=sanctionsData[1:5,], type="outcome")

## comparative static on \bar{a}, compute more precise equilibria with uniroot
new.theta &lt;- data.frame(t(replicate(25, coef(fit2))))
new.theta[,19] &lt;- seq(-6, 0, length=25)
p2 &lt;- predict(fit2, newdata=sanctionsData[1,], new.theta=new.theta, control=list(comp=TRUE))


</code></pre>

<hr>
<h2 id='print.summary.sigfit'>Print the summary table for a <code>sigfit</code> object.</h2><span id='topic+print.summary.sigfit'></span>

<h3>Description</h3>

<p>Prints the summary regression table for a model fitted with <code><a href="#topic+sigint">sigint</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sigfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.sigfit_+3A_x">x</code></td>
<td>
<p>a <code>summary.sigfit</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.sigfit_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the standard regression results table from a fitted strategic model,
along with the log-likelihood and number of games used in estimation.
</p>

<hr>
<h2 id='sanctionsData'>Economic Sanctions Threats and Outcomes</h2><span id='topic+sanctionsData'></span>

<h3>Description</h3>

<p>Dataset on economic sanctions threats and outcomes from 1970-2000
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sanctionsData)
</code></pre>


<h3>Details</h3>

<p>These data were compiled using the Threat and Imposition of Sanctions (TIES),
data project (Morgan, Bapat, and Kobayashi 2014),
with additional data from the Correlates of War (COW),
and Polity IV datasets.
See Crisman-Cox and Gibilisco (2018) for more information.
The unit of
observation is the dyad-decade, and the variables are: 
</p>

<dl>
<dt><code>gameID</code></dt><dd><p>A dyad-decade identifier composed of COW country codes and the decade observed.</p>
</dd>
<dt><code>dyadID</code></dt><dd><p>A dyad identifier composed of COW country codes</p>
</dd>
<dt><code>tenyear</code></dt><dd><p>The observed decade</p>
</dd>
<dt><code>code1</code></dt><dd><p>Challenger's COW code</p>
</dd>
<dt><code>code2</code></dt><dd><p>Target's COW code</p>
</dd>
<dt><code>sq</code></dt><dd><p>The number of status quo observations in this dyad decade</p>
</dd>
<dt><code>cd</code></dt><dd><p>The number of times that the game ends with Challenge-Concede (Outcome <code class="reqn">CD</code>) </p>
</dd>
<dt><code>sf</code></dt><dd><p>The number of times that the game ends with Challenge-Resist
-Stand Firm (Outcome <code class="reqn">SF</code>) </p>
</dd>
<dt><code>bd</code></dt><dd><p>The number of times that the game ends with Challenge-Resist-Back Down
(Outcome <code class="reqn">BD</code>) </p>
</dd>
<dt><code>senderecondep</code></dt><dd><p>Challenger's economic dependence (dyadic trade / 
Challenger's GDP per capita)</p>
</dd>
<dt><code>senderdemocracy</code></dt><dd><p>Challenger's Polity score</p>
</dd>
<dt><code>contig</code></dt><dd><p>Contiguity between states</p>
</dd>
<dt><code>ally</code></dt><dd><p>Are these state allied? (indicator)</p>
</dd>
<dt><code>anticipatedsendercosts</code></dt><dd><p>The Challenger's 
anticipated costs for enacting sanctions</p>
</dd>
<dt><code>anticipatedtargetcosts</code></dt><dd><p>The Target's 
anticipated costs for being sanctions</p>
</dd>
<dt><code>targetecondep</code></dt><dd><p>Target's economic dependence (dyadic trade /
Target's GDP per capita)</p>
</dd>
<dt><code>lncaprat</code></dt><dd><p>Ratio of the Challenger's military capability to the Target's (logged)</p>
</dd>
<dt><code>targetdemocracy</code></dt><dd><p>Target's Polity score</p>
</dd>
<dt><code>PRhat</code></dt><dd><p>Estimated probability that the Target resists a challenge (fit using a random forest)</p>
</dd>
<dt><code>PFhat</code></dt><dd><p>Estimated probability that the Challenger stands firm given that 
it challenged (fit using a random forest)</p>
</dd>
<dt><code>PRnpl</code></dt><dd><p>Estimated probability that the Target resists a challenge (taken from the last stage of NPL iteration)</p>
</dd>
<dt><code>PFnpl</code></dt><dd><p>Estimated probability that the Challenger stands firm given that 
it challenged  (taken from the last stage of NPL iteration)</p>
</dd>
</dl>



<h3>References</h3>

<p>Barbieri, Katherine, Omar M. G. Keshk, and Brian Pollins. 2009.
&quot;TRADING DATA: Evaluating our Assumptions and Coding Rules.&quot; 
Conflict Management and Peace Science. 26(5): 471-491.
</p>
<p>Casey Crisman-Cox and Michael Gibilisco. 2018. &quot;Estimating 
Signaling Games in International Relations: Problems and Solutions.&quot;
Unpublished Manuscript.
</p>
<p>Gibler, Douglas M. 2009. International military alliances, 1648-2008. CQ Press.  
</p>
<p>Marshall, Monty G., and Keith Jaggers. 2013. &quot;Polity IV Project.&quot; 
<a href="http://www.systemicpeace.org/polity/polity4.htm">http://www.systemicpeace.org/polity/polity4.htm</a>.
</p>
<p>Morgan, T. Clifton, Navin Bapat, and Yoshi Kobayashi. 2014.
&quot;The Threat and Imposition of Sanctions: Updating the TIES dataset.&quot; 
Conflict Management and Peace Science 31(5): 541-558.   
</p>
<p>Singer, J. David, Stuart Bremer, and John Stuckey. 1972. 
&quot;Capability Distribution, Uncertainty, and Major Power War, 1820-1965.&quot;
in Bruce Russett (ed) Peace, War, and Numbers, Beverly Hills: Sage, 19-48.
</p>
<p>Stinnett, Douglas M., Jaroslav Tir, Philip Schafer, Paul F. Diehl, and Charles Gochman. 2002. 
&quot;The Correlates of War Project Direct Contiguity Data, Version 3.&quot; 
Conflict Management and Peace Science 19(2):58-66.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigint">sigint</a></code>
</p>

<hr>
<h2 id='sigint'>Estimating the parameters of the canonical discrete crisis bargaining game.</h2><span id='topic+sigint'></span>

<h3>Description</h3>

<p>This function fits the Lewis and Schultz (2003) model to data using either 
the pseudo-likelihood (PL) or nested-pseudo likelihood (NPL) method from 
Crisman-Cox and Gibilisco (2018). Throughout, we refer to the data as
containing <code class="reqn">D</code> games, where each game is  observed one or more times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigint(
  formulas,
  data,
  subset,
  na.action,
  fixed.par = list(),
  method = c("npl", "pl"),
  npl.maxit = 25,
  npl.tol = 1e-07,
  npl.trace = FALSE,
  start.beta,
  maxlik.method = "NR",
  phat,
  phat.formulas,
  pl.vcov = FALSE,
  phat.vcov,
  seed = 12345,
  maxlik.options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigint_+3A_formulas">formulas</code></td>
<td>
<p>a <code>Formula</code> object four variables on the left-hand side and 
seven (7) separate right-hand sides. See &quot;Details&quot; and examples below.</p>
</td></tr>
<tr><td><code id="sigint_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables used to fit the model.
Each row of the data frame describes an individual game
<code class="reqn">d = 1, 2, ..., D</code>. Each row <code class="reqn">d</code>  should be a summary of all of the
within-game observations for game <code class="reqn">d</code>. See &quot;Details&quot; for more
information.</p>
</td></tr>
<tr><td><code id="sigint_+3A_subset">subset</code></td>
<td>
<p>an optional logical expression to specify a subset of 
observations to be used in fitting the model.</p>
</td></tr>
<tr><td><code id="sigint_+3A_na.action">na.action</code></td>
<td>
<p>how do deal with missing data (<code>NA</code>s).  Defaults to the 
<code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code> (typically <code>na.omit</code>).</p>
</td></tr>
<tr><td><code id="sigint_+3A_fixed.par">fixed.par</code></td>
<td>
<p>a list with up to seven (7) named elements for normalizing payoffs to non-zero values.
Names must match a payoff name as listed in &quot;Details.&quot;
Each named element should contain a single number that is the fixed (not estimated) value of that payoff.
For example, to fix each side's victory-without-fighting payoff to 1
use <code>fixed.par=list(VA=1, VB=1)</code> and set their portions of the <code>formulas</code> to zero.
To normalize a payoff to zero, you only need to specify it has a zero in the <code>formulas</code>.</p>
</td></tr>
<tr><td><code id="sigint_+3A_method">method</code></td>
<td>
<p>whether to use the nested-pseudo-likelihood (<code>"npl"</code>, default) or
the pseudo-likelihood method for fitting the model. See &quot;Details&quot; for more 
information.</p>
</td></tr>
<tr><td><code id="sigint_+3A_npl.maxit">npl.maxit</code></td>
<td>
<p>maximum number of outer-loop iterations to be used when fitting the NPL.
See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="sigint_+3A_npl.tol">npl.tol</code></td>
<td>
<p>Convergence criteria for the NPL. When the estimates change by
less than this amount, convergence is considered successful.</p>
</td></tr>
<tr><td><code id="sigint_+3A_npl.trace">npl.trace</code></td>
<td>
<p>logical. Should the NPL's progress be printed to screen?</p>
</td></tr>
<tr><td><code id="sigint_+3A_start.beta">start.beta</code></td>
<td>
<p>starting values for the model coefficients as a single 
vector. If missing, random values are drawn from a normal distribution with mean
zero and standard deviation 0.05.</p>
</td></tr>
<tr><td><code id="sigint_+3A_maxlik.method">maxlik.method</code></td>
<td>
<p>method used by  <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>  to fit the
model. Default is Newton-Raphson (<code>"NR"</code>). See  <code><a href="maxLik.html#topic+maxLik">maxLik</a></code> 
for additional details. At this time only <code>"NR"</code>, <code>"BFGS"</code>, and <code>"Nelder-Mead"</code> are available.</p>
</td></tr>
<tr><td><code id="sigint_+3A_phat">phat</code></td>
<td>
<p>a list containing two vectors: <code>PRhat</code> and <code>PFhat</code>.
These are the first-stage estimates that <code class="reqn">B</code> resists a threat and that <code class="reqn">A</code> 
follows through on a threat, respectively.
If missing, they will be estimated by a  <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  with default options.
See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="sigint_+3A_phat.formulas">phat.formulas</code></td>
<td>
<p>if <code>phat</code> are  missing, you can supply formulas to 
estimate them. Should be a Formulas object containing no left-hand side and
1-2 right hand sides.  If  one right-hand side is given, the same 
covariates are used to estimate both <code>PRhat</code> and <code>PFhat</code>.  
Otherwise, the first RHS is used to generate <code>PRhat</code>, while the second RHS 
generates <code>PFhat</code>.
If no formulas are provided and <code>phat</code> is 
missing, all the covariates used in formulas argument and used here. See 
&quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="sigint_+3A_pl.vcov">pl.vcov</code></td>
<td>
<p>number of bootstrap iterations to generate <code>phat.vcov</code>. 
If less than <code>0</code> or <code>FALSE</code> (default), the pseudo-likelihood 
covariance is not estimated.  Only used if <code>method = "pl"</code>.</p>
</td></tr>
<tr><td><code id="sigint_+3A_phat.vcov">phat.vcov</code></td>
<td>
<p>a covariance matrix for the estimates <code>PRhat</code> and <code>PFhat</code>.
If missing and <code>pl.vcov = TRUE</code> and <code>phat</code> is missing, it will be 
estimated by bootstrapping the random forest used to fit <code>phat</code>.</p>
</td></tr>
<tr><td><code id="sigint_+3A_seed">seed</code></td>
<td>
<p>integer.
Used to set the seed for the random forest and for drawing the the starting values.
The PL can be sensitive to starting value, so this makes results reproducible.
The NPL is less sensitive, but we always recommend checking the first order conditions.</p>
</td></tr>
<tr><td><code id="sigint_+3A_maxlik.options">maxlik.options</code></td>
<td>
<p>a list of options to be passed to 
<code><a href="maxLik.html#topic+maxLik">maxLik</a></code>  for fitting the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model corresponds to an extensive-form, 
discrete-crisis-bargaining game from Lewis and Schultz (2003): 
</p>
<pre> 
  .       A 
  .      / \ 
  .     /   \ 
  .    /     \
  .   S_A     B 
  .    0     / \
  .         /   \
  .        /     \
  .      V_A      A 
  .      C_B     / \ 
  .             /   \
  .            /     \
  .     W_A + e_A    a + e_a 
  .     W_B + e_B    V_B</pre> 
<p>If <code class="reqn">A</code> chooses not to challenge <code class="reqn">B</code>,
then the game ends at the leftmost node (<code class="reqn">SQ</code>) and payoffs are
<code class="reqn">S_A</code> and 0 to players <code class="reqn">A</code> and <code class="reqn">B</code>, respectively. If <code class="reqn">A</code>
challenges <code class="reqn">B</code>, <code class="reqn">B</code> can concede or resist.  If <code class="reqn">B</code> concedes,
the game ends at <code class="reqn">CD</code> with payoffs <code class="reqn">V_A</code> and <code class="reqn">C_B</code>.  However,
if <code class="reqn">B</code> resists, <code class="reqn">A</code> decides to stand firm, which ends the game at
<code class="reqn">SF</code> with payoffs <code class="reqn">W_A + \epsilon_A</code> and <code class="reqn">W_B + \epsilon_B</code>.
Finally, if <code class="reqn">A</code> decides to back down in the face of <code class="reqn">B</code>'s
resistance, then the game ends at the rightmost node <code class="reqn">BD</code>, with payoffs
<code class="reqn">a + \epsilon_a</code> and <code class="reqn">V_B</code>.
</p>
<p>The seven right-hand formulas that are specified in the formula argument 
correspond to the regressors to be placed in <code class="reqn">S_A, V_A, C_B, W_A, W_B, 
  a</code>, and <code class="reqn">V_B</code>, respectively. The model is unidentified if any regressor
(including a constant term) is included in all the formulas for each player
(Lewis and Schultz 2003). Often the easiest way to meet this requirement is
set one formula per player  to 0. When an identification problem is
detected, an error is issued. For example, the syntax for the formula
argument could be:
</p>
<p><code>formulas = sq + cd + sf + bd ~ x1 + 0 | x2 | x2 | x1 + x2 | x1 | 1 | 0)</code>
</p>
<p>Where: </p>

<ul>
<li> <p><code>sq + cd + sf + bd</code> are the tallies of how many
times each outcome is observed for each observation.  When the game is only
observed once, that observation will be a 1 and three 0s.  When the game is
observed multiple times, these variables should count the number of times 
each outcome is observed.  They need to be in the order of <code class="reqn">SQ</code>, 
<code class="reqn">CD</code>, <code class="reqn">SF</code>, <code class="reqn">BD</code>.
</p>
</li>
<li> <p><code class="reqn">S_A</code> is a function of the variable <code>x1</code> and no constant term.
</p>
</li>
<li> <p><code class="reqn">V_A</code> is a function of the variable <code>x2</code> and a constant term.
</p>
</li>
<li> <p><code class="reqn">C_B</code> is a function of the variable <code>x2</code> and a constant term.
</p>
</li>
<li> <p><code class="reqn">W_A</code> is a function  of the variables <code>x1</code>, <code>x2</code> and a constant term.
</p>
</li>
<li> <p><code class="reqn">W_B</code> is a function of the variable  <code>x1</code> and a constant term.
</p>
</li>
<li> <p><code class="reqn">a</code> is a constant term.
</p>
</li>
<li> <p><code class="reqn">V_B</code> is fixed to 0 (or a non-zero value set by <code>fixed.par</code>. </p>
</li></ul>

<p>Each row of the data frame should be a summary of the covariates and outcomes associated with that particular game.
When each game is observed only once, then this will resemble an ordinary dyad-time data frame.
However, if there are multiple observations per game, then each row should be a summary of all the data associated
with that game.
For example, if there are <code class="reqn">D</code> games in the data, where each is observed <code class="reqn">T_d</code> times, then the data frame
should have <code class="reqn">D</code> rows.
The four columns making up the dependent variable will denote the frequencies of each outcome for game <code class="reqn">d</code>,
such that <code>sq</code><code class="reqn">_d</code> + <code>cd</code><code class="reqn">_d</code> + <code>sf</code><code class="reqn">_d</code> + <code>bd</code><code class="reqn">_d = T_d</code>.
The covariates in row <code class="reqn">d</code> should be summary statistics for the exogenous variables (e.g., mean, median, mode, first observation).
</p>
<p>The model is first fit using a pseudo-likelihood estimator.  This approach 
requires first stage estimation of the probability that <code class="reqn">B</code> resists and
the probability that <code class="reqn">A</code> fights conditional on <code class="reqn">B</code> choosing to 
resist. These first stage estimates should be flexible and we recommend
that users fit a flexible semi-parametric or non-parametric model to
produce them. If these estimates are produced by the analyst prior to using
this function, then they can be provided by providing a list to the
<code>phat</code> argument. This list should contain two named elements </p>

<ul>
<li> <p><code>PRhat</code> is the probability that <code class="reqn">B</code> resists.  This should be
a vector of probabilities with one estimated probability for each
observation. </p>
</li>
<li> <p><code>PFhat</code> is the probability that <code class="reqn">A</code> stands firm
conditional on <code class="reqn">B</code> resisting.  This should be a vector of probabilities
with one estimated probability for each observation. </p>
</li></ul>

<p>If the user leaves the <code>phat</code> argument empty, then these first-stage 
estimates are produced internally using the 
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code> function.
Users wanting to use the
random forest, can supply a formula for it using the argument 
<code>phat.formulas</code>.
This argument can take a formula with nothing on the 
left-hand side and 1-2 right-hand sides.
If two right-hand sides are 
provided then the first is used to generate <code>PRhat</code>, and the second is
used for <code>PFhat</code>.
If only one right-hand side is provided, it is used
for both. Some examples: </p>

<ul>
<li> <p><code>phat.formulas = ~ x1 + x2</code> 
predict <code>PRhat</code> and <code>PFhat</code> using <code>x1</code> and <code>x2</code>.
</p>
</li>
<li> <p><code>phat.formulas = ~ x1 + x2 | x1 + x2</code> predict <code>PRhat</code> and 
<code>PFhat</code> using <code>x1</code> and <code>x2</code>
</p>
</li>
<li> <p><code>phat.formulas = ~ x1 + x2 | x1 </code> predict <code>PRhat</code>  using <code>x1</code> and <code>x2</code>, but
predict <code>PFhat</code> using only <code>x1</code>. </p>
</li></ul>

<p>If both <code>phat</code> and <code>phat.formula</code> are missing, then a random forest is fit using all the 
exogenous variables listed in the formulas argument
</p>
<p>If <code>method = "npl"</code>, then estimation continues.  
For each iteration of the NPL, the estimates of <code>PRhat</code> and <code>PFhat</code> are updated
by one best-response iteration using the current parameter estimates.
The model is then refit using these updated choice probabilities.
This process continues until the maximum absolute change in
parameters and choice probabilities is less than <code>npl.tol</code> (default, <code>1e-7</code>), or
the number of outer iterations exceeds <code>npl.maxit</code> (default, <code>25</code>).
In the latter case, a warning is produced.
</p>
<p>If pseudo-likelihood (<code>method="pl"</code>) is used, then 
<code>pl.vcov</code> is checked.
There are four possibilities here: 
</p>

<ul>
<li> <p><code>pl.vcov = FALSE</code> (default), then no covariance matrix or
standard errors are returned, only the point estimates. 
</p>
</li>
<li> <p><code>pl.vcov &gt; 0</code> and <code>phat.vcov</code> is supplied, 
then <code>phat.vcov</code> is used to estimate the PL's covariance matrix. 
</p>
</li>
<li>  <p><code>pl.vcov &gt; 0</code>, <code>phat.vcov</code> is missing, and <code>phat</code> 
is missing, then the random forest used to estimate <code>PRhat</code> and
<code>PFhat</code> is bootstrapped (simple, nonparametric bootstrap)  <code>pl.vcov</code> times.
</p>
</li>
<li> <p><code>pl.vcov &gt; 0</code>, <code>phat.vcov</code> is missing, and <code>phat</code> is not
missing, then an error is returned. 
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>sigfit</code>, containing:</p>
 
<dl>
<dt><code>coefficients</code></dt><dd><p>A vector of estimated model parameters.</p>
</dd>  
<dt><code>vcov</code></dt><dd><p>Estimated variance-covariance matrix. When <code>pl.vcov = FALSE</code>, this slot is omitted.</p>
</dd> 
<dt><code>utilities</code></dt><dd><p>Each actor's utilities at the estimated values.</p>
</dd>  
<dt><code>fixed.par</code></dt><dd><p>The fixed utilities if specified in the call.</p>
</dd>  
<dt><code>logLik</code></dt><dd><p>Final log-likelihood value of the model.</p>
</dd>
<dt><code>gradient</code></dt><dd><p>First derivative values at the estimated parameters.</p>
</dd>
<dt><code>Phat</code></dt><dd><p>List of two elements 
</p>
 
<ul>
<li> <p><code>PRhat</code> The first stage estimates of the probability that 
<code class="reqn">B</code> resists (<code>method = "pl"</code>) or the final estimates that
<code class="reqn">B</code> resists (if <code>method = "npl"</code>) 
</p>
</li>
<li> <p><code>PFhat</code> The first stage estimates of the probability that 
<code class="reqn">A</code> stands firms given that <code class="reqn">A</code> challenged (<code>method = "pl"</code>) or 
the final estimates that <code class="reqn">A</code> stands firms given that <code class="reqn">A</code> challenged
(if <code>method = "npl"</code>)
</p>
</li></ul>
 
<p>Note that <code>PRhat</code> will only be an equilibrium if <code>method = "npl"</code> and the NPL convergences
</p>
</dd>
<dt><code>user.phat</code></dt><dd><p>Logical. Did the user provide phat?</p>
</dd> 
<dt><code>start.beta</code></dt><dd><p>The vector of starting values used in the PL optimization.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call used to produce the object.</p>
</dd>
<dt><code>model</code></dt><dd><p>The data frame used to fit the model.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method (<code>"pl"</code> or <code>"npl"</code>) used to fit the model.</p>
</dd>
<dt><code>maxlik.method</code></dt><dd><p>The optimization used by <code>maxLik</code> to fit the model.</p>
</dd>
<dt><code>maxlik.code</code></dt><dd><p>The convergence code returned by <code>maxLik</code>.</p>
</dd>
<dt><code>maxlik.message</code></dt><dd><p>The convergence message returned by <code>maxLik</code>.</p>
</dd>
</dl>

<p>Additionally, when <code>method = "npl"</code>, the following are also included in the <code>sigfit</code> object.</p>

<dl>
<dt><code>npl.iter</code></dt><dd><p>Number of best response iterations used in fitting the NPL.</p>
</dd>
<dt><code>npl.eval</code></dt><dd><p>Maximum difference between the parameters at the last two NPL iterations. If the NPL method converged, this should be less than <code>npl.tol</code> specified in the function call.</p>
</dd>
<dt><code>eq.constraint</code></dt><dd><p>Maximum equilibrium constraint violation.</p>
</dd>
</dl>



<h3>References</h3>

<p>Casey Crisman-Cox and Michael Gibilisco. 2019. &quot;Estimating 
Signaling Games in International Relations: Problems and Solutions.&quot;
<em>Political Science Research and Methods</em>. Online First.
</p>
<p>Jeffrey B. Lewis and Kenneth A. Schultz.  2003.  &quot;Revealing
Preferences: Empirical Estimation of a Crisis Bargaining Game with
Incomplete Information.&quot;  <em>Political Analysis</em> 11:345&ndash;367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sanctionsData")
f1 &lt;- sq+cd+sf+bd ~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
                    anticipatedsendercosts|#VA
                    sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
                    sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
                    targetdemocracy + lncaprat| #barWB
                    senderdemocracy| #bara
                    -1#VB

## Using Nested-Pseudo Likelihood  with default first stage     
## Not run:             
fit1 &lt;- sigint(f1, data=sanctionsData, npl.trace=TRUE)
summary(fit1)

## End(Not run)


## Using Pseudo Likelihood with user supplied first stage
Phat &lt;- list(PRhat=sanctionsData$PRnpl, PFhat=sanctionsData$PFnpl)
fit2 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat)
summary(fit2)

## Using Pseudo Likelihood with user made first stage and user covariance
## SIGMA is a bootstrapped first-stage covariance matrix (not provided)
## Not run: 
fit3 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat, phat.vcov=SIGMA, pl.vcov=TRUE)
summary(fit3)

## End(Not run)

## Using Pseudo Likelihood with default first stage and 
## bootstrapped standard errors for the first stage covariance
## Not run: 
fit4 &lt;- sigint(f1, data=sanctionsData, method="pl", pl.vcov=25) 
summary(fit4)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.sigfit'>Summarize a fitted crisis signaling model</h2><span id='topic+summary.sigfit'></span>

<h3>Description</h3>

<p>The default method for summarizing a <code>sigfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sigfit'
summary(object, vcov, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sigfit_+3A_object">object</code></td>
<td>
<p>a fitted model of class <code>sigfit</code></p>
</td></tr>
<tr><td><code id="summary.sigfit_+3A_vcov">vcov</code></td>
<td>
<p>a substitute variance covariance matrix</p>
</td></tr>
<tr><td><code id="summary.sigfit_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forms a block regression results table from fitted crisis signaling model.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.sigfit</code>.  This object
contains the information needed to print the summary
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.summary.sigfit">print.summary.sigfit</a></code>.
</p>

<hr>
<h2 id='toLatexTable'>Export a <code>sigfit</code> object into paper-ready LaTeX table</h2><span id='topic+toLatexTable'></span>

<h3>Description</h3>

<p>This method converts one or more fitted models of class <code>sigfit</code> into a publication-ready LaTeX table.
This conversion is performed by reformatting the models into a format that is fed to 
<code><a href="xtable.html#topic+xtable">xtable</a></code>, which generates the actual LaTeX code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toLatexTable(
  ...,
  se.list,
  stars = c("default", "all", "none"),
  caption = "",
  label,
  align,
  digits = 2,
  se.note = "Standard errors in parenthesis",
  order,
  covariate.labels,
  model.names,
  dep.varnames,
  k = 1,
  print.xtable.options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toLatexTable_+3A_...">...</code></td>
<td>
<p>one or more models fit using <code><a href="#topic+sigint">sigint</a></code>.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_se.list">se.list</code></td>
<td>
<p>an optional list where each element contains the standard errors of the models.
If included this list must include one element per model, even if that model's standard errors are unchanged.
This argument should be used when standard errors have been adjusted outside the model (e.g., a bootstrap).
If left empty the standard errors from the model's covariance matrix are used if available.
Within each element of this list, the order of standard errors must be the same order as the coefficients in the model.
Standard errors are not matched on name.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_stars">stars</code></td>
<td>
<p>how should significance stars be used? <code>stars = "default"</code> returns a single star when <code class="reqn">p &lt; 0.05</code>,
<code>stars = "all"</code> returns flags for <code class="reqn">p &lt; 0.1</code>, <code class="reqn">p &lt; 0.05</code>, and <code class="reqn">p &lt; 0.01</code>, and <code>stars = "none"</code> 
returns no stars at all.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_caption">caption</code></td>
<td>
<p>a string to be used as the table's caption.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_label">label</code></td>
<td>
<p>a string to be used as the table's LaTeX <code>label</code> argument.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_align">align</code></td>
<td>
<p>a string to indicate the alignment of each column in the table.
Passed directly to the LaTeX <code>tabular</code> options.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_digits">digits</code></td>
<td>
<p>how many digits after the decimal point should be displayed? Default 2.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_se.note">se.note</code></td>
<td>
<p>a string containing a note for the bottom of the table. 
Default is the common &quot;Standard errors in parenthesis.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_order">order</code></td>
<td>
<p>a string vector describing the order that  the covariates should be in the table.
The default is to use the order they're listed in the <code>sigfit</code> object. 
When this vector is shorter than the coefficient vector, variables are first included by <code>order</code>,
remaining variables are included based on their order in the model</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_covariate.labels">covariate.labels</code></td>
<td>
<p>a string vector of &quot;nice&quot; names for the variables appropriate for a published work.
If empty, the &quot;ugly&quot; names from the fitted model are used. Note that if <code>order</code> is specified then the
covariate labels must match the order in <code>order</code>.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_model.names">model.names</code></td>
<td>
<p>an optional vector of model names to include as column titles in the table. 
Should be either a single title or one title per model (repetition is allowed).
If only one title is given, that is centered over the table.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_dep.varnames">dep.varnames</code></td>
<td>
<p>an optional vector to describe the dependent variable in the models.
Can be either a single variable name or one per model (repetition is allowed).</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_k">k</code></td>
<td>
<p>an integer to start the counter for model numbers in the table.</p>
</td></tr>
<tr><td><code id="toLatexTable_+3A_print.xtable.options">print.xtable.options</code></td>
<td>
<p>a list of options for <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a ready-to-use LaTeX table for <code>sigfit</code> objects.
Each column is its own model, along with model-based information.
The generation of LaTeX code is done by <code><a href="xtable.html#topic+xtable">xtable</a></code> and so additional printing options can
be passed via <code>print.xtable.options</code>.
For a full list of these options see <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="xtable.html#topic+xtable">xtable</a></code>, <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sanctionsData")
f1 &lt;- sq+cd+sf+bd ~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
                    anticipatedsendercosts|#VA
                    sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
                    sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
                    targetdemocracy + lncaprat| #barWB
                    senderdemocracy| #bara
                    -1#VB
## Using Nested-Pseudo Likelihood  with default first stage
## Not run: 
fit1 &lt;- sigint(f1, data=sanctionsData, npl.trace=TRUE)

## End(Not run)

## Using Pseudo Likelihood with user made first stage
Phat &lt;- list(PRhat=sanctionsData$PRhat, PFhat=sanctionsData$PFhat)
fit2 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat)

## Using Pseudo Likelihood with default first stage and bootstrapped standard errors
## Not run: 
fit3 &lt;- sigint(f1, data=sanctionsData, method="pl", pl.vcov=25) 

## End(Not run)

## Simple regression table
toLatexTable(fit2)

## More options: multiple models and user supplied standard errors
## Not run: 
toLatexTable(fit1, fit2, fit3,
        se.list=list(sqrt(diag(vcov(fit1))),
                     sqrt(diag(vcov(fit3))),
                     sqrt(diag(vcov(fit3)))),
        stars="all",
        caption = "Economic Sanctions",
        label = "tab:sanctions",
        model.names = c("NPL", "PL", "PL"))

## End(Not run)         
        
## Not run: 
## More options, from print.xtable including printing to a file
toLatexTable(fit1, fit2, fit3,
        caption = "Economic Sanctions",
        label = "tab:sanctions",
        model.names = c("NPL", "PL", "PL"),
        print.xtable.options=list(file="myTable.tex",
                                  booktabs=TRUE))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
