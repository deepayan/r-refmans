<!DOCTYPE html><html><head><title>Help for package mplot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mplot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mplot-package'><p>Graphical model stability and model selection procedures</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#af'><p>The adaptive fence procedure</p></a></li>
<li><a href='#artificialeg'><p>Artificial example</p></a></li>
<li><a href='#bglmnet'><p>Model stability and variable importance plots for glmnet</p></a></li>
<li><a href='#bodyfat'><p>Body fat data set</p></a></li>
<li><a href='#diabetes'><p>Blood and other measurements in diabetics</p></a></li>
<li><a href='#fev'><p>Forced Expiratory Volume</p></a></li>
<li><a href='#glmfence'><p>The fence procedure for generalised linear models</p></a></li>
<li><a href='#lmfence'><p>The fence procedure for linear models</p></a></li>
<li><a href='#mplot'><p>Model selection and stability curves</p></a></li>
<li><a href='#plot.af'><p>Plot diagnostics for an af object</p></a></li>
<li><a href='#plot.bglmnet'><p>Plot diagnostics for a bglmnet object</p></a></li>
<li><a href='#plot.vis'><p>Plot diagnostics for a vis object</p></a></li>
<li><a href='#print.af'><p>Print method for an af object</p></a></li>
<li><a href='#print.vis'><p>Print method for a vis object</p></a></li>
<li><a href='#process.fn'><p>Process results within af function</p></a></li>
<li><a href='#summary.af'><p>Summary method for an af object</p></a></li>
<li><a href='#txt.fn'><p>Print text for fence methods</p></a></li>
<li><a href='#vis'><p>Model stability and variable inclusion plots</p></a></li>
<li><a href='#wallabies'><p>Rock-wallabies data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Model Stability and Variable Selection Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-07-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Model stability and variable inclusion plots [Mueller and Welsh
    (2010, &lt;<a href="https://doi.org/10.1111%2Fj.1751-5823.2010.00108.x">doi:10.1111/j.1751-5823.2010.00108.x</a>&gt;); Murray, Heritier and Mueller
    (2013, &lt;<a href="https://doi.org/10.1002%2Fsim.5855">doi:10.1002/sim.5855</a>&gt;)] as well as the adaptive fence [Jiang et al.
    (2008, &lt;<a href="https://doi.org/10.1214%2F07-AOS517">doi:10.1214/07-AOS517</a>&gt;); Jiang et al. 
    (2009, &lt;<a href="https://doi.org/10.1016%2Fj.spl.2008.10.014">doi:10.1016/j.spl.2008.10.014</a>&gt;)] for linear and generalised linear models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mvoutlier, glmulti, rmarkdown, DT, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>leaps, foreach, parallel, bestglm, doParallel, doRNG, plyr,
shinydashboard, shiny, glmnet, graphics, stats, googleVis,
ggplot2, reshape2, scales, dplyr, tidyr, magrittr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://garthtarr.github.io/mplot/">https://garthtarr.github.io/mplot/</a>,
<a href="https://github.com/garthtarr/mplot">https://github.com/garthtarr/mplot</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-10 10:37:12 UTC; garthtarr</td>
</tr>
<tr>
<td>Author:</td>
<td>Garth Tarr <a href="https://orcid.org/0000-0002-6605-7478"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Samuel Mueller <a href="https://orcid.org/0000-0002-3087-8127"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alan H Welsh <a href="https://orcid.org/0000-0002-3165-9559"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Garth Tarr &lt;garth.tarr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-10 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mplot-package'>Graphical model stability and model selection procedures</h2><span id='topic+mplot-package'></span>

<h3>Description</h3>

<p>Graphical model stability and model selection procedures
</p>


<h3>References</h3>

<p>Tarr G, Mueller S and Welsh AH (2018). mplot: An R Package for
Graphical Model Stability and Variable Selection Procedures.
Journal of Statistical Software, 83(9), pp. 1-28. doi: 10.18637/jss.v083.i09
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='af'>The adaptive fence procedure</h2><span id='topic+af'></span>

<h3>Description</h3>

<p>This function implements the adaptive fence procedure to
first find the optimal cstar value and then finds the
corresponding best model as described in Jiang et. al.
(2009) with some practical modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>af(
  mf,
  B = 60,
  n.c = 20,
  initial.stepwise = FALSE,
  force.in = NULL,
  cores,
  nvmax,
  c.max,
  screen = FALSE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="af_+3A_mf">mf</code></td>
<td>
<p>a fitted 'full' model, the result of a call
to lm or glm (and in the future lme or lmer).</p>
</td></tr>
<tr><td><code id="af_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications at each fence
boundary value</p>
</td></tr>
<tr><td><code id="af_+3A_n.c">n.c</code></td>
<td>
<p>number of boundary values to be considered</p>
</td></tr>
<tr><td><code id="af_+3A_initial.stepwise">initial.stepwise</code></td>
<td>
<p>logical.  Performs an initial stepwise
procedure to look for the range of model sizes where attention
should be focussed. See details for implementation.</p>
</td></tr>
<tr><td><code id="af_+3A_force.in">force.in</code></td>
<td>
<p>the names of variables that should be forced
into all estimated models</p>
</td></tr>
<tr><td><code id="af_+3A_cores">cores</code></td>
<td>
<p>number of cores to be used when parallel
processing the bootstrap</p>
</td></tr>
<tr><td><code id="af_+3A_nvmax">nvmax</code></td>
<td>
<p>size of the largest model that can still be
considered as a viable candidate.  Included for performance
reasons but if it is an active constraint it could lead to
misleading results.</p>
</td></tr>
<tr><td><code id="af_+3A_c.max">c.max</code></td>
<td>
<p>manually specify the upper boundary limit.
Only applies when <code>initial.stepwise=FALSE</code>.</p>
</td></tr>
<tr><td><code id="af_+3A_screen">screen</code></td>
<td>
<p>logical, whether or not to perform an initial
screen for outliers.  Highly experimental, use at own risk.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="af_+3A_seed">seed</code></td>
<td>
<p>random seed for reproducible results</p>
</td></tr>
<tr><td><code id="af_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial stepwise procedure performs forward stepwise model
selection using the AIC and backward stepwise model selection
using BIC.  In general the backwise selection via the more
conservative BIC will tend to select a smaller model than that
of the forward selection AIC approach.  The size of these two
models is found, and we go two dimensions smaller and larger
to estimate a sensible range of <code>c</code> values over which to
perform a parametric bootstrap.
</p>
<p>This procedure can take some time.  It is recommended that you start
with a relatively small number of bootstrap samples (<code>B</code>)
and grid of boundary values (<code>n.c</code>) and increase both as
required.
</p>
<p>If you use <code>initial.stepwise=TRUE</code> then in general you will
need a smaller grid of boundary values than if you select
<code>initial.stepwise=FALSE</code>.
It can be useful to check <code>initial.stepwise=FALSE</code> with a
small number of bootstrap replications over a sparse grid to ensure
that the <code>initial.stepwise=TRUE</code> has landed you in a reasonable
region.
</p>
<p>The <code>best.only=FALSE</code> option when plotting the results of the
adaptive fence is a modification to the adaptive fence procedure
which considers all models at a particular size that pass the fence
hurdle when calculating the p* values.  In particular,
for each value of c and at each bootstrap replication,
if a candidate model is found that passes the fence, then we look to see
if there are any other models of the same size that also pass the fence.
If no other models of the same size pass the fence, then that model is
allocated a weight of 1.  If there are two models that pass the fence, then
the best model is allocated a weight of 1/2.  If three models pass the fence,
the best model gets a weight of 1/3, and so on. After <code>B</code> bootstrap
replications, we aggregate the weights by summing over the various models.
The p* value is the maximum aggregated weight divided by the number of bootstrap
replications.
This correction penalises the probability associated with the best model if
there were other models of the same size that also passed the fence hurdle.
The rationale being that if a model has no redundant variables
then it will be the only model at that size that passes the fence over a
range of values of c.
The result is more pronounced peaks which can help to determine
the location of the correct peak and identify the optimal c*.
</p>
<p>See <code>?plot.af</code> or <code>help("plot.af")</code> for details of the
plot method associated with the result.
</p>


<h3>References</h3>

<p>Jiang J., Nguyen T., Sunil Rao J. (2009),
A simplified adaptive fence procedure, Statistics &amp;
Probability Letters, 79(5):625-629.  doi: 10.1016/j.spl.2008.10.014
</p>
<p>Jiang J., Sunil Rao J., Gu Z, Nguyen T. (2008),
Fence methods for mixed model selection, Annals of Statistics,
36(4):1669-1692. doi: 10.1214/07-AOS517
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.af">plot.af</a></code>
</p>
<p>Other fence: 
<code><a href="#topic+glmfence">glmfence</a>()</code>,
<code><a href="#topic+lmfence">lmfence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
set.seed(11)
e = rnorm(n)
x1 = rnorm(n)
x2 = rnorm(n)
x3 = x1^2
x4 = x2^2
x5 = x1*x2
y = 1 + x1 + x2 + e
dat = data.frame(y,x1,x2,x3,x4,x5)
lm1 = lm(y ~ ., data = dat)

## Not run: 
af1 = af(lm1, initial.stepwise = TRUE, seed = 1)
summary(af1)
plot(af1)

## End(Not run)
</code></pre>

<hr>
<h2 id='artificialeg'>Artificial example</h2><span id='topic+artificialeg'></span>

<h3>Description</h3>

<p>An artificial data set which causes stepwise regression
procedures to select a non-parsimonious model.
The true model is a simple linear regression of
y against x8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(artificialeg)
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on 10 variables.
</p>


<h3>Details</h3>

<p>Inspired by the pathoeg data set in the MPV pacakge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(artificialeg)
full.mod = lm(y~.,data=artificialeg)
step(full.mod)
# generating model
n=50
set.seed(8) # a seed of 2 also works
x1 = rnorm(n,0.22,2)
x7 = 0.5*x1 + rnorm(n,0,sd=2)
x6 = -0.75*x1 + rnorm(n,0,3)
x3 = -0.5-0.5*x6 + rnorm(n,0,2)
x9 = rnorm(n,0.6,3.5)
x4 = 0.5*x9 + rnorm(n,0,sd=3)
x2 = -0.5 + 0.5*x9 + rnorm(n,0,sd=2)
x5 = -0.5*x2+0.5*x3+0.5*x6-0.5*x9+rnorm(n,0,1.5)
x8 = x1 + x2 -2*x3 - 0.3*x4 + x5 - 1.6*x6 - 1*x7 + x9 +rnorm(n,0,0.5)
y = 0.6*x8 + rnorm(n,0,2)
artificialeg = round(data.frame(x1,x2,x3,x4,x5,x6,x7,x8,x9,y),1)
</code></pre>

<hr>
<h2 id='bglmnet'>Model stability and variable importance plots for glmnet</h2><span id='topic+bglmnet'></span>

<h3>Description</h3>

<p>Model stability and variable importance plots for glmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bglmnet(
  mf,
  nlambda = 100,
  lambda = NULL,
  B = 100,
  penalty.factor,
  screen = FALSE,
  redundant = TRUE,
  cores = NULL,
  force.in = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bglmnet_+3A_mf">mf</code></td>
<td>
<p>a fitted 'full' model, the result of a call
to lm or glm.</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_nlambda">nlambda</code></td>
<td>
<p>how many penalty values to consider.  Default = 100.</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_lambda">lambda</code></td>
<td>
<p>manually specify the penalty values (optional).</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow
differential shrinkage. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the model.
Default is 1 for all variables (and implicitly infinity for variables
listed in exclude). Note: the penalty factors are internally rescaled
to sum to nvars, and the lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_screen">screen</code></td>
<td>
<p>logical, whether or not to perform an initial
screen for outliers.  Highly experimental, use at own risk.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_redundant">redundant</code></td>
<td>
<p>logical, whether or not to add a redundant
variable.  Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_cores">cores</code></td>
<td>
<p>number of cores to be used when parallel
processing the bootstrap (Not yet implemented.)</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_force.in">force.in</code></td>
<td>
<p>the names of variables that should be forced
into all estimated models. (Not yet implemented.)</p>
</td></tr>
<tr><td><code id="bglmnet_+3A_seed">seed</code></td>
<td>
<p>random seed for reproducible results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is essentially just a
list. The supplied plot method provides a way to visualise the
results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bglmnet">plot.bglmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
set.seed(11)
e = rnorm(n)
x1 = rnorm(n)
x2 = rnorm(n)
x3 = x1^2
x4 = x2^2
x5 = x1*x2
y = 1 + x1 + x2 + e
dat = data.frame(y, x1, x2, x3, x4, x5)
lm1 = lm(y ~ ., data = dat)

## Not run: 
bg1 = bglmnet(lm1, seed = 1)
# plot(bg1, which = "boot_size", interactive = TRUE)
plot(bg1, which = "boot_size", interactive = FALSE)
# plot(bg1, which = "vip", interactive = TRUE)
plot(bg1, which = "vip", interactive = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bodyfat'>Body fat data set</h2><span id='topic+bodyfat'></span>

<h3>Description</h3>

<p>A data frame with 128 observations on 15 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bodyfat)
</code></pre>


<h3>Format</h3>

<p>A data frame with 128 observations on 15 variables.
</p>

<dl>
<dt>Id</dt><dd><p>Identifier</p>
</dd>
<dt>Bodyfat</dt><dd><p>Bodyfat percentage</p>
</dd>
<dt>Age</dt><dd><p>Age (years)</p>
</dd>
<dt>Weight</dt><dd><p>Weight (kg)</p>
</dd>
<dt>Height</dt><dd><p>Height (inches)</p>
</dd>
<dt>Neck</dt><dd><p>Neck circumference (cm)</p>
</dd>
<dt>Chest</dt><dd><p>Chest circumference (cm)</p>
</dd>
<dt>Abdo</dt><dd><p>Abdomen circumference (cm) &quot;at the umbilicus
and level with the iliac crest&quot;</p>
</dd>
<dt>Hip</dt><dd><p>Hip circumference (cm)</p>
</dd>
<dt>Thigh</dt><dd><p>Thigh circumference (cm)</p>
</dd>
<dt>Knee</dt><dd><p>Knee circumference (cm)</p>
</dd>
<dt>Ankle</dt><dd><p>Ankle circumference (cm)</p>
</dd>
<dt>Bic</dt><dd><p>Extended biceps circumference (cm)</p>
</dd>
<dt>Fore</dt><dd><p>Forearm circumference (cm)</p>
</dd>
<dt>Wrist</dt><dd><p>Wrist circumference (cm) &quot;distal to the
styloid processes&quot;</p>
</dd>
</dl>



<h3>Details</h3>

<p>A subset of the 252 observations available in the <code>mfp</code> package.
The selected observations avoid known high leverage points and
outliers.  The unused points from the data set could be used to validate
selected models.
</p>


<h3>References</h3>

<p>Johnson W (1996, Vol 4). Fitting percentage of
body fat to simple body measurements. Journal of Statistics
Education. Bodyfat data retrieved from
http://www.amstat.org/publications/jse/v4n1/datasets.johnson.html
An expanded version is included in the <code>mfp</code> R package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodyfat)
full.mod = lm(Bodyfat~.,data=subset(bodyfat,select=-Id))
</code></pre>

<hr>
<h2 id='diabetes'>Blood and other measurements in diabetics</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>The diabetes data frame has 442 rows and 11 columns.
These are the data used in Efron et al. (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diabetes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 442 observations on 11 variables.
</p>

<dl>
<dt>age</dt><dd><p>Age</p>
</dd>
<dt>sex</dt><dd><p>Gender</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index</p>
</dd>
<dt>map</dt><dd><p>Mean arterial pressure (average blood pressure)</p>
</dd>
<dt>tc</dt><dd><p>Total cholesterol (mg/dL)? Desirable range: below 200 mg/dL</p>
</dd>
<dt>ldl</dt><dd><p>Low-density lipoprotein (&quot;bad&quot; cholesterol)?
Desirable range: below 130 mg/dL </p>
</dd>
<dt>hdl</dt><dd><p>High-density lipoprotein (&quot;good&quot; cholesterol)?
Desirable range: above 40 mg/dL</p>
</dd>
<dt>tch</dt><dd><p>Blood serum measurement</p>
</dd>
<dt>ltg</dt><dd><p>Blood serum measurement</p>
</dd>
<dt>glu</dt><dd><p>Blood serum measurement (glucose?)</p>
</dd>
<dt>y</dt><dd><p>A quantitative measure of disease progression
one year after baseline</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data sourced from http://web.stanford.edu/~hastie/Papers/LARS
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., Tibshirani, R., (2004).
Least angle regression. The Annals of Statistics 32(2) 407-499.
DOI: 10.1214/009053604000000067
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diabetes)
full.mod = lm(y~.,data=diabetes)
</code></pre>

<hr>
<h2 id='fev'>Forced Expiratory Volume</h2><span id='topic+fev'></span>

<h3>Description</h3>

<p>This data set consists of 654 observations on youths aged 3 to 19 from
East Boston recorded duing the middle to late 1970's.
Forced expiratory volume (FEV), a measure of lung capacity, is the
variable of interest. Age and height are two continuous predictors.
Sex and smoke are two categorical predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fev)
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 observations on 5 variables.
</p>

<dl>
<dt>age</dt><dd><p>Age (years)</p>
</dd>
<dt>fev</dt><dd><p>Forced expiratory volume (liters).  Roughly the amount
of air an individual can exhale in the first second of
a forceful breath.</p>
</dd>
<dt>height</dt><dd><p>Height (inches).</p>
</dd>
<dt>sex</dt><dd><p>Female is 0. Male is 1.</p>
</dd>
<dt>smoke</dt><dd><p>A binary variable indicating whether or not the
youth smokes. Nonsmoker is 0. Smoker is 1.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Copies of this data set can also be found in the
<code>coneproj</code> and <code>tmle</code> packages.
</p>


<h3>References</h3>

<p>Tager, I. B., Weiss, S. T., Rosner, B., and Speizer, F. E. (1979).
Effect of parental cigarette smoking on pulmonary function in children.
<em>American Journal of Epidemiology</em>, <b>110</b>, 15-26.
</p>
<p>Rosner, B. (1999).
<em>Fundamentals of Biostatistics</em>, 5th Ed., Pacific Grove, CA: Duxbury.
</p>
<p>Kahn, M.J. (2005). An Exhalent Problem for Teaching Statistics.
<em>Journal of Statistics Education</em>,  <b>13</b>(2).
http://www.amstat.org/publications/jse/v13n2/datasets.kahn.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fev)
full.mod = lm(fev~.,data=fev)
step(full.mod)
</code></pre>

<hr>
<h2 id='glmfence'>The fence procedure for generalised linear models</h2><span id='topic+glmfence'></span>

<h3>Description</h3>

<p>This function implements the fence procedure to
find the best generalised linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmfence(mf, cstar, nvmax, adaptive = TRUE, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmfence_+3A_mf">mf</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+glm">glm</a></code>
specifying the full model.</p>
</td></tr>
<tr><td><code id="glmfence_+3A_cstar">cstar</code></td>
<td>
<p>the boundary of the fence, typically found
through bootstrapping.</p>
</td></tr>
<tr><td><code id="glmfence_+3A_nvmax">nvmax</code></td>
<td>
<p>the maximum number of variables that will be
be considered in the model.</p>
</td></tr>
<tr><td><code id="glmfence_+3A_adaptive">adaptive</code></td>
<td>
<p>logical. If <code>TRUE</code> the boundary of the fence is
given by cstar.  Otherwise, it the original (non-adaptive) fence
is performed where the boundary is cstar*hat(sigma)_M,tildeM.</p>
</td></tr>
<tr><td><code id="glmfence_+3A_trace">trace</code></td>
<td>
<p>logical. If <code>TRUE</code> the function prints out its
progress as it iterates up through the dimensions.</p>
</td></tr>
<tr><td><code id="glmfence_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jiming Jiang, Thuan Nguyen, J. Sunil Rao,
A simplified adaptive fence procedure, Statistics &amp;
Probability Letters, Volume 79, Issue 5, 1 March 2009,
Pages 625-629, http://dx.doi.org/10.1016/j.spl.2008.10.014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+af">af</a></code>, <code><a href="#topic+lmfence">lmfence</a></code>
</p>
<p>Other fence: 
<code><a href="#topic+af">af</a>()</code>,
<code><a href="#topic+lmfence">lmfence</a>()</code>
</p>

<hr>
<h2 id='lmfence'>The fence procedure for linear models</h2><span id='topic+lmfence'></span>

<h3>Description</h3>

<p>This function implements the fence procedure to
find the best linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmfence(mf, cstar, nvmax, adaptive = TRUE, trace = TRUE, force.in = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmfence_+3A_mf">mf</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+lm">lm</a></code>
specifying the full model.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_cstar">cstar</code></td>
<td>
<p>the boundary of the fence, typically found
through bootstrapping.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_nvmax">nvmax</code></td>
<td>
<p>the maximum number of variables that will be
be considered in the model.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_adaptive">adaptive</code></td>
<td>
<p>logical. If <code>TRUE</code> the boundary of the fence is
given by cstar.  Otherwise, it the original (non-adaptive) fence
is performed where the boundary is cstar*hat(sigma)_M,tildeM.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_trace">trace</code></td>
<td>
<p>logical. If <code>TRUE</code> the function prints out its
progress as it iterates up through the dimensions.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_force.in">force.in</code></td>
<td>
<p>the names of variables that should be forced
into all estimated models.</p>
</td></tr>
<tr><td><code id="lmfence_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jiming Jiang, Thuan Nguyen, J. Sunil Rao,
A simplified adaptive fence procedure, Statistics &amp;
Probability Letters, Volume 79, Issue 5, 1 March 2009,
Pages 625-629, http://dx.doi.org/10.1016/j.spl.2008.10.014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+af">af</a></code>, <code><a href="#topic+glmfence">glmfence</a></code>
</p>
<p>Other fence: 
<code><a href="#topic+af">af</a>()</code>,
<code><a href="#topic+glmfence">glmfence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 40 # sample size
beta = c(1,2,3,0,0)
K=length(beta)
set.seed(198)
X = cbind(1,matrix(rnorm(n*(K-1)),ncol=K-1))
e = rnorm(n)
y = X%*%beta + e
dat = data.frame(y,X[,-1])
# Non-adaptive approach (not recommended)
lm1 = lm(y~.,data=dat)
lmfence(lm1,cstar=log(n),adaptive=FALSE)
</code></pre>

<hr>
<h2 id='mplot'>Model selection and stability curves</h2><span id='topic+mplot'></span>

<h3>Description</h3>

<p>Opens a shiny GUI to investigate a range of model selection
and stability issues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplot(mf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mplot_+3A_mf">mf</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="mplot_+3A_...">...</code></td>
<td>
<p>objects of type <code>vis</code> or <code>af</code> or <code>bglmnet</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tarr G, Mueller S and Welsh AH (2018). mplot: An R Package for
Graphical Model Stability and Variable Selection Procedures.
Journal of Statistical Software, 83(9), pp. 1-28. doi: 10.18637/jss.v083.i09
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
set.seed(11)
e = rnorm(n)
x1 = rnorm(n)
x2 = rnorm(n)
x3 = x1^2
x4 = x2^2
x5 = x1*x2
y = 1 + x1 + x2 + e
dat = round(data.frame(y,x1,x2,x3,x4,x5),2)
lm1 = lm(y ~ ., data = dat)
## Not run: 
v1 = vis(lm1)
af1 = af(lm1)
bg1 = bglmnet(lm1)
mplot(lm1, v1, af1, bg1)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.af'>Plot diagnostics for an af object</h2><span id='topic+plot.af'></span>

<h3>Description</h3>

<p>Summary plot of the bootstrap results of an af object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'af'
plot(
  x,
  pch,
  interactive = FALSE,
  classic = NULL,
  tag = NULL,
  shiny = FALSE,
  best.only = FALSE,
  width = 800,
  height = 400,
  fontSize = 12,
  left = 50,
  top = 30,
  chartWidth = "60%",
  chartHeight = "80%",
  backgroundColor = "transparent",
  legend.position = "top",
  model.wrap = NULL,
  legend.space = NULL,
  options = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.af_+3A_x">x</code></td>
<td>
<p><code>af</code> object, the result of <code><a href="#topic+af">af</a></code></p>
</td></tr>
<tr><td><code id="plot.af_+3A_pch">pch</code></td>
<td>
<p>plotting character, i.e., symbol to use</p>
</td></tr>
<tr><td><code id="plot.af_+3A_interactive">interactive</code></td>
<td>
<p>logical.  If <code>interactive=TRUE</code> a
googleVis plot is provided instead of the base graphics plot.
Default is <code>interactive=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_classic">classic</code></td>
<td>
<p>logical.  Depricated. If <code>classic=TRUE</code> a
base graphics plot is provided instead of a googleVis plot.
For now specifying <code>classic</code> will overwrite the
default <code>interactive</code> behaviour, though this is
likely to be removed in the future.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_tag">tag</code></td>
<td>
<p>Default NULL. Name tag of the objects to be extracted
from a gvis (googleVis) object.
</p>
<p>The default tag for is NULL, which will
result in R opening a browser window.  Setting <code>tag='chart'</code>
or setting <code>options(gvis.plot.tag='chart')</code> is useful when
googleVis is used in scripts, like knitr or rmarkdown.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_shiny">shiny</code></td>
<td>
<p>Default FALSE. Set to TRUE when using in a shiny interface.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_best.only">best.only</code></td>
<td>
<p>logical determining whether the output used the
standard fence approach of only considering the best models
that pass the fence (<code>TRUE</code>) or if it should take into
account all models that pass the fence at each boundary
value (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.af_+3A_width">width</code></td>
<td>
<p>Width of the googleVis chart canvas area, in pixels.
Default: 800.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_height">height</code></td>
<td>
<p>Height of the googleVis chart canvas area, in pixels.
Default: 400.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_fontsize">fontSize</code></td>
<td>
<p>font size used in googleVis chart.  Default: 12.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_left">left</code></td>
<td>
<p>space at left of chart (pixels?).  Default: &quot;50&quot;.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_top">top</code></td>
<td>
<p>space at top of chart (pixels?).  Default: &quot;30&quot;.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_chartwidth">chartWidth</code></td>
<td>
<p>googleVis chart area width.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"60%"</code></p>
</td></tr>
<tr><td><code id="plot.af_+3A_chartheight">chartHeight</code></td>
<td>
<p>googleVis chart area height.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"80%"</code></p>
</td></tr>
<tr><td><code id="plot.af_+3A_backgroundcolor">backgroundColor</code></td>
<td>
<p>The background colour for the main area
of the chart. A simple HTML color string,
for example: 'red' or '#00cc00'.  Default: 'transparent'</p>
</td></tr>
<tr><td><code id="plot.af_+3A_legend.position">legend.position</code></td>
<td>
<p>legend position, e.g. <code>"topleft"</code>
or  <code>"bottomright"</code></p>
</td></tr>
<tr><td><code id="plot.af_+3A_model.wrap">model.wrap</code></td>
<td>
<p>Optional parameter to split the legend names
if they are too long for classic plots.  <code>model.wrap=2</code>
means that there will be two variables per line,  <code>model.wrap=2</code>
gives three variables per line and <code>model.wrap=4</code> gives 4
variables per line.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_legend.space">legend.space</code></td>
<td>
<p>Optional parameter to add additional space
between the legend items for the classic plot.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_options">options</code></td>
<td>
<p>If you want to specify the full set of googleVis
options.</p>
</td></tr>
<tr><td><code id="plot.af_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each value of <code class="reqn">c</code> a parametric
bootstrap is performed under the full model.
For each bootstrap
sample we identify the smallest model inside the fence,
<code class="reqn">\hat{\alpha}(c)</code>.   We calculate the empirical probability of selecting
model <code class="reqn">\alpha</code> for a given value of <code class="reqn">c</code> as
</p>
<p style="text-align: center;"><code class="reqn">p^*(c,\alpha)=P^*\{\hat{\alpha}(c)=\alpha\}.</code>
</p>

<p>Hence, if <code class="reqn">B</code> bootstrap replications are performed,
<code class="reqn">p^*(c,\alpha)</code> is the
proportion of times that model <code class="reqn">\alpha</code> is selected.  Finally,
define an overall selection probability,
</p>
<p style="text-align: center;"><code class="reqn">p^*(c)=\max_{\alpha\in\mathcal{A}}p^*(c,\alpha)</code>
</p>
<p> and we plot
<code class="reqn">p^*(c)</code> against <code class="reqn">c</code>. The points on the scatter plot are
colour coded by the model that yielded the highest inclusion probability.
</p>

<hr>
<h2 id='plot.bglmnet'>Plot diagnostics for a bglmnet object</h2><span id='topic+plot.bglmnet'></span>

<h3>Description</h3>

<p>A plot method to visualise the results of a <code>bglmnet</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bglmnet'
plot(
  x,
  highlight,
  interactive = FALSE,
  classic = NULL,
  tag = NULL,
  shiny = FALSE,
  which = c("vip", "boot", "boot_size"),
  width = 800,
  height = 400,
  fontSize = 12,
  left = 50,
  top = 30,
  chartWidth = "60%",
  chartHeight = "80%",
  axisTitlesPosition = "out",
  dataOpacity = 0.5,
  options = NULL,
  hAxis.logScale = TRUE,
  ylim,
  text = FALSE,
  backgroundColor = "transparent",
  legend.position = "right",
  jitterk = 0.1,
  srt = 45,
  max.circle = 15,
  min.prob = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bglmnet_+3A_x">x</code></td>
<td>
<p><code>bglmnet</code> object, the result of <code><a href="#topic+bglmnet">bglmnet</a></code></p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_highlight">highlight</code></td>
<td>
<p>the name of a variable that will be highlighted.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_interactive">interactive</code></td>
<td>
<p>logical.  If <code>interactive=TRUE</code> a
googleVis plot is provided instead of the base graphics plot.
Default is <code>interactive=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_classic">classic</code></td>
<td>
<p>logical.  Depricated. If <code>classic=TRUE</code> a
base graphics plot is provided instead of a googleVis plot.
For now specifying <code>classic</code> will overwrite the
default <code>interactive</code> behaviour, though this is
likely to be removed in the future.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_tag">tag</code></td>
<td>
<p>Default NULL. Name tag of the objects to be extracted
from a gvis (googleVis) object.
</p>
<p>The default tag for is NULL, which will
result in R opening a browser window.  Setting <code>tag='chart'</code>
or setting <code>options(gvis.plot.tag='chart')</code> is useful when
googleVis is used in scripts, like knitr or rmarkdown.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_shiny">shiny</code></td>
<td>
<p>Default FALSE. Set to TRUE when using in a shiny interface.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_which">which</code></td>
<td>
<p>a vector specifying the plots to be output. Variable
inclusion type plots <code>which = "vip"</code> or plots where the size
of the point representing each model is proportional to selection
probabilities by model size <code>which = "boot_size"</code>
or by penalty paramter <code>which = "boot"</code>.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_width">width</code></td>
<td>
<p>Width of the googleVis chart canvas area, in pixels.
Default: 800.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_height">height</code></td>
<td>
<p>Height of the googleVis chart canvas area, in pixels.
Default: 400.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_fontsize">fontSize</code></td>
<td>
<p>font size used in googleVis chart.  Default: 12.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_left">left</code></td>
<td>
<p>space at left of chart (pixels?).  Default: &quot;50&quot;.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_top">top</code></td>
<td>
<p>space at top of chart (pixels?).  Default: &quot;30&quot;.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_chartwidth">chartWidth</code></td>
<td>
<p>googleVis chart area width.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"60%"</code></p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_chartheight">chartHeight</code></td>
<td>
<p>googleVis chart area height.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"80%"</code></p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_axistitlesposition">axisTitlesPosition</code></td>
<td>
<p>Where to place the googleVis axis titles,
compared to the chart area. Supported values:
&quot;in&quot; - Draw the axis titles inside the the chart area.
&quot;out&quot; - Draw the axis titles outside the chart area.
&quot;none&quot; - Omit the axis titles.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_dataopacity">dataOpacity</code></td>
<td>
<p>The transparency of googleVis data points,
with 1.0 being completely opaque and 0.0 fully transparent.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_options">options</code></td>
<td>
<p>a list to be passed to the googleVis function giving
complete control over the output.  Specifying a value for
<code>options</code> overwrites all other plotting variables.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_haxis.logscale">hAxis.logScale</code></td>
<td>
<p>logical, whether or not to use a log scale on
the horizontal axis. Default = TRUE.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the <code>which="boot"</code> plots.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_text">text</code></td>
<td>
<p>logical, whether or not to add text labels to classic
boot plot. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_backgroundcolor">backgroundColor</code></td>
<td>
<p>The background colour for the main area
of the chart. A simple HTML color string,
for example: 'red' or '#00cc00'.  Default: 'transparent'</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_legend.position">legend.position</code></td>
<td>
<p>the postion of the legend for classic plots.
Default <code>legend.position="right"</code> alternatives include
<code>legend.position="top"</code> and <code>legend.position="bottom"</code></p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_jitterk">jitterk</code></td>
<td>
<p>amount of jittering of the model size in the lvk and boot plots.
Default = 0.1.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_srt">srt</code></td>
<td>
<p>when <code>text=TRUE</code>, the angle of rotation for the text labels.
Default = 45.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_max.circle">max.circle</code></td>
<td>
<p>determines the maximum circle size.
Default = 15.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_min.prob">min.prob</code></td>
<td>
<p>lower bound on the probability of a model being selected. If
a model has a selection probability lower than <code>min.prob</code> it will not be
plotted.</p>
</td></tr>
<tr><td><code id="plot.bglmnet_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bglmnet">bglmnet</a></code>
</p>

<hr>
<h2 id='plot.vis'>Plot diagnostics for a vis object</h2><span id='topic+plot.vis'></span>

<h3>Description</h3>

<p>A plot method to visualise the results of a <code>vis</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vis'
plot(
  x,
  highlight,
  interactive = FALSE,
  classic = NULL,
  tag = NULL,
  shiny = FALSE,
  nbest = "all",
  which = c("vip", "lvk", "boot"),
  width = 800,
  height = 400,
  fontSize = 12,
  left = 50,
  top = 30,
  chartWidth = "60%",
  chartHeight = "80%",
  axisTitlesPosition = "out",
  dataOpacity = 0.5,
  options = NULL,
  ylim,
  legend.position = "right",
  backgroundColor = "transparent",
  text = FALSE,
  min.prob = 0.4,
  srt = 45,
  max.circle = 15,
  print.full.model = FALSE,
  jitterk = 0.1,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vis_+3A_x">x</code></td>
<td>
<p><code>vis</code> object, the result of <code><a href="#topic+vis">vis</a></code></p>
</td></tr>
<tr><td><code id="plot.vis_+3A_highlight">highlight</code></td>
<td>
<p>the name of a variable that will be highlighted</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_interactive">interactive</code></td>
<td>
<p>logical.  If <code>interactive=TRUE</code> a
googleVis plot is provided instead of the base graphics plot.
Default is <code>interactive=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_classic">classic</code></td>
<td>
<p>logical.  Depricated. If <code>classic=TRUE</code> a
base graphics plot is provided instead of a googleVis plot.
For now specifying <code>classic</code> will overwrite the
default <code>interactive</code> behaviour, though this is
likely to be removed in the future.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_tag">tag</code></td>
<td>
<p>Default NULL. Name tag of the objects to be extracted
from a gvis (googleVis) object.
</p>
<p>The default tag for is NULL, which will
result in R opening a browser window.  Setting <code>tag='chart'</code>
or setting <code>options(gvis.plot.tag='chart')</code> is useful when
googleVis is used in scripts, like knitr or rmarkdown.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_shiny">shiny</code></td>
<td>
<p>Default FALSE. Set to TRUE when using in a shiny interface.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_nbest">nbest</code></td>
<td>
<p>maximum number of models at each model size
that will be considered for the lvk plot. Can also take
a value of <code>"all"</code> which displays all models (default).</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_which">which</code></td>
<td>
<p>a vector specifying the plots to be output.  Variable
inclusion plots <code>which="vip"</code>; description loss against model
size <code>which="lvk"</code>; bootstrapped description loss against
model size <code>which="boot"</code>.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_width">width</code></td>
<td>
<p>Width of the googleVis chart canvas area, in pixels.
Default: 800.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_height">height</code></td>
<td>
<p>Height of the googleVis chart canvas area, in pixels.
Default: 400.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_fontsize">fontSize</code></td>
<td>
<p>font size used in googleVis chart.  Default: 12.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_left">left</code></td>
<td>
<p>space at left of chart (pixels?).  Default: &quot;50&quot;.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_top">top</code></td>
<td>
<p>space at top of chart (pixels?).  Default: &quot;30&quot;.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_chartwidth">chartWidth</code></td>
<td>
<p>googleVis chart area width.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"60%"</code></p>
</td></tr>
<tr><td><code id="plot.vis_+3A_chartheight">chartHeight</code></td>
<td>
<p>googleVis chart area height.
A simple number is a value in pixels;
a string containing a number followed by <code>%</code> is a percentage.
Default: <code>"80%"</code></p>
</td></tr>
<tr><td><code id="plot.vis_+3A_axistitlesposition">axisTitlesPosition</code></td>
<td>
<p>Where to place the googleVis axis titles,
compared to the chart area. Supported values:
&quot;in&quot; - Draw the axis titles inside the the chart area.
&quot;out&quot; - Draw the axis titles outside the chart area.
&quot;none&quot; - Omit the axis titles.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_dataopacity">dataOpacity</code></td>
<td>
<p>The transparency of googleVis data points,
with 1.0 being completely opaque and 0.0 fully transparent.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_options">options</code></td>
<td>
<p>a list to be passed to the googleVis function giving
complete control over the output.  Specifying a value for
<code>options</code> overwrites all other plotting variables.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the lvk and boot plots.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_legend.position">legend.position</code></td>
<td>
<p>the postion of the legend for classic plots.
Default <code>legend.position="right"</code> alternatives include
<code>legend.position="top"</code> and <code>legend.position="bottom"</code></p>
</td></tr>
<tr><td><code id="plot.vis_+3A_backgroundcolor">backgroundColor</code></td>
<td>
<p>The background colour for the main area
of the chart. A simple HTML color string,
for example: 'red' or '#00cc00'.  Default: 'null' (there is an
issue with GoogleCharts when setting 'transparent' related to the
zoom window sticking - once that's sorted out, the default
will change back to 'transparent')</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_text">text</code></td>
<td>
<p>logical, whether or not to add text labels to classic
boot plot. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_min.prob">min.prob</code></td>
<td>
<p>when <code>text=TRUE</code>, a lower bound on the probability of
selection before a text label is shown.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_srt">srt</code></td>
<td>
<p>when <code>text=TRUE</code>, the angle of rotation for the text labels.
Default = 45.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_max.circle">max.circle</code></td>
<td>
<p>determines the maximum circle size.
Default = 15.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_print.full.model">print.full.model</code></td>
<td>
<p>logical, when <code>text=TRUE</code> this determines if the full
model gets a label or not.  Default=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_jitterk">jitterk</code></td>
<td>
<p>amount of jittering of the model size in the lvk and boot plots.
Default = 0.1.</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_seed">seed</code></td>
<td>
<p>random seed for reproducible results</p>
</td></tr>
<tr><td><code id="plot.vis_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>which = "lvk"</code> generates a scatter plot where
the points correspond to description loss is plot against model size
for each model considered.  The <code>highlight</code> argument is
used to differentiate models that contain a particular variable
from those that do not.
</p>
<p>Specifying <code>which = "boot"</code> generates a scatter plot where
each circle represents a model with a non-zero bootstrap probability,
that is, each model that was selected as the best model of a
particular dimension in at least one bootstrap replication.
The area of each circle is proportional to the
corresponding model's bootstrapped selection probability.
</p>


<h3>References</h3>

<p>Mueller, S. and Welsh, A. H. (2010), On model
selection curves. International Statistical Review, 78:240-256.
doi: 10.1111/j.1751-5823.2010.00108.x
</p>
<p>Murray, K., Heritier, S. and Mueller, S. (2013), Graphical
tools for model selection in generalized linear models.
Statistics in Medicine, 32:4438-4451. doi: 10.1002/sim.5855
</p>
<p>Tarr G, Mueller S and Welsh AH (2018). mplot: An R Package for
Graphical Model Stability and Variable Selection Procedures.
Journal of Statistical Software, 83(9), pp. 1-28. doi: 10.18637/jss.v083.i09
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vis">vis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
set.seed(11)
e = rnorm(n)
x1 = rnorm(n)
x2 = rnorm(n)
x3 = x1^2
x4 = x2^2
x5 = x1*x2
y = 1 + x1 + x2 + e
dat = data.frame(y,x1,x2,x3,x4,x5)
lm1 = lm(y~.,data=dat)

## Not run: 
v1 = vis(lm1, seed = 1)
plot(v1, highlight = "x1", which = "lvk")
plot(v1, which = "boot")
plot(v1, which = "vip")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.af'>Print method for an af object</h2><span id='topic+print.af'></span>

<h3>Description</h3>

<p>Prints basic output of the bootstrap results of an
af object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'af'
print(x, best.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.af_+3A_x">x</code></td>
<td>
<p>an <code>af</code> object, the result of <code><a href="#topic+af">af</a></code></p>
</td></tr>
<tr><td><code id="print.af_+3A_best.only">best.only</code></td>
<td>
<p>logical determining whether the output used the
standard fence approach of only considering the best models
that pass the fence (<code>TRUE</code>) or if it should take into
account all models that pass the fence at each boundary
value (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="print.af_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>

<hr>
<h2 id='print.vis'>Print method for a vis object</h2><span id='topic+print.vis'></span>

<h3>Description</h3>

<p>Prints basic output of the bootstrap results of an
vis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vis'
print(x, min.prob = 0.3, print.full.model = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.vis_+3A_x">x</code></td>
<td>
<p>a <code>vis</code> object, the result of <code><a href="#topic+vis">vis</a></code></p>
</td></tr>
<tr><td><code id="print.vis_+3A_min.prob">min.prob</code></td>
<td>
<p>a lower bound on the probability of
selection before the result is printed</p>
</td></tr>
<tr><td><code id="print.vis_+3A_print.full.model">print.full.model</code></td>
<td>
<p>logical, determines if the full
model gets printed or not.  Default=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.vis_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>

<hr>
<h2 id='process.fn'>Process results within af function</h2><span id='topic+process.fn'></span>

<h3>Description</h3>

<p>This function is used by the af function to process
the results when iterating over different boundary values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.fn(fence.mod, fence.rank)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.fn_+3A_fence.mod">fence.mod</code></td>
<td>
<p>set of fence models</p>
</td></tr>
<tr><td><code id="process.fn_+3A_fence.rank">fence.rank</code></td>
<td>
<p>set of fence model ranks</p>
</td></tr>
</table>

<hr>
<h2 id='summary.af'>Summary method for an af object</h2><span id='topic+summary.af'></span>

<h3>Description</h3>

<p>Provides comprehensive  output of the bootstrap results of an
af object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'af'
summary(object, best.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.af_+3A_object">object</code></td>
<td>
<p><code>af</code> object, the result of <code><a href="#topic+af">af</a></code></p>
</td></tr>
<tr><td><code id="summary.af_+3A_best.only">best.only</code></td>
<td>
<p>logical determining whether the output used the
standard fence approach of only considering the best models
that pass the fence (<code>TRUE</code>) or if it should take into
account all models that pass the fence at each boundary
value (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="summary.af_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>

<hr>
<h2 id='txt.fn'>Print text for fence methods</h2><span id='topic+txt.fn'></span>

<h3>Description</h3>

<p>This function provides the text for the case when trace=TRUE
when using lmfence and glmfence functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txt.fn(score, UB, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="txt.fn_+3A_score">score</code></td>
<td>
<p>realised value</p>
</td></tr>
<tr><td><code id="txt.fn_+3A_ub">UB</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="txt.fn_+3A_obj">obj</code></td>
<td>
<p>fitted model object</p>
</td></tr>
</table>

<hr>
<h2 id='vis'>Model stability and variable inclusion plots</h2><span id='topic+vis'></span>

<h3>Description</h3>

<p>Calculates and provides the plot methods for standard
and bootstrap enhanced model stability plots (<code>lvk</code> and
<code>boot</code>) as well as variable inclusion plots (<code>vip</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis(
  mf,
  nvmax,
  B = 100,
  lambda.max,
  nbest = "all",
  use.glmulti = FALSE,
  cores,
  force.in = NULL,
  screen = FALSE,
  redundant = TRUE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_+3A_mf">mf</code></td>
<td>
<p>a fitted 'full' model, the result of a call
to lm or glm (and in the future lme or lmer)</p>
</td></tr>
<tr><td><code id="vis_+3A_nvmax">nvmax</code></td>
<td>
<p>size of the largest model that can still be
considered as a viable candidate</p>
</td></tr>
<tr><td><code id="vis_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="vis_+3A_lambda.max">lambda.max</code></td>
<td>
<p>maximum penalty value for the vip plot,
defaults to 2*log(n)</p>
</td></tr>
<tr><td><code id="vis_+3A_nbest">nbest</code></td>
<td>
<p>maximum number of models at each model size
that will be considered for the lvk plot. Can also take
a value of <code>"all"</code> which displays all models.</p>
</td></tr>
<tr><td><code id="vis_+3A_use.glmulti">use.glmulti</code></td>
<td>
<p>logical. Whether to use the glmulti package
instead of bestglm. Default <code>use.glmulti=FALSE</code>.</p>
</td></tr>
<tr><td><code id="vis_+3A_cores">cores</code></td>
<td>
<p>number of cores to be used when parallel
processing the bootstrap</p>
</td></tr>
<tr><td><code id="vis_+3A_force.in">force.in</code></td>
<td>
<p>the names of variables that should be forced
into all estimated models. (Not yet implemented.)</p>
</td></tr>
<tr><td><code id="vis_+3A_screen">screen</code></td>
<td>
<p>logical, whether or not to perform an initial
screen for outliers.  Highly experimental, use at own risk.
Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vis_+3A_redundant">redundant</code></td>
<td>
<p>logical, whether or not to add a redundant
variable.  Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vis_+3A_seed">seed</code></td>
<td>
<p>random seed for reproducible results</p>
</td></tr>
<tr><td><code id="vis_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is essentially just a
list. The supplied plot method provides a way to visualise the
results.
</p>
<p>See <code>?plot.vis</code> or <code>help("plot.vis")</code> for details of the
plot method associated with the result.
</p>


<h3>References</h3>

<p>Mueller, S. and Welsh, A. H. (2010), On model
selection curves. International Statistical Review, 78:240-256.
doi: 10.1111/j.1751-5823.2010.00108.x
</p>
<p>Murray, K., Heritier, S. and Mueller, S. (2013), Graphical
tools for model selection in generalized linear models.
Statistics in Medicine, 32:4438-4451. doi: 10.1002/sim.5855
</p>
<p>Tarr G, Mueller S and Welsh AH (2018). mplot: An R Package for
Graphical Model Stability and Variable Selection Procedures.
Journal of Statistical Software, 83(9), pp. 1-28. doi: 10.18637/jss.v083.i09
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.vis">plot.vis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
set.seed(11)
e = rnorm(n)
x1 = rnorm(n)
x2 = rnorm(n)
x3 = x1^2
x4 = x2^2
x5 = x1*x2
y = 1 + x1 + x2 + e
dat = data.frame(y, x1, x2, x3, x4, x5)
lm1 = lm(y ~ ., data = dat)

## Not run: 
v1 = vis(lm1, seed = 1)
plot(v1, highlight = "x1", which = "lvk")
plot(v1, which = "boot")
plot(v1, which = "vip")

## End(Not run)
</code></pre>

<hr>
<h2 id='wallabies'>Rock-wallabies data set</h2><span id='topic+wallabies'></span>

<h3>Description</h3>

<p>On Chalkers Top in the Warrumbungles (NSW, Australia) 200 evenly distributed
one metre squared plots were surveyed. Plots were placed at a density
of 7-13 per hectare. The presence or absence of fresh
(&lt;1 month old) scats of rock-wallabies was recorded for each plot
along with location and a selection of predictor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wallabies)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on 9 variables.
</p>

<dl>
<dt>rw</dt><dd><p>Presence of rock-wallaby scat</p>
</dd>
<dt>edible</dt><dd><p>Percentage cover of edible vegetation</p>
</dd>
<dt>inedible</dt><dd><p>Percentage cover of inedible vegetation</p>
</dd>
<dt>canopy</dt><dd><p>Percentage canopy cover</p>
</dd>
<dt>distance</dt><dd><p>Distance from diurnal refuge</p>
</dd>
<dt>shelter</dt><dd><p>Whether or not a plot occurred within a shelter point (large
rock or boulder pile)</p>
</dd>
<dt>lat</dt><dd><p>Latitude of the plot location</p>
</dd>
<dt>long</dt><dd><p>Longitude of the plot location</p>
</dd>
</dl>



<h3>Details</h3>

<p>Macropods defaecate randomly as they forage and scat
(faecal pellet) surveys are a reliable method for detecting the
presence of rock-wallabies and other macropods.
Scats are used as an indication of spatial foraging patterns
of rock-wallabies and sympatric macropods. Scats deposited while
foraging were not confused with scats deposited while
resting because the daytime refuge areas of rock-wallabies
were known in detail for each colony and no samples were
taken from those areas. Each of the 200 sites were
examined separately to
account for the different levels of predation risk and the
abundance of rock-wallabies.
</p>


<h3>References</h3>

<p>Tuft KD, Crowther MS, Connell K, Mueller S and McArthur C (2011),
Predation risk and competitive interactions affect foraging of
an endangered refuge-dependent herbivore. Animal Conservation,
14: 447-457. doi: 10.1111/j.1469-1795.2011.00446.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wallabies)
wdat = data.frame(subset(wallabies,select=-c(lat,long)), 
  EaD = wallabies$edible*wallabies$distance,
  EaS = wallabies$edible*wallabies$shelter,
  DaS = wallabies$distance*wallabies$shelter)
M1 = glm(rw~., family = binomial(link = "logit"), data = wdat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
