<!DOCTYPE html><html><head><title>Help for package rLDCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rLDCP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cp'><p>Define the CP</p></a></li>
<li><a href='#data_structure'><p>Define the data structure</p></a></li>
<li><a href='#degree_mf'><p>Define generic calculation of fuzzy membership degrees</p></a></li>
<li><a href='#fuzzy_partitions'><p>Define the fuzzy parititions</p></a></li>
<li><a href='#fuzzy_rule'><p>Define the fuzzy rule</p></a></li>
<li><a href='#fuzzy_rules'><p>Define the fuzzy rules</p></a></li>
<li><a href='#generate_code'><p>Generate the R code</p></a></li>
<li><a href='#glmp'><p>Define the GLMP</p></a></li>
<li><a href='#infer_rules'><p>Make the inference</p></a></li>
<li><a href='#ldcp'><p>Define the LDCP system</p></a></li>
<li><a href='#ldcp_run'><p>Execute the LDCP system</p></a></li>
<li><a href='#operator'><p>Define the operator</p></a></li>
<li><a href='#pm'><p>Define the PM</p></a></li>
<li><a href='#pm_infer'><p>Call the g function</p></a></li>
<li><a href='#pm_multidimensional'><p>Define the pm of a multidimensional cp</p></a></li>
<li><a href='#pm_report'><p>Generate the report of y</p></a></li>
<li><a href='#report_template'><p>Define the report template</p></a></li>
<li><a href='#trapezoid_mf'><p>Define the trapezoid membership function</p></a></li>
<li><a href='#triangle_mf'><p>Define the triangle membership function</p></a></li>
<li><a href='#validate_xml'><p>Validate the XML file</p></a></li>
<li><a href='#xml2rldcp'><p>XML to rLDCP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Text Generation from Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-11-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricia Conde-Clemente [aut, cre], Jose M. Alonso [aut], Gracian Trivino [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patricia Conde-Clemente &lt;patricia.condeclemente@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Linguistic Descriptions of Complex Phenomena (LDCP) is an architecture and methodology that allows us to model complex phenomena, interpreting input data, and generating automatic text reports customized to the user needs (see &lt;<a href="https://doi.org/10.1016%2Fj.ins.2016.11.002">doi:10.1016/j.ins.2016.11.002</a>&gt; and &lt;<a href="https://doi.org/10.1007%2Fs00500-016-2430-5">doi:10.1007/s00500-016-2430-5</a>&gt;). The proposed package contains a set of methods that facilitates the development of LDCP systems. It main goal is increasing the visibility and practical use of this research line.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://phedes.com/rLDCP">http://phedes.com/rLDCP</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML (&ge; 3.98-1.4), methods</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-11-10 14:20:08 UTC; patri</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-11-10 16:42:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='cp'>Define the CP</h2><span id='topic+cp'></span>

<h3>Description</h3>

<p>In general, CP corresponds with specific parts of the analyzed phenomenon at a certain degree of
granularity. To create a computational model of the analyzed phenomenon,
the designer analyzes the everyday use of natural language about the monitored phenomenon with
the aim of identifying different parts (units of information or granules) based on his/her
subjective perceptions. According with Zadeh (1996), a granule is a clump of
elements which are drawn together by indistinguishability, similarity, proximity or functionality.
The GLMP handles granules by using CPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp(name, a, b = NULL, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_+3A_name">name</code></td>
<td>
<p>is the identifier of the CP.</p>
</td></tr>
<tr><td><code id="cp_+3A_a">a</code></td>
<td>
<p>is a vector <code>A = (a1, a2,... , an)</code> of linguistic expressions that
represents the whole linguistic domain of CP, e.g. we have the linguistic domain &quot;statistical data&quot;
that is represented with three linguistic variables (bad, good, very good).</p>
</td></tr>
<tr><td><code id="cp_+3A_b">b</code></td>
<td>
<p>is a vector <code>B = (b1, b2,... , bn)</code> of linguistic expressions (words or
sentences in natural language) that represents the reliability of the CP, e.g., the reliability of
the &quot;statistical data&quot; are (low, moderate, high). By default (<code>b = NULL</code>), the CP does not manage information about reliability.</p>
</td></tr>
<tr><td><code id="cp_+3A_r">r</code></td>
<td>
<p>is a vector <code>R = (r1, r2,... , rn)</code> of relevance degrees 0 &lt;= ri &lt;=1 assigned to each ai in the
specific context, e.g., the relevance of the linguistic expressions (bad, good, very good) is (0.5, 0.5, 1)
means the perception of &quot;very good&quot; is more relevant than the other two choices.
By default (<code>r = NULL</code>), the function create a r vector with the maximum degree of relevance for all linguistic expression, e.g., (1,1,1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>CP = list(a, w, r, b, wb)</code> where <code>w</code> and <code>wb</code> are vectors with the validity degrees (wi and wbi in [0,1]) of the linguistic expressions in <code>a</code> and <code>b</code> respectively.
These vectors are initialized with 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCP &lt;-cp("myCP", c("bad", "good", "very good"))
myCP &lt;- cp("myCP", c("bad", "good", "very good"), c("low", "moderate", "high"))
myCP &lt;- cp("myCP", c("bad", "good", "very good"), r=c(1,0.8,0.9))
myCP &lt;- cp("myCP", c("bad", "good", "very good"), c("low", "moderate", "high"), c(1,0.8,0.9))

</code></pre>

<hr>
<h2 id='data_structure'>Define the data structure</h2><span id='topic+data_structure'></span>

<h3>Description</h3>

<p>Data structure provides the GLMP input. It constructor receives the input values and the method that defines
the data structure, i.e., the set of preprocesing techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_structure(input, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_structure_+3A_input">input</code></td>
<td>
<p>is the input data. May be a vector, list or matrix with numbers.</p>
</td></tr>
<tr><td><code id="data_structure_+3A_method">method</code></td>
<td>
<p>is the function with the data preprocesing techniques needed to prepare the GLMP input. The method must have
one argument, the <code>input</code> data:
</p>
<p><code>my_method &lt;- function(input)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>data_structure = list(input, method)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
values &lt;- matrix(c(34,11,9,32), ncol=2)

my_method &lt;- function (input){
 output &lt;- c(mean(input[,1]), mean(input[,2]))
 output
}
 my_data_structure &lt;- data_structure(values,my_method)
</code></pre>

<hr>
<h2 id='degree_mf'>Define generic calculation of fuzzy membership degrees</h2><span id='topic+degree_mf'></span>

<h3>Description</h3>

<p>It is a generic function in charge of computing fuzzy membership degrees. Namely, it identifies the specific
membership function to consider and run the related method for computing the membership degree for a given
input value. It takes as input an object (<code>trapezoid_mf</code>, <code>triangle_mf</code> and <code>fuzzy_partitions</code>) and the related input values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_mf(shape, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_mf_+3A_shape">shape</code></td>
<td>
<p>is the object (<code>trapezoid_mf</code>, <code>triangle_mf</code> and <code>fuzzy_partitions</code>) to dispatch to.</p>
</td></tr>
<tr><td><code id="degree_mf_+3A_input">input</code></td>
<td>
<p>is the value to be assess.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the membership degree for a given input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- degree_mf(triangle_mf(450,450,550),450)

w &lt;- degree_mf(fuzzy_partitions(triangle_mf(450,450,550),
                                triangle_mf(450,550,600),
                                trapezoid_mf(550,600,800,1000),
                                triangle_mf(800,1000,1300),
                                trapezoid_mf(1000,1300,1500,1500)),450)
</code></pre>

<hr>
<h2 id='fuzzy_partitions'>Define the fuzzy parititions</h2><span id='topic+fuzzy_partitions'></span>

<h3>Description</h3>

<p>It is a constructor of fuzzy partitions, it defines a set of membership functions.  It takes as input a set of
<code>trapezoid_mf</code> or <code>triangle_mf</code> or objects in the shape_mf class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_partitions(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_partitions_+3A_...">...</code></td>
<td>
<p>are the diferent partitions, e.g., <code>trapezoid_mf</code> or <code>triangle_mf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>(fuzzy_partitions &lt;- list(...)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fuzzy_partitions(triangle_mf(450,450,550),
                 triangle_mf(450,550,600),
                 trapezoid_mf(550,600,800, 1000),
                 triangle_mf(800,1000,1300),
                 trapezoid_mf(1000,1300,1500,1500))
</code></pre>

<hr>
<h2 id='fuzzy_rule'>Define the fuzzy rule</h2><span id='topic+fuzzy_rule'></span>

<h3>Description</h3>

<p>We define a fuzzy rule using the numbers 1 and 0.
rule(0,0,1,0,0, 0,0,1,0,0, 0,0,1,0,0, 0,0,1)
</p>
<p>This is an example of fuzzy_rule(0,0,1,0,0,1). In the fuzzy rule the number 1 means that the linguistic
expression is included and the number 0 means that the linguistic expression is not included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_rule(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_rule_+3A_...">...</code></td>
<td>
<p>the 0 and 1 that compose the fuzzy rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>fuzzy_rule &lt;- c(...)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the rule "IF CPtemp IS warm THEN CPcomfort IS very comfortable"
#is coded as:

 fuzzy_rule(0,1,0,0,0,1)

# Where, the first three values (0,1,0) correspond with the linguistic
# expressions Atemp=(cold, warm, hot) that define the room temperature (CPtemp).
# The last three values (0,0,1) are related to the linguistic expressions
# Acomfort=(uncomfortable, comfortable and very comfortable) that define
# the room comfort (CPcomfort).
#
</code></pre>

<hr>
<h2 id='fuzzy_rules'>Define the fuzzy rules</h2><span id='topic+fuzzy_rules'></span>

<h3>Description</h3>

<p>It is a constructor of fuzzy rules, the arguments are the diferent <code><a href="#topic+fuzzy_rule">fuzzy_rule</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_rules(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_rules_+3A_...">...</code></td>
<td>
<p>one or more <code><a href="#topic+fuzzy_rule">fuzzy_rule</a></code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fuzzy_rules &lt;- list(...)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fuzzy_rules(fuzzy_rule(0,0,1, 0,0,1, 0,0,1),
     fuzzy_rule(1,0,0, 1,0,0, 1,0,0),
     fuzzy_rule(0,1,0, 0,1,0, 0,1,0))
</code></pre>

<hr>
<h2 id='generate_code'>Generate the R code</h2><span id='topic+generate_code'></span>

<h3>Description</h3>

<p>The function takes as input the path to a XML file that contains a LDCP system.
Then it generates its corresponding in R code. This R code is stored in an output
file. The output file path is another function parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_code(input, output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_code_+3A_input">input</code></td>
<td>
<p>is the XML source path file. E.g. &quot;/folder/ldcp_system.xml&quot;.</p>
</td></tr>
<tr><td><code id="generate_code_+3A_output">output</code></td>
<td>
<p>is the R destination path file. E.g. &quot;/folder/ldcp_system.R&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the process ends without error, the user will receive a message that indicates
that the code has been generated successfully. Otherwise, the user will receive the
detailed list of errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: generate_code('extdata/comfortableroom','comfortableroom')

## The code has been generated successfully
</code></pre>

<hr>
<h2 id='glmp'>Define the GLMP</h2><span id='topic+glmp'></span>

<h3>Description</h3>

<p>Granular Linguistic Model of Phenomena (GLMP) is a network of <code><a href="#topic+cp">cp</a></code> and <code><a href="#topic+pm">pm</a></code> objects.
that allows the designer to model computationally her/his own perceptions. The input data are introduced
into the model through 1PMs which interpret the input data and create CPs. Then, 2PMs take several CPs
as input and generate 2CPs. Of course, following the same scheme, is possible to add additional upper levels.
</p>
<p>The <code>glmp</code> constructor receive as arguments the list of pms and the method with the computational model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmp(pms, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmp_+3A_pms">pms</code></td>
<td>
<p>is the list of <code><a href="#topic+pm">pm</a></code> objects included in the <code>glmp</code>.</p>
</td></tr>
<tr><td><code id="glmp_+3A_method">method</code></td>
<td>
<p>is the function with the glmp computational model. The method must have two arguments: the list of
<code><a href="#topic+pm">pm</a></code> objects defined in the <code>glmp</code> and the input <code>data</code>:
</p>
<p><code>my_glmp_method &lt;- function(pm,input)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>glmp = list(pm, method)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: glmp_method &lt;- function(pm,input){

  pm$pm_depth   &lt;- pm_infer(pm$pm_depth, input[1])
  pm$pm_height  &lt;- pm_infer(pm$pm_height,input[2])
  pm$pm_width   &lt;- pm_infer(pm$pm_width, input[3])

  pm$pm_frame  &lt;- pm_infer(pm$pm_frame, list( pm$pm_depth$y,
                                           pm$pm_height$y,
                                           pm$pm_width$y)
  )
  pm
}

my_glmp &lt;- glmp(list(pm_depth  = pm_depth,
                     pm_height = pm_height,
                     pm_width  = pm_width,
                     pm_frame  = pm_frame),
                glmp_method)
                
## End(Not run)
</code></pre>

<hr>
<h2 id='infer_rules'>Make the inference</h2><span id='topic+infer_rules'></span>

<h3>Description</h3>

<p>Make an inference with the fuzzy rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_rules(rules, operator, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_rules_+3A_rules">rules</code></td>
<td>
<p>the set of fuzzy rules.</p>
</td></tr>
<tr><td><code id="infer_rules_+3A_operator">operator</code></td>
<td>
<p>the <code><a href="#topic+operator">operator</a></code> object.</p>
</td></tr>
<tr><td><code id="infer_rules_+3A_input">input</code></td>
<td>
<p>is the list of validity degrees related to the input <code><a href="#topic+cp">cp</a></code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector that containd the result of the inference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In the example the input of the fuzzy rule correspond with two CPs and each CP has 3
## linguistic variables, e.g, {"bad", "good", "very good"}. The output also
## correspond with a CP with 3 linguistic variables.

 infer_rules(fuzzy_rules(fuzzy_rule(0,0,1, 0,0,1, 0,0,1),
                   fuzzy_rule(1,0,0, 1,0,0, 1,0,0),
                   fuzzy_rule(0,1,0, 0,1,0, 0,1,0)),
             operator(min, max),
             list(c(0,0.5,0.5),c(0.5,0.5,0)))
## [1] 0.0 0.5 0.0
</code></pre>

<hr>
<h2 id='ldcp'>Define the LDCP system</h2><span id='topic+ldcp'></span>

<h3>Description</h3>

<p>Linguistic Descriptions of Complex Phenomena (LDCP) is a technology focused on
modeling complex phenomena, interpreting input data and generating automatic
text reports customized to the user needs. #'
The <code>ldcp</code> constructor receive as arguments: the <code>data_structure</code>,
the <code><a href="#topic+glmp">glmp</a></code> and the <code><a href="#topic+report_template">report_template</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldcp(data, glmp, report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldcp_+3A_data">data</code></td>
<td>
<p>is the <code><a href="#topic+data_structure">data_structure</a></code> object.</p>
</td></tr>
<tr><td><code id="ldcp_+3A_glmp">glmp</code></td>
<td>
<p>is the <code><a href="#topic+glmp">glmp</a></code> object.</p>
</td></tr>
<tr><td><code id="ldcp_+3A_report">report</code></td>
<td>
<p>is the <code><a href="#topic+report_template">report_template</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated system <code>ldcp = list(data, glmp, report)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code> and <code><a href="#topic+pm">pm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: my_ldcp &lt;- ldcp(my_data,my_glmp,my_report)
</code></pre>

<hr>
<h2 id='ldcp_run'>Execute the LDCP system</h2><span id='topic+ldcp_run'></span>

<h3>Description</h3>

<p>Execute the <code><a href="#topic+ldcp">ldcp</a></code> system in order to obtain the linguistic report.
This method follows these three sequential steps 1) Data acquisition, 2) Interpretation and 3)
Report generation.
Data acquisition process gets the input data and prepares the data structure. Then, the data
are interpreted using the GLMP. The result is a set of computational perceptions (CP) that are valid to describe
these data. Finally, the report generation process generates a linguistic report using the report template
and the previous set of CPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldcp_run(ldcp, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldcp_run_+3A_ldcp">ldcp</code></td>
<td>
<p>is the <code><a href="#topic+ldcp">ldcp</a></code> system.</p>
</td></tr>
<tr><td><code id="ldcp_run_+3A_input">input</code></td>
<td>
<p>is the system input data. May be a vector, list, or matrix with numbers. It is a new input to the <code><a href="#topic+data_structure">data_structure</a></code> object. By default, is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+ldcp">ldcp</a></code> object that contains the execution results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: my_ldcp &lt;- ldcp_run(my_ldcp)
</code></pre>

<hr>
<h2 id='operator'>Define the operator</h2><span id='topic+operator'></span>

<h3>Description</h3>

<p>The operator defines the conjunction and disjunction functions used in the fuzzy rules.
It takes as input parameters the function used to implement the conjunction,
and the function used to implement the disjunction, e.g., &quot;operator(min, max)&quot;, where
min and max are functions defined by the R language that calculate the maximum and
minimum, respectively, from a set of values received as input. Note that, we implicitly assign
to the fuzzy implication operator (THEN) the function given for conjunction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operator(conjunction, disjunction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operator_+3A_conjunction">conjunction</code></td>
<td>
<p>is the method used to make the conjunction.</p>
</td></tr>
<tr><td><code id="operator_+3A_disjunction">disjunction</code></td>
<td>
<p>is the method used to make the disjunction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>opertator</code> object <code>my_op &lt;- list(conjunction, disjunction)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>operator &lt;- operator(min, max)
</code></pre>

<hr>
<h2 id='pm'>Define the PM</h2><span id='topic+pm'></span>

<h3>Description</h3>

<p>Perception Mapping (PM) is used to create and aggregate <code><a href="#topic+cp">cp</a></code> objects. Each PM receives
a set of inputs (<code><a href="#topic+cp">cp</a></code> objects or numerical values) which are aggregated into a single CP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm(u = NULL, y, g, t = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm_+3A_u">u</code></td>
<td>
<p>is a vector of n input <code><a href="#topic+cp">cp</a></code>s <code>u = (u1, u2,..., un)</code>. In the special case
of first level perception mappings (1PM) the inputs are numerical values provided either by sensors or
obtained from a database.</p>
</td></tr>
<tr><td><code id="pm_+3A_y">y</code></td>
<td>
<p>is the output <code><a href="#topic+cp">cp</a></code>.</p>
</td></tr>
<tr><td><code id="pm_+3A_g">g</code></td>
<td>
<p>is an aggregation function employed to calculate w from the input <code><a href="#topic+cp">cp</a></code>s. For example,
<code>g</code> might be implemented using a set of fuzzy rules. In the case of 1PMs, <code>g</code> is built using a set of
membership functions.</p>
</td></tr>
<tr><td><code id="pm_+3A_t">t</code></td>
<td>
<p>is a text generation algorithm which allows generating the sentences in <code>A</code>. In simple cases,
<code>t</code> is a linguistic template, e.g., cat(&quot;Alabama has&quot;, value, &quot;the number of women in the last census&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>pm = list(u,y,g,t)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: cp_depth &lt;- cp("cp_depth",c("far",
                            "bit far",
                            "good",
                            "close",
                            "very close"))

g_depth &lt;- function(u,y){
  y$w &lt;- degree_mf(fuzzy_partitions(triangle_mf(450,450,550),
                                 triangle_mf( 450,550,600),
                                 trapezoid_mf(550,600,800, 1000),
                                 triangle_mf( 800,1000,1300),
                                 trapezoid_mf( 1000,1300,1500,1500)),u)
  y
}

pm_depth  &lt;- pm(y=cp_depth, g=g_depth)

########################### HEIGHT DEFINITION ###########################################
cp_height &lt;- cp("cp_height", c("high",
                             "average high",
                             "centered",
                             "average low",
                             "low"))

g_height &lt;- function(u,y){
  y$w &lt;- degree_mf(fuzzy_partitions(trapezoid_mf(-1000,-1000,-600,-400),
                                               triangle_mf(-600,-400,0),
                                               trapezoid_mf(-400,0,200,400),
                                               triangle_mf(200,400,600),
                                               trapezoid_mf(400,600,1000,1000)),u)
  y
}

pm_height &lt;- pm(y=cp_height, g=g_height)

########################### WIDTH DEFINITION ###########################################
cp_width &lt;- cp("cp_width",  c("left",
                               "average left",
                                "centered",
                                "average right",
                                 "right"))

g_width &lt;- function(u,y){
  y$w &lt;- degree_mf(fuzzy_partitions(triangle_mf(-1000,-600,-400),
                                               triangle_mf(-600,-400,0),
                                              triangle_mf(-400,0,400),
                                               triangle_mf(0,400,600),
                                               triangle_mf(400,600,1000,1000)),
                              u)
  y
}

pm_width  &lt;- pm(y=cp_width,  g=g_width)

########################### FRAME DEFINITION ###########################################
cp_frame &lt;- cp("cp_frame", c("bad",
                             "middle",
                             "good"))

g_frame &lt;- function(u,y){

  operator &lt;- operator(min, max)

  y$w&lt;- infer_rules(fuzzy_rules( fuzzy_rule(0,0,1,0,0, 0,0,1,0,0, 0,0,1,0,0, 0,0,1),
                           fuzzy_rule(1,1,1,1,1, 1,1,1,1,1, 1,1,0,1,1, 1,0,0),
                           fuzzy_rule(1,1,1,1,1, 1,0,0,0,1, 0,0,1,0,0, 1,0,0),
                           fuzzy_rule(1,0,0,0,1, 1,1,1,1,1, 0,0,1,0,0, 1,0,0),
                           fuzzy_rule(0,1,0,1,0, 0,1,0,1,0, 0,0,1,0,0, 0,1,0)),
                     operator,
                     list(u[[1]]$w,u[[2]]$w,u[[3]]$w))

  y
}

t_frame &lt;- function(y){

  templates &lt;- c("It has been taken a bad framed photo",
                 "It has been taken a middle framed photo",
                 "It has been taken a good framed photo")

  return( templates[which.max(y$w)])
}

pm_frame &lt;-  pm(y=cp_frame, g=g_frame, t=t_frame)

## End(Not run)
</code></pre>

<hr>
<h2 id='pm_infer'>Call the g function</h2><span id='topic+pm_infer'></span>

<h3>Description</h3>

<p>It call the <code>g</code> function in order to make the inference,
i.e.,  map inputs <code>u</code> to output <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm_infer(pm, u = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm_infer_+3A_pm">pm</code></td>
<td>
<p>is the <code>pm</code> object.</p>
</td></tr>
<tr><td><code id="pm_infer_+3A_u">u</code></td>
<td>
<p>is the new <code>pm</code> input. By default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>pm</code> obtained after calling <code>g</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cp_depth &lt;- cp("cp_depth", c("far",
                           "bit far",
                           "good",
                           "close",
                           "very close"))

g_depth &lt;- function(u,y){
   y$w &lt;- degree_mf(fuzzy_partitions(triangle_mf(450,450,550),
                                              triangle_mf( 450,550,600),
                                              trapezoid_mf(550,600,800, 1000),
                                              triangle_mf( 800,1000,1300),
                                              trapezoid_mf( 1000,1300,1500,1500)),u)
 y
}

pm_depth  &lt;- pm(y=cp_depth, g=g_depth)
pm_depth   &lt;- pm_infer(pm_depth, 650)

</code></pre>

<hr>
<h2 id='pm_multidimensional'>Define the pm of a multidimensional cp</h2><span id='topic+pm_multidimensional'></span>

<h3>Description</h3>

<p>It is a set of <code><a href="#topic+pm">pm</a></code>s that infer a multidimensional <code><a href="#topic+cp">cp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm_multidimensional(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm_multidimensional_+3A_...">...</code></td>
<td>
<p>the set of <code><a href="#topic+pm">pm</a></code>s</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>pm_multidimensional &lt;- list(...)</code>
</p>

<hr>
<h2 id='pm_report'>Generate the report of y</h2><span id='topic+pm_report'></span>

<h3>Description</h3>

<p>It call the <code>t</code> function in order to generate the linguistic
descriptions that better describe the output <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm_report(pm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm_report_+3A_pm">pm</code></td>
<td>
<p>is the <code>pm</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the description obtained after calling <code>t</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp_frame &lt;- cp("cp_frame", c("bad",
                           "middle",
                           "good"))

                           g_frame &lt;- function(u,y){

operator &lt;- operator(min, max)

  y$w&lt;- infer_rules(fuzzy_rules( fuzzy_rule(0,0,1,0,0, 0,0,1,0,0, 0,0,1,0,0, 0,0,1),
                           fuzzy_rule(1,1,1,1,1, 1,1,1,1,1, 1,1,0,1,1, 1,0,0),
                           fuzzy_rule(1,1,1,1,1, 1,0,0,0,1, 0,0,1,0,0, 1,0,0),
                           fuzzy_rule(1,0,0,0,1, 1,1,1,1,1, 0,0,1,0,0, 1,0,0),
                           fuzzy_rule(0,1,0,1,0, 0,1,0,1,0, 0,0,1,0,0, 0,1,0)),
                     operator,
                     list(u[[1]]$w,u[[2]]$w,u[[3]]$w))

  y
}

t_frame &lt;- function(y){

 templates &lt;- c("It has been taken a bad framed photo",
                 "It has been taken a middle framed photo",
                 "It has been taken a good framed photo")

  return( templates[which.max(y$w)])
}

pm_frame &lt;-  pm(y=cp_frame, g=g_frame, t=t_frame)
pm_report(pm_frame)
</code></pre>

<hr>
<h2 id='report_template'>Define the report template</h2><span id='topic+report_template'></span>

<h3>Description</h3>

<p>The text generation algorithm contains the programming code capable of generating
the appropriate report to each specific user. Algorithms must select and order
the linguistic expressions to generate the text included in the report.
#'
The <code>report_template</code> constructor receive as arguments the list of properties
and the method (programming code) capable of generating the appropriate report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_template(properties = NULL, method, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_template_+3A_properties">properties</code></td>
<td>
<p>may be a vector, list or matrix with the user's needs,
preferences and goals. By default <code>properties = NULL</code>.</p>
</td></tr>
<tr><td><code id="report_template_+3A_method">method</code></td>
<td>
<p>is the function that generates the appropriate report. The method must have
two arguments: the list of properties and the list of pms:
<code>my_report_method</code>  <code>&lt;-</code> <code>function(properties, pm){...}</code>.</p>
</td></tr>
<tr><td><code id="report_template_+3A_description">description</code></td>
<td>
<p>is the result of call the report template. By default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated <code>report_template= list(properties, method,description)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>properties = NULL
report_method &lt;- function(properties,pm){
  pm_report(pm$pm_frame)
}
my_report &lt;- report_template(properties,
                    report_method)
</code></pre>

<hr>
<h2 id='trapezoid_mf'>Define the trapezoid membership function</h2><span id='topic+trapezoid_mf'></span>

<h3>Description</h3>

<p>It is a constructor of trapezoidal shapes. They take as input the numerical values which
define the anchor points in membership functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapezoid_mf(a, b, c, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapezoid_mf_+3A_a">a</code></td>
<td>
<p>the trapezoid point a.</p>
</td></tr>
<tr><td><code id="trapezoid_mf_+3A_b">b</code></td>
<td>
<p>the trapezoid point b.</p>
</td></tr>
<tr><td><code id="trapezoid_mf_+3A_c">c</code></td>
<td>
<p>the trapezoid point c.</p>
</td></tr>
<tr><td><code id="trapezoid_mf_+3A_d">d</code></td>
<td>
<p>the trapezoid point d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>(trapezoid_mf &lt;- list(a,b,c,d))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trapezoid_mf(0, 1, 2, 3)
</code></pre>

<hr>
<h2 id='triangle_mf'>Define the triangle membership function</h2><span id='topic+triangle_mf'></span>

<h3>Description</h3>

<p>It is a constructor of triangular shapes. They take as input the numerical values which
define the anchor points in membership functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle_mf(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_mf_+3A_a">a</code></td>
<td>
<p>the trapezoid point a.</p>
</td></tr>
<tr><td><code id="triangle_mf_+3A_b">b</code></td>
<td>
<p>the trapezoid point b.</p>
</td></tr>
<tr><td><code id="triangle_mf_+3A_c">c</code></td>
<td>
<p>the trapezoid point c.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>(triangle_mf &lt;- list(a,b,c))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle_mf(0, 1, 2)
</code></pre>

<hr>
<h2 id='validate_xml'>Validate the XML file</h2><span id='topic+validate_xml'></span>

<h3>Description</h3>

<p>The function takes as input the path to a XML file that contains a LDCP system.
Then it validates the LDCP system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_xml(xmlfile, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_xml_+3A_xmlfile">xmlfile</code></td>
<td>
<p>is the XML source path file. E.g. &quot;/folder/ldcp_system.xml&quot;.</p>
</td></tr>
<tr><td><code id="validate_xml_+3A_schema">schema</code></td>
<td>
<p>is the ldcp schema path file. By default is &quot;ldcpSchema.xsd&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the process ends without error, the user will receive the message that indicates
that the XML is valid. Otherwise, the user will receive the detailed list of errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: validate_xml('extdata/comfortableroom.xml')

## The xml is valid

</code></pre>

<hr>
<h2 id='xml2rldcp'>XML to rLDCP</h2><span id='topic+xml2rldcp'></span>

<h3>Description</h3>

<p>The function takes as input the path to a XML file that contains a LDCP system.
Then it validates the LDCP system and generates its corresponding in R code.
This R code is stored in an output file. The output file path is another
function parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml2rldcp(input, output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml2rldcp_+3A_input">input</code></td>
<td>
<p>is the XML source path file. E.g. &quot;/folder/ldcp_system.xml&quot;.</p>
</td></tr>
<tr><td><code id="xml2rldcp_+3A_output">output</code></td>
<td>
<p>is the R destination path file. E.g. &quot;/folder/ldcp_system.R&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the process ends without error, the user will receive two messages:
one indicates that the XML is valid and the other indicates that the code has
been generated successfully. Otherwise, the user will receive the detailed list of errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: xml2rldcp('extdata/comfortableroom.xml','comfortableroom.R')

## The xml is valid
## The code has been generated successfully
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
