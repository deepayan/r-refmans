<!DOCTYPE html><html><head><title>Help for package mFilter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mFilter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bkfilter'>
<p>Baxter-King filter of a time series</p></a></li>
<li><a href='#bwfilter'>
<p>Butterworth filter of a time series</p></a></li>
<li><a href='#cffilter'>
<p>Christiano-Fitzgerald filter of a time series</p></a></li>
<li><a href='#hpfilter'>
<p>Hodrick-Prescott filter of a time series</p></a></li>
<li><a href='#mFilter'>
<p>Decomposition of a time series into trend and cyclical components</p>
using various filters</a></li>
<li><a href='#mFilter-methods'><p>Methods for mFilter objects</p></a></li>
<li><a href='#mFilter-package'>
<p>Getting started with the mFilter package</p></a></li>
<li><a href='#trfilter'>
<p>Trigonometric regression filter of a time series</p></a></li>
<li><a href='#unemp'><p>US Quarterly Unemployment Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Miscellaneous Time Series Filters</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-04</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-5</td>
</tr>
<tr>
<td>Author:</td>
<td>Mehmet Balcilar &lt;mehmet@mbalcilar.net&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tseries, pastecs, locfit, tseriesChaos, tsDyn, forecast</td>
</tr>
<tr>
<td>Description:</td>
<td>The mFilter package implements several time series filters useful
        for smoothing and extracting trend and cyclical components of a
        time series. The routines are commonly used in economics and
        finance, however they should also be interest to other areas.
        Currently, Christiano-Fitzgerald, Baxter-King,
        Hodrick-Prescott, Butterworth, and trigonometric regression
        filters are included in the package.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mehmet Balcilar &lt;mehmet@mbalcilar.net&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.mbalcilar.net">http://www.mbalcilar.net</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-04 20:52:13 UTC; mbalcilar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-04 22:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='bkfilter'>
Baxter-King filter of a time series
</h2><span id='topic+bkfilter'></span>

<h3>Description</h3>

<p>This function implements the Baxter-King approximation to
the band pass filter for a time series. The function computes cyclical
and trend components of the time series using band-pass
approximation for fixed and variable length filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkfilter(x,pl=NULL,pu=NULL,nfix=NULL,type=c("fixed","variable"),drift=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkfilter_+3A_x">x</code></td>
<td>
<p>a regular time series</p>
</td></tr>
<tr><td><code id="bkfilter_+3A_type">type</code></td>
<td>
<p>character, indicating the filter type,
<code>"fixed"</code>, for the fixed length Baxter-King filter
(default),
<code>"variable"</code>, for the variable length Baxter-King filter.</p>
</td></tr>
<tr><td><code id="bkfilter_+3A_pl">pl</code></td>
<td>
<p>integer. minimum period of oscillation of desired component (pl&lt;=2).</p>
</td></tr>
<tr><td><code id="bkfilter_+3A_pu">pu</code></td>
<td>
<p>integer. maximum period of oscillation of desired component (2&lt;=pl&lt;pu&lt;infinity).</p>
</td></tr>
<tr><td><code id="bkfilter_+3A_drift">drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td></tr>
<tr><td><code id="bkfilter_+3A_nfix">nfix</code></td>
<td>
<p>sets fixed lead/lag length or order of the filter. The
<code>nfix</code> option sets the order of the filter by 2*nfix+1. The
default is <code>frequency(x)*3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The Baxter-King filter is a finite data approximation to the
ideal bandpass filter with following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n}_{j=-n}\hat{B}_{j} x_{t+j}=\hat{B}_0
  x_t + \sum^{n}_{j=1} \hat{B}_j (x_{t-j}+x_{t+j})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=B_j-\frac{1}{2n+1}\sum^{n}_{j=-n}B_{j}</code>
</p>

<p>If <code>drift=TRUE</code> the drift adjusted series is obtained
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A &quot;<code>mFilter</code>&quot; object (see <code><a href="#topic+mFilter">mFilter</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+hpfilter">hpfilter</a></code>, <code><a href="#topic+trfilter">trfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.bk &lt;- bkfilter(unemp)
plot(unemp.bk)
unemp.bk1 &lt;- bkfilter(unemp, drift=TRUE)
unemp.bk2 &lt;- bkfilter(unemp, pl=8,pu=40,drift=TRUE)
unemp.bk3 &lt;- bkfilter(unemp, pl=2,pu=60,drift=TRUE)
unemp.bk4 &lt;- bkfilter(unemp, pl=2,pu=40,drift=TRUE)

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.bk1$x,
    main="Baxter-King filter of unemployment: Trend, drift=TRUE",
    col=1, ylab="")
lines(unemp.bk1$trend,col=2)
lines(unemp.bk2$trend,col=3)
lines(unemp.bk3$trend,col=4)
lines(unemp.bk4$trend,col=5)
legend("topleft",legend=c("series", "pl=2, pu=32", "pl=8, pu=40",
      "pl=2, pu=60", "pl=2, pu=40"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.bk1$cycle,
main="Baxter-King filter of unemployment: Cycle,drift=TRUE",
      col=2, ylab="", ylim=range(unemp.bk3$cycle,na.rm=TRUE))
lines(unemp.bk2$cycle,col=3)
lines(unemp.bk3$cycle,col=4)
lines(unemp.bk4$cycle,col=5)
## legend("topleft",legend=c("pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
## "pl=2, pu=40"), col=1:5, lty=rep(1,5), ncol=1)

par(opar)
</code></pre>

<hr>
<h2 id='bwfilter'>
Butterworth filter of a time series
</h2><span id='topic+bwfilter'></span>

<h3>Description</h3>

<p>Filters a time series using the Butterworth square-wave
highpass filter described in Pollock (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwfilter(x,freq=NULL,nfix=NULL,drift=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwfilter_+3A_x">x</code></td>
<td>
<p>a regular time series</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_nfix">nfix</code></td>
<td>
<p>sets the order of the filter. The default is
<code>nfix=2</code>, when <code>nfix=NULL</code>.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_freq">freq</code></td>
<td>
<p>integer, the cut-off frequency of the Butterworth
filter. The default is <code>trunc(2.5*frequency(x))</code>.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_drift">drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The digital version of the Butterworth highpass filter is described by the
rational polynomial expression (the filter's z-transform)
</p>
<p style="text-align: center;"><code class="reqn">\frac{\lambda(1-z)^n(1-z^{-1})^n}{(1+z)^n(1+z^{-1})^n+\lambda(1-z)^n(1-z^{-1})^n}</code>
</p>

<p>The time domain version can be obtained by substituting <code class="reqn">z</code> for the
lag operator <code class="reqn">L</code>.
</p>
<p>Pollock derives a specialized finite-sample version of the Butterworth
filter on the basis of signal extraction theory. Let <code class="reqn">s_t</code> be the
trend and <code class="reqn">c_t</code> cyclical component of <code class="reqn">y_t</code>, then these
components are extracted as
</p>
<p style="text-align: center;"><code class="reqn">y_t=s_t+c_t=\frac{(1+L)^n}{(1-L)^d}\nu_t+(1-L)^{n-d}\varepsilon_t</code>
</p>

<p>where <code class="reqn">\nu_t \sim N(0,\sigma_\nu^2)</code> and <code class="reqn">\varepsilon_t \sim N(0,\sigma_\varepsilon^2)</code>.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A &quot;<code>mFilter</code>&quot; object (see <code><a href="#topic+mFilter">mFilter</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code>, <code><a href="#topic+hpfilter">hpfilter</a></code>, <code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+bkfilter">bkfilter</a></code>, <code><a href="#topic+trfilter">trfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.bw &lt;- bwfilter(unemp)
plot(unemp.bw)
unemp.bw1 &lt;- bwfilter(unemp, drift=TRUE)
unemp.bw2 &lt;- bwfilter(unemp, freq=8,drift=TRUE)
unemp.bw3 &lt;- bwfilter(unemp, freq=10, nfix=3, drift=TRUE)
unemp.bw4 &lt;- bwfilter(unemp, freq=10, nfix=4, drift=TRUE)

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.bw1$x,
     main="Butterworth filter of unemployment: Trend,
     drift=TRUE",col=1, ylab="")
lines(unemp.bw1$trend,col=2)
lines(unemp.bw2$trend,col=3)
lines(unemp.bw3$trend,col=4)
lines(unemp.bw4$trend,col=5)
legend("topleft",legend=c("series", "freq=10, nfix=2",
       "freq=8, nfix=2", "freq=10, nfix=3", "freq=10, nfix=4"),
       col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.bw1$cycle,
     main="Butterworth filter of unemployment: Cycle,drift=TRUE",
     col=2, ylab="", ylim=range(unemp.bw3$cycle,na.rm=TRUE))
lines(unemp.bw2$cycle,col=3)
lines(unemp.bw3$cycle,col=4)
lines(unemp.bw4$cycle,col=5)
## legend("topleft",legend=c("series", "freq=10, nfix=2", "freq=8,
## nfix=2", "freq## =10, nfix=3", "freq=10, nfix=4"), col=1:5,
## lty=rep(1,5), ncol=1)

par(opar)
</code></pre>

<hr>
<h2 id='cffilter'>
Christiano-Fitzgerald filter of a time series
</h2><span id='topic+cffilter'></span>

<h3>Description</h3>

<p>This function implements the Christiano-Fitzgerald approximation to
the ideal band pass filter for a time series. The function computes cyclical
and trend components of the time series using several band-pass
approximation strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cffilter(x,pl=NULL,pu=NULL,root=FALSE,drift=FALSE,
         type=c("asymmetric","symmetric","fixed","baxter-king","trigonometric"),
	 nfix=NULL,theta=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cffilter_+3A_x">x</code></td>
<td>
<p>a regular time series.</p>
</td></tr>
<tr><td><code id="cffilter_+3A_type">type</code></td>
<td>
<p>the filter type,
<code>"asymmetric"</code>, asymmetric Christiano-Fitzgerald filter
(default),
<code>"symmetric"</code>, symmetric Christiano-Fitzgerald filter
<code>"fixed"</code>, fixed length Christiano-Fitzgerald filter,
<code>"baxter-king"</code>, Baxter-King fixed length symmetric filter,
<code>"trigonometric"</code>, trigonometric regression filter.</p>
</td></tr>
<tr><td><code id="cffilter_+3A_pl">pl</code></td>
<td>
<p>minimum period of oscillation of desired component (pl&lt;=2).</p>
</td></tr>
<tr><td><code id="cffilter_+3A_pu">pu</code></td>
<td>
<p>maximum period of oscillation of desired component (2&lt;=pl&lt;pu&lt;infinity).</p>
</td></tr>
<tr><td><code id="cffilter_+3A_root">root</code></td>
<td>
<p>logical, <code>FALSE</code> if no unit root in time series
(default),  <code>TRUE</code> if unit root in time series. The
<code>root</code> option has no effect if <code>type</code> is
<code>"baxter-king"</code> or <code>"trigonometric"</code>.</p>
</td></tr>
<tr><td><code id="cffilter_+3A_drift">drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td></tr>
<tr><td><code id="cffilter_+3A_nfix">nfix</code></td>
<td>
<p>sets fixed lead/lag length or order of the filter with
<code>"baxter-king"</code> and <code>"fixed"</code>. The <code>nfix</code> option sets
the order of the filter by 2*nfix+1. The default is <code>nfix=1</code>.</p>
</td></tr>
<tr><td><code id="cffilter_+3A_theta">theta</code></td>
<td>
<p>moving average coefficients for time series model: x(t) =
mu + root*x(t-1) + theta(1)*e(t) + theta(2)*e(t-1) + ..., where e(t)
is a white noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The finite sample approximation to the ideal bandpass filter uses the
alternative filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n_2}_{j=-n_1}\hat{B}_{t,j} x_{t+j}</code>
</p>

<p>Here the weights, <code class="reqn">\hat{B}_{t,j}</code>, of the approximation is a
solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{t,j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \}</code>
</p>

<p>The Christiano-Fitzgerald filter is a finite data approximation to the
ideal bandpass filter and minimizes the mean squared error defined in the
above equation.
</p>
<p>Several band-pass approximation strategies can be selected in the
function <code>cffilter</code>. The default setting of <code>cffilter</code> returns
the filtered data <code class="reqn">\hat{y_t}</code> associated with the unrestricted optimal filter
assuming no unit root, no drift and an iid filter.
</p>
<p>If <code>theta</code> is not equal to 1 the series is assumed to follow a
moving average process. The moving average weights are given by <code>theta</code>. The default is
<code>theta=1</code> (iid series). If <code>theta</code><code class="reqn">=(\theta_1, \theta_2, \dots)</code> then
the series is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">x_t = \mu + 1_{root} x_{t-1} + \theta_1 e_t + \theta_2 e_{t-1} + \dots</code>
</p>

<p>where <code class="reqn">1_{root}=1</code> if the option <code>root=1</code> and <code class="reqn">1_{root}=0</code>
if the option <code>root=0</code>, and <code class="reqn">e_t</code> is a white noise.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A &quot;<code>mFilter</code>&quot; object (see <code><a href="#topic+mFilter">mFilter</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+hpfilter">hpfilter</a></code>, <code><a href="#topic+trfilter">trfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.cf &lt;- cffilter(unemp)
plot(unemp.cf)
unemp.cf1 &lt;- cffilter(unemp, drift=TRUE, root=TRUE)
unemp.cf2 &lt;- cffilter(unemp, pl=8,pu=40,drift=TRUE, root=TRUE)
unemp.cf3 &lt;- cffilter(unemp, pl=2,pu=60,drift=TRUE, root=TRUE)
unemp.cf4 &lt;- cffilter(unemp, pl=2,pu=40,drift=TRUE, root=TRUE,theta=c(.1,.4))

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.cf1$x,
main="Christiano-Fitzgerald filter of unemployment: Trend \n root=TRUE,drift=TRUE",
col=1, ylab="")
lines(unemp.cf1$trend,col=2)
lines(unemp.cf2$trend,col=3)
lines(unemp.cf3$trend,col=4)
lines(unemp.cf4$trend,col=5)
legend("topleft",legend=c("series", "pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
"pl=2, pu=40, theta=.1,.4"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.cf1$cycle,
main="Christiano-Fitzgerald filter of unemployment: Cycle \n root=TRUE,drift=TRUE",
col=2, ylab="", ylim=range(unemp.cf3$cycle))
lines(unemp.cf2$cycle,col=3)
lines(unemp.cf3$cycle,col=4)
lines(unemp.cf4$cycle,col=5)
## legend("topleft",legend=c("pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
## "pl=2, pu=40, theta=.1,.4"), col=2:5, lty=rep(1,4), ncol=2)

par(opar)
</code></pre>

<hr>
<h2 id='hpfilter'>
Hodrick-Prescott filter of a time series
</h2><span id='topic+hpfilter'></span>

<h3>Description</h3>

<p>This function implements the Hodrick-Prescott for estimating cyclical
and trend component of a time series. The function computes cyclical
and trend components of the time series using a frequency cut-off or
smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpfilter(x,freq=NULL,type=c("lambda","frequency"),drift=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpfilter_+3A_x">x</code></td>
<td>
<p>a regular time series.</p>
</td></tr>
<tr><td><code id="hpfilter_+3A_type">type</code></td>
<td>
<p>character, indicating the filter type,
<code>"lambda"</code>, for the filter that uses smoothness penalty
parameter of the Hodrick-Prescott filter
(default),
<code>"frequency"</code>, for the filter that uses a frequency cut-off
type Hodrick-Prescott filter. These are related by
<code class="reqn">lambda = (2*sin(pi/frequency))^{-4}</code>.</p>
</td></tr>
<tr><td><code id="hpfilter_+3A_freq">freq</code></td>
<td>
<p>integer, if <code>type="lambda"</code> then <code>freq</code> is the
smoothing parameter (lambda) of the Hodrick-Prescott filter, if
<code>type="frequency"</code> then <code>freq</code> is the
cut-off frequency of the Hodrick-Prescott filter.</p>
</td></tr>
<tr><td><code id="hpfilter_+3A_drift">drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The Hodrick-Prescott filter obtains the filter weights <code class="reqn">\hat{B}_j</code>
as a solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \} = \arg \min
\left\{ \sum^{T}_{t=1}(y_t-\hat{y}_{t})^2 + \lambda\sum^{T-1}_{t=2}(\hat{y}_{t+1}-2\hat{y}_{t}+\hat{y}_{t-1})^2 \right\}</code>
</p>

<p>The Hodrick-Prescott filter is a finite data approximation with
following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=\frac{1}{2\pi}\int^{\pi}_{-\pi}
\frac{4\lambda(1-\cos(\omega))^2}{1+4\lambda(1-\cos(\omega))^2}e^{i \omega
j}  d \omega</code>
</p>

<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A &quot;<code>mFilter</code>&quot; object (see <code><a href="#topic+mFilter">mFilter</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+bkfilter">bkfilter</a></code>, <code><a href="#topic+trfilter">trfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.hp &lt;- hpfilter(unemp)
plot(unemp.hp)
unemp.hp1 &lt;- hpfilter(unemp, drift=TRUE)
unemp.hp2 &lt;- hpfilter(unemp, freq=800, drift=TRUE)
unemp.hp3 &lt;- hpfilter(unemp, freq=12,type="frequency",drift=TRUE)
unemp.hp4 &lt;- hpfilter(unemp, freq=52,type="frequency",drift=TRUE)

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.hp1$x,  ylim=c(2,13),
main="Hodrick-Prescott filter of unemployment: Trend, drift=TRUE",
     col=1, ylab="")
lines(unemp.hp1$trend,col=2)
lines(unemp.hp2$trend,col=3)
lines(unemp.hp3$trend,col=4)
lines(unemp.hp4$trend,col=5)
legend("topleft",legend=c("series", "lambda=1600", "lambda=800",
       "freq=12", "freq=52"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.hp1$cycle,
main="Hodrick-Prescott filter of unemployment: Cycle,drift=TRUE",
     col=2, ylab="", ylim=range(unemp.hp4$cycle,na.rm=TRUE))
lines(unemp.hp2$cycle,col=3)
lines(unemp.hp3$cycle,col=4)
lines(unemp.hp4$cycle,col=5)
## legend("topleft",legend=c("lambda=1600", "lambda=800",
## "freq=12", "freq=52"), col=1:5, lty=rep(1,5), ncol=1)

par(opar)
</code></pre>

<hr>
<h2 id='mFilter'>
Decomposition of a time series into trend and cyclical components
using various filters
</h2><span id='topic+mFilter'></span><span id='topic+mFilter.default'></span><span id='topic+mFilter.ts'></span>

<h3>Description</h3>

<p><code>mFilter</code> is a generic function for filtering
time series data.  The function invokes particular
<em>filters</em> which depend on filter type specified via its argument
<code>filter</code>. The filters implemented in the package <code>mFilter</code>
package are useful for smoothing, and estimating tend and cyclical components.
Some of these filters are commonly used in economics and
finance for estimating cyclical component of time series.
</p>
<p>The <code>mFilter</code> currently applies only to time series
objects. However a default method is available and should work for any
<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+vector">vector</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mFilter(x, ...)
  ## Default S3 method:
mFilter(x, ...)
  ## S3 method for class 'ts'
mFilter(x, filter=c("HP","BK","CF","BW","TR"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFilter_+3A_x">x</code></td>
<td>
<p>a regular a time series.</p>
</td></tr>
<tr><td><code id="mFilter_+3A_filter">filter</code></td>
<td>
<p>filter type, the filter types are <code>"HP"</code>
(Hodrick-Prescott), <code>"BK"</code> (Baxter-King), <code>"CF"</code>
(Christiano-Fitzgerald), <code>"BW"</code> (Butterworth), and <code>"TR"</code>
(trigonometric regression).</p>
</td></tr>
<tr><td><code id="mFilter_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the relevant filter
functions. These are passed to <code>hpfilter</code>,  <code>bkfilter</code>,
<code>cffilter</code>, <code>bwfilter</code>, and <code>trfilter</code>, respectively for
the <code>"HP"</code>, <code>"BK"</code>, <code>"CF"</code>, <code>"BW"</code>, and <code>"TR"</code> filters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour is to apply the default filter to
<code><a href="stats.html#topic+ts">ts</a></code> objects.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>mFilter</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the original
series, the trend, and the cyclical components. The function <code>print</code> is also available
for displaying estimation results.
</p>
<p>The generic accessor functions <code>fitted</code> and <code>residuals</code>
extract estimated trend and cyclical componets of an &quot;<code>mFilter</code>&quot;
object, respectively.
</p>
<p>An object of class &quot;<code>mFilter</code>&quot; is a list containing at least the following elements:
</p>
<table>
<tr><td><code>cycle</code></td>
<td>
<p>Estimated cyclical (irregular) component of the series.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Estimated trend (smooth) component of the series.</p>
</td></tr>
<tr><td><code>fmatrix</code></td>
<td>
<p>The filter matrix applied to original series.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method, if available, for the filter type applied.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The filter type applied to the series.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call to the function.</p>
</td></tr>
<tr><td><code>title</code></td>
<td>
<p>The title for displaying results.</p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p>Name of the series passed to <code>mFilter</code> for filtering.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original or drift adjusted, if <code>drift=TRUE</code>, time series passed to the <code>mFilter</code>.</p>
</td></tr>
</table>
<p>Following additional elements may exists depending on the type of filter
applied:
</p>
<table>
<tr><td><code>nfix</code></td>
<td>
<p>Length or order of the fixed length filters.</p>
</td></tr>
<tr><td><code>pl</code></td>
<td>
<p>Minimum period of oscillation of desired component (2&lt;=pl).</p>
</td></tr>
<tr><td><code>pu</code></td>
<td>
<p>Maximum period of oscillation of desired component (2&lt;=pl&lt;pu&lt;infinity).</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda (smoothness) parameter of the HP filter.</p>
</td></tr>
<tr><td><code>root</code></td>
<td>
<p>Whether time series has a unit root, TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code>drift</code></td>
<td>
<p>Whether time series has drift, TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>MA coefficients for time series model, used in <code>"CF"</code> filter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>See Also</h3>

<p>Other functions which return objects of class <code>"mFilter"</code> are
<code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+bwfilter">bwfilter</a></code>,
<code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+trfilter">trfilter</a></code>.
Following functions apply the relevant methods to an object of the
<code>"mFilter"</code> class:
<code><a href="#topic+print.mFilter">print.mFilter</a></code>,
<code><a href="#topic+summary.mFilter">summary.mFilter</a></code>,
<code><a href="#topic+plot.mFilter">plot.mFilter</a></code>,
<code><a href="#topic+fitted.mFilter">fitted.mFilter</a></code>,
<code><a href="#topic+residuals.mFilter">residuals.mFilter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.hp &lt;- mFilter(unemp,filter="HP")  # Hodrick-Prescott filter
print(unemp.hp)
summary(unemp.hp)
residuals(unemp.hp)
fitted(unemp.hp)
plot(unemp.hp)

unemp.bk &lt;- mFilter(unemp,filter="BK")  # Baxter-King filter
unemp.cf &lt;- mFilter(unemp,filter="CF")  # Christiano-Fitzgerald filter
unemp.bw &lt;- mFilter(unemp,filter="BW")  # Butterworth filter
unemp.tr &lt;- mFilter(unemp,filter="TR")  # Trigonometric regression filter

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp,main="Unemployment Series &amp; Estimated Trend", col=1, ylab="")
lines(unemp.hp$trend,col=2)
lines(unemp.bk$trend,col=3)
lines(unemp.cf$trend,col=4)
lines(unemp.bw$trend,col=5)
lines(unemp.tr$trend,col=6)

legend("topleft",legend=c("series", "HP","BK","CF","BW","TR"),
    col=1:6,lty=rep(1,6),ncol=2)

plot(unemp.hp$cycle,main="Estimated Cyclical Component",
     ylim=c(-2,2.5),col=2,ylab="")
lines(unemp.bk$cycle,col=3)
lines(unemp.cf$cycle,col=4)
lines(unemp.bw$cycle,col=5)
lines(unemp.tr$cycle,col=6)
## legend("topleft",legend=c("HP","BK","CF","BW","TR"),
## col=2:6,lty=rep(1,5),ncol=2)

unemp.cf1 &lt;- mFilter(unemp,filter="CF", drift=TRUE, root=TRUE)
unemp.cf2 &lt;- mFilter(unemp,filter="CF", pl=8,pu=40,drift=TRUE, root=TRUE)
unemp.cf3 &lt;- mFilter(unemp,filter="CF", pl=2,pu=60,drift=TRUE, root=TRUE)
unemp.cf4 &lt;- mFilter(unemp,filter="CF", pl=2,pu=40,drift=TRUE,
             root=TRUE,theta=c(.1,.4))

plot(unemp,
main="Christiano-Fitzgerald filter of unemployment: Trend \n root=TRUE,drift=TRUE",
      col=1, ylab="")
lines(unemp.cf1$trend,col=2)
lines(unemp.cf2$trend,col=3)
lines(unemp.cf3$trend,col=4)
lines(unemp.cf4$trend,col=5)
legend("topleft",legend=c("series", "pl=2, pu=32", "pl=8, pu=40",
"pl=2, pu=60", "pl=2, pu=40, theta=.1,.4"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.cf1$cycle,
main="Christiano-Fitzgerald filter of unemployment: Cycle \n root=TRUE,drift=TRUE",
     col=2, ylab="", ylim=range(unemp.cf3$cycle))
lines(unemp.cf2$cycle,col=3)
lines(unemp.cf3$cycle,col=4)
lines(unemp.cf4$cycle,col=5)
## legend("topleft",legend=c("pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
## "pl=2, pu=40, theta=.1,.4"), col=2:5, lty=rep(1,4), ncol=2)

par(opar)
</code></pre>

<hr>
<h2 id='mFilter-methods'>Methods for mFilter objects</h2><span id='topic+mFilter-methods'></span><span id='topic+residuals.mFilter'></span><span id='topic+fitted.mFilter'></span><span id='topic+print.mFilter'></span><span id='topic+plot.mFilter'></span><span id='topic+summary.mFilter'></span>

<h3>Description</h3>

<p>Common methods for all <code>mFilter</code> objects usually created by the
<code>mFilter</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mFilter'
residuals(object, ...)
## S3 method for class 'mFilter'
fitted(object, ...)
## S3 method for class 'mFilter'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'mFilter'
plot(x, reference.grid = TRUE, col = "steelblue", ask=interactive(), ...)
## S3 method for class 'mFilter'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFilter-methods_+3A_object">object</code>, <code id="mFilter-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mFilter"</code>; usually, a result
of a call to <code><a href="#topic+mFilter">mFilter</a></code>.</p>
</td></tr>
<tr><td><code id="mFilter-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits used for printing (see <code><a href="base.html#topic+print">print</a></code>).</p>
</td></tr>
<tr><td><code id="mFilter-methods_+3A_col">col</code></td>
<td>
<p>color of the graph (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="mFilter-methods_+3A_ask">ask</code></td>
<td>
<p>logical. if <code>TRUE</code> the user is asked for input before a new
graph drawn in an interactive session (see <code><a href="base.html#topic+interactive">interactive</a></code>).</p>
</td></tr>
<tr><td><code id="mFilter-methods_+3A_reference.grid">reference.grid</code></td>
<td>
<p>logical. if true grid lines are drawn.</p>
</td></tr>
<tr><td><code id="mFilter-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>residuals</code> and <code>fitted</code> a univariate time series;
for <code>plot</code>, <code>print</code>, and <code>summary</code> the   &quot;<code>mFilter</code>&quot;
object.
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code> for the function that returns an objects of class <code>"mFilter"</code>.
Other functions which return objects of class <code>"mFilter"</code> are
<code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+bwfilter">bwfilter</a></code>,
<code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+trfilter">trfilter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.hp &lt;- mFilter(unemp,filter="HP")  # Hodrick-Prescott filter
print(unemp.hp)
summary(unemp.hp)
residuals(unemp.hp)
fitted(unemp.hp)
plot(unemp.hp)

par(opar)
</code></pre>

<hr>
<h2 id='mFilter-package'>
Getting started with the mFilter package
</h2><span id='topic+mFilter-package'></span>

<h3>Description</h3>

<p>Getting started with the mFilter package
</p>


<h3>Details</h3>

<p>This package provides some tools for decomposing time series into
trend (smooth) and cyclical (irregular) components. The package implements come commonly used
filters such as the Hodrick-Prescott, Baxter-King and Christiano-Fitzgerald
filter.
</p>
<p>For loading the package, type:
</p>
<p><code>library(mFilter)</code>
</p>
<p>A good place to start learning the package usage is to examine examples for
the <code>mFilter</code> function. At the R prompt, write:
</p>
<p><code>example("mFilter")</code>
</p>
<p>For a full list of functions exported by the package, type:
</p>
<p><code>ls("package:mFilter")</code>
</p>
<p>Each exported function has a corresponding man page (some man pages are
common to more functions). Display it by typing
</p>
<p><code>help(functionName)</code>.
</p>
<p>Almost all filters in this package can be put into the following
framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are interested
in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with period of
oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The finite sample approximation to the ideal bandpass filter uses the
alternative filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n_2}_{j=-n_1}\hat{B}_{t,j} x_{t+j}</code>
</p>

<p>Here the weights, <code class="reqn">\hat{B}_{t,j}</code>, of the approximation is a
solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{t,j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \}</code>
</p>

<p>The Christiano-Fitzgerald filter is a finite data approximation to the
ideal bandpass filter and minimizes the mean squared error defined in the
above equation.
</p>
<p>Several band-pass approximation strategies can be selected in the
function <code>cffilter</code>. The default setting of <code>cffilter</code> returns
the filtered data <code class="reqn">\hat{y_t}</code> associated with the unrestricted optimal filter
assuming no unit root, no drift and an iid filter.
</p>
<p>If <code>theta</code> is not equal to 1 the series is assumed to follow a
moving average process. The moving average weights are given by <code>theta</code>. The default is
<code>theta=1</code> (iid series). If <code>theta</code><code class="reqn">=(\theta_1, \theta_2, \dots)</code> then
the series is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">x_t = \mu + 1_{root} x_{t-1} + \theta_1 e_t + \theta_2 e_{t-1} + \dots</code>
</p>

<p>where <code class="reqn">1_{root}=1</code> if the option <code>root=1</code> and <code class="reqn">1_{root}=0</code>
if the option <code>root=0</code>, and <code class="reqn">e_t</code> is a white noise.
</p>
<p>The Baxter-King filter is a finite data approximation to the
ideal bandpass filter with following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n}_{j=-n}\hat{B}_{j} x_{t+j}=\hat{B}_0
  x_t + \sum^{n}_{j=1} \hat{B}_j (x_{t-j}+x_{t+j})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=B_j-\frac{1}{2n+1}\sum^{n}_{j=-n} B_{j}</code>
</p>

<p>The Hodrick-Prescott filter obtains the filter weights <code class="reqn">\hat{B}_j</code>
as a solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \} = \arg \min
\left\{ \sum^{T}_{t=1}(y_t-\hat{y}_{t})^2 + \lambda\sum^{T-1}_{t=2}(\hat{y}_{t+1}-2\hat{y}_{t}+\hat{y}_{t-1})^2 \right\}</code>
</p>

<p>The Hodrick-Prescott filter is a finite data approximation with
following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=\frac{1}{2\pi}\int^{\pi}_{-\pi}
\frac{4\lambda(1-\cos(\omega))^2}{1+4\lambda(1-\cos(\omega))^2}e^{i \omega
j}  d \omega</code>
</p>

<p>The digital version of the Butterworth highpass filter is described by the
rational polynomial expression (the filter's z-transform)
</p>
<p style="text-align: center;"><code class="reqn">\frac{\lambda(1-z)^n(1-z^{-1})^n}{(1+z)^n(1+z^{-1})^n+\lambda(1-z)^n(1-z^{-1})^n}</code>
</p>

<p>The time domain version can be obtained by substituting <code class="reqn">z</code> for the
lag operator <code class="reqn">L</code>.
</p>
<p>Pollock (2000) derives a specialized finite-sample version of the Butterworth
filter on the basis of signal extraction theory. Let <code class="reqn">s_t</code> be the
trend and <code class="reqn">c_t</code> cyclical component of <code class="reqn">y_t</code>, then these
components are extracted as
</p>
<p style="text-align: center;"><code class="reqn">y_t=s_t+c_t=\frac{(1+L)^n}{(1-L)^d}\nu_t+(1-L)^{n-d}\varepsilon_t</code>
</p>

<p>where <code class="reqn">\nu_t \sim N(0,\sigma_\nu^2)</code> and <code class="reqn">\varepsilon_t \sim
  N(0,\sigma_\varepsilon^2)</code>.
</p>
<p>Let <code class="reqn">T</code> be even and define <code class="reqn">n_1=T/p_u</code> and <code class="reqn">n_2=T/p_l</code>. The
trigonometric regression filter is based on the following relation
</p>
<p style="text-align: center;"><code class="reqn">{y}_t=\sum^{n_1}_{j=n_2}\left\{ a_j \cos(\omega_j t) + b_j
    \sin(\omega_j t) \right\}</code>
</p>

<p>where <code class="reqn">a_j</code> and <code class="reqn">b_j</code> are the coefficients obtained by
regressing <code class="reqn">x_t</code> on the indicated sine and cosine
functions. Specifically,
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\omega_j t) x_t,\ \ \ </code>   for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\pi t) x_t,\ \ \ </code>    for <code class="reqn">j=T/2</code>
</p>
<p>and
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\omega_j t) x_t,\ \ \ </code>    for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\pi t) x_t,\ \ \ </code>   for <code class="reqn">j=T/2</code>
</p>
<p>Let <code class="reqn">\hat{B}(L) x_t</code> be the trigonometric regression filter. It can
be showed that <code class="reqn">\hat{B}(1)=0</code>, so that <code class="reqn">\hat{B}(L)</code> has a unit
root for <code class="reqn">t=1,2,\dots,T</code>. Also, when <code class="reqn">\hat{B}(L)</code> is symmetric,
it has a second unit root in the middle of the data for
<code class="reqn">t</code>. Therefore it is important to drift adjust data before it is
filtered with a trigonometric regression filter.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter-methods">mFilter-methods</a></code> for listing all currently
available <code>mFilter</code> methods. For help on common interface function
&quot;<code>mFilter</code>&quot;, <code><a href="#topic+mFilter">mFilter</a></code>. For individual filter function
usage, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+bkfilter">bkfilter</a></code>,
<code><a href="#topic+cffilter">cffilter</a></code>, <code><a href="#topic+hpfilter">hpfilter</a></code>, <code><a href="#topic+trfilter">trfilter</a></code>.
</p>

<hr>
<h2 id='trfilter'>
Trigonometric regression filter of a time series
</h2><span id='topic+trfilter'></span>

<h3>Description</h3>

<p>This function uses trigonometric regression filter for estimating cyclical
and trend components of a time series. The function computes cyclical
and trend components of the time series using a lower and upper cut-off
frequency in the spirit of a band pass filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trfilter(x,pl=NULL,pu=NULL,drift=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trfilter_+3A_x">x</code></td>
<td>
<p>a regular time series.</p>
</td></tr>
<tr><td><code id="trfilter_+3A_pl">pl</code></td>
<td>
<p>integer. minimum period of oscillation of desired component
(pl&lt;=2).</p>
</td></tr>
<tr><td><code id="trfilter_+3A_pu">pu</code></td>
<td>
<p>integer. maximum period of oscillation of desired component
(2&lt;=pl&lt;pu&lt;infinity).</p>
</td></tr>
<tr><td><code id="trfilter_+3A_drift">drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>Let <code class="reqn">T</code> be even and define <code class="reqn">n_1=T/p_u</code> and <code class="reqn">n_2=T/p_l</code>. The
trigonometric regression filter is based on the following relation
</p>
<p style="text-align: center;"><code class="reqn">{y}_t=\sum^{n_1}_{j=n_2}\left\{ a_j \cos(\omega_j t) + b_j
    \sin(\omega_j t) \right\}</code>
</p>

<p>where <code class="reqn">a_j</code> and <code class="reqn">b_j</code> are the coefficients obtained by
regressing <code class="reqn">x_t</code> on the indicated sine and cosine
functions. Specifically,
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\omega_j t) x_t,\ \ \ </code>    for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\pi t) x_t,\ \ \ </code>    for <code class="reqn">j=T/2</code>
</p>
<p>and
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\omega_j t) x_t,\ \ \ </code>    for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\pi t) x_t,\ \ \ </code>    for <code class="reqn">j=T/2</code>
</p>
<p>Let <code class="reqn">\hat{B}(L) x_t</code> be the trigonometric regression filter. It can
be showed that <code class="reqn">\hat{B}(1)=0</code>, so that <code class="reqn">\hat{B}(L)</code> has a unit
root for <code class="reqn">t=1,2,\dots,T</code>. Also, when <code class="reqn">\hat{B}(L)</code> is symmetric,
it has a second unit root in the middle of the data for
<code class="reqn">t</code>. Therefore it is important to drift adjust data before it is
filtered with a trigonometric regression filter.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A &quot;<code>mFilter</code>&quot; object (see <code><a href="#topic+mFilter">mFilter</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mFilter">mFilter</a></code>, <code><a href="#topic+hpfilter">hpfilter</a></code>, <code><a href="#topic+cffilter">cffilter</a></code>,
<code><a href="#topic+bkfilter">bkfilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.tr &lt;- trfilter(unemp, drift=TRUE)
plot(unemp.tr)
unemp.tr1 &lt;- trfilter(unemp, drift=TRUE)
unemp.tr2 &lt;- trfilter(unemp, pl=8,pu=40,drift=TRUE)
unemp.tr3 &lt;- trfilter(unemp, pl=2,pu=60,drift=TRUE)
unemp.tr4 &lt;- trfilter(unemp, pl=2,pu=40,drift=TRUE)

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.tr1$x,
main="Trigonometric regression filter of unemployment: Trend, drift=TRUE",
     col=1, ylab="")
lines(unemp.tr1$trend,col=2)
lines(unemp.tr2$trend,col=3)
lines(unemp.tr3$trend,col=4)
lines(unemp.tr4$trend,col=5)
legend("topleft",legend=c("series", "pl=2, pu=32", "pl=8, pu=40",
"pl=2, pu=60", "pl=2, pu=40"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.tr1$cycle,
main="Trigonometric regression filter of unemployment: Cycle,drift=TRUE",
     col=2, ylab="", ylim=range(unemp.tr3$cycle,na.rm=TRUE))
lines(unemp.tr2$cycle,col=3)
lines(unemp.tr3$cycle,col=4)
lines(unemp.tr4$cycle,col=5)
## legend("topleft",legend=c("pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
## "pl=2, pu=40"), col=1:5, lty=rep(1,5), ncol=1)

par(opar)
</code></pre>

<hr>
<h2 id='unemp'>US Quarterly Unemployment Series</h2><span id='topic+unemp'></span>

<h3>Description</h3>

<p>Quarterly US unemployment series for 1959.1 to 2000.4.
</p>
<p><em>number of observations</em> :  168
</p>
<p><em>observation</em> :  country
</p>
<p><em>country</em> :  United States
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(unemp)
</code></pre>


<h3>Format</h3>

<p>A time series containing :
</p>

<dl>
<dt>unemp</dt><dd><p>unemployment rate (average of months in quarter)       </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>Source</h3>

<p>Bureau of Labor Statistics, OECD, Federal Reserve.
</p>


<h3>References</h3>

<p>Stock, James H.  and  Mark W.  Watson (2003) <em>Introduction to
Econometrics</em>, Addison-Wesley Educational Publishers, chapter 12 and 14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library(mFilter)

data(unemp)

unemp.hp &lt;- mFilter(unemp,filter="HP")  # Hodrick-Prescott filter
unemp.bk &lt;- mFilter(unemp,filter="BK")  # Baxter-King filter
unemp.cf &lt;- mFilter(unemp,filter="CF")  # Christiano-Fitzgerald filter

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,1),mar=c(3,3,2,1))
plot(unemp,main="Unemployment Series &amp; Estimated Trend",col=1,ylab="")
lines(unemp.hp$trend,col=2)
lines(unemp.bk$trend,col=3)
lines(unemp.cf$trend,col=4)
legend("topleft",legend=c("series", "HP","BK","CF"),col=1:4,
       lty=rep(1,4),ncol=2)

plot(unemp.hp$cycle,main="Estimated Cyclical Component",col=2,
     ylim=c(-2,2),ylab="")
lines(unemp.bk$cycle,col=3)
lines(unemp.cf$cycle,col=4)
legend("topleft",legend=c("HP","BK","CF"),col=2:4,lty=rep(1,3),ncol=2)
par(opar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
