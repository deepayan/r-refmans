<!DOCTYPE html><html lang="en"><head><title>Help for package dfvad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dfvad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dynamics'><p>Productivity Dynamics</p></a></li>
<li><a href='#firms'><p>Sample data for firm dynamics</p></a></li>
<li><a href='#mining'><p>Sample Data for Value Added Decomposition</p></a></li>
<li><a href='#pb_index'><p>Bilateral Price Indexes</p></a></li>
<li><a href='#pm_index'><p>Multilateral Price Indexes</p></a></li>
<li><a href='#prices'><p>Sample Data for Price Indexes</p></a></li>
<li><a href='#roll_div'><p>Converting Level Values to Growth Values</p></a></li>
<li><a href='#roll_prod'><p>Converting Growth Values to Level Values</p></a></li>
<li><a href='#sector'><p>Sample Data for Weighted Average Aggregation</p></a></li>
<li><a href='#t_weight'><p>Aggregation over Sectors with a Weighted Average Approach</p></a></li>
<li><a href='#value_decom'><p>Decomposing Value Added Growth into Explanatory Factors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Diewert and Fox's Method of Value Added Growth Decomposition</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Shipei Zeng</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shipei Zeng &lt;shipei.zeng@unswalumni.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Decomposing value added growth into explanatory factors.
    A cost constrained value added function is defined to specify the 
    production frontier. Industry estimates can also be aggregated using 
    a weighted average approach.
    Details about the methodology and data can be found in Diewert and Fox (2018)
    &lt;<a href="https://doi.org/10.1093%2Foxfordhb%2F9780190226718.013.19">doi:10.1093/oxfordhb/9780190226718.013.19</a>&gt;
    and Zeng, Parsons, Diewert and Fox (2018)
    <a href="https://www.business.unsw.edu.au/research-site/centreforappliedeconomicresearch-site/Documents/emg2018-6_SZeng_EMG-Slides.pdf">https://www.business.unsw.edu.au/research-site/centreforappliedeconomicresearch-site/Documents/emg2018-6_SZeng_EMG-Slides.pdf</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shipei-zeng/dfvad">https://github.com/shipei-zeng/dfvad</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shipei-zeng/dfvad/issues">https://github.com/shipei-zeng/dfvad/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-15 03:22:09 UTC; Franklin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-15 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dynamics'>Productivity Dynamics</h2><span id='topic+dynamics'></span>

<h3>Description</h3>

<p>Productivity dynamics reflect firm contributions to
productivity growth over periods when firms enter or
exit an industry. <code>dynamics</code> summarises a series
of decomposition methods that are centred on the contributions
from incumbents, entrants and exits. It applies to other
weighted aggregation measures analogous to aggregate productivity
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamics(df, x, s, id, tm, typ = "df")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynamics_+3A_df">df</code></td>
<td>
<p>A data frame sorted by the time period column.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_x">x</code></td>
<td>
<p>A string indicating the productivity (or analogous measures) column.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_s">s</code></td>
<td>
<p>A string indicating the market share column.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_id">id</code></td>
<td>
<p>A string indicating the identity column.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_tm">tm</code></td>
<td>
<p>A string indicating the time period column.</p>
</td></tr>
<tr><td><code id="dynamics_+3A_typ">typ</code></td>
<td>
<p>Relevant types of productivity dynamics. Options include &quot;df&quot; for
Diewert-Fox decomposition (by default), &quot;bhc&quot; for Baily-Hulten-Campbell, &quot;gr&quot; for
Griliches-Regev, &quot;fhk&quot; for Foster-Haltiwanger-Krizan, &quot;bg&quot; for Baldwin-Gu, and
&quot;mp&quot; for Melitz-Polanec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of the time period and firm contributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in data set "firms"
# DF decomposition of firm dynamics
dym_df &lt;- dynamics(firms, "tfp", "s", "id", "t")
# BG decomposition of firm dynamics
dym_bg &lt;- dynamics(firms, "tfp", "s", "id", "t", "bg")

</code></pre>

<hr>
<h2 id='firms'>Sample data for firm dynamics</h2><span id='topic+firms'></span>

<h3>Description</h3>

<p>Firm productivity and market shares adopted to
demonstrate the decomposition of firm dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firms
</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>tfp</dt><dd><p>Firm productivity (or firm performance indicators)</p>
</dd>
<dt>s</dt><dd><p>Market shares occupied the firm.</p>
</dd>
<dt>id</dt><dd><p>A firm identity column.</p>
</dd>
<dt>t</dt><dd><p>A time period column</p>
</dd>
</dl>


<h3>References</h3>

<p>Zeng, S. (2019). Frontier firms, inefficiency and productivity
dynamics. Presented in EMG Workshop 2019, Sydney.
</p>

<hr>
<h2 id='mining'>Sample Data for Value Added Decomposition</h2><span id='topic+mining'></span>

<h3>Description</h3>

<p>Mining inputs and outputs adopted to
demonstrate the decomposition of value added growth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mining
</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>year</dt><dd><p>A time period column.</p>
</dd>
<dt>p2</dt><dd><p>Output prices.</p>
</dd>
<dt>w2</dt><dd><p>Wages of labour inputs.</p>
</dd>
<dt>u2</dt><dd><p>Prices of capital services.</p>
</dd>
<dt>y2</dt><dd><p>Output quantities.</p>
</dd>
<dt>h2</dt><dd><p>Labour input quantities.</p>
</dd>
<dt>x2</dt><dd><p>Capital services quantities.</p>
</dd>
</dl>


<h3>References</h3>

<p>Zeng, S., Parsons, S., Diewert, W. E. and Fox, K. J. (2018).
Industry and state level value added and productivity
decompositions. Presented in EMG Worshop 2018, Sydney.
</p>

<hr>
<h2 id='pb_index'>Bilateral Price Indexes</h2><span id='topic+pb_index'></span>

<h3>Description</h3>

<p>Bilateral indexes refer to the case when only two periods are
compared each time. <code>pb_index()</code> computes price indexes in a
bilateral approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pb_index(df, p, qty, id, tm, typ = "f", seq = "ch", bsk = "flx")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pb_index_+3A_df">df</code></td>
<td>
<p>A data frame sorted by the time period column.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_p">p</code></td>
<td>
<p>A string indicating the price column.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_qty">qty</code></td>
<td>
<p>A string indicating the quantity column.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_id">id</code></td>
<td>
<p>A string indicating the identity column.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_tm">tm</code></td>
<td>
<p>A string indicating the time period column. Each period must
contain two observations at least.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_typ">typ</code></td>
<td>
<p>Relevant types of price indexes. Options include &quot;f&quot;
for Fisher price indexes (by default), &quot;t&quot; for Tornqvist price indexes,
&quot;l&quot; for Laspeyres price indexes, and &quot;p&quot; for Paasche price indexes.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_seq">seq</code></td>
<td>
<p>Index construction sequences when the number of periods
is larger than 2. Options include &quot;ch&quot; for chained indexes (by default),
and &quot;fb&quot; for fixed base indexes.</p>
</td></tr>
<tr><td><code id="pb_index_+3A_bsk">bsk</code></td>
<td>
<p>The choice of baskets when items are not matched over
multiple periods. Options include &quot;flx&quot; (by default) for a flexible basket
that varies depending on the maximal number of matched items in
two periods each time, and &quot;cst&quot; for a constant basket
that takes the maximal number of matched items across all periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of the time period and price indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in data set "prices"
# Laspeyres fixed base indexes with a constant basket
df &lt;- prices[[1]]
df &lt;- df[order(df[,"t"]),]
index1 &lt;- pb_index(df, "p", "q", "id", "t", typ = "l", seq = "fb", bsk = "cst")
# Fisher chained indexes with a flexible basket
df &lt;- prices[[2]]
df &lt;- df[order(df[,"t"]),]
index2 &lt;- pb_index(df, "p", "q", "id", "t")
</code></pre>

<hr>
<h2 id='pm_index'>Multilateral Price Indexes</h2><span id='topic+pm_index'></span>

<h3>Description</h3>

<p>Multilateral indexes refer to the case when more than two periods
are compared each time. <code>pm_index()</code> computes price indexes in a
multilateral approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm_index(df, p, qty, id, tm, typ = "geks", len = NULL,
lnk = NULL, bsk = "flx", wd = "flx")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm_index_+3A_df">df</code></td>
<td>
<p>A data frame sorted by the time period column.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_p">p</code></td>
<td>
<p>A string indicating the price column.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_qty">qty</code></td>
<td>
<p>A string indicating the quantity column.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_id">id</code></td>
<td>
<p>A string indicating the identity column.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_tm">tm</code></td>
<td>
<p>A string indicating the time period column. Each period must
contain two observations at least.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_typ">typ</code></td>
<td>
<p>Relevant types of price indexes. Options include &quot;geks&quot;
for GEKS price indexes (by default), &quot;ccdi&quot; for CCDI price indexes,
&quot;wtpd&quot; for the weighted time product dummy method, and &quot;gk&quot; for the
Geary-Khamis method.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_len">len</code></td>
<td>
<p>Window length for linked indexes using rolling windows. A
single window is set as NULL (by default).</p>
</td></tr>
<tr><td><code id="pm_index_+3A_lnk">lnk</code></td>
<td>
<p>Linking position in rolling windows, effective when 'len'
is not NULL. If no linking position is provided, it should be set as NULL
(by default). Other options include &quot;mean&quot; for mean splices and numbers
for specific cases.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_bsk">bsk</code></td>
<td>
<p>The choice of baskets when items are not matched over
multiple periods. Options include &quot;flx&quot; (by default) for a flexible basket
that varies depending on the maximal number of matched items in
two periods each time, and &quot;cst&quot; for a constant basket
that takes the maximal number of matched items across all periods.</p>
</td></tr>
<tr><td><code id="pm_index_+3A_wd">wd</code></td>
<td>
<p>The choice of windows when items are not matched over multiple
windows. Options include &quot;flx&quot; (by default) for a flexible window that allows for
different items in two windows each time, and &quot;cst&quot; for a constant window
that takes the maximal number of matched items across all windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of the time period and price indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in data set "prices"
# matched items
df &lt;- prices[[1]]
df &lt;- df[order(df[,"t"]),]
# GEKS price indexes with a constant basket over periods
index1 &lt;- pm_index(df, "p", "q", "id", "t", typ = "geks", bsk = "cst")
# unmatched items
df_add &lt;- matrix(c(1, 6, 12, 5, 6, 7, 0.5, 0.5, 0.5, 9, 9, 9), nrow=3)
df_add &lt;- as.data.frame(df_add)
colnames(df_add) &lt;- colnames(df)
df &lt;- rbind(df, df_add)
df &lt;- df[order(df[,"t"]),]
# CCDI price indexes with a flexible basket over periods
index2 &lt;- pm_index(df, "p", "q", "id", "t", typ = "ccdi", bsk = "flx")
# CCDI price indexes with rolling windows (window length at 11, linking at the first observation)
index3 &lt;- pm_index(df, "p", "q", "id", "t", typ = "ccdi", len = 11, lnk = 1)
# CCDI price indexes with rolling windows (window length at 11, linking with mean splices)
index4 &lt;- pm_index(df, "p", "q", "id", "t", typ = "ccdi", len = 11, lnk = "mean")
</code></pre>

<hr>
<h2 id='prices'>Sample Data for Price Indexes</h2><span id='topic+prices'></span>

<h3>Description</h3>

<p>Prices, quantities, identities and time periods
adopted to demonstrate the computation of price indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prices
</code></pre>


<h3>Format</h3>

<p>A list of data frames with the following columns:
</p>

<dl>
<dt>t</dt><dd><p>A time period column.</p>
</dd>
<dt>id</dt><dd><p>An identity column.</p>
</dd>
<dt>p</dt><dd><p>A price column.</p>
</dd>
<dt>q</dt><dd><p>A quantity column.</p>
</dd>
</dl>

<p>These data frames are produced with different elasticities
that can be specified by the sub-list names.</p>


<h3>References</h3>

<p>Diewert, W.E., and Fox, K. J. 2018. Substitution bias in
multilateral methods for CPI construction using scanner
data. Discussion Papers 2018-13, School of Economics,
the University of New South Wales.
</p>

<hr>
<h2 id='roll_div'>Converting Level Values to Growth Values</h2><span id='topic+roll_div'></span>

<h3>Description</h3>

<p><code>roll_div()</code> converts level values to growth values for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_div(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_div_+3A_x">x</code></td>
<td>
<p>A vector with level values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of growth values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table2 &lt;- value_decom(c("h2","x2"), c("w2","u2"), "y2", "p2", "year", mining)[[2]]
roll_div(table2[, "TFP"])
</code></pre>

<hr>
<h2 id='roll_prod'>Converting Growth Values to Level Values</h2><span id='topic+roll_prod'></span>

<h3>Description</h3>

<p><code>roll_prod()</code> converts growth values to level values for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_prod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_prod_+3A_x">x</code></td>
<td>
<p>A vector with growth values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of level values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table1 &lt;- value_decom(c("h2","x2"), c("w2","u2"), "y2", "p2", "year", mining)[[1]]
roll_prod(table1[, "TFPG"])
</code></pre>

<hr>
<h2 id='sector'>Sample Data for Weighted Average Aggregation</h2><span id='topic+sector'></span>

<h3>Description</h3>

<p>Explanatory factors of value added decomposition
adopted to demonstrate the aggregation over industries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sector
</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>year</dt><dd><p>A time period column.</p>
</dd>
<dt>p</dt><dd><p>Output prices.</p>
</dd>
<dt>y</dt><dd><p>Output quantities.</p>
</dd>
<dt>alpha</dt><dd><p>Net output price indexes.</p>
</dd>
<dt>beta</dt><dd><p>Input quantity indexes</p>
</dd>
<dt>gamma</dt><dd><p>Input mix indexes.</p>
</dd>
<dt>epsilon</dt><dd><p>Value added efficiency indexes.</p>
</dd>
<dt>tau</dt><dd><p>Technical progress indexes.</p>
</dd>
<dt>industry</dt><dd><p>Industry codes.</p>
</dd>
</dl>


<h3>References</h3>

<p>Zeng, S., Parsons, S., Diewert, W. E. and Fox, K. J. (2018).
Industry and state level value added and productivity
decompositions. Presented in EMG Worshop 2018, Sydney.
</p>

<hr>
<h2 id='t_weight'>Aggregation over Sectors with a Weighted Average Approach</h2><span id='topic+t_weight'></span>

<h3>Description</h3>

<p>This &quot;bottom up&quot; approach uses weighted averages of the
sectoral decompositions to provide an approximate
decomposition into explanatory components at the aggregate
level. Specifically, the Tornqvist index is adopted in the
aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_weight(y, p, id, t, alpha, beta, gamma, epsilon, tau, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t_weight_+3A_y">y</code></td>
<td>
<p>A string (or a vector of strings) indicating the output quantity columns.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_p">p</code></td>
<td>
<p>A string (or a vector of strings) indicating the output price columns.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_id">id</code></td>
<td>
<p>A string indicating the industry column.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_t">t</code></td>
<td>
<p>A string indicating the time period column.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_alpha">alpha</code></td>
<td>
<p>A string indicating net output price indexes.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_beta">beta</code></td>
<td>
<p>A string indicating input quantity indexes.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_gamma">gamma</code></td>
<td>
<p>A string indicating input mixe indexes.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_epsilon">epsilon</code></td>
<td>
<p>A string indicating value added efficiency indexes.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_tau">tau</code></td>
<td>
<p>A string indicating technical progress indexes.</p>
</td></tr>
<tr><td><code id="t_weight_+3A_data">data</code></td>
<td>
<p>A data frame containing input prices, input quantities,
industry identities, the time period, and explanatory factors of
value added growth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a growth-value table and a level-value table of
explanatory factors for value added growth decomposition. It is
sorted by the time period.
</p>


<h3>References</h3>

<p>Diewert, W. E. and Fox, K. J. (2018). Decomposing value added growth into explanatory
factors. In The Oxford Handbook of Productivity Analysis, chapter 19,
page 625&ndash;662. Oxford University Press: New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in dataset "sector"
table1 &lt;- t_weight("y", "p", "industry", "year", "alpha",
        "beta", "gamma", "epsilon", "tau", sector)[[1]]
table2 &lt;- t_weight("y", "p", "industry", "year", "alpha",
        "beta", "gamma", "epsilon", "tau", sector)[[2]]
</code></pre>

<hr>
<h2 id='value_decom'>Decomposing Value Added Growth into Explanatory Factors</h2><span id='topic+value_decom'></span>

<h3>Description</h3>

<p>This method for decomposing nominal value added growth is
proposed by Diewert and Fox (2018), which identifies the
contributions from efficiency change, growth of primary
inputs, changes in output and input prices, technical
progress and returns to scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_decom(x, w, y, p, t, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_decom_+3A_x">x</code></td>
<td>
<p>A string (or a vector of strings) indicating the quantity columns.</p>
</td></tr>
<tr><td><code id="value_decom_+3A_w">w</code></td>
<td>
<p>A string (or a vector of strings) indicating the input price columns.</p>
</td></tr>
<tr><td><code id="value_decom_+3A_y">y</code></td>
<td>
<p>A string (or a vector of strings) indicating the the output quantity columns.</p>
</td></tr>
<tr><td><code id="value_decom_+3A_p">p</code></td>
<td>
<p>A string (or a vector of strings) indicating the the output price columns.</p>
</td></tr>
<tr><td><code id="value_decom_+3A_t">t</code></td>
<td>
<p>A string indicating the time period column.</p>
</td></tr>
<tr><td><code id="value_decom_+3A_data">data</code></td>
<td>
<p>A data frame containing input prices, input quantities, output prices,
output quantities, and the time period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a growth-value table and a level-value table of explanatory factors
for value added growth decomposition. It is sorted by the time period.
</p>


<h3>References</h3>

<p>Diewert, W. E. and Fox, K. J. (2018). Decomposing value added growth into explanatory
factors. In The Oxford Handbook of Productivity Analysis, chapter 19,
page 625&ndash;662. Oxford University Press: New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in dataset "mining"
table1 &lt;- value_decom(c("h2","x2"), c("w2","u2"), "y2", "p2", "year", mining)[[1]]
table2 &lt;- value_decom(c("h2","x2"), c("w2","u2"), "y2", "p2", "year", mining)[[2]]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
