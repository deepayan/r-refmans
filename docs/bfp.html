<!DOCTYPE html><html><head><title>Help for package bfp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bfp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.BayesMfp'><p>Convert a BayesMfp object to a data frame</p></a></li>
<li><a href='#BayesMfp'><p>Bayesian model inference for multiple fractional polynomial models</p></a></li>
<li><a href='#BayesMfp Methods'><p>Other methods for BayesMfp objects</p></a></li>
<li><a href='#bmaPredict'><p>BMA prediction for new data points</p></a></li>
<li><a href='#BmaSamples'><p>Bayesian model averaging over multiple fractional polynomial</p>
models</a></li>
<li><a href='#BmaSamples Methods'><p>Other methods for BmaSamples objects</p></a></li>
<li><a href='#constructNewdataMatrix'><p>Construct the model matrix for new data based on an existing</p>
BayesMfp object</a></li>
<li><a href='#dinvGamma'><p>Functions for the inverse gamma distribution.</p></a></li>
<li><a href='#empiricalHpd'><p>Construct an empirical HPD interval from samples</p></a></li>
<li><a href='#Extract.BayesMfp'><p>Extract method for BayesMfp objects</p></a></li>
<li><a href='#findModel'><p>Find a specific fractional polynomial model in a</p>
BayesMfp object</a></li>
<li><a href='#fpScale'><p>Internal function for shifting and rescaling a fractional polynomial covariate</p></a></li>
<li><a href='#getDesignMatrix'><p>Extract the design matrix of a multiple FP model.</p></a></li>
<li><a href='#getFpTransforms'><p>Internal functions to handle FP transforms.</p></a></li>
<li><a href='#getLogMargLik'><p>Extract log marginal likelihood from a model.</p></a></li>
<li><a href='#getLogPrior'><p>Extract the log prior probability from a model.</p></a></li>
<li><a href='#getPosteriorParms'><p>Extract updated posterior parameters for the normal inverse gamma</p>
distribution from a model, given a shrinkage factor.</a></li>
<li><a href='#getPostExpectedgAndShrinkage'><p>Extract posterior expected g and shrinkage factor (g/(1+g)) from a model</p></a></li>
<li><a href='#inclusionProbs'><p> Compute (model averaged) posterior variable inclusion probabilites</p></a></li>
<li><a href='#ozone'><p>Ozone data from Breiman and Friedman, 1985</p></a></li>
<li><a href='#plotCurveEstimate'><p>Generic function for plotting a fractional polynomial curve estimate</p></a></li>
<li><a href='#posteriors'><p>Extract posterior model probability estimates from BayesMfp objects</p></a></li>
<li><a href='#predict.BayesMfp'><p>Predict method for BayesMfp objects</p></a></li>
<li><a href='#predict.BmaSamples'><p>Predict method to extract point and interval predictions from</p>
BmaSamples objects</a></li>
<li><a href='#rmvt'><p>Multivariate Student Random Deviates</p></a></li>
<li><a href='#rshrinkage'><p>Sample from the model-specific posterior of the shrinkage factor t = g / (1 + g)</p></a></li>
<li><a href='#scrBesag'><p>Simultaneous credible band computation (Besag, Green et al algorithm)</p></a></li>
<li><a href='#scrHpd'><p>Calculate an SCB from a samples matrix</p></a></li>
<li><a href='#Summary of BayesMfp object'><p>Calculate and print the summary of a BayesMfp object</p></a></li>
<li><a href='#Summary of BmaSamples object'><p>Calculate and print the summary of a BmaSamples object</p></a></li>
<li><a href='#transformMfp'><p>Transform a fitted mfp model into a BayesMfp model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.0-48</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Fractional Polynomials</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doBy, Hmisc</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Bayesian paradigm for fractional
 polynomial models under the assumption of normally distributed error terms, see
 Sabanes Bove, D. and Held, L. (2011) &lt;<a href="https://doi.org/10.1007%2Fs11222-010-9170-7">doi:10.1007/s11222-010-9170-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>hyp2f1 is from Cephes Math Library Release 2.3, Copyright
1995 by Stephen L. Moshier. Newmat is Copyright 1991-2005 by
Robert B. Davies. Function fpScale is derived from the
R-package mfp written by Gareth Ambler and Axel Benner.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 09:59:04 UTC; danie</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Sabanes Bove [aut, cre],
  Isaac Gravestock [aut],
  Robert Davies [cph],
  Stephen Moshier [cph],
  Gareth Ambler [cph],
  Axel Benner [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Sabanes Bove &lt;daniel.sabanesbove@gmx.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.BayesMfp'>Convert a BayesMfp object to a data frame</h2><span id='topic+as.data.frame.BayesMfp'></span>

<h3>Description</h3>

<p>Convert the <code><a href="#topic+BayesMfp">BayesMfp</a></code> object to a data frame with the
saved models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesMfp'
as.data.frame(x, row.names = NULL, ..., freq = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.BayesMfp_+3A_x">x</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code id="as.data.frame.BayesMfp_+3A_row.names">row.names</code></td>
<td>
<p>optional rownames (default is to keep the names of
the <code><a href="#topic+BayesMfp">BayesMfp</a></code> list)</p>
</td></tr>
<tr><td><code id="as.data.frame.BayesMfp_+3A_freq">freq</code></td>
<td>
<p>should empirical frequencies of the models in the sampling
path be given? (default)</p>
</td></tr>
<tr><td><code id="as.data.frame.BayesMfp_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BayesMfp">summary.BayesMfp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## get the models data frame
as.data.frame(test)
</code></pre>

<hr>
<h2 id='BayesMfp'>Bayesian model inference for multiple fractional polynomial models</h2><span id='topic+BayesMfp'></span><span id='topic+bfp'></span><span id='topic+uc'></span>

<h3>Description</h3>

<p>Bayesian model inference for multiple fractional polynomial
models is conducted by means of either exhaustive model space
evaluation or posterior model sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesMfp(formula = formula(data), data = parent.frame(), family =
gaussian, priorSpecs = list(a = 4, modelPrior = "flat"), method =
c("ask", "exhaustive", "sampling"), subset = NULL, na.action = na.omit,
verbose = TRUE, nModels = NULL, nCache=1e9L, chainlength = 1e5L)

bfp(x, max = 2, scale = TRUE, rangeVals=NULL)

uc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesMfp_+3A_formula">formula</code></td>
<td>
<p>model formula</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_data">data</code></td>
<td>
<p>optional data.frame for model variables (defaults to the
parent frame)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_family">family</code></td>
<td>
<p>distribution and link: only gaussian(&quot;identity&quot;) supported at the moment</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_priorspecs">priorSpecs</code></td>
<td>
<p>prior specifications, see details</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_method">method</code></td>
<td>
<p>which method should be used to explore the  posterior
model space? (default: ask the user)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_subset">subset</code></td>
<td>
<p>optional subset expression</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_na.action">na.action</code></td>
<td>
<p>default is to skip rows with missing data, and no other
option supported at the moment</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_verbose">verbose</code></td>
<td>
<p>should information on computation progress be given? (default)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_nmodels">nModels</code></td>
<td>
<p>how many best models should be saved? (default: 1% of
the explored models or the chainlength, 1 would mean only the
maximum a posteriori [MAP] model)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_ncache">nCache</code></td>
<td>
<p>maximum number of best models to be cached at the same
time during the model sampling (only has an effect if sampling has
been chosen as method)</p>
</td></tr>  
<tr><td><code id="BayesMfp_+3A_chainlength">chainlength</code></td>
<td>
<p>length of the model sampling chain (only has an
effect if sampling has been chosen as method)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_x">x</code></td>
<td>
<p>variable</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_max">max</code></td>
<td>
<p>maximum degree for this FP (default: 2)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_scale">scale</code></td>
<td>
<p>use pre-transformation scaling to avoid numerical
problems? (default)</p>
</td></tr>
<tr><td><code id="BayesMfp_+3A_rangevals">rangeVals</code></td>
<td>
<p>extra numbers if the scaling should consider values
in this range. Use this argument if you have test data with larger
range than the training range.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>The formula is of the form
<code>y ~ bfp (x1, max = 4) + uc (x2 + x3)</code>, that is, the
auxiliary functions <code><a href="#topic+bfp">bfp</a></code> and <code><a href="#topic+uc">uc</a></code> must be
used for defining the fractional polynomial and uncertain fixed form
covariates terms, respectively. There must be an intercept, and no
other fixed covariates are allowed. All <code>max</code> arguments of the
<code><a href="#topic+bfp">bfp</a></code> terms must be identical.
</p>
<p>The prior specifications are a list:
</p>

<dl>
<dt>a</dt><dd><p>hyperparameter for hyper-g prior which must be greater than
3 and is recommended to be not greater than 4 (default is 4)</p>
</dd>
<dt>modelPrior</dt><dd><p>choose if a flat model prior (default,
<code>"flat"</code>), a model prior favoring 
sparse models explicitly (<code>"sparse"</code>), or a dependent model
prior (<code>"dependent"</code>) should be used.</p>
</dd>
</dl>

<p>If <code>method = "ask"</code>, the user is prompted with the maximum
cardinality of the model space and can then decide whether to use
posterior sampling or the exhaustive model space evaluation.
</p>
<p>Note that if you specify only one FP term, the exhaustive model search
must be done, due to the structure of the model sampling algorithm.
However, in reality this will not be a problem as the model space will
typically be very small.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>BayesMfp</code> that inherits from list. It
is essentially a list of models. Each model is a list and has the
following components: 
</p>
<table>
<tr><td><code>powers</code></td>
<td>
<p>a list of numeric vectors, where each vector contains
the powers of the covariate that its name denotes.</p>
</td></tr>
<tr><td><code>ucTerms</code></td>
<td>
<p>an integer vector of the indices of uncertain fixed
form covariates that are present in the model.</p>
</td></tr>
<tr><td><code>logM</code></td>
<td>
<p>log marginal likelihood</p>
</td></tr>
<tr><td><code>logP</code></td>
<td>
<p>log prior probability</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>normalized posterior probability, and if model
sampling was done, the frequency of the model in the sampling
algorithm</p>
</td></tr> 
<tr><td><code>postExpectedg</code></td>
<td>
<p>posterior expected covariance factor g</p>
</td></tr>
<tr><td><code>postExpectedShrinkage</code></td>
<td>
<p>posterior expected shrinkage factor
t=g/(g + 1)</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>usual coefficient of determination for the linear model</p>
</td></tr>
</table>
<p>Subsetting the object
with <code><a href="#topic++5B.BayesMfp">[.BayesMfp</a></code> returns again a <code>BayesMfp</code> object
with the same attributes, which are
</p>
<table>
<tr><td><code>numVisited</code></td>
<td>
<p>the number of models that have been visited
(exhaustive search) or cached (model sampling)</p>
</td></tr>
<tr><td><code>inclusionProbs</code></td>
<td>
<p>BMA inclusion probabilities for all uncertain
covariates</p>
</td></tr>
<tr><td><code>linearInclusionProbs</code></td>
<td>
<p>BMA probabilities for exactly linear
inclusion of FP covariates</p>
</td></tr> 
<tr><td><code>logNormConst</code></td>
<td>
<p>the (estimated) log normalizing constant <code class="reqn">f
      (D)</code></p>
</td></tr>
<tr><td><code>chainlength</code></td>
<td>
<p>length of the Markov chain, only present if <code>method = "sampling"</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula by which the appropriate untransformed
design matrix can be extracted</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the shifted and scaled design matrix for the data</p>
</td></tr>
<tr><td><code>xCentered</code></td>
<td>
<p>the column-wise centered x</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code>yMean</code></td>
<td>
<p>the mean of the response values</p>
</td></tr>
<tr><td><code>SST</code></td>
<td>
<p>sum of squares total</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p>a list with components that describe the positions of
uncertain covariate groups, fractional polynomial terms and fixed
variables in the design matrix</p>
</td></tr>
<tr><td><code>termNames</code></td>
<td>
<p>a list of character vectors containing the names of
uncertain covariate groups, fractional polynomial terms and fixed
variables</p>
</td></tr>
<tr><td><code>shiftScaleMax</code></td>
<td>
<p>matrix with 4 columns containing preliminary
transformation parameters, maximum degrees and cardinalities of the
powersets of the fractional polynomial terms</p>
</td></tr>
<tr><td><code>priorSpecs</code></td>
<td>
<p>the utilized prior specifications</p>
</td></tr>
<tr><td><code>randomSeed</code></td>
<td>
<p>if a seed existed at function call
(<code>get(".Random.seed", .GlobalEnv)</code>), it is saved here</p>
</td></tr> 
</table>


<h3>Note</h3>

<p><code>logNormConst</code> may be unusable due to necessary conversion
from long double to double!
</p>
<p>Various methods for posterior summaries are available.
</p>


<h3>See Also</h3>

<p><a href="#topic+BayesMfp+20Methods">BayesMfp Methods</a>, <code><a href="#topic+BmaSamples">BmaSamples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

## run an exhaustive model space evaluation with a flat model prior and
## a uniform prior (a = 4) on the shrinkage factor t = g/(1 + g):
test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")
test

## now the same with a *dependent* model prior:
test2 &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
		 priorSpecs = list(a = 4, modelPrior = "dependent"),
                 method="exhaustive")
test2
</code></pre>

<hr>
<h2 id='BayesMfp+20Methods'>Other methods for BayesMfp objects</h2><span id='topic+BayesMfp+20Methods'></span><span id='topic+fitted.BayesMfp'></span><span id='topic+print.BayesMfp'></span><span id='topic+residuals.BayesMfp'></span>

<h3>Description</h3>

<p>Print the object (<code>print</code>),
get fitted values (<code>fitted</code>) and corresponding residuals (<code>residuals</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesMfp'
print(x, ...)
## S3 method for class 'BayesMfp'
fitted(object, design = getDesignMatrix(object), post =
getPosteriorParms(object, design = design), ...) 
## S3 method for class 'BayesMfp'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesMfp+2B20Methods_+3A_x">x</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code id="BayesMfp+2B20Methods_+3A_object">object</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object, only the first model will be
used.</p>
</td></tr> 
<tr><td><code id="BayesMfp+2B20Methods_+3A_design">design</code></td>
<td>
<p>design matrix of the first model in the object, which
can be supplied by the caller if it is computed beforehand</p>
</td></tr>
<tr><td><code id="BayesMfp+2B20Methods_+3A_post">post</code></td>
<td>
<p>posterior parameters of the normal-gamma distribution
(defaults to the posterior expected mean, marginalized over the
covariance factor g)</p>
</td></tr>
<tr><td><code id="BayesMfp+2B20Methods_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesMfp">BayesMfp</a></code>, <code><a href="#topic+BmaSamples+20Methods">BmaSamples Methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## the print method
test

## extract fitted values and corresponding residuals
fitted(test)
residuals(test)

</code></pre>

<hr>
<h2 id='bmaPredict'>BMA prediction for new data points</h2><span id='topic+bmaPredict'></span>

<h3>Description</h3>

<p>Make a Bayesian model averaged prediction for new data points, from
those models saved in a <code><a href="#topic+BayesMfp">BayesMfp</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmaPredict(BayesMfpObject, postProbs = posteriors(BayesMfpObject), newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmaPredict_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p><code><a href="#topic+BayesMfp">BayesMfp</a></code> object with the models
over which the predictions should be averaged</p>
</td></tr>
<tr><td><code id="bmaPredict_+3A_postprobs">postProbs</code></td>
<td>
<p>vector of posterior probabilities, which are then
normalized to the weights of the model average (defaults to the
normalized posterior probability estimates)</p>
</td></tr>
<tr><td><code id="bmaPredict_+3A_newdata">newdata</code></td>
<td>
<p>new covariate data as data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted values as a vector.
</p>


<h3>Note</h3>

<p>Note that this function is not an S3 predict method for
<code><a href="#topic+BmaSamples">BmaSamples</a></code> objects, but a function working on
<code><a href="#topic+BayesMfp">BayesMfp</a></code> objects (because we do not need BMA samples to
do BMA point predictions).
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+BmaSamples+20Methods">BmaSamples Methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## predict new responses at (again random) covariates
bmaPredict(test,
           newdata = list(x1 = rnorm(n=15),
                          x2 = rbinom(n=15, size=5, prob=0.2) + 1,
                          x3 = rexp(n=15)))
</code></pre>

<hr>
<h2 id='BmaSamples'>Bayesian model averaging over multiple fractional polynomial
models</h2><span id='topic+BmaSamples'></span>

<h3>Description</h3>

<p>Draw samples from the Bayesian model average over the models in
saved in a <code><a href="#topic+BayesMfp">BayesMfp</a></code>-object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BmaSamples(object, sampleSize = length(object) * 10, postProbs =
posteriors(object), gridList = list(), gridSize = 203, newdata=NULL,
verbose = TRUE, includeZeroSamples=FALSE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BmaSamples_+3A_object">object</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object containing the
models over which to average</p>
</td></tr> 
<tr><td><code id="BmaSamples_+3A_samplesize">sampleSize</code></td>
<td>
<p>sample size (default is 10 times the number of models)</p>
</td></tr>
<tr><td><code id="BmaSamples_+3A_postprobs">postProbs</code></td>
<td>
<p>vector of posterior probabilites (will be normalized
within the function, defaults to the normalized posterior probabilities)</p>
</td></tr> 
<tr><td><code id="BmaSamples_+3A_gridlist">gridList</code></td>
<td>
<p>optional list of appropriately named grid vectors for FP evaluation,
default is a length (<code>gridSize</code> - 2) grid per covariate additional to the observed values
(two are at the minimum and maximum)</p>
</td></tr>
<tr><td><code id="BmaSamples_+3A_gridsize">gridSize</code></td>
<td>
<p>see above (default: 203)</p>
</td></tr>
<tr><td><code id="BmaSamples_+3A_newdata">newdata</code></td>
<td>
<p>new covariate data.frame with exactly the names (and
preferably ranges) as before (default: no new covariate data)</p>
</td></tr>  
<tr><td><code id="BmaSamples_+3A_verbose">verbose</code></td>
<td>
<p>should information on sampling progress be printed?
(default)</p>
</td></tr>
<tr><td><code id="BmaSamples_+3A_includezerosamples">includeZeroSamples</code></td>
<td>
<p>should the function and coefficient samples
include zero samples, from models where these covariates are not
included at all? (default: <code>FALSE</code>, so the zero samples are
not included)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class <code>BmaSamples</code>, which is a list with
various elements that describe the <code>BayesMfp</code> object over which
was averaged, model frequencies in the samples, the samples themselves
etc:
</p>
<table>
<tr><td><code>priorSpecs</code></td>
<td>
<p>the utilized prior specifications</p>
</td></tr>
<tr><td><code>termNames</code></td>
<td>
<p>a list of character vectors containing the names of
uncertain covariate groups, fractional polynomial terms and fixed
variables</p>
</td></tr>
<tr><td><code>shiftScaleMax</code></td>
<td>
<p>matrix with 4 columns containing preliminary
transformation parameters, maximum degrees and cardinalities of the
powersets of the fractional polynomial terms</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the shifted and scaled design matrix for the data</p>
</td></tr>
<tr><td><code>randomSeed</code></td>
<td>
<p>if a seed existed at function call
(<code>get(".Random.seed", .GlobalEnv)</code>), it is saved here</p>
</td></tr>
<tr><td><code>modelFreqs</code></td>
<td>
<p>The table of model frequencies in the BMA sample</p>
</td></tr>
<tr><td><code>modelData</code></td>
<td>
<p>data frame containing the normalized posterior
probabilities of the models in the underlying <code><a href="#topic+BayesMfp">BayesMfp</a></code>
object, corresponding log marginal likelihoods, model prior
probabilities, posterior expected covariance and shrinkage factors,
coefficients of determination, powers and inclusions, and finally
model average weights and relative frequencies in the BMA sample.</p>
</td></tr>
<tr><td><code>sampleSize</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>BMA samples of the regression variance</p>
</td></tr>
<tr><td><code>shrinkage</code></td>
<td>
<p>BMA samples of the shrinkage factor</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>samples of the intercept</p>
</td></tr>
<tr><td><code>bfp</code></td>
<td>
<p>named list of the FP function samples, where each element
contains one FP covariate and is a matrix (samples x grid), with the
following attributes:
</p>

<dl>
<dt>whereObsVals</dt><dd><p>where in the scaled grid are the originally
observed covariate values? (integer vector of the indexes)</p>
</dd>
<dt>scaledGrid</dt><dd><p>numeric vector with the positions of the scaled
grid points, corresponding to the columns of the samples matrix</p>
</dd>
<dt>counter</dt><dd><p>how often has this covariate been included in the BMA
sample? (identical to the number of rows in the samples matrix)</p>
</dd>
</dl>

</td></tr>
<tr><td><code>uc</code></td>
<td>
<p>named list of the uncertain fixed form covariates, where each
element contains the coefficient samples of one group: in a matrix
with the attribute <code>counter</code> as number of samples in the rows,
and the columns are appropriately named to correspond to the single
design variables.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values of all models in <code>object</code>, in a matrix
with layout models x observations.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>samples from the predictive distribution at the
covariates given in <code>newdata</code></p>
</td></tr>
<tr><td><code>predictMeans</code></td>
<td>
<p>means of the predictive distribution at the
covariates given in <code>newdata</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+BmaSamples+20Methods">BmaSamples Methods</a>, <code><a href="#topic+BayesMfp">BayesMfp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## now draw samples from the Bayesian model average
testBma &lt;- BmaSamples (test)
testBma

## We can also draw predictive samples for new data points, but then
## we need to supply the new data to BmaSamples:
newdata &lt;- data.frame(x1 = rnorm(15),
                      x2 = rbinom(n=15, size=5, prob=0.2) + 1,
                      x3 = rexp(n=15))
testBma &lt;- BmaSamples(test, newdata=newdata)
predict(testBma)

## test that inclusion of zero samples works
testBma &lt;- BmaSamples (test, includeZeroSamples=TRUE)
testBma
</code></pre>

<hr>
<h2 id='BmaSamples+20Methods'>Other methods for BmaSamples objects</h2><span id='topic+BmaSamples+20Methods'></span><span id='topic+fitted.BmaSamples'></span><span id='topic+print.BmaSamples'></span><span id='topic+residuals.BmaSamples'></span>

<h3>Description</h3>

<p>Print the object (<code>print</code>),
get fitted values (<code>fitted</code>) and corresponding residuals
(<code>residuals</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BmaSamples'
print(x, ...)
## S3 method for class 'BmaSamples'
fitted(object, ...)
## S3 method for class 'BmaSamples'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BmaSamples+2B20Methods_+3A_x">x</code></td>
<td>
<p>valid <code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr>
<tr><td><code id="BmaSamples+2B20Methods_+3A_object">object</code></td>
<td>
<p>valid <code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr>
<tr><td><code id="BmaSamples+2B20Methods_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.BmaSamples">predict.BmaSamples</a></code>, <code><a href="#topic+summary.BmaSamples">summary.BmaSamples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## now draw samples from the Bayesian model average
testBma &lt;- BmaSamples (test)

## the print method:
testBma

## the fitted method:
fitted(testBma)

## and the corresponding residuals:
residuals(testBma)

</code></pre>

<hr>
<h2 id='constructNewdataMatrix'>Construct the model matrix for new data based on an existing
BayesMfp object</h2><span id='topic+constructNewdataMatrix'></span>

<h3>Description</h3>

<p>This is an internal function, which constructs a model matrix for new covariate
data, based on the formula and scaling info in an existing BayesMfp object.
The matrix can then be passed to prediction functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructNewdataMatrix(BayesMfpObject, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructNewdataMatrix_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p>a valid <code><a href="#topic+BayesMfp">BayesMfp</a></code>-Object</p>
</td></tr>
<tr><td><code id="constructNewdataMatrix_+3A_newdata">newdata</code></td>
<td>
<p>the new covariate data as a data.frame (with the same
covariate names as in the call to <code><a href="#topic+BayesMfp">BayesMfp</a></code>)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>The (uncentered!) model matrix with the FP columns shifted and scaled
as for the original data.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## some new covariate data
newdata &lt;- data.frame(x1 = 1:10, x2 = rbinom(n=10, size=20, prob=0.6),
x3 = 2:11)

## construct the new design matrix:
newmatrix &lt;- bfp:::constructNewdataMatrix(BayesMfpObject=test, newdata=newdata)

## check the result:
stopifnot(identical(newmatrix,
                    structure(c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.6,
				1.2, 1.2, 1.2,  1.3, 1.3, 1.4, 1.1,
				1.2, 1.1, 1, 2, 3, 4, 5, 6, 7, 8, 9,
				10,  2, 3, 4, 5, 6, 7, 8, 9, 10, 11),
				.Dim = c(10L, 4L),
				.Dimnames =
                                 list(c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"),
				      c("(Intercept)", "x2", "x1", "x3")),
				assign = 0:3)))
</code></pre>

<hr>
<h2 id='dinvGamma'>Functions for the inverse gamma distribution.</h2><span id='topic+dinvGamma'></span><span id='topic+pinvGamma'></span><span id='topic+qinvGamma'></span><span id='topic+rinvGamma'></span>

<h3>Description</h3>

<p>Functions for the inverse gamma distribution, analogues to the gamma
distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvGamma(x, a, b, log = FALSE, normalize = TRUE)
pinvGamma(q, a, b, lower.tail = TRUE, log.p = FALSE)
qinvGamma(p, a, b, lower.tail = TRUE, log.p = FALSE)
rinvGamma(n, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dinvGamma_+3A_x">x</code>, <code id="dinvGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_a">a</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_b">b</code></td>
<td>
<p>rate parameter</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_log">log</code>, <code id="dinvGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities p
are returned as log(p)</p>
</td></tr> 
<tr><td><code id="dinvGamma_+3A_normalize">normalize</code></td>
<td>
<p>normalize the density function? (default)</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x]</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="dinvGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the gamma distribution (<code><a href="stats.html#topic+rgamma">rgamma</a></code>) for the details.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>

<hr>
<h2 id='empiricalHpd'>Construct an empirical HPD interval from samples</h2><span id='topic+empiricalHpd'></span>

<h3>Description</h3>

<p>Construct an empirical highest posterior density (HPD) interval from
samples which have been drawn from the distribution of a quantity of
interest. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empiricalHpd(theta, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiricalHpd_+3A_theta">theta</code></td>
<td>
<p>the vector of samples</p>
</td></tr>
<tr><td><code id="empiricalHpd_+3A_level">level</code></td>
<td>
<p>the credible level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the estimated lower and upper bounds of the HPD
interval. 
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## draw standard normal variates
test &lt;- rnorm(n=1000)

## estimate the 95% HPD interval with these samples:
empiricalHpd(theta=test, level=0.95)

## compare with true HPD:
qnorm(p=c(0.025, 0.975))
</code></pre>

<hr>
<h2 id='Extract.BayesMfp'>Extract method for BayesMfp objects</h2><span id='topic+Extract.BayesMfp'></span><span id='topic++5B.BayesMfp'></span>

<h3>Description</h3>

<p>Extract a subset of models from a <code><a href="#topic+BayesMfp">BayesMfp</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesMfp'
x[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.BayesMfp_+3A_x">x</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code id="Extract.BayesMfp_+3A_...">...</code></td>
<td>
<p>transports the indexes of the models</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+BayesMfp">BayesMfp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## extract the top ten models
test[1:10]
</code></pre>

<hr>
<h2 id='findModel'>Find a specific fractional polynomial model in a
BayesMfp object</h2><span id='topic+findModel'></span>

<h3>Description</h3>

<p>Returns the index of the wished model if it is present in the model
list, and otherwise returns <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findModel(model, BayesMfpObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findModel_+3A_model">model</code></td>
<td>
<p>the specific model: a list with entries <code>powers</code> and
<code>ucTerms</code></p>
</td></tr>
<tr><td><code id="findModel_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p>an object of class <code><a href="#topic+BayesMfp">BayesMfp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+BayesMfp">BayesMfp</a></code> for the description of a model. 
</p>


<h3>Value</h3>

<p>Index of <code>model</code> in <code>BayesMfpObject</code> if it is present in the
model list, otherwise <code>NA</code>.
</p>


<h3>Note</h3>

<p>The searched model must have exactly the same construction as the
models in <code>BayesMfpObject</code>. See the example below for the
recommended use. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(92)

x1 &lt;- rnorm (15)
x2 &lt;- rbinom (n=15, size=20, prob=0.6)
x3 &lt;- rexp (15)
y &lt;- rt (15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels=2000, method="exhaustive")

## copy one model 
myModel &lt;- test[[1]]

## and modify it!
myModel$powers[["x2"]] &lt;- c (1, 2)
stopifnot(identical(findModel (myModel, test),
                    31L))
</code></pre>

<hr>
<h2 id='fpScale'>Internal function for shifting and rescaling a fractional polynomial covariate</h2><span id='topic+fpScale'></span>

<h3>Description</h3>

<p>This function is derived from mfp:::fp.scale written by Gareth Ambler and Axel Benner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpScale(x, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpScale_+3A_x">x</code></td>
<td>
<p>covariate</p>
</td></tr>
<tr><td><code id="fpScale_+3A_scaling">scaling</code></td>
<td>
<p>should scaling take place?</p>
</td></tr>
</table>

<hr>
<h2 id='getDesignMatrix'>Extract the design matrix of a multiple FP model.</h2><span id='topic+getDesignMatrix'></span>

<h3>Description</h3>

<p>Extract the (centered) design matrix of the first element (== model) of a
<code><a href="#topic+BayesMfp">BayesMfp</a></code> object. This is an internal function not
intended to be used publicly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignMatrix(x, fixedColumns=TRUE, center=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDesignMatrix_+3A_x">x</code></td>
<td>
<p>a valid BayesMfp-Object of length 1 (otherwise only first
element is recognized)</p>
</td></tr>
<tr><td><code id="getDesignMatrix_+3A_fixedcolumns">fixedColumns</code></td>
<td>
<p>return the fixed columns (intercept) inside the
matrix (default) or not?</p>
</td></tr>
<tr><td><code id="getDesignMatrix_+3A_center">center</code></td>
<td>
<p>shall the non-intercept columns be centered? (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The design matrix with an attribute <code>shifts</code> containing the used
shifts for the optional centering of the non-intercept columns. (If
<code>center</code> is <code>FALSE</code>, the shifts vector will contain only
zeroes.) 
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFpTransforms">getFpTransforms</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## get the design matrix of the fifth best model
a &lt;- bfp:::getDesignMatrix(test[5])
attr(a, "shifts")

## and once again but without centering
b &lt;- bfp:::getDesignMatrix(test[5], center=FALSE)
stopifnot(all(attr(b, "shifts") == 0))
</code></pre>

<hr>
<h2 id='getFpTransforms'>Internal functions to handle FP transforms.</h2><span id='topic++25bt+25'></span><span id='topic+getFpTransforms'></span><span id='topic+getTransformName'></span>

<h3>Description</h3>

<p>Transform a variable according to FP transformation formula and attach
proper names to the resulting design matrix. The binary function
<code>bt</code> is the Box-Tidwell transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %bt% pow
getFpTransforms(vec, powers, center=TRUE)
getTransformName(name, pow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFpTransforms_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getFpTransforms_+3A_pow">pow</code></td>
<td>
<p>one single power (not vectorized in this argument)</p>
</td></tr>
<tr><td><code id="getFpTransforms_+3A_vec">vec</code></td>
<td>
<p>positive (== already shifted and scaled) column vector (!) with
proper colname</p>
</td></tr> 
<tr><td><code id="getFpTransforms_+3A_powers">powers</code></td>
<td>
<p>power vector with at least one element</p>
</td></tr>
<tr><td><code id="getFpTransforms_+3A_center">center</code></td>
<td>
<p>should the columns be centered around zero? (default)</p>
</td></tr>
<tr><td><code id="getFpTransforms_+3A_name">name</code></td>
<td>
<p>name of the covariate to be transformed with <code>bt</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignMatrix">getDesignMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bfp:::getFpTransforms(cbind(x=1:10), powers=c(-2, 0, 1))
</code></pre>

<hr>
<h2 id='getLogMargLik'>Extract log marginal likelihood from a model.</h2><span id='topic+getLogMargLik'></span>

<h3>Description</h3>

<p>Extract log marginal likelihood from a model, saved as the first
element of a <code><a href="#topic+BayesMfp">BayesMfp</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLogMargLik(x, design=getDesignMatrix(x), nObs = nrow(design), dim = ncol(design))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLogMargLik_+3A_x">x</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code>-Object of length 1 (otherwise only first
element recognized)</p>
</td></tr> 
<tr><td><code id="getLogMargLik_+3A_design">design</code></td>
<td>
<p>(centered) design matrix</p>
</td></tr>
<tr><td><code id="getLogMargLik_+3A_nobs">nObs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="getLogMargLik_+3A_dim">dim</code></td>
<td>
<p>number of design matrix columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interfaces the C++ function <code>logMargLik</code>, and can
be used to compute the marginal likelihood of a model not saved in the
model list. But be careful to adjust the saved R^2 of the model, too,
and not only the powers! Therefore this function is internal only...
and is used e.g. in <code><a href="#topic+transformMfp">transformMfp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLogPrior">getLogPrior</a></code></p>

<hr>
<h2 id='getLogPrior'>Extract the log prior probability from a model.</h2><span id='topic+getLogPrior'></span>

<h3>Description</h3>

<p>Extract the log prior probability from the first model saved in a
<code><a href="#topic+BayesMfp">BayesMfp</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLogPrior(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLogPrior_+3A_x">x</code></td>
<td>
<p>a valid BayesMfp-Object of length 1 (otherwise only first
element recognized)</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Note that the returned value might be only defined up to a constant,
because some models might not be identifiable or have a dimension too
large, and are thus implicitly assigned a zero prior probabibility.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLogMargLik">getLogMargLik</a></code></p>

<hr>
<h2 id='getPosteriorParms'>Extract updated posterior parameters for the normal inverse gamma
distribution from a model, given a shrinkage factor.</h2><span id='topic+getPosteriorParms'></span>

<h3>Description</h3>

<p>Conditional on a fixed shrinkage factor t=g/(g+1), the posterior joint distribution
of the effects and the regression variance is normal inverse gamma.
With this function, you can compute the parameters of this distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPosteriorParms(x, shrinkage=x[[1]]$postExpectedShrinkage,  
                  design = getDesignMatrix(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPosteriorParms_+3A_x">x</code></td>
<td>
<p>a valid <code><a href="#topic+BayesMfp">BayesMfp</a></code>-Object, only first list element will be recognized</p>
</td></tr>
<tr><td><code id="getPosteriorParms_+3A_shrinkage">shrinkage</code></td>
<td>
<p>shrinkage factor used in the computations (defaults
to the posterior expected shrinkage factor in the model <code>x[1]</code>)</p>
</td></tr> 
<tr><td><code id="getPosteriorParms_+3A_design">design</code></td>
<td>
<p>(centered) design matrix for the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four parameters:
</p>
<table>
<tr><td><code>aStar</code></td>
<td>
<p>the first parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code>VStar</code></td>
<td>
<p>the covariance matrix part of the multivariate normal
distribution</p>
</td></tr>
<tr><td><code>mStar</code></td>
<td>
<p>the expectation of the multivariate normal
distribution</p>
</td></tr>
<tr><td><code>bStar</code></td>
<td>
<p>the second parameter of the inverse gamma distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## now get the posterior parameters of the third best model
getPosteriorParms(test[3])
</code></pre>

<hr>
<h2 id='getPostExpectedgAndShrinkage'>Extract posterior expected g and shrinkage factor (g/(1+g)) from a model</h2><span id='topic+getPostExpectedg'></span><span id='topic+getPostExpectedShrinkage'></span>

<h3>Description</h3>

<p>For a valid BayesMfp object, extract posterior expected g and
shrinkage factor g/(1+g)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPostExpectedg(x, design=getDesignMatrix(x), nObs = nrow(design),
dim = ncol(design))
getPostExpectedShrinkage(x, design=getDesignMatrix(x),
nObs =nrow(design), dim = ncol(design))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPostExpectedgAndShrinkage_+3A_x">x</code></td>
<td>
<p>a valid <code><a href="#topic+BayesMfp">BayesMfp</a></code>-Object of length 1 (otherwise only first
element is recognized)</p>
</td></tr>
<tr><td><code id="getPostExpectedgAndShrinkage_+3A_design">design</code></td>
<td>
<p>the (centered) design matrix</p>
</td></tr>
<tr><td><code id="getPostExpectedgAndShrinkage_+3A_nobs">nObs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="getPostExpectedgAndShrinkage_+3A_dim">dim</code></td>
<td>
<p>number of design covariates</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>The posterior expected g or shrinkage factor g/(1+g) from the model.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>

<hr>
<h2 id='inclusionProbs'> Compute (model averaged) posterior variable inclusion probabilites</h2><span id='topic+inclusionProbs'></span>

<h3>Description</h3>

<p>Compute (model averaged) posterior inclusion probabilites for the
uncertain variables (including FP variables) based on a
<code><a href="#topic+BayesMfp">BayesMfp</a></code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusionProbs(BayesMfpObject, postProbs = posteriors(BayesMfpObject, ind = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclusionProbs_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code id="inclusionProbs_+3A_postprobs">postProbs</code></td>
<td>
<p>posterior probabilities to weight the models
(defaults to the normalized probability estimates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named numeric vector with the estimated variable inclusion
probabilities. Note that these can differ noticeably from the
&ldquo;global&rdquo; inclusion probabilities computed from all discovered
models, from which only the best were saved in the
<code><a href="#topic+BayesMfp">BayesMfp</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)

x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)

y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 200, method="exhaustive")

## now get the local inclusion probabilities
local &lt;- inclusionProbs(test)

## they can be compared with the global inclusion probabilities
local - attr(test, "inclusionProbs")
</code></pre>

<hr>
<h2 id='ozone'>Ozone data from Breiman and Friedman, 1985</h2><span id='topic+ozone'></span>

<h3>Description</h3>

<p>This is the Ozone data discussed in Breiman and Friedman (JASA, 1985, p. 580).
These data are for 330 days in 1976.  All measurements are in the area of
Upland, CA, east of Los Angeles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ozone)</code></pre>


<h3>Format</h3>

<p>A data frame with 366 observations on the following 13 variables.
</p>

<dl>
<dt><code>month</code></dt><dd><p>month of the year</p>
</dd>
<dt><code>day</code></dt><dd><p>day of the month</p>
</dd>
<dt><code>weekday</code></dt><dd><p>day of the week: a factor with levels <code>Monday</code>,
<code>Tueday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>,
<code>Saturday</code>, <code>Sunday</code></p>
</dd> 
<dt><code>hourAverageMax</code></dt><dd><p>maximum 1-hour average ozone level [ppm]</p>
</dd>
<dt><code>pressure500Height</code></dt><dd><p>500 millibar pressure height [meters]</p>
</dd>
<dt><code>windSpeed</code></dt><dd><p>wind speed [mph]</p>
</dd>
<dt><code>humidity</code></dt><dd><p>relative humidity [%]</p>
</dd>
<dt><code>tempSandburg</code></dt><dd><p>temperature at Sandberg, CA [degrees F]</p>
</dd>
<dt><code>tempElMonte</code></dt><dd><p>temperature at El Monte, CA [degrees F]</p>
</dd>
<dt><code>inversionBaseHeight</code></dt><dd><p>inversion base height [feet]</p>
</dd>
<dt><code>pressureGradientDaggett</code></dt><dd><p>pressure gradient from LAX to
Daggett, CA [mm Hg]</p>
</dd>
<dt><code>inversionBaseTemp</code></dt><dd><p>inversion base temperature [degrees F]</p>
</dd>
<dt><code>visibility</code></dt><dd><p>visibility [miles]</p>
</dd>
</dl>



<h3>Source</h3>

<p>Breiman, L and  Friedman, J.  (1985),
&ldquo;Estimating Optimal Transformations for Multiple Regression and Correlation&rdquo;,
<em>Journal of the American Statistical Association</em>, 80, 580-598.</p>

<hr>
<h2 id='plotCurveEstimate'>Generic function for plotting a fractional polynomial curve estimate</h2><span id='topic+plotCurveEstimate'></span><span id='topic+plotCurveEstimate.BayesMfp'></span><span id='topic+plotCurveEstimate.BmaSamples'></span>

<h3>Description</h3>

<p>Plot a fractional polynomial curve estimate for either a single model
or a Bayesian model average over <code><a href="#topic+BayesMfp">BayesMfp</a></code> objects. Optionally,
credible intervals and / or bands can be added to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCurveEstimate(model, termName, plevel = 0.95, slevel = plevel,
plot = TRUE, legendPos = "topleft", rug = FALSE, partialResids=TRUE, 
hpd=TRUE,..., main = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCurveEstimate_+3A_model">model</code></td>
<td>
<p>an object of class <code><a href="#topic+BayesMfp">BayesMfp</a></code> or <code><a href="#topic+BmaSamples">BmaSamples</a></code></p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_termname">termName</code></td>
<td>
<p>string denoting an FP term, as written by the
<code><a href="#topic+summary.BayesMfp">summary</a></code> method</p>
</td></tr> 
<tr><td><code id="plotCurveEstimate_+3A_plevel">plevel</code></td>
<td>
<p>credible level for pointwise intervals, and <code>NULL</code>
means no pointwise intervals (default: 0.95)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_slevel">slevel</code></td>
<td>
<p>credible level for simultaneous credible band (SCB),
<code>NULL</code> means no SCB (defaults to <code>plevel</code>)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_plot">plot</code></td>
<td>
<p>if <code>FALSE</code>, only return values needed to produce the
plot, but do not plot (default is <code>TRUE</code>, so a plot is made)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_legendpos">legendPos</code></td>
<td>
<p>position of coefficient estimates (for <code><a href="#topic+BayesMfp">BayesMfp</a></code>) or
sample size (for <code><a href="#topic+BmaSamples">BmaSamples</a></code>) in the plot, <code>NULL</code> suppresses the
printing (default is &ldquo;topleft&rdquo;)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_rug">rug</code></td>
<td>
<p>add a rug to the plot? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_partialresids">partialResids</code></td>
<td>
<p>add partial residuals to the plot? (default:
<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_hpd">hpd</code></td>
<td>
<p>use HPD intervals (<code>TRUE</code>, default) or quantile-based
(<code>FALSE</code>) intervals?</p>
</td></tr> 
<tr><td><code id="plotCurveEstimate_+3A_...">...</code></td>
<td>
<p>further arguments in case of a <code><a href="#topic+BayesMfp">BayesMfp</a></code>
object (see details) and arguments for plotting with
<code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
<tr><td><code id="plotCurveEstimate_+3A_main">main</code></td>
<td>
<p>optional main argument for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further arguments for application on a <code><a href="#topic+BayesMfp">BayesMfp</a></code> object:
</p>

<dl>
<dt>grid</dt><dd><p>vector of unscaled abscissae, default is a length
<code>gridSize</code> grid over the observed range specified by
providing the argument <code>NULL</code>.</p>
</dd>
<dt>post</dt><dd><p>list with posterior parameters of the model, which may be
provided manually to accelerate plotting in a loop</p>
</dd>
<dt>gridSize</dt><dd><p>default number of grid points used when no
<code>grid</code> is supplied (default is 201)</p>
</dd>
<dt>numSim</dt><dd><p>number of simulations for estimation of the SCB
(default is 500)</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list of various plotting information:
</p>
<table>
<tr><td><code>original</code></td>
<td>
<p>grid on the original covariate scale</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>grid on the transformed scale</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>mode curve values, only for <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>pointwise mean curve values, only for
<code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>pointwise median curve values, only for
<code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr> 
<tr><td><code>plower</code></td>
<td>
<p>lower boundaries for pointwise intervals</p>
</td></tr>
<tr><td><code>pupper</code></td>
<td>
<p>upper boundaries for pointwise intervals</p>
</td></tr>
<tr><td><code>slower</code></td>
<td>
<p>lower boundaries for SCB</p>
</td></tr>
<tr><td><code>supper</code></td>
<td>
<p>upper boundaries for SCB</p>
</td></tr>
<tr><td><code>obsVals</code></td>
<td>
<p>observed values of the covariate on the original scale</p>
</td></tr>
<tr><td><code>sampleSize</code></td>
<td>
<p>sample size underlying the curve estimate, only for
<code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr> 
<tr><td><code>partialResids</code></td>
<td>
<p>partial residuals</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>vector of shift and scale parameter</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BayesMfp">BayesMfp</a></code>, <code><a href="#topic+BmaSamples">BmaSamples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)
x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)
y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
method="exhaustive")

## plot the x2 curve estimate for the 20-th best model
p1 &lt;- plotCurveEstimate (test[20], "x2")

## look at the returned list
str(p1)

## plot the BMA curve estimate for the same covariate
testBma &lt;- BmaSamples (test)
p2 &lt;- plotCurveEstimate (testBma, "x2")

## look at the returned list
str(p2)

## try the new options:
plotCurveEstimate (testBma, "x2", partialResids=FALSE, hpd=FALSE)
</code></pre>

<hr>
<h2 id='posteriors'>Extract posterior model probability estimates from BayesMfp objects</h2><span id='topic+posteriors'></span>

<h3>Description</h3>

<p>Extract posterior model probability estimates (either normalized
estimates or sampling frequencies) from <code><a href="#topic+BayesMfp">BayesMfp</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriors(BayesMfpObject, ind = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriors_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p>a valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object,
containing the models the probabilites of which one wants to
estimate</p>
</td></tr>
<tr><td><code id="posteriors_+3A_ind">ind</code></td>
<td>
<p><code>ind = 1</code> means normalized posteriors, <code>ind = 2</code>
means sampling frequencies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of probability estimates.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(19)
x1 &lt;- rnorm (n=15)
x2 &lt;- rbinom (n=15, size=20, prob=0.5) 
x3 &lt;- rexp (n=15)
y &lt;- rt (n=15, df=2)

test &lt;- BayesMfp (y ~ bfp (x1, max = 2) + bfp (x2, max = 2) + uc (x3), nModels = 100,
		  method="exhaustive")

## this works:
posteriors(test)


## only if we do model sampling there are model frequencies:
test2 &lt;- BayesMfp (y ~ bfp (x1, max = 2) + bfp (x2, max = 2) + uc (x3), nModels = 100,
         method="sampling")
posteriors(test2, ind=2)
</code></pre>

<hr>
<h2 id='predict.BayesMfp'>Predict method for BayesMfp objects</h2><span id='topic+predict.BayesMfp'></span>

<h3>Description</h3>

<p>Predict new responses from a single multiple FP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesMfp'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BayesMfp_+3A_object">object</code></td>
<td>
<p>valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object, from which only the
first model will be used.</p>
</td></tr> 
<tr><td><code id="predict.BayesMfp_+3A_newdata">newdata</code></td>
<td>
<p>new covariate data with exactly the names (and
preferably ranges) as for the original <code><a href="#topic+BayesMfp">BayesMfp</a></code> call</p>
</td></tr>
<tr><td><code id="predict.BayesMfp_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmaPredict">bmaPredict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## predict new responses at (again random) covariates
predict(test,
        newdata = list(x1 = rnorm (15),
                       x2 = rbinom (n=15, size=5, prob=0.2) + 1,
                       x3 = rexp (15)))
</code></pre>

<hr>
<h2 id='predict.BmaSamples'>Predict method to extract point and interval predictions from
BmaSamples objects</h2><span id='topic+predict.BmaSamples'></span><span id='topic+print.predict.BmaSamples'></span>

<h3>Description</h3>

<p>Predict new responses from a Bayesian model average over FP models,
from which predictive samples have already been produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BmaSamples'
predict(object, level=0.95, hpd=TRUE, ...)
## S3 method for class 'predict.BmaSamples'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BmaSamples_+3A_object">object</code></td>
<td>
<p>valid <code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr>
<tr><td><code id="predict.BmaSamples_+3A_level">level</code></td>
<td>
<p>credible level for the credible intervals (default:
95%)</p>
</td></tr>
<tr><td><code id="predict.BmaSamples_+3A_hpd">hpd</code></td>
<td>
<p>should emprical hpd intervals be used (default) or simple
quantile-based?</p>
</td></tr>   
<tr><td><code id="predict.BmaSamples_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="predict.BmaSamples_+3A_x">x</code></td>
<td>
<p>object of S3 class <code><a href="#topic+predict.BmaSamples">predict.BmaSamples</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function summarizes the predictive samples saved in the
<code><a href="#topic+BmaSamples">BmaSamples</a></code> object. Using these functions, one can obtain
predictive credible intervals, as opposed to just using the function
<code><a href="#topic+bmaPredict">bmaPredict</a></code>, which only gives the means of the predictive
distributions.
</p>


<h3>Value</h3>

<p>A list of class <code>predict.BmaSamples</code>, which has then a separate
print method. The elements of the list are:
</p>
<table>
<tr><td><code>intervalType</code></td>
<td>
<p>which credible intervals have been computed
(either &ldquo;HPD&rdquo; or &ldquo;equitailed&rdquo;)</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the credible level</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>the covariate data for the predicted data points (just
copied from <code>object</code>)</p>
</td></tr>
<tr><td><code>sampleSize</code></td>
<td>
<p>the sample size (just copied from <code>object</code>)</p>
</td></tr>
<tr><td><code>nModels</code></td>
<td>
<p>the number of models (just copied from <code>object</code>)</p>
</td></tr>
<tr><td><code>summaryMat</code></td>
<td>
<p>the summary matrix for the predictions, with median,
mean, lower and upper credible interval borders.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmaPredict">bmaPredict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BmaSamples object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## predict new responses at (again random) covariates with BMA:
testBma &lt;- BmaSamples(test,
                      newdata=data.frame(x1 = rnorm (15),
                                         x2 = rbinom (n=15, size=5, prob=0.2) + 1,
                                         x3 = rexp (15)))
predict(testBma)
</code></pre>

<hr>
<h2 id='rmvt'>Multivariate Student Random Deviates</h2><span id='topic+rmvt'></span>

<h3>Description</h3>

<p>This function provides a random vector generator for the multivariate
Student distribution with mean vector <code>mean</code>, scale matrix
<code>sigma</code> and degrees of freedom <code>df</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvt(n, sigma = diag(2), mu = rep(0, 2), df = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvt_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_sigma">sigma</code></td>
<td>
<p>symmetric and positive definite scale matrix</p>
</td></tr>
<tr><td><code id="rmvt_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="rmvt_+3A_df">df</code></td>
<td>
<p>degree of freedom as integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector samples, stacked in the rows of a matrix.
</p>


<h3>Note</h3>

<p>Note that the covariance matrix is only defined for <code>df &gt; 2</code>, and
is given by <code>sigma * df / (df - 2)</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## samples from the multivariate Cauchy distribution:
bfp:::rmvt(20)

## here the covariance exists:
sigma &lt;- matrix(c(1, 0.5, 0.5, 1), nrow=2)
df &lt;- 10

## theoretical covariance:
sigma * df / (df - 2)

## this should be close:
cov(bfp:::rmvt(n=100000, sigma=sigma, df=df))
</code></pre>

<hr>
<h2 id='rshrinkage'>Sample from the model-specific posterior of the shrinkage factor t = g / (1 + g)</h2><span id='topic+rshrinkage'></span>

<h3>Description</h3>

<p>Sample from the model-specific posterior of the shrinkage factor t = g
/ (1 + g), using inverse sampling. This function is internal only
because the arguments are not very user-friendly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rshrinkage(n=1, R2, nObs, p, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rshrinkage_+3A_n">n</code></td>
<td>
<p>number of samples (default: 1)</p>
</td></tr>
<tr><td><code id="rshrinkage_+3A_r2">R2</code></td>
<td>
<p>coefficient of determination in the model</p>
</td></tr>
<tr><td><code id="rshrinkage_+3A_nobs">nObs</code></td>
<td>
<p>number of observations used to fit the model</p>
</td></tr>
<tr><td><code id="rshrinkage_+3A_p">p</code></td>
<td>
<p>number of design matrix columns without counting the
intercept</p>
</td></tr>
<tr><td><code id="rshrinkage_+3A_alpha">alpha</code></td>
<td>
<p>used hyperparameter for hyper-g prior</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>n</code> posterior shrinkage factor samples
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a BayesMfp object
set.seed(29)
nObs &lt;- 15

x1 &lt;- rnorm (n=nObs)
x2 &lt;- rbinom (n=nObs, size=20, prob=0.5) 
x3 &lt;- rexp (n=nObs)

y &lt;- rt (n=nObs, df=2)

test &lt;- BayesMfp (y ~ bfp (x2, max = 3) + bfp(x3, max=3), nModels = 200, method="exhaustive")

## get the best found model
map &lt;- test[[1]]

## produce many samples from the shrinkage factor
samples &lt;- bfp:::rshrinkage(n=1e+5,
			    R2=map$R2,
		            nObs=nObs,
			    p=length(unlist(map$powers)),
			    alpha=4)
hist(samples,
     nclass=50, prob=TRUE)

## compare the mean with the analytical mean
abline(v=c(sampled &lt;- mean(samples),
	   true &lt;- map$postExpectedShrinkage),
       col=c(1, 2))
stopifnot(abs(sampled - true) &lt; 0.0001)
</code></pre>

<hr>
<h2 id='scrBesag'>Simultaneous credible band computation (Besag, Green et al algorithm)</h2><span id='topic+scrBesag'></span>

<h3>Description</h3>

<p>Simultaneous credible band computation</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrBesag(samples, level=0.95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scrBesag_+3A_samples">samples</code></td>
<td>
<p>m by n matrix where m is the number of parameters,
n is the number of samples and  hence each (multivariate) sample is a column
in the matrix <code>samples</code></p>
</td></tr>
<tr><td><code id="scrBesag_+3A_level">level</code></td>
<td>
<p>the credible level (default: 0.95)</p>
</td></tr></table>


<h3>Details</h3>

<p>Calculates a series of simultaneous credible bounds for one parameter type, following section 6.3 in the seminal paper &quot;Bayesian computation and stochastic systems&quot;. The corresponding algorithm was invented by Peter Green.</p>


<h3>Value</h3>

<p>matrix with &lsquo;lower&rsquo; and &lsquo;upper&rsquo; rows</p>


<h3>Author(s)</h3>

<p>Thomas Kneib</p>


<h3>References</h3>

<p>J. Besag, P. Green, D. Higdon, K. Mengersen (1995):
Bayesian computation and stochastic systems,
<em>Statistical Science</em> <b>10</b>/1, 3&ndash;41</p>

<hr>
<h2 id='scrHpd'>Calculate an SCB from a samples matrix</h2><span id='topic+scrHpd'></span>

<h3>Description</h3>

<p>Calculate an SCB from a samples matrix, which minimizes
the absolute distances of the contained samples to a mode vector, at
each gridpoint. Therefore the SCB might be considered an &ldquo;HPD
SCB&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrHpd(samples, mode = apply(samples, 2, median), level = 0.95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scrHpd_+3A_samples">samples</code></td>
<td>
<p>m by n matrix where m is the number of samples and n
the number of parameters, hence each (multivariate) sample is a row in
the matrix <code>samples</code></p>
</td></tr> 
<tr><td><code id="scrHpd_+3A_mode">mode</code></td>
<td>
<p>mode vector of length n (defaults to the vector of medians)</p>
</td></tr>
<tr><td><code id="scrHpd_+3A_level">level</code></td>
<td>
<p>credible level for the SCB (default: 0.95)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first computes the matrix of absolute distances of the
samples to the mode vector. Then based on this distance matrix, a
one-sided SCB as described in Besag et al. (1995) is computed, which
is then mapped back to the samples.
</p>


<h3>Value</h3>

<p>A matrix with rows &ldquo;lower&rdquo; and &ldquo;upper&rdquo;, with the lower
and upper SCB bounds.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>References</h3>

<p>Besag, J.; Green, P.; Higdon, D. and Mengersen, K. (1995):
&ldquo;Bayesian computation and stochastic systems (with
discussion)&rdquo;, <em>Statistical Science</em>, 10, 3-66.</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalHpd">empiricalHpd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create some samples
time &lt;- 1:10
nSamples &lt;- 50
samples &lt;- t(replicate(nSamples,
                       time * rnorm(1) + rexp(1))) +
           rnorm(length(time) * nSamples)
matplot(time, t(samples), type="l", lty=1, col=1,
        xlab="time", ylab="response")

## now test the function: 50% credible band
scb &lt;- scrHpd(samples, level=0.5)
matlines(time, t(scb), col=2, lwd=2, lty=1)
</code></pre>

<hr>
<h2 id='Summary+20of+20BayesMfp+20object'>Calculate and print the summary of a BayesMfp object</h2><span id='topic+print.summary.BayesMfp'></span><span id='topic+summary.BayesMfp'></span>

<h3>Description</h3>

<p>Calculate and print the summary of a <code><a href="#topic+BayesMfp">BayesMfp</a></code> object,
using S3 methods for the class. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesMfp'
summary(object, level=0.95, table=TRUE,
                           shrinkage=NULL, ...)
## S3 method for class 'summary.BayesMfp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_object">object</code></td>
<td>
<p>a valid <code><a href="#topic+BayesMfp">BayesMfp</a></code> object</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_x">x</code></td>
<td>
<p>a return value of <code><a href="#topic+summary.BayesMfp">summary.BayesMfp</a></code></p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_level">level</code></td>
<td>
<p>credible level for coefficients HPD intervals (default: 0.95)</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_table">table</code></td>
<td>
<p>should a data.frame of the models be included? (default)</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_shrinkage">shrinkage</code></td>
<td>
<p>shrinkage factor used, where <code>NULL</code> defaults to
the posterior expected shrinkage factor</p>
</td></tr> 
<tr><td><code id="Summary+2B20of+2B20BayesMfp+2B20object_+3A_...">...</code></td>
<td>
<p>only used by <code><a href="#topic+summary.BayesMfp">summary.BayesMfp</a></code> to pass
arguments to <code><a href="#topic+as.data.frame.BayesMfp">as.data.frame.BayesMfp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+summary.BayesMfp">summary.BayesMfp</a></code> returns a list with S3 class
<code>summary.BayesMfp</code>, where the arguments &ldquo;call&rdquo;,
&ldquo;numVisited&rdquo;, &ldquo;termNames&rdquo;, 
&ldquo;shiftScaleMax&rdquo;, &ldquo;inclusionProbs&rdquo;, &ldquo;chainlength&rdquo;
(only for model sampling results) are copied from the attributes of
the <code><a href="#topic+BayesMfp">BayesMfp</a></code> object, please see its help page for
details.  
</p>
<p>The other elements are:
</p>
<table>
<tr><td><code>dataframe</code></td>
<td>
<p>the model overview as data.frame (only if
<code>table=TRUE</code> was specified)</p>
</td></tr>
<tr><td><code>localInclusionProbs</code></td>
<td>
<p>local variable inclusion probability
estimates</p>
</td></tr>
<tr><td><code>nModels</code></td>
<td>
<p>number of models contained in <code>object</code></p>
</td></tr>
</table>
<p>If there are multiple models in <code>object</code>, the list element
<code>postProbs</code> contains the exact (for exhaustively explored model
spaces) or estimated (if model sampling has been done) posterior model
probabilities.
</p>
<p>If <code>object</code> contains only one FP model, then this one is
summarized in more detail:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>used credible level for coefficients HPD intervals</p>
</td></tr>
<tr><td><code>shrinkage</code></td>
<td>
<p>used shrinkage factor</p>
</td></tr>
<tr><td><code>summaryMat</code></td>
<td>
<p>matrix with posterior summaries of the single
coefficients: &ldquo;mode&rdquo; gives the posterior mode,
&ldquo;HPDlower&rdquo; and &ldquo;HPDupper&rdquo; give the boundaries of the HPD
intervals with specified credible <code>level</code></p>
</td></tr>
<tr><td><code>sigma2Sum</code></td>
<td>
<p>posterior summary for the regression variance: again
mode, and lower and upper HPD bounds are given in a rowvector.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that if you extract the summary of a single model with these
functions, you ignore the uncertainty about the shrinkage factor
t=g/(g+1) by plugging in the number <code>shrinkage</code>. If you want to
incorporate this uncertainty, you must run <code><a href="#topic+BmaSamples">BmaSamples</a></code> on
this model and call the corresponding method
<code><a href="#topic+summary.BmaSamples">summary.BmaSamples</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BmaSamples">summary.BmaSamples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BayesMfp object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

## summary of multiple models:
summary(test)

## summary of just one model (no. 10):
summary(test[10])

## internal structure is usually not interesting:
str(summary(test[10]))
</code></pre>

<hr>
<h2 id='Summary+20of+20BmaSamples+20object'>Calculate and print the summary of a BmaSamples object</h2><span id='topic+print.summary.BmaSamples'></span><span id='topic+summary.BmaSamples'></span>

<h3>Description</h3>

<p>Calculate and print the summary of a <code><a href="#topic+BmaSamples">BmaSamples</a></code> object,
using S3 methods for the class. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BmaSamples'
summary(object, level = 0.95, hpd = TRUE, ...)
## S3 method for class 'summary.BmaSamples'
print(x, table = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_object">object</code></td>
<td>
<p>a valid <code><a href="#topic+BmaSamples">BmaSamples</a></code> object</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_level">level</code></td>
<td>
<p>credible level for coefficients credible intervals</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_hpd">hpd</code></td>
<td>
<p>should emprical hpd intervals be used (default) or simple quantile-based?</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_x">x</code></td>
<td>
<p>a return value of <code><a href="#topic+summary.BmaSamples">summary.BmaSamples</a></code></p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_table">table</code></td>
<td>
<p>should the model table been shown? (default)</p>
</td></tr>
<tr><td><code id="Summary+2B20of+2B20BmaSamples+2B20object_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary method returns an S3 object, where &ldquo;sampleSize&rdquo;,
&ldquo;modelData&rdquo; and &ldquo;modelFreqs&rdquo; are copied from the
<code><a href="#topic+BmaSamples">BmaSamples</a></code> object, please see its help page for the
details. &ldquo;intervalType&rdquo; and &ldquo;level&rdquo; copy the function's
parameters. 
</p>
<p>&ldquo;summaryMat&rdquo; contains the posterior summaries for the intercept
and uncertain fixed form covariates. &ldquo;sigma2Sum&rdquo; and
&ldquo;shrinkageSum&rdquo; contain the posterior summaries for the
regression variance and the shrinkage factor, respectively. The
summaries are always the median, mean, lower and upper credible
bounds for the coefficients.
</p>


<h3>Author(s)</h3>

<p>Daniel Saban\'es Bov\'e</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BayesMfp">summary.BayesMfp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a BmaSamples object
set.seed(19)

x1 &lt;- rnorm(n=15)
x2 &lt;- rbinom(n=15, size=20, prob=0.5) 
x3 &lt;- rexp(n=15)

y &lt;- rt(n=15, df=2)

test &lt;- BayesMfp(y ~ bfp (x2, max = 4) + uc (x1 + x3), nModels = 100,
                 method="exhaustive")

testBma &lt;- BmaSamples(test)

## look at the summary
summary(testBma)

## and its structure
str(summary(testBma))
</code></pre>

<hr>
<h2 id='transformMfp'>Transform a fitted mfp model into a BayesMfp model</h2><span id='topic+transformMfp'></span>

<h3>Description</h3>

<p>Transform a fitted mfp model into a BayesMfp model with the correct powers etc.
to compare with other (true) BayesMfp models fitted to the same (!) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformMfp(mfpObject, BayesMfpObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformMfp_+3A_mfpobject">mfpObject</code></td>
<td>
<p>the original mfp object</p>
</td></tr>
<tr><td><code id="transformMfp_+3A_bayesmfpobject">BayesMfpObject</code></td>
<td>
<p>BayesMfp object, from which the first model is
used for imputation of the powers from mfpObject</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A BayesMfp object with the converted model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
