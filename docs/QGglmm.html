<!DOCTYPE html><html><head><title>Help for package QGglmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QGglmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#QGglmm-package'>
<p>Estimate Quantitative Genetics Parameters from Generalised Linear Mixed Models</p></a></li>
<li><a href='#QGicc'>
<p>Intra - Class Correlation coefficients (ICC) on the observed data scale</p></a></li>
<li><a href='#QGlink.funcs'><p>List of functions according to a distribution and a link function</p></a></li>
<li><a href='#QGmean'><p>Compute the phenotypic mean on the observed scale</p></a></li>
<li><a href='#QGmvicc'>
<p>Intra - Class Correlation coefficients (ICC) on the observed data scale (multivariate analysis).</p></a></li>
<li><a href='#QGmvmean'><p>Compute the multivariate phenotypic mean on the observed scale</p></a></li>
<li><a href='#QGmvparams'>
<p>Quantitative Genetics parameters from GLMM estimates (multivariate analysis).</p></a></li>
<li><a href='#QGmvpred'><p>Predict the evolutionary response to selection on the observed scale</p></a></li>
<li><a href='#QGmvpsi'><p>Compute a multivariate &quot;Psi&quot; (used to compute the additive genetic variance on the observed scale).</p></a></li>
<li><a href='#QGparams'>
<p>Quantitative Genetics parameters from GLMM estimates.</p></a></li>
<li><a href='#QGpred'><p>Predict the evolutionary response to selection on the observed scale</p></a></li>
<li><a href='#QGpsi'><p>Compute &quot;Psi&quot; (used to compute the additive genetic variance on the observed scale).</p></a></li>
<li><a href='#QGvar.dist'><p>Compute the distribution variance</p></a></li>
<li><a href='#QGvar.exp'><p>Compute the variance of expected values (i.e. the latent values after inverse-link transformation.)</p></a></li>
<li><a href='#QGvcov'><p>Compute the phenotypic variance-covariance matrix on the observed / expected scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Quantitative Genetics Parameters from Generalised
Linear Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/devillemereuil/qgglmm/issues">https://github.com/devillemereuil/qgglmm/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Compute various quantitative genetics parameters from a Generalised Linear Mixed Model (GLMM) estimates. Especially, it yields the observed phenotypic mean, phenotypic variance and additive genetic variance.</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubature (&ge; 1.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-03 12:48:35 UTC; flyos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-07 16:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='QGglmm-package'>
Estimate Quantitative Genetics Parameters from Generalised Linear Mixed Models
</h2><span id='topic+QGglmm-package'></span><span id='topic+QGglmm'></span>

<h3>Description</h3>

<p>Compute various quantitative genetics parameters from a Generalised Linear Mixed Model (GLMM) estimates. Especially, it yields the observed phenotypic mean, phenotypic variance and additive genetic variance.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> QGglmm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Estimate Quantitative Genetics Parameters from Generalised Linear Mixed Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.7.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-01-03</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/devillemereuil/qgglmm/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Compute various quantitative genetics parameters from a Generalised Linear Mixed Model (GLMM) estimates. Especially, it yields the observed phenotypic mean, phenotypic variance and additive genetic variance.</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> cubature (&gt;= 1.4)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
QGglmm-package          Estimate Quantitative Genetics Parameters from
                        Generalised Linear Mixed Models
QGicc                   Intra - Class Correlation coefficients (ICC) on
                        the observed data scale
QGlink.funcs            List of functions according to a distribution
                        and a link function
QGmean                  Compute the phenotypic mean on the observed
                        scale
QGmvicc                 Intra - Class Correlation coefficients (ICC) on
                        the observed data scale (multivariate
                        analysis).
QGmvmean                Compute the multivariate phenotypic mean on the
                        observed scale
QGmvparams              Quantitative Genetics parameters from GLMM
                        estimates (multivariate analysis).
QGmvpred                Predict the evolutionary response to selection
                        on the observed scale
QGmvpsi                 Compute a multivariate "Psi" (used to compute
                        the additive genetic variance on the observed
                        scale).
QGparams                Quantitative Genetics parameters from GLMM
                        estimates.
QGpred                  Predict the evolutionary response to selection
                        on the observed scale
QGpsi                   Compute "Psi" (used to compute the additive
                        genetic variance on the observed scale).
QGvar.dist              Compute the distribution variance
QGvar.exp               Compute the variance of expected values (i.e.
                        the latent values after inverse-link
                        transformation.)
QGvcov                  Compute the phenotypic variance-covariance
                        matrix on the observed / expected scale
</pre>
<p>This package gives the values on the observed scale for several quantitative genetics parameter using estimates from a Generalised Linear Mixed Model (GLMM). If a fitness function is assumed or measured, it also predicts the evolutionary response to selection on the observed scale.
</p>
<p>The two main functions of this package are <code><a href="#topic+QGparams">QGparams</a></code> and <code><a href="#topic+QGpred">QGpred</a></code>. The first allows to compute the quantitative genetics parameters on the observed scale for any given GLMM and its estimates. The second allows to compute a predicted response to evolution on the observed scale using GLMM estimates and an assumed/measured/inferred fitness function.
</p>
<p>For some distribution/link models (e.g. Binomial/probit and Poisson and Negative Binomial with logartihm or square-root link), a closed form solutions of the integrals computed by this package are available. They are automatially used by <code><a href="#topic+QGparams">QGparams</a></code> and this function only.
</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;
</p>
<p>Maintainer: Pierre de Villemereuil &lt;bonamy@horus.ens.fr&gt;
</p>


<h3>References</h3>

<p>de Villemereuil, P., Schielzeth, H., Nakagawa, S., and Morrissey, M.B. (2016). General methods for evolutionary quantitative genetic inference from generalised mixed models. Genetics 204, 1281-1294.
</p>

<hr>
<h2 id='QGicc'>
Intra - Class Correlation coefficients (ICC) on the observed data scale
</h2><span id='topic+QGicc'></span>

<h3>Description</h3>

<p>Function to estimate the Intra - Class Correlation coefficients (ICC, a.k.a. repeatability - like estimates) on the observed scale based on estimates on the latent scale. For a specific variance component, the function yields a data.frame which includes the phenotypic mean and variance, as well as the variance component and associated ICC, on the observed data scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGicc(mu = NULL, var.comp, var.p, model = "", width = 10, predict = NULL,
    closed.form = TRUE, custom.model = NULL, n.obs = NULL, theta = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGicc_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_var.comp">var.comp</code></td>
<td>
<p>Latent variance component for which ICC needs to be computed, estimated from a GLMM. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_var.p">var.p</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_model">model</code></td>
<td>
<p>Name of the used model, i.e. distribution.link. Ignored if <code>custom.model</code> is not NULL. (character) Available models are :
</p>

<ul>
<li><p>&quot;Gaussian&quot; Gaussian distribution with identity link (e.g. LMM)
</p>
</li>
<li><p>&quot;binom1.probit&quot; Binomial with 1 trial (binary data) with a probit link
</p>
</li>
<li><p>&quot;binomN.probit&quot; Binomial with N tria with a probit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;binom1.logit&quot; Binomial with 1 trial (binary) with a logit link
</p>
</li>
<li><p>&quot;binomN.logit&quot; Binomial with N trial with a logit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;Poisson.log&quot; Poisson distribution wiht a log link
</p>
</li>
<li><p>&quot;Poisson.sqrt&quot; Poisson distribution with a square - root link
</p>
</li>
<li><p>&quot;negbin.log&quot; Negative - Binomial distribution wiht a log link (require the parameter <code>theta</code>)
</p>
</li>
<li><p>&quot;negbin.sqrt&quot; Negative - Binomial distribution with a square - root link (require the parameter <code>theta</code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="QGicc_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from -<code>width * sqrt(var.comp)</code> to <code>width * sqrt(var.comp)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_closed.form">closed.form</code></td>
<td>
<p>When available, should closed forms be used instead of integral computations? (boolean)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_custom.model">custom.model</code></td>
<td>
<p>If the model used is not available using the <code>model</code> argument, a list of functions describing the model can be provided. (list of functions, see Details)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of &quot;trials&quot; for the &quot;binomN&quot; distribution. (numeric)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_theta">theta</code></td>
<td>
<p>Dispersion parameter for the Negative Binomial distribution. The parameter <code>theta</code> should be such as the variance of the distribution is <code>mean + mean^2 / theta</code>. (numeric)</p>
</td></tr>
<tr><td><code id="QGicc_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function typically uses precise integral numerical approximation to compute parameters on the observed scale, from latent estimates yielded by a GLMM. If closed form solutions for the integrals are available, it uses them if <code>closed.form = TRUE</code>.
</p>
<p>Only the most typical distribution/link function couples are implemented in the function. If you used an &quot;exotic&quot; GLMM, you can use the <code>custom.model</code> argument. It should take the form of a list of functions. The first function should be the inverse of the link function named <code>inv.link</code>, the second function should be the &quot;distribution variance&quot; function named <code>var.func</code> and the third function should be the derivative of the inverse link function named <code>d.inv.link</code> (see Example below).
</p>
<p>Some distributions require extra-arguments. This is the case for &quot;binomN&quot;, which require the number of trials N, passed with the argument <code>n.obs</code>. The distribution &quot;negbin&quot; requires a dispersion parameter <code>theta</code>, such as the variance of the distribution is <code>mean + mean^2 / theta</code> (mean/dispersion parametrisation).
</p>
<p>If fixed effects (apart from the intercept) have been included in the GLMM, they can be included as marginal predicted values, i.e. predicted values excluding the random effects, which can be calculated as the matrix product <strong>Xb</strong> where <strong>X</strong> is the design matrix and <strong>b</strong> is the vector of fixed effects estimates. To do so, provide the vector of marginal predicted values using the argument <code>predict</code>. Note this can considerably slow down the algorithm, especially when no closed form is used.
</p>


<h3>Value</h3>

<p>The function yields a data.frame containing the following values:
</p>
<table>
<tr><td><code>mean.obs</code></td>
<td>
<p>Phenotypic mean on the observed scale.</p>
</td></tr>
<tr><td><code>var.obs</code></td>
<td>
<p>Phenotypic variance on the observed scale.</p>
</td></tr>
<tr><td><code>var.comp.obs</code></td>
<td>
<p>Component variance on the observed scale.</p>
</td></tr>
<tr><td><code>icc.obs</code></td>
<td>
<p>ICC on the observed scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using Poisson count data
# Parameters
mu &lt;- 0
va &lt;- 0.5
vm &lt;- 0.2  # Maternal effect
vp &lt;- 1

# Simulating data l = mu + a + e
lat &lt;- mu + 
       rnorm(1000, 0, sqrt(va)) + 
       rnorm(1000, 0, sqrt(vm)) +
       rnorm(1000, 0, sqrt(vp - (va + vm)))
y   &lt;- rpois(1000, exp(lat))

# Computing the broad - sense heritability
QGicc(mu = mu, var.p = vp, var.comp = va, model = "Poisson.log")
# Computing the maternal effect ICC
QGicc(mu = mu, var.p = vp, var.comp = vm, model = "Poisson.log")

# Using integral computation
QGicc(mu = mu, var.p = vp, var.comp = vm, model = "Poisson.log", closed.form = FALSE)
# Note that the "approximation" is exactly equal to the results obtained with the closed form

# Let's create a custom model
custom &lt;- list(inv.link = function(x){exp(x)},
    var.func = function(x){exp(x)},
    d.inv.link = function(x){exp(x)})
    
QGicc(mu = mu, var.p = vp, var.comp = vm, custom.model = custom)
# Again, exactly equal

# Integrating over a posterior distribution
# e.g. output from MCMCglmm named "model"
# df &lt;- data.frame(mu = model$Sol[, 'intercept'], 
#                  vm = model$VCV[, 'mother'], 
#                  vp = rowSums(model$VCV))
# params &lt;- apply(df, 1, function(row){
#        QGicc(mu = row$mu, var.comp = row$vm, var.p = row$vp, model = "Poisson.log")
# })
</code></pre>

<hr>
<h2 id='QGlink.funcs'>List of functions according to a distribution and a link function</h2><span id='topic+QGlink.funcs'></span>

<h3>Description</h3>

<p>Function yielding different functions (inverse-link, variance function, derivative of the inverse-link) according to a distribution and link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGlink.funcs(name, n.obs = NULL, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGlink.funcs_+3A_name">name</code></td>
<td>
<p>Name of the distribution.link couple. See <code><a href="#topic+QGparams">QGparams</a></code> for a complete list of model available. (character)</p>
</td></tr>
<tr><td><code id="QGlink.funcs_+3A_n.obs">n.obs</code></td>
<td>
<p>Optional parameter required for &quot;binomN&quot; distributions (number of &quot;trials&quot;). See <code><a href="#topic+QGparams">QGparams</a></code>. (numeric)</p>
</td></tr>
<tr><td><code id="QGlink.funcs_+3A_theta">theta</code></td>
<td>
<p>Optional parameter required for &quot;negbin&quot; distributions (dispersion parameter). See <code><a href="#topic+QGparams">QGparams</a></code>. (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the name of a distribution.link couple and yields several important functions such as the inverse-link function and its derivative, as well as the &quot;distribution variance function&quot;.
</p>
<p>The inverse-link function is the inverse function of the link function. For example, if the link function is the natural logarithm (typically for a Poisson distribution), then the inverse-link function is the exponential.
</p>
<p>The distribution variance function is a function yielding the variance of the distribution for a given latent trait. For a Poisson distribution, the variance is equal to the mean, hence the variance function is equal to the inverse-link function. For a binomial distribution, the variance is N * p(l) * (1 - p(l)), where p is the inverse-link function.
</p>
<p>For some distributions, such as &quot;binomN&quot; and &quot;negbin&quot;, some extra-parameters are required.
</p>


<h3>Value</h3>

<p>This function yields a list of function:
</p>

<ul>
<li><p><code>inv.link</code>Inverse function of the link function. (function)
</p>
</li>
<li><p><code>var.func</code>Distribution variance function. (function)
</p>
</li>
<li><p><code>inv.link</code>Derivative of the inverse-link function. (function)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGmvparams">QGmvparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Getting the functions for a Poisson.log model
QGlink.funcs("Poisson.log")
# Note that because the variance is equal to the mean in a Poisson distribution
# and the derivative of exp is exp
# all functions are the same!

## Getting the functions for a binom1.probit model
QGlink.funcs("binom1.probit")

## The function QGparams automatically computes these functions
QGparams(mu = 0, var.p = 2, var.a = 1, model = "binom1.logit")
# Hence this is the same as using the custom.model argument with QGlink.funcs
QGparams(mu = 0, var.p = 2, var.a = 1, custom.model = QGlink.funcs("binom1.logit"))

## We can create our own custom set of functions
# Let's create a custom model exactly identical to QGlink.funcs("binom1.logit")
custom &lt;- list(inv.link = function(x){plogis(x)},
               var.func = function(x){plogis(x) * (1 - plogis(x))},
               d.inv.link = function(x){dlogis(x)})
    
QGparams(mu = 0, var.p = 2, var.a = 1, custom.model = custom)
</code></pre>

<hr>
<h2 id='QGmean'>Compute the phenotypic mean on the observed scale</h2><span id='topic+QGmean'></span>

<h3>Description</h3>

<p>This function calculates the phenotypic mean on the observed scale from the latent mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGmean(mu = NULL, var, link.inv, predict = NULL, width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmean_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGmean_+3A_var">var</code></td>
<td>
<p>Latent total variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGmean_+3A_link.inv">link.inv</code></td>
<td>
<p>Inverse function of the link function. (function)</p>
</td></tr>
<tr><td><code id="QGmean_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmean_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var)</code> to <code>mu</code> + <code>width * sqrt(var)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs the latent population mean (<code>mu</code>) or the marginal predicted values (<code>predict</code>) and the total latent variance (i.e. total latent variance <code>var</code>) to compute the observed phenotypic mean. To do so, it also requires the inverse function of the link function.
</p>
<p>For example, if the link function is the natural logarithm, the inverse-link function will be the exponential. The inverse-link functions for many models are yielded by the <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code> function.
</p>
<p>Contrary to <code><a href="#topic+QGparams">QGparams</a></code>, <code>QGmean.obs</code> never uses the closed form solutions, but always compute the integrals.
</p>


<h3>Value</h3>

<p>This function yields the phenotypic mean on the observed scale. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGmvmean">QGmvmean</a></code>, <code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Computing the observed mean for a probit link
QGmean(mu = 0.3, var = 1, link.inv = pnorm)
# The theoretical expectation is
1 - pnorm(0, 0.3, sqrt(1 + 1))

# Or, using the QGlink.funcs function
QGmean(mu = 0.3, var = 1, link.inv = QGlink.funcs(name = "binom1.probit")$inv.link)

## Computing the observed mean for a logarithm link
QGmean(mu = 1, var = 1, link.inv = exp)
# The theoretical expectation is
exp(1 + 0.5 * 1)

# This computation is automatically performed by QGparams
# but directly using the closed form solution when available
QGparams(mu = 1, var.p = 1, var.a = 0.5, model = "Poisson.log")

</code></pre>

<hr>
<h2 id='QGmvicc'>
Intra - Class Correlation coefficients (ICC) on the observed data scale (multivariate analysis).
</h2><span id='topic+QGmvicc'></span>

<h3>Description</h3>

<p>Function to estimate the variance-covariance matrix of a variance component on the observed scale based on estimates on the latent scale. Contrary to the univariate function, this one cannot use the analytical closed forms and yields a list of paramaters instead of a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGmvicc(mu = NULL, vcv.comp, vcv.P, models, predict = NULL, rel.acc = 0.001, 
    width = 10, n.obs = NULL, theta = NULL, verbose = TRUE, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmvicc_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_vcv.comp">vcv.comp</code></td>
<td>
<p>Component variance-covariance matrix (G-matrix - like). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_vcv.p">vcv.P</code></td>
<td>
<p>Total phenotypic variance-covariance matrix. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_models">models</code></td>
<td>
<p>A vector containing the names of the model used or a list which elements contain the list of the functions needed (inverse-link, distribution variance and derivative of the inverse-link, as stated in the output of <code>QGlink.funcs()</code>). (character vector or list of lists of functions) Available model names are :
</p>

<ul>
<li><p>&quot;Gaussian&quot; Gaussian distribution with identity link (e.g. LMM)
</p>
</li>
<li><p>&quot;binom1.probit&quot; Binomial with 1 trial (binary data) with a probit link
</p>
</li>
<li><p>&quot;binomN.probit&quot; Binomial with N tria with a probit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;binom1.logit&quot; Binomial with 1 trial (binary) with a logit link
</p>
</li>
<li><p>&quot;binomN.logit&quot; Binomial with N trial with a logit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;Poisson.log&quot; Poisson distribution wiht a log link
</p>
</li>
<li><p>&quot;Poisson.sqrt&quot; Poisson distribution with a square - root link
</p>
</li>
<li><p>&quot;negbin.log&quot; Negative - Binomial distribution wiht a log link (require the parameter <code>theta</code>)
</p>
</li>
<li><p>&quot;negbin.sqrt&quot; Negative - Binomial distribution with a square - root link (require the parameter <code>theta</code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="QGmvicc_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of &quot;trials&quot; for each &quot;binomN&quot; distribution. (numeric, length equal to the number of &quot;binomN&quot; models)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_theta">theta</code></td>
<td>
<p>Dispersion parameter for the Negative Binomial distribution. The parameter <code>theta</code> should be such as the variance of the distribution is <code>mean + mean^2 / theta</code>. (numeric, length equal to the number of &quot;negbin&quot; models)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
<tr><td><code id="QGmvicc_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function typically uses integral numerical approximation provided by the R2Cuba package to compute multivariate quantitative genetics parameters on the observed scale, from latent estimates yielded by a GLMM. It cannot use closed form solutions.
</p>
<p>Only the most typical distribution/link function couples are implemented through the <code>models</code> argument. If you used an &quot;exotic&quot; GLMM, you can provide a list containg lists of functions corresponding to the model. The list of functions should be implemented as is the output of <code>QGlink.funcs()</code>, i.e. three elements: the inverse link functions named <code>inv.link</code>, the derivative of this function named <code>d.inv.link</code> and the distribution variance named <code>var.func</code> (see Example below).
</p>
<p>Some distributions require extra-arguments. This is the case for &quot;binomN&quot;, which require the number of trials N, passed with the argument <code>n.obs</code>. The distribution &quot;negbin&quot; requires a dispersion parameter <code>theta</code>, such as the variance of the distribution is <code>mean + mean^2 / theta</code> (mean/dispersion parametrisation). For now, the arguments <code>n.obs</code> and <code>theta</code> can be used for ONE distribution only.
</p>
<p>If fixed effects (apart from the intercept) have been included in the GLMM, they can be included through the argument <code>predict</code> as a matrix of the marginal predicted values, i.e. predicted values excluding the random effects, for each trait (one trait per column of the matrix, see Example below).Note that computation can be extremely slow in that case.
</p>


<h3>Value</h3>

<p>The function yields a list containing the following values:
</p>
<table>
<tr><td><code>mean.obs</code></td>
<td>
<p>Vector of phenotypic means on the observed scale.</p>
</td></tr>
<tr><td><code>vcv.P.obs</code></td>
<td>
<p>Phenotypic variance-covariance matrix on the observed scale.</p>
</td></tr>
<tr><td><code>vcv.comp.obs</code></td>
<td>
<p>Component variance-covariance (G-matrix - like, but broad - sense) on the observed scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGmvparams">QGmvparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmvmean">QGmvmean</a></code>, <code><a href="#topic+QGvcov">QGvcov</a></code>, <code><a href="#topic+QGmvpsi">QGmvpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using a bivariate model (Binary trait/Gaussian trait)
# Parameters
mu &lt;- c(0, 1)
G &lt;- diag(c(0.5, 2))
M &lt;- diag(c(0.2, 1))  # Maternal effect VCV matrix
P &lt;- diag(c(1, 4))

# Broad - sense "G-matrix" on observed data scale
## Not run: QGmvicc(mu = mu, vcv.comp = G, vcv.P = P, models = c("binom1.probit", "Gaussian"))
# Maternal effect VCV matrix on observed data scale
## Not run: QGmvicc(mu = mu, vcv.comp = M, vcv.P = P, models = c("binom1.probit", "Gaussian"))
# Reminder: the results are the same here because we have no correlation between the two traits

# Defining the model "by hand" using the list
list.models = list(
  model1 = list(inv.link = function(x){pnorm(x)},
              d.inv.link = function(x){dnorm(x)},
              var.func = function(x){pnorm(x) * (1 - pnorm(x))}),
  model2 = list(inv.link = function(x){x},
              d.inv.link = function(x){1},
              var.func = function(x){0})
)
# Running the same analysis than above
QGmvicc(mu = mu, vcv.comp = M, vcv.P = P, models = list.models)

# Using predicted values
# Say we have 100  individuals
n &lt;- 100
# Let's simulate predicted values
p &lt;- matrix(c(runif(n), runif(n)), ncol = 2)
# Note that p has as many as columns as we have traits (i.e. two)
# Multivariate analysis with predicted values
## Not run: QGmvicc(predict = p, vcv.comp = M, vcv.P = P, models = c("binom1.probit", "Gaussian"))
# That can be a bit long to run!
</code></pre>

<hr>
<h2 id='QGmvmean'>Compute the multivariate phenotypic mean on the observed scale</h2><span id='topic+QGmvmean'></span>

<h3>Description</h3>

<p>This function calculates the multivariate phenotypic mean on the observed scale from multivariate latent mean and variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGmvmean(mu = NULL, vcov, link.inv, predict = NULL,
         rel.acc = 0.001, width = 10, mask = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmvmean_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_vcov">vcov</code></td>
<td>
<p>Latent total phenotypic variance-covariance matrix estimated from a GLMM. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_link.inv">link.inv</code></td>
<td>
<p>Inverse functions of the link functions. This function should accept a vector and yield a vector of the same length, see Details and Example below. (function)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvmean_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs the multivariate latent population mean (<code>mu</code>) or the marginal predicted values (<code>predict</code>) and the total latent variance-covariance matrix (<code>vcov</code>) to compute the observed phenotypic mean.
</p>
<p>To do so, it also requires the inverse functions of the link functions (<code>link.inv</code>). For an analysis with d traits, the function given to the <code>link.inv</code> argument should use a vector of length d and yield a vector of length d (see Example below).
</p>


<h3>Value</h3>

<p>This function yields the mutlivariate phenotypic mean on the observed scale. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGmvparams">QGmvparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGvcov">QGvcov</a></code>, <code><a href="#topic+QGmvpsi">QGmvpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using a bivariate model (Binary trait/Gaussian trait)
# Parameters
mu &lt;- c(0, 1)
P &lt;- diag(c(1, 4))

# Note: no phenotypic, nor genetic correlations, hence should be equal to univariate case!

# Setting up the link functions
# Note that since the use of "cubature" to compute the integrals,
# the functions must use a matrix as input and yield a matrix as output,
# each row corresponding to a trait
inv.links &lt;- function(mat) {matrix(c(pnorm(mat[1, ]), mat[2, ]), nrow = 2, byrow = TRUE)}
# probit link and identity link respectively

# Computing the multivariate mean on observed scale
QGmvmean(mu = mu, vcov = P, link.inv = inv.links)
QGmean(mu = 0, var = 1, link.inv = pnorm)     # Same result than trait 1!
QGmean(mu = 1, var = 4, link.inv = function(x){x})     # Same result than trait 2!
# Reminder: the results are the same here because we have no correlation between the two traits
</code></pre>

<hr>
<h2 id='QGmvparams'>
Quantitative Genetics parameters from GLMM estimates (multivariate analysis).
</h2><span id='topic+QGmvparams'></span>

<h3>Description</h3>

<p>Function to estimate the multivariate quantitative genetics parameters on the observed scale based on estimates on the latent scale. Contrary to the univariate function, this one cannot use the analytical closed forms and yields a list of paramaters instead of a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGmvparams(mu = NULL, vcv.G, vcv.P, models, predict = NULL, rel.acc = 0.001, 
    width = 10, n.obs = NULL, theta = NULL, verbose = TRUE, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmvparams_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_vcv.g">vcv.G</code></td>
<td>
<p>Genetic additive variance-covariance matrix (a.k.a. G-matrix). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_vcv.p">vcv.P</code></td>
<td>
<p>Total phenotypic variance-covariance matrix. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_models">models</code></td>
<td>
<p>A vector containing the names of the model used or a list which elements contain the list of the functions needed (inverse-link, distribution variance and derivative of the inverse-link, as stated in the output of <code>QGlink.funcs()</code>). (character vector or list of lists of functions) Available model names are :
</p>

<ul>
<li><p>&quot;Gaussian&quot; Gaussian distribution with identity link (e.g. LMM)
</p>
</li>
<li><p>&quot;binom1.probit&quot; Binomial with 1 trial (binary data) with a probit link
</p>
</li>
<li><p>&quot;binomN.probit&quot; Binomial with N tria with a probit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;binom1.logit&quot; Binomial with 1 trial (binary) with a logit link
</p>
</li>
<li><p>&quot;binomN.logit&quot; Binomial with N trial with a logit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;Poisson.log&quot; Poisson distribution wiht a log link
</p>
</li>
<li><p>&quot;Poisson.sqrt&quot; Poisson distribution with a square - root link
</p>
</li>
<li><p>&quot;negbin.log&quot; Negative - Binomial distribution wiht a log link (require the parameter <code>theta</code>)
</p>
</li>
<li><p>&quot;negbin.sqrt&quot; Negative - Binomial distribution with a square - root link (require the parameter <code>theta</code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="QGmvparams_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of &quot;trials&quot; for the &quot;binomN&quot; distribution. (numeric, length equal to the number of &quot;negbin&quot; models)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_theta">theta</code></td>
<td>
<p>Dispersion parameter for the Negative Binomial distribution. The parameter <code>theta</code> should be such as the variance of the distribution is <code>mean + mean^2 / theta</code>. (numeric, length equal to the number of &quot;negbin&quot; models)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
<tr><td><code id="QGmvparams_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function typically uses integral numerical approximation provided by the R2Cuba package to compute multivariate quantitative genetics parameters on the observed scale, from latent estimates yielded by a GLMM. It cannot use closed form solutions.
</p>
<p>Only the most typical distribution/link function couples are implemented through the <code>models</code> argument. If you used an &quot;exotic&quot; GLMM, you can provide a list containg lists of functions corresponding to the model. The list of functions should be implemented as is the output of <code>QGlink.funcs()</code>, i.e. three elements: the inverse link functions named <code>inv.link</code>, the derivative of this function named <code>d.inv.link</code> and the distribution variance named <code>var.func</code> (see Example below).
</p>
<p>Some distributions require extra-arguments. This is the case for &quot;binomN&quot;, which require the number of trials N, passed with the argument <code>n.obs</code>. The distribution &quot;negbin&quot; requires a dispersion parameter <code>theta</code>, such as the variance of the distribution is <code>mean + mean^2 / theta</code> (mean/dispersion parametrisation). For now, the arguments <code>n.obs</code> and <code>theta</code> can be used for ONE distribution only.
</p>
<p>If fixed effects (apart from the intercept) have been included in the GLMM, they can be included through the argument <code>predict</code> as a matrix of the marginal predicted values, i.e. predicted values excluding the random effects, for each trait (one trait per column of the matrix, see Example below).Note this can considerably slow down the algorithm, especially when no closed form is used.
</p>


<h3>Value</h3>

<p>The function yields a list containing the following values:
</p>
<table>
<tr><td><code>mean.obs</code></td>
<td>
<p>Vector of phenotypic means on the observed scale.</p>
</td></tr>
<tr><td><code>vcv.P.obs</code></td>
<td>
<p>Phenotypic variance-covariance matrix on the observed scale.</p>
</td></tr>
<tr><td><code>vcv.G.obs</code></td>
<td>
<p>Additive genetic variance-covariance (a.k.a. G-matrix) on the observed scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmvmean">QGmvmean</a></code>, <code><a href="#topic+QGvcov">QGvcov</a></code>, <code><a href="#topic+QGmvpsi">QGmvpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using a bivariate model (Binary trait/Gaussian trait)
# Parameters
mu &lt;- c(0, 1)
G &lt;- diag(c(0.5, 2))
P &lt;- diag(c(1, 4))

# Note: no phenotypic, nor genetic correlations, hence should be equal to univariate case!

# Multivariate analysis
QGmvparams(mu = mu, vcv.G = G, vcv.P = P, models = c("binom1.probit", "Gaussian"))
QGparams(mu = 0, var.a = 0.5, var.p = 1, model = "binom1.probit") # Consistent results!
# Reminder: the results are the same here because we have no correlation between the two traits

# Defining the model "by hand" using the list
list.models = list(
  model1 = list(inv.link = function(x){pnorm(x)},
                d.inv.link = function(x){dnorm(x)},
                var.func = function(x){pnorm(x) * (1 - pnorm(x))}),
  model2 = list(inv.link = function(x){x},
                d.inv.link = function(x){1},
                var.func = function(x){0})
)
# Running the same analysis than above
QGmvparams(mu = mu, vcv.G = G, vcv.P = P, models = list.models) # Same results!

# Using predicted values
# Say we have 100  individuals
n &lt;- 100
# Let's simulate predicted values
p &lt;- matrix(c(runif(n), runif(n)), ncol = 2)
# Note that p has as many as columns as we have traits (i.e. two)
# Multivariate analysis with predicted values
## Not run: QGmvparams(predict = p, vcv.G = G, vcv.P = P, models = c("binom1.probit", "Gaussian"))
</code></pre>

<hr>
<h2 id='QGmvpred'>Predict the evolutionary response to selection on the observed scale</h2><span id='topic+QGmvpred'></span>

<h3>Description</h3>

<p>This function uses an assumed or measured fitness function to compute evolutionary response to selection on the observed scale. To do so a latent fitness function must be provided to the function. This fitness function is used to compute the evolutionary response on the latent scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGmvpred(mu = NULL, vcv.G, vcv.P, fit.func, d.fit.func, 
             predict = NULL, rel.acc = 0.001, width = 10,
             verbose = TRUE, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmvpred_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_vcv.g">vcv.G</code></td>
<td>
<p>Genetic additive variance-covariance matrix (a.k.a. G-matrix). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_vcv.p">vcv.P</code></td>
<td>
<p>Total phenotypic variance-covariance matrix. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_fit.func">fit.func</code></td>
<td>
<p>Function giving the expected fitness on the observed scale for a given latent trait (see Example). (function)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_d.fit.func">d.fit.func</code></td>
<td>
<p>Derivative of the expected fitness to the latent trait. This function should return a vector containing the partial derivative to each trait (see Example). (function)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
<tr><td><code id="QGmvpred_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the latent fitness function (<code>fitness.func</code>) and latent quantitative genetics parameters to compute the expected selection differential and response on the latent scale.
</p>
<p>There is no argument to describe the model used as it is already and implicitely contained in the calculation of <code>fit.func</code> and <code>d.fit.func</code> (see Example below).
</p>
<p>If fixed effects were included during the estimation of the quantitative genetics parameters, they can be included as marginal predicted values, i.e. predicted values excluding the random effects, which can be calculated as the matrix product <strong>Xb</strong> where <strong>X</strong> is the design matrix and <strong>b</strong> is the vector of fixed effects estimates. To do so, provide the vector of marginal predicted values using the argument <code>predict</code>. Note this will considerably slow down the algorithm.
</p>
<p>The predictions can be transposed on the observed scale by using the <code><a href="#topic+QGmvmean">QGmvmean</a></code> function (see Example below).
</p>


<h3>Value</h3>

<p>The function yields a data.frame containing:
</p>

<ul>
<li><p><code>mean.lat.fitness</code>Average latent fitness. (numeric)
</p>
</li>
<li><p><code>lat.grad</code>Latent selection gradient. (numeric)
</p>
</li>
<li><p><code>lat.sel</code>Latent selection differential. (numeric)
</p>
</li>
<li><p><code>lat.resp</code>Latent evolutionary response to selection. (numeric)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Bivariate example with a binary trait and a Gaussian one

# Assume a bivariate GLMM with Binomial(probit)/Gaussian distributions with:
mu &lt;- c(0, 10)
G &lt;- matrix(c(0.5, 0, 0, 1), nrow = 2)
P &lt;- matrix(c(1, 0, 0, 2), nrow = 2) 

# Link functions
inv.links = function(vec){c(pnorm(vec[1]), vec[2])}

# Creating the expected fitness function
# i.e. expected fitness given a latent trait vector l
# Say if the binary trait is 1, then the fitness is 0.5 * "the Gaussian trait"
# But if the binary trait is 0, then the fitness is 0
lat.fit &lt;- function(mat) {pnorm(mat[1, ]) * 0.5 * mat[2, ]}
# Derivative of the above function
# This function yields a vector which elements are the derivative according to each trait
d.lat.fit &lt;- function(mat) {matrix(c(dnorm(mat[1, ]) * 0.5 * mat[2, ], pnorm(mat[1, ]) * 0.5),
                            nrow = 2, 
                            byrow = TRUE)}

# Predicting the latent evolutionary response
pred&lt;- QGmvpred(mu = mu, vcv.P = P, vcv.G = G, fit.func = lat.fit, d.fit.func = d.lat.fit)


# Predicting the observed evolutionary response
# Current observed phenotypic mean
QGmvmean(mu = mu, vcov = P, link.inv = inv.links)
# Predicted observed phenotypic mean after selection
QGmvmean(mu = mu + pred$lat.resp, vcov = P, link.inv = inv.links)
</code></pre>

<hr>
<h2 id='QGmvpsi'>Compute a multivariate &quot;Psi&quot; (used to compute the additive genetic variance on the observed scale).</h2><span id='topic+QGmvpsi'></span>

<h3>Description</h3>

<p>This function computes a multivariate version of the parameter &quot;Psi&quot; which relates the additive genetic variance-covariance matrix on the latent scale to the additive genetic variance-covariance matrix on the observed scale: G.obs = Psi %*% G %*% t(Psi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGmvpsi(mu = NULL, vcov, d.link.inv, predict = NULL, 
        rel.acc = 0.001, width = 10, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGmvpsi_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_vcov">vcov</code></td>
<td>
<p>Latent total phenotypic variance-covariance matrix estimated from a GLMM. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_d.link.inv">d.link.inv</code></td>
<td>
<p>Derivative of the inverse-link functions. This function should accept a vector and yield a vector of the same length, see Details and Example below. (function)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGmvpsi_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate parameter &quot;Psi&quot; is a diagonal matrix which elements are the average of the derivative of the inverse-link function. The additive genetic variance-covariance matrix on the latent scale G is linked to the additive genetic variance-covariance matrix on the observed scale G.obs through Psi: G.obs = Psi %*% G %*% t(Psi).
</p>
<p>This function requires the derivatives of the inverse-link functions (<code>d.link.inv</code>). For an analysis with d traits, the function given to the <code>d.link.inv</code> argument should use a vector of length d and yield a vector of length d (see Example below).
</p>


<h3>Value</h3>

<p>This function yields the matrix &quot;Psi&quot;. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGpsi">QGpsi</a></code>, <code><a href="#topic+QGmvparams">QGmvparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGvcov">QGvcov</a></code>, <code><a href="#topic+QGmvpsi">QGmvpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using a bivariate model (Binary trait/Gaussian trait)
# Parameters
mu &lt;- c(0, 1)
G &lt;- diag(c(0.5, 2))
P &lt;- diag(c(1, 4))

# Setting up the derivatives of the inverse-link functions
dinvs &lt;- function(mat) {matrix(c(dnorm(mat[1, ]), rep(1, length(mat[2, ]))),
                               nrow = 2, 
                               byrow = TRUE)}
# The derivative of pnorm() is dnorm(), and the derivative of the identity is 1

# Computing Psi
Psi &lt;- QGmvpsi(mu = mu, vcov = P, d.link.inv = dinvs)
# Computing genetic additive variance-covariance matrix on the observed scale
Psi
G.obs &lt;- Psi %*% G %*% t(Psi)

QGparams(mu = 0, var.a = 0.5, var.p = 1, model = "binom1.probit")
# Same additive variance than trait 1
# Reminder: the results are the same here because we have no correlation between the two traits
</code></pre>

<hr>
<h2 id='QGparams'>
Quantitative Genetics parameters from GLMM estimates.
</h2><span id='topic+QGparams'></span>

<h3>Description</h3>

<p>Function to estimate the quantitative genetics parameters on the observed scale based on estimates on the latent scale. The function yields a data.frame which includes the phenotypic mean and variance, as well as the additive genetic variance and heritability, on the observed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGparams(mu, var.a, var.p, model = "", width = 10, predict = NULL,
             closed.form = TRUE, custom.model = NULL, n.obs = NULL, 
             cut.points = NULL, theta = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGparams_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_var.a">var.a</code></td>
<td>
<p>Latent additive genetic variance estimated from a GLMM. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_var.p">var.p</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_model">model</code></td>
<td>
<p>Name of the used model, i.e. distribution.link. Ignored if <code>custom.model</code> is not NULL. (character) Available models are :
</p>

<ul>
<li><p>&quot;Gaussian&quot; Gaussian distribution with identity link (e.g. LMM)
</p>
</li>
<li><p>&quot;binom1.probit&quot; Binomial with 1 trial (binary data) with a probit link
</p>
</li>
<li><p>&quot;binomN.probit&quot; Binomial with N tria with a probit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;binom1.logit&quot; Binomial with 1 trial (binary) with a logit link
</p>
</li>
<li><p>&quot;binomN.logit&quot; Binomial with N trial with a logit link (require the parameter <code>n.obs</code>)
</p>
</li>
<li><p>&quot;Poisson.log&quot; Poisson distribution wiht a log link
</p>
</li>
<li><p>&quot;Poisson.sqrt&quot; Poisson distribution with a square - root link
</p>
</li>
<li><p>&quot;negbin.log&quot; Negative - Binomial distribution wiht a log link (require the parameter <code>theta</code>)
</p>
</li>
<li><p>&quot;negbin.sqrt&quot; Negative - Binomial distribution with a square - root link (require the parameter <code>theta</code>)
</p>
</li>
<li><p>&quot;ordinal&quot; Multiple threshold model for ordinal categorical traits (require the parameter <code>cut.points</code>)
</p>
</li></ul>

</td></tr>
<tr><td><code id="QGparams_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var.p)</code> to <code>mu</code> + <code>width * sqrt(var.p)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_closed.form">closed.form</code></td>
<td>
<p>When available, should closed forms be used instead of integral computations? (boolean, ignored if <code>model = "ordinal"</code>)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_custom.model">custom.model</code></td>
<td>
<p>If the model used is not available using the <code>model</code> argument, a list of functions describing the model can be provided. (list of functions, see Details)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of &quot;trials&quot; for the &quot;binomN&quot; distribution. (numeric)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_cut.points">cut.points</code></td>
<td>
<p>Values for the &quot;cut points&quot; in the multiple threshold model (&quot;ordinal&quot;). Should be a vector of length equal to the number of categories plus one, starting with the value -Inf and ending with the value Inf. (numeric)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_theta">theta</code></td>
<td>
<p>Dispersion parameter for the Negative Binomial distribution. The parameter <code>theta</code> should be such as the variance of the distribution is <code>mean + mean^2 / theta</code>. (numeric)</p>
</td></tr>
<tr><td><code id="QGparams_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function typically uses precise integral numerical approximation to compute quantitative genetics parameters on the observed scale, from latent estimates yielded by a GLMM. If closed form solutions for the integrals are available, it uses them if <code>closed.form = TRUE</code>.
</p>
<p>Only the most typical distribution/link function couples are implemented in the function. If you used an &quot;exotic&quot; GLMM, you can use the <code>custom.model</code> argument. It should take the form of a list of functions. The first function should be the inverse of the link function named <code>inv.link</code>, the second function should be the &quot;distribution variance&quot; function named <code>var.func</code> and the third function should be the derivative of the inverse link function named <code>d.inv.link</code> (see Example below).
</p>
<p>Some distributions require extra-arguments. This is the case for &quot;binomN&quot;, which require the number of trials N, passed with the argument <code>n.obs</code>. The distribution &quot;negbin&quot; requires a dispersion parameter <code>theta</code>, such as the variance of the distribution is <code>mean + mean^2 / theta</code> (mean/dispersion parametrisation).
</p>
<p>If fixed effects (apart from the intercept) have been included in the GLMM, they can be included as marginal predicted values, i.e. predicted values excluding the random effects, which can be calculated as the matrix product <strong>Xb</strong> where <strong>X</strong> is the design matrix and <strong>b</strong> is the vector of fixed effects estimates. To do so, provide the vector of marginal predicted values using the argument <code>predict</code>. Note this can considerably slow down the algorithm, especially when no closed form is used.
</p>
<p>Ordinal model is different from the other models, because it yields multivariate inference on the observed data scale, even though the latent scale is not multivariate. As a consequence, this model can only be accessed using the function <code>QGparams</code> and has an output similar to the one of <code>QGmvparams</code>.
</p>


<h3>Value</h3>

<p>The function yields a data.frame containing the following values:
</p>
<table>
<tr><td><code>mean.obs</code></td>
<td>
<p>Phenotypic mean on the observed scale.</p>
</td></tr>
<tr><td><code>var.obs</code></td>
<td>
<p>Phenotypic variance on the observed scale.</p>
</td></tr>
<tr><td><code>var.a.obs</code></td>
<td>
<p>Additive genetic variance on the observed scale.</p>
</td></tr>
<tr><td><code>h2.obs</code></td>
<td>
<p>Heritability on the observed scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGmvparams">QGmvparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using binary data
# Parameters
mu &lt;- 0
va &lt;- 1
vp &lt;- 2

# Simulating data l = mu + a + e
lat&lt;- mu + rnorm(1000, 0, sqrt(va)) + rnorm(1000, 0, sqrt(vp - va))
y&lt;- rbinom(1000, 1, pnorm(lat))

# Expected results
QGparams(mu = 0, var.p = 2, var.a = 1, model = "binom1.probit")
# Simulated results for mean and variance
mean(y)
var(y)

# Using integral approximations
QGparams(mu = 0, var.p = 2, var.a = 1, model = "binom1.probit", closed.form = FALSE)
# Note that the approximation is exactly equal to the results obtained with the closed form

# Let's create a custom model
custom &lt;- list(inv.link = function(x){pnorm(x)},
    var.func = function(x){pnorm(x) * (1 - pnorm(x))},
    d.inv.link = function(x){dnorm(x)})
    
QGparams(mu = 0, var.p = 2, var.a = 1, custom.model = custom)

# Using an ordinal model (with 4 categories)
QGparams(mu = 0.1, var.a = 1, var.p = 2, cut.points = c( - Inf, 0, 0.5, 1, Inf), model = "ordinal")
# Note the slightly different output (see QGmvparams)

# Integrating over a posterior distribution
# e.g. output from MCMCglmm named "model"
# df &lt;- data.frame(mu = model$Sol[, 'intercept'], 
#                  va = model$VCV[, 'animal'], 
#                  vp = rowSums(model$VCV))
# params &lt;- apply(df, 1, function(row){
#        QGparams(mu = row$mu, var.a = row$va, var.p = row$vp, model = "Poisson.log")
# })
</code></pre>

<hr>
<h2 id='QGpred'>Predict the evolutionary response to selection on the observed scale</h2><span id='topic+QGpred'></span>

<h3>Description</h3>

<p>This function uses an assumed or measured fitness function to compute evolutionary response to selection on the observed scale. To do so a latent fitness function must be provided to the function. This fitness function is used to compute the evolutionary response on the latent scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    QGpred(mu = NULL, var.a, var.p, fit.func, d.fit.func, width = 10, 
           predict = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGpred_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (set to 0 if <code>predict</code> is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_var.a">var.a</code></td>
<td>
<p>Latent additive genetic variance estimated from a GLMM. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_var.p">var.p</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_fit.func">fit.func</code></td>
<td>
<p>Function giving the expected fitness on the observed scale for a given latent trait (see Example). (function)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_d.fit.func">d.fit.func</code></td>
<td>
<p>Derivative of the expected fitness to the latent trait (see Example). (function)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var.p)</code> to <code>mu</code> + <code>width * sqrt(var.p)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGpred_+3A_verbose">verbose</code></td>
<td>
<p>Should the function be verbose? (boolean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the latent fitness function (<code>fit.func</code>) and latent quantitative genetics parameters to compute the expected selection differential and response on the latent scale.
</p>
<p>There is no argument to describe the model used as it is already and implicitely contained in the calculation of <code>fit.func</code>.
</p>
<p>If fixed effects were included during the estimation of the quantitative genetics parameters,  they can be included as marginal predicted values, i.e. predicted values excluding the random effects, which can be calculated as the matrix product <strong>Xb</strong> where <strong>X</strong> is the design matrix and <strong>b</strong> is the vector of fixed effects estimates. To do so, provide the vector of marginal predicted values using the argument <code>predict</code>. Note this will considerably slow down the algorithm.
</p>
<p>The predictions can be transposed on the observed scale by using the <code><a href="#topic+QGmean">QGmean</a></code> function (see Example below).
</p>


<h3>Value</h3>

<p>The function yields a data.frame containing:
</p>

<ul>
<li><p><code>mean.lat.fitness</code>Average latent fitness. (numeric)
</p>
</li>
<li><p><code>lat.grad</code>Latent selection gradient. (numeric)
</p>
</li>
<li><p><code>lat.sel</code>Latent selection differential. (numeric)
</p>
</li>
<li><p><code>lat.resp</code>Latent evolutionary response to selection. (numeric)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with binary traits and a fitness measurement
# Let's assume we dispose of a binary trait measurement 
# and associated fitness of trait 0 (say 1) and trait 1 (say 1.86)
# We further assume a GLMM with Binomial distribution and probit link with:
mu &lt;- -0.1
va &lt;- 2
vp &lt;- 2.5  # note that the latent heritability is very high

# Creating the latent fitness function
# i.e. expected fitness given a latent trait l
# We have a trait 1 with probability pnorm(l) with fitness 1.86
# We have a trait 0 with probability (1 - pnorm(l)) with fitness 1
lat.fit&lt;- function(l){(1 - pnorm(l)) * 1 + pnorm(l) * 1.86}
# Derivate of the fitnes function
d.lat.fit&lt;- function(l){- dnorm(l) * 1 + dnorm(l) * 1.86}

# Predicting the latent evolutionary response
pred &lt;- QGpred(mu = mu, var.p = vp, var.a = va, fit.func = lat.fit, d.fit.func = d.lat.fit)

# Predicting the observed evolutionary response
# Current observed phenotypic mean
QGmean(mu = mu, var = vp, link.inv = QGlink.funcs("binom1.probit")$inv.link)
# Predicted observed phenotypic mean after selection
QGmean(mu = mu + pred$lat.resp, var = vp, link.inv = QGlink.funcs("binom1.probit")$inv.link)
</code></pre>

<hr>
<h2 id='QGpsi'>Compute &quot;Psi&quot; (used to compute the additive genetic variance on the observed scale).</h2><span id='topic+QGpsi'></span>

<h3>Description</h3>

<p>This function computes the parameter &quot;Psi&quot; which relates the additive genetic variance on the latent scale to the additive genetic variance on the observed scale: Va.obs = (Psi^2) * Va
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGpsi(mu = NULL, var, d.link.inv, predict = NULL, width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGpsi_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (set to 0 if <code>predict</code> is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGpsi_+3A_var">var</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGpsi_+3A_d.link.inv">d.link.inv</code></td>
<td>
<p>Derivative of the inverse-link function. (function)</p>
</td></tr>
<tr><td><code id="QGpsi_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGpsi_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var)</code> to <code>mu</code> + <code>width * sqrt(var)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter &quot;Psi&quot; is the average of the derivative of the inverse-link function. The additive genetic variance on the observed scale is linked to the additive genetic variance on the latent scale by : Va.obs = (Psi^2) * Va.lat.
</p>


<h3>Value</h3>

<p>This function yields the &quot;Psi&quot; parameter. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGmvpsi">QGmvpsi</a></code>, <code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using binom1.probit model
mu &lt;- 0
va &lt;- 1
vp &lt;- 2
# The inverse-link for a probit is the CDF of a standard Gaussian
# Hence its derivative is the PDF of a standard Gaussian
dinv &lt;- function(x){dnorm(x)}

# Computing Psi
Psi &lt;- QGpsi(mu = 0, var = 2, d.link.inv = dinv)
# Computing additive variance on the observed scale
(Psi^2) * va

# This function is used by QGparams to obtain var.a.obs
QGparams(mu = 0, var.p = vp, var.a = va, model = "binom1.probit")
# Same results as above!
</code></pre>

<hr>
<h2 id='QGvar.dist'>Compute the distribution variance</h2><span id='topic+QGvar.dist'></span>

<h3>Description</h3>

<p>This function computes the variance emerging from the error distribution around the individual expected value. This variance, added to the variance of the individual expected values themselves (see <code><a href="#topic+QGvar.exp">QGvar.exp</a></code>) yields the total observed phenotypic variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGvar.dist(mu = NULL, var, var.func, predict = NULL, width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGvar.dist_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGvar.dist_+3A_var">var</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGvar.dist_+3A_var.func">var.func</code></td>
<td>
<p>Function giving the variance of the distribution according to a given latent value. (function)</p>
</td></tr>
<tr><td><code id="QGvar.dist_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGvar.dist_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var)</code> to <code>mu</code> + <code>width * sqrt(var)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution variance is the part of the observed variance emerging from the error distribution. It is calculated as an average error variance over all possible latent values. The distribution variance added to the variance of the expected values gives the total phenotypic variance on the observed scale.
</p>
<p>The variance function (<code>var.func</code>) is a function giving the variance of the error distribution of the GLMM according to a given latent value.
</p>
<p>Using a Poisson distribution with a logarithm link, this function is <code>exp(x)</code>, because the variance of a Poisson is its mean. Using a Negative Binomial distribution with a logarithm link, this function will now be <code>exp(x) + exp(2 * x) / theta</code>. Note that the dispersion parameter <code>theta</code> is necessary for a Negative Binomial distribution.
</p>
<p>The <code>var.func</code> function is yielded by <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code> according to a given distribution.link model (see Example below).
</p>
<p>Contrary to <code><a href="#topic+QGparams">QGparams</a></code>, <code>QGvar.exp</code> never uses the closed form solutions, but always compute the integrals.
</p>


<h3>Value</h3>

<p>This function yields the distribution variance. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using Poisson.log model
mu &lt;- 1
va &lt;- 0.2
vp &lt;- 0.5

# The variance function is simply the inverse-link function
# because the variance of a Poisson is its mean
varfunc &lt;- function(x) { exp(x) }

QGvar.dist(mu = mu, var = vp, var.func = varfunc)

# The QGlink.funcs gives a ready - to - use var.func
funcs &lt;- QGlink.funcs(name = "Poisson.log")

# Calculating the distribution variance
vdist &lt;- QGvar.dist(mu = mu, var = vp, var.func = funcs$var.func)

vdist           # Same value as above

# Calculating the variance of the expected values
vexp &lt;- QGvar.exp(mu = mu, var = vp, link.inv = funcs$inv.link)

# The phenotypic variance on the observed scale is then:
vexp + vdist

# This computation is automatically performed by QGparams
# but directly using the closed form solutions when available
QGparams(mu = mu, var.p = vp, var.a = va, model = "Poisson.log")
# var.obs is equal to the sum above
</code></pre>

<hr>
<h2 id='QGvar.exp'>Compute the variance of expected values (i.e. the latent values after inverse-link transformation.)</h2><span id='topic+QGvar.exp'></span>

<h3>Description</h3>

<p>This function computes the variance of the expected values, i.e. the variance of the latent values after transformation through the inverse-link function. This variance, added to the distribution variance, yields to the phenotypic variance on the observed scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGvar.exp(mu = NULL, var, link.inv, obs.mean = NULL, predict = NULL, width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGvar.exp_+3A_mu">mu</code></td>
<td>
<p>Latent intercept estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGvar.exp_+3A_var">var</code></td>
<td>
<p>Latent total phenotypic variance estimated from a GLMM. Usually, the sum of the estimated variances of the random effects, plus the &quot;residual&quot; variance. (numeric of length 1)</p>
</td></tr>
<tr><td><code id="QGvar.exp_+3A_link.inv">link.inv</code></td>
<td>
<p>Inverse function of the link function. (function)</p>
</td></tr>
<tr><td><code id="QGvar.exp_+3A_obs.mean">obs.mean</code></td>
<td>
<p>Optional parameter giving the phenotypic mean on the observed scale. Automatically computed if not provided. (numeric)</p>
</td></tr>
<tr><td><code id="QGvar.exp_+3A_predict">predict</code></td>
<td>
<p>Optional vector of predicted values on the latent scale (i.e. matrix product <b>Xb</b>). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGvar.exp_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The integral is evaluated from <code>mu</code> - <code>width * sqrt(var)</code> to <code>mu</code> + <code>width * sqrt(var)</code>. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the expected values is the variance that directly arise from the variance of the latent values, but after transformation through the inverse-link function. For example, using a logarithm link, this is the variance of exp(l) where l is the latent trait.
</p>
<p>To compute the variance, the function needs the phenotypic mean on the observed scale. If this was already computed, it can be provided using the optional argument <code>obs.mean</code>, which will save computing time. Otherwise (default), the function will compute the mean on the observed scale before computing the variance.
</p>
<p>This variance, when added to the distribution variance (see <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>) yields the phenotypic variance on the observed scale.
</p>
<p>The function required for <code>link.inv</code> is yielded by <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code> according to a given distribution.link model (see Example below).
</p>
<p>Contrary to <code><a href="#topic+QGparams">QGparams</a></code>, <code>QGvar.dist</code> never uses the closed form solutions, but always compute the integrals.
</p>


<h3>Value</h3>

<p>This function yields the variance of the expected values. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGparams">QGparams</a></code>, <code><a href="#topic+QGpred">QGpred</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmean">QGmean</a></code>, <code><a href="#topic+QGpsi">QGpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using Poisson.log model
mu &lt;- 1
va &lt;- 0.2
vp &lt;- 0.5

# The inverse-link for a logarithm link is the exponential
inv.link&lt;- function(x){exp(x)}

# We can then calculate the variance of expected values
QGvar.exp(mu = mu, var = vp, link.inv = inv.link)

# The mean on the observed scale can be computed beforehand
y_bar &lt;- QGmean(mu = mu, var = vp, link.inv = inv.link)
QGvar.exp(mu = mu, var = vp, obs.mean = y_bar, link.inv = inv.link)

# The QGlink.funcs gives a ready - to - use inverse-link function
funcs&lt;- QGlink.funcs(name = "Poisson.log")

# Calculating the distribution variance
vexp &lt;- QGvar.exp(mu = mu, var = vp, obs.mean = y_bar, link.inv = funcs$var.func)

vexp           # Same value as above

# Calculating the associated distribution variance
vdist &lt;- QGvar.dist(mu = mu, var = vp, var.func = funcs$var.func)

# The phenotypic variance on the observed scale is then:
vexp + vdist

# This computation is automatically performed by QGparams
# but directly using the closed form solutions when available
QGparams(mu = mu, var.p = vp, var.a = va, model = "Poisson.log")
# var.obs is equal to the sum above
</code></pre>

<hr>
<h2 id='QGvcov'>Compute the phenotypic variance-covariance matrix on the observed / expected scale</h2><span id='topic+QGvcov'></span>

<h3>Description</h3>

<p>This function computes the total phenotypic variance-covariance matrix on the observed or expected scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGvcov(mu = NULL, vcov, link.inv, var.func, mvmean.obs = NULL,
       predict = NULL, rel.acc = 0.001, width = 10, exp.scale = FALSE, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGvcov_+3A_mu">mu</code></td>
<td>
<p>Vector of latent intercepts estimated from a GLMM (ignored if predict is not <code>NULL</code>). (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_vcov">vcov</code></td>
<td>
<p>Latent total phenotypic variance-covariance matrix estimated from a GLMM. Usually, the sum of all the estimated variance-covariance matrices. (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_link.inv">link.inv</code></td>
<td>
<p>Inverse functions of the link functions. This function should accept a vector and yield a vector of the same length, see Details and Example below. (function)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_var.func">var.func</code></td>
<td>
<p>Function giving the variance function for each trait. This function should accept a vector and yield a vector of the same length, see Details and Example below. (function)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_mvmean.obs">mvmean.obs</code></td>
<td>
<p>Optional parameter giving the multivariate phenotypic mean on the observed scale. Automatically computed if not provided. (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_predict">predict</code></td>
<td>
<p>Optional matrix of predicted values on the latent scale (each trait in each column). The latent predicted values must be computed while only accounting for the fixed effects (marginal to the random effects). (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_rel.acc">rel.acc</code></td>
<td>
<p>Relative accuracy of the integral approximation. (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_width">width</code></td>
<td>
<p>Parameter for the integral computation. The default value is 10, which should be sensible for most models. (numeric)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_exp.scale">exp.scale</code></td>
<td>
<p>Should the variance-covariance matrix be computed on the expected scale? <code>FALSE</code> by default, which means the variance-covariance matrix is computed on the observed scale. (boolan)</p>
</td></tr>
<tr><td><code id="QGvcov_+3A_mask">mask</code></td>
<td>
<p>Masking filter for removing predictions that don't exist in the population (e.g. female predictions for males for a sex - based bivariate model). Should the same dimensions as <code>predict</code> and values should be <code>FALSE</code> when the predictions should be filtered out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs the multivariate latent population mean (<code>mu</code>) or the marginal predicted values (<code>predict</code>) and the total latent variance-covariance matrix (<code>vcov</code>) to compute the phenotypic variance-covariance matrix on the observed scale (or on the expected scale if <code>exp.scale</code> is <code>TRUE</code>).
</p>
<p>To do so, it also requires the inverse functions of the link functions (<code>link.inv</code>) and the distribution variance functions (<code>var.func</code>). For an analysis with d traits, the function given to these arguments should use a vector of length d and yield a vector of length d (see Example below).
</p>


<h3>Value</h3>

<p>This function yields the phenotypic variance-covariance on the observed or expected scale. (numeric)</p>


<h3>Author(s)</h3>

<p>Pierre de Villemereuil &amp; Michael B. Morrissey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QGvar.exp">QGvar.exp</a></code>, <code><a href="#topic+QGvar.dist">QGvar.dist</a></code>, <code><a href="#topic+QGmvparams">QGmvparams</a></code>, <code><a href="#topic+QGlink.funcs">QGlink.funcs</a></code>, <code><a href="#topic+QGmvpsi">QGmvpsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example using a bivariate model (Binary trait/Gaussian trait)
# Parameters
mu &lt;- c(0, 1)
P &lt;- diag(c(1, 4))

# Note: no phenotypic, nor genetic correlations, hence should be equal to univariate case!

# Setting up the link functions
# Note that since the use of "cubature" to compute the integrals,
# the functions must use a matrix as input and yield a matrix as output,
# each row corresponding to a trait
inv.links &lt;- function(mat) {matrix(c(pnorm(mat[1, ]), mat[2, ]), nrow = 2, byrow = TRUE)}

# Setting up the distribution variance functions
var.funcs &lt;- function(mat) {matrix(c(pnorm(mat[1, ]) * (1 - pnorm(mat[1, ])), 0 * mat[2, ]),
                                   nrow = 2, 
                                   byrow = TRUE)}
# The first row is p * (1 - p) (variance of a binomial)
# The second row is 0 because no extra distribution is assumed for a Gaussian trait

# Computing the multivariate mean on observed scale
# Phenotypic VCV matrix on observed scale
QGvcov(mu = mu, vcov = P, link.inv = inv.links, var.func = var.funcs) 
# Phenotypic VCV matrix on the expected scale
QGvcov(mu = mu, vcov = P, link.inv = inv.links, var.func = var.funcs, exp.scale = TRUE) 

QGvar.exp(mu = 0, var = 1, link.inv = pnorm) # Same variance on the expected scale
QGvar.exp(mu = 0, var = 1, link.inv = pnorm) +
    QGvar.dist(mu = 0, var = 1, var.func = function(x){pnorm(x) * (1 - pnorm(x))})
# Same variance on the observed scale
# Reminder: the results are the same here because we have no correlation between the two traits
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
