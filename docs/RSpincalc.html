<!DOCTYPE html><html lang="en"><head><title>Help for package RSpincalc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSpincalc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DCM2EA'>
<p>Convert from Direction Cosine Matrix to Euler Angles</p></a></li>
<li><a href='#DCM2EV'>
<p>Convert from Direction Cosine Matrix to Euler Vectors</p></a></li>
<li><a href='#DCM2Q'>
<p>Convert from Direction Cosine Matrix to rotation Quaternions</p></a></li>
<li><a href='#DCMrandom'>
<p>Generate uniform random direction cosine matrices</p></a></li>
<li><a href='#EA2DCM'>
<p>Convert from Euler Angles to Direction Cosine Matrix</p></a></li>
<li><a href='#EA2EA'>
<p>Convert from Euler Angles to Euler Angles</p></a></li>
<li><a href='#EA2EV'>
<p>Convert from Euler Angles to Euler Vectors</p></a></li>
<li><a href='#EA2Q'>
<p>Convert from Euler Angles to rotation Quaternions</p></a></li>
<li><a href='#EArandom'>
<p>Generate uniform random Euler Angles</p></a></li>
<li><a href='#EV2DCM'>
<p>Convert from Euler Vectors to Direction Cosine Matrix</p></a></li>
<li><a href='#EV2EA'>
<p>Convert from Euler Vectors to Euler Angles</p></a></li>
<li><a href='#EV2Q'>
<p>Convert from Euler Vectors to rotation Quaternions</p></a></li>
<li><a href='#EVrandom'>
<p>Generate uniform random Euler Vectors</p></a></li>
<li><a href='#isPureRotationMatrix'>
<p>Determine if the variable is a pure rotation matrix</p></a></li>
<li><a href='#Q2DCM'>
<p>Convert from rotation Quaternions to Direction Cosine Matrix</p></a></li>
<li><a href='#Q2EA'>
<p>Convert from rotation Quaternions to Euler Angles</p></a></li>
<li><a href='#Q2EV'>
<p>Convert from rotation Quaternions to Euler Vectors</p></a></li>
<li><a href='#Q2GL'>
<p>Convert from rotation Quaternions to OpenGL rotation matrix</p></a></li>
<li><a href='#QangularDifference'>
<p>Angular difference between 2 quaternions</p></a></li>
<li><a href='#Qconj'>
<p>Quaternion conjugate</p></a></li>
<li><a href='#Qinv'>
<p>Quaternion inverse</p></a></li>
<li><a href='#Qlerp'>
<p>Linear quaternion interpolation</p></a></li>
<li><a href='#Qlog'>
<p>Quaternion logarithm</p></a></li>
<li><a href='#Qnorm'>
<p>Norm of a quaternion</p></a></li>
<li><a href='#Qnormalize'>
<p>Quaternion normalization</p></a></li>
<li><a href='#Qrandom'>
<p>Generate uniform random unit quaternions</p></a></li>
<li><a href='#Qrot'>
<p>Updates current attitude quaternion</p></a></li>
<li><a href='#Qzero'>
<p>Generate zero-valued quaternions</p></a></li>
<li><a href='#vectQrot'>
<p>Rotate a vector by a quaternion</p></a></li>
<li><a href='#z1'>
<p>Quaternion multiplication</p></a></li>
<li><a href='#z2'>
<p>Quaternion division</p></a></li>
<li><a href='#z3'>
<p>Quaternion subtraction</p></a></li>
<li><a href='#z4'>
<p>Quaternion addition</p></a></li>
<li><a href='#z5'>
<p>Quaternion dot product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conversion Between Attitude Representations of DCM, Euler
Angles, Quaternions, and Euler Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Conversion between attitude representations: DCM, Euler angles, Quaternions, and Euler vectors.
    Plus conversion between 2 Euler angle set types (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx).
    Fully vectorized code, with warnings/errors for Euler angles (singularity, out of range, invalid angle order), 
    DCM (orthogonality, not proper, exceeded tolerance to unity determinant) and Euler vectors(not unity).
    Also quaternion and other useful functions.
    Based on SpinCalc by John Fuller and SpinConv by Paolo de Leva.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Gama [aut, cre],
  John Fuller [aut, cph],
  Paolo Leva [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Gama &lt;rxprtgama@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>rspincalc</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>16</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2015-07-16 22:34:34</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-17 12:51:32</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-16 22:45:13 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='DCM2EA'>
Convert from Direction Cosine Matrix to Euler Angles
</h2><span id='topic+DCM2EA'></span>

<h3>Description</h3>

<p><code>DCM2EA</code> converts from Direction Cosine Matrix (DCM) to Euler Angles (EA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCM2EA(DCM, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ichk = FALSE, 
ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCM2EA_+3A_dcm">DCM</code></td>
<td>

<p>Direction Cosine Matrix (DCM) is a rotation matrix 3x3 (N=1) or an array 3x3xN
</p>
</td></tr>
<tr><td><code id="DCM2EA_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Angles (EA) is a vector [psi, theta, phi]
</p>
</td></tr>
<tr><td><code id="DCM2EA_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or 
the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="DCM2EA_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="DCM2EA_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Euler Angles (EA) vector [psi, theta, phi]
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler 
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EA2DCM">EA2DCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DCM &lt;- matrix(c(-0.3573404, -0.1515663, 0.9215940, 0.6460385, 0.6724915, 
0.3610947, -0.6744939, 0.7244189, -0.1423907),3,3,byrow=TRUE)
DCM2EA(DCM,'xyz')
</code></pre>

<hr>
<h2 id='DCM2EV'>
Convert from Direction Cosine Matrix to Euler Vectors
</h2><span id='topic+DCM2EV'></span>

<h3>Description</h3>

<p><code>DCM2EV</code> converts from Direction Cosine Matrix (DCM) to Euler Vectors (EV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCM2EV(DCM, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCM2EV_+3A_dcm">DCM</code></td>
<td>

<p>Direction Cosine Matrix (DCM) is a rotation matrix 3x3 (N=1) or an array 3x3xN.
</p>
</td></tr>
<tr><td><code id="DCM2EV_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or 
the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="DCM2EV_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="DCM2EV_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU]
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler 
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EV2DCM">EV2DCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DCM &lt;- matrix(c(-0.3573404, -0.1515663, 0.9215940, 0.6460385, 0.6724915, 
0.3610947, -0.6744939, 0.7244189, -0.1423907),3,3,byrow=TRUE)
DCM2EV(DCM)
</code></pre>

<hr>
<h2 id='DCM2Q'>
Convert from Direction Cosine Matrix to rotation Quaternions
</h2><span id='topic+DCM2Q'></span>

<h3>Description</h3>

<p><code>DCM2Q</code> converts from Direction Cosine Matrix (DCM) to Quaternions (Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCM2Q(DCM, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCM2Q_+3A_dcm">DCM</code></td>
<td>

<p>Direction Cosine Matrix (DCM) is a rotation matrix 3x3 (N=1) or an array 3x3xN
</p>
</td></tr>
<tr><td><code id="DCM2Q_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or 
the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="DCM2Q_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="DCM2Q_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler 
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Q2DCM">Q2DCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DCM &lt;- matrix(c(-0.3573404, -0.1515663, 0.9215940, 0.6460385, 0.6724915, 
0.3610947, -0.6744939, 0.7244189, -0.1423907),3,3,byrow=TRUE)
DCM2Q(DCM)
</code></pre>

<hr>
<h2 id='DCMrandom'>
Generate uniform random direction cosine matrices
</h2><span id='topic+DCMrandom'></span>

<h3>Description</h3>

<p><code>DCMrandom</code> generates uniform random direction cosine matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCMrandom(n=NA, tol = 10 * .Machine$double.eps, ignoreAllChk=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCMrandom_+3A_n">n</code></td>
<td>
<p>Optional integer for the number of generated direction cosine matrices, default = 1.</p>
</td></tr>
<tr><td><code id="DCMrandom_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="DCMrandom_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DCM</code></td>
<td>

<p>Direction cosine matrix or array (DCM).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DCMrandom()
DCMrandom(5)
</code></pre>

<hr>
<h2 id='EA2DCM'>
Convert from Euler Angles to Direction Cosine Matrix
</h2><span id='topic+EA2DCM'></span>

<h3>Description</h3>

<p><code>EA2DCM</code> converts from Euler Angles (EA) to Direction Cosine Matrix (DCM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EA2DCM(EA, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ichk = FALSE, 
ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EA2DCM_+3A_ea">EA</code></td>
<td>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>
</td></tr>
<tr><td><code id="EA2DCM_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EA2DCM_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices 
or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EA2DCM_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EA2DCM_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Direction Cosine Matrix (DCM) 3x3xN.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCM2EA">DCM2EA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EAxyx &lt;- c(-170.6607, 110.937, 136.2344) * (pi/180)
EA2DCM(EAxyx,'xyx')
</code></pre>

<hr>
<h2 id='EA2EA'>
Convert from Euler Angles to Euler Angles
</h2><span id='topic+EA2EA'></span>

<h3>Description</h3>

<p><code>EA2EA</code> converts from Euler Angles (EA) to Euler Angles (EA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EA2EA(EA, EulerOrder1='zyx', EulerOrder2='zyx', tol = 10 * .Machine$double.eps, 
ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EA2EA_+3A_ea">EA</code></td>
<td>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>
</td></tr>
<tr><td><code id="EA2EA_+3A_eulerorder1">EulerOrder1</code></td>
<td>

<p>Euler Order 1 (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EA2EA_+3A_eulerorder2">EulerOrder2</code></td>
<td>

<p>Euler Order 2 (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EA2EA_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices 
or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EA2EA_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EA2EA_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler 
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EA2DCM">EA2DCM</a></code>, <code><a href="#topic+EA2Q">EA2Q</a></code>, <code><a href="#topic+EA2EV">EA2EV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
EAxyx &lt;- c(-170.6607, 110.937, 136.2344)
EA2EA(EAxyx,'xyx','xyz')
EA2EA(EAxyx,'xyx','xzy')
EA2EA(EAxyx,'xyx','yzx')
EA2EA(EAxyx,'xyx','yxz')
EA2EA(EAxyx,'xyx','zxy')
EA2EA(EAxyx,'xyx','zyx')
EA2EA(EAxyx,'xyx','xzx')
EA2EA(EAxyx,'xyx','yxy')
EA2EA(EAxyx,'xyx','yzy')
EA2EA(EAxyx,'xyx','zxz')
EA2EA(EAxyx,'xyx','zyz')

## End(Not run)
</code></pre>

<hr>
<h2 id='EA2EV'>
Convert from Euler Angles to Euler Vectors
</h2><span id='topic+EA2EV'></span>

<h3>Description</h3>

<p><code>EA2EV</code> converts from Euler Angles (EA) to Euler Vectors (EV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EA2EV(EA, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ichk = FALSE, 
ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EA2EV_+3A_ea">EA</code></td>
<td>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>
</td></tr>
<tr><td><code id="EA2EV_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EA2EV_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices 
or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EA2EV_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EA2EV_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EV2EA">EV2EA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EAxyx &lt;- c(-170.6607, 110.937, 136.2344) * (pi/180)
EA2EV(EAxyx,'xyx')
</code></pre>

<hr>
<h2 id='EA2Q'>
Convert from Euler Angles to rotation Quaternions
</h2><span id='topic+EA2Q'></span>

<h3>Description</h3>

<p><code>EA2Q</code> converts from Euler Angles (EA) to Quaternions (Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EA2Q(EA, EulerOrder='zyx', ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EA2Q_+3A_ea">EA</code></td>
<td>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>
</td></tr>
<tr><td><code id="EA2Q_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EA2Q_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EA2Q_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Quaternions (Q) vector [q1, q2, q3, q4].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Q2EA">Q2EA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EAxyx &lt;- c(-170.6607, 110.937, 136.2344) * (pi/180)
EA2Q(EAxyx,'xyx')
</code></pre>

<hr>
<h2 id='EArandom'>
Generate uniform random Euler Angles
</h2><span id='topic+EArandom'></span>

<h3>Description</h3>

<p><code>EArandom</code> generates uniform random Euler Angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EArandom(n=NA, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ignoreAllChk=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EArandom_+3A_n">n</code></td>
<td>
<p>Optional integer for the number of generated Euler Angles, default = 1.</p>
</td></tr>
<tr><td><code id="EArandom_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx).
</p>
</td></tr>
<tr><td><code id="EArandom_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EArandom_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>EA</code></td>
<td>

<p>Euler Angles (EA).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EArandom()
EArandom(5)
</code></pre>

<hr>
<h2 id='EV2DCM'>
Convert from Euler Vectors to Direction Cosine Matrix
</h2><span id='topic+EV2DCM'></span>

<h3>Description</h3>

<p><code>EV2DCM</code> converts from Euler Vectors (EV) to Direction Cosine Matrix (DCM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV2DCM(EV, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EV2DCM_+3A_ev">EV</code></td>
<td>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU].
</p>
</td></tr>
<tr><td><code id="EV2DCM_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EV2DCM_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EV2DCM_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Direction Cosine Matrix (DCM) 3x3xN.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCM2EV">DCM2EV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EV &lt;- c(-0.1995301, -0.8765382, -0.4380279, 114.4324 * (pi/180))
EV2DCM(EV,1e-7)
#EV2DCM(EV)
</code></pre>

<hr>
<h2 id='EV2EA'>
Convert from Euler Vectors to Euler Angles
</h2><span id='topic+EV2EA'></span>

<h3>Description</h3>

<p><code>EV2EA</code> converts from Euler Vectors (EV) to Euler Angles (EA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV2EA(EV, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ichk = FALSE, 
ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EV2EA_+3A_ev">EV</code></td>
<td>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU].
</p>
</td></tr>
<tr><td><code id="EV2EA_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx)
</p>
</td></tr>
<tr><td><code id="EV2EA_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices 
or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EV2EA_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EV2EA_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EA2EV">EA2EV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
EV &lt;- c(-0.1995301, -0.8765382, -0.4380279, 114.4324 * (pi/180))
EV2EA(EV,'xyx')

## End(Not run)
</code></pre>

<hr>
<h2 id='EV2Q'>
Convert from Euler Vectors to rotation Quaternions
</h2><span id='topic+EV2Q'></span>

<h3>Description</h3>

<p><code>EV2Q</code> converts from Euler Vectors (EV) to Quaternions (Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV2Q(EV, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EV2Q_+3A_ev">EV</code></td>
<td>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU].
</p>
</td></tr>
<tr><td><code id="EV2Q_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EV2Q_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="EV2Q_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quaternions (Q) vector [q1, q2, q3, q4].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Q2EV">Q2EV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EV &lt;- c(-0.1995301, -0.8765382, -0.4380279, 114.4324 * (pi/180))
EV2Q(EV,1e-7)
#EV2Q(EV)
</code></pre>

<hr>
<h2 id='EVrandom'>
Generate uniform random Euler Vectors
</h2><span id='topic+EVrandom'></span>

<h3>Description</h3>

<p><code>EVrandom</code> generates uniform random Euler Vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EVrandom(n=NA, tol = 10 * .Machine$double.eps, ignoreAllChk=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EVrandom_+3A_n">n</code></td>
<td>
<p>Optional integer for the number of generated Euler Vectors, default = 1.</p>
</td></tr>
<tr><td><code id="EVrandom_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="EVrandom_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>EV</code></td>
<td>

<p>Euler Vectors (EV).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EVrandom()
EVrandom(5)
</code></pre>

<hr>
<h2 id='isPureRotationMatrix'>
Determine if the variable is a pure rotation matrix
</h2><span id='topic+isPureRotationMatrix'></span><span id='topic+isPureQuaternion'></span><span id='topic+isRealQuaternion'></span><span id='topic+isUnitQuaternion'></span>

<h3>Description</h3>

<p><code>isPureRotationMatrix</code> determines if a matrix is pure rotation matrix (proper orthogonal matrix) with det(m)==1.
<code>isPureQuaternion</code> determines if a quaternion is a pure quaternion.
<code>isRealQuaternion</code> determines if a quaternion is a real quaternion.
<code>isUnitQuaternion</code> determines if a quaternion is a unit quaternion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPureRotationMatrix(DCM, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isPureRotationMatrix_+3A_dcm">DCM</code></td>
<td>
<p>Direction Cosine Matrix (DCM) is a rotation matrix 3x3 (N=1) or an array 3x3xN.</p>
</td></tr>
<tr><td><code id="isPureRotationMatrix_+3A_tol">tol</code></td>
<td>
<p>Tolerance value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, TRUE = matrix is pure rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Q2GL">Q2GL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isPureRotationMatrix(matrix(rep(0,9),3,3,byrow=TRUE),.1)
isPureRotationMatrix(matrix(rep(1,9),3,3,byrow=TRUE),.1)
isPureRotationMatrix(matrix(c(0,0,-1,0,1,0,1,0,1),3,3,byrow=TRUE),.1)
DCMx10 &lt;- DCMrandom(10)
isPureRotationMatrix(DCMx10)
</code></pre>

<hr>
<h2 id='Q2DCM'>
Convert from rotation Quaternions to Direction Cosine Matrix
</h2><span id='topic+Q2DCM'></span>

<h3>Description</h3>

<p><code>Q2DCM</code> converts from Quaternions to Direction Cosine Matrix (DCM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q2DCM(Q, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q2DCM_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="Q2DCM_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="Q2DCM_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="Q2DCM_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Direction Cosine Matrix (DCM) 3x3xN.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCM2Q">DCM2Q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q2DCM(Q)
</code></pre>

<hr>
<h2 id='Q2EA'>
Convert from rotation Quaternions to Euler Angles
</h2><span id='topic+Q2EA'></span><span id='topic+Q2EA.Xiao'></span>

<h3>Description</h3>

<p><code>Q2EA</code> converts from Quaternions (Q) to Euler Angles (EA) based on D. M.
Henderson (1977).
<code>Q2EA.Xiao</code> is the algorithm by J. Xiao (2013) for the Princeton Vision 
Toolkit - included here to allow reproducible research.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q2EA(Q, EulerOrder='zyx', tol = 10 * .Machine$double.eps, ichk = FALSE, 
ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q2EA_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="Q2EA_+3A_eulerorder">EulerOrder</code></td>
<td>

<p>Euler Order (xyx, yzy, zxz, xzx, yxy, zyz, xyz, yzx, zxy, xzy, yxz, zyx).
</p>
</td></tr>
<tr><td><code id="Q2EA_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices 
or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="Q2EA_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="Q2EA_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euler Angles (EA) xyz &lt;=&gt; x(roll) y(pitch) z(yaw)
Type 1 Rotations (Tait-Bryan angles): xyz - xzy - yxz - yzx - zyx - zxy
Singular if second rotation angle is -90 or 90 degrees.
Type 2 Rotations (proper Euler angles): xyx - xzx - yxy - yzy - zxz - zyz
Singular if second rotation angle is 0 or 180 degrees.
</p>
<p>Euler angles [psi, theta, phi] range from -90 to 90 degrees.
Tait-Bryan angles [psi, theta, phi] range from 0 to 180 degrees.
Angles about Euler vectors range from 0 to 180 degrees.
</p>


<h3>Value</h3>

<p>Euler Angles (EA) vector [psi, theta, phi].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>D. M. Henderson, 1977
Shuttle Program. Euler Angles, Quaternions, and Transformation Matrices Working
Relationships.
National Aeronautics and Space Administration (NASA), N77-31234/6
</p>
<p>J. Xiao, 2013
Princeton Vision Toolkit. Available from:
<a href="http://vision.princeton.edu/code.html">http://vision.princeton.edu/code.html</a>
<a href="http://vision.princeton.edu/pvt/GCBreader/quaternion.m">http://vision.princeton.edu/pvt/GCBreader/quaternion.m</a>
</p>
<p>John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler
vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EA2Q">EA2Q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q2EA(Q,'xyx')

## End(Not run)
</code></pre>

<hr>
<h2 id='Q2EV'>
Convert from rotation Quaternions to Euler Vectors
</h2><span id='topic+Q2EV'></span>

<h3>Description</h3>

<p><code>Q2EV</code> converts from Quaternions (Q) to Euler Vectors (EV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q2EV(Q, tol = 10 * .Machine$double.eps, ichk = FALSE, ignoreAllChk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q2EV_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="Q2EV_+3A_tol">tol</code></td>
<td>

<p>Tolerance from deviations from unity for the determinant of rotation matrices or the the vector length for unitary vectors.
</p>
</td></tr>
<tr><td><code id="Q2EV_+3A_ichk">ichk</code></td>
<td>

<p>Logical, FALSE=disables near-singularity warnings.
</p>
</td></tr>
<tr><td><code id="Q2EV_+3A_ignoreallchk">ignoreAllChk</code></td>
<td>

<p>Logical, TRUE=disables all warnings and error checks (use with caution!).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euler Vectors (EV) vector [m1, m2, m3, MU].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>by John Fuller, 14 Jul 2008
SpinCalc, Function to Convert between DCM, Euler angles, Quaternions, and Euler vectors.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm--euler-angles--quaternions--and-euler-vectors">http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm&ndash;euler-angles&ndash;quaternions&ndash;and-euler-vectors</a>
</p>
<p>Paolo de Leva, 01 May 2013
SpinConv, Conversion from a rotation representation type to another.
<a href="http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv">http://www.mathworks.com/matlabcentral/fileexchange/41562-spinconv</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EV2Q">EV2Q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q2EV(Q)
</code></pre>

<hr>
<h2 id='Q2GL'>
Convert from rotation Quaternions to OpenGL rotation matrix
</h2><span id='topic+Q2GL'></span>

<h3>Description</h3>

<p><code>DCM2EA</code> converts from Quaternions (Q) to OpenGL rotation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q2GL(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q2GL_+3A_q">Q</code></td>
<td>

<p>rotation Quaternions (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>OpenGL rotation matrix 4x4xN.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>References</h3>

<p>Python - IMU Brick 2012
<a href="http://www.tinkerforge.com/doc/Software/Bricks/IMU_Brick_Python.html">http://www.tinkerforge.com/doc/Software/Bricks/IMU_Brick_Python.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isPureRotationMatrix">isPureRotationMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q2GL(Q)
</code></pre>

<hr>
<h2 id='QangularDifference'>
Angular difference between 2 quaternions
</h2><span id='topic+QangularDifference'></span>

<h3>Description</h3>

<p><code>QangularDifference</code> returns the angular difference between 2 quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QangularDifference(Q1, Q2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QangularDifference_+3A_q1">Q1</code></td>
<td>
<p>Quaternion (Q) vector [q1, q2, q3, q4].</p>
</td></tr>
<tr><td><code id="QangularDifference_+3A_q2">Q2</code></td>
<td>
<p>Quaternion (Q) vector [q1, q2, q3, q4].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real value = angular difference between 2 quaternions.</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q1 &lt;- Qrandom()
Q2 &lt;- Qrandom()
QangularDifference(Q1, Q2)
</code></pre>

<hr>
<h2 id='Qconj'>
Quaternion conjugate
</h2><span id='topic+Qconj'></span>

<h3>Description</h3>

<p><code>Qconj</code> performs a quaternion conjugate operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qconj(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qconj_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Conjugate quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Qconj(Q)
</code></pre>

<hr>
<h2 id='Qinv'>
Quaternion inverse
</h2><span id='topic+Qinv'></span>

<h3>Description</h3>

<p><code>Qinv</code> calculated the quaternion inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qinv(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qinv_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion inverse (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Qinv(Q)
</code></pre>

<hr>
<h2 id='Qlerp'>
Linear quaternion interpolation
</h2><span id='topic+Qlerp'></span><span id='topic+Qslerp'></span><span id='topic+QslerpNoInvert'></span><span id='topic+Qspline'></span><span id='topic+Qsquad'></span><span id='topic+Qbezier'></span>

<h3>Description</h3>

<p><code>Qlerp</code> linear quaternion interpolation.
<code>Qslerp</code> spherical linear interpolation.
<code>QslerpNoInvert</code> version of slerp, used by squad, that does not check for theta &gt; 90.
<code>Qspline</code> spherical cubic interpolation.
<code>Qsquad</code> spherical and Quadrangle linear interpolation.
<code>Qbezier</code> Shoemake-Bezier interpolation using De Castlejau algorithm.
<code>Qspline</code> for 3 quaternions, qn-1,qn and qn+1, calculate a control point to be used in spline interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qlerp(Q1, Q2, fracT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qlerp_+3A_q1">Q1</code></td>
<td>
<p>Quaternion (Q) vector [q1, q2, q3, q4].</p>
</td></tr>
<tr><td><code id="Qlerp_+3A_q2">Q2</code></td>
<td>
<p>Quaternion (Q) vector [q1, q2, q3, q4].</p>
</td></tr>
<tr><td><code id="Qlerp_+3A_fract">fracT</code></td>
<td>
<p>Fraction of .</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Zero or one-valued quaternion (Q) vector [q1, q2, q3, q4] or matrix n x 4.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q1 &lt;- Qrandom()
Q2 &lt;- Qrandom()
Qlerp(Q1, Q2, 0.1)
</code></pre>

<hr>
<h2 id='Qlog'>
Quaternion logarithm
</h2><span id='topic+Qlog'></span><span id='topic+Qexp'></span>

<h3>Description</h3>

<p><code>Qlog</code> performs a quaternion logarithm operation.
<code>Qexp</code> performs a quaternion exponential operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qlog(Q)
Qexp(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qlog_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Result quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Qlog(Q)
Qexp(Q)
</code></pre>

<hr>
<h2 id='Qnorm'>
Norm of a quaternion
</h2><span id='topic+Qnorm'></span>

<h3>Description</h3>

<p><code>Qnorm</code> calculates the norm of a quaternion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qnorm(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qnorm_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Norm of the quaternion.
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Qnorm(Q)
</code></pre>

<hr>
<h2 id='Qnormalize'>
Quaternion normalization
</h2><span id='topic+Qnormalize'></span>

<h3>Description</h3>

<p><code>Qnormalize</code> performs a quaternion normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qnormalize(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qnormalize_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Normalized quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Qnormalize(Q)
</code></pre>

<hr>
<h2 id='Qrandom'>
Generate uniform random unit quaternions
</h2><span id='topic+Qrandom'></span>

<h3>Description</h3>

<p><code>Qrandom</code> generates uniform random unit quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qrandom(n=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qrandom_+3A_n">n</code></td>
<td>

<p>Optional integer for the number of generated quaternions, default = 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Uniform random unit quaternion (Q) vector [q1, q2, q3, q4] or matrix n x 4.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qrandom()
Qrandom(5)
</code></pre>

<hr>
<h2 id='Qrot'>
Updates current attitude quaternion
</h2><span id='topic+Qrot'></span>

<h3>Description</h3>

<p><code>Qrot</code> updates the current attitude quaternion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qrot(Q, w, dT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qrot_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="Qrot_+3A_w">w</code></td>
<td>

<p>Angular rate values [wx, wy, wz].
</p>
</td></tr>
<tr><td><code id="Qrot_+3A_dt">dT</code></td>
<td>

<p>Inverse of update rate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Updated quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
w &lt;- c(0.1, 0.2, 0.3)
dT &lt;- -.12
Qrot(Q,w,dT)
</code></pre>

<hr>
<h2 id='Qzero'>
Generate zero-valued quaternions
</h2><span id='topic+Qzero'></span><span id='topic+Qone'></span>

<h3>Description</h3>

<p><code>Qzero</code> generates zero-valued quaternions.
<code>Qone</code> generates one-valued quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qzero(n=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qzero_+3A_n">n</code></td>
<td>

<p>Optional integer for the number of generated quaternions, default = 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Zero or one-valued quaternion (Q) vector [q1, q2, q3, q4] or matrix n x 4.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qzero()
Qzero(5)
Qone()
Qone(5)
</code></pre>

<hr>
<h2 id='vectQrot'>
Rotate a vector by a quaternion
</h2><span id='topic+vectQrot'></span>

<h3>Description</h3>

<p><code>vectQrot</code> performs a vector rotation by a quaternion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectQrot(Q, rr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectQrot_+3A_q">Q</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="vectQrot_+3A_rr">rr</code></td>
<td>

<p>Vector [x, y, z].
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rotated vector [x, y, z].
</p>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
v &lt;- c(1, 2, 3)
vectQrot(Q, v)
</code></pre>

<hr>
<h2 id='z1'>
Quaternion multiplication
</h2><span id='topic++25Q+2A+25'></span>

<h3>Description</h3>

<p><code>%Q*%</code> performs a quaternion multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1 %Q*% Q2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z1_+3A_q1">Q1</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="z1_+3A_q2">Q2</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion result of multiplication (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q %Q*% Q

## End(Not run)
</code></pre>

<hr>
<h2 id='z2'>
Quaternion division
</h2><span id='topic++25Q+2F+25'></span>

<h3>Description</h3>

<p><code>%Q/%</code> performs a quaternion division.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1 %Q/% Q2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z2_+3A_q1">Q1</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="z2_+3A_q2">Q2</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion result of division (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q %Q/% Q

## End(Not run)
</code></pre>

<hr>
<h2 id='z3'>
Quaternion subtraction
</h2><span id='topic++25Q-+25'></span>

<h3>Description</h3>

<p><code>%Q-%</code> performs a quaternion subtraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1 %Q-% Q2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z3_+3A_q1">Q1</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="z3_+3A_q2">Q2</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion result of subtraction (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q %Q-% Q

## End(Not run)
</code></pre>

<hr>
<h2 id='z4'>
Quaternion addition
</h2><span id='topic++25Q+2B+25'></span>

<h3>Description</h3>

<p><code>%Q+%</code> performs a quaternion addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1 %Q+% Q2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z4_+3A_q1">Q1</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="z4_+3A_q2">Q2</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion sum (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q %Q+% Q

## End(Not run)
</code></pre>

<hr>
<h2 id='z5'>
Quaternion dot product
</h2><span id='topic++25Q.+25'></span>

<h3>Description</h3>

<p><code>%Q.%</code> performs a quaternion dot product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q1 %Q.% Q2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z5_+3A_q1">Q1</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
<tr><td><code id="z5_+3A_q2">Q2</code></td>
<td>

<p>Quaternion (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>

<p>Quaternion result of dot product (Q) vector [q1, q2, q3, q4].
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Gama
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Q &lt;- c(-0.1677489, -0.7369231, -0.3682588, 0.5414703)
Q %Q.% Q

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
