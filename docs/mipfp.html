<!DOCTYPE html><html><head><title>Help for package mipfp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mipfp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mipfp-package'>
<p>Multidimensional Iterative Proportional Fitting and Alternative Models</p></a></li>
<li><a href='#Array2Vector'>
<p>Transforming an array to a vector</p></a></li>
<li><a href='#coef.mipfp'>
<p>Extract the coefficients of the estimates from an object of class mipfp</p></a></li>
<li><a href='#CompareMaxDev'>
<p>Comparing deviations of mipfp objects</p></a></li>
<li><a href='#ComputeA'>
<p>Computes the marginal matrix A and margins vector m of an estimation problem</p></a></li>
<li><a href='#confint.mipfp'>
<p>Computing confidence intervals for the mipfp estimates</p></a></li>
<li><a href='#Corr2Odds'><p>Converting correlation to odds ratio</p></a></li>
<li><a href='#Corr2PairProbs'><p>Converting correlation to pairwise probability</p></a></li>
<li><a href='#error.margins'>
<p>Extracts the deviation between every target and generated margin</p></a></li>
<li><a href='#Estimate'>
<p>Update an N-way table given target margins</p></a></li>
<li><a href='#expand'>
<p>Expand a Table in a Data Frame</p></a></li>
<li><a href='#flat'>
<p>Flatten a table, array or matrix</p></a></li>
<li><a href='#GetConfInt'>
<p>Computing confidence intervals for the estimated counts and probabilities</p>
(deprecated)</a></li>
<li><a href='#GetLinInd'>
<p>Extracting the linearly independant columns from a matrix</p></a></li>
<li><a href='#gof.estimates'>
<p>Wald, Log-likelihood ratio and Person Chi-square statistics for mipfp object</p></a></li>
<li><a href='#Ipfp'>
<p>Multidimensional Iterative Proportional Fitting</p></a></li>
<li><a href='#IpfpCov'>
<p>Covariance matrix of the estimators produced by Ipfp (deprecated)</p></a></li>
<li><a href='#ObtainModelEstimates'><p>Estimating a contingency table using model-based approaches</p></a></li>
<li><a href='#ObtainMultBinaryDist'><p>Generating a multivariate Bernoulli joint-distribution</p></a></li>
<li><a href='#Odds2Corr'><p>Converting odds ratio to correlation</p></a></li>
<li><a href='#Odds2PairProbs'><p>Converting odds ratio to pairwise probability</p></a></li>
<li><a href='#Qaqish'>
<p>Qaqish</p></a></li>
<li><a href='#RMultBinary'><p>Simulating a multivariate Bernoulli distribution</p></a></li>
<li><a href='#spnamur'>
<p>Synthetic population of Namur (Belgium)</p></a></li>
<li><a href='#summary.mipfp'>
<p>Summarizing objects of class mipfp</p></a></li>
<li><a href='#vcov.mipfp'>
<p>Calculate variance-covariance matrix for mipfp objects</p></a></li>
<li><a href='#Vector2Array'>
<p>Transforming a vector to an array</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multidimensional Iterative Proportional Fitting and Alternative
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Johan Barthelemy [aut, cre],
  Thomas Suesse [aut],
  Mohammad Namazi-Rad [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johan Barthelemy &lt;johan@uow.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the iterative proportional fitting (IPFP), 
    maximum likelihood, minimum chi-square and weighted least squares procedures
    for updating a N-dimensional array with respect to given target marginal 
    distributions (which, in turn can be multidimensional). The package also
    provides an application of the IPFP to simulate multivariate Bernoulli
    distributions.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>cmm, Rsolnp, numDeriv, R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jojo-/mipfp">https://github.com/jojo-/mipfp</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-29 00:15:56 UTC; johan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-29 08:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='mipfp-package'>
Multidimensional Iterative Proportional Fitting and Alternative Models
</h2><span id='topic+mipfp-package'></span><span id='topic+mipfp'></span>

<h3>Description</h3>

<p>An implementation of several methods for updating an initial <code class="reqn">N</code>-dimensional
array (called a seed) with respect to given target marginal distributions. 
Those targets can also be multi-dimensional. The procedures are also able to 
estimate a (multi-dimensional) contingency table (encoded as an array) 
matching a given set of (multi-dimensional) margins. In that case, each cell 
of the seed must simply be set to 1.
</p>
<p>The package provides the iterative proportional fitting procedure (IPFP), also 
known as the RAS algorithm in economics and matrix raking or matrix scaling in 
computer science. Additionnaly several alternative estimating methods to 
the IPFP are also included, namely the maximum likelihood (ML), minimum 
chi-squared (CHI2) and weighted least squares (WLSQ) model-based approaches.
</p>
<p>The package also includes an application of the IPFP to simulate and estimate 
the parameters of multivariate Bernoulli distributions.
</p>
<p>Finally a function extracting the linearly independant columns from a matrix,
hence returning a matrix of full rank is provided.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mipfp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-08-29</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> cmm, numDeriv, Rsolnp, R(&gt;= 2.10.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package provides an implementation of several fitting procedures for 
updating a <code class="reqn">N</code>-dimensional array with respect to given target marginal 
distributions. Those targets can also multi-dimensional. The available methods
are listed herehunder.
</p>

<ul>
<li><p> The function <code><a href="#topic+Ipfp">Ipfp</a></code> provides the iterative 
proportionnal fitting Procedure.
</p>
</li>
<li><p> Maximum likelihood, minimum Chi-square and weighted least squares
approaches are availables in the function
<a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a>.
</p>
</li></ul>

<p>The function <code><a href="#topic+Estimate">Estimate</a></code> provides an interface to
these two methods. Each of them returns an object of class <code>mipfp</code>, but
<code><a href="#topic+Estimate">Estimate</a></code> should be the preferred constructor.
</p>
<p>The package provides several methods and functions to extract various 
information from the resulting object such as as the variance-covariance matrix 
of the estimated cell probabilities or counts using either the Lang's (2004) or 
the Delta method (Little and Wu, 1991) (<code><a href="#topic+vcov.mipfp">vcov</a></code>),
the confidence interval of the estimates 
(<code><a href="#topic+confint.mipfp">confint</a></code>), the comparison of the deviations
(<code><a href="#topic+CompareMaxDev">CompareMaxDev</a></code>), etc. Note that the functions 
starting with a lower case are S3 methods for objects of class <code>mipfp</code> 
while the one starting with an upper case are general functions.
</p>
<p>The package also includes an application of the IPFP to simulate and estimate 
the parameters of multivariate Bernoulli distributions, respectively in the
functions <code><a href="#topic+RMultBinary">RMultBinary</a></code> and 
<code><a href="#topic+ObtainMultBinaryDist">ObtainMultBinaryDist</a></code>. In addition, the functions 
<code><a href="#topic+Corr2Odds">Corr2Odds</a></code>, <code><a href="#topic+Odds2Corr">Odds2Corr</a></code>, 
<code><a href="#topic+Corr2PairProbs">Corr2PairProbs</a></code>, <code><a href="#topic+Odds2PairProbs">Odds2PairProbs</a></code> are in 
turn responsible for converting correlation to odds ratio, odds ratio to 
correlation, correlation to pairwise probability and odds ratio to pairwise 
probability.
</p>
<p>Finally, auxillary functions are also provided. <code><a href="#topic+expand">expand</a></code> 
expands a multi-dimensional contingency table (stored in <code>table</code>) into a
data frame of individual recors. <code><a href="#topic+Array2Vector">Array2Vector</a></code> and 
<code><a href="#topic+Vector2Array">Vector2Array</a></code> transforms an array to a vector and 
vice-versa. <code><a href="#topic+flat">flat</a></code> flattens multi-dimensional objects 
for pretty printing. The function <code><a href="#topic+GetLinInd">GetLinInd</a></code> extracting the 
linearly independant columns from a matrix (using QR decomposition) and 
returning a matrix of full rank is also provided. 
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy and Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Bacharach, M. (1965).
Estimating Nonnegative Matrices from Marginal Data.
<em>International Economic Review</em> (Blackwell Publishing) 6 (3): 294-310.
</p>
<p>Barthelemy, J., Suesse, T. (2018).
mipfp: An R Package for Multidimensional Array Fitting and Simulating Multivariate Bernoulli Distributions.
<em>Journal of Statistical Software, Code Snippets</em> 86 (2): 1-20, doi: 10.18637/jss.v086.c02.
</p>
<p>Bishop, Y. M. M., Fienberg, S. E., Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice.</em>
MIT Press. ISBN 978-0-262-02113-5.
</p>
<p>Deming, W. E., Stephan, F. F. (1940).
On a Least Squares Adjustment of a Sampled Frequency Table When the Expected
Marginal Totals are Known.
<em>Annals of Mathematical Statistics</em> 11 (4): 427-444.
</p>
<p>Fienberg, S. E. (1970).
An Iterative Procedure for Estimation in Contingency Tables.
<em>Annals of Mathematical Statistics</em> 41 (3): 907-917.
</p>
<p>Golub, G. H., Van Loan C. F. (2012)
<em>Matrix Computations. Third Edition.</em>
Johns Hopkins University Press.
</p>
<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em>  47 (3): 209-215.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and sampled 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012). 
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>
<p>Stephan, F. F. (1942).
Iterative method of adjusting frequency tables when expected margins are known.
<em>Annals of Mathematical Statistics</em> 13 (2): 166-178.
</p>


<h3>See Also</h3>

<p><code>ipfp</code> for a package implementing the ipfp to solve problems of the form
<code class="reqn">Ax = b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generation of an intial 2-ways table to be updated
seed &lt;- array(1, dim=c(2, 2))
# desired targets (margins)
target.row &lt;- c(87, 13)
target.col &lt;- c(52, 48)
# storing the margins in a list
target.data &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
target.list &lt;- list(1, 2)
# calling the fitting methods
r.ipfp &lt;- Ipfp(seed, target.list, target.data)
r.ml &lt;- ObtainModelEstimates(seed, target.list, target.data, method = "ml")
r.chi2 &lt;- ObtainModelEstimates(seed, target.list, target.data, method = "chi2")
r.lsq &lt;- ObtainModelEstimates(seed, target.list, target.data, method = "lsq")
</code></pre>

<hr>
<h2 id='Array2Vector'>
Transforming an array to a vector
</h2><span id='topic+Array2Vector'></span>

<h3>Description</h3>

<p>Transform a N-dimensional array a to vector. The transformation is done
assuming that the last index of the array moves fastest. For instance, an array
<code class="reqn">a</code> of dimensions (2,2,2) will produce the vector
<code class="reqn">v = (a_{111}, a_{112}, a_{113}, a_{121}, a_{122},\ldots,a_{333})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Array2Vector(arr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Array2Vector_+3A_arr">arr</code></td>
<td>

<p>The array to be transformed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector filled with the data of the input array <code>arr</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The inverse transformation is performed with the function
<code><a href="#topic+Vector2Array">Vector2Array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating an array of dimension (3,3,3)
a &lt;- array(seq(1:27),dim=c(3,3,3))
# transforming it into a vector
v &lt;- Array2Vector(a)
</code></pre>

<hr>
<h2 id='coef.mipfp'>
Extract the coefficients of the estimates from an object of class mipfp
</h2><span id='topic+coef.mipfp'></span>

<h3>Description</h3>

<p>This method extracts the coefficients of estimates of an mipfp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
coef(object, prop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mipfp_+3A_object">object</code></td>
<td>

<p>An object of class <code>mipfp</code>
</p>
</td></tr>
<tr><td><code id="coef.mipfp_+3A_prop">prop</code></td>
<td>

<p>If this Boolean is set to <code>TRUE</code> then the method will return
the estimated probabilities. Otherwise, it will return the estimated counts.
Default is <code>False</code>.
</p>
</td></tr>
<tr><td><code id="coef.mipfp_+3A_...">...</code></td>
<td>

<p>Not used.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients of the estimates extracted from the <code>mipfp</code> object 
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992)
<em>Statistical Models in S.</em>
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# estimating a table using ipfp
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data)
# exctracting and printing the coefficient of the estimates
print(coef(r.ipfp))
</code></pre>

<hr>
<h2 id='CompareMaxDev'>
Comparing deviations of mipfp objects
</h2><span id='topic+CompareMaxDev'></span>

<h3>Description</h3>

<p>This function compares either the margins errors from different <code>mipfp</code> 
objects or the absolute maximum deviation between a given table and the 
estimates in the mipfp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareMaxDev(list.mipfp = list(), true.table = NULL, echo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareMaxDev_+3A_list.mipfp">list.mipfp</code></td>
<td>

<p>The list produced by the function <code><a href="#topic+Estimate">Estimate</a></code>.
</p>
</td></tr>
<tr><td><code id="CompareMaxDev_+3A_true.table">true.table</code></td>
<td>

<p>When provided, the estimates contained in the <code>mipfp</code> objects in the 
list <code>list.mipfp</code> are compared against this table. It is an optional
argument.
</p>
</td></tr>
<tr><td><code id="CompareMaxDev_+3A_echo">echo</code></td>
<td>

<p>Verbose parameter. If <code>TRUE</code>, the function prints what is being 
compared. Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with as many rows as the number of mipfp objects in <code>list.mipfp</code>. 
Each row details the margins errors or the maximum absolute deviation of 
one <code>mipfp</code> object.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The estimation function <code><a href="#topic+Estimate">Estimate</a></code>.
</p>
<p>This function is used by 
<code><a href="#topic+error.margins.mipfp">error.margins.mipfp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10% sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying the different fitting methods
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data,  method = "ipfp")
r.ml   &lt;- Estimate(seed = seed.table, target.list = tgt.list.dims, 
                   target.data = tgt.data, method = "ml")
r.chi2 &lt;- Estimate(seed = seed.table, target.list = tgt.list.dims, 
                   target.data = tgt.data, method = "chi2")
r.lsq  &lt;- Estimate(seed = seed.table, target.list = tgt.list.dims, 
                   target.data = tgt.data, method = "lsq")
# print the maximum absolute deviation between targets and generated margins
CompareMaxDev(list(r.ipfp,r.ml,r.chi2,r.lsq), echo = TRUE)
# compute the maximum absolute deviation between the true and estimated tables
CompareMaxDev(list(r.ipfp,r.ml,r.chi2,r.lsq), echo = TRUE, 
              true.table = true.table)
</code></pre>

<hr>
<h2 id='ComputeA'>
Computes the marginal matrix A and margins vector m of an estimation problem
</h2><span id='topic+ComputeA'></span>

<h3>Description</h3>

<p>Given a set of marginal target constraints and the dimension of the array
<code class="reqn">X</code> to wich the targets relate to, this function computes the matrix 
<code class="reqn">A</code> of full rank and vector <code class="reqn">m</code> such that
</p>
<p style="text-align: center;"><code class="reqn">A^T \pi = (m, 1)^T</code>
</p>

<p>where vector <code class="reqn">m</code> contains all components but one of every target and
<code class="reqn">\pi</code> is a vector of the (unknow) components of <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeA(dim.arr, target.list, target.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeA_+3A_dim.arr">dim.arr</code></td>
<td>

<p>The dimension of the array <code class="reqn">X</code> to which the margins are applied.
</p>
</td></tr>
<tr><td><code id="ComputeA_+3A_target.list">target.list</code></td>
<td>

<p>A list of the target margins provided in target.data. Each 
component of the list is an array whose cells indicates which
dimension the corresponding margin relates to.
</p>
</td></tr>
<tr><td><code id="ComputeA_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target margins. Each 
component of the list is an array storing a margin. The list 
order must follow the one defined in target.list. Note that 
the cells of the arrays must be non-negative.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are defined below.
</p>
<table>
<tr><td><code>marginal.matrix</code></td>
<td>

<p>The marginal matrix.
</p>
</td></tr>
<tr><td><code>margins</code></td>
<td>

<p>A vector containing the margins associated with A.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom of the problem.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy &lt;johan@uow.edu.au&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="cmm.html#topic+MarginalMatrix">MarginalMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# computing the associated marginal matrix and margins vector
res.marg &lt;- ComputeA(dim(seed.table), tgt.list.dims, tgt.data)
print(res.marg)
</code></pre>

<hr>
<h2 id='confint.mipfp'>
Computing confidence intervals for the mipfp estimates
</h2><span id='topic+confint.mipfp'></span>

<h3>Description</h3>

<p>This function computes the (asymptotic) Wald confidence intervals at a given 
significance level for the estimates of an <code>mipfp</code> object generated by
<code><a href="#topic+Estimate">Estimate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
confint(object, parm, level = 0.95, prop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.mipfp_+3A_object">object</code></td>
<td>

<p>The <code>mipfp</code> object containing the estimates.
</p>
</td></tr>
<tr><td><code id="confint.mipfp_+3A_parm">parm</code></td>
<td>

<p>A specification of which estimates are to be given confidence intervals, 
either a vector of numbers or a vector of names. If missing, all estimates
are considered.
</p>
</td></tr>
<tr><td><code id="confint.mipfp_+3A_level">level</code></td>
<td>

<p>The confidence level required.
</p>
</td></tr>
<tr><td><code id="confint.mipfp_+3A_prop">prop</code></td>
<td>

<p>A boolean indicating if the results should be using counts (<code>FALSE</code>) or
proportion (<code>TRUE</code>). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="confint.mipfp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods (for instance
<code><a href="#topic+vcov.mipfp">vcov.mipfp</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence interval of the estimates <code class="reqn">\hat{X}</code>, at significance
level <code class="reqn">\alpha</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{X} \pm z \left( 1-\frac{\alpha}{2} \right) * 
\hat{\sigma}</code>
</p>

<p>where <code class="reqn">\hat{\sigma}</code> is the standart deviations of 
<code class="reqn">\hat{X}</code>, <code class="reqn">z</code> and 
<code class="reqn">\alpha = 1 - level</code> is the inverse of the cumulative 
distribution function of the standard normal distribution.
</p>


<h3>Value</h3>

<p>A matrix containing the upper and lower bounds for the estimated
counts/probabilities (depending on the value of the <code>prop</code> argument).
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Smithson, M. (2002).
<em>Confidence intervals</em>.
Sage Publications.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint.default">confint</a></code> for the default method to compute 
confidence intervals for model parameters.
<code><a href="#topic+Estimate">Estimate</a></code>, <code><a href="#topic+Ipfp">Ipfp</a></code> and 
<code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code> to generate the
<code>mipfp</code> objects for this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># true contingency (2-way) table
true.table &lt;- array(c(43, 44, 9, 4), dim = c(2, 2))
# generation of sample, i.e. the seed to be updated
seed &lt;- ceiling(true.table / 10)
# desired targets (margins)
target.row &lt;- apply(true.table, 2, sum)
target.col &lt;- apply(true.table, 1, sum)
# storing the margins in a list
target.data &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
target.list &lt;- list(1, 2)
# using ipfp
res &lt;- Estimate(seed, target.list, target.data)
# computing and printing the confidence intervals
print(confint(res))
</code></pre>

<hr>
<h2 id='Corr2Odds'>Converting correlation to odds ratio
</h2><span id='topic+Corr2Odds'></span>

<h3>Description</h3>

<p>For <code class="reqn">K</code> binary (Bernoulli) random variables 
<code class="reqn">X_1</code>, ..., <code class="reqn">X_K</code>, this function transforms the correlation
measure of association <code class="reqn">C_{ij}</code> between every pair
<code class="reqn">(X_i, X_j)</code> to the odds ratio <code class="reqn">O_{ij}</code> where
</p>
<p style="text-align: center;"><code class="reqn">C_{ij} = \frac{cov(X_i, X_j)}{\sqrt{var(X_i) * var(X_j)}}</code>
</p>

<p>and 
</p>
<p style="text-align: center;"><code class="reqn">
O_{ij} = \frac{P(X_i = 1, X_j = 1) * P(X_i = 0, X_j = 0)}
            {P(X_i = 1, X_j = 0) * P(X_i = 0, X_j = 1)}.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Corr2Odds(corr, marg.probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Corr2Odds_+3A_corr">corr</code></td>
<td>
      
<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th
column represents the correlation <code class="reqn">C_{ij}</code> between variables
<code class="reqn">i</code> and <code class="reqn">j</code>.  
</p>
</td></tr>
<tr><td><code id="Corr2Odds_+3A_marg.probs">marg.probs</code></td>
<td>

<p>A vector with <code class="reqn">K</code> elements of marginal probabilities where the 
<code class="reqn">i</code>-th entry refers to <code class="reqn">P(X_i = 1)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return a list with the correlations and the pairwise probabilities.
</p>
<table>
<tr><td><code>odds</code></td>
<td>

<p>A matrix of the same dimension as <code>corr</code> containing the correlations
</p>
</td></tr>
<tr><td><code>pair.proba</code></td>
<td>

<p>A matrix of the same dimension as <code>corr</code> containing the pairwise 
probabilities.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em> 47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012).
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Corr2Odds">Corr2Odds</a></code> for converting correlation to odds 
ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># correlation matrix from Qaqish et al. (2012)
cr &lt;- matrix(c( 1.000, -0.215, 0.144, 0.107,
               -0.215,  1.000, 0.184, 0.144,
                0.144,  0.184, 1.000, 0.156,
                0.107,  0.144, 0.156, 1.000), nrow = 4, ncol = 4, byrow = TRUE)
rownames(cr) &lt;- colnames(cr) &lt;- c("Parent1", "Parent2", "Sibling1", "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# converting correlation to odds ratio and getting pairwise probabilities
or &lt;- Corr2Odds(corr = cr, marg.probs = p)
print(or)
</code></pre>

<hr>
<h2 id='Corr2PairProbs'>Converting correlation to pairwise probability
</h2><span id='topic+Corr2PairProbs'></span>

<h3>Description</h3>

<p>For <code class="reqn">K</code> binary (Bernoulli) random variables 
<code class="reqn">X_1</code>, ..., <code class="reqn">X_K</code>, this function transforms the correlation
measure of association <code class="reqn">C_{ij}</code> between every pair 
<code class="reqn">(X_i, X_j)</code> to the pairwise probability 
<code class="reqn">P(X_i = 1, X_j = 1)</code>, where <code class="reqn">C_{ij}</code> is
defined as
</p>
<p style="text-align: center;"><code class="reqn">
C_{ij} = \frac{cov(X_i, X_j)}{\sqrt(var(X_i) * var(X_j))}.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Corr2PairProbs(corr, marg.probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Corr2PairProbs_+3A_corr">corr</code></td>
<td>

<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th
column represents the correlation <code class="reqn">C_{ij}</code> between variables
<code class="reqn">i</code> and <code class="reqn">j</code>. 
</p>
</td></tr>
<tr><td><code id="Corr2PairProbs_+3A_marg.probs">marg.probs</code></td>
<td>

<p>A vector with <code class="reqn">K</code> elements of marginal probabilities where the 
<code class="reqn">i</code>-th entry refers to <code class="reqn">P(X_i = 1)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimension as <code>corr</code> containing the pairwise 
probabilities
</p>


<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em>  47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012). 
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Odds2PairProbs">Odds2PairProbs</a></code> for converting odds ratio 
to pairwise probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># correlation matrix from Qaqish et al. (2012)
corr &lt;- matrix(c( 1.000, -0.215, 0.144, 0.107,
                 -0.215,  1.000, 0.184, 0.144,
                  0.144,  0.184, 1.000, 0.156,
                  0.107,  0.144, 0.156, 1.000), 
                  nrow = 4, ncol = 4, byrow = TRUE)
rownames(corr) &lt;- colnames(corr) &lt;- c("Parent1", "Parent2", "Sibling1", 
                                      "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# getting the pairwise probabilities
pp &lt;- Corr2PairProbs(cor = corr, marg.probs = p)
print(pp)
</code></pre>

<hr>
<h2 id='error.margins'>
Extracts the deviation between every target and generated margin
</h2><span id='topic+error.margins'></span><span id='topic+error.margins.default'></span><span id='topic+error.margins.mipfp'></span>

<h3>Description</h3>

<p>This method returns the maximum deviation between each generated and 
desired margins of the input argument. It corresponds to the absolute
maximum deviation between each target margin used to generate the estimates
in the mipfp object and the generated one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
error.margins(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error.margins_+3A_object">object</code></td>
<td>

<p>An object of class <code>mipfp</code>.
</p>
</td></tr>
<tr><td><code id="error.margins_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods. See 
<code><a href="#topic+CompareMaxDev">CompareMaxDev</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the absolute maximum deviations for each margin.
</p>


<h3>Note</h3>

<p>It is an alias for <code><a href="#topic+CompareMaxDev">CompareMaxDev</a></code> when
only one object is passed to the function and the verbose parameter is set to
<code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The estimation function <code><a href="#topic+Estimate">Estimate</a></code>.
</p>
<p>This function relies on 
<code><a href="#topic+CompareMaxDev">CompareMaxDev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10% sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying a fitting method
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data,  method = "ipfp")
# print the maximum absolute deviation between targets and generated margins
print(error.margins(r.ipfp))
</code></pre>

<hr>
<h2 id='Estimate'>
Update an N-way table given target margins
</h2><span id='topic+Estimate'></span><span id='topic+print.mipfp'></span>

<h3>Description</h3>

<p>This function provides several estimating methods to up multiway table 
(referred as the seed) subject to known constrains/totals: Iterative 
proportional fitting procedure (ipfp), maximum likelihood method (ml), minimum 
chi-squared (chi2) and weighted least squares (lsq). Note that the targets can 
also be multi-dimensional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estimate(seed, target.list, target.data, method = "ipfp", keep.input = FALSE,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estimate_+3A_seed">seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative if <code>method</code> is <code>ipfp</code> or strictly positive
when <code>method</code> is <code>ml</code>, <code>lsq</code> or <code>chi2</code>.
</p>
</td></tr>
<tr><td><code id="Estimate_+3A_target.list">target.list</code></td>
<td>

<p>A list of dimensions of the marginal target constrains in
<code>target.data</code>. Each component of the list is an array whose cells 
indicate which dimension the corresponding margin relates to.
</p>
</td></tr>
<tr><td><code id="Estimate_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target marginal tables. Each
component of the list is an array storing a margin.
The list order must follow the ordering defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td></tr>
<tr><td><code id="Estimate_+3A_method">method</code></td>
<td>

<p>An optional character string indicating which method is to be used to
update the <code>seed</code>. This must be on of the strings &quot;ipfp&quot;, &quot;ml&quot;,
&quot;chi2&quot;, or &quot;lsq&quot;. Default is &quot;ipfp&quot;.
</p>
</td></tr>
<tr><td><code id="Estimate_+3A_keep.input">keep.input</code></td>
<td>

<p>A Boolean indicating if <code>seed</code>, <code>target.data</code> and 
<code>target.list</code> when set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="Estimate_+3A_...">...</code></td>
<td>

<p>Additionals argument that can be passed to the functions 
<a href="#topic+Ipfp">Ipfp</a> and 
<a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a>. See their 
respective documentation for more details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mipfp</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>x.hat</code></td>
<td>

<p>An array with the same dimension of <code>seed</code> whose margins match those
specified in <code>target.list</code>.
</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>

<p>An array with the same dimension of <code>x.hat</code> containing the updated
cell probabilities, i.e. <code>x.hat / sum(x.hat)</code>.
</p>
</td></tr>
<tr><td><code>error.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin.
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td></tr>
<tr><td><code>evol.stp.crit</code></td>
<td>

<p>The evolution of the stopping criterion over the iterations (if selected
<code>method</code> is <code>"ipfp"</code>)).
</p>
</td></tr>
<tr><td><code>solnp.res</code></td>
<td>

<p>The estimation process uses the <code>solnp</code> optimisation function from 
the R package Rsolnp and <code>solnp.res</code> is the corresponding object 
returned by the solver (if selected <code>method</code> is not <code>"ipfp"</code>).
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The selected method for estimation.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td></tr>
</table>
<p>The will be also added if <code>keep.input</code> has been set to <code>TRUE</code>: 
<code>seed</code>, <code>target.data</code>, <code>target.list</code>.
</p>


<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li><p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li><p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Bacharach, M. (1965).
Estimating Nonnegative Matrices from Marginal Data.
<em>International Economic Review</em> (Blackwell Publishing) 6 (3): 294-310.
</p>
<p>Bishop, Y. M. M., Fienberg, S. E., Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice.</em>
MIT Press. ISBN 978-0-262-02113-5.
</p>
<p>Deming, W. E., Stephan, F. F. (1940).
On a Least Squares Adjustment of a Sampled Frequency Table When the Expected
Marginal Totals are Known.
<em>Annals of Mathematical Statistics</em> 11 (4): 427-444.
</p>
<p>Fienberg, S. E. (1970).
An Iterative Procedure for Estimation in Contingency Tables.
<em>Annals of Mathematical Statistics</em> 41 (3): 907-917.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and sampled 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>
<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Stephan, F. F. (1942).
Iterative method of adjusting frequency tables when expected margins are known.
<em>Annals of Mathematical Statistics</em> 13 (2): 166-178.
</p>


<h3>See Also</h3>

<p>See the functions <code><a href="#topic+Ipfp">Ipfp</a></code> and 
<code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code>
for more details about the estimation process.
</p>
<p><code><a href="#topic+summary.mipfp">summary.mipfp</a></code> for summaries,  
<code><a href="#topic+vcov.mipfp">vcov.mipfp</a></code> for the (asymptotic) covariance of 
the estimates and <code><a href="#topic+gof.estimates.mipfp">gof.estimates.mipfp</a></code>
for testing if the seed agrees with the targets.
</p>
<p>The genereric functions <code><a href="#topic+print.mipfp">print</a></code> and
<code><a href="#topic+coef.mipfp">coef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying one fitting method (ipfp)
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data)
print(r.ipfp)
</code></pre>

<hr>
<h2 id='expand'>
Expand a Table in a Data Frame
</h2><span id='topic+expand'></span><span id='topic+expand.default'></span><span id='topic+expand.table'></span>

<h3>Description</h3>

<p>This function takes a multi-dimensionnal contingency table and expands it to a 
data frame containing individual records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(x, ...)

## S3 method for class 'table'
expand(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">x</code></td>
<td>

<p>An object of type <code>table</code> storing a N-dimensial contingency table.
</p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the individual records derived from <code>x</code>.
</p>


<h3>Note</h3>

<p>The function is inspired from the &quot;Cookbook for R&quot;.
</p>
<p>It should also be noted that the cells od <code>x</code> are rounded before being
expanded in a data frame.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Cookbook for R - 
<a href="http://www.cookbook-r.com/Manipulating_data/Converting_between_data_frames_and_contingency_tables/">http://www.cookbook-r.com/Manipulating_data/Converting_between_data_frames_and_contingency_tables/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid</a></code> and <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# create a contingency table
t &lt;- table(spnamur.sub)
# expand the table to a data frame
t.df &lt;- expand(t)
</code></pre>

<hr>
<h2 id='flat'>
Flatten a table, array or matrix
</h2><span id='topic+flat'></span><span id='topic+flat.default'></span><span id='topic+flat.table'></span><span id='topic+flat.array'></span><span id='topic+flat.matrix'></span>

<h3>Description</h3>

<p>This function takes a multidimensional object and flattens it for a pretty 
printing. The row names are the concatenation of the original dimension names 
while the only column stores the initial data of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
flat(x, sep = ".", label = "value", l.names = 0, ...)

## S3 method for class 'table'
flat(x, sep = ".", label = "value", l.names = 0, ...)

## S3 method for class 'matrix'
flat(x, sep = ".", label = "value", l.names = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat_+3A_x">x</code></td>
<td>
 
<p>An array, table or matrix.
</p>
</td></tr>
<tr><td><code id="flat_+3A_sep">sep</code></td>
<td>

<p>The separator used to concatenate the dimension names.
</p>
</td></tr>
<tr><td><code id="flat_+3A_label">label</code></td>
<td>

<p>The name of the column storing the data.
</p>
</td></tr>
<tr><td><code id="flat_+3A_l.names">l.names</code></td>
<td>

<p>If set to a value greater than 0, then the dimnames will be shorten to
a length of <code>l.names</code> characters.
</p>
</td></tr>
<tr><td><code id="flat_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing a flattened version of <code>x</code>.
</p>


<h3>Note</h3>

<p>The function is inspired from the function <code>wrap.array</code> from the package 
<code>R.utils</code> written by Henrik Bengtsson.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The function <code>wrap.array</code> from the <code>R.utils</code> package
(<a href="https://cran.r-project.org/package=R.utils">https://cran.r-project.org/package=R.utils</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data and saving in a 3D-table
data(spnamur, package = "mipfp")
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
tab &lt;- table(spnamur.sub)

# flattening the table
tab.flat &lt;- flat(tab)
print(tab.flat)
</code></pre>

<hr>
<h2 id='GetConfInt'>
Computing confidence intervals for the estimated counts and probabilities
(deprecated)
</h2><span id='topic+GetConfInt'></span>

<h3>Description</h3>

<p>This function computes the (asymptotic) Wald confidence intervals at a given 
significance level for the results generated by <code><a href="#topic+Ipfp">Ipfp</a></code>
and <code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code> (provided 
that their option <code>compute.cov</code> was set to <code>TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetConfInt(list.est, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetConfInt_+3A_list.est">list.est</code></td>
<td>

<p>A list produced either by <code><a href="#topic+Ipfp">Ipfp</a></code> or 
<code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code> containing
the estimated counts and probabilities as well as their associated
standard deviations.
</p>
</td></tr>
<tr><td><code id="GetConfInt_+3A_alpha">alpha</code></td>
<td>

<p>Significance level of the confidence interval corresponding to the
100(1 - <code class="reqn">\alpha</code>)% confidence level.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence interval of the estimates <code class="reqn">\hat{X}</code>, at significance
level <code class="reqn">\alpha</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{X} \pm z \left( 1-\frac{\alpha}{2} \right) * 
\hat{\sigma}</code>
</p>

<p>where <code class="reqn">\hat{\sigma}</code> is the standart deviations of 
<code class="reqn">\hat{X}</code> and <code class="reqn">z</code> is the inverse of the cumulative 
distribution function of the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list of matrices containing the upper and lower bounds for the estimated
counts and probabilities.
</p>
<table>
<tr><td><code>lower.x</code></td>
<td>

<p>Lower bounds of the confidence interval for <code>list.est$x.hat</code>.
</p>
</td></tr>
<tr><td><code>upper.x</code></td>
<td>

<p>Upper bounds of the confidence interval for <code>list.est$x.hat</code>.
</p>
</td></tr>
<tr><td><code>lower.p</code></td>
<td>

<p>lower bounds of the confidence interval for <code>list.est$p.hat</code>.
</p>
</td></tr>
<tr><td><code>upper.p</code></td>
<td>

<p>upper bounds of the confidence interval for <code>list.est$p.hat</code>.
</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note: this function is deprecated, instead use
<code><a href="#topic+confint.mipfp">confint.mipfp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Smithson, M. (2002).
<em>Confidence intervals</em>.
Sage Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimate">Estimate</a></code>, <code><a href="#topic+Ipfp">Ipfp</a></code> and 
<code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code> to generate the
inputs for this function.
</p>
<p>The S3 method <code><a href="#topic+confint.mipfp">confint.mipfp</a></code> for object of 
class <code>mipfp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># true contingency (2-way) table
true.table &lt;- array(c(43, 44, 9, 4), dim = c(2, 2))
# generation of sample, i.e. the seed to be updated
seed &lt;- ceiling(true.table / 10)
# desired targets (margins)
target.row &lt;- apply(true.table, 2, sum)
target.col &lt;- apply(true.table, 1, sum)
# storing the margins in a list
target.data &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
target.list &lt;- list(1, 2)
# calling the Ipfp function
res &lt;- Ipfp(seed, target.list, target.data)
# addint the standart deviations to res (required by GetConfInt)
cov.res &lt;- vcov(res, seed = seed, target.list = target.list, 
                target.data = target.data)
res$p.hat.se &lt;- cov.res$p.hat.se
res$x.hat.se &lt;- cov.res$x.hat.se
# computing and printing the confidence intervals
print(GetConfInt(res))
</code></pre>

<hr>
<h2 id='GetLinInd'>
Extracting the linearly independant columns from a matrix
</h2><span id='topic+GetLinInd'></span>

<h3>Description</h3>

<p>Extracts the linearly dependant columns of matrix to obtain a matrix of full
rank using QR decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLinInd(mat, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLinInd_+3A_mat">mat</code></td>
<td>

<p>The matrix possibly containing linearly dependant columns
</p>
</td></tr>
<tr><td><code id="GetLinInd_+3A_tol">tol</code></td>
<td>

<p>Rank estimation tolerance. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the new matrix and the index of the selected colums.
</p>
<table>
<tr><td><code>mat.li</code></td>
<td>

<p>A matrix made of the linearly independant columns of <code>mat</code>.
</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>

<p>The index of the selected columns.    
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Golub, G. H., Van Loan C. F. (2012)
<em>Matrix Computations. Third Edition.</em>
Johns Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+qr">qr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generation of a matrix with linearly dependant columns
A &lt;- matrix(c(1, 2, 3,
              1, 2, 4,
              1, 2, 8), nrow = 3, ncol = 3, byrow = TRUE)
              
# extracting and printing the linearly independant columns
B &lt;- GetLinInd(A)
print(B)
</code></pre>

<hr>
<h2 id='gof.estimates'>
Wald, Log-likelihood ratio and Person Chi-square statistics for mipfp object
</h2><span id='topic+gof.estimates'></span><span id='topic+gof.estimates.default'></span><span id='topic+gof.estimates.mipfp'></span>

<h3>Description</h3>

<p>This method computes three statistics to perform a test wheter the seed
agrees with the target data. The statistics are the Wilk's log-likelihood ratio
statistic, the Wald statistic and the Person Chi-square statistic.
</p>
<p>The method also returns the associated degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
gof.estimates(object, seed = NULL, target.data = NULL, 
              target.list = NULL, replace.zeros = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.estimates_+3A_object">object</code></td>
<td>

<p>The object of class <code>mipfp</code> containing.
</p>
</td></tr>
<tr><td><code id="gof.estimates_+3A_seed">seed</code></td>
<td>

<p>The seed used to compute the estimates (optional). If not provided, the
method tries to determine the <code>seed</code> automatically.
</p>
</td></tr>
<tr><td><code id="gof.estimates_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target margins. Each component of the 
list is an array storing a margin. The list order must follow the one 
defined in <code>target.list</code>. Note that the cells of the arrays must be 
non-negative (and can even be NA if <code>method = ipfp</code>) (optional). 
If not provided, the method tries to dermine <code>target.data</code>
automatically.
</p>
</td></tr>
<tr><td><code id="gof.estimates_+3A_target.list">target.list</code></td>
<td>

<p>A list of the target margins provided in <code>target.data</code>. Each
component of the list is an array whose cells indicates which dimension the 
corresponding margin relates to (optional). If not provided, the method
tries to determine <code>target.list</code> automatically.
</p>
</td></tr>
<tr><td><code id="gof.estimates_+3A_replace.zeros">replace.zeros</code></td>
<td>

<p>If 0-cells are to be found, then they are replaced with this value.
</p>
</td></tr>
<tr><td><code id="gof.estimates_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is formally expressed as:
</p>
<p style="text-align: center;"><code class="reqn">H_0 ~ : ~ h(\pi) = 0 \quad vs \quad H_1~:~h(\pi) \neq 0</code>
</p>

<p>where <code class="reqn">\pi</code> is the vector of the seed probabilities and 
<code class="reqn">h(x) = A^T x - m</code> with <code class="reqn">A</code> and <code class="reqn">m</code> being
respectively the marginal matrix and the margins vector of the estimation
problem.
</p>
<p>The three statistics are then defined as:
</p>

<ul>
<li><p>Wilk's log-likelihoold ratio
</p>
<p style="text-align: center;"><code class="reqn">G^2 = 2 \sum x_i \ln \frac{\pi_i}{\hat{\pi}_i}</code>
</p>


</li>
<li><p>Wald's statistic
</p>
<p style="text-align: center;"><code class="reqn">W^2 = h(x)^T ( H^T_x D_x H_x)^{-1} h(x)</code>
</p>


</li>
<li><p>Pearson Chi-square
</p>
<p style="text-align: center;"><code class="reqn">\chi^2 = (x - n \hat{\pi})^T D^{-1}_{n\hat{\pi}} (x - n \hat{\pi})</code>
</p>


</li></ul>

<p>where <code class="reqn">x</code> is the vectorization of the <code>seed</code>, 
<code class="reqn">n = \sum x_i</code>, <code class="reqn">D_v</code> is a diagonal matrix 
derived from the vector <code class="reqn">v</code> and <code class="reqn">H</code> denotes the Jacobian evaluated 
in <code class="reqn">\hat{\pi}</code> (the vector of the estimated probabilities) of the 
function <code class="reqn">h(x)</code>.
</p>
<p>The degrees of freedom for these statistics corresponds to the number of
components in <code class="reqn">m</code>.
</p>


<h3>Value</h3>

<p>A list whose elements are detailed below.
</p>
<table>
<tr><td><code>G2</code></td>
<td>

<p>The Log-likelihood statistic.
</p>
</td></tr>
<tr><td><code>W2</code></td>
<td>

<p>The Wald statistic.
</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>

<p>The Pearson chi-squared statistic.
</p>
</td></tr>
<tr><td><code>stats.df</code></td>
<td>

<p>The degrees of freedom for the <code>G2</code>, <code>W2</code> and 
<code>X2</code> statistics.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johan Barthelemy
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimate">Estimate</a></code> function to create an object of class
<code>mipfp</code> and to update an initial multidimensional array with respect to 
given constraints.
<code><a href="#topic+summary.mipfp">summary.mipfp</a></code> can also retrieve the
statistics and their associated p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying one fitting method (ipfp)
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data)
# printing the G2, X2 and W2 statistics
print(gof.estimates(r.ipfp))
# alternative way (pretty printing, with p-values)
print(summary(r.ipfp)$stats.gof)
</code></pre>

<hr>
<h2 id='Ipfp'>
Multidimensional Iterative Proportional Fitting
</h2><span id='topic+Ipfp'></span>

<h3>Description</h3>

<p>This function implements the iterative proportional fitting (IPFP) procedure. 
This procedure updates an initial N-dimensional array (referred as the seed) 
with respect to given target marginal distributions. Those targets can also 
be multi-dimensional. This procedure is also able to 
estimate a (multi-dimensional) contingency table (encoded as an array) matching 
a given set of (multi-dimensional) margins. In that case, each cell of the seed 
must simply be set to 1.
</p>
<p>The IPFP is also known as the RAS algorithm in economics and matrix raking or 
matrix scaling in computer science.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ipfp(seed, target.list, target.data, print = FALSE, iter = 1000, tol = 1e-10,
     tol.margins = 1e-10, na.target = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ipfp_+3A_seed">seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_target.list">target.list</code></td>
<td>

<p>A list of dimensions of the marginal target constrains in
<code>target.data</code>. Each component of the list is an array whose cells 
indicate which dimension the corresponding margin relates to.
</p>
</td></tr>    
<tr><td><code id="Ipfp_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target marginal tables. Each
component of the list is an array storing a margin.
The list order must follow the ordering defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_print">print</code></td>
<td>

<p>Verbose parameter: if TRUE prints the current iteration number
and the associated value of the stopping criterion. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_iter">iter</code></td>
<td>

<p>Stopping criterion. The maximum number of iteration allowed; 
must be greater than 0. Default is 1000.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_tol">tol</code></td>
<td>

<p>Stopping criterion. If the maximum absolute difference between two iteration
is lower than the value specified by <code>tol</code>, then ipfp has reached 
convergence; must be greater than 0. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_tol.margins">tol.margins</code></td>
<td>

<p>Tolerance for the margins consistency. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td></tr>
<tr><td><code id="Ipfp_+3A_na.target">na.target</code></td>
<td>

<p>If set to TRUE, allows the targets to have NA cells. Note that in that 
particular case the margins consistency is not checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the final updated array as well as other convergence
informations.
</p>
<table>
<tr><td><code>x.hat</code></td>
<td>

<p>An array with the same dimension of <code>seed</code> whose margins match those
specified in <code>target.list</code>.
</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>

<p>An array with the same dimension of <code>x.hat</code> containing the updated
cell probabilities, i.e. <code>x.hat / sum(x.hat)</code>.
</p>
</td></tr>
<tr><td><code>evol.stp.crit</code></td>
<td>

<p>The evolution of the stopping criterion over the iterations.
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td></tr>
<tr><td><code>error.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The selected method for estimation (here it will always be <code>ipfpf</code>).  
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li><p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li><p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Bacharach, M. (1965).
Estimating Nonnegative Matrices from Marginal Data.
<em>International Economic Review</em> (Blackwell Publishing) 6 (3): 294-310.
</p>
<p>Bishop, Y. M. M., Fienberg, S. E., Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice.</em>
MIT Press. ISBN 978-0-262-02113-5.
</p>
<p>Deming, W. E., Stephan, F. F. (1940).
On a Least Squares Adjustment of a Sampled Frequency Table When the Expected
Marginal Totals are Known.
<em>Annals of Mathematical Statistics</em> 11 (4): 427-444.
</p>
<p>Fienberg, S. E. (1970).
An Iterative Procedure for Estimation in Contingency Tables.
<em>Annals of Mathematical Statistics</em> 41 (3): 907-917.
</p>
<p>Stephan, F. F. (1942).
Iterative method of adjusting frequency tables when expected margins are known.
<em>Annals of Mathematical Statistics</em> 13 (2): 166-178.
</p>


<h3>See Also</h3>

<p>The documentation of <code><a href="#topic+IpfpCov">IpfpCov</a></code> provide details on the
the covariance matrices determination.
</p>
<p><code><a href="#topic+ObtainModelEstimates">ObtainModelEstimates</a></code> for alternatives 
to the IPFP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: 2-way table (V1,V2) of dim=(2,2)
# generating an intial 2-way table to be updated
seed.2d &lt;- array(1,dim=c(2,2))
# desired targets (margins) : V1 and V2
target.row &lt;- c(50,50)
target.col &lt;- c(30,70)
# storing the margins in a list
tgt.data.2d &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
tgt.list.2d &lt;- list(1,2)
# calling the Ipfp function
res.2d &lt;- Ipfp(seed.2d, tgt.list.2d, tgt.data.2d)

# Example 2: 3-way table (V1,V2,V3) of dim=(2,4,2)
# seed
seed.3d &lt;- array(1,c(2,4,2))
seed.3d[1,1,1] &lt;- 4
seed.3d[1,3,1] &lt;- 10
seed.3d[1,4,2] &lt;- 6
# desired targets (margins) : V1 and (V2,V3)
target.V1 &lt;- c(50, 16)
target.V2.V3 &lt;- array(4, dim=c(4,2))
target.V2.V3[1,1] &lt;- 10
target.V2.V3[3,1] &lt;- 22
target.V2.V3[4,2] &lt;- 14
# list of dimensions of each marginal constrain
tgt.data.3d &lt;- list(target.V1, target.V2.V3)
# storing the description of target data in a list
tgt.list.3d &lt;- list( 1, c(2,3) )
# calling the Ipfp function
res.3d &lt;- Ipfp(seed.3d, tgt.list.3d, tgt.data.3d, iter=50, print=TRUE, tol=1e-5)

# Example 3: 2-way table (V1,V2) of dim=(2,3) with missing values in the targets
# generating an intial 2-way table to be updated
seed.2d.na &lt;- array(1,dim=c(2,3))
# desired targets (margins) : V1 and V2
target.row.na &lt;- c(40,60)
target.col.na &lt;- c(NA,10,NA)
# storing the margins in a list
tgt.data.2d.na &lt;- list(target.row.na, target.col.na)
# storing the description of target data in a list
tgt.list.2d.na &lt;- list(1,2)
# calling the Ipfp function
res.2d.na &lt;- Ipfp(seed.2d.na, tgt.list.2d.na, tgt.data.2d.na, na.target=TRUE)
</code></pre>

<hr>
<h2 id='IpfpCov'>
Covariance matrix of the estimators produced by Ipfp (deprecated)
</h2><span id='topic+IpfpCov'></span>

<h3>Description</h3>

<p>This function determines the (asymptotic) covariance matrix of the estimates 
produced by the iterative proportional fitting procedure using the formula 
designed by Little and Wu (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IpfpCov(estimate, seed, target.list, replace.zeros = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IpfpCov_+3A_estimate">estimate</code></td>
<td>

<p>The array of estimates produced by the <code><a href="#topic+Ipfp">Ipfp</a></code>
function.
</p>
</td></tr>
<tr><td><code id="IpfpCov_+3A_seed">seed</code></td>
<td>

<p>The intial array (seed) that was updated by the 
<code><a href="#topic+Ipfp">Ipfp</a></code> function.
</p>
</td></tr>
<tr><td><code id="IpfpCov_+3A_target.list">target.list</code></td>
<td>

<p>A list of dimensions of the marginal target constrains. Each component of 
the list is an array whose cells indicate which dimension the corresponding 
margin relates to.
</p>
</td></tr>
<tr><td><code id="IpfpCov_+3A_replace.zeros">replace.zeros</code></td>
<td>

<p>If a cell of the <code>estimate</code> or the <code>seed</code> has a value equals to 
0, then it is replaced with this value. Default is 1e-10.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymptotic covariance matrix of the estimates produced by the iterative
proportional fitting procedure has the form (Little and Wu, 1991)
</p>
<p style="text-align: center;"><code class="reqn">K(K^T D1^{-1} K)^{-1} K^T D2^{-1} K (K^T D1^{-1} K)^{-1} K^T</code>
</p>

<p>where
</p>

<ul>
<li><p><code>K</code> is the orthogonal complement of the marginal matrix, i.e. the 
matrix required to obtain the marginal frequencies;
</p>
</li>
<li><p><code>D1</code> is a diagonal matrix of the estimates probabilities;
</p>
</li>
<li><p><code>D2</code> is a diagonal matrix of the seed probabilities.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix of dimension <code>length(estimate) x length(estimate)</code> of the
asymptotic variance of the proportion estimates produced by <code>Ipfp</code>.  
</p>


<h3>Warning</h3>

<p>Note: this function is deprecated, instead use
<code><a href="#topic+vcov.mipfp">vcov.mipfp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and seed 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ipfp">Ipfp</a></code> function to update an initial multidimensional
array with respect to given constraints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># true contingency (2-way) table
true.table &lt;- array(c(43, 44, 9, 4), dim = c(2, 2))
# generation of sample, i.e. the seed to be updated
seed &lt;- ceiling(true.table / 10)
# desired targets (margins)
target.row &lt;- apply(true.table, 2, sum)
target.col &lt;- apply(true.table, 1, sum)
# storing the margins in a list
target.data &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
target.list &lt;- list(1, 2)
# calling the Ipfp function
res &lt;- Ipfp(seed, target.list, target.data)
# computation of the covariance matrix of the produced estimated probabilities
res.cov &lt;- IpfpCov(res$x.hat, seed, target.list)
# 0.95 level confidence interval of the estimates
n &lt;- sum(res$x.hat)
# ... lower bound
ci.lb &lt;- Array2Vector(res$x.hat) - 1.96 * sqrt(n * diag(res.cov))
# ... upperbound
ci.ub &lt;- Array2Vector(res$x.hat) + 1.96 * sqrt(n * diag(res.cov))
</code></pre>

<hr>
<h2 id='ObtainModelEstimates'>Estimating a contingency table using model-based approaches
</h2><span id='topic+ObtainModelEstimates'></span>

<h3>Description</h3>

<p>This function provides several alternative estimating methods to 
the IPFP when estimating a multiway table subject to known constrains/totals: 
maximum likelihood method (ML), minimum chi-squared (CHI2) and weighted least 
squares (WLSQ). Note that the resulting estimators are probabilities.
</p>
<p>The covariance matrix of the estimated proportions (as defined by Little and Wu, 
1991) are also provided. Also in the case of the ML method, the covariance 
matrix defined by Lang (2004) is also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObtainModelEstimates(seed, target.list, target.data, method="ml", 
                     tol.margins = 1e-10, replace.zeros = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObtainModelEstimates_+3A_seed">seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative.
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_target.list">target.list</code></td>
<td>

<p>A list of the target margins provided in <code>target.data</code>. Each component
of the list is an array whose cells indicates which dimension the
corresponding margin relates to.
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target margins. Each
component of the list is an array storing a margin.
The list order must follow the one defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_method">method</code></td>
<td>
<p>Determine the model to be used for estimating the contingency
table. By default the method is <code>ml</code> (maximum likelihood); other 
options available are <code>chi2</code> (minimum chi-squared) and <code>lsq</code> 
(least squares).
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_tol.margins">tol.margins</code></td>
<td>

<p>Tolerance for the margins consistency. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_replace.zeros">replace.zeros</code></td>
<td>

<p>Constant that is added to zero cell found in the seed,
as procedures require strictly positive cells. Default value is 
<code class="reqn">1e^{-10}</code>.
</p>
</td></tr>
<tr><td><code id="ObtainModelEstimates_+3A_...">...</code></td>
<td>
<p>Additional parameters that can be passed to control the 
optimisation process (see <a href="Rsolnp.html#topic+solnp">solnp</a> from the package 
<a href="Rsolnp.html#topic+Rsolnp">Rsolnp</a>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the final estimated table as well as the covariance matrix of
the estimated proportion and other convergence informations.
</p>
<table>
<tr><td><code>x.hat</code></td>
<td>

<p>Array of the estimated table frequencies.
</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>

<p>Array of the estimated table probabilities.
</p>
</td></tr>
<tr><td><code>error.margins</code></td>
<td>

<p>For each list element of <code>target.data</code>, <code>check.margins</code> shows the 
maximum absolute deviation between the element and the corresponding 
estimated margin. Note that the deviations should approximate zero, 
otherwise the target margins are not met.
</p>
</td></tr>
<tr><td><code>solnp.res</code></td>
<td>

<p>The estimation process uses the <code>solnp</code> optimisation function from 
the R package Rsolnp and <code>solnp.res</code> is the corresponding object 
returned by the solver.
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The selected method for estimation.  
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li><p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li><p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Suesse 
</p>
<p>Maintainer: Johan Barthelemy &lt;johan@uow.edu.au&gt;.
</p>


<h3>References</h3>

<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and sampled 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>


<h3>See Also</h3>

<p><code><a href="Rsolnp.html#topic+solnp">solnp</a></code> function documentation of the package
<code><a href="Rsolnp.html#topic+Rsolnp">Rsolnp</a></code> for the details of the <code>solnp.res</code> object 
returned by the function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set-up an initial 3-way table of dimension (2 x 2 x 2)
seed &lt;- Vector2Array(c(80, 60, 20, 20, 40, 35, 35, 30), dim = c(c(2, 2, 2)))

# building target margins
margins12 &lt;- c(2000, 1000, 1500, 1800)
margins12.array &lt;- Vector2Array(margins12, dim=c(2, 2))
margins3 &lt;- c(4000,2300)
margins3.array &lt;- Vector2Array(margins3, dim = 2) 
target.list &lt;- list(c(1, 2), 3)
target.data &lt;- list(margins12.array, margins3.array)

# estimating the new contingency table using the ml method
results.ml &lt;- ObtainModelEstimates(seed, target.list, target.data, 
                                   compute.cov = TRUE)
print(results.ml)

# estimating the new contingency table using the chi2 method
results.chi2 &lt;- ObtainModelEstimates(seed, target.list, target.data, 
                                     method = "chi2", compute.cov = TRUE)
print(results.chi2)

# estimating the new contingency table using the lsq method
results.lsq &lt;- ObtainModelEstimates(seed, target.list, target.data,
                                    method = "lsq", compute.cov = TRUE)
print(results.lsq)
</code></pre>

<hr>
<h2 id='ObtainMultBinaryDist'>Generating a multivariate Bernoulli joint-distribution
</h2><span id='topic+ObtainMultBinaryDist'></span>

<h3>Description</h3>

<p>This function applies the IPFP procedure to obtain a joint distribution of 
<code class="reqn">K</code> multivariate binary (Bernoulli) variables <code class="reqn">X_1</code>, ..., <code class="reqn">X_K</code>.
</p>
<p>It requires as input the odds ratio or alternatively the correlation as a 
measure of association between all the binary variables and a vector of marginal 
probabilities. 
</p>
<p>This function is useful when one wants to simulate and draw from a 
multivariate binary distribution when only first order (marginal probabilities)
and second order moments (correlation or odds ratio) are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObtainMultBinaryDist(odds = NULL, corr = NULL, marg.probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObtainMultBinaryDist_+3A_odds">odds</code></td>
<td>
  
<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th 
column represents the Odds ratio between variables <code class="reqn">i</code> and <code class="reqn">j</code>. Must 
be provided if <code>corr</code> is not.
</p>
</td></tr>
<tr><td><code id="ObtainMultBinaryDist_+3A_corr">corr</code></td>
<td>

<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th
column represents the correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code>. 
Must be provided if <code>odds</code> is not.
</p>
</td></tr>
<tr><td><code id="ObtainMultBinaryDist_+3A_marg.probs">marg.probs</code></td>
<td>

<p>A vector with <code class="reqn">K</code> elements of marginal probabilities where the 
<code class="reqn">i</code>-th entry refers to <code class="reqn">P(X_i = 1)</code>.
</p>
</td></tr>
<tr><td><code id="ObtainMultBinaryDist_+3A_...">...</code></td>
<td>

<p>Additional arguments that can be passed to the <code>Ipfp</code> function such as 
<code>tol</code>, <code>iter</code>, <code>print</code> and <code>compute.cov</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are mainly determined by the <code>Ipfp</code> function.
</p>
<table>
<tr><td><code>joint.proba</code></td>
<td>

<p>The resulting multivariate joint-probabilities (from <code>Ipfp</code>).
</p>
</td></tr>
<tr><td><code>stp.crit</code></td>
<td>

<p>The final value of the <code>Ipfp</code> stopping criterion.
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>Boolean indicating whether the <code>Ipfp</code> algorithm converged to a 
solution.
</p>
</td></tr>
<tr><td><code>check.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin. Ideally the elements should approximate
0 (from <code>Ipfp</code>).
</p>
</td></tr>
<tr><td><code>label</code></td>
<td>

<p>The names of the variables.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is important to note that either the odds ratio defined in <code>odds</code> or
the correlations described in <code>corr</code> must be provided.
</p>


<h3>Author(s)</h3>

<p>Thomas Suesse 
</p>
<p>Maintainer: Johan Barthelemy &lt;johan@uow.edu.au&gt;.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em>  47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012). 
Orthogonalized residuals for estimation of marginally specified association 
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ipfp">Ipfp</a></code> for the function used to estimate the 
distribution; <code><a href="#topic+RMultBinary">RMultBinary</a></code> to simulate the
estimated joint-distribution; <code><a href="#topic+Corr2Odds">Corr2Odds</a></code> and
<code><a href="#topic+Odds2Corr">Odds2Corr</a></code> to convert odds ratio to correlation
and conversely.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initial odds ratios from Qaqish et al. (2012)
or &lt;- matrix(c(Inf, 0.281, 2.214, 2.214, 
               0.281, Inf, 2.214, 2.214,
               2.214, 2.214, Inf, 2.185,
               2.214, 2.214, 2.185, Inf), nrow = 4, ncol = 4, byrow = TRUE)
rownames(or) &lt;- colnames(or) &lt;- c("Parent1", "Parent2", "Sibling1", "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# estimating the joint-distribution
p.joint &lt;- ObtainMultBinaryDist(odds = or, corr = NULL, marg.probs = p)
print(p.joint$joint.proba)

# obtain identical solution when providing correlation
corr &lt;- Odds2Corr(odds = or, marg.probs = p)$corr
p.joint.alt &lt;- ObtainMultBinaryDist(corr = corr, marg.probs = p)

# checking if the results are truly identicals
diff &lt;- sum(abs(p.joint.alt$joint.proba - p.joint$joint.proba))
cat('Sum of the absolute deviations: ', diff, '\n')
</code></pre>

<hr>
<h2 id='Odds2Corr'>Converting odds ratio to correlation
</h2><span id='topic+Odds2Corr'></span>

<h3>Description</h3>

<p>For <code class="reqn">K</code> binary (Bernoulli) random variables 
<code class="reqn">X_1</code>, ..., <code class="reqn">X_K</code>, this function transforms the odds ratios 
measure of association <code class="reqn">O_{ij}</code> between every pair
<code class="reqn">(X_i, X_j)</code> to the correlation <code class="reqn">C_{ij}</code> where
</p>
<p style="text-align: center;"><code class="reqn">C_{ij} = \frac{cov(X_i, X_j)}{\sqrt{var(X_i) * var(X_j)}}</code>
</p>

<p>and 
</p>
<p style="text-align: center;"><code class="reqn">
O_{ij} = \frac{P(X_i = 1, X_j = 1) * P(X_i = 0, X_j = 0)}
            {P(X_i = 1, X_j = 0) * P(X_i = 0, X_j = 1)}.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Odds2Corr(odds, marg.probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Odds2Corr_+3A_odds">odds</code></td>
<td>
      
<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th
column represents the odds ratio <code class="reqn">O_{ij}</code> between variables
<code class="reqn">i</code> and <code class="reqn">j</code>.  
</p>
</td></tr>
<tr><td><code id="Odds2Corr_+3A_marg.probs">marg.probs</code></td>
<td>

<p>A vector with <code class="reqn">K</code> elements of marginal probabilities where the 
<code class="reqn">i</code>-th entry refers to <code class="reqn">P(X_i = 1)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return a list with the correlations and the pairwise probabilities.
</p>
<table>
<tr><td><code>corr</code></td>
<td>

<p>A matrix of the same dimension as <code>odds</code> containing the correlations
</p>
</td></tr>
<tr><td><code>pair.proba</code></td>
<td>

<p>A matrix of the same dimension as <code>odds</code> containing the pairwise 
probabilities.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em> 47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012).
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Corr2Odds">Corr2Odds</a></code> for converting correlation to odds ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from Qaqish et al. (2012)
or &lt;- matrix(c(Inf, 0.281, 2.214, 2.214,
               0.281, Inf, 2.214, 2.214,
               2.214, 2.214, Inf, 2.185,
               2.214, 2.214, 2.185, Inf), nrow = 4, ncol = 4, byrow = TRUE)
rownames(or) &lt;- colnames(or) &lt;- c("Parent1", "Parent2", "Sibling1", "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# converting odds ratio to correlation
corr &lt;- Odds2Corr(odds = or, marg.probs = p)
print(corr)
</code></pre>

<hr>
<h2 id='Odds2PairProbs'>Converting odds ratio to pairwise probability
</h2><span id='topic+Odds2PairProbs'></span>

<h3>Description</h3>

<p>For <code class="reqn">K</code> binary (Bernoulli) random variables 
<code class="reqn">X_1</code>, ..., <code class="reqn">X_K</code>, this function transforms the odds ratios
measure of association <code class="reqn">O_{ij}</code> between every pair 
<code class="reqn">(X_i, X_j)</code> to the pairwise probability 
<code class="reqn">P(X_i = 1, X_j = 1)</code>, where <code class="reqn">O_{ij}</code> is
defined as
</p>
<p style="text-align: center;"><code class="reqn">
O_{ij} = \frac{P(X_i = 1, X_j = 1) * P(X_i = 0, X_j = 0)}
            {P(X_i = 1, X_j = 0) * P(X_i = 0, X_j = 1)}.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Odds2PairProbs(odds, marg.probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Odds2PairProbs_+3A_odds">odds</code></td>
<td>

<p>A <code class="reqn">K \times K</code> matrix where the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th
column represents the odds ratio <code class="reqn">O_{ij}</code> between variables
<code class="reqn">i</code> and <code class="reqn">j</code>. 
</p>
</td></tr>
<tr><td><code id="Odds2PairProbs_+3A_marg.probs">marg.probs</code></td>
<td>

<p>A vector with <code class="reqn">K</code> elements of marginal probabilities where the 
<code class="reqn">i</code>-th entry refers to <code class="reqn">P(X_i = 1)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimension as <code>odds</code> containing the pairwise 
probabilities
</p>


<h3>Note</h3>

<p>If we denote <code class="reqn">P(X_i = 1, X_j = 1)</code> by 
<code class="reqn">h_{ij}</code>, and <code class="reqn">P(X_i = 1)</code> by <code class="reqn">p_i</code>, then it
can be shown that
</p>
<p style="text-align: center;"><code class="reqn">O_{ij} = \frac{h_{ij} * (1 - p_i - p_j + h_{ij})}{ 
      ((p_i - h_{ij}) * (p_j - h_{ij}))}</code>
</p>



<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association
<em>The American Statistician</em>  47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012). 
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Corr2PairProbs">Corr2PairProbs</a></code> for converting the 
correlation to pairwise probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from Qaqish et al. (2012)
or &lt;- matrix(c(Inf, 0.281, 2.214, 2.214,
               0.281, Inf, 2.214, 2.214,
               2.214, 2.214, Inf, 2.185,
               2.214, 2.214, 2.185, Inf), nrow = 4, ncol = 4, byrow = TRUE)
rownames(or) &lt;- colnames(or) &lt;- c("Parent1", "Parent2", "Sibling1", "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# getting the pairwise probabilities
pp &lt;- Odds2PairProbs(odds = or, marg.probs = p)
print(pp)
</code></pre>

<hr>
<h2 id='Qaqish'>
Qaqish
</h2><span id='topic+Qaqish'></span>

<h3>Description</h3>

<p>The data set provides the odds ratios and correlations as measures of 
associations of the binary outcome impaired pulmonary function for a family of 
four with two parents and two siblings.
</p>
<p>These correlations and odds ratios are obtained from Qaqish et al. (2012) based
on a regression analysis of a common data set of parents and siblings with 
chronic obstructive pulmonary disease and their controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Qaqish)</code></pre>


<h3>Format</h3>

<p>A list <code>Qaqish</code> containing 2 elements:
</p>

<ol>
<li> <p><code>cr</code> : the correlation matrix;
</p>
</li>
<li> <p><code>or</code> : the odd ratios matrix.
</p>
</li></ol>



<h3>Source</h3>

<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012).
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Qaqish)
print(Qaqish$or)
print(Qaqish$cr)
</code></pre>

<hr>
<h2 id='RMultBinary'>Simulating a multivariate Bernoulli distribution
</h2><span id='topic+RMultBinary'></span><span id='topic+Bernoulli'></span><span id='topic+RMultBernoulli'></span>

<h3>Description</h3>

<p>This function generates a sample from a multinomial distribution of <code class="reqn">K</code>
dependent binary (Bernoulli) variables
<code class="reqn">(X_1, X_2, ..., X_K)</code> defined by an array 
(of 2^K cells) detailing the joint-probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMultBinary(n = 1, mult.bin.dist, target.values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMultBinary_+3A_n">n</code></td>
<td>

<p>Desired sample size. Default = 1.
</p>
</td></tr>
<tr><td><code id="RMultBinary_+3A_mult.bin.dist">mult.bin.dist</code></td>
<td>

<p>A list describing the multivariate binary distribution. It can be generated
by the <code><a href="#topic+ObtainMultBinaryDist">ObtainMultBinaryDist</a></code> function.
The list contains at least the element <code>joint.proba</code>, an array 
detailing the joint-probabilities of the <code class="reqn">K</code> 
binary variables. The array has <code class="reqn">K</code> dimensions of size 2, referring to 
the 2 possible outcomes of the considered variable. Hence, the total number 
of elements is <code class="reqn">2^K</code>.
Additionnaly the list can also provides the element <code>var.label</code>, a list
containing the names of the <code class="reqn">K</code> variables.    
</p>
</td></tr>
<tr><td><code id="RMultBinary_+3A_target.values">target.values</code></td>
<td>

<p>A list describing the possibles outcomes of each binary variable, for 
instance {1, 2}. Default = {0, 1}.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are detailed herehunder.
</p>
<table>
<tr><td><code>binary.sequences</code></td>
<td>

<p>The generated <code class="reqn">K \times n</code> random sequence.
</p>
</td></tr>
<tr><td><code>possible.binary.sequences</code></td>
<td>

<p>The possible binary sequences, i.e. the domain.
</p>
</td></tr>
<tr><td><code>chosen.random.index</code></td>
<td>

<p>The index of the random draws in the domain.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Suesse 
</p>
<p>Maintainer: Johan Barthelemy &lt;johan@uow.edu.au&gt;.
</p>


<h3>References</h3>

<p>Lee, A.J. (1993).
Generating Random Binary Deviates Having Fixed Marginal Distributions and 
Specified Degrees of Association.
<em>The American Statistician</em>  47 (3): 209-215.
</p>
<p>Qaqish, B. F., Zink, R. C., and Preisser, J. S. (2012).
Orthogonalized residuals for estimation of marginally specified association
parameters in multivariate binary data.
<em>Scandinavian Journal of Statistics</em> 39, 515-527.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ObtainMultBinaryDist">ObtainMultBinaryDist</a></code> for estimating the 
joint-distribution required by this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from Qaqish et al. (2012)
or &lt;- matrix(c(Inf, 0.281, 2.214, 2.214,
               0.281, Inf, 2.214, 2.214,
               2.214, 2.214, Inf, 2.185,
               2.214, 2.214, 2.185, Inf), nrow = 4, ncol = 4, byrow = TRUE)
rownames(or) &lt;- colnames(or) &lt;- c("Parent1", "Parent2", "Sibling1", "Sibling2")

# hypothetical marginal probabilities
p &lt;- c(0.2, 0.4, 0.6, 0.8)

# estimating the joint-distribution
p.joint &lt;- ObtainMultBinaryDist(odds = or, marg.probs = p)

# simulating 100,000 draws from the obtained joint-distribution
y.sim &lt;- RMultBinary(n = 1e5, mult.bin.dist = p.joint)$binary.sequences

# checking results
cat('dim y.sim =', dim(y.sim)[1], 'x', dim(y.sim)[2], '\n')
cat('Estimated marginal probs from simulated data\n')
apply(y.sim,2,mean)
cat('True probabilities\n')
print(p)
cat('Estimated correlation from simulated data\n')
cor(y.sim)
cat('True correlation\n')
Odds2Corr(or,p)$corr

# generating binary outcomes with outcome different than 0, 1
RMultBinary(n = 10, mult.bin.dist = p.joint, 
            target.values = list(c("A", "B"), c(0, 1), c(1, 2), c(100, 101)))
</code></pre>

<hr>
<h2 id='spnamur'>
Synthetic population of Namur (Belgium)
</h2><span id='topic+spnamur'></span>

<h3>Description</h3>

<p>This data drame contains a synthetic population of individuals for Belgian city
of Namur. The attributes details the gender, age class, socio-professional
status, education level and driving license ownership of every synthetic
individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spnamur)</code></pre>


<h3>Format</h3>

<p>A data frame detailing the synthetic individuals whose columns are described
in the Table below.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <b>Attribute</b> </td><td style="text-align: left;"> <b>Values (levels)</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  Household.type </td><td style="text-align: left;"> C (couple); F (family with children); I (isolated); N (non
                      family) </td>
</tr>
<tr>
 <td style="text-align: left;">
  Gender </td><td style="text-align: left;"> F (female); H (male) </td>
</tr>
<tr>
 <td style="text-align: left;">
  Prof.status  </td><td style="text-align: left;"> A (active); E (student); I (inactive) </td>
</tr>
<tr>
 <td style="text-align: left;">
  Education.level  </td><td style="text-align: left;"> O (none); P (primary); S (high school); 
                        U (higher education) </td>
</tr>
<tr>
 <td style="text-align: left;">
  Driving.license </td><td style="text-align: left;"> O (no); P (yes) </td>
</tr>
<tr>
 <td style="text-align: left;">
  Age.class	</td><td style="text-align: left;"> 0 (0-5); 1 (6-17); 2 (18-39); 3 (40-59); 4 (60+) </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>



<h3>Source</h3>

<p>VirtualBelgium - <a href="http://virtualbelgium.sourceforge.net">http://virtualbelgium.sourceforge.net</a>
</p>


<h3>References</h3>

<p>Barthelemy, J. and Toint, P.L. (2013)
Synthetic population generation without a sample
<em>Transportation Science</em> 47 (2): 266-279
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spnamur)
# generating the contingency table of the synthetic population
table(spnamur)
</code></pre>

<hr>
<h2 id='summary.mipfp'>
Summarizing objects of class mipfp
</h2><span id='topic+summary.mipfp'></span><span id='topic+print.summary.mipfp'></span>

<h3>Description</h3>

<p>Summary method for class <code>mipfp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
summary(object, cov.method = "delta", prop = FALSE, 
        target.list = NULL, l.names = 0, ...)

## S3 method for class 'summary.mipfp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mipfp_+3A_object">object</code></td>
<td>

<p>An object of class <code>mipfp</code>, usually a result of a call to
<a href="#topic+Estimate">Estimate</a>
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_x">x</code></td>
<td>

<p>An object of class <code>summary.mipfp</code>, usually a result of a call to
<code>summary.mipfp</code>.
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_cov.method">cov.method</code></td>
<td>

<p>Indicates which method to use to compute the covariance. Possible values 
are Delta (<code>delta</code>, default) or Lang (<code>lang</code>).
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_prop">prop</code></td>
<td>

<p>If set to <code>FALSE</code> (the default), the results return counts, 
probabilities otherwise.
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_target.list">target.list</code></td>
<td>

<p>The list of the dimensions of the targets used by for the estimation
process (see <a href="#topic+Estimate">Estimate</a> for more details).
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_l.names">l.names</code></td>
<td>

<p>If set to a value greater than 0, then the names of the
categories will be shorten to a length of <code>l.names</code> characters.
</p>
</td></tr>
<tr><td><code id="summary.mipfp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the underlying <code>print</code> and <code>flat</code> 
method, or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.mipfp</code> compute and returns a list of summary
statistics of the estimates (covariance, t-statistics, goodness-of-fit
statistics, associated degrees of freedom).
</p>


<h3>Value</h3>

<p>The function <code>summary.mipfp</code> returns an object of class 
<code>summary.mipfp</code> having the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>A <code>call</code> object in which all the specified arguments are given by
their full names.
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>A Boolean indicating if the specified method converged to a 
solution (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The method used to generate estimates.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>Degrees of freedom of the estimates.
</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>

<p>Estimates generated by the selected method with standard deviations and 
associated t- and p-values.
</p>
</td></tr>
<tr><td><code>error.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin.
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>A covariance matrix of the estimates (last index move fastest) computed 
using the method specified in <code>cov.method</code>.
</p>
</td></tr>
<tr><td><code>tab.gof</code></td>
<td>

<p>A table containing the Log-likelihood (G2), Wald (W2) and Pearson 
chi-squared (X2) statistics with their associated p-values.
</p>
</td></tr>
<tr><td><code>stats.df</code></td>
<td>

<p>Degrees of freedom for the <code>G2</code>, <code>W2</code> and <code>X2</code> statistics.
</p>
</td></tr>
<tr><td><code>dim.names</code></td>
<td>

<p>Original dimension names of the estimated table.
</p>
</td></tr>
<tr><td><code>l.names</code></td>
<td>

<p>The value of the parameter <code>l.names</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When using <code>print</code> for printing the resulting <code>mipfp</code> object, you can
also have a look at the options of the method <code><a href="#topic+flat">flat</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The estimation function <code><a href="#topic+Estimate">Estimate</a></code>.
</p>
<p>The function <code><a href="#topic+coef.mipfp">coef.mipfp</a></code> to extract the 
estimates.
</p>
<p><code><a href="#topic+gof.estimates">gof.estimates</a></code> for the computation of the 
<code>G2</code>, <code>W2</code> and <code>X2</code> statistics. 
</p>
<p><code><a href="#topic+vcov.mipfp">vcov.mipfp</a></code> for the details of the covariance 
computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying the different fitting methods
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data)
# printing the summary                   
print(summary(r.ipfp))
</code></pre>

<hr>
<h2 id='vcov.mipfp'>
Calculate variance-covariance matrix for mipfp objects
</h2><span id='topic+vcov.mipfp'></span>

<h3>Description</h3>

<p>This function determines the (asymptotic) covariance matrix of the estimates 
in an <code>mipfp</code> object using either the Delta formula designed by Little 
and Wu (1991) or Lang's formula (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipfp'
vcov(object, method.cov = "delta", seed = NULL, 
     target.data = NULL, target.list = NULL, replace.zeros = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mipfp_+3A_object">object</code></td>
<td>

<p>An object of class mipfp.
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_method.cov">method.cov</code></td>
<td>

<p>Select the method to use for the computation of the covariance.
The available methods are <code>delta</code> and <code>lang</code>.
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_seed">seed</code></td>
<td>

<p>The initial multi-dimensional array used to create <code>object</code>
(optional). 
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_target.data">target.data</code></td>
<td>

<p>A list containing the data of the target margins used to create 
<code>object</code>. Each component of the list is an array storing a margin. 
The list order must follow the one defined in <code>target.list</code>
(optional).
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_target.list">target.list</code></td>
<td>

<p>A list of the target margins used to create <code>object</code> function. Each
component of the list is an array whose cells indicates which dimension the
corresponding margin relates to (optional).
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_replace.zeros">replace.zeros</code></td>
<td>

<p>If 0-cells are to be found, then their values are replaced with this
value.
</p>
</td></tr>
<tr><td><code id="vcov.mipfp_+3A_...">...</code></td>
<td>

<p>Not used.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymptotic covariance matrix of the estimates probabilities using Delta's 
formula has the form (Little and Wu, 1991)
</p>
<p style="text-align: center;"><code class="reqn">K(K^T D1^{-1} K)^{-1} K^T D2^{-1} K (K^T D1^{-1} K)^{-1} K^T</code>
</p>

<p>where
</p>

<ul>
<li><p><code>K</code> is the orthogonal complement of the marginal matrix, i.e. the 
matrix <code class="reqn">A</code> required to obtain the marginal frequencies <code class="reqn">m</code>;

</p>
</li>
<li><p><code>D1</code> and <code>D2</code> are two diagonal matrices whose components
depends on the estimation process used to generate <code>object</code>.

</p>
</li></ul>

<p>If the estimation process has been done using
</p>

<ul>
<li><p><code>ipfp</code>
then <code class="reqn">diag(D1) = \hat{p}</code> and 
<code class="reqn">diag(D2) = p_*</code>;

</p>
</li>
<li><p><code>ml</code>
then <code class="reqn">diag(D1) = \frac{\hat{p}^2}{p_*}</code> and 
<code class="reqn">diag(D2) = diag(D1)</code>;

</p>
</li>
<li><p><code>chi2</code>
then <code class="reqn">diag(D1) = \frac{\hat{p}^4}{p_*^3}</code>
and <code class="reqn">diag(D2) = diag(D1)</code>;

</p>
</li>
<li><p><code>lsq</code>
then <code class="reqn">diag(D1) = p_*</code> and 
<code class="reqn">diag(D2) = \frac{p_*3}{\hat{p}^2}</code>;

</p>
</li></ul>

<p>where <code class="reqn">\hat{p}</code> is the vector of estimated probabilities and
<code class="reqn">p_*</code> is the vector of the seed probabilities.
</p>
<p>Using Lang's formula (2004), the covariance matrix becomes
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{N} 
      \left( D - \hat{p}\hat{p}^T - D H(H^T D H)^{-1} H^T D \right)</code>
</p>

<p>where
</p>

<ul>
<li><p><code>D</code>
is a diagonal matrix of the estimated probabilities <code class="reqn">\hat{p}</code>;

</p>
</li>
<li><p><code>H</code>
denotes the Jacobian evaluated in <code class="reqn">\hat{p}</code> of the function
<code class="reqn">h(p) = A^T p - m</code>.

</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x.hat.cov</code></td>
<td>

<p>A covariance matrix of the estimated counts (last index move fastest)
computed using the method specified in <code>cov.method</code>.
</p>
</td></tr>
<tr><td><code>p.hat.cov</code></td>
<td>

<p>A covariance matrix of the estimated probabilities (last index 
move fastest) computed using the method specified in <code>cov.method</code>.
</p>
</td></tr>
<tr><td><code>x.hat.se</code></td>
<td>

<p>The standard deviation of the estimated counts (last index move fastest)
computed using the method specified in <code>cov.method</code>.
</p>
</td></tr>
<tr><td><code>p.hat.se</code></td>
<td>

<p>The standard deviation of the estimated probabilities (last index move 
fastest) computed using the method specified in <code>cov.method</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>Degrees of freedom of the estimates.
</p>
</td></tr>
<tr><td><code>method.cov</code></td>
<td>

<p>The method used to compute the covariance matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and seed 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimate">Estimate</a></code> function to create an object of class
<code>mipfp</code> and to update an initial multidimensional array with respect to 
given constraints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># true contingency (2-way) table
true.table &lt;- array(c(43, 44, 9, 4), dim = c(2, 2))
# generation of sample, i.e. the seed to be updated
seed &lt;- ceiling(true.table / 10)
# desired targets (margins)
target.row &lt;- apply(true.table, 2, sum)
target.col &lt;- apply(true.table, 1, sum)
# storing the margins in a list
target.data &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
target.list &lt;- list(1, 2)
# calling the Estimate function
res &lt;- Estimate(seed, target.list, target.data)
# printing the variance-covariance matrix
print(vcov(res))
</code></pre>

<hr>
<h2 id='Vector2Array'>
Transforming a vector to an array
</h2><span id='topic+Vector2Array'></span>

<h3>Description</h3>

<p>Transform a vector into a multidimensional array. The transformation is done
assuming that the last index of the array moves fastest. For instance, the
relation between a vector <code class="reqn">v</code> of lenght 8 and an array <code class="reqn">a</code> of dimensions
(2,2,2) is defined by <code class="reqn">v = (a_{111}, a_{112}, a_{113}, a_{121}, a_{122},
\ldots,a_{333}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vector2Array(vect, dim.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vector2Array_+3A_vect">vect</code></td>
<td>

<p>The vector of length one or more to be transformed into an array.
</p>
</td></tr>
<tr><td><code id="Vector2Array_+3A_dim.out">dim.out</code></td>
<td>

<p>The dimension attribute for the array to be created, that is an integer 
vector of length one or more giving the maximal indices in each dimension.    
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimensions given by <code>dim.out</code> filled with the data from the
input vector <code>vec</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Suesse.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>See Also</h3>

<p>The inverse transformation is performed with the function 
<code><a href="#topic+Array2Vector">Array2Vector</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a vector [1,2,...,27]
v &lt;- seq(1:27)
# transform it into an array of dimension (3,3,3)
a &lt;- Vector2Array(v,c(3,3,3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
