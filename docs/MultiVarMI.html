<!DOCTYPE html><html><head><title>Help for package MultiVarMI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiVarMI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#countrate'><p>Computation of Rates for Count Data</p></a></li>
<li><a href='#MI'><p>Bayesian Multiple Imputation for Multivariate Data</p></a></li>
<li><a href='#MultiVarMI-package'>
<p>Multiple Imputation for Multivariate Data</p></a></li>
<li><a href='#MVN.corr'><p>Calculation of Intermediate Correlation Matrix</p></a></li>
<li><a href='#MVN.dat'><p>Computation of Normal Scores for Multivariate Data</p></a></li>
<li><a href='#nctsum'><p>Summary and Standardization of Continuous Data</p></a></li>
<li><a href='#ordmps'><p>Computation of Marginal Probabilities for Binary and Ordinal Data</p></a></li>
<li><a href='#trMVN.dat'><p>Transformation of Normal Scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Imputation for Multivariate Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Rawan Allozi, Hakan Demirtas</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rawan Allozi &lt;ralloz2@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fully parametric Bayesian multiple imputation framework for massive multivariate data of different variable types as seen in Demirtas, H. (2017) &lt;<a href="https://doi.org/10.1007%2F978-981-10-3307-0_8">doi:10.1007/978-981-10-3307-0_8</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>BinOrdNonNor, CorrToolBox, corpcor, Matrix, moments, norm,
PoisNonNor</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PoisBinOrdNonNor</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-08 13:48:32 UTC; rawanallozi</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-09 11:55:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='countrate'>Computation of Rates for Count Data</h2><span id='topic+countrate'></span>

<h3>Description</h3>

<p>This function computes the empirical rates for count data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>countrate(count.dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countrate_+3A_count.dat">count.dat</code></td>
<td>
<p>A matrix consisting of count variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length ncol(count.dat) containing the data and empirical rates for each variable in count.dat.</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+MVN.corr">MVN.corr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PoisBinOrdNonNor)
set.seed(123)
n&lt;-1e4

lambdas&lt;-list(1, 3)

#generate Poisson data
cmat.star &lt;- find.cor.mat.star(cor.mat = .4 * diag(2) + .6, 
                               no.pois = length(lambdas), 
                               pois.list = lambdas)

cntdata &lt;- genPBONN(n, 
                    no.pois = length(lambdas), 
                    cmat.star = cmat.star, 
                    pois.list = lambdas)

#set a sample of the data to missing
cntdata&lt;-apply(cntdata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

cntdata&lt;-data.frame(cntdata)
cntinfo&lt;-countrate(cntdata)
</code></pre>

<hr>
<h2 id='MI'>Bayesian Multiple Imputation for Multivariate Data</h2><span id='topic+MI'></span>

<h3>Description</h3>

<p>This function implements the multiple imputation framework as described in Demirtas (2017) &quot;A multiple imputation framework for massive multivariate
data of different variable types: A Monte-Carlo technique.&quot;</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI(dat, var.types, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI_+3A_dat">dat</code></td>
<td>
<p>A data frame containing multivariate data with missing values.</p>
</td></tr>
<tr><td><code id="MI_+3A_var.types">var.types</code></td>
<td>
<p>The variable type corresponding to each column in dat, taking values of &quot;NCT&quot; for continuous data, &quot;O&quot; for ordinal or binary data, or &quot;C&quot; for count data.</p>
</td></tr>
<tr><td><code id="MI_+3A_m">m</code></td>
<td>
<p>The number of stochastic simulations in which the missing values are replaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing m imputed data sets.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper correlation bounds. <em>The American Statistician</em>, <b>65(2)</b>, 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R. J. (2012). Simulation of massive public health data by power polynomials. <em>Statistics in Medicine</em>, <b>31(27)</b>, 3337-3346.
</p>
<p>Demirtas, H. (2016). A note on the relationship between the phi coefficient and the tetrachoric correlation under nonnormal underlying distributions. <em>The American Statistician</em>, <b>70(2)</b>, 143-148.
</p>
<p>Demirtas, H. and Hedeker, D. (2016). Computing the point-biserial correlation under any underlying continuous distribution. <em>Communications in Statistics-Simulation and Computation</em>, <b>45(8)</b>, 2744-2751.
</p>
<p>Demirtas, H., Ahmadian, R., Atis, S., Can, F.E., and Ercan, I. (2016). A nonnormal look at polychoric correlations: modeling the change in correlations before and after discretization. <em>Computational Statistics</em>, <b>31(4)</b>, 1385-1401.
</p>
<p>Demirtas, H. (2017). A multiple imputation framework for massive multivariate data of different variable types: A Monte-Carlo technique. <em>Monte-Carlo Simulation-Based Statistical Modeling</em>, edited by Ding-Geng (Din) Chen and John Dean Chen, Springer, 143-162.
</p>
<p>Ferrari, P.A. and Barbiero, A. (2012). Simulating ordinal data. <em>Multivariate Behavioral Research</em>, <b>47(4)</b>, 566-589.
</p>
<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>
<p>Vale, C.D. and Maurelli, V.A. (1983). Simulating multivariate nonnormal distributions. <em>Psychometrika</em>, <b>48(3)</b>, 465-471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVN.corr">MVN.corr</a></code>, <code><a href="#topic+MVN.dat">MVN.dat</a></code>, <code><a href="#topic+trMVN.dat">trMVN.dat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PoisBinOrdNonNor)
set.seed(1234)
n&lt;-1e5
lambdas&lt;-list(1, 3) #2 count variables
mps&lt;-list(c(.2, .8), c(.6, 0, .3, .1)) #1 binary variable, 1 ordinal variable with skip pattern
moms&lt;-list(c(-1, 1, 0, 1), c(0, 3, 0, 2)) #2 continuous variables

################################################
#Generate Poisson, Ordinal, and Continuous Data#
################################################
#get intermediate correlation matrix
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(6) + .2, #all pairwise correlations set to 0.2
                               no.pois = length(lambdas),
                               no.ord = length(mps),
                               no.nonn = length(moms),
                               pois.list = lambdas,
                               ord.list = mps,
                               nonn.list = moms)

#generate dataset
mydata &lt;- genPBONN(n,
                   no.pois = length(lambdas),
                   no.ord = length(mps),
                   no.nonn = length(moms),
                   cmat.star = cmat.star,
                   pois.list = lambdas,
                   ord.list = mps,
                   nonn.list = moms)

cor(mydata)
apply(mydata, 2, mean)

#Make 10 percent of each variable missing completely at random
mydata&lt;-apply(mydata, 2, function(x) {
  x[sample(1:n, size=n*0.1)]&lt;-NA
  return(x) 
  }
)


#Create 5 imputed datasets
mydata&lt;-data.frame(mydata)
mymidata&lt;-MI(dat=mydata,
             var.types=c('C', 'C', 'O', 'O', 'NCT', 'NCT'),
             m=5)

#get the means of each variable for the m imputed datasets  
do.call(rbind, lapply(mymidata, function(x) apply(x, 2, mean)))

#get m correlation matrices of for the m imputed dataset
lapply(mymidata, function(x) cor(x))

#Look at the second imputed dataset
head(mymidata$dataset2)

##run a linear model on each dataset and extract coefficients
mycoef&lt;-lapply(mymidata, function(x) {
  fit&lt;-lm(X6~., data=data.frame(x))
  fit.coef&lt;-coef(fit)
  return(fit.coef)
})

do.call(rbind, mycoef)

</code></pre>

<hr>
<h2 id='MultiVarMI-package'>
Multiple Imputation for Multivariate Data
</h2><span id='topic+MultiVarMI-package'></span><span id='topic+MultiVarMI'></span>

<h3>Description</h3>

<p>This package implements a Bayesian multiple imputation framework for multivariate data. Most incomplete data sets constist of interdependent binary, ordinal, count, and continuous data. Furthermore, planned missing data designs have been developed to reduce respondent burden and lower the cost associated with data collection. The unified, general-purpose multiple imputation framework described in Demirtas (2017) can be utilized in developing power analysis guidelines for intensive multivariate data sets that are collected via increasingly popular real-time data capture (RTDC) approaches. This framework can accommodate all four major types of variables with a minimal set of assumptions. The data are prepared for multivariate normal multiple imputation for use in the <code>norm</code> package and subsequently backtransformed to the original distribution.
</p>
<p>This package consists of one main function and six auxiliary functions. Multiple imputation can be performed using the function <code><a href="#topic+MI">MI</a></code>. While the auxiliary functions are utilized in <code><a href="#topic+MI">MI</a></code>, they can be used as stand-alone functions. <code><a href="#topic+nctsum">nctsum</a></code> outputs a list with summary statistics and Fleishman coefficients and standardized forms of each variable. <code><a href="#topic+ordmps">ordmps</a></code> is utilized for ordinal variables and outputs a list with empirical marginal probabilities and the associated observations for each ordinal variable. <code><a href="#topic+countrate">countrate</a></code> is designed for variables and outputs a list with empirical rates and the associated observations for each ordinal variable. <code><a href="#topic+MVN.corr">MVN.corr</a></code> calculates the intermediate correlation matrix, <code><a href="#topic+MVN.dat">MVN.dat</a></code> transforms variables to a standard normal variable, and <code><a href="#topic+trMVN.dat">trMVN.dat</a></code> transforms standard normal variables to ordinal, count, and/or non-normal continuous variables through specified parameters.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MultiVarMI</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-04-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Rawan Allozi, Hakan Demirtas
</p>
<p>Maintainer: Rawan Allozi &lt;ralloz2@uic.edu&gt;
</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper correlation bounds. <em>The American Statistician</em>, <b>65(2)</b>, 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R. J. (2012). Simulation of massive public health data by power polynomials. <em>Statistics in Medicine</em>, <b>31(27)</b>, 3337-3346.
</p>
<p>Demirtas, H. (2016). A note on the relationship between the phi coefficient and the tetrachoric correlation under nonnormal underlying distributions. <em>The American Statistician</em>, <b>70(2)</b>, 143-148.
</p>
<p>Demirtas, H. and Hedeker, D. (2016). Computing the point-biserial correlation under any underlying continuous distribution. <em>Communications in Statistics-Simulation and Computation</em>, <b>45(8)</b>, 2744-2751.
</p>
<p>Demirtas, H., Ahmadian, R., Atis, S., Can, F.E., and Ercan, I. (2016). A nonnormal look at polychoric correlations: modeling the change in correlations before and after discretization. <em>Computational Statistics</em>, <b>31(4)</b>, 1385-1401.
</p>
<p>Demirtas, H. (2017). A multiple imputation framework for massive multivariate data of different variable types: A Monte-Carlo technique. <em>Monte-Carlo Simulation-Based Statistical Modeling</em>, edited by Ding-Geng (Din) Chen and John Dean Chen, Springer, 143-162.
</p>
<p>Ferrari, P.A. and Barbiero, A. (2012). Simulating ordinal data. <em>Multivariate Behavioral Research</em>, <b>47(4)</b>, 566-589.
</p>
<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>
<p>Vale, C.D. and Maurelli, V.A. (1983). Simulating multivariate nonnormal distributions. 
<em>Psychometrika</em>, <b>48(3)</b>, 465-471.
</p>

<hr>
<h2 id='MVN.corr'>Calculation of Intermediate Correlation Matrix</h2><span id='topic+MVN.corr'></span>

<h3>Description</h3>

<p>This function calculates an intermediate correlation matrix for Poisson, ordinal, and continuous random variables, with specified target correlations and marginal properties.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVN.corr(indat, var.types, ord.mps=NULL, nct.sum=NULL, count.rate=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN.corr_+3A_indat">indat</code></td>
<td>
<p>A data frame containing multivariate data. Continuous variables should be standardized.</p>
</td></tr>
<tr><td><code id="MVN.corr_+3A_var.types">var.types</code></td>
<td>
<p>The variable type corresponding to each column in dat, taking values of &quot;NCT&quot; for continuous data, &quot;O&quot; for ordinal or binary data, or &quot;C&quot; for count data.</p>
</td></tr>
<tr><td><code id="MVN.corr_+3A_ord.mps">ord.mps</code></td>
<td>
<p>A list containing marginal probabilities for binary and ordinal variables as packaged from output in <code>ordmps</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="MVN.corr_+3A_nct.sum">nct.sum</code></td>
<td>
<p>A matrix containing summary statistics for continuous variables as packaged from output in <code>nctsum</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="MVN.corr_+3A_count.rate">count.rate</code></td>
<td>
<p>A vector containing rates for count variables as packaged from output in <code>countrate</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The intermediate correlation matrix.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper correlation bounds. <em>The American Statistician</em>, <b>65(2)</b>, 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R. J. (2012). Simulation of massive public health data by power polynomials. <em>Statistics in Medicine</em>, <b>31(27)</b>, 3337-3346.
</p>
<p>Demirtas, H. (2016). A note on the relationship between the phi coefficient and the tetrachoric correlation under nonnormal underlying distributions. <em>The American Statistician</em>, <b>70(2)</b>, 143-148.
</p>
<p>Demirtas, H. and Hedeker, D. (2016). Computing the point-biserial correlation under any underlying continuous distribution. <em>Communications in Statistics-Simulation and Computation</em>, <b>45(8)</b>, 2744-2751.
</p>
<p>Demirtas, H., Ahmadian, R., Atis, S., Can, F.E., and Ercan, I. (2016). A nonnormal look at polychoric correlations: modeling the change in correlations before and after discretization. <em>Computational Statistics</em>, <b>31(4)</b>, 1385-1401.
</p>
<p>Ferrari, P.A. and Barbiero, A. (2012). Simulating ordinal data. <em>Multivariate Behavioral Research</em>, <b>47(4)</b>, 566-589.
</p>
<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>
<p>Vale, C.D. and Maurelli, V.A. (1983). Simulating multivariate nonnormal distributions. <em>Psychometrika</em>, <b>48(3)</b>, 465-471.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+MVN.dat">MVN.dat</a></code>, <code><a href="#topic+ordmps">ordmps</a></code>, <code><a href="#topic+nctsum">nctsum</a></code>, <code><a href="#topic+countrate">countrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PoisBinOrdNonNor)
n&lt;-1e4
lambdas&lt;-list(1, 3)
mps&lt;-list(c(.2, .8), c(.6, 0, .3, .1))
moms&lt;-list(c(-1, 1, 0, 1), c(0, 3, 0, 2))
  
#generate Poisson, ordinal, and continuous data
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(6) + .2, 
                               no.pois = length(lambdas), 
                               no.ord = length(mps),
                               no.nonn = length(moms), 
                               pois.list = lambdas, 
                               ord.list = mps, 
                               nonn.list = moms)

mydata &lt;- genPBONN(n, 
                   no.pois = length(lambdas), 
                   no.ord = length(mps), 
                   no.nonn = length(moms),
                   cmat.star = cmat.star, 
                   pois.list = lambdas,
                   ord.list = mps, 
                   nonn.list = moms)

#set a sample of each variable to missing
mydata&lt;-apply(mydata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

mydata&lt;-data.frame(mydata)

#get information for use in function
ord.info&lt;-ordmps(ord.dat=mydata[,c('X3', 'X4')])
nct.info&lt;-nctsum(nct.dat=mydata[,c('X5', 'X6')])
count.info&lt;-countrate(count.dat=mydata[,c('X1', 'X2')])

#extract marginal probabilites, continuous properties, and count rates
mps&lt;-sapply(ord.info, "[[", 2)
nctsum&lt;-sapply(nct.info, "[[", 2)
rates&lt;-sapply(count.info, "[[", 2)

#replace continuous with standardized forms
mydata[,c('X5', 'X6')]&lt;-sapply(nct.info, "[[", 1)[,c('X5', 'X6')] 

var.types&lt;-c('C', 'C', 'O', 'O', 'NCT', 'NCT')
mvn.cmat&lt;-MVN.corr(indat=mydata,
                   var.types=var.types,
                   ord.mps=mps,
                   nct.sum=nctsum,
                   count.rate=rates)

</code></pre>

<hr>
<h2 id='MVN.dat'>Computation of Normal Scores for Multivariate Data</h2><span id='topic+MVN.dat'></span>

<h3>Description</h3>

<p>This function assigns a normal score to binary and ordinal variables using normal quantiles in this appropriate range dictated by marginal proportions; a normal score to count variables based on the equivalence of CDFs of Poisson and normal distribution in the appropriate range dictated by the rate parameters; and a normal score for each continuous measurement by finding the normal root in the Fleishman equation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVN.dat(ord.info=NULL, nct.info=NULL, count.info=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN.dat_+3A_ord.info">ord.info</code></td>
<td>
<p>A list containing binary and ordinal data and corresponding marginal probabilities as packaged in <code>ordmps</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="MVN.dat_+3A_nct.info">nct.info</code></td>
<td>
<p>A list containing standardized continuous data and corresponding summary statistics for continuous variables as packaged in <code>nctsum</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="MVN.dat_+3A_count.info">count.info</code></td>
<td>
<p>A list containing count data and corresponding rates as packaged in <code>countrate</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing normal scores for each variable input.</p>


<h3>References</h3>

<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+ordmps">ordmps</a></code>, <code><a href="#topic+nctsum">nctsum</a></code>, <code><a href="#topic+countrate">countrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PoisBinOrdNonNor)
n&lt;-1e4
lambdas&lt;-list(1)
mps&lt;-list(c(.2, .8))
moms&lt;-list(c(-1, 1, 0, 1))
  
#generate Poisson, ordinal, and continuous data
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(3) + .2, 
                               no.pois = length(lambdas), 
                               no.ord = length(mps),
                               no.nonn = length(moms), 
                               pois.list = lambdas, 
                               ord.list = mps, 
                               nonn.list = moms)

mydata &lt;- genPBONN(n, 
                   no.pois = length(lambdas), 
                   no.ord = length(mps), 
                   no.nonn = length(moms),
                   cmat.star = cmat.star, 
                   pois.list = lambdas,
                   ord.list = mps, 
                   nonn.list = moms)

#set a sample of each variable to missing
mydata&lt;-apply(mydata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

mydata&lt;-data.frame(mydata)

#get information for use in function
count.info&lt;-countrate(count.dat=data.frame(mydata[,c('X1')]))
ord.info&lt;-ordmps(ord.dat=data.frame(mydata[,c('X2')]))
nct.info&lt;-nctsum(nct.dat=data.frame(mydata[,c('X3')]))

mvn.dat&lt;-MVN.dat(ord.info=ord.info,
                 nct.info=nct.info,
                 count.info=count.info) #outputs in order of continuous, ordinal, count
                   
</code></pre>

<hr>
<h2 id='nctsum'>Summary and Standardization of Continuous Data</h2><span id='topic+nctsum'></span>

<h3>Description</h3>

<p>This function calculates mean, variance, skewness, excess kurtosis, and Fleishman coefficients for continuous data and also standardizes each variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nctsum(nct.dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nctsum_+3A_nct.dat">nct.dat</code></td>
<td>
<p>A data frame consisting of continuous variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length ncol(nct.dat) containing the standardized data and summary statistics for each variable in nct.dat.</p>


<h3>References</h3>

<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+MVN.corr">MVN.corr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PoisBinOrdNonNor)
set.seed(123)
n&lt;-1e4

#first four moments for each simulated variable
moms&lt;-list(c(-1, 1, 0, 1), c(0, 3, 0, 2)) 
  
#generate continuous data
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(2) + .2, 
                               no.nonn = 2, 
                               nonn.list = moms)

nctdata &lt;- genPBONN(n,
                    no.nonn = length(moms),
                    cmat.star = cmat.star, 
                    nonn.list = moms)

#set a sample of each variable to missing
nctdata&lt;-apply(nctdata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

nctdata&lt;-data.frame(nctdata)
nctinfo&lt;-nctsum(nctdata)
</code></pre>

<hr>
<h2 id='ordmps'>Computation of Marginal Probabilities for Binary and Ordinal Data</h2><span id='topic+ordmps'></span>

<h3>Description</h3>

<p>This function computes the empirical marginal probabilities for binary and ordinal data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordmps(ord.dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordmps_+3A_ord.dat">ord.dat</code></td>
<td>
<p>A data frame consisting of binary and ordinal variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length ncol(ord.dat) containing the data and empirical marginal probabilities for each variable in ord.dat.</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+MVN.corr">MVN.corr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PoisBinOrdNonNor)
set.seed(123)
n&lt;-1e4
mps&lt;-list(c(.2, .8), c(.6, 0, .3, .1))

#generate ordinal data
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(2) + .2, 
                               no.ord = length(mps),
                               ord.list = mps)

orddata &lt;- genPBONN(n, 
                    no.ord = length(mps), 
                    cmat.star = cmat.star, 
                    ord.list = mps)

#set a sample of each variable to missing
orddata&lt;-apply(orddata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

orddata&lt;-data.frame(orddata)
ordinfo&lt;-ordmps(orddata)
</code></pre>

<hr>
<h2 id='trMVN.dat'>Transformation of Normal Scores</h2><span id='topic+trMVN.dat'></span>

<h3>Description</h3>

<p>This function backtransforms normal scores for ordinal variables using the thresholds determined by the marginal proportions using quantiles of the normal distribution; normal scores for continuous variables by the sum of linear combinations of standard normals using the corresponding Fleishman coefficients; and normal scores for count variables by the inverse cdf matching procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>trMVN.dat(indat, ord.mps=NULL, nct.sum=NULL, count.rate=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trMVN.dat_+3A_indat">indat</code></td>
<td>
<p>A list of data frames of normal scores to be backtransformed.</p>
</td></tr>
<tr><td><code id="trMVN.dat_+3A_ord.mps">ord.mps</code></td>
<td>
<p>A list containing marginal probabilities for binary and ordinal variables as packaged from output in <code>ordmps</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="trMVN.dat_+3A_nct.sum">nct.sum</code></td>
<td>
<p>A matrix containing summary statistics for continuous variables as packaged from output in <code>nctsum</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="trMVN.dat_+3A_count.rate">count.rate</code></td>
<td>
<p>A vector containing rates for count variables as packaged from output in <code>countrate</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing backtransformed data.</p>


<h3>References</h3>

<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>, <code><a href="#topic+ordmps">ordmps</a></code>, <code><a href="#topic+nctsum">nctsum</a></code>, <code><a href="#topic+countrate">countrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sndat&lt;-data.frame(matrix(rnorm(1e4), ncol=5, nrow=1e4/5))

#ordinal marginal probabilities
m1&lt;-c(0.4, 0.6)
names(m1)&lt;-c(0,1)
m2&lt;-c(0.2, 0.3, 0.5)
names(m2)&lt;-c(0,2,3)
mps&lt;-list(X1=m1, X2=m2)

#count rates
rates&lt;-c(2, 3)
names(rates)&lt;-c('X3', 'X4')

#continuous
nctsum&lt;-data.frame(X5=c(1, 1, -0.31375, 0.82632, 0.31375, 0.02271)) #Weibull(1,1)
rownames(nctsum)&lt;-c('Mean', 'Variance', 'a', 'b', 'c', 'd')

trdat&lt;-trMVN.dat(indat=list(sndat), ord.mps=mps, nct.sum=nctsum, count.rate=rates)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
