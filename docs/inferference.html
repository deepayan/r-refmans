<!DOCTYPE html><html lang="en"><head><title>Help for package inferference</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inferference}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diagnose_weights'><p>Plot histograms of weights from an interference object</p></a></li>
<li><a href='#direct_effect'><p>Retreive Direct Effect estimates</p></a></li>
<li><a href='#get_args'><p>Get arguments from a function</p></a></li>
<li><a href='#indirect_effect'><p>Retreive Indirect Effect estimates</p></a></li>
<li><a href='#inferference'><p>Methods for causal inference with interference</p></a></li>
<li><a href='#interference'><p>Estimate Causal Effects in presence of interference</p></a></li>
<li><a href='#log_likelihood'><p>Log Likelihood</p></a></li>
<li><a href='#logit_integrand'><p>Default integrand for the group-level propensity score</p></a></li>
<li><a href='#overall_effect'><p>Retrieve Overall Effect Estimates</p></a></li>
<li><a href='#print.interference'><p>Prints a summary of an interference object</p></a></li>
<li><a href='#score_calc'><p>Compute scores for a single group</p></a></li>
<li><a href='#score_matrix'><p>Calculate matrix of log Likelihood derivatives</p></a></li>
<li><a href='#total_effect'><p>Retrieve Total Effect estimates</p></a></li>
<li><a href='#vaccinesim'><p>Vaccine Study Sample Data</p></a></li>
<li><a href='#voters'><p>Voting Contagion Experiment Data</p></a></li>
<li><a href='#wght_calc'><p>Compute IPW weight</p></a></li>
<li><a href='#wght_deriv_array'><p>Create an array of group weight derivatives</p></a></li>
<li><a href='#wght_deriv_calc'><p>Compute the derivative(s) of a weight</p></a></li>
<li><a href='#wght_matrix'><p>Creates a number of groups by number of allocation schemes matrix of group weights.</p>
Allocation schemes are selected by the user.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Causal Inference with Interference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Bradley Saul</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bradley Saul &lt;bradleysaul@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for estimating causal effects in the presence of interference described in  B. Saul and M. Hugdens (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v082.i02">doi:10.18637/jss.v082.i02</a>&gt;. Currently it implements the inverse-probability weighted (IPW) estimators proposed by E.J. Tchetgen Tchetgen and T.J. Vanderweele (2012) &lt;<a href="https://doi.org/10.1177%2F0962280210386779">doi:10.1177/0962280210386779</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv (&ge; 2012.9-1), lme4 (&ge; 1.1-6), Formula (&ge; 1.1-2),
methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-21 10:44:33 UTC; bsaul</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-21 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='diagnose_weights'>Plot histograms of weights from an interference object</h2><span id='topic+diagnose_weights'></span>

<h3>Description</h3>

<p>Plot histograms of weights from an interference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose_weights(obj, allocations = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_weights_+3A_obj">obj</code></td>
<td>
<p>an <code>interference</code> object</p>
</td></tr>
<tr><td><code id="diagnose_weights_+3A_allocations">allocations</code></td>
<td>
<p>optional numeric vector of allocations for which to print
histogram. If NULL (the default), five allocations selected evenly from the 
first allocation to the last are printed.</p>
</td></tr>
<tr><td><code id="diagnose_weights_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>histogram of group-level weights
</p>

<hr>
<h2 id='direct_effect'>Retreive Direct Effect estimates</h2><span id='topic+direct_effect'></span>

<h3>Description</h3>

<p>Retrieves the population average direct causal effect for a 
specified allocation:
<code class="reqn">\hat{Y}(0, alpha) - \hat{Y}(1, alpha)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_effect(object, allocation = NULL, trt.lvl1 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_effect_+3A_object">object</code></td>
<td>
<p>an object of class <code>interference</code></p>
</td></tr>
<tr><td><code id="direct_effect_+3A_allocation">allocation</code></td>
<td>
<p>the allocation scheme for which to estimate direct effects.
If NULL, then returns all direct effects.</p>
</td></tr>
<tr><td><code id="direct_effect_+3A_trt.lvl1">trt.lvl1</code></td>
<td>
<p>Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with requested values
</p>

<hr>
<h2 id='get_args'>Get arguments from a function</h2><span id='topic+get_args'></span>

<h3>Description</h3>

<p>Extracts the names of the arguments from a function, and creates a list
of those arguments where they exist in ... .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_args(FUN, args_list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_args_+3A_fun">FUN</code></td>
<td>
<p>function for which to find arguments</p>
</td></tr>
<tr><td><code id="get_args_+3A_args_list">args_list</code></td>
<td>
<p>a list of arguments. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_args_+3A_...">...</code></td>
<td>
<p>any arguments. Those necessary for FUN must be named as appropriate for FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arguments for FUN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myargs &lt;- get_args(lm, formula = Sepal.Length ~ Sepal.Width, data = iris )
summary(do.call('lm', myargs))
</code></pre>

<hr>
<h2 id='indirect_effect'>Retreive Indirect Effect estimates</h2><span id='topic+indirect_effect'></span><span id='topic+ie'></span>

<h3>Description</h3>

<p>Retrieves the population average indirect causal effect for
specified allocations:
<code class="reqn">\hat{Y}(0, alpha1) - \hat{Y}(0, alpha2)</code>. 
This is the effect due to the coverage (allocation) levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirect_effect(object, allocation1, allocation2 = NULL, trt.lvl = 0)

ie(object, allocation1, allocation2 = NULL, trt.lvl = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indirect_effect_+3A_object">object</code></td>
<td>
<p>an object of class <code>interference</code></p>
</td></tr>
<tr><td><code id="indirect_effect_+3A_allocation1">allocation1</code></td>
<td>
<p>the allocation scheme for which to estimate indirect effects</p>
</td></tr>
<tr><td><code id="indirect_effect_+3A_allocation2">allocation2</code></td>
<td>
<p>the allocation scheme for which to estimate indirect effects.
If NULL, then returns all indirect effects compared to allocation1.</p>
</td></tr>
<tr><td><code id="indirect_effect_+3A_trt.lvl">trt.lvl</code></td>
<td>
<p>Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with requested values
</p>

<hr>
<h2 id='inferference'>Methods for causal inference with interference</h2><span id='topic+inferference'></span>

<h3>Description</h3>

<p>Interference occurs when the treatment of one unit affects outcomes of other
units. This package provides methods for estimating causal effects in the 
presence of interference. Currently it implements the IPW estimators 
proposed by Tchetgen Tchetgen and Vanderweele (2012) (doi: <a href="https://doi.org/10.1177/0962280210386779">10.1177/0962280210386779</a>)
and developed further in Heydrich-Perez et al. (2014) (doi: <a href="https://doi.org/10.1111/biom.12184">10.1111/biom.12184</a>).
</p>


<h3>References</h3>

<p>Saul, B. and Hugdens, M. G. (2017). 
A Recipe for inferference: Start with Causal Inference. Add Interference. Mix Well with R. 
Journal of Statistical Software, 82(2), 1-21. doi: <a href="https://doi.org/10.18637/jss.v082.i02">10.18637/jss.v082.i02</a>
</p>

<hr>
<h2 id='interference'>Estimate Causal Effects in presence of interference</h2><span id='topic+interference'></span>

<h3>Description</h3>

<p>Estimate Causal Effects in presence of interference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interference(
  formula,
  propensity_integrand = "logit_integrand",
  loglihood_integrand = propensity_integrand,
  allocations,
  data,
  model_method = "glmer",
  model_options = list(family = stats::binomial(link = "logit")),
  causal_estimation_method = "ipw",
  causal_estimation_options = list(variance_estimation = "robust"),
  conf.level = 0.95,
  rescale.factor = 1,
  integrate_allocation = TRUE,
  runSilent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interference_+3A_formula">formula</code></td>
<td>
<p>The formula used to define the causal model.  Has a minimum 
of 4 parts, separated by <code>|</code> and <code>~</code> in a specific structure: 
<code>outcome | exposure ~ propensity covariates | group</code>. The order matters, 
and the pipes split the data frame into corresponding pieces. The part 
separated by <code>~</code> is passed to the chosen <code>model_method</code> used to 
estimate or fix propensity parameters.</p>
</td></tr>
<tr><td><code id="interference_+3A_propensity_integrand">propensity_integrand</code></td>
<td>
<p>A function, which may be created by the user, 
used to compute the IP weights. This defaults to <code>logit_integrand</code>, 
which calculates the product of inverse logits for individuals in a group: 
<code class="reqn">\prod_{j = 1}^{n_i} \{r \times h_{ij}(b_i)^{A_{ij}}\}\{1 - r \times 
h_{ij}(b_i)\}^{1 - A_{ij}} f_b(b_i; \theta_s)</code> where </p>
<p style="text-align: center;"><code class="reqn">h_{ij}(b_i) = logit^{-1}
(\mathbf{X}_{ij}\theta_a + b_i)</code>
</p>
<p> and <code class="reqn">b_i</code> is a group-level random effect, 
<code class="reqn">f_b</code> is a <code class="reqn">N(0, \theta_s)</code> density, and <code class="reqn">r</code> is a known 
randomization probability which may be useful if a participation vector is 
included in the <code>formula</code>. If no random effect was included in the 
<code>formula</code>, <code>logit_integrand</code> essentially ignores the random effect 
and <code class="reqn">f_b(b_i, \theta_s)</code> integrates to 1. See details for arguments that 
can be passed to <code>logit_integrand</code></p>
</td></tr>
<tr><td><code id="interference_+3A_loglihood_integrand">loglihood_integrand</code></td>
<td>
<p>A function, which may be created by the user, that
defines the log likelihood of the logit model used for <code>robust</code> variance
estimation. Generally, this will be the same function as 
<code>propensity_integrand</code>. Indeed, this is the default.</p>
</td></tr>
<tr><td><code id="interference_+3A_allocations">allocations</code></td>
<td>
<p>a vector of values in (0, 1). Increasing the number of 
elements of the allocation vector greatly increases computation time; however, 
a larger number of allocations will make plots look nicer. A minimum of two 
allocations is required.</p>
</td></tr>
<tr><td><code id="interference_+3A_data">data</code></td>
<td>
<p>the analysis data frame. This must include all the variables 
defined in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_model_method">model_method</code></td>
<td>
<p>the method used to estimate or set the propensity model 
parameters. Must be one of <code>'glm'</code>, <code>'glmer'</code>, or <code>'oracle'</code>. 
Defaults to <code>'glmer'</code>. For a fixed effects only model use <code>'glm'</code>, 
and to include random effects use<code>'glmer'</code>. <code>logit_integrand</code> 
only supports a single random effect for the grouping variable, so if more 
random effects are included in the model, different <code>propensity_integrand</code>
and <code>loglihood_integrand</code> functions should be defined. When the propensity 
parameters are known (as in simulations) or if estimating parameters by 
other methods, use the <code>'oracle'</code> option. See <code>model_options</code> for
details on how to pass the oracle parameters.</p>
</td></tr>
<tr><td><code id="interference_+3A_model_options">model_options</code></td>
<td>
<p>a list of options passed to the function in 
<code>model_method</code>. Defaults to <code>list(family = binomial(link = 'logit'))</code>. 
When <code>model_method = 'oracle'</code>, the list must have two elements (1)
<code>fixed_effects</code> and (2) <code>random_effects</code>. If the model did not include 
random effects, set <code>random.effects = NULL</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_causal_estimation_method">causal_estimation_method</code></td>
<td>
<p>currently only supports <code>'ipw'</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_causal_estimation_options">causal_estimation_options</code></td>
<td>
<p>A list. Current options are: (1) <code>variance_estimation</code> is 
either <code>'naive'</code> or <code>'robust'</code>. See details. Defaults to <code>'robust'</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_conf.level">conf.level</code></td>
<td>
<p>level for confidence intervals. Defaults to <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_rescale.factor">rescale.factor</code></td>
<td>
<p>a scalar multiplication factor by which to rescale outcomes
and effects. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="interference_+3A_integrate_allocation">integrate_allocation</code></td>
<td>
<p>Indicator of whether the integrand function uses 
the allocation parameter. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="interference_+3A_runsilent">runSilent</code></td>
<td>
<p>if FALSE, status of computations are printed to console. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="interference_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments to internal functions such as 
<code>numDeriv::grad()</code> or <code>integrate()</code>. Additionally, arguments can be 
passed to the <code>propensity_integrand</code> and <code>loglihood_integrand</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following formula includes a random effect for the group: <code>outcome | 
exposure ~ propensity covariates + (1|group) | group</code>. In this instance, the 
group variable appears twice. If the study design includes a &quot;participation&quot; 
variable, this is easily added to the formula: <code>outcome | exposure | 
participation ~ propensity covariates | group</code>. 
</p>
<p><code>logit_integrand</code> has two options that can be passed via the <code>...</code> 
argument: 
</p>

<ul>
<li> <p><code>randomization</code>: a scalar. This is the <code class="reqn">r</code> in the formula just 
above. It defaults to 1 in the case that a <code>participation</code> vector is not 
included. The vaccine study example demonstrates use of this argument.
</p>
</li>
<li> <p><code>integrate_allocation</code>: <code>TRUE/FALSE</code>. When group sizes grow 
large (over 1000), the product term of <code>logit_integrand</code> tends quickly to 0. 
When set to <code>TRUE</code>, the IP weights tend less quickly to 0. 
Defaults to <code>FALSE</code>.
</p>
</li></ul>

<p>If the true propensity model is known (e.g. in simulations) use 
<code>variance_estimatation = 'naive'</code>; otherwise, use the default 
<code>variance_estimatation = 'robust'</code>. Refer to the web appendix of
Heydrich-Perez et al. (2014) (doi: <a href="https://doi.org/10.1111/biom.12184">10.1111/biom.12184</a>)
for complete details.
</p>


<h3>Value</h3>

<p>Returns a list of overall and group-level IPW point estimates, overall 
and group-level IPW point estimates (using the weight derivatives), derivatives
of the loglihood, the computed weight matrix, the computed 
weight derivative array, and a summary.
</p>


<h3>References</h3>

<p>Saul, B. and Hugdens, M. G. (2017). 
A Recipe for inferference: Start with Causal Inference. Add Interference. Mix Well with R. 
Journal of Statistical Software, 82(2), 1-21. doi: <a href="https://doi.org/10.18637/jss.v082.i02">10.18637/jss.v082.i02</a>
</p>
<p>Perez-Heydrich, C., Hudgens, M. G., Halloran, M. E., Clemens, J. D., Ali, M., &amp; Emch, M. E. (2014). 
Assessing effects of cholera vaccination in the presence of interference. Biometrics, 70(3), 731-741.
</p>
<p>Tchetgen Tchetgen, E. J., &amp; VanderWeele, T. J. (2012). On causal inference in the presence of interference. 
Statistical Methods in Medical Research, 21(1), 55-75.
</p>

<hr>
<h2 id='log_likelihood'>Log Likelihood</h2><span id='topic+log_likelihood'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+score_matrix">score_matrix</a></code> to compute the log likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_likelihood(parameters, integrand, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_likelihood_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters passed to <code>integrand</code></p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_integrand">integrand</code></td>
<td>
<p>Defaults to logit_integrand</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>integrand</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of log likelihood
</p>

<hr>
<h2 id='logit_integrand'>Default integrand for the group-level propensity score</h2><span id='topic+logit_integrand'></span>

<h3>Description</h3>

<p>Computes the following function:
</p>
<p style="text-align: center;"><code class="reqn">\prod_{j=1}^{n} (r h_{j}(b))^{A_j}  (1 - r h_{j}(b))^{1 - A_j} 
f_b(b; \theta_b)</code>
</p>
 
<p>where <code class="reqn">r</code> is the randomization scheme. <code class="reqn">X</code> is the covariate(s) vectors. 
<code class="reqn">fixef</code> is the vector of fixed effects. <code class="reqn">b</code> is the random (group-level) effect.
<code class="reqn">ranef</code> is the random effect variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_integrand(b, X, A, parameters, allocation = A, randomization = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_integrand_+3A_b">b</code></td>
<td>
<p>vector argument of values necessary for <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="logit_integrand_+3A_x">X</code></td>
<td>
<p>n by length(fixed effects) matrix of covariates.</p>
</td></tr>
<tr><td><code id="logit_integrand_+3A_a">A</code></td>
<td>
<p>vector of binary treatments</p>
</td></tr>
<tr><td><code id="logit_integrand_+3A_parameters">parameters</code></td>
<td>
<p>vector of fixed effect (and random effect if applicable). 
Random effect should be last element in vector.</p>
</td></tr>
<tr><td><code id="logit_integrand_+3A_allocation">allocation</code></td>
<td>
<p>The allocation strategy. Defaults to A so that is essentially 
ignored if allocation is not set to a value within (0, 1).</p>
</td></tr>
<tr><td><code id="logit_integrand_+3A_randomization">randomization</code></td>
<td>
<p>Randomization probability. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the integrand
</p>

<hr>
<h2 id='overall_effect'>Retrieve Overall Effect Estimates</h2><span id='topic+overall_effect'></span><span id='topic+oe'></span>

<h3>Description</h3>

<p>Retrieves the population average overall causal effect:
<code class="reqn">\hat{Y}(alpha1) - \hat{Y}(lpha2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_effect(object, allocation1, allocation2 = NULL)

oe(object, allocation1, allocation2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overall_effect_+3A_object">object</code></td>
<td>
<p>an object of class <code>interference</code></p>
</td></tr>
<tr><td><code id="overall_effect_+3A_allocation1">allocation1</code></td>
<td>
<p>the allocation scheme for which to estimate overall effects</p>
</td></tr>
<tr><td><code id="overall_effect_+3A_allocation2">allocation2</code></td>
<td>
<p>the allocation scheme for which to estimate overall effects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with a single row with requested values
</p>

<hr>
<h2 id='print.interference'>Prints a summary of an interference object</h2><span id='topic+print.interference'></span>

<h3>Description</h3>

<p>Prints a summary of an interference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interference'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.interference_+3A_x">x</code></td>
<td>
<p>object of class 'interference'</p>
</td></tr>
<tr><td><code id="print.interference_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='score_calc'>Compute scores for a single group</h2><span id='topic+score_calc'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+score_matrix">score_matrix</a></code> to log likelihood derivatives for
a single group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_calc(parameters, integrand, hide.errors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_calc_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters passed to <code>integrand</code></p>
</td></tr>
<tr><td><code id="score_calc_+3A_integrand">integrand</code></td>
<td>
<p>function to used for the integrand.
Defaults to <code><a href="#topic+logit_integrand">logit_integrand</a></code>.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_hide.errors">hide.errors</code></td>
<td>
<p>Hide errors printed from <code>grad</code>.
Defaults to true.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_...">...</code></td>
<td>
<p>additional arguments pass to the integrand function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length(theta) vector of scores
</p>

<hr>
<h2 id='score_matrix'>Calculate matrix of log Likelihood derivatives</h2><span id='topic+score_matrix'></span>

<h3>Description</h3>

<p>Calculate matrix of log Likelihood derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_matrix(integrand, X, A, G, parameters, runSilent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_matrix_+3A_integrand">integrand</code></td>
<td>
<p>function passed to <code><a href="#topic+log_likelihood">log_likelihood</a></code>. Defaults to
<code><a href="#topic+logit_integrand">logit_integrand</a></code></p>
</td></tr>
<tr><td><code id="score_matrix_+3A_x">X</code></td>
<td>
<p>covariate matrix</p>
</td></tr>
<tr><td><code id="score_matrix_+3A_a">A</code></td>
<td>
<p>vector of treatment assignments</p>
</td></tr>
<tr><td><code id="score_matrix_+3A_g">G</code></td>
<td>
<p>vector of group assignments</p>
</td></tr>
<tr><td><code id="score_matrix_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters passed to <code>integrand</code></p>
</td></tr>
<tr><td><code id="score_matrix_+3A_runsilent">runSilent</code></td>
<td>
<p>If FALSE, prints errors to console. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="score_matrix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>integrand</code> or <code>grad</code>.
For example, one can change the <code>method</code> argument in <code>grad</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N X length(params) matrix of scores
</p>

<hr>
<h2 id='total_effect'>Retrieve Total Effect estimates</h2><span id='topic+total_effect'></span><span id='topic+te'></span>

<h3>Description</h3>

<p>Retrieves the population average total causal effect for
specified allocations:
<code class="reqn">\hat{Y}(0, alpha1) - \hat{Y}(1, alpha2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_effect(object, allocation1, allocation2 = NULL, trt.lvl1 = 0)

te(object, allocation1, allocation2 = NULL, trt.lvl1 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_effect_+3A_object">object</code></td>
<td>
<p>an object of class <code>interference</code></p>
</td></tr>
<tr><td><code id="total_effect_+3A_allocation1">allocation1</code></td>
<td>
<p>the allocation scheme for which to estimate total effects</p>
</td></tr>
<tr><td><code id="total_effect_+3A_allocation2">allocation2</code></td>
<td>
<p>the allocation scheme for which to estimate total effects
If NULL, then returns all indirect effects compared to allocation1.</p>
</td></tr>
<tr><td><code id="total_effect_+3A_trt.lvl1">trt.lvl1</code></td>
<td>
<p>Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with requested values
</p>

<hr>
<h2 id='vaccinesim'>Vaccine Study Sample Data</h2><span id='topic+vaccinesim'></span>

<h3>Description</h3>

<p>A sample dataset based on the simulations of a cholera vaccine trial 
in Heydrich-Perez et al. (2014) (doi: <a href="https://doi.org/10.1111/biom.12184">10.1111/biom.12184</a>)
except with 3000 individuals in 250 groups rather than 10000 in 500.
</p>


<h3>Format</h3>

<p>a dataset with 6 variables and 3000 rows
</p>

<ul>
<li><p>Ythe outcome (0 - no cholera; 1 - cholera)
</p>
</li>
<li><p>X1an individual's age (in decades)
</p>
</li>
<li><p>X2an individual's distance from river
</p>
</li>
<li><p>Aan indicator of vaccination (0 - no vaccine; 1 - vaccine)
</p>
</li>
<li><p>Ban indicator of participation (0 - did not participant in vaccine trial, 1 - did participate)
</p>
</li>
<li><p>groupgroup membership
</p>
</li></ul>



<h3>References</h3>

<p>Perez-Heydrich, C., Hudgens, M. G., Halloran, M. E., Clemens, J. D., Ali, M., &amp; Emch, M. E. (2014). 
Assessing effects of cholera vaccination in the presence of interference. Biometrics, 70(3), 731-741.
</p>

<hr>
<h2 id='voters'>Voting Contagion Experiment Data</h2><span id='topic+voters'></span>

<h3>Description</h3>

<p>A dataset of a voting contagion experiment. See Nickerson (2008) for more
details. The variables used in the package vignette are documented here.
</p>


<h3>Format</h3>

<p>a dataset with 21 variables and 7722 rows
</p>

<ul>
<li><p>familyhousehold ID
</p>
</li>
<li><p>denver1 = subject in Denver, 0 = Minneapolis
</p>
</li>
<li><p>treatment1 = voting encouragement, 2 = recycling message, 3 = not contacted
</p>
</li>
<li><p>reached1 = subject answered door, 0 = not
</p>
</li>
<li><p>hsecontact1 = household contacted by canvassers, 0 = not
</p>
</li>
<li><p>voted02p1 = voted in '02 primary, 0 = not
</p>
</li>
<li><p>partyparty affiliation
</p>
</li>
<li><p>ageage
</p>
</li>
<li><p>gendergender    
</p>
</li></ul>



<h3>References</h3>

<p>Nickerson, D. W. (2008). Is voting contagious? Evidence from two field experiments. 
American Political Science Review, 102(01), 49-57. doi: <a href="https://doi.org/10.1017/S0003055408080039">10.1017/S0003055408080039</a>
</p>

<hr>
<h2 id='wght_calc'>Compute IPW weight</h2><span id='topic+wght_calc'></span>

<h3>Description</h3>

<p>Calculates the IPW for a single group. Used by <code><a href="#topic+wght_matrix">wght_matrix</a></code> to
create a matrix of weights for each group and allocation scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wght_calc(parameters, integrand, allocation, integrate_allocation = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wght_calc_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameter values</p>
</td></tr>
<tr><td><code id="wght_calc_+3A_integrand">integrand</code></td>
<td>
<p>function to pass to the argument 'f' of <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="wght_calc_+3A_allocation">allocation</code></td>
<td>
<p>the allocation ratio for which to compute the weight</p>
</td></tr>
<tr><td><code id="wght_calc_+3A_integrate_allocation">integrate_allocation</code></td>
<td>
<p>Indicator of whether the integrand function uses 
the allocation parameter. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_calc_+3A_...">...</code></td>
<td>
<p>other arguments passed to integrand.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allocation</code> is an argument in the integrand function and
<code>integrate_allocation == TRUE</code>, then the weight is calcuated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{Pr(A|X)}</code>
</p>

<p>Otherwise, the weight is computed by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\prod_{j=1}^n \alpha^A_j (1 - \alpha)^(1-
A_j)}{Pr(A|X)}</code>
</p>



<h3>Value</h3>

<p>scalar result of the integral
</p>

<hr>
<h2 id='wght_deriv_array'>Create an array of group weight derivatives</h2><span id='topic+wght_deriv_array'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+wght_deriv_calc">wght_deriv_calc</a></code> to compute the weight derivatives for each
group per coverage level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wght_deriv_array(
  parameters,
  integrand,
  allocations,
  X,
  A,
  G,
  runSilent = TRUE,
  integrate_allocation = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wght_deriv_array_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters passed to <code>integrand</code></p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_integrand">integrand</code></td>
<td>
<p>function to pass to the argument 'f' of <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_allocations">allocations</code></td>
<td>
<p>coverage levels in [0, 1]. Can be vector.</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_x">X</code></td>
<td>
<p>covariate matrix</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_a">A</code></td>
<td>
<p>vector of treatment assignments</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_g">G</code></td>
<td>
<p>vector of group assignments</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_runsilent">runSilent</code></td>
<td>
<p>if FALSE, errors are printed to console. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_integrate_allocation">integrate_allocation</code></td>
<td>
<p>Indicator of whether the integrand function uses 
the allocation parameter. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_deriv_array_+3A_...">...</code></td>
<td>
<p>other arguments passed to integrand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length(unique(group)) X length(params) X length(alphas) array of
group weight derivatives
</p>

<hr>
<h2 id='wght_deriv_calc'>Compute the derivative(s) of a weight</h2><span id='topic+wght_deriv_calc'></span>

<h3>Description</h3>

<p>Takes the derivative of the <code><a href="#topic+wght_calc">wght_calc</a></code> function with respect to each
parameter in <code>params</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wght_deriv_calc(
  integrand,
  parameters,
  allocation,
  integrate_allocation = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wght_deriv_calc_+3A_integrand">integrand</code></td>
<td>
<p>function to pass to the argument 'f' of <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="wght_deriv_calc_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameter values</p>
</td></tr>
<tr><td><code id="wght_deriv_calc_+3A_allocation">allocation</code></td>
<td>
<p>the allocation ratio for which to compute the weight</p>
</td></tr>
<tr><td><code id="wght_deriv_calc_+3A_integrate_allocation">integrate_allocation</code></td>
<td>
<p>Indicator of whether the integrand function uses 
the allocation parameter. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_deriv_calc_+3A_...">...</code></td>
<td>
<p>other arguments passed to integrand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of derivatives with respect to element of params
</p>

<hr>
<h2 id='wght_matrix'>Creates a number of groups by number of allocation schemes matrix of group weights.
Allocation schemes are selected by the user.</h2><span id='topic+wght_matrix'></span>

<h3>Description</h3>

<p>Groups should be numbered 1, ..., N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wght_matrix(
  integrand,
  allocations,
  X,
  A,
  G,
  parameters,
  runSilent = TRUE,
  integrate_allocation = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wght_matrix_+3A_integrand">integrand</code></td>
<td>
<p>function to pass to the argument 'f' of <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_allocations">allocations</code></td>
<td>
<p>coverage levels in [0, 1]. Can be vector.</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_x">X</code></td>
<td>
<p>covariate matrix</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_a">A</code></td>
<td>
<p>vector of treatment assignments</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_g">G</code></td>
<td>
<p>vector of group assignments</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters passed to <code>integrand</code></p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_runsilent">runSilent</code></td>
<td>
<p>if FALSE, errors are printed to console. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_integrate_allocation">integrate_allocation</code></td>
<td>
<p>Indicator of whether the integrand function uses 
the allocation parameter. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="wght_matrix_+3A_...">...</code></td>
<td>
<p>other arguments passed to integrand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length(unique(group)) X length(alphas) matrix of group weights
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
