<!DOCTYPE html><html lang="en"><head><title>Help for package mrfDepth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mrfDepth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjOutl'><p>Adjusted outlyingness of points relative to a dataset</p></a></li>
<li><a href='#bagdistance'><p>Bagdistance of points relative to a dataset</p></a></li>
<li><a href='#bagplot'><p>Draws a bagplot, a bivariate boxplot</p></a></li>
<li><a href='#bloodfat'><p>Blood data for patients with narrowing arteries</p></a></li>
<li><a href='#cardata90'><p>Car data from Consumer Reports in 1990</p></a></li>
<li><a href='#characterA'><p>Writing trajectories of the letter 'a'</p></a></li>
<li><a href='#characterI'><p>Writing trajectories of the letter i</p></a></li>
<li><a href='#cmltest'><p>Test for linearity of the conditional median in simple regression</p></a></li>
<li><a href='#compBagplot'><p>Computations for drawing a bagplot</p></a></li>
<li><a href='#depthContour'><p>Depth contours of multivariate data</p></a></li>
<li><a href='#dirOutl'><p>Directional outlyingness of points relative to a dataset</p></a></li>
<li><a href='#distSpace'><p>distSpace</p></a></li>
<li><a href='#dprojdepth'><p>Directional projection depth of points relative to a dataset</p></a></li>
<li><a href='#dprojmedian'><p>Location estimates based on directional projection depth</p></a></li>
<li><a href='#fHeatmap'><p>Draws a heatmap of functional depth values or distances</p></a></li>
<li><a href='#fom'><p>Draws the Functional Outlier Map (FOM)</p></a></li>
<li><a href='#fOutl'><p>Functional outlyingness measures for functional data</p></a></li>
<li><a href='#geological'><p>Composition of elements in soil samples around the Baltic Sea</p></a></li>
<li><a href='#glass'><p>EXPMA spectra of glass samples</p></a></li>
<li><a href='#hdepth'><p>Halfspace depth of points relative to a dataset</p></a></li>
<li><a href='#hdepthmedian'><p>Location estimates based on halfspace depth.</p></a></li>
<li><a href='#medcouple'><p>A robust measure of skewness for univariate data</p></a></li>
<li><a href='#mfd'><p>Multivariate functional depth for functional data</p></a></li>
<li><a href='#mfdmedian'><p>Multivariate functional median for functional data</p></a></li>
<li><a href='#mrainbowplot'><p>Rainbow plot for bivariate data</p></a></li>
<li><a href='#mri'><p>Intensities of MRI images</p></a></li>
<li><a href='#octane'><p>Near infrared spectra of gasoline samples</p></a></li>
<li><a href='#outlyingness'><p>Stahel-Donoho outlyingness of points relative to a dataset</p></a></li>
<li><a href='#plane'><p>Fighter plane dataset</p></a></li>
<li><a href='#plotContours'><p>Draws depth contours of bivariate data</p></a></li>
<li><a href='#projdepth'><p>Projection depth of points relative to a dataset</p></a></li>
<li><a href='#projmedian'><p>Location estimates based on projection depth</p></a></li>
<li><a href='#rdepth'><p>Regression depth of hyperplanes</p></a></li>
<li><a href='#rdepthmedian'><p>Hyperplane of maximal regression depth</p></a></li>
<li><a href='#sdepth'><p>Simplicial depth of points relative to a dataset</p></a></li>
<li><a href='#sprojdepth'><p>Skewness-adjusted projection depth of points relative to a dataset</p></a></li>
<li><a href='#sprojmedian'><p>Location estimates based on skewness-adjusted projection depth</p></a></li>
<li><a href='#stars'><p>stars data</p></a></li>
<li><a href='#symtest'><p>Test for angular symmetry around a specified center for bivariate data</p></a></li>
<li><a href='#tablets'><p>Near Infrared Spectroscopy responses for a batch of pills</p></a></li>
<li><a href='#wine'><p>Proton Nuclear Magnetic Resonance spectra of 40 different wine samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.17</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Depth Measures in Multivariate, Regression and Functional
Settings</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to compute depth measures and implementations of related 
             tasks such as outlier detection, data exploration and 
            classification of multivariate, regression and functional data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, geometry, grid, matrixStats, reshape2, Rcpp (&ge; 0.12.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>robustbase</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen (&ge; 0.3.2.9.0), Rcpp (&ge; 0.12.6), RcppArmadillo
(&ge; 0.7.600.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-24 11:42:45 UTC; Jakob Raymaekers</td>
</tr>
<tr>
<td>Author:</td>
<td>Pieter Segaert [aut],
  Mia Hubert [aut],
  Peter Rousseeuw [aut],
  Jakob Raymaekers [aut, cre],
  Kaveh Vakili [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Raymaekers &lt;jakob.raymaekers@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-24 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjOutl'>Adjusted outlyingness of points relative to a dataset</h2><span id='topic+adjOutl'></span>

<h3>Description</h3>

<p>Computes the skew-adjusted outlyingness of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. For each multivariate point <code class="reqn">z_i</code>, its adjusted outlyingness relative to <code>x</code> is defined as its maximal univariate adjusted outlyingness measured over all directions. To obtain the univariate adjusted outlyingness in the direction <code class="reqn">v</code>, the dataset <code>x</code> is projected on <code class="reqn">v</code>, and the robustly skew-adjusted standardized distance of <code class="reqn">v'z_i</code> to the median of the projected data points <code>x</code><code class="reqn">v</code> is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjOutl(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjOutl_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="adjOutl_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the adjusted outlyingness. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="adjOutl_+3A_options">options</code></td>
<td>
<p> A list of available options:
</p>

<ul>
<li> <p><code>type</code> <br />
Determines the desired type of invariance and should be
one of <code>"Affine"</code>, <code>"Rotation"</code> or <code>"Shift"</code>.
When the option <code>"Affine"</code> is used,  the directions
<code class="reqn">v</code> are orthogonal to hyperplanes spanned by <code class="reqn">p</code>
observations from <code>x</code>. When the option <code>"Rotation"</code>
is used, the directions pass by two randomly selected
observations from <code>x</code>. With the option <code>"Shift"</code>,
directions are randomly generated.<br />
Defaults to <code>"Affine"</code>.
</p>
</li>
<li> <p><code>ndir</code> <br />
Determines the number of directions <code class="reqn">v</code> by setting
<code>ndir</code> to a specific number or to <code>"all"</code>.
In the latter case, an exhaustive search over all possible
directions (according to <code>type</code>) is performed.
If <code>ndir</code> is larger than the number of possible directions,
the algorithm will automatically use this setting. <br />
Defaults to
<code class="reqn">250p</code> when <code>type="Affine"</code>, to 5000 when
<code>type="Rotation"</code> and to 12500 when <code>type="Shift"</code>.
</p>
</li>
<li> <p><code>seed</code>  <br />
A strictly positive integer specifying the seed to be used
by the <code>C++</code> code.<br />
Defaults to <code class="reqn">10</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted outlyingness (AO) of multivariate data was introduced in Brys et al. (2005) and studied in more detail in Hubert and Van der Veeken (2008). It extends the Stahel-Donoho outlyingness towards skewed distributions.
</p>
<p>Depending on the dimension <code class="reqn">p</code>, different approximate algorithms are implemented. The affine invariant algorithm can only be used when <code class="reqn">n &gt; p</code>. It draws <code>ndir</code> times at random <code class="reqn">p</code> observations from <code>x</code> and considers the direction orthogonal to the hyperplane spanned by these <code class="reqn">p</code> observations. At most <code class="reqn">p</code> out of <code class="reqn">n</code> directions can be considered. The orthogonal invariant version can be applied to high-dimensional data. It draws <code>ndir</code> times at random <code class="reqn">2</code> observations from <code>x</code> and considers the direction through these two observations. Here, at most 2 out of <code class="reqn">n</code> directions can be considered. Finally, the shift invariant version randomly draws <code>ndir</code> vectors from the unit sphere.
</p>
<p>The resulting AO values are invariant to affine transformations, rotations and shifts respectively provided that the <code>seed</code> is kept fixed at different runs of the algorithm. Note that the AO values are guaranteed to increase when more directions are considered provided the seed is kept fixed, as this ensures that the random directions are generated in a fixed order.
</p>
<p>An observation from <code>x</code> and <code>z</code> is flagged as an outlier if its AO exceeds a cutoff value. This cutoff value is determined using the procedure in Rousseeuw et al. (2018). First, the logarithm of the AO values is taken to render their distribution more symmetric, after which a normal approximation yields a cutoff on these values. The cutoff is then transformed back by applying the exponential function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it. Furthermore, the univariate adjusted outlyingness of the projected points <code>x</code><code class="reqn">v</code> is ill-defined when the scale in its denominator becomes zero. This can happen when many observations collapse. In these cases the algorithm will stop and give a warning. The returned values then include the direction <code class="reqn">v</code> as well as an indicator specifying which of the observations of <code>x</code> belong to the hyperplane orthogonal to <code class="reqn">v</code>.
</p>
<p>This function extends the <code>adjOutlyingness</code> function in the package <code>robustbase</code>. It has more options for choosing the directions, it allows to compute the adjusted outlyingness of points not belonging to the data matrix <code>x</code> and it is faster as it is fully implemented in C++. On the other hand, the constants (3 and -4) used in the definition of the adjusted outlyingness can not be modified in this implementation.
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>outlyingnessX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the adjusted
outlyingness of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>outlyingnessZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the adjusted
outlyingness of the points in <code>z</code> relative to <code>x</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose adjusted outlyingness exceeds this cutoff can be considered as outliers with respect to <code>x</code>. </p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose adjusted outlyingness exceeds the cutoff receive a flag <code>FALSE</code>, regular observations receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose adjusted outlyingness exceeds the cutoff receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In such a case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
When the input parameter type is equal to <code>"Rotation"</code> it
is possible that two randomly selected points of the data coincide
due to ties in the data. In such a case this value signals how many
times this happens.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace. When a direction <code class="reqn">v</code> is found such that the robust skew-adjusted scale of <code>x</code><code class="reqn">v</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that AO(<code>x</code><code class="reqn">v</code>) is ill-defined, the observations from <code>x</code> which belong to the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert using <code>C++</code> code by K. Vakili, P. Segaert, G. Brys and M. Maechler.</p>


<h3>References</h3>

<p>Brys G., Hubert M., Rousseeuw P.J. (2005). A robustification of Independent Component Analysis. <em>Journal of Chemometrics</em>, <b>19</b>, 364&ndash;375.
</p>
<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>
<p>Hubert M., Vandervieren E. (2008). An adjusted boxplot for skewed distributions. <em>Computational Statistics &amp; Data Analysis</em>, <b>52</b>, 5186&ndash;5201.
</p>
<p>Rousseeuw P.J., Raymaekers J., Hubert M., (2018). A measure of directional outlyingness with applications to image data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sprojdepth">sprojdepth</a></code>, <code><a href="#topic+sprojmedian">sprojmedian</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>
<p><code><a href="robustbase.html#topic+adjbox">adjbox</a></code>, <code><a href="robustbase.html#topic+adjOutlyingness">adjOutlyingness</a></code> from package robustbase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the adjusted outlyingness of a simple
# two-dimensional dataset. Outliers are plotted
# in red.
data(geological)
BivData &lt;- geological[c("MnO","MgO")]
Result &lt;- adjOutl(x = BivData)
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# The number of directions may be specified through
# the option list. The resulting adjusted outlyingness
# is monotone increasing in the number of directions.
Result1 &lt;- adjOutl(x = BivData,
                   options = list(ndir = 50)
                   )
Result2 &lt;- adjOutl(x = BivData,
                   options = list(ndir = 100)
                   )
which(Result2$outlyingnessX - Result1$outlyingnessX &lt; 0)
# This is however not the case when the seed is changed
Result1 &lt;- adjOutl(x = BivData,
                   options = list(ndir = 50)
                   )
Result2 &lt;- adjOutl(x = BivData,
                   options = list(ndir = 100,
                                  seed = 950)
                   )
plot(Result2$outlyingnessX - Result1$outlyingnessX,
     xlab = "Index", ylab = "Difference in AO")

# We can also consider directions through two data
# points. If the sample is small enough one may opt
# to search over all choose(n,2) directions.
# Note that the computational load increases dramatically
# as n becomes larger.
data(bloodfat)
BivData &lt;- bloodfat[1:100,] # Consider a small toy example.
Result &lt;- adjOutl(x = BivData,
                  options = list(type = "Rotation",
                                 ndir = "all")
                  )
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# Alternatively one may consider randomly generated directions.
data(bloodfat)
Result &lt;- adjOutl(x = bloodfat,
                  options = list(type = "Shift",
                                 ndir = 1000)
                  )
IndOutliers &lt;- which(!Result$flagX)
plot(bloodfat)
points(bloodfat[IndOutliers,], col = "red")
</code></pre>

<hr>
<h2 id='bagdistance'>Bagdistance of points relative to a dataset</h2><span id='topic+bagdistance'></span>

<h3>Description</h3>

<p>Computes the bagdistance of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. To compute the bagdistance of a point <code class="reqn">z_i</code> first the bag of <code>x</code> is computed as the depth region containing the 50% observations (of <code>x</code>) with largest halfspace depth. Next, the ray from the halfspace median <code class="reqn">\theta</code> through <code class="reqn">z_i</code> is considered and <code class="reqn">c_z</code> is defined as the intersection of this ray and the boundary of the bag. The bagdistance of <code class="reqn">z_i</code> to <code>x</code> is then given by the ratio between the Euclidean distance of <code class="reqn">z_i</code> to the halfspace median and the Euclidean distance of <code class="reqn">c_z</code> to the halfspace median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagdistance(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bagdistance_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="bagdistance_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the bagdistance. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="bagdistance_+3A_options">options</code></td>
<td>
<p>A list of available options:
</p>

<ul>
<li> <p><code>approx</code> <br />
In two dimensions one may choose to use an approximate algorithm or the exact algorithm to find the bag. <br />
Defaults to <code>TRUE</code>.

</p>
</li>
<li> <p><code>max.iter</code> <br />
The maximum number of steps in the bisection algorithm to find the intersection point <code class="reqn">c_z</code> (see Details).<br />
Defaults to <code class="reqn">100</code>.

</p>
</li>
<li>
<p>All options may be specified that are passed to the <code>hdepth</code> function, see <code>hdepth</code> for details. Note that the option parameter <code>approx</code> is by default set to <code>TRUE</code> to save computation time.</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The bagdistance has been introduced in Hubert et al. (2015) and studied in Hubert et al. (2017). It does not assume symmetry and is affine invariant. Note that when the halfspace is not computed in an affine invariant way, the bagdistance cannot be affine invariant either. 
</p>
<p>The function first computes the halfspace depth and the halfspace median of <code>x</code>. Additional options may be passed to the <code>hdepth</code> routine by specifying them in the <code>option</code> list argument.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it.
</p>
<p>Depending on the dimensions different algorithms are used. For <code class="reqn">p=1</code> the bagdistance is computed exactly. For <code class="reqn">p=2</code> the default setting (<code>options$approx=TRUE</code>) uses an approximated algorithm. Exact computation, based on the exact algoritm to compute the contours of the bag (see the <code>depthContour</code> function), is obtained by setting <code>options$approx</code> to FALSE. Note that this may lead to an increase in computation time. 
</p>
<p>For the approximated algorithm, the intersection point <code class="reqn">c_z</code> is approximated by searching on each ray the point whose depth is equal to the median of the depth values of <code>x</code>. As the halfspace depth is monotone decreasing along the ray, a bisection algorithm is used. Starting limits are obtained by projecting the data on the direction and considering the data point with univariate depth corresponding to the median of the halfspace depths of <code>x</code>. By definition the multivariate depth of this point has to be lower or equal than its univariate depth. A second limit is obtained by considering the deepest location estimate. The maximum number of iterations bisecting the current search interval can be specified through the options argument <code>max.iter</code>. 
</p>
<p>An observation from <code>z</code> is flagged as an outlier if its bagdistance exceeds a cutoff value. This cutoff is equal to the squareroot of the 0.99 quantile of the chi-squared distribution with <code class="reqn">p</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>bagdistance</code></td>
<td>
<p>The bagdistance of the points of <code>z</code> with respect to the data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points of <code>z</code> whose bagdistance exceeds this cutoff can be considered as outliers with respect to <code>x</code>. </p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>Points of <code>z</code> whose bagdistance exceeds the cutoff receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Vector of length <code>m</code> indicating for each point of <code>z</code> whether the bisection algorithm converged within the maximum number of steps specified by <code>max.iter</code> in the <code>options</code> list.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert. </p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445&ndash;466.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code>, <code><a href="#topic+hdepth">hdepth</a></code>, <code><a href="#topic+bagplot">bagplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some bivariate data
set.seed(5)
nObs &lt;- 500
XS &lt;- matrix(rnorm(nObs * 2), nrow = nObs, ncol = 2)
A &lt;- matrix(c(1,1,.5,.1), ncol = 2, nrow = 2)
X &lt;- XS %*% A

# In two dimensions we may either use the approximate
# or the exact algorithm to compute the bag.
respons.exact &lt;- bagdistance(x = X, options = list(approx = FALSE))
respons.approx &lt;- bagdistance(x = X, options = list(approx = TRUE))
# Both algorithms yield fairly similar results.
plot(respons.exact$bagdistance, respons.approx$bagdistance)
abline(a = 0, b = 1)

# In Hubert et al. (2015) it was shown that for elliptical
# distributions the squared bagdistance relates to the 
# squared Mahalanobis distances. This may be easily illustrated.
mahDist &lt;- mahalanobis(x = X, colMeans(X), cov(X))
plot(respons.exact$bagdistance^2, mahDist)

# Computation of the bagdistance relies on the computation
# of halfspace depth using the hdepth function. Options for
# the hdepth routine can be passed down using the options
# arguments. Note that the bagdistance is only affine invariant
# if the halfspace depth is computed in an affine invariant way. 
options &lt;-list(type = "Rotation",
               ndir = 375,
               approx = TRUE,
               seed = 78341)
respons.approx.rot &lt;- bagdistance(x = X, options = options)
plot(respons.exact$bagdistance, respons.approx.rot$bagdistance)
abline(a = 0, b = 1)
</code></pre>

<hr>
<h2 id='bagplot'>Draws a bagplot, a bivariate boxplot</h2><span id='topic+bagplot'></span>

<h3>Description</h3>

<p>This function draws a bagplot of bivariate data, based on the result of a call to <code>compBagplot</code>. The bagplot is a generalisation of the univariate boxplot to bivariate data. It aims to visualize the location, spread, skewness and outliers of the data set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagplot(compbag.result,
        colorbag = NULL, colorloop = NULL, colorchull = NULL,
        databag = TRUE, dataloop = TRUE, plot.fence = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bagplot_+3A_compbag.result">compbag.result</code></td>
<td>
<p>The return of a call to <code>compBagplot</code>.</p>
</td></tr>
<tr><td><code id="bagplot_+3A_colorbag">colorbag</code></td>
<td>
<p>The color of the bag (which contains the 50% observations with largest depth).</p>
</td></tr>
<tr><td><code id="bagplot_+3A_colorloop">colorloop</code></td>
<td>
<p>The color of the loop (which contains the regular observations).</p>
</td></tr>
<tr><td><code id="bagplot_+3A_colorchull">colorchull</code></td>
<td>
<p>When the bagplot is based on halfspace depth, the depth region with maximal depth is plotted. This argument controls its color.</p>
</td></tr>
<tr><td><code id="bagplot_+3A_databag">databag</code></td>
<td>
<p>Logical indicating whether data points inside the bag need to be plotted. <br />
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bagplot_+3A_dataloop">dataloop</code></td>
<td>
<p>Logical indicating whether data points inside the fence need to be plotted. <br />
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bagplot_+3A_plot.fence">plot.fence</code></td>
<td>
<p>Logical indicating whether the fence should be plotted. <br />
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bagplot has been proposed by Rousseeuw et al. (1999) as a generalisation of the boxplot to bivariate data. It is constructed based on halfspace depth and as such is invariant under affine transformations. Similar graphical representations can be obtained by means of other depth functions, as illustrated in Hubert and Van der Veeken (2008) and in Hubert et al. (2015). See <code><a href="#topic+compBagplot">compBagplot</a></code> for more details.
</p>
<p>The deepest point is indicated by a red diamond symbol, the outlying observations by red stars.
</p>
<p>The plot is made using <code>ggplot2</code>. The plot itself is returned by the function and is fully customisable using standard <code>ggplot2</code> commands.
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Rousseeuw P.J., Ruts I., Tukey J.W. (1999). The bagplot: a bivariate boxplot. <em>The American Statistician</em>, <b>53</b>, 382&ndash;387.
</p>
<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Rejoinder of 'Multivariate functional outlier detection'. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 269&ndash;277.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compBagplot">compBagplot</a></code>, <code><a href="#topic+hdepth">hdepth</a></code>, <code><a href="#topic+projdepth">projdepth</a></code>, <code><a href="#topic+sprojdepth">sprojdepth</a></code>,
<code><a href="#topic+dprojdepth">dprojdepth</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bloodfat)

# The bagplot can be plotted based on halfspace depth, projection depth,
# skewness-adjusted projection depth or directional projection depth.
# Note that projection depth is not appropiate for skewed data.
# bagplot(compBagplot(bloodfat))
bagplot(compBagplot(bloodfat, type = "projdepth"))
bagplot(compBagplot(bloodfat, type = "dprojdepth"))

# The main features of the bagplot can easily be adjusted.
result &lt;- compBagplot(bloodfat, type = "projdepth")
bagplot(result, databag = FALSE, dataloop = FALSE)
bagplot(result, colorbag = rgb(0.2, 0.2, 0.2), colorloop = "lightgreen")

data(cardata90)
result &lt;- compBagplot(cardata90, type = "projdepth")
bagplot(result)

# Compared to the original paper on the bagplot,
# an additional outlier is identified. However this
# point lies very close to the fence and this may be
# attributed to differences in numerical rounding.
# This may be illustrated by plotting the fence.
plot &lt;- bagplot(result, plot.fence = TRUE)
plot

# The returned object is a ggplot2 object and may be
# edited using standard ggplot2 commands.
library("ggplot2")
plot + ylab("Engine displacement") + xlab("Weight in pounds")
</code></pre>

<hr>
<h2 id='bloodfat'>Blood data for patients with narrowing arteries</h2><span id='topic+bloodfat'></span>

<h3>Description</h3>

<p>Data were collected on the concentration of plasma cholesterol and plasma triglycerides (mg/dl) for 371 male patients evaluated for chest pain. For 51 of those patients, no evidence of heart disease was found. This subset corresponds to the remaining 320 patients for which there was evidence of narrowing arteries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bloodfat)
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>Cholesterol</code></dt><dd><p>Concentration of plasma cholesterol [mg/dl].</p>
</dd>
<dt><code>Triglycerides</code></dt><dd><p>Concentration of plasma triglycerides [mg/dl].</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hand D.J., Daly F., Lunn A., McConway A. (1994). A Handbook of Small Data Sets. <em>Londen: Chapman and Hall</em>, dataset 277.
</p>


<h3>References</h3>

<p>Scott D.W., Gotto A.M., Cole J.S., Gorry G.A. (1978). Plasma lipids as collateral risk factors in coronary artery disease: a study of 371 males with chest pain.  <em>Journal of Chronic Diseases</em>, <b>31</b>, 337&ndash;345.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bloodfat)
plot(bloodfat)
</code></pre>

<hr>
<h2 id='cardata90'>Car data from Consumer Reports in 1990</h2><span id='topic+cardata90'></span>

<h3>Description</h3>

<p>Subset from data on cars taken from pages 235-255, 281-285 and 287-288 of the April 1990 Consumer Reports Magazine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cardata90)
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>Weight</code></dt><dd><p> Weight of the car (in pounds). </p>
</dd>
<dt><code>Disp</code></dt><dd><p> Engine displacement (in cubic inches). </p>
</dd>
</dl>



<h3>Source</h3>

<p><em>Consumer Reports</em>, April 1990, 235&ndash;288.
</p>
<p>Chambers J.M., Hastie T.J. (1993). Statistical Models in S. <em>Londen: Chapman and Hall</em>, 46&ndash;47.
</p>


<h3>References</h3>

<p>Rousseeuw P.J., Ruts I., Tukey J.W. (1999).
The bagplot: a bivariate boxplot.
<em>The American Statistician</em>, <b>53</b>, 382&ndash;387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardata90)
plot(cardata90)
</code></pre>

<hr>
<h2 id='characterA'>Writing trajectories of the letter 'a'</h2><span id='topic+characterA'></span>

<h3>Description</h3>

<p>Subset of the 'Character Trajectories Data Set' from the UCI Machine Learning Repository. The data set consists of trajectories of the tip of a pen whilst writing the letter 'a'. All samples are from the same writer. Original data has been processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(characterA)
</code></pre>


<h3>Format</h3>

<p>Three dimensional array. The first dimension represents time. The second dimension corresponds to the observation number. The third dimension contains the X and Y coordinates.
</p>


<h3>Source</h3>

<p>Bache K., Lichman M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>


<h3>References</h3>

<p>Williams B.H., Toussaint M., Storkey A.J. (2006). Extracting motion primitives from natural handwriting data. In ICANN, volume 2, pages 634&ndash;643.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(characterA)
par(mfrow = c(1,2))
matplot(y = characterA[,,1],
        type = "l", col = "black", lty = 1, 
        xlab = "Time", ylab = "X position of the pen")
matplot(y = characterA[,,2],
        type = "l", col = "black", lty = 1, 
        xlab = "Time", ylab = "Y position of the pen")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='characterI'>Writing trajectories of the letter i</h2><span id='topic+characterI'></span>

<h3>Description</h3>

<p>Subset of the 'Character Trajectories Data Set' from the UCI Machine Learning Repository. The data set consists of trajectories of the tip of a pen whilst writing the letter 'i'. All samples are from the same writer. Original data has been processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(characterI)
</code></pre>


<h3>Format</h3>

<p>Three dimensional array. The first dimension represents time. The second dimension corresponds to the observation number. The third dimension contains the X and Y coordinates.
</p>


<h3>Source</h3>

<p>Bache K., Lichman M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>


<h3>References</h3>

<p>Williams B.H., Toussaint M., Storkey A.J. (2006). Extracting motion primitives from natural handwriting data. In ICANN, volume 2, pages 634&ndash;643.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(characterI)
par(mfrow = c(1,2))
matplot(y = characterI[,,1],
        type = "l", col = "black", lty = 1, 
        xlab = "Time", ylab = "X position of the pen")
matplot(y = characterI[,,2],
        type = "l", col = "black", lty = 1, 
        xlab = "Time", ylab = "Y position of the pen")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='cmltest'>Test for linearity of the conditional median in simple regression</h2><span id='topic+cmltest'></span>

<h3>Description</h3>

<p>A test based on regression depth for linearity of the
conditional median <code>z</code> given the simple regression dataset <code>x</code>. The computation of the regression depth of <code>z</code> with respect to <code>x</code> is done by the function <code>rdepth</code>.
The test is only valid when <code>x</code> contains no duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmltest(x, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmltest_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by 2 regression data matrix. <br />
The first column is the explanatory variable, the second column corresponds to the response variable. </p>
</td></tr>
<tr><td><code id="cmltest_+3A_z">z</code></td>
<td>
<p>A matrix with one row containing an intercept and slope. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following hypothesis test is performed:<br />
<code class="reqn">H_0</code>: The data come from a model with: <code class="reqn">med(x_2|x_1) = z_1 + z_2 * x_1</code> <br />
The test statistic being used is the regression depth of <code>z</code> with respect to <code>x</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>The <code class="reqn">p</code>-value of the hypothesis test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Van Aelst S., Rousseeuw P.J., Hubert M., Struyf A. (2002). The deepest regression method. <em>Journal of Multivariate Analysis</em>, <b>81</b>, 138&ndash;166.
</p>
<p>Rousseeuw P.J., Struyf A. (2002). A depth test for symmetry. In:  <em>Goodness-of-Fit Tests and Model Validity</em>, Birkhäuser Boston, pages 401&ndash;412.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdepth">rdepth</a></code>, <code><a href="#topic+rdepthmedian">rdepthmedian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(stars)

# Compute the least squares fit. Due to outliers
# this fit will be bad and thus H0 should be rejected. 
temp &lt;- lsfit(x = stars[,1], y = stars[,2])$coefficients
intercept &lt;- temp[1]
slope &lt;- temp[2]
z &lt;- matrix(c(intercept, slope), nrow = 1)
pvalue1 &lt;- cmltest(x = stars[!duplicated(stars), ], z = z)
pvalue1

# Let's now test the deepest regression line. 
result &lt;- rdepthmedian(x = stars)
pvalue2 &lt;- cmltest(x = stars[!duplicated(stars), ], z = matrix(result$deepest, nrow = 1))
pvalue2

plot(stars)
abline(a = intercept, b = slope)
abline(result$deepest, col = "red")
text(x = 3.8, y = 5.3, labels = paste("p-value", round(pvalue1, digits = 3)))
text(x = 4.45, y = 4.8, labels = paste("p-value", round(pvalue2, digits = 3)),
     col = "red")
</code></pre>

<hr>
<h2 id='compBagplot'>Computations for drawing a bagplot</h2><span id='topic+compBagplot'></span>

<h3>Description</h3>

<p>Computes all elements of the bagplot, a generalisation
of the univariate boxplot to bivariate data. The bagplot can be
computed based on halfspace depth, projection depth, skewness-adjusted projection 
depth and directional projection depth. To draw the actual plot, the function 
<code>bagplot</code> needs to be called on the result of <code>compBagplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compBagplot(x, type = "hdepth", sizesubset = 500,
            extra.directions = FALSE, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compBagplot_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by 2 data matrix.</p>
</td></tr>
<tr><td><code id="compBagplot_+3A_type">type</code></td>
<td>
<p>Determines the depth function used to construct the bagplot: 
<code>"hdepth"</code> for halfspace depth, <code>"projdepth"</code> for projection depth, 
<code>"sprojdepth"</code> for skewness-adjusted projection depth and 
<code>"dprojdepth"</code> for directional projection depth. <br />
Defaults to <code>"hdepth"</code>.
</p>
</td></tr>
<tr><td><code id="compBagplot_+3A_sizesubset">sizesubset</code></td>
<td>
<p>When computing the bagplot based on halfspace depth,
the size of the subset used to perform the main
computations. See Details for more information. <br />
Defaults to <code class="reqn">500</code>.
</p>
</td></tr>
<tr><td><code id="compBagplot_+3A_extra.directions">extra.directions</code></td>
<td>
<p>Logical indicating whether additional directions should
be considered in the computation of the fence for the
bagplot based on projection depth or skewness-adjusted
projection depth. If set to <code>TRUE</code> an additional 
250 equispaced directions
are added to the directions defined by the points in
<code>x</code> themselves and the center. If <code>FALSE</code>
only directions determined by the points in <code>x</code> are
considered. <br />
Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="compBagplot_+3A_options">options</code></td>
<td>
<p>A list of options to pass to the <code>projdepth</code>, <code>sprojdepth</code> 
or <code>dprojdepth</code> function.
In addition the following option may be specified:
</p>

<ul>
<li> <p><code>max.iter</code> <br />
The maximum number of iterations in the bisection algorithm used
to compute the depth contour corresponding to the cutoff. See
<code>depthContour</code> for more information. <br />
Defaults to <code class="reqn">100</code>.

</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The bagplot has been proposed by Rousseeuw et al. (1999) as a generalisation of the boxplot to bivariate data.  It is constructed based on halfspace depth. In the original format the deepest point is indicated by a &quot;+&quot; and is contained in the bag which is defined as the depth region containing the 50% observations with largest depth. The fence is obtained by inflating the bag (relative to the deepest point) by a factor of three. The loop is the convex hull of the observations of <code>x</code> inside the fence. Observations outside the fence are flagged as outliers and plotted with a red star. This function only computes all the components constituting the bagplot. The bagplot itself can be drawn using the <code><a href="#topic+bagplot">bagplot</a></code> function.
</p>
<p>The bagplot may also be defined using other depth functions. When using projection depth, skewness-adjusted projection depth or directional projection depth, the bagplot is build as follows. The center corresponds to the observation with largest depth. The bag is constructed as the convex hull of the fifty percent points with largest depth. Outliers are identified as points with a depth smaller than a cutoff value, see <code>projdepth</code>, <code>sprojdepth</code> and <code>dprojdepth</code>for the precise definition.
The loop is computed as the convex hull of the non-outlying points. The fence is approximated by the convex hull of those points that lie on rays from the center through the vertices of the bag and have a depth that equals the cutoff depth. For a better approximation the user can set the input parameter <code>extraDirections</code> to <code>TRUE</code> such that an additional 250 equally spaced directions on the circle are considered.
</p>
<p>The computation of the bagplot based on halfspace depth can be time
consuming. Therefore it is possible to limit the bulk of the computations
to a random subset of the data. Computations of the halfspace median and
the bag are then based on this random subset. The number of points in this
subset can be controlled by the optional argument <code>sizesubset</code>.
</p>
<p>It is first checked whether the data is found to lie on a line. If so, the routine will give a warning, giving back the dimension of the subspace (being 1) together with the normal vector to that line.
</p>


<h3>Value</h3>

<p>A  list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>center</code></td>
<td>
<p>Center of the data. <br />
When <code>type = "hdepth"</code>, this corresponds with the
Tukey median.
In other cases this point corresponds to the point
with maximal depth.
</p>
</td></tr>
<tr><td><code>chull</code></td>
<td>
<p>When <code>type = "hdepth"</code>, these are the vertices of
the region with maximal halfspace depth.
In other cases this is a null vector.
</p>
</td></tr>
<tr><td><code>bag</code></td>
<td>
<p>The coordinates of the vertices of the bag.</p>
</td></tr>
<tr><td><code>fence</code></td>
<td>
<p>The coordinates of the vertices of the fence.</p>
</td></tr>
<tr><td><code>datatype</code></td>
<td>
<p>An <code class="reqn">n</code> by 3 matrix. The first two columns correspond with <code>x</code>. The third column indicates the
position of each observation of <code>x</code> in the bagplot: 2 for observations in
the bag, 1 for the observations in the fence and 3 for
outliers. <br />
Note that points may not be in the same order as in <code>x</code>.
</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> wich is 0 for outliers and 1 for regular observations of <code>x</code>.</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>The depth of the observations of <code>x</code>.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Same as the input parameter <code>type</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert based on Fortran code by P.J. Rousseeuw, I. Ruts and A. Struyf.</p>


<h3>References</h3>

<p>Rousseeuw P.J., Ruts I., Tukey J.W. (1999). The bagplot: A bivariate boxplot. <em>The American Statistician</em>, <b>53</b>, 382&ndash;387.
</p>
<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert, P. (2015). Rejoinder to 'Multivariate functional outlier detection'. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 269&ndash;277.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bagplot">bagplot</a></code>, <code><a href="#topic+hdepth">hdepth</a></code>, <code><a href="#topic+projdepth">projdepth</a></code>, <code><a href="#topic+sprojdepth">sprojdepth</a></code>,
<code><a href="#topic+dprojdepth">dprojdepth</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bloodfat)
# Result &lt;- compBagplot(bloodfat)
# bagplot(Result)

# The sizesubset argument may be used to control the
# computation time when computing the bagplot based on
# halfspace depth. However results may be unreliable when
# choosing a small subset for the main computations.
# system.time(Result1 &lt;- compBagplot(bloodfat))
# system.time(Result2 &lt;- compBagplot(bloodfat, sizesubset = 100))
# bagplot(Result1)
# bagplot(Result2)

# When using any of the projection depth functions,
# a list of options may be passed down to the corresponding
# outlyingness routines.
options &lt;- list(type = "Rotation",
                ndir = 50,
                stand = "unimcd",
                h = floor(nrow(bloodfat)*3/4))
Result &lt;- compBagplot(bloodfat,
                      type = "projdepth", options = options)
bagplot(Result)

# The fence is computed using the depthContour function.
# To get a smoother fence, one may opt to consider extra
# directions.
options &lt;- list(ndir = 500,
                seed = 36)
Result &lt;- compBagplot(bloodfat,
                      type = "dprojdepth", options = options)
bagplot(Result, plot.fence = TRUE)

options &lt;- list(ndir = 500,
                seed = 36)
Result &lt;- compBagplot(bloodfat,
                      type = "dprojdepth", options = options,
                      extra.directions = TRUE)
bagplot(Result, plot.fence = TRUE)
</code></pre>

<hr>
<h2 id='depthContour'>Depth contours of multivariate data</h2><span id='topic+depthContour'></span>

<h3>Description</h3>

<p>Computes the vertices of depth contours of multivariate data. The contours can be
computed based on halfspace depth, projection depth, skewness-adjusted projection 
depth or directional projection depth. To make the actual plot for bivariate data, 
the function <code>plotContours</code> needs to be called on the result of <code>depthContour</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthContour(x, alpha = NULL, type = "hdepth", directions = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depthContour_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_alpha">alpha</code></td>
<td>
<p>A vector containing the depth values of which the depth
contours have to be computed.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_type">type</code></td>
<td>
<p>The depth used in the computation of the contours:
<code>hdepth</code> for halfspace depth, <code>projdepth</code> for projection depth, 
<code>sprojdepth</code> for skewness-adjusted projection depth and 
<code>dprojdepth</code> for directional projection depth. <br />
Defaults to <code>hdepth</code>.
</p>
</td></tr>
<tr><td><code id="depthContour_+3A_directions">directions</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">p</code> matrix specifying the directions
on which to compute the vertices (see Details). </p>
</td></tr>
<tr><td><code id="depthContour_+3A_options">options</code></td>
<td>
<p>A list of options to pass to <code>hdepth</code>, <code>projdepth</code>,
<code>sprojdepth</code> or <code>dprojdepth</code>.
In addition the following option may be specified:
</p>

<ul>
<li> <p><code>max.iter</code> <br />
The maximum number of iterations in the bisection algorithm used
to compute the depth contour corresponding to level alpha. <br />
Defaults to <code class="reqn">100</code>.

</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Depth contours of level <code class="reqn">\alpha</code> (or <code class="reqn">\alpha</code>-depth contours) are the boundaries of depth regions. Depth regions of level <code class="reqn">\alpha</code> are defined as regions in space containing the multivariate points whose depth value is at least <code class="reqn">\alpha</code>.
</p>
<p>For bivariate data halfspace depth contours can be computed exactly following the algorithm in Ruts and Rousseeuw (1996). When the data are not in general position (i.e. when there is a line containing more than two observations) dithering is performed by adding random Gaussian noise to the data.
</p>
<p>In all other cases an approximated method is performed using a bisection algorithm. Intersections with the depth contours are searched on lines originating from the depth median. The user can specify a set of directions corresponding to these lines. By default a random set of <code class="reqn">250p</code> directions is considered. On each direction a point is searched having depth <code class="reqn">\alpha</code>. Starting limits are obtained by projecting the data on the direction and considering the data point with univariate depth <code class="reqn">\alpha</code>. By definition the multivariate depth of this point has to be lower or equal to <code class="reqn">\alpha</code>. A second limit is obtained by considering the deepest location estimate. The maximum number of iterations bisecting the current search interval can be specified through the options argument <code>max.iter</code>.  Note that this method is only affine or rotation equivariant if the chosen directions are affine or rotation equivariant.
</p>
<p>It is first checked whether the data is found to lie in a subspace of
dimension lower than <code class="reqn">p</code>. If so, the routine will give a warning, giving
back the dimension of the subspace together with a direction describing a
hyperplane containing this subspace.
</p>


<h3>Value</h3>

<p>The output consists of a list. Each element of the list contains the following elements for each value <code class="reqn">\alpha</code> specified in the argument <code>alpha</code>.
</p>
<table role = "presentation">
<tr><td><code>depth</code></td>
<td>
<p>The depth of the depth contour of level <code class="reqn">\alpha</code>. For halfspace depth this is equal to <code class="reqn">floor(\alpha n)/n</code>. For projection depth, skewness-adjusted projection depth and directional depth, this equals to <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>The coordinates of the vertices of the depth contour.</p>
</td></tr>
<tr><td><code>empty</code></td>
<td>
<p>Logical indicating whether the corresponding depth region is empty. <br />
<code>FALSE</code> indicates the depth region is non-empty. <br />
<code>TRUE</code> indicates the depth region is empty. <br />
</p>
</td></tr>
<tr><td><code>dithered</code></td>
<td>
<p>Logical indicating whether dithering has been applied in the exact bivariate algorithm based on halfspace depth. <br />
<code>FALSE</code> indicates no dithering has been applied. <br />
<code>TRUE</code> indicates dithering has been applied.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A vector of length <code class="reqn">m</code> containing a flag indicating for each direction whether convergence was reached by the bisecting algorithm within the allowed <code>max.iter</code> number of steps. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Same as input parameter type.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert based on Fortran code by  P.J. Rousseeuw, I. Ruts and A. Struyf</p>


<h3>References</h3>

<p>Ruts I., Rousseeuw P.J. (1996). Computing depth contours of bivariate point clouds. <em>Computational Statistics &amp; Data Analysis</em>, <b>23</b>, 153&ndash;168.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotContours">plotContours</a></code>, <code><a href="#topic+bagdistance">bagdistance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute and plot some halfspace depth contours of a two-dimensional dataset. 
# The returned object is a ggplot2 object that may be edited 
# using standard ggplot2 commands.

# One may consider different depth functions such as projection depth 
# by changing the input parameter 'type'.
# By default the halfspace depth is used.
data(bloodfat)
Result &lt;- depthContour(x = bloodfat,
                       alpha = c(0.03, 0.125, 0.25))
plotContours(x = bloodfat, depthContour = Result)


# Other options are projection depth, skewness-adjusted projection depth
# and directional projection depth
# they can be used by specifying type to be
# "projdepth", "sprojdepth" or "dprojdepth" respectively.
# When there is skewness in the data projection depth
# is less appropriate. 

Result &lt;- depthContour(x = bloodfat,
                       alpha = c(0.25, 0.35, 0.45),
                       type = "projdepth")
plotContours(x = bloodfat, depthContour = Result)

# The skewness-adjusted projection depth and directional projection depth
# better reflect the skewness in the data.
Result &lt;- depthContour(x = bloodfat,
                       alpha = c(0.35, 0.45, 0.55),
                       type = "sprojdepth")
plotContours(x = bloodfat, depthContour = Result)

Result &lt;- depthContour(x = bloodfat,
                       alpha = c(0.25, 0.35, 0.45),
                       type = "dprojdepth")
plotContours(x = bloodfat, depthContour = Result)

</code></pre>

<hr>
<h2 id='dirOutl'>Directional outlyingness of points relative to a dataset</h2><span id='topic+dirOutl'></span>

<h3>Description</h3>

<p>Computes the directional outlyingness of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. For each multivariate point <code class="reqn">z_i</code>, its directional outlyingness relative to <code>x</code> is defined as its maximal univariate directional outlyingness measured over all directions. To obtain the univariate directional outlyingness in the direction <code class="reqn">v</code>, the dataset <code>x</code> is projected on <code class="reqn">v</code>, and the robustly skew-adjusted standardized distance of <code class="reqn">v'z_i</code> to the median of the projected data points <code>x</code><code class="reqn">v</code> is computed. This is done through the estimation of 2 scales, one on each side of the median, using a 1-step M-estimator of scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirOutl(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirOutl_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="dirOutl_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the directional outlyingness. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="dirOutl_+3A_options">options</code></td>
<td>
<p> A list of available options:
</p>

<ul>
<li> <p><code>type</code> <br />
Determines the desired type of invariance and should be
one of <code>"Affine"</code>, <code>"compWise"</code>.
When the option <code>"Affine"</code> is used,  the directions
<code class="reqn">v</code> are orthogonal to hyperplanes spanned by <code class="reqn">p</code>
observations from <code>x</code>. With the option <code>"compWise"</code>,
the directional outlyingness is computed in the directions of the
coordinate axes and combined through the Euclidean norm.<br />
Defaults to <code>"Affine"</code>.
</p>
</li>
<li> <p><code>ndir</code> <br />
When <code>type</code> is chosen to be <code>"Affine"</code>, determines the number of                              directions <code class="reqn">v</code> by setting <code>ndir</code> to a specific number.
Defaults to <code class="reqn">250p</code>.
</p>
</li>
<li> <p><code>seed</code>  <br />
A strictly positive integer specifying the seed to be used
to select the directions.<br />
Defaults to <code class="reqn">10</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The directional outlyingness (DO) of multivariate data was introduced in Rousseeuw et al. (2018). It extends the Stahel-Donoho outlyingness towards skewed distributions.
</p>
<p>Depending on the dimension <code class="reqn">p</code>, different approximate algorithms are implemented. The affine invariant algorithm can only be used when <code class="reqn">n &gt; p</code>. It draws <code>ndir</code> times at random <code class="reqn">p</code> observations from <code>x</code> and considers the direction orthogonal to the hyperplane spanned by these <code class="reqn">p</code> observations. At most <code class="reqn">p</code> out of <code class="reqn">n</code> directions can be considered. The orthogonal invariant version can be applied to high-dimensional data. It draws <code>ndir</code> times at random <code class="reqn">2</code> observations from <code>x</code> and considers the direction through these two observations. Here, at most 2 out of <code class="reqn">n</code> directions can be considered. Finally, the shift invariant version randomly draws <code>ndir</code> vectors from the unit sphere.
</p>
<p>The resulting DO values are invariant to affine transformations, rotations and shifts respectively provided that the <code>seed</code> is kept fixed at different runs of the algorithm. Note that the DO values are guaranteed to increase when more directions are considered provided the seed is kept fixed, as this ensures that the random directions are generated in a fixed order.
</p>
<p>An observation from <code>x</code> and <code>z</code> is flagged as an outlier if its DO exceeds a cutoff value. This cutoff value is determined using the procedure in Rousseeuw et al. (2018). First, the logarithm of the DO values is taken to render their distribution more symmetric, after which a normal approximation yields a cutoff on these values. The cutoff is then transformed back by applying the exponential function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it. Furthermore, the univariate directional outlyingness of the projected points <code>x</code><code class="reqn">v</code> is ill-defined when the scale in its denominator becomes zero. This can happen when many observations collapse. In these cases the algorithm will stop and give a warning. The returned values then include the direction <code class="reqn">v</code> as well as an indicator specifying which of the observations of <code>x</code> belong to the hyperplane orthogonal to <code class="reqn">v</code>.
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>outlyingnessX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the directional
outlyingness of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>outlyingnessZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the directional
outlyingness of the points in <code>z</code> relative to <code>x</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose directional outlyingness exceeds this cutoff can be considered as outliers with respect to <code>x</code>.</p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose directional outlyingness exceeds the cutoff receive a flag <code>FALSE</code>, regular observations receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose directional outlyingness exceeds the cutoff receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In such a case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace. When a direction <code class="reqn">v</code> is found such that the robust skew-adjusted scale of <code>x</code><code class="reqn">v</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that DO(<code>x</code><code class="reqn">v</code>) is ill-defined, the observations from <code>x</code> which belong to the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Raymaekers and P. Rousseeuw</p>


<h3>References</h3>

<p>Rousseeuw P.J., Raymaekers J., Hubert M. (2018). A measure of directional outlyingness with applications to image data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprojdepth">dprojdepth</a></code>, <code><a href="#topic+dprojmedian">dprojmedian</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the directional outlyingness of a two-dimensional dataset. 
# Outliers are plotted in red.
data(geological)
BivData &lt;- geological[c("MnO", "MgO")]
Result &lt;- dirOutl(x = BivData)
IndOutliers &lt;- which(!Result$flagX)
plot(BivData, pch = 16, col = "grey60")
points(BivData[IndOutliers, ], pch = 16, col = "red")

# The number of directions may be specified through
# the option list. The resulting directional outlyingness
# is monotone increasing in the number of directions.
Result1 &lt;- dirOutl(x = BivData, options = list(ndir = 50))
Result2 &lt;- dirOutl(x = BivData, options = list(ndir = 100))
which(Result2$outlyingnessX - Result1$outlyingnessX &lt; 0)
# This is however not the case when the seed is changed
Result1 &lt;- dirOutl(x = BivData, options = list(ndir = 50))
Result2 &lt;- dirOutl(x = BivData, options = list(ndir = 100, seed = 950))

plot(Result2$outlyingnessX - Result1$outlyingnessX,
     xlab = "Index", ylab = "Difference in DO")
</code></pre>

<hr>
<h2 id='distSpace'>distSpace</h2><span id='topic+distSpace'></span>

<h3>Description</h3>

<p>Computation of distance space representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distSpace(trainingData, testData = NULL, type = "bagdistance", options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distSpace_+3A_trainingdata">trainingData</code></td>
<td>
<p>A list of <code class="reqn">n</code> by <code class="reqn">p</code> matrices containing  multivariate data or a list of <code class="reqn">t</code> by <code class="reqn">n</code> by <code class="reqn">p</code> arrays containing functional data. Each element of the list contains the observations from one group. The training data should contain at least two groups.</p>
</td></tr>
<tr><td><code id="distSpace_+3A_testdata">testData</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing multivariate test data or a <code class="reqn">t</code> by <code class="reqn">m</code> by <code class="reqn">p</code> array for functional data.</p>
</td></tr>
<tr><td><code id="distSpace_+3A_type">type</code></td>
<td>
<p>The distance used in the computations.
For multivariate data one of the following options: <code>bagdistance</code>,
<code>outlyingness</code>, <code>adjOutl</code> or <code>dirOutl</code>. 
Defaults to <code>bagdistance</code>.<br />
For functional data one of the following options: <code>fbd</code>, <code>fSDO</code>, 
<code>fAO</code> or <code>fDO</code>. Defaults to <code>fbd</code>.
</p>
</td></tr>
<tr><td><code id="distSpace_+3A_options">options</code></td>
<td>
<p>A list of options to pass to the function
computing the underlying distance. <br />
See <code>bagdistance</code>, <code>outlyingness</code>, <code>adjOutl</code>,
<code>dirOutl</code> or <code>fOutl</code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance space representation is a tool in supervised classification and was introduced in Hubert et al. (2016) as a generalisation of the depth-depth representation of a multivariate sample. Based on a distance transform, an observation (be it multivariate or functional) is mapped to its representation in distance space. The distance transformation consists of mapping the observation to a vector containing at coordinate <code class="reqn">i</code> the distance to the training group <code class="reqn">i</code>. After transformation, any multivariate classifier may be used to classify new observations in distance space. Typically the <code class="reqn">k</code>-nearest neighbour algorithm is used. 
</p>
<p>Different options are available to compute the distance to each of the training groups. For multivariate data, the user may choose between the bagdistance or any of the projection type distances including the Stahel-Donoho outlyingness, the adjusted outlyingness or the directional outlyingness. For functional data, the user may opt to employ the functional bagdistance (fbd), the functional Stahel-Donoho outlyingness (fSDO), the functional skweness-adjusted outlyingness (fAO) or the functional directional outlyingness (fDO). Options available in each of the underlying distance routines may be passed down using the <code>options</code> argument.
</p>


<h3>Value</h3>

<p>A <code class="reqn">q</code> by <code class="reqn">(p+1)</code> matrix composed of two blocks. The first block contains the observations in the training set (rows) with in each column the distance to each of the groups. The last column contains a label indicating the original group membership of the observation. The second block contains the observations in the test set, if any, with in each column the distance to the different training groups. The last column contains an indicator signaling the observation was part of the test set. 
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445&ndash;466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plane)

# Build the training data
Mirage &lt;- plane$plane1[, 1:25, 1, drop = FALSE]
Eurofighter &lt;- plane$plane3[, 1:25, 1, drop = FALSE]
trainingData &lt;- list(group1 = Mirage,
                     group2 = Eurofighter)

# Build the test data 
Mirage.t &lt;- plane$plane1[, 26:30, 1, drop = FALSE]
Eurofighter.t &lt;- plane$plane3[, 26:30, 1, drop = FALSE]
testData &lt;- abind::abind(Mirage.t, Eurofighter.t, along = 2) 

# Transform the data into distSpace
Result &lt;- distSpace(trainingData = trainingData, testData = testData, type="fbd")

# Plot the results
plotColors &lt;- c(rep("orange", dim(Mirage)[2]),
                rep("blue", dim(Eurofighter)[2]),
                rep("green3", dim(testData)[2]))
plot(Result[, 1:2, ],
     col = plotColors, pch=16,
     xlab = "distance to Mirage", ylab = "distance to Eurofighter",
     main = "distSpace representation of Mirage and Eurofighter")
     legend("bottomleft", legend = c("Mirage","Eurofighter", "test data"), pch = 16, 
       col = c("orange","blue", "green3"))
       
</code></pre>

<hr>
<h2 id='dprojdepth'>Directional projection depth of points relative to a dataset</h2><span id='topic+dprojdepth'></span>

<h3>Description</h3>

<p>Computes the directional projection depth of <code class="reqn">p</code>-dimensional
points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprojdepth(x, z = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprojdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="dprojdepth_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the directional projection depth. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="dprojdepth_+3A_options">options</code></td>
<td>
<p> A list of options to pass to the underlying <code>dirOutl</code> routine.
</p>
<p>See <code>dirOutl</code> for the full list of options. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Directional projection depth is based on the directional
outlyingness and is computed as <code class="reqn">1/(1+DO)</code>. As directional 
outlyingness extends the Stahel-Donoho outlyingness towards 
skewed distributions, the directional projection depth 
is suited for both elliptical distributions and skewed 
multivariate data.
</p>
<p>It is first checked whether the data is found to lie in a subspace of
dimension lower than <code class="reqn">p</code>. If so, a warning is given, as well as the
dimension of the subspace and a direction which is orthogonal to it.
</p>
<p>See <code>dirOutl</code> for more details on the computation of the DO.
To visualize the depth of bivariate data one can apply the 
<code>mrainbowplot</code> function. It plots the data colored according to 
their depth. 
</p>
<p>The output values of this function are based on the output of the 
<code>dirOutl</code> function. More details can be found there. 
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>depthX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the
directional projection depth of
the observations in x.</p>
</td></tr>
<tr><td><code>depthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the
directional projection depth of
the points in z.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose directional projection depth is smaller
than this cutoff can be considered as outliers.</p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose directional outlyingness exceeds 
the cutoff receive a flag <code>FALSE</code>, regular observations 
receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose directional outlyingness exceeds the 
cutoff receive a flag equal to <code>FALSE</code>, otherwise they 
receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In such a case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a
lower dimensional subspace, the dimension
of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional 
subspace, a direction orthogonal to this subspace. When a 
direction <code class="reqn">v</code> is found such that the robust directional
scale of <code class="reqn">xv</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that DO(<code class="reqn">xv</code>) is 
ill-defined, the observations from <code>x</code> which belong to 
the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. 
The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Raymaekers</p>


<h3>References</h3>

<p>Rousseeuw, P.J., Raymaekers, J., Hubert, M. (2018). A measure of directional outlyingness with applications to image Data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+dprojmedian">dprojmedian</a></code>, <code><a href="#topic+mrainbowplot">mrainbowplot</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the directional projection depth 
# of a simple two-dimensional dataset.
# Outliers are plotted in red.

data(bloodfat)
Result &lt;- dprojdepth(x = bloodfat)
IndOutliers &lt;- which(!Result$flagX)
plot(bloodfat)
points(bloodfat[IndOutliers,], col = "red")

# A multivariate rainbowplot may be obtained using mrainbowplot.
plot.options = list(legend.title = "DPD")
mrainbowplot(x = bloodfat, 
             depths = Result$depthX, plot.options = plot.options)

# Options for the underlying outlyingness routine may be passed 
# using the options argument. 
Result &lt;- dprojdepth(x = bloodfat, 
                     options = list(type = "Affine", ndir=100))

</code></pre>

<hr>
<h2 id='dprojmedian'>Location estimates based on directional projection depth</h2><span id='topic+dprojmedian'></span>

<h3>Description</h3>

<p>Computes a directional projection depth based location estimate of a 
<code class="reqn">p</code>-dimensional dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprojmedian(x, dprojection.depths = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprojmedian_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="dprojmedian_+3A_dprojection.depths">dprojection.depths</code></td>
<td>
<p>Vector containing the directional projection
depth of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="dprojmedian_+3A_options">options</code></td>
<td>
<p>A list of options to pass to the <code>dprojdepth</code> routine.
See <code>dprojdepth</code> for more details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm depends on the function <code>dprojdepth</code> to compute the
directional projection depth of the observations in <code>x</code>. If these depth values  have already been computed they can be passed as an optional argument to save computing time. If not, directional projection depth values will be computed and the user 
can pass a list with options to the <code>dprojdepth</code> function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller 
than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the 
subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A list with component: <br />
</p>
<table role = "presentation">
<tr><td><code>max</code></td>
<td>
<p>The observation of <code>x</code> with maximal directional projection 
depth. If multiple points have maximum depth, their center
of gravity is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Raymaekers</p>


<h3>References</h3>

<p>Rousseeuw P.J., Raymaekers J., Hubert M. (2018). A measure of directional outlyingness with applications to image data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+dprojdepth">dprojdepth</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a location estimate of a two-dimensional dataset.
data(bloodfat)
result &lt;- dprojmedian(x = bloodfat)
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# Options for the underlying dprojdepth routine may be passed 
# using the options argument. 
result &lt;- dprojmedian(x = bloodfat, options = list(type = "Rotation", ndir = 100))
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# One may also compute the depth values of the observations in the data
# separately. This avoids having to recompute them when conmputing the median. 
depth.result &lt;- dprojdepth(x = bloodfat)
result &lt;- dprojmedian(x = bloodfat, dprojection.depths = depth.result$depthX)
</code></pre>

<hr>
<h2 id='fHeatmap'>Draws a heatmap of functional depth values or distances</h2><span id='topic+fHeatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap of depth values or distances of functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fHeatmap(rowValues, cellValues, type, legend.title = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fHeatmap_+3A_rowvalues">rowValues</code></td>
<td>
<p>Vector of functional depth or distance values. Each value should correspond with the functional depth or distance of an observation from a (multivariate) functional data set.</p>
</td></tr>
<tr><td><code id="fHeatmap_+3A_cellvalues">cellValues</code></td>
<td>
<p>Matrix of multivariate depth or distance values. The value in row <code class="reqn">i</code> and column <code class="reqn">j</code> should correspond with the multivariate depth or distance of observation <code class="reqn">i</code> at time point <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="fHeatmap_+3A_type">type</code></td>
<td>
<p>One of <code>"depth"</code> or <code>"distance"</code>. Determines whether a depth or a distance heatmap is drawn.</p>
</td></tr>
<tr><td><code id="fHeatmap_+3A_legend.title">legend.title</code></td>
<td>
<p>Title of the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On the vertical axis the functional data are sorted from top to bottom according to their functional depth or distance value as provided in <code>rowValues</code>. When <code>type = "depth"</code>, the deepest observation is put at the bottom. When <code>type = "distance"</code>, the rows are sorted in decreasing order of their functional distance.
</p>
<p>Each cell of the map is colored according to the multivariate depth provided in <code>cellValues</code>. For a depth-based heatmap, the smallest
depth value is  white and the overall highest depth value is colored dark green. A distance-based heatmap colors the cells from white to dark red.  
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)
Result &lt;- mfd(octane, diagnostic = TRUE, type = "sprojdepth")
Plot &lt;- fHeatmap(rowValues = Result$MFDdepthZ,
                 cellValues = Result$crossdepthZ,
                 type = "depth",
                 legend.title = "SPD")
Plot

Result &lt;- fOutl(octane, diagnostic = TRUE, type = "fAO")
Plot &lt;- fHeatmap(rowValues = Result$fOutlyingnessZ,
                 cellValues = Result$crossDistsZ,
                 type = "distance",
                 legend.title = "AO")                 
Plot
</code></pre>

<hr>
<h2 id='fom'>Draws the Functional Outlier Map (FOM)</h2><span id='topic+fom'></span>

<h3>Description</h3>

<p>Creates the Functional Outlier Map, a graphical tool to detect outliers in multivariate functional data. Depending on the position of a multivariate curve in the FOM, different types of outliers may be distinguished. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fom(fOutlResult, cutoff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fom_+3A_foutlresult">fOutlResult</code></td>
<td>
<p>The return of a call to <code>fOutl</code></p>
</td></tr>
<tr><td><code id="fom_+3A_cutoff">cutoff</code></td>
<td>
<p>Boolean indicating whether the cutoff should be drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fom is only applicable when <code>fOutl</code> is called with the following options: <code>diagnostic = TRUE</code> and <code>type</code> equaling either <code>fAO</code> or <code>fDO</code>.
</p>
<p>The functional outlier map was proposed by Hubert et al. (2015) and subsequently improved by Rousseeuw et al. (2018). It consists of a graphical tool to detect outliers in multivariate functional data based on functional outlyingness measures such as the <code class="reqn">fAO</code> or <code class="reqn">fDO</code> (see <code>fOutl</code>). 
</p>
<p>The coordinates of the points in the FOM correspond to two outlyingness indicators. On the horizontal axis, the functional outlyingness as obtained by the routine <code><a href="#topic+fOutl">fOutl</a></code> is plotted. On the vertical axis the scaled standard deviation of the cross-sectional outlyingness measures across time are plotted. The FOM thus consists of the following points representing the curve <code class="reqn">i</code>: <code class="reqn">(fOutl_i; std_j(fOutl_i(t_j)) / (1 + fOutl_i))</code>. The scaling of the standard deviation is added to ensure that curves with a different location, measured from the center, but with the same relative variability have a similar <code class="reqn">y</code>-coordinate. 
</p>
<p>For some underlying multivariate outlyingness measures, the output of <code>fOutl</code> contains an additional argument signaling whether curve <code class="reqn">i</code> is outlying as measured in the multivariate space at time point <code class="reqn">j</code>. This information is incorporated in the FOM by plotting the points with a different degree of outlyingness by a different symbol. Curves that are outlying in the multivariate space determined by at least <code class="reqn">75\%</code> of the total number of time points in the domain are plotted using filled diamonds. Similarly curves that are outlying in at least <code class="reqn">50\%</code> or <code class="reqn">25\%</code> of the time points are plotted in filled squares and filled triangles respectively. Curves that are outlying in fewer than <code class="reqn">25\%</code> of the time points are plotted using filled circles. 
</p>
<p>The user may opt to draw a cutoff curve for the detection of outliers on the FOM.
This cutoff was introduced in Rousseeuw et al. (2018) and is based on the euclidean
distance between the points on the FOM and the origin, after scaling with the median.
More specifically, let <code class="reqn">(fOutl_i;vOutl_i) = (fOutl_i; std_j(fOutl_i(t_j)) / (1 + fOutl_i))</code> and 
let <code class="reqn">cOutl_i^2 = (fOutl_i / median(fOutl))^2 + (vOutl_i / median(vOutl))^2</code>.
Finally, with <code class="reqn">lcOutl_i = \log(0.1 + coutl_i)</code>,an observation lies outside of the cutoff when 
<code class="reqn">(lcOutl_i - median(lcOutl)) / mad(lcOutl) &gt; \Phi^{-1}(0.995)</code>.
</p>
<p>This FOM may be read in a way similar to the outlier map of robust regression (Rousseeuw and van Zomeren 1990) and the outlier map of
robust principal components (Hubert et al. 2005). Points in the lower left part of the FOM represent regular curves which hold a central position in the dataset. Points in the lower right part are curves with a high <code class="reqn">fOutl</code> but a low variability of their cross-sectional <code class="reqn">fOutl</code> values. This happens for shift outliers, i.e. curves which have the same shape as the majority but are shifted on the whole domain. Points in the upper left part have a low <code class="reqn">fOutl</code> but a high variability in cross-sectional <code class="reqn">fOutl</code>. Typical examples are isolated outliers, i.e. cuves which only display outlyingness over a small part of their domain.
The points in the upper right part of the FOM have both a high <code class="reqn">fOutl</code> and a high cross-sectional <code class="reqn">fOutl</code>. These correspond to curves which are strongly outlying on a substantial part of their domain. 
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>
<p>Rousseeuw P.J., Raymaekers J., Hubert M., (2018). A measure of directional outlyingness with applications to image data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fOutl">fOutl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)

# To construct the FOM, one first need to compute
# the functional outlyingness.
# Note that the option diagnostic in fOutl must be 
# set to TRUE. If not calling fom will result in an 
# error
Result &lt;- fOutl(octane, alpha = 0, type = "fAO", diagnostic = TRUE)
fom(Result)

# The user may opt to draw a cut off line seperating the outliers.
# which will be plotted in red
fom(Result, cutoff = TRUE)

# Six observations are flagged as outliers. These correspond to 
# the samples with added ethanol. 
</code></pre>

<hr>
<h2 id='fOutl'>Functional outlyingness measures for functional data</h2><span id='topic+fOutl'></span>

<h3>Description</h3>

<p>Computes several measures of functional outlyingness for multivariate 
functional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fOutl(x, z = NULL, type = "fAO", alpha = 0, time = NULL, 
        diagnostic = FALSE, distOptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fOutl_+3A_x">x</code></td>
<td>
<p>A three dimensional <code class="reqn">t</code> by <code class="reqn">n</code> by <code class="reqn">p</code> array,
with <code class="reqn">t</code> the number of observed time points,
<code class="reqn">n</code> the number of functional observations
and <code class="reqn">p</code> the number of measurements
for every functional observation at every time point.</p>
</td></tr>
<tr><td><code id="fOutl_+3A_z">z</code></td>
<td>
<p>An optional three-dimensional <code class="reqn">t</code> by <code class="reqn">m</code> by <code class="reqn">p</code> 
array, containing the observations for which to compute the 
functional outlyingness with respect to <code>x</code>. 
If <code>z</code> is not specified, it is set equal to <code>x</code>. 
The time points of <code>z</code> should correspond to those of 
<code>x</code>. </p>
</td></tr>
<tr><td><code id="fOutl_+3A_type">type</code></td>
<td>
<p>The outlyingness measure used in the computations.
One of the following options: <code>"fAO"</code>, <code>"fSDO"</code>,
<code>"fDO"</code> or <code>"fbd"</code>. <br />
Defaults to <code>"fAO"</code>.</p>
</td></tr>
<tr><td><code id="fOutl_+3A_alpha">alpha</code></td>
<td>
<p>Specifies the weights at every cross-section. 
When <code>alpha = 0</code>, uniform weights are used. Otherwise
<code>alpha</code> should be a weight vector of length <code class="reqn">t</code>. <br />
Defaults to 0. </p>
</td></tr>
<tr><td><code id="fOutl_+3A_time">time</code></td>
<td>
<p>If the measurements are not equidistant, 
a sorted numeric vector containing a set of time points. <br />
Defaults to <code>1:t</code>.</p>
</td></tr>
<tr><td><code id="fOutl_+3A_diagnostic">diagnostic</code></td>
<td>
<p>If set to <code>TRUE</code>, the output contains some additional 
components: <br /> 
crossDists: an <code class="reqn">n</code> by <code class="reqn">t</code> matrix containing the 
multivariate outlyingness of each observation at each time 
point <br />
locOutl: output containing flags for local outlyingness 
(see &quot;Value&quot; for more details)
<br />
Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="fOutl_+3A_distoptions">distOptions</code></td>
<td>
<p>A list of options to pass to the function
computing the cross-sectional distances. <br />
See <code>adjOutl</code>, <code>outlyingness</code>, <code>dirOutl</code>, or
<code>bagdistance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional outlyingness of a multivariate curve with respect to a 
given set of multivariate curves is defined as the weighted average of its 
multivariate outlyingness at each time point (Hubert et al., 2015). 
The functional outlyingness can be computed in all dimensions <code class="reqn">p</code> using
the adjusted outlyingness (<code>fAO</code>), the directional outlyingness (<code>fDO</code>), 
the Stahel-Donoho outlyingness (<code>fSDO</code>) or the bagdistance (<code>fbd</code>). 
</p>
<p>When the data array <code>z</code> is specified, the functional outlyingness and diagnostic 
information for the data array <code>x</code> is also returned whenever the underlying
outlyingness routine allows it. For more information see the specific routines 
listed in the section &quot;See Also&quot;.
</p>
<p>In some situations, additional diagnostics are available to flag outlying time 
points. At each time point, observations from the data array <code>x</code> are marked
if they are flagged as outliers. The observations from the data array <code>x</code> 
are marked if their scaled outlyingness is larger than a prescribed cutoff value
from the chi-square distribution. For more details see the respective 
outlyingness routines.
</p>
<p>It is possible that at certain time points a part of the algorithm can not be 
executed due to e.g. exact fits. In that case the weight of that particular time
point is set to zero. A warning is issued at the end of the algorithm to signal 
these time points. Furthermore the output contains an extra argument giving the 
indices of the time points where problems occured.
</p>


<h3>Value</h3>

<p>A  list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>fOutlyingnessX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> containing the 
functional outlyingness of every curve
from <code>x</code>.</p>
</td></tr>
<tr><td><code>fOutlyingnessZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> containing the 
functional outlyingness of every curve
from <code>z</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector of weights according to the input parameter 
<code>alpha</code>.</p>
</td></tr>
<tr><td><code>crossDistsX</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">t</code> matrix containing the multivariate
outlyingness of each observation of <code>x</code> at each point. 
Only provided if the input parameter <code>diagnostic</code> is 
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>crossDistsZ</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">t</code> matrix containing the multivariate
outlyingness of each observation of <code>z</code> at each point. 
Only provided if the input parameter <code>diagnostic</code> is 
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>locOutlX</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">t</code> matrix flagging local outlyingness for 
<code>x</code>. Only provided if the input parameter <code>diagnostic</code>
is set to TRUE.<br />
The <code class="reqn">(i,j)</code>th element takes value 1 if curve 
<code class="reqn">x_i</code> is outlying at time point <code class="reqn">j</code>.
</p>
</td></tr>
<tr><td><code>locOutlZ</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">t</code> matrix flagging local outlyingness for 
<code>z</code>. Only provided if the input parameter <code>diagnostic</code>
is set to TRUE.<br />
The <code class="reqn">(i,j)</code>th element takes value 1 if curve 
<code class="reqn">z_i</code> is outlying at time point <code class="reqn">j</code>.
</p>
</td></tr>
<tr><td><code>IndFlagExactFit</code></td>
<td>
<p>Vector containing the indices of the
time points for which an exact fit is
detected.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder).
<em>Statistical Methods and Applications,</em> <b>24</b>, 177&ndash;202.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445&ndash;466.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bagdistance">bagdistance</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+fom">fom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)
Data &lt;- octane

# When the option diagnostic is set to TRUE, a crude diagnostic
# to detect outliers can be extracted from the local outlyingness
# indicators. 
Result &lt;- fOutl(x = Data, type = "fAO", diagnostic = TRUE)
matplot(Data[,,1], type = "l", col = "black", lty = 1)
for (i in 1:dim(Data)[2]) {
  if(sum(Result$locOutlZ[i, ]) &gt; 0) {
    obsData &lt;- matrix(Data[,i,1], nrow = 1)
    obsData[!Result$locOutlZ[i,]] &lt;- NA
    obsData &lt;- rbind(obsData, obsData)
    matpoints(t(obsData), col = "red", pch = 15)
  }
}
# For more advanced outlier detection techniques, see the 
# fom routine.
</code></pre>

<hr>
<h2 id='geological'>Composition of elements in soil samples around the Baltic Sea</h2><span id='topic+geological'></span>

<h3>Description</h3>

<p>This data originates from a geological survey on the composition in agricultural soils from 10 countries surrounding the Baltic Sea.
Top soil (0-25 cm) and bottom soil (50-75 cm) samples from 768 sites were analysed. This data frame contains the measurements corresponding to the total concentration of four elements in the top soil samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geological)
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>Fe2O3</code></dt><dd><p> Iron Oxide </p>
</dd>
<dt><code>MgO</code></dt><dd><p> Magnesium oxide </p>
</dd>
<dt><code>MnO</code></dt><dd><p> Manganese oxide </p>
</dd>
<dt><code>TiO2</code></dt><dd><p> Titanium dioxide </p>
</dd>
</dl>



<h3>Source</h3>

<p>Reimann C., Siewers U., Tarvainen T., Bityukova L., Eriksson J., Gilucis A.,  Gregorauskiene V., Lukashev V., Matinian N.N., Pasieczna A. (2000). Baltic soil survey: total concentrations of major and selected trace elements in arable soils from 10 countries around the Baltic Sea. <em>Science of the Total Environment</em>,
<b>257</b>, 155&ndash;170.
</p>


<h3>References</h3>

<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geological)
plot(geological)
</code></pre>

<hr>
<h2 id='glass'>EXPMA spectra of glass samples</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>The glass data set studied by Lemberge et al. (2000) consists of 180 different 16-17th century archeological glass samples. Electron Probe X-ray Microanalysis (EPXMA) intensities across <code class="reqn">750</code> energy levels are recorded using a Jeol JSM 6300 scanning electron microscope equipped with an energy-dispersive Si(Li) X-ray detection system (SEM-EDX).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glass)</code></pre>


<h3>Format</h3>

<p>A three-dimensional <code class="reqn">t = 750</code> by <code class="reqn">n = 180</code> by <code class="reqn">p = 1</code> array.
</p>


<h3>Source</h3>

<p>Lemberge P., De Raedt I., Janssens K.H., Wei F., Van Espen P.J. (2000).
Quantitative Z-analysis of 16th-17th century archaeological glass vessels using
PLS regression of EPXMA and <code class="reqn">\mu</code>-XRF data. <em>Journal of Chemometrics</em>, <b>14</b>,
751&ndash;763.
</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Vanden Branden K. (2005).
ROBPCA: a new approach to robust principal component analysis.
<em>Technometrics</em>, <b>47</b>, 64&ndash;79.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(glass)
  matplot(glass[,,1], type = "l", lty = 1, col = "black")
</code></pre>

<hr>
<h2 id='hdepth'>Halfspace depth of points relative to a dataset</h2><span id='topic+hdepth'></span>

<h3>Description</h3>

<p>Computes the halfspace depth of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. Computation is exact for <code class="reqn">p \le 3</code> and approximate when <code class="reqn">p &gt; 3</code>. For the approximate algorithm  the halfspace depth is computed as the minimal univariate halfspace depth over many directions. To obtain the univariate halfspace depth in the direction <code class="reqn">v</code>, the dataset <code>x</code> is projected on <code class="reqn">v</code>, and the univariate location depth of the points of <code class="reqn">v'z_i</code> to <code class="reqn">xv</code> is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdepth(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="hdepth_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the halfspace depth. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="hdepth_+3A_options">options</code></td>
<td>
<p> A list of available options:
</p>

<ul>
<li> <p><code>type</code> <br />
Determines the desired type of invariance for the approximate algorithm and should be
one of <code>"Affine"</code>, <code>"Rotation"</code> or <code>"Shift"</code>.
When the option <code>"Affine"</code> is used,  the directions
<code class="reqn">v</code> are orthogonal to hyperplanes spanned by <code class="reqn">p</code>
observations from <code>x</code>. When the option <code>"Rotation"</code>
is used, the directions pass by two randomly selected
observations from <code>x</code>. With the option <code>"Shift"</code>,
directions are randomly generated.<br />
Defaults to <code>"Affine"</code>.
</p>
</li>
<li> <p><code>ndir</code> <br />
Determines the number of directions <code class="reqn">v</code> by setting
<code>ndir</code> to a specific number or to <code>"all"</code>.
In the latter case, an exhaustive search over all possible
directions (according to <code>type</code>) is performed.
If <code>ndir</code> is larger than the number of possible directions,
the algorithm will automatically use this setting. <br />
Defaults to
<code class="reqn">250p</code> when <code>type="Affine"</code>, to 5000 when
<code>type="Rotation"</code> and to 12500 when <code>type="Shift"</code>.
</p>
</li>
<li> <p><code>approx</code> <br />
The user may force approximate calculation in two or three
dimensions by setting this option to <code>TRUE</code>. <br />
Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>seed</code>  <br />
A strictly positive integer specifying the seed to be used
by the <code>C++</code> code.<br />
Defaults to <code class="reqn">10</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Halfspace depth has been introduced by Tukey (1975). The halfspace depth of a point <code class="reqn">z_i</code> is defined as the minimal number of observations from <code>x</code> that are contained in any closed halfspace with boundary through <code class="reqn">z_i</code>.
</p>
<p>In dimensions <code class="reqn">p=2</code> and <code class="reqn">p=3</code> the computations are by default carried out exactly using the algorithms described in Rousseeuw and Ruts (1996) and Rousseeuw and Struyf (1998). This yields an affine invariant measure of depth.
Approximate algorithms are also implemented which are affine, rotation or shift invariant, depending on the value chosen for <code>type</code>. They can be used in any dimension. The shift invariant algorithm coincides with the random Tukey depth (Cuesta-Albertos and Nieto-Reyes, 2008).
</p>
<p>The resulting halfspace depth values are invariant to affine transformations when the exact algorithm is used and invariant to affine transformations, rotations and shifts depending on the choice for <code>type</code>, provided that the <code>seed</code> is kept fixed at different runs of the algorithm. Note that the halfspace depth values values are guaranteed to decrease when more directions are considered, provided the seed is kept fixed, as this ensures that the random directions are generated in a fixed order.
</p>
<p>If the halfspace depth needs to be computed for <code class="reqn">m</code> points <code class="reqn">z_i</code>, it is recommended to apply the function once with the matrix <code class="reqn">z</code> as input, instead of applying it <code class="reqn">m</code> times with input vectors <code class="reqn">z_i</code>, as numerous computations can be saved. The approximate algorithms automatically then also compute the depth values of the observations in <code>x</code>.
When only the halfspace depth of the observations in <code>x</code> is required, the call to the function should be <code>hdepth(x)</code> or equivalently <code>hdepth(x,x)</code>. In that case the depth values will be stored in the 'depthZ' output field. For bivariate data these will be the exact values by default.
</p>
<p>To visualize the depth of bivariate data one can apply the <code>mrainbowplot</code> function. It plots the data colored according to their depth.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A  list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>depthX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the halfspace depth of the observations in <code>x</code>.<br />
By default exact if <code class="reqn">p \le 3</code> and approximate if <code class="reqn">p &gt; 3</code> or the option <code>approx</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>depthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the halfspace depth of the points in <code>z</code> relative to <code>x</code>. <br />
By default exact if <code class="reqn">p \le 3</code> and approximate if <code class="reqn">p &gt; 3</code> or the option <code>approx</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In that case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
When the input parameter type is equal to <code>"Rotation"</code> it
is possible that two randomly selected points of the data coincide
due to ties in the data. In this case this value signals how many
times this happens.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace,
the dimension of this subspace.
</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace,
a direction orthogonal to this subspace.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert based on Fortran code by P.J. Rousseeuw, I. Ruts and A. Struyf, and <code>C++</code> code by P. Segaert and K. Vakili.</p>


<h3>References</h3>

<p>Tukey J. (1975). Mathematics and the picturing of data. <em>Proceedings of the International Congress of Mathematicians,</em> <b>2</b>, 523&ndash;531, Vancouver.
</p>
<p>Rousseeuw P.J., Ruts I. (1996). AS 307: Bivariate location depth. <em>Journal of the Royal Statistical Society: Series C</em>, <b>45</b>, 516&ndash;526.
</p>
<p>Rousseeuw P.J., Struyf A. (1998). Computing location depth and regression depth in higher dimensions. <em>Statistics and  Computing</em>, <b>8</b>, 193&ndash;203.
</p>
<p>Cuesta-Albertos J., Nieto-Reyes A. (2008). The random Tukey depth. <em>Computational Statistics &amp; Data Analysis</em>, <b>52</b>, 4979&ndash;4988.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdepthmedian">hdepthmedian</a></code>, <code><a href="#topic+mrainbowplot">mrainbowplot</a></code>, <code><a href="#topic+bagdistance">bagdistance</a></code>, <code><a href="#topic+bagplot">bagplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the halfspace depth of a simple
# two-dimensional dataset. 
data(cardata90)
Result &lt;- hdepth(x = cardata90)
mrainbowplot(cardata90, depths = Result$depthZ)

# In two dimensions we may also opt to use the
# approximate algorithm. The number of directions
# may be specified through the option list.
options &lt;- list(type = "Rotation",
                ndir = 750,
                approx = TRUE)
Result &lt;- hdepth(x = cardata90, options = options)
# The resulting halfspace depth is monotone decreasing 
# in the number of directions.
options &lt;- list(type = "Rotation",
                ndir = 10,
                approx = TRUE)
Result1 &lt;- hdepth(x = cardata90, options = options)
options &lt;- list(type = "Rotation",
                ndir = 500,
                approx = TRUE)
Result2 &lt;- hdepth(x = cardata90, options = options)
which(Result1$depthZ - Result2$depthZ &lt; 0)
# This is however not the case when the seed is changed
options &lt;- list(type = "Rotation",
                ndir = 10,
                approx = TRUE)
Result1 &lt;- hdepth(x = cardata90, options = options)
options &lt;- list(type = "Rotation",
                ndir = 50,
                approx = TRUE,
                seed = 897)
Result2 &lt;- hdepth(x = cardata90, options = options)
which(Result1$depthZ - Result2$depthZ &lt; 0)
plot(Result1$depthZ - Result2$depthZ,
     xlab = "Index", ylab = "Difference in halfspace depth")

# We can also consider directions through two data
# points. If the sample is small enough one may opt
# to search over all choose(n,2) directions.
# Note that the computational load increases substantially
# as n becomes larger.
options &lt;- list(type = "Rotation",
                ndir = "all",
                approx = TRUE)
Result1 &lt;- hdepth(x = cardata90, options = options)

# Alternatively one may consider randomly generated directions.
options &lt;- list(type = "Shift",
                ndir = 250,
                approx = TRUE)
Result1 &lt;- hdepth(x = cardata90, options = options)
</code></pre>

<hr>
<h2 id='hdepthmedian'>Location estimates based on halfspace depth.</h2><span id='topic+hdepthmedian'></span>

<h3>Description</h3>

<p>Computes the halfspace median and its corresponding
halfspace depth for a <code class="reqn">p</code>-dimensional data set <code>x</code>.  Computation is exact for <code class="reqn">p \le 2</code> and approximate for <code class="reqn">p &gt; 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdepthmedian(x, maxdir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdepthmedian_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.
</p>
</td></tr>
<tr><td><code id="hdepthmedian_+3A_maxdir">maxdir</code></td>
<td>
<p>The number of projections used in the approximate algorithm. <br />
Defaults to <code class="reqn">250p</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The halfspace median, or Tukey median, is the multivariate point with largest halfspace depth with respect to the data <code>x</code>. This point is not always unique. In that case the halfspace median corresponds to the center of gravity of the convex set of deepest points.
</p>
<p>It is first checked whether the data is found to lie in a subspace of
dimension lower than <code class="reqn">p</code>. If so, the routine will give a warning, giving
back the dimension of the subspace together with a direction describing a
hyperplane containing this subspace.
</p>
<p>For bivariate data the exact algorithm of Rousseeuw and Ruts (1998) is applied. 
When the data are not in general position (i.e. when there is a line containing more than two observations) dithering is performed by adding random Gaussian noise to the data. In this case the output argument <code>dithered</code> will contain a flag. 
</p>
<p>When <code class="reqn">p &gt; 2</code> the approximate algorithm of Struyf and Rousseeuw (2000) is applied. It is an iterative procedure based on projections. Their number can be chosen by the input parameter <code>maxdir</code>.
</p>


<h3>Value</h3>

<p>A  list containing: <br />
</p>
<table role = "presentation">
<tr><td><code>median</code></td>
<td>
<p>The coordinates of the halfspace median.<br />
Approximate when <code class="reqn">p&gt;2</code>.</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>The halfspace depth of the halfspace median. <br />
Approximate when <code class="reqn">p&gt;2</code>.</p>
</td></tr>
<tr><td><code>dithered</code></td>
<td>
<p>Logical indicating whether dithering has been applied in the exact algorithm. <br />
<code>FALSE</code> indicates no dithering has been applied. <br />
<code>TRUE</code> indicates dithering has been applied.</p>
</td></tr> 
<tr><td><code>ndir</code></td>
<td>
<p>The number of projections used by the approximate algorithm. Due to the possibility of singularity of certain <code class="reqn">p</code> subsamples it is possible that not all <code>maxdir</code> directions are evaluated. <br />
</p>
</td></tr>
<tr><td><code>AlgStopFlag</code></td>
<td>
<p>Indicates which stopping rule is used by the approximate algorithm.<br />
0 indicates the maximum number of projections was reached <br />
1 indicates no improvement of the location estimate was
made after <code class="reqn">10(p+1)</code> steps.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>If the data are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert based on Fortran code by P.J. Rousseeuw, I. Ruts and A. Struyf</p>


<h3>References</h3>

<p>Rousseeuw P.J., Ruts I. (1998). Constructing the bivariate Tukey median. <em>Statistica Sinica</em>, <b>8</b>, 827&ndash;839.
</p>
<p>Struyf A., Rousseeuw P.J. (2000). High-dimensional computation of the deepest location. <em>Computational Statistics &amp; Data Analysis</em>, <b>34</b>, 415&ndash;436.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a location estimate of a two-dimensional dataset.
data(cardata90)
Result &lt;- hdepthmedian(x = cardata90)
plot(cardata90, pch = 16)
points(Result$median, col = "red", pch = 18, cex = 1.5)
</code></pre>

<hr>
<h2 id='medcouple'>A robust measure of skewness for univariate data</h2><span id='topic+medcouple'></span>

<h3>Description</h3>

<p>Computes the medcouple, a robust measure of skewness for univariate data. For multivariate data the medcouple is computed on each column of the data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medcouple(x, do.reflect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medcouple_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="medcouple_+3A_do.reflect">do.reflect</code></td>
<td>
<p>Logical indicating whether the medcouple should also be computed on the reflected sample <code>-x</code>, with final result <code class="reqn">(mc</code>(<code>x</code>)<code class="reqn">-mc(-</code><code>x</code><code class="reqn">))/2</code>. <br />
Defaults <code>TRUE</code> when <code class="reqn">n&lt;=100</code> and to <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The medcouple is a robust measure of skewness yielding values between <code class="reqn">-1</code> and <code class="reqn">1</code>. For left- and right-skewed data the medcouple is negative and positive respectively. <br />
</p>
<p>The medcouple is defined as the median of the kernel function
<code class="reqn">h(x_i,x_j) = \frac{(x_j - med(x)) - (med(x)-x_i)}{x_j-x_i}</code>
evaluated over all couples <code class="reqn">(x_i,x_j)</code> where
<code class="reqn">x_i</code> is smaller than the median of <code>x</code> and <code class="reqn">x_j</code> larger than the median of <code>x</code>. When there are multiple observations tied to the median, the kernel is defined separately as the denominator is not defined for these observations. Let <code class="reqn">m_1 &lt; ... &lt; m_k</code> denote the indices of the observations which are tied to the median. Then <code class="reqn">h(x_{m_i},x_{m_j})</code> is defined to equal <code class="reqn">-1</code> if <code class="reqn">i + j - 1 &lt; k</code>, <code class="reqn">0</code> when <code class="reqn">i + j - 1 = k</code> and <code class="reqn">+1</code> if <code class="reqn">i + j - 1 &gt; k</code>. To compute the medcouple an algorithm with time complexity <code class="reqn">O(n log(n))</code> is applied. For details, see <a href="https://en.wikipedia.org/wiki/Medcouple">https://en.wikipedia.org/wiki/Medcouple</a>. 
</p>
<p>For numerical accuracy it is advised, for small data sets, to compute the medcouple on both <code>x</code> and <code>-x</code>. The final value of the medcouple may then be obtained as a linear combination of both calculations. This procedure is warranted by the properties of the medcouple. Indeed the medcouple of the distribution <code class="reqn">X</code> equals minus the medcouple of the reflected distribution <code class="reqn">-X</code>. Moreover the medcouple is location and scale invariant.
</p>
<p>Note that missing values are not allowed.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mc</code></td>
<td>
<p>A <code class="reqn">p</code>-vector containing the medcouple of each column of the data matrix <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert with original code from M. Maechler and G. Brys.</p>


<h3>References</h3>

<p>Brys G., Hubert M., Struyf A. (2004).
A robust measure of skewness.
<em>Journal of Computational and Graphical Statistics</em>, <b>13</b>, 996&ndash;1017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the medcouple of a bivariate data set.
# Note that the medcouple of each variable is returned.
data(bloodfat)
medcouple(bloodfat)

# For smaller data sets it is advisable to compute
# the medcouple on both the sample and the reflected sample.
small.data &lt;- bloodfat[1:25,]
medcouple(small.data, do.reflect = FALSE)
-medcouple(-small.data, do.reflect = FALSE)
# Small difference are due to numerical instabilities. 
# Use the option do.reflect to increase expected accuracy. 
medcouple(small.data, do.reflect = TRUE)
</code></pre>

<hr>
<h2 id='mfd'>Multivariate functional depth for functional data</h2><span id='topic+mfd'></span>

<h3>Description</h3>

<p>Computes the multivariate functional depth for multivariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mfd(x, z = NULL, type = "hdepth", alpha = 0, time = NULL, diagnostic = FALSE,
      depthOptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfd_+3A_x">x</code></td>
<td>
<p>A three-dimensional <code class="reqn">t</code> by <code class="reqn">n</code> by <code class="reqn">p</code> array,
with <code class="reqn">t</code> the number of observed time points,
<code class="reqn">n</code> the number of functional observations
and <code class="reqn">p</code> the number of measurements
for every functional observation at every time point.</p>
</td></tr>
<tr><td><code id="mfd_+3A_z">z</code></td>
<td>
<p>An optional three-dimensional <code class="reqn">t</code> by <code class="reqn">m</code> by <code class="reqn">p</code> 
array, containing the observations for which to compute the 
multivariate functional depth with respect to <code>x</code>. 
If <code>z</code> is not specified, it is set equal to <code>x</code>. 
The time points of <code>z</code> should correspond to those of 
<code>x</code>. </p>
</td></tr>
<tr><td><code id="mfd_+3A_type">type</code></td>
<td>
<p>The depth used in the computations.
One of the following options: <code>"hdepth"</code>,
<code>"projdepth"</code>, <code>"sprojdepth"</code>, <code>"dprojdepth"</code>,
<code>"sdepth"</code>. <br />  Defaults to <code>"hdepth"</code>.</p>
</td></tr>
<tr><td><code id="mfd_+3A_alpha">alpha</code></td>
<td>
<p>Specifies the weights at every cross-section. 
When <code>alpha = 0</code>, uniform weights are used. Weights 
following equation (2) in Claeskens et al. (2014) are obtained 
by setting <code>alpha</code> to a number smaller than the maximal 
depth at any time point. The weights are then proportional to 
the volume of the <code class="reqn">\alpha</code>-depth regions at each 
cross-section. Otherwise <code>alpha</code> should be a weight vector 
of length <code class="reqn">t</code>. <br />
Defaults to 0. </p>
</td></tr>
<tr><td><code id="mfd_+3A_time">time</code></td>
<td>
<p>If the measurements are not equidistant, 
a sorted numeric vector containing a set of time points. <br />
Defaults to <code>1:t</code>.</p>
</td></tr>
<tr><td><code id="mfd_+3A_diagnostic">diagnostic</code></td>
<td>
<p>If set to <code>TRUE</code>, the output contains some additional 
components: <br /> 
<code>crossDepths</code>: an <code class="reqn">n</code> by <code class="reqn">t</code> matrix containing the 
multivariate depth of each observation at each time point <br />
<code>locOutl</code>: output containing flags for local outlyingness 
(see &quot;Value&quot; for more details)
<br />
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mfd_+3A_depthoptions">depthOptions</code></td>
<td>
<p>A list of options to pass to the function
computing the cross-sectional depths. <br />
See <code>hdepth</code>, <code>projdepth</code>, <code>sprojdepth</code>,
<code>dprojdepth</code> or <code>sdepth</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate functional depth of a multivariate curve with respect to a 
given set of multivariate curves is defined as the weighted average of its 
multivariate depth at each time point (Claeskens et al., 2014). 
The MFD can be computed in all dimensions <code class="reqn">p</code> using halfspace depth, 
projection depth, skewness-adjusted projection depth and directional projection depth. 
For <code class="reqn">p&lt;=2</code> also simplicial depth is available. 
</p>
<p>When the data array <code>z</code> is specified, the MFD depth and diagnostic 
information for the data array <code>x</code> is also returned whenever the underlying
depth routine allows it. For more information see the specific depth routines 
listed in the section &quot;See Also&quot;.
</p>
<p>For the weight vector, three options are available: uniform weights, 
user-defined weights or weights proportional to the volume of the 
<code class="reqn">\alpha</code>-depth contour at each time point. 
The <code class="reqn">\alpha</code>-depth contours are computed using the <code><a href="#topic+depthContour">depthContour</a></code> function. 
</p>
<p>In some situations, additional diagnostics are available to flag outlying time 
points, as described in Hubert et al. (2012). At each time point, observations 
from the data array <code>x</code> are marked if they are flagged as outliers. 
When using any of the projection depth measures, this flag is automatically 
returned by the corresponding functions. When using halfspace depth, 
the diagnostic is only available for bivariate curves. The observations 
from the data array <code>x</code> are marked if they are flagged as outliers by the 
bagplot, or similarly if their <code>bagdistance</code> is larger than 3 at that time 
point. This can be seen as a measure of local outlyingness. The option is not 
available for simplicial depth. 
</p>
<p>A heatmap of the cross-sectional depth values can be drawn by setting <code>diagnostic</code>
to TRUE and passing the results to <code><a href="#topic+fHeatmap">fHeatmap</a></code>.
</p>
<p>It is possible that at certain time points a part of the algorithm can not be 
executed due to e.g. exact fits. In that case the weight of that particular time
point is set to zero. A warning is issued at the end of the algorithm to signal 
these time points. Furthermore the output contains an extra argument giving the 
indices of the time points where problems occured.
</p>


<h3>Value</h3>

<p>A  list with the following  components:
</p>
<table role = "presentation">
<tr><td><code>MFDdepthX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> containing the MFD depth
of every curve from <code>x</code>.</p>
</td></tr>
<tr><td><code>MFDdepthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> containing the MFD depth
of every curve from <code>z</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector of weights according to the input parameter 
<code>alpha</code>.</p>
</td></tr>
<tr><td><code>crossDepthsX</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">t</code> matrix containing the multivariate
depth of each observation of <code>x</code> at each time point.<br /> Only 
provided if the input parameter <code>diagnostic</code> is set to 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code>crossDepthsZ</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">t</code> matrix containing the multivariate
depth of each observation of <code>z</code> at each time point.<br /> Only 
provided if the input parameter <code>diagnostic</code> is set to 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code>locOutlX</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">t</code> matrix flagging local outlyingness for 
<code>x</code>. Only provided if the input parameter <code>diagnostic</code>
is set to TRUE.<br />
The <code class="reqn">(i,j)</code>th element takes value 1 if curve 
<code class="reqn">x_i</code> is outlying at time point <code class="reqn">j</code>.
</p>
</td></tr>
<tr><td><code>locOutlZ</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">t</code> matrix flagging local outlyingness for 
<code>z</code>. Only provided if the input parameter <code>diagnostic</code>
is set to TRUE.<br />
The <code class="reqn">(i,j)</code>th element takes value 1 if curve 
<code class="reqn">z_i</code> is outlying at time point <code class="reqn">j</code>.
</p>
</td></tr>
<tr><td><code>IndFlagExactFit</code></td>
<td>
<p>Vector containing the indices of the
time points for which an exact fit is
detected.</p>
</td></tr>
<tr><td><code>IndFlagBag</code></td>
<td>
<p>Vector containing the indices of the
time points for which the bagplot could
not be computed.</p>
</td></tr>
<tr><td><code>IndFlagIso</code></td>
<td>
<p>Vector containing the indices of the time
points for which the cross-sectional <code class="reqn">\alpha</code>-depth 
contours could not be computed.</p>
</td></tr>
<tr><td><code>IndFlagAlpha</code></td>
<td>
<p>Vector containing the indices of the
time points for which the volume of the
cross-sectional <code class="reqn">\alpha</code>-depth contours could not
be computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert and M. Hubert</p>


<h3>References</h3>

<p>Claeskens G., Hubert M., Slaets L., Vakili K. (2014). Multivariate functional halfspace depth.
<em>Journal of the American Statistical Association,</em> <b>109</b>, 411&ndash;423.
</p>
<p>Hubert M., Claeskens G., De Ketelaere B., Vakili K. (2012).
A new depth-based approach for detecting outlying curves. 
In <em>Proceedings of COMPSTAT 2012, edited by A. Colubi, K. Fokianos, G. Gonzalez-Rodriguez, E.J. Kontoghiorghes,</em> 329&ndash;340. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code>, <code><a href="#topic+hdepth">hdepth</a></code>, <code><a href="#topic+projdepth">projdepth</a></code>, 
<code><a href="#topic+sprojdepth">sprojdepth</a></code>, <code><a href="#topic+dprojdepth">dprojdepth</a></code>, <code><a href="#topic+sdepth">sdepth</a></code>,
<code><a href="#topic+fHeatmap">fHeatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)
Result &lt;- mfd(x = octane, alpha = 0.125, diagnostic = TRUE)

Plot &lt;- fHeatmap(rowValues = Result$MFDdepthZ,
                 cellValues = Result$crossdepthZ,
                 type = "depth",
                 legend.title = "HD")
Plot 
</code></pre>

<hr>
<h2 id='mfdmedian'>Multivariate functional median for functional data</h2><span id='topic+mfdmedian'></span>

<h3>Description</h3>

<p>Computes the multivariate functional median, an estimate for the central tendency of multivariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mfdmedian(x, type = "hdepth", crossDepthsX = NULL,
            depthOptions = NULL, centerOption = "maxdepth")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfdmedian_+3A_x">x</code></td>
<td>
<p>A three-dimensional <code class="reqn">t</code> by <code class="reqn">n</code> by <code class="reqn">p</code> array,
with <code class="reqn">t</code> the number of observed time points,
<code class="reqn">n</code> the number of functional observations
and <code class="reqn">p</code> the number of measurements
for every functional observation at every time point.</p>
</td></tr>
<tr><td><code id="mfdmedian_+3A_type">type</code></td>
<td>
<p>The depth used in the computations.
One of the following options: <code>"hdepth"</code>,
<code>"projdepth"</code>, <code>"sprojdepth"</code>, <code>"dprojdepth"</code>,
<code>"sdepth"</code>. <br />  Defaults to <code>"hdepth"</code>.</p>
</td></tr>
<tr><td><code id="mfdmedian_+3A_crossdepthsx">crossDepthsX</code></td>
<td>
<p>Depth values at each time point. Can be used to save computing time.</p>
</td></tr>
<tr><td><code id="mfdmedian_+3A_depthoptions">depthOptions</code></td>
<td>
<p>A list of options to pass to the function
that computes the cross-sectional depths.</p>
</td></tr> 
<tr><td><code id="mfdmedian_+3A_centeroption">centerOption</code></td>
<td>
<p>When equal to <code>"maxdepth"</code> the functional median equals 
at each time point the point with cross-sectional maximal depth. 
When <code>type</code> is equal to <code>"projdepth"</code>, also a weighted center 
of gravity can be computed based on Huber weights (see                                               <code><a href="#topic+projmedian">projmedian</a></code>). Then <code>centerOption</code> should be set to                                 <code>"Huber"</code>. Defaults to <code>"maxdepth"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate functional median of a multivariate functional data set is defined
as the multivariate curve connecting the cross-sectional multivariate depth 
medians (Claeskens et al., 2014). 
The MFD median can be computed in all dimensions <code class="reqn">p</code> using halfspace depth, 
projection depth, skewness-adjusted projection depth or directional projection depth. 
The simplicial depth can only be used for <code class="reqn">p \le 2</code>.
</p>
<p>It is possible that at certain time points a part of the algorithm can not be 
executed due to e.g. exact fits. In that case the estimate for the center will 
be set to NaN. A warning is issued at the end of the algorithm to signal 
these time points. Furthermore the output contains an extra argument giving the 
indices of the time points where problems occured.
</p>


<h3>Value</h3>

<p>A  list with the following
component:
</p>
<table role = "presentation">
<tr><td><code>MFDmedian</code></td>
<td>
<p>An <code class="reqn">t</code> by <code class="reqn">p</code> matrix containing the estimated central curve.</p>
</td></tr>
<tr><td><code>IndFlagExactFit</code></td>
<td>
<p>Vector containing the indices of the
time points for which an exact fit is
detected.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert, M. Hubert</p>


<h3>References</h3>

<p>Claeskens G., Hubert M., Slaets L., Vakili K. (2014). Multivariate functional halfspace depth.
<em>Journal of the American Statistical Association,</em> <b>109</b>, 411&ndash;423.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdepth">hdepth</a></code>, <code><a href="#topic+projdepth">projdepth</a></code>, 
<code><a href="#topic+sprojdepth">sprojdepth</a></code>, <code><a href="#topic+dprojdepth">dprojdepth</a></code>, <code><a href="#topic+sdepth">sdepth</a></code>,
<code><a href="#topic+mfd">mfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a bivariate functional sample.
data(characterA)
Data &lt;- characterA[, 1:50, ]
Result &lt;- mfdmedian(Data)

# Plot the data and the functional median
par(mfrow = c(1,2))
matplot(Data[, , 1], type = "l", col = "black", lty = 1, ylab = "x-coordinate")
matlines(Result$MFDmedian[, 1], type = "l", col = "red", lwd = 2)
matplot(Data[, , 2], type = "l", col = "black", lty = 1, ylab = "y-coordinate")
matlines(Result$MFDmedian[, 2], type = "l", col = "red", lwd = 2)
par(mfrow = c(1,1))

# Other depth functions such as the adjusted outlyingness may also 
# be used to determine the cross-sectional depth median. 
# In this case the depth median is computed by the 
# sprojmedian routine. 
# Optional arguments used by the sprojmedian routine may be specified
# using the depthOptions. For example one might choose the
# "Rotation" option with 300 directions. 
Result &lt;- mfdmedian(Data, type = "sprojdepth",
                    depthOptions = list(type = "Rotation",
                                        ndir = 300))
par(mfrow = c(1,2))
matplot(Data[, , 1], type = "l", col = "black", lty = 1, ylab = "x-coordinate")
matlines(Result$MFDmedian[, 1], type = "l", col = "red", lwd = 2)
matplot(Data[, , 2], type = "l", col = "black", lty = 1, ylab = "y-coordinate")
matlines(Result$MFDmedian[, 2], type = "l", col = "red", lwd = 2)
par(mfrow = c(1,1))

# If the user already placed a call to the mfd routine
# with the diagnostic options set to TRUE, the 
# mfdmedian can easily be obtained by passing the cross-sectional 
# depths. This considerably saves computing time.  
tResult &lt;- mfd(x = Data, type = "sprojdepth", diagnostic = TRUE)
Result &lt;- mfdmedian(Data, type = "sprojdepth",
                    crossDepthsX = tResult$crossdepthX,
                    )
  
# Univariate curves should also be represented as arrays
Data.x &lt;- Data[, , 1, drop = FALSE]
Result &lt;- mfdmedian(Data.x)
matplot(Data.x[ , , 1], type = "l", col = "black", lty = 1, ylab = "x-coordinate")
matlines(Result$MFDmedian[, 1], type = "l", col = "red", lwd = 2)
</code></pre>

<hr>
<h2 id='mrainbowplot'>Rainbow plot for bivariate data</h2><span id='topic+mrainbowplot'></span>

<h3>Description</h3>

<p>Makes a scatterplot of bivariate data and colors the observations according to their depth value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrainbowplot(x, depths, col = NULL, plot.options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrainbowplot_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by 2 data matrix.
</p>
</td></tr>
<tr><td><code id="mrainbowplot_+3A_depths">depths</code></td>
<td>
<p>A column vector of length <code class="reqn">n</code>. <br />
The depth values of the observations in <code>x</code>. The coloring
is based on these depth values.</p>
</td></tr>
<tr><td><code id="mrainbowplot_+3A_col">col</code></td>
<td>
<p>An <code class="reqn">m &gt; 2</code> by 3 matrix. <br />
Colors in rgb format. The user may use this argument to set the colorscale of the depth range. The first row should contain the rgb values for the lowest depth value, the last row the rgb values of the color for the deepest depth value. Colors for other depth values are interpolated. When more than two rows are provided the color range will be equidistantly divided over the different colors.
</p>
</td></tr>
<tr><td><code id="mrainbowplot_+3A_plot.options">plot.options</code></td>
<td>
<p>A list of available options:
</p>

<ul>
<li><p>legend.title Title of the legend. <br />
Defaults to <code>"Depth"</code>.
</p>
</li>
<li><p>point.size Numeric defining the size of the points in the plot. <br />
Defaults to 4.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The plot is made using ggplot2. The plot itself is returned by the function and is fully customisable using standard ggplot2 commands. Similar plots for multivariate data with <code class="reqn">p &gt; 2</code> can be made using the ggpairs function in the library <code>GGally</code>. 
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardata90)
Result &lt;- projdepth(x = cardata90)
plot.options &lt;- list(legend.title = "PD")
plot &lt;- mrainbowplot(cardata90,
                     depths = Result$depthZ, 
                     plot.options = plot.options)
plot + ggtitle("Rainbowplot based on projection depth")

# The default color range may be adjusted using the col argument.
RGBmatrix &lt;- c(1, 0, 0, #Red
               1, 1, 1, #White
               0, 1, 0) #Green
RGBmatrix &lt;- matrix(RGBmatrix, ncol = 3, byrow = TRUE)
plot &lt;- mrainbowplot(cardata90, 
                     depths = Result$depthZ, 
                     col = RGBmatrix,
                     plot.options = plot.options)
plot + ggtitle("Rainbowplot based on projection depth")
</code></pre>

<hr>
<h2 id='mri'>Intensities of MRI images</h2><span id='topic+mri'></span>

<h3>Description</h3>

<p>Felipe et al. (2005) obtained intensities of MRI images of 9 different parts of the human
body (plus a group consisting of all remaining body regions, which was of course very
heterogeneous). They then transformed their data to univariate curves. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mri)</code></pre>


<h3>Format</h3>

<p>A list of arrays corresponding to each bodypart. For each bodypart, a three-dimensional <code class="reqn">t = 99</code> by <code class="reqn">n</code> by <code class="reqn">p = 1</code> array is available. The index <code class="reqn">t</code> corresponds to the different points of measurement, the index <code class="reqn">n</code> to the different observations. 
</p>


<h3>Details</h3>

<p>When using this data set please cite both Felipe et al. (2005) and Hubert et al. (2017).
</p>


<h3>Source</h3>

<p>Felipe J.C., Traina A.J.M., Traina C. (2005). Global warp metric distance: boosting
content-based image retrieval through histograms. Proceedings of the Seventh IEEE
International Symposium on Multimedia (ISM05), p.8.
</p>
<p>Chen Y., Keogh E., Hu B., Begum N., Bagnall A., Mueen A., Batista G.J. (2015). The
UCR Time Series Classification Archive. [http://www.cs.ucr.edu/~eamonn/time_series_data] 
</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445&ndash;466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mri)
par(mfrow = c(2,1))
matplot(y = mri$bodypart1[,,1],
        type = "l", col = "black", lty = 1, 
        xlab = "", ylab="", main = "bodypart 1")
matplot(y = mri$bodypart2[,,1],
        type = "l", col = "black", lty = 1, 
        xlab = "", ylab="", main = "bodypart 2")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='octane'>Near infrared spectra of gasoline samples</h2><span id='topic+octane'></span>

<h3>Description</h3>

<p>Near infrared absorbance spectra (NIR) of 39 gasoline samples over 226 wavelengths ranging from 1102nm to 1552nm with measurements every two nanometers. Six of the samples (25, 26, 36-39) contain added alcohol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(octane)
</code></pre>


<h3>Format</h3>

<p>A three-dimensional <code class="reqn">t = 226</code> by <code class="reqn">n = 39</code> by <code class="reqn">p = 1</code> array.
</p>


<h3>Source</h3>

<p>Esbensen K., Schonkopf S., Midtgaard T. (1994). Multivariate Analysis
in Practice. Trondheim: Camo.
</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Vanden Branden K. (2005).
ROBPCA: a new approach to robust principal component analysis.
<em>Technometrics</em>, <b>47</b>, 64&ndash;79.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)
matplot(octane[,1:30,1], type = "l", lty = 1, col = "black")
</code></pre>

<hr>
<h2 id='outlyingness'>Stahel-Donoho outlyingness of points relative to a dataset</h2><span id='topic+outlyingness'></span>

<h3>Description</h3>

<p>Computes the Stahel-Donoho outlyingness (SDO) of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. For each multivariate point <code class="reqn">z_i</code>, its outlyingness relative to <code>x</code> is defined as its maximal univariate Stahel-Donoho outlyingness measured over all directions. To obtain the univariate Stahel-Donoho outlyingness in the direction <code class="reqn">v</code>, the dataset <code>x</code> is projected on <code class="reqn">v</code>, and the robustly standardized distance of <code class="reqn">v'z_i</code> to the robust center of the projected data points <code>x</code><code class="reqn">v</code> is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlyingness(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlyingness_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="outlyingness_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute the outlyingness.
If <code>z</code> is not specified, it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="outlyingness_+3A_options">options</code></td>
<td>
<p> A list of available options:
</p>

<ul>
<li> <p><code>type</code> <br />
Determines the desired type of invariance and should be one
of <code>"Affine"</code>, <code>"Rotation"</code> or <code>"Shift"</code>. When
the option <code>"Affine"</code> is used,  the directions <code class="reqn">v</code> are
orthogonal to hyperplanes spanned by <code class="reqn">p</code> observations from
<code>x</code>. When the option <code>"Rotation"</code> is used, the directions
pass by two randomly selected observations from <code>x</code>.
With the option <code>"Shift"</code>, directions are randomly generated. <br />
Defaults to <code>"Affine"</code>.
</p>
</li>
<li>  <p><code>ndir</code> <br />
Determines the number of directions <code class="reqn">v</code> by setting <code>ndir</code>
to a specific number or to <code>"all"</code>. In the latter case, an
exhaustive search over all possible directions (according to <code>type</code>)
is performed. If <code>ndir</code> is larger than the number of possible
directions, the algorithm will automatically use this setting. <br />
Defaults to <code class="reqn">250p</code> when <code>type="Affine"</code>, to 5000 when
<code>type="Rotation"</code> and to 12500 when <code>type="Shift"</code>.
</p>
</li>
<li> <p><code>stand</code> <br />
Determines how to robustly standardize the projected data:
<code>"MedMad"</code> uses the median and the MAD, <code>"unimcd"</code>
uses the univariate MCD of location and scale. <br />
Defaults to <code>"MedMad"</code>.
</p>
</li>
<li> <p><code>centered</code> <br />
When the data matrix <code>x</code> is already centered, no robust center
should be computed in each direction. In that case, <code>centered</code> should
be set to <code>TRUE</code>. <br />
Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>h</code> <br />
When the input argument <code>stand</code> is equal to <code>unimcd</code>,
the parameter <code>h</code> controls the number of data points that
define the MCD estimator (see <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
in the <code>robustbase</code> package).
This value should lie between <code class="reqn">[n/2]+1</code> and <code class="reqn">n</code>. <br />
Defaults to <code class="reqn">[n/2]+1</code>.
</p>
</li>
<li> <p><code>seed</code>  <br />
A strictly positive integer specifying the seed to be used
by the <code>C++</code> code.<br />
Defaults to <code class="reqn">10</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The Stahel-Donoho outlyingness has been introduced by Stahel (1981) and Donoho (1982).
It is mostly suited to measure the degree of outlyingness of multivariate points with respect to a data cloud from an elliptical distribution.
</p>
<p>Depending on the dimension <code class="reqn">p</code>, different approximate algorithms are implemented. The affine invariant algorithm can only be used when <code class="reqn">n &gt; p</code>. It draws <code>ndir</code> times at random <code class="reqn">p</code> observations from <code>x</code> and considers the direction orthogonal to the hyperplane spanned by these <code class="reqn">p</code> observations. At most <code class="reqn">p</code> out of <code class="reqn">n</code> directions can be considered. The orthogonal invariant version can be applied to high-dimensional data. It draws <code>ndir</code> times at random 2 observations from <code>x</code> and considers the direction through these observations. Here, at most 2 out of <code class="reqn">n</code> directions can be considered. Finally, the shift invariant version randomly draws <code>ndir</code> vectors from the unit sphere.
</p>
<p>The resulting  Stahel-Donoho outlyingness values are invariant to affine transformations, rotations and shifts respectively provided that the <code>seed</code> is kept fixed at different runs of the algorithm. Note that the SDO values are guaranteed to increase when more directions are considered provided the seed is kept fixed, as this ensures that the random directions are generated in a fixed order.
</p>
<p>An observation from <code>x</code> and <code>z</code> is flagged as an outlier if its SDO exceeds a cutoff value. This cutoff value is determined using the procedure in Rousseeuw et al. (2018). First, the logarithm of the SDO values is taken to render their distribution more symmetric, after which a normal approximation yields a cutoff on these values. The cutoff is then transformed back by applying the exponential function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it. Moreover, from the definition of the Stahel-Donoho outlyingness it follows that the outlyingness is ill-defined when the robust scale of the data projected on the direction <code class="reqn">v</code> equals zero. In this case the algorithm will stop and give a warning. The returned values then include the direction <code class="reqn">v</code> as well as an indicator specifying which of the observations of <code>x</code> belong to the hyperplane orthogonal to <code class="reqn">v</code>.
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>outlyingnessX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the outlyingness of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>outlyingnessZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the outlyingness of the points in <code>z</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose outlyingness exceeds this cutoff can be considered as outliers with respect to <code>x</code>.</p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose outlyingness exceeds the cutoff value receive a flag <code>FALSE</code>, regular observations receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose outlyingness exceeds the cutoff value receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In such a case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
When the input parameter type is equal to <code>"Rotation"</code> it
is possible that two randomly selected points of the data coincide
due to ties in the data. In such a case this value signals how many
times this happens.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace. When a direction <code class="reqn">v</code> is found such that the robust scale of <code class="reqn">xv</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that the robust scale of <code class="reqn">xv</code> is zero, the observations from <code>x</code> which belong to the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert using <code>C++</code> code by K. Vakili and P. Segaert.</p>


<h3>References</h3>

<p>Stahel W.A. (1981). Robuste Schatzungen: infinitesimale Optimalitat und Schatzungen  von Kovarianzmatrizen. PhD Thesis, ETH Zurich.
</p>
<p>Donoho D.L. (1982). Breakdown properties of multivariate location estimators. Ph.D. Qualifying paper, Dept. Statistics, Harvard University, Boston.
</p>
<p>Maronna R.A., Yohai V. (1995). The behavior of the Stahel-Donoho robust multivariate estimator. <em>Journal of the American Statistical Association</em>, <b>90</b>, 330&ndash;341.
</p>
<p>Rousseeuw P.J., Raymaekers J., Hubert M., (2018). A measure of directional outlyingness with applications to image data and video. <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 345&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projdepth">projdepth</a></code>, <code><a href="#topic+projmedian">projmedian</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the outlyingness of a simple two-dimensional dataset.
# Outliers are plotted in red.

if (requireNamespace("robustbase", quietly = TRUE)) {
    BivData &lt;- log(robustbase::Animals2)
} else {
  BivData &lt;- matrix(rnorm(120), ncol = 2)
  BivData &lt;- rbind(BivData, matrix(c(6,6,6,-2), ncol = 2))
}

Result &lt;- outlyingness(x = BivData)
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# The number of directions may be specified through
# the option list. The resulting outlyingness is
# monotone increasing in the number of directions.
Result1 &lt;- outlyingness(x = BivData,
                        options = list(ndir = 50)
                        )
Result2 &lt;- outlyingness(x = BivData,
                        options = list(ndir = 100)
                        )
which(Result2$outlyingnessX - Result1$outlyingnessX &lt; 0)
# This is however not the case when the seed is changed
Result1 &lt;- outlyingness(x = BivData,
                        options = list(ndir = 50)
                        )
Result2 &lt;- outlyingness(x = BivData,
                        options = list(ndir = 100,
                                       seed = 950)
                        )
plot(Result2$outlyingnessX - Result1$outlyingnessX,
     xlab = "Index", ylab = "Difference in outlyingness")

# We can also consider directions through two data
# points. If the sample is small enough one may opt
# to search over all choose(n,2) directions.
# Note that the computational load increases considerably
# as n becomes larger.
Result &lt;- outlyingness(x = BivData,
                       options = list(type = "Rotation",
                                      ndir = "all")
                       )
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# Alternatively one may consider randomly generated directions.
Result &lt;- outlyingness(x = BivData,
                       options = list(type = "Shift",
                                      ndir = 1000)
                      )
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# The default option of using the MAD for the scale may be
# changed to using the univariate mcd.
Result &lt;- outlyingness(x = BivData,
                       options = list(type = "Affine",
                                      ndir = 1000,
                                      stand = "unimcd",
                                      h = 0.75*nrow(BivData))
                      )
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")
</code></pre>

<hr>
<h2 id='plane'>Fighter plane dataset</h2><span id='topic+plane'></span>

<h3>Description</h3>

<p>The fighter plane dataset of Thakoor and Gao (2005) describes 7 shapes: of the Mirage,
Eurofighter, F-14 with wings closed, F-14 with wings opened, Harrier, F-22 and F-15.
Each class contains 30 shape samples obtained from digital pictures, which Thakoor and
Gao (2005) then reduced to univariate functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plane)</code></pre>


<h3>Format</h3>

<p>A list of arrays corresponding to each plane. For each plane, a three-dimensional <code class="reqn">t</code> by <code class="reqn">n</code> by <code class="reqn">p = 1</code> array is available. The index <code class="reqn">t</code> corresponds to the different measurement points, the index <code class="reqn">n</code> to the different observations. 
</p>


<h3>Details</h3>

<p>When using this data set please cite both Thakoor et al. (2005) and Hubert et al. (2017).
</p>


<h3>Source</h3>

<p>Thakoor N., Gao J. (2005). Shape classifier based on generalized probabilistic descent
method with hidden Markov descriptor. Tenth IEEE International Conference on
Computer Vision (ICCV 2005), Vol. 1: 495&ndash;502.
</p>
<p>Chen Y., Keogh E., Hu B., Begum N., Bagnall A., Mueen A., Batista G.J. (2015). The UCR time series classification archive. [http://www.cs.ucr.edu/~eamonn/time_series_data] 
</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445&ndash;466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plane)
par(mfrow = c(2,1))
matplot(y = plane$plane1[,,1],
        type ="l", col = "black", lty = 1, 
        xlab = "", ylab = "", main = "plane 1")
matplot(y = plane$plane2[,,1],
        type = "l", col = "black", lty = 1, 
        xlab = "", ylab = "", main = "plane 2")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='plotContours'>Draws depth contours of bivariate data</h2><span id='topic+plotContours'></span>

<h3>Description</h3>

<p>Draws the depth contours of bivariate data computed with <code>depthContour</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotContours(x, depthContour, data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotContours_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by 2 data matrix.</p>
</td></tr>
<tr><td><code id="plotContours_+3A_depthcontour">depthContour</code></td>
<td>
<p>The result of a call to <code>depthContour</code>.</p>
</td></tr>
<tr><td><code id="plotContours_+3A_data">data</code></td>
<td>
<p>Logical value indicating whether the data <code>x</code> should be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is made using <code>ggplot2</code>. The plot itself is returned by the function and is fully customisable using standard <code>ggplot2</code> commands.
</p>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Ruts I., Rousseeuw P.J. (1996). Computing depth contours of bivariate point clouds. <em>Computational Statistics &amp; Data Analysis</em>, <b>23</b>, 153-168.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute and plot some halfspace depth contours of a two-dimensional dataset. 
# The returned object is a ggplot2 object that may be edited 
# using standard ggplot2 commands.
data(cardata90)
Result &lt;- depthContour(x = cardata90,
                       alpha = c(0.125, 0.25))
plot &lt;- plotContours(x = cardata90, depthContour = Result)
plot + ylab("Engine displacement") + xlab("Weight in pounds")

# One may consider different depth functions such as projection depth 
# by changing the input parameter 'type' in the depthcontour function.
Result &lt;- depthContour(x = cardata90,
                       alpha = c(0.35, 0.55),
                       type = "projdepth")
plotContours(x = cardata90, depthContour = Result)
</code></pre>

<hr>
<h2 id='projdepth'>Projection depth of points relative to a dataset</h2><span id='topic+projdepth'></span>

<h3>Description</h3>

<p>Computes the projection depth of <code class="reqn">p</code>-dimensional points <code>z</code>
relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projdepth(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="projdepth_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the projection depth. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="projdepth_+3A_options">options</code></td>
<td>
<p> A list of options to pass to the underlying <code>outlyingness</code> routine. <br />
See <code>outlyingness</code> for the full list of options. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Projection depth is based on the Stahel-Donoho outlyingness (SDO) and is computed as <code class="reqn">1/(1+SDO)</code>. It is mostly suited to measure the degree of outlyingness of multivariate points with respect to a data cloud from an elliptical distribution.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it.
</p>
<p>See <code>outlyingness</code> for more details on the computation of the SDO. To visualize the depth of bivariate data one can apply the <code>mrainbowplot</code> function. It plots the data colored according to their depth. 
</p>
<p>The output values of this function are based on the output of the <code>outlyingness</code> function. More details can be found there. 
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>depthX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the projection depth
of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>depthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the projection depth
of the points in <code>z</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose projection depth is smaller than this
cutoff can be considered as outliers. Equivalently the 
outliers are those points whose Stahel-Donoho outlyingness
exceed the corresponding cutoff.</p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose projection depth is smaller than
the cutoff receive a flag <code>FALSE</code>, regular observations receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose projection depth is smaller than the cutoff
receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>, the number of <code class="reqn">p</code>-subsets that span a subspace of dimension smaller than <code class="reqn">p-1</code>. In that case the orthogonal direction can not be uniquely determined. This is an indication that the data are not in general position.   When the input parameter type is equal to <code>"Rotation"</code> it is possible that two randomly selected points of the data coincide due to ties in the data. In this case this value signals how many times this happens.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace. When a direction <code class="reqn">v</code> is found such that the robust scale of <code class="reqn">xv</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that the robust scale of <code class="reqn">xv</code> is zero, the observations from <code>x</code> which belong to the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Zuo Y. (2003). Projection-based depth functions and associated medians.  <em>The Annals of Statistics</em>, <b>31</b>, 1460&ndash;1490.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outlyingness">outlyingness</a></code>, <code><a href="#topic+projmedian">projmedian</a></code>, <code><a href="#topic+mrainbowplot">mrainbowplot</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute the projection depth of a simple two-dimensional dataset.
# Outliers are plotted in red.

if (requireNamespace("robustbase", quietly = TRUE)) {
    BivData &lt;- log(robustbase::Animals2)
} else {
  BivData &lt;- matrix(rnorm(120), ncol = 2)
  BivData &lt;- rbind(BivData, matrix(c(6,6, 6, -2), ncol = 2))
}

Result &lt;- projdepth(x = BivData)
IndOutliers &lt;- which(!Result$flagX)
plot(BivData)
points(BivData[IndOutliers,], col = "red")

# A multivariate rainbowplot may be obtained using mrainbowplot.
plot.options = list(legend.title = "PD")
mrainbowplot(x = BivData, 
             depths = Result$depthX, plot.options = plot.options)

# Options for the underlying outlyingness routine may be passed 
# using the options argument. 
Result &lt;- projdepth(x = BivData, 
                    options = list(type = "Affine",
                                   ndir = 1000,
                                   stand = "MedMad",
                                   h = nrow(BivData)
                                   )
                   )

</code></pre>

<hr>
<h2 id='projmedian'>Location estimates based on projection depth</h2><span id='topic+projmedian'></span>

<h3>Description</h3>

<p>Computes a projection depth based location estimate of a <code class="reqn">p</code>-dimensional 
dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projmedian(x, projection.depths = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projmedian_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="projmedian_+3A_projection.depths">projection.depths</code></td>
<td>
<p>Vector containing the projection depth of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="projmedian_+3A_options">options</code></td>
<td>
<p>A list of options to pass to the <code>projdepth</code> routine.
See <code>projdepth</code> for more details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm depends on the function <code>projdepth</code> to compute the
projection depth of the observations in <code>x</code>. If these depth values have already been computed, they can be passed as an optional
argument to save computing time. If not, the projection depth values will be
computed and the user can pass a list with options to the
<code>projdepth</code> function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller 
than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the 
subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>max</code></td>
<td>
<p>The point of <code>x</code> with maximal projection depth.
If multiple points have maximum depth, their center
of gravity is returned.</p>
</td></tr>
<tr><td><code>Huber</code></td>
<td>
<p>A weighted center of gravity of all observations.
The weights are defined by the Huber
function with parameter
<code>alpha = 1 / (1+sqrt(qchisq(0.95, p)))</code>
Observations for which the projection depth
is more than alpha receive weight 1,
other points receive weight
<code>( sqrt(qchisq(0.95, p)) / outlyingness )^2.</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Maronna, R.A., Yohai, V.J. (1995). The behavior of the Stahel-Donoho robust multivariate estimator. <em>Journal of the American Statistical Association</em>, <b>90</b>, 330&ndash;341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outlyingness">outlyingness</a></code>, <code><a href="#topic+projdepth">projdepth</a></code>, <code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a location estimate of a two-dimensional dataset.
if (requireNamespace("robustbase", quietly = TRUE)) {
  BivData &lt;- log(robustbase::Animals2)
} else {
  BivData &lt;- matrix(rnorm(120), ncol = 2)
  BivData &lt;- rbind(BivData, matrix(c(6, 6, 6, -2), ncol = 2))
}

result &lt;- projmedian(x = BivData)
plot(BivData, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)
points(result$Huber, col = "blue", pch = 3, cex = 1.5)

# Options for the underlying projdepth routine may be passed 
# using the options argument. 
result &lt;- projmedian(x = BivData,
                     options = list(type = "Rotation",
                                    ndir = 100,
                                    stand = "unimcd",
                                    h = 0.75*nrow(BivData)))
              
plot(BivData, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)
points(result$Huber, col = "blue", pch = 3, cex = 1.5)

# One may also compute the depth values of the observations in the data
# separately. This avoids having to recompute them when computing the median. 
depth.result &lt;- projdepth(x = BivData)
result &lt;- projmedian(x = BivData, 
                     projection.depths = depth.result$depthX)
</code></pre>

<hr>
<h2 id='rdepth'>Regression depth of hyperplanes</h2><span id='topic+rdepth'></span>

<h3>Description</h3>

<p>Computes the regression depth of several hyperplanes with
respect to a multiple regression dataset with <code class="reqn">p</code> explanatory variables.
The computation is exact for <code class="reqn">p &lt;= 3</code>.
An approximate algorithm is used for <code class="reqn">p&gt;3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdepth(x, z = NULL, ndir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p+1</code> regression dataset. <br />
The first <code class="reqn">p</code> columns are the explanatory variables. The last
column corresponds to the response variable.
</p>
</td></tr>
<tr><td><code id="rdepth_+3A_z">z</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">p+1</code> matrix containing rowwise the hyperplanes for which to compute the regression depth. The first column should contain the intercepts. <br />
If <code>z</code> is not specified, it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="rdepth_+3A_ndir">ndir</code></td>
<td>
<p>Controls the number of directions when the approximate
algorithm is used. Defaults to <code class="reqn">250p</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regression depth has been introduced in Rousseeuw and Hubert (1999). To compute the regression depth of a hyperplane, different algorithms are used. When <code class="reqn">p &lt;= 3</code> it can be computed exactly. In higher dimensions an approximate algorithm is used (Rousseeuw and Struyf 1998). 
</p>
<p>It is first checked whether the data <code>x</code> lie in a subspace of
dimension smaller than <code class="reqn">p + 1</code>. If so, a warning is given, as well as the  dimension of the subspace and a direction which is orthogonal to it.</p>


<h3>Value</h3>

<p>A  list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>depthZ</code></td>
<td>
<p>A vector containing the regression depth of the hyperplanes in <code>z</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p> A vector of length <code class="reqn">m</code>. <br />
For each hyperplane, it contains the number of singular subsamples when the approximate algorithm is used. The actual number of directions used in the algorithm therefore equals <code>ndir-singularSubsets</code>.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert using Fortran code by P.J. Rousseeuw, I. Ruts and A. Struyf</p>


<h3>References</h3>

<p>Rousseeuw P.J., Hubert M. (1999). Regression depth.  <em>Journal of the American Statistical Association</em>, <b>94</b>, 388&ndash;402.
</p>
<p>Rousseeuw P.J., Struyf A. (1998). Computing location depth and regression depth in higher dimensions.  <em>Statistics and Computing</em>, <b>45</b>, 193&ndash;203.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdepthmedian">rdepthmedian</a></code>, <code><a href="#topic+cmltest">cmltest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustrate the concept of regression depth in the case of simple 
# linear regression. 

data(stars)

# Compute the least squares fit. Due to outliers
# this fit will be bad and thus should result in a small
# regression depth.
temp &lt;- lsfit(x = stars[,1], y = stars[,2])$coefficients
intercept &lt;- temp[1]
slope &lt;- temp[2]
plot(stars, ylim = c(4,7))
abline(a = intercept, b = slope)
abline(a = -9.2, b = 3.2, col = "red")

# Let us compare the regression depth of the least squares fit
# with the depth of the better fitting red regression line.
z &lt;- rbind(cbind(intercept, slope),
           cbind(-9.2, 3.2))
result &lt;- rdepth(x = stars, z = z)
result$depthZ
text(x = 3.8, y = 5.3, labels = round(result$depthZ[1], digits =2))
text(x = 4.45, y = 4.8, labels = round(result$depthZ[2], digits =2), col = "red")

# Compute the depth of some other regression lines to illustrate the concept.
# Note that the stars data set has 47 observations and 1/47 = 0.0212766.
z &lt;- rbind(cbind(6.2, 0),
           cbind(6.5, 0))
result &lt;- rdepth(x = stars, z = z)
abline(a = 6.2, b = 0, col = "blue")
abline(a = 6.5, b = 0, col = "darkgreen")
text(x = 3.8, y = 6.25, labels = round(result$depthZ[1], digits = 2),
     col = "blue")
text(x = 4, y = 6.55, labels = round(result$depthZ[2], digits = 2), 
     col = "darkgreen")
# One point needs to removed to make the blue line a nonfit. The green line is 
# clearly a nonfit. 
</code></pre>

<hr>
<h2 id='rdepthmedian'>Hyperplane of maximal regression depth</h2><span id='topic+rdepthmedian'></span>

<h3>Description</h3>

<p>Computes the deepest regression, i.e. the hyperplane with maximal
regression depth given a regression dataset with <code class="reqn">p</code> explanatory variables. The computation is exact for simple regression, and approximate otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdepthmedian(x, maxit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdepthmedian_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p+1</code> regression data matrix. <br />
The first <code class="reqn">p</code> columns are the explanatory variables. The last
column corresponds to the response variable.</p>
</td></tr>
<tr><td><code id="rdepthmedian_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations. <br />
Defaults to <code class="reqn">100</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simple regression the deepest regression fit can be computed exactly by considering all lines through two data points and taking the one with maximal regression depth. If several lines have the same maximal regression depth, their average is taken.
</p>
<p>When <code class="reqn">p &gt; 1</code>, the approximate MEDSWEEP algorithm is applied (Van Aelst et al, 2002).
</p>
<p>It is first checked whether the data lie in a subspace of
dimension smaller than <code class="reqn">p + 1</code>. If so, a warning is given, as well as the  dimension of the subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A  list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>deepest</code></td>
<td>
<p>A <code class="reqn">(p+1)</code> vector containing the estimates of the deepest regression fit. The last <code class="reqn">p</code> values are the slopes, the first value corresponds to the intercept.</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>The depth of the deepest regression hyperplane.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p> The number of performed iterations used in the medsweep algorithm. </p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert using Fortran code by S. Van Aelst</p>


<h3>References</h3>

<p>Van Aelst S., Rousseeuw P.J., Hubert M., Struyf A. (2002). The deepest regression method. <em>Journal of Multivariate Analysis</em>, <b>81</b>, 138&ndash;166.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdepth">rdepth</a></code>, <code><a href="#topic+cmltest">cmltest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustrate the concept of deepest regression line in the case of simple 
# linear regression. 
data(stars)
plot(stars, pch=16)
result &lt;- rdepthmedian(x = stars)
abline(result$deepest, col="blue", lwd=2)

x &lt;- matrix(rnorm(3000), ncol = 3) + 10
rdepthmedian(x = x)
</code></pre>

<hr>
<h2 id='sdepth'>Simplicial depth of points relative to a dataset</h2><span id='topic+sdepth'></span>

<h3>Description</h3>

<p>Computes the simplicial depth of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. Only dimension <code class="reqn">p&lt;=2</code> is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdepth(x, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="sdepth_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the simplicial depth. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplicial depth has been introduced by Liu (1990). The simplicial depth of a point <code class="reqn">z_i</code> is defined as the number of simplices with vertices in <code>x</code> that contain <code class="reqn">z_i</code>. 
Exact computation of the simplicial depth for bivariate data is performed by means of the algorithm described in Rousseeuw and Ruts (1996).
To visualize the depth of bivariate data one can apply the <code>mrainbowplot</code> function. It plots the data with coloring according to their depth. 
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>depthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the simplicial depth of the points in <code>z</code>. </p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert, based on Fortran code by  P.J. Rousseeuw, I. Ruts and A. Struyf.</p>


<h3>References</h3>

<p>Liu R. (1990). On a notion of data depth based on random simplices. 
<em>The Annals of Statistics,</em> <b>18</b>, 405&ndash;414.
</p>
<p>Rousseeuw P.J., Ruts I. (1996). AS 307: Bivariate location depth. <em>Applied Statistics,</em> <b>45</b>, 516&ndash;526.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mrainbowplot">mrainbowplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bloodfat)
Result &lt;- sdepth(x = bloodfat)
mrainbowplot(bloodfat, depth = Result$depthZ)
</code></pre>

<hr>
<h2 id='sprojdepth'>Skewness-adjusted projection depth of points relative to a dataset</h2><span id='topic+sprojdepth'></span>

<h3>Description</h3>

<p>Computes the skewness-adjusted projection depth of <code class="reqn">p</code>-dimensional
points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprojdepth(x, z = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sprojdepth_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="sprojdepth_+3A_z">z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the projection depth. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td></tr>
<tr><td><code id="sprojdepth_+3A_options">options</code></td>
<td>
<p> A list of options to pass to the underlying <code>adjOutl</code> routine.
See <code>adjOutl</code> for the full list of options. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Skewness-adjusted projection depth is based on the adjusted
outlyingness and is computed as <code class="reqn">1/(1+AO)</code>. As adjusted 
outlyingness extends the Stahel-Donoho outlyingness towards 
skewed distributions, the skewness-adjusted projection depth 
is suited for both elliptical distributions and skewed 
multivariate data.
</p>
<p>It is first checked whether the data is found to lie in a subspace of
dimension lower than <code class="reqn">p</code>. If so, a warning is given, as well as the
dimension of the subspace and a direction which is orthogonal to it.
</p>
<p>See <code>adjOutl</code> for more details on the computation of the AO.
To visualize the depth of bivariate data one can apply the 
<code>mrainbowplot</code> function. It plots the data colored according to 
their depth. 
</p>
<p>The output values of this function are based on the output of the 
<code>adjOutl</code> function. More details can be found there. 
</p>


<h3>Value</h3>

<p>A list with components: <br />
</p>
<table role = "presentation">
<tr><td><code>depthX</code></td>
<td>
<p>Vector of length <code class="reqn">n</code> giving the
skewness-adjusted projection depth of
the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>depthZ</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> giving the
skewness-adjusted projection depth of
the points in <code>z</code>.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>Points whose skew-adjusted projection depth is smaller
than this cutoff can be considered as outliers.</p>
</td></tr>
<tr><td><code>flagX</code></td>
<td>
<p>Observations of <code>x</code> whose adjusted outlyingness exceeds 
the cutoff receive a flag <code>FALSE</code>, regular observations 
receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>flagZ</code></td>
<td>
<p>Points of <code>z</code> whose adjusted outlyingness exceeds the 
cutoff receive a flag equal to <code>FALSE</code>, otherwise they 
receive a flag <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>singularSubsets</code></td>
<td>
<p>When the input parameter type is equal to <code>"Affine"</code>,
the number of <code class="reqn">p</code>-subsets that span a subspace of
dimension smaller than <code class="reqn">p-1</code>. In that case the orthogonal
direction can not be uniquely determined. This is an indication
that the data are not in general position.
When the input parameter type is equal to <code>"Rotation"</code> it
is possible that two randomly selected points of the data coincide
due to ties in the data. In this case this value signals how many
times this is the case.
</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a
lower dimensional subspace, the dimension
of this subspace.</p>
</td></tr>
<tr><td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional 
subspace, a direction orthogonal to this subspace. When a 
direction <code class="reqn">v</code> is found such that the robust skew-adjusted
scale of <code class="reqn">xv</code> is equal to zero, this equals <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>inSubspace</code></td>
<td>
<p>When a direction <code class="reqn">v</code> is found such that AO(<code class="reqn">xv</code>) is 
ill-defined, the observations from <code>x</code> which belong to 
the hyperplane orthogonal to <code class="reqn">v</code> receive a value TRUE. 
The other observations receive a value FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert with original code from M. Maechler, G. Brys, K. Vakili</p>


<h3>References</h3>

<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>
<p>Hubert M, Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+sprojmedian">sprojmedian</a></code>, <code><a href="#topic+mrainbowplot">mrainbowplot</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the skewness-adjusted projection depth 
# of a two-dimensional dataset.

data(bloodfat)
Result &lt;- sprojdepth(x = bloodfat)

# A multivariate rainbowplot may be obtained using mrainbowplot.
plot.options = list(legend.title = "SPD")
mrainbowplot(x = bloodfat, 
             depths = Result$depthX, plot.options = plot.options)

# Options for the underlying outlyingness routine may be passed 
# using the options argument. 
Result &lt;- sprojdepth(x = bloodfat, 
                     options = list(type = "Affine",
                                    ndir = 1000,
                                    seed = 12345
                                    )
                    )
</code></pre>

<hr>
<h2 id='sprojmedian'>Location estimates based on skewness-adjusted projection depth</h2><span id='topic+sprojmedian'></span>

<h3>Description</h3>

<p>Computes a skewness-adjusted projection depth based location estimate of a 
<code class="reqn">p</code>-dimensional dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprojmedian(x, sprojection.depths = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sprojmedian_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td></tr>
<tr><td><code id="sprojmedian_+3A_sprojection.depths">sprojection.depths</code></td>
<td>
<p>Vector containing the skewness-adjusted projection
depth values of the observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="sprojmedian_+3A_options">options</code></td>
<td>
<p> A list of options to pass to the <code>sprojdepth</code> routine.
See <code>sprojdepth</code> for more details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm depends on the function <code>sprojdepth</code> to compute the
skewness-adjusted projection depth values of the observations in <code>x</code>. 
If these depth have already been
computed they can be passed as an optional argument to save computing time.
If not, the skewness-adjusted projection depth values will be computed and the user 
can pass a list with options to the <code>sprojdepth</code> function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller 
than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the 
subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A list with component: <br />
</p>
<table role = "presentation">
<tr><td><code>max</code></td>
<td>
<p>The point of <code>x</code> with maximal skewness-adjusted projection 
depth. If multiple points have maximum depth, their center
of gravity is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235&ndash;246.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjOutl">adjOutl</a></code>, <code><a href="#topic+sprojdepth">sprojdepth</a></code>, <code><a href="#topic+dirOutl">dirOutl</a></code>, <code><a href="#topic+outlyingness">outlyingness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a location estimate of a two-dimensional dataset.
data(bloodfat)

result &lt;- sprojmedian(x = bloodfat)
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# Options for the underlying sprojdepth routine may be passed 
# using the options argument. 
result &lt;- sprojmedian(x = bloodfat,
                      options = list(type = "Rotation",
                                     ndir = 1000
                                     )
                     )
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# One may also compute the depth values of the observations in the data
# separately. This avoids having to recompute them when computing the median. 
depth.result &lt;- sprojdepth(x = bloodfat)
result &lt;- sprojmedian(x = bloodfat, 
                      sprojection.depths = depth.result$depthX)
</code></pre>

<hr>
<h2 id='stars'>stars data</h2><span id='topic+stars'></span>

<h3>Description</h3>

<p>Data corresponding to a Hertzsprung-Russel diagram of the star cluster CYG OB1 containing 47 stars in the direction of Cygnus.
A typical Hertzsprung-Russel diagram shows the logarithm of the temperature in reverse order from high to low.
</p>
<p>The data has been taken from Humphreys (1978) by C. Doom who calibrated them according to Vansina and De Greve (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stars)
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>LogTemp</code></dt><dd><p>Logarithm of the effective temperature at the star's surface.</p>
</dd>
<dt><code>LogLight</code></dt><dd><p>Logarithm of a star's light intensity. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Humphreys R.M. (1978). Studies of luminous stars in nearby galaxies. I. Supergiants and O stars in the milky way.  <em>Astrophysics Journal Supplementary Series</em>, <b>38</b>, 309&ndash;350.
</p>


<h3>References</h3>

<p>Vansima F., De Greve J.P. (1982). Close binary systems before and after mass transfer. <em>Astrophysics and Space Science</em>, <b>87</b>, 377&ndash;401. 
</p>
<p>Rousseeuw P.J., Leroy A. (1987). Robust Regression and Outlier Detection. <em>New York: Wiley</em>.
</p>
<p>Hand D.J., Daly F., Lunn A., McConway A. (1994). A Handbook of Small Data Sets. <em>Londen: Chapman and Hall</em>,  dataset 367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stars)
plot(stars, xlim = rev(range(stars[,1])))
</code></pre>

<hr>
<h2 id='symtest'>Test for angular symmetry around a specified center for bivariate data</h2><span id='topic+symtest'></span>

<h3>Description</h3>

<p>A test based on halfspace depth for angular symmetry of the bivariate data set <code>x</code> around the point <code>z</code>. The test is only valid when <code>x</code> contains no duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symtest(x, z, options=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symtest_+3A_x">x</code></td>
<td>
<p> An <code class="reqn">n</code> by 2 data matrix.</p>
</td></tr>
<tr><td><code id="symtest_+3A_z">z</code></td>
<td>
<p> A vector of length <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="symtest_+3A_options">options</code></td>
<td>
<p>A list of options to pass to <code>hdepth</code>. <br />
See <code>hdepth</code> for more information. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following hypothesis test is performed: <br />
<code class="reqn">H_0</code>: The data come from a continuous distribution <code class="reqn">P</code> which is angularly symmetric about <code>z</code>. <br />
The test statistic being used is the halfspace depth of <code>z</code> with respect to <code>x</code>. Under the null hypothesis the halfspace depth of <code>z</code> equals <code class="reqn">1/2</code>. The distribution of the teststatistic under <code class="reqn">H_0</code> is <code class="reqn">F_n(k) = P(hdepth(P, z) \le k)</code>. The <code class="reqn">p</code>-value of the test is <code class="reqn">F_n(k)</code> with <code class="reqn">k= hdepth(\code{x},z)</code>. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>The <code class="reqn">p</code>-value of the hypothesis test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Rousseeuw P.J, Struyf A. (2002). A depth test for symmetry. In:  <em> Goodness-of-Fit Tests and Model Validity</em>, Birkhäuser Boston,  pages 401&ndash;412.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform the test on a simple data example.
data(cardata90)
deepest &lt;- hdepthmedian(cardata90)$median
symtest(x = cardata90[!duplicated(cardata90), ], z = deepest)
plot(cardata90)
points(deepest[1], deepest[2], pch=18, col="red", cex=1.2)
</code></pre>

<hr>
<h2 id='tablets'>Near Infrared Spectroscopy responses for a batch of pills</h2><span id='topic+tablets'></span>

<h3>Description</h3>

<p>The original data set consists of Near Infrared Spectroscopy (NIR) data of a batch of pills with different levels of the active compound.  This data set considers 70 observations weighing 90 mg and 20 observations weighing 250 mg and also differ in the amount of active compound. 
</p>
<p>The data correspond to the form discussed in Hubert et al. (2015), see below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tablets)</code></pre>


<h3>Format</h3>

<p>A three dimensional <code class="reqn">t  = 404</code> by <code class="reqn">n = 90</code> by <code class="reqn">p = 3</code> array,
with <code class="reqn">t</code> the number of observed time points,
<code class="reqn">n</code> the number of functional observations
and <code class="reqn">p</code> the number of measurements
for every functional observation at every wavelength.
</p>


<h3>Details</h3>

<p>For each wavelength and each curve, a three-dimensional vector of observations is available. The second coordinate corresponds to the original data, the first coordinate corresponds to the mean of the corresponding curve. The last component corresponds to the derivative of the original curve data.
</p>
<p>When using this data, please cite both of the references listed below. 
</p>


<h3>Source</h3>

<p>Dyrby M., Engelsen S.B., Norgaard L., Bruhn M.,  Nielsen L. (2002).
Chemometric quantitation of the active substance in a pharmaceutical tablet Using near infrared (NIR) transmittance and NIR FT-Raman spectra.
<em>Applied Spectroscopy</em>,  <b>56</b>, 579&ndash;585.
</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tablets)
par(mfrow = c(3,1))
matplot(tablets[,,1], type = "l", lty = 1, col = "black")
matplot(tablets[,,2], type = "l", lty = 1, col = "black")
matplot(tablets[,,3], type = "l", lty = 1, col = "black")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='wine'>Proton Nuclear Magnetic Resonance spectra of 40 different wine samples</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>The original data set consists of Proton Nuclear Magnetic Resonance (NMR) spectra of 40 different wine samples in the spectral region from 6.00ppm to 0.50ppm. This data set corresponds to the region between wavelengths 5.62ppm and 5.37ppm only for which <code class="reqn">t = 397</code> measurements are available for each curve. The data has been analyzed in Hubert et al. (2015), see below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)</code></pre>


<h3>Format</h3>

<p>A three dimensional <code class="reqn">t  = 397</code> by <code class="reqn">n = 40</code> by <code class="reqn">p = 1</code> array,
with <code class="reqn">t</code> the number of observed time points,
<code class="reqn">n</code> the number of functional observations
and <code class="reqn">p</code> the number of measurements
for every functional observation at every wavelength.
</p>


<h3>Details</h3>

<p>When using this data set, please cite both of the references below. 
</p>


<h3>Source</h3>

<p>Larsen F., van den Berg F., Engelsen S. (2006). An exploratory chemometric study of NMR spectra of table wines. <em>Journal of Chemometrics</em>, <b>20</b>, 198&ndash;208.</p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection (with rejoinder). <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177&ndash;202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
matplot(wine[,,1], type = "l", lty = 1, col = "black")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
