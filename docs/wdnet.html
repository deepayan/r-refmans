<!DOCTYPE html><html><head><title>Help for package wdnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wdnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wdnet-package'><p>wdnet: Weighted and Directed Networks</p></a></li>
<li><a href='#+2B.rpacontrol'><p>Add components to the control list</p></a></li>
<li><a href='#adj_to_edgelist'><p>Converts an adjacency matrix to edgelist and edgeweight using the</p>
<code>igraph</code> package.</a></li>
<li><a href='#adj_to_wdnet'><p>Creates a <code>wdnet</code> object using an adjacency matrix</p></a></li>
<li><a href='#assortcoef'><p>Compute the assortativity coefficient(s) for a network.</p></a></li>
<li><a href='#centrality'><p>Centrality measures</p></a></li>
<li><a href='#closeness_c'><p>Closeness centrality</p></a></li>
<li><a href='#clustcoef'><p>Directed clustering coefficient</p></a></li>
<li><a href='#compile_pref_func'><p>Compile preference functions via <code>RcppXPtrUtils</code>.</p></a></li>
<li><a href='#create_wdnet'><p>Creates a <code>wdnet</code> object from input data.</p></a></li>
<li><a href='#cvxr_control'><p>Parameters passed to CVXR::solve().</p></a></li>
<li><a href='#degree_c'><p>Degree-based centrality</p></a></li>
<li><a href='#dprewire'><p>Degree preserving rewiring.</p></a></li>
<li><a href='#dprewire_directed'><p>Degree preserving rewiring for directed networks</p></a></li>
<li><a href='#dprewire_directed_cpp'><p>Degree preserving rewiring process for directed networks.</p></a></li>
<li><a href='#dprewire_undirected'><p>Degree preserving rewiring for undirected networks</p></a></li>
<li><a href='#dprewire_undirected_cpp'><p>Degree preserving rewiring process for undirected networks.</p></a></li>
<li><a href='#dprewire.range'><p>Range of assortativity coefficients.</p></a></li>
<li><a href='#dw_assort'><p>Compute the assortativity coefficient of a weighted and directed network.</p></a></li>
<li><a href='#dw_feature_assort'><p>Feature based assortativity coefficient</p></a></li>
<li><a href='#edgelist_to_adj'><p>Convert edgelist and edgeweight to adjacency matrix.</p></a></li>
<li><a href='#edgelist_to_wdnet'><p>Creates a <code>wdnet</code> object using <code>edgelist</code>.</p></a></li>
<li><a href='#fill_weight_cpp'><p>Fill edgeweight into the adjacency matrix.</p>
Defined for function <code>edgelist_to_adj</code>.</a></li>
<li><a href='#find_node_cpp'><p>Fill missing nodes in the node sequence. Defined for <code>wdnet::rpanet</code>.</p></a></li>
<li><a href='#find_node_undirected_cpp'><p>Fill missing values in node sequence. Defined for <code>wdnet::rpanet</code>.</p></a></li>
<li><a href='#get_constr'><p>Get the constraints for the optimization problem. This function is defined</p>
for <code>get_eta_directed()</code>.</a></li>
<li><a href='#get_dist'><p>Get the node-level joint distributions and some empirical distributions with</p>
given edgelist.</a></li>
<li><a href='#get_eta_directed'><p>Compute edge-level distributions for directed networks with respect to</p>
desired assortativity level(s).</a></li>
<li><a href='#get_eta_undirected'><p>Compute edge-level distribution for undirected networks with respect to</p>
desired assortativity level.</a></li>
<li><a href='#get_values'><p>Get the value of an object from the optimization problem. This function is</p>
defined for <code>get_eta_directed()</code>.</a></li>
<li><a href='#igraph_to_wdnet'><p>Converts an <code>igraph</code> object to a <code>wdnet</code> object</p></a></li>
<li><a href='#is_rpacontrol'><p>Checks whether the input is a <code>rpacontrol</code> object</p></a></li>
<li><a href='#is_wdnet'><p>Checks if the input is a <code>wdnet</code> object</p></a></li>
<li><a href='#node_strength_cpp'><p>Aggregate edgeweight into nodes' strength.</p></a></li>
<li><a href='#plot.wdnet'><p>Plots the input network</p></a></li>
<li><a href='#print_control_details'><p>Prints <code>rpacontrol</code> in terminal</p></a></li>
<li><a href='#print_control_edgeweight'><p>Prints <code>rpa_control_edgeweight()</code> in terminal</p></a></li>
<li><a href='#print_control_newedge'><p>Prints <code>rpa_control_newedge()</code> in terminal</p></a></li>
<li><a href='#print_control_preference'><p>Prints <code>rpa_control_preference()</code> in terminal</p></a></li>
<li><a href='#print_control_reciprocal'><p>Prints <code>rpa_control_reciprocal()</code> in terminal</p></a></li>
<li><a href='#print_control_scenario'><p>Prints <code>rpa_control_scenario()</code> in terminal</p></a></li>
<li><a href='#print.rpacontrol'><p>Prints <code>rpacontrol</code> objects</p></a></li>
<li><a href='#print.wdnet'><p>Prints the input network</p></a></li>
<li><a href='#rpa_control_default'><p>Default controls for <code>rpanet</code></p></a></li>
<li><a href='#rpa_control_edgeweight'><p>Control weight of new edges. Defined for <code>rpanet</code>.</p></a></li>
<li><a href='#rpa_control_newedge'><p>Control new edges in each step. Defined for <code>rpanet</code>.</p></a></li>
<li><a href='#rpa_control_preference'><p>Set preference function(s). Defined for <code>rpanet</code>.</p></a></li>
<li><a href='#rpa_control_reciprocal'><p>Control reciprocal edges. Defined for <code>rpanet</code>.</p></a></li>
<li><a href='#rpa_control_scenario'><p>Control edge scenarios. Defined for <code>rpanet</code>.</p></a></li>
<li><a href='#rpacontrol'><p>rpacontrol: Controls the Preferential Attachment (PA) Network Generation</p>
Process</a></li>
<li><a href='#rpanet'><p>Generate PA networks.</p></a></li>
<li><a href='#rpanet_bag_cpp'><p>Preferential attachment algorithm for simple situations,</p>
i.e., edge weight equals 1, each step adds one new edge.</a></li>
<li><a href='#rpanet_binary_directed'><p>Preferential attachment network generation.</p></a></li>
<li><a href='#rpanet_binary_undirected_cpp'><p>Preferential attachment network generation.</p></a></li>
<li><a href='#rpanet_general'><p>Internal functions for generating PA networks</p></a></li>
<li><a href='#rpanet_linear_directed_cpp'><p>Preferential attachment network generation.</p></a></li>
<li><a href='#rpanet_linear_undirected_cpp'><p>Preferential attachment network generation.</p></a></li>
<li><a href='#sample_node_cpp'><p>Uniformly draw a node from existing nodes for each time step.</p>
Defined for <code>wdnet::rpanet()</code>.</a></li>
<li><a href='#wdnet_to_igraph'><p>Converts a <code>wdnet</code> object to an <code>igraph</code> object</p></a></li>
<li><a href='#wpr'><p>Weighted PageRank centrality</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Weighted and Directed Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yelie Yuan &lt;yelie.yuan@uconn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Assortativity coefficients, centrality measures, 
    and clustering coefficients for weighted and directed networks.
    Rewiring unweighted networks with given assortativity coefficients.
    Generating general preferential attachment networks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>CVXR, igraph, Matrix, rARPACK, RcppXPtrUtils, stats, wdm</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/wdnetwork/wdnet/-/issues">https://gitlab.com/wdnetwork/wdnet/-/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/wdnetwork/wdnet">https://gitlab.com/wdnetwork/wdnet</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 16:06:10 UTC; yelie</td>
</tr>
<tr>
<td>Author:</td>
<td>Yelie Yuan [aut, cre],
  Tiandong Wang [aut],
  Jun Yan [aut],
  Panpan Zhang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wdnet-package'>wdnet: Weighted and Directed Networks</h2><span id='topic+wdnet'></span><span id='topic+wdnet-package'></span>

<h3>Description</h3>

<p>This package provides functions to conduct network analysis
</p>

<ul>
<li><p> Assortativity, centrality, clustering coefficient
for weighted and directed networks
</p>
</li>
<li><p> Rewire an unweighted network with given assortativity coefficient(s)
</p>
</li>
<li><p> Preferential attachment (PA) network generation
</p>
</li></ul>



<h3>wdnet networks</h3>

<p>wdnet networks have a class <code>wdnet</code>. It is a
list containing the following components:
</p>

<ul>
<li><p> A logical value <code>directed</code> indicating if the network is directed.
</p>
</li>
<li><p> A logical value <code>weighted</code> indicating if the network is weighted.
</p>
</li>
<li><p> A two-column matrix <code>edgelist</code> representing the edges.
</p>
</li>
<li><p> A data frame <code>node.attr</code> that includes node attributes,
such as node strengths.
</p>
</li>
<li><p> A data frame <code>edge.attr</code> that includes edge attributes,
such as edge weights.
</p>
</li></ul>



<h3>Creating a <code>wdnet</code> Object</h3>


<ul>
<li><p> To generate a preferential attachment (PA) network,
use <code>rpanet()</code>.
</p>
</li>
<li><p> To create a <code>wdnet</code> object from an edge list
and edge weights, use <code>edgelist_to_wdnet()</code>.
</p>
</li>
<li><p> To create a <code>wdnet</code> object from an adjacency
matrix, use <code>adj_to_wdnet()</code>.
</p>
</li>
<li><p> To convert an <code>igraph</code> object to a <code>wdnet</code>
object, use <code>igraph_to_wdnet()</code>.
</p>
</li></ul>



<h3>Further information</h3>

<p>The development version of this package is
available on Gitlab (<a href="https://gitlab.com/wdnetwork/wdnet">https://gitlab.com/wdnetwork/wdnet</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yelie Yuan <a href="mailto:yelie.yuan@uconn.edu">yelie.yuan@uconn.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tiandong Wang <a href="mailto:td_wang@fudan.edu.cn">td_wang@fudan.edu.cn</a>
</p>
</li>
<li><p> Jun Yan <a href="mailto:jun.yan@uconn.edu">jun.yan@uconn.edu</a>
</p>
</li>
<li><p> Panpan Zhang <a href="mailto:panpan.zhang@vumc.org">panpan.zhang@vumc.org</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/wdnetwork/wdnet">https://gitlab.com/wdnetwork/wdnet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/wdnetwork/wdnet/-/issues">https://gitlab.com/wdnetwork/wdnet/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+2B.rpacontrol'>Add components to the control list</h2><span id='topic++2B.rpacontrol'></span>

<h3>Description</h3>

<p>'+' is used to combine components to control the PA network generation
process. Available components are <code>rpa_control_scenario()</code>,
<code>rpa_control_edgeweight()</code>, <code>rpa_control_newedge()</code>,
<code>rpa_control_preference()</code> and <code>rpa_control_reciprocal()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpacontrol'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.rpacontrol_+3A_e1">e1</code></td>
<td>
<p>A list of class <code>rpacontrol</code>.</p>
</td></tr>
<tr><td><code id="+2B2B.rpacontrol_+3A_e2">e2</code></td>
<td>
<p>A list of class <code>rpacontrol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> with components from <code>e1</code> and
<code>e2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
control &lt;- rpa_control_scenario(alpha = 0.5, beta = 0.5) +
  rpa_control_preference(
    ftype = "customized",
    spref = "pow(outs, 2) + 1",
    tpref = "pow(ins, 2) + 1"
  )


control &lt;- rpa_control_scenario(alpha = 1) +
  rpa_control_edgeweight(
    sampler = function(n) rgamma(n, shape = 5, scale = 0.2)
  )
</code></pre>

<hr>
<h2 id='adj_to_edgelist'>Converts an adjacency matrix to edgelist and edgeweight using the
<code>igraph</code> package.</h2><span id='topic+adj_to_edgelist'></span>

<h3>Description</h3>

<p>Converts an adjacency matrix to edgelist and edgeweight using the
<code>igraph</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_to_edgelist(adj, directed = TRUE, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_to_edgelist_+3A_adj">adj</code></td>
<td>
<p>Adjacency matrix of a network.</p>
</td></tr>
<tr><td><code id="adj_to_edgelist_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed. This value is
passed to <code>igraph::graph_from_adjacency_matrix()</code>.</p>
</td></tr>
<tr><td><code id="adj_to_edgelist_+3A_weighted">weighted</code></td>
<td>
<p>Logical, whether the network is weighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of edgelist, edgeweight and directed.
</p>

<hr>
<h2 id='adj_to_wdnet'>Creates a <code>wdnet</code> object using an adjacency matrix</h2><span id='topic+adj_to_wdnet'></span>

<h3>Description</h3>

<p>Creates a <code>wdnet</code> object using an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_to_wdnet(adj, directed = TRUE, weighted = TRUE, nodegroup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_to_wdnet_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix used to extract <code>edgelist</code> and
<code>edgeweight</code> using <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="adj_to_wdnet_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed (TRUE) or undirected
(FALSE). If <code>adj</code> is asymmetric, the network is directed.</p>
</td></tr>
<tr><td><code id="adj_to_wdnet_+3A_weighted">weighted</code></td>
<td>
<p>Logical, whether the network is weighted (TRUE) or unweighted
(FALSE).</p>
</td></tr>
<tr><td><code id="adj_to_wdnet_+3A_nodegroup">nodegroup</code></td>
<td>
<p>A numeric vector of node groups.</p>
</td></tr>
<tr><td><code id="adj_to_wdnet_+3A_...">...</code></td>
<td>
<p>Additional components to be added to the <code>wdnet</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wdnet</code> object with the specified <code>adj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- matrix(c(0, 1, 2, 0), nrow = 2, ncol = 2, byrow = TRUE)
adj_to_wdnet(adj = adj, directed = TRUE, weighted = FALSE)

</code></pre>

<hr>
<h2 id='assortcoef'>Compute the assortativity coefficient(s) for a network.</h2><span id='topic+assortcoef'></span>

<h3>Description</h3>

<p>Compute the assortativity coefficient(s) for a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assortcoef(netwk, edgelist, edgeweight, adj, directed, f1, f2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assortcoef_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object that represents the network. If
<code>NULL</code>, the function will compute the coefficient using either
<code>edgelist</code> and <code>edgeweight</code>, or <code>adj</code>.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing edges.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A numeric vector of edge weights with the same length as
the number of rows in edgelist. If <code>NULL</code>, all edges will be assigned
weight 1.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_adj">adj</code></td>
<td>
<p>The adjacency matrix of a network.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_directed">directed</code></td>
<td>
<p>Logical. Indicates whether the edges in <code>edgelist</code> or
<code>adj</code> are directed. It will be omitted if <code>netwk</code> is provided.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_f1">f1</code></td>
<td>
<p>A vector representing the first feature of existing nodes. The
number of nodes should be equal to the length of both <code>f1</code> and
<code>f2</code>. Defined for directed networks. If <code>NULL</code>, out-strength will
be used.</p>
</td></tr>
<tr><td><code id="assortcoef_+3A_f2">f2</code></td>
<td>
<p>A vector representing the second feature of existing nodes. Defined
for directed networks. If <code>NULL</code>, in-strength will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Assortativity coefficient for undirected networks, or a list of four
assortativity coefficients for directed networks.
</p>


<h3>Note</h3>

<p>When the adjacency matrix is binary (i.e., directed but unweighted
networks), <code>assortcoef</code> returns the assortativity coefficient proposed
in Foster et al. (2010).
</p>


<h3>References</h3>

 <ul>
<li><p> Foster, J.G., Foster, D.V., Grassberger, P. and
Paczuski, M. (2010). Edge direction and the structure of networks.
<em>Proceedings of the National Academy of Sciences of the United
States</em>, 107(24), 10815&ndash;10820. </p>
</li>
<li><p> Yuan, Y. Zhang, P. and Yan, J.
(2021). Assortativity coefficients for weighted and directed networks.
<em>Journal of Complex Networks</em>, 9(2), cnab017.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
control &lt;- rpa_control_edgeweight(
  sampler = function(n) rgamma(n, shape = 5, scale = 0.2)
)
netwk &lt;- rpanet(nstep = 10^4, control = control)
ret &lt;- assortcoef(netwk)
ret &lt;- assortcoef(
  edgelist = netwk$edgelist,
  edgeweight = netwk$edge.attr$weight,
  directed = TRUE
)

</code></pre>

<hr>
<h2 id='centrality'>Centrality measures</h2><span id='topic+centrality'></span>

<h3>Description</h3>

<p>Computes the centrality measures of the nodes in a weighted and directed
network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centrality(
  netwk,
  adj,
  edgelist,
  edgeweight,
  directed = TRUE,
  measure = c("degree", "closeness", "wpr"),
  degree.control = list(alpha = 1, mode = "out"),
  closeness.control = list(alpha = 1, mode = "out", method = "harmonic", distance =
    FALSE),
  wpr.control = list(gamma = 0.85, theta = 1, prior.info = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centrality_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object that represents the network. If
<code>NULL</code>, the function will compute the coefficient using either
<code>edgelist</code> and <code>edgeweight</code>, or <code>adj</code>.</p>
</td></tr>
<tr><td><code id="centrality_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix of a weighted and directed network.</p>
</td></tr>
<tr><td><code id="centrality_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing edges of a directed
network.</p>
</td></tr>
<tr><td><code id="centrality_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A vector representing the weight of edges.</p>
</td></tr>
<tr><td><code id="centrality_+3A_directed">directed</code></td>
<td>
<p>Logical. Indicates whether the edges in <code>edgelist</code> or
<code>adj</code> are directed.</p>
</td></tr>
<tr><td><code id="centrality_+3A_measure">measure</code></td>
<td>
<p>Which measure to use: &quot;degree&quot; (degree-based centrality),
&quot;closeness&quot; (closeness centrality), or &quot;wpr&quot; (weighted PageRank
centrality)?</p>
</td></tr>
<tr><td><code id="centrality_+3A_degree.control">degree.control</code></td>
<td>
<p>A list of parameters passed to the degree centrality
measure:
</p>

<ul>
<li><p> 'alpha' A tuning parameter. The value of alpha must be
nonnegative. By convention, alpha takes a value from 0 to 1 (default).
</p>
</li>
<li><p> 'mode' Which mode to compute: &quot;out&quot; (default) or &quot;in&quot;?
For undirected networks, this setting is irrelevant.</p>
</li></ul>
</td></tr>
<tr><td><code id="centrality_+3A_closeness.control">closeness.control</code></td>
<td>
<p>A list of parameters passed to the closeness
centrality measure:
</p>

<ul>
<li><p> 'alpha' A tuning parameter. The value of alpha must be
nonnegative. By convention, alpha takes a value from 0 to
1 (default).
</p>
</li>
<li><p> 'mode' Which mode to compute: &quot;out&quot; (default) or &quot;in&quot;?
For undirected networks, this setting is irrelevant.
</p>
</li>
<li><p> 'method' Which method to use: &quot;harmonic&quot; (default) or
&quot;standard&quot;?
</p>
</li>
<li><p> 'distance' Whether to consider the entries in the adjacency
matrix as distances or strong connections. The default setting is
<code>FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="centrality_+3A_wpr.control">wpr.control</code></td>
<td>
<p>A list of parameters passed to the weighted PageRank
centrality measure:
</p>

<ul>
<li><p> 'gamma' The damping factor; it takes 0.85 (default) if not
given.
</p>
</li>
<li><p> 'theta' A tuning parameter leveraging node degree and
strength; theta = 0 does not consider edge weight; theta = 1 (default)
fully considers edge weight.
</p>
</li>
<li><p> 'prior.info' Vertex-specific prior information for restarting when
arriving at a sink. When it is not given (<code>NULL</code>), a random restart
is implemented.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of node names and associated centrality measures
</p>


<h3>Note</h3>

<p>The degree-based centrality measure is an extension of function
<code>strength</code> in package <code>igraph</code> and an alternative of function
<code>degree_w</code> in package <code>tnet</code>.
</p>
<p>The closeness centrality measure is an extension of function
<code>closeness</code> in package <code>igraph</code> and function <code>closeness_w</code>
in package <code>tnet</code>. The method of computing distances between vertices
is the <em>Dijkstra's algorithm</em>.
</p>
<p>The weighted PageRank centrality measure is an extension of function
<code>page_rank</code> in package <code>igraph</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Dijkstra, E.W. (1959). A note on two problems in connexion with
graphs. <em>Numerische Mathematik</em>, 1, 269&ndash;271.
</p>
</li>
<li><p> Newman, M.E.J. (2003). The structure and function of complex
networks. <em>SIAM review</em>, 45(2), 167&ndash;256.
</p>
</li>
<li><p> Opsahl, T., Agneessens, F., Skvoretz, J. (2010). Node centrality
in weighted networks: Generalizing degree and shortest paths.
<em>Social Networks</em>, 32, 245&ndash;251.
</p>
</li>
<li><p> Zhang, P., Wang, T. and Yan, J. (2022) PageRank centrality and algorithms for
weighted, directed networks with applications to World Input-Output Tables.
<em>Physica A: Statistical Mechanics and its Applications</em>, 586, 126438.
</p>
</li>
<li><p> Zhang, P., Zhao, J. and Yan, J. (2020+) Centrality measures of
networks with application to world input-output tables
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate a network according to the Erd\"{o}s-Renyi model of order 20
## and parameter p = 0.3
edge_ER &lt;- rbinom(400, 1, 0.3)
weight_ER &lt;- sapply(edge_ER, function(x) x * sample(3, 1))
adj_ER &lt;- matrix(weight_ER, 20, 20)
mydegree &lt;- centrality(
  adj = adj_ER,
  measure = "degree", degree.control =
    list(alpha = 0.8, mode = "in")
)
myclose &lt;- centrality(
  adj = adj_ER,
  measure = "closeness", closeness.control =
    list(alpha = 0.8, mode = "out", method = "harmonic", distance = FALSE)
)
mywpr &lt;- centrality(
  adj = adj_ER,
  measure = "wpr", wpr.control =
    list(gamma = 0.85, theta = 0.75)
)

</code></pre>

<hr>
<h2 id='closeness_c'>Closeness centrality</h2><span id='topic+closeness_c'></span>

<h3>Description</h3>

<p>Compute the closeness centrality measures of the vertices in a weighted and
directed network represented through its adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeness_c(
  adj,
  alpha = 1,
  mode = "out",
  method = "harmonic",
  distance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness_c_+3A_adj">adj</code></td>
<td>
<p>is an adjacency matrix of a weighted and directed network</p>
</td></tr>
<tr><td><code id="closeness_c_+3A_alpha">alpha</code></td>
<td>
<p>is a tuning parameter. The value of alpha must be nonnegative.
By convention, alpha takes a value from 0 to 1 (default).</p>
</td></tr>
<tr><td><code id="closeness_c_+3A_mode">mode</code></td>
<td>
<p>which mode to compute: &quot;out&quot; (default) or &quot;in&quot;? For undirected
networks, this setting is irrelevant.</p>
</td></tr>
<tr><td><code id="closeness_c_+3A_method">method</code></td>
<td>
<p>which method to use: &quot;harmonic&quot; (default) or &quot;standard&quot;?</p>
</td></tr>
<tr><td><code id="closeness_c_+3A_distance">distance</code></td>
<td>
<p>whether to consider the entries in the adjacency matrix as
distances or strong connections. The default setting is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of node names and associated closeness centrality measures
</p>


<h3>Note</h3>

<p>Function <code>closeness_c</code> is an extension of function
<code>closeness</code> in package <code>igraph</code> and function <code>closeness_w</code>
in package <code>tnet</code>. The method of computing distances between vertices
is the <em>Dijkstra's algorithm</em>.
</p>


<h3>References</h3>


<ul>
<li><p> Dijkstra, E.W. (1959). A note on two problems in connexion with
graphs. <em>Numerische Mathematik</em>, 1, 269&ndash;271.
</p>
</li>
<li><p> Newman, M.E.J. (2003). The structure and function of complex
networks. <em>SIAM review</em>, 45(2), 167&ndash;256.
</p>
</li>
<li><p> Opsahl, T., Agneessens, F., Skvoretz, J. (2010). Node centrality
in weighted networks: Generalizing degree and shortest paths.
<em>Social Networks</em>, 32, 245&ndash;251.
</p>
</li>
<li><p> Zhang, P., Zhao, J. and Yan, J. (2020+) Centrality measures of
networks with application to world input-output tables
</p>
</li></ul>


<hr>
<h2 id='clustcoef'>Directed clustering coefficient</h2><span id='topic+clustcoef'></span>

<h3>Description</h3>

<p>Compute the clustering coefficient of a weighted and directed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustcoef(
  netwk,
  edgelist,
  edgeweight,
  adj,
  directed = TRUE,
  method = c("Clemente", "Fagiolo"),
  isolates = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustcoef_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object that represents the network. If
<code>NULL</code>, the function will compute the coefficient using either
<code>edgelist</code>, <code>edgeweight</code>, or <code>adj</code>.</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix, each row represents a directed edge of
the network.</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A vector representing the weight of edges.</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix of a weighted and directed network.</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_directed">directed</code></td>
<td>
<p>Logical. Indicates whether the edges in <code>edgelist</code> or
<code>adj</code> are directed.</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_method">method</code></td>
<td>
<p>Which method used to compute clustering coefficients: Clemente
and Grassi (2018) or Fagiolo (2007).</p>
</td></tr>
<tr><td><code id="clustcoef_+3A_isolates">isolates</code></td>
<td>
<p>Binary, defines how to treat vertices with degree zero and
one. If 0, then their clustering coefficient is returned as 0 and are
included in the averaging. Otherwise, their clustering coefficient is <code>NaN</code>
and are excluded in the averaging. Default value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lists of local clustering coefficients (in terms of a vector), global
clustering coefficient (in terms of a scalar) and number of weighted
directed triangles (in terms of a vector) based on <code>total</code>, <code>in</code>,
<code>out</code>, middleman (<code>middle</code>), or <code>cycle</code> triplets.
</p>


<h3>Note</h3>

<p>Self-loops (if exist) are removed prior to the computation of
clustering coefficient. When the adjacency matrix is symmetric (i.e.,
undirected but possibly unweighted networks), <code>clustcoef</code> returns
local and global clustering coefficients proposed by Barrat et al. (2010).
</p>


<h3>References</h3>


<ul>
<li><p> Barrat, A., Barthelemy, M., Pastor-Satorras,
R. and Vespignani, A. (2004). The architecture of complex weighted
networks. <em>Proceedings of National Academy of Sciences of the United
States of America</em>, 101(11), 3747&ndash;3752.
</p>
</li>
<li><p> Clemente, G.P. and Grassi,
R. (2018). Directed clustering in weighted networks: A new perspective.
<em>Chaos, Solitons &amp; Fractals</em>, 107, 26&ndash;38.
</p>
</li>
<li><p> Fagiolo, G. (2007).
Clustering in complex directed networks. <em>Physical Review E</em>, 76,
026107.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate a network according to the Erd\"{o}s-Renyi model of order 20
## and parameter p = 0.3
edge_ER &lt;- rbinom(400, 1, 0.3)
weight_ER &lt;- sapply(edge_ER, function(x) x * sample(3, 1))
adj_ER &lt;- matrix(weight_ER, 20, 20)
mycc &lt;- clustcoef(adj = adj_ER, method = "Clemente")
system.time(mycc)

</code></pre>

<hr>
<h2 id='compile_pref_func'>Compile preference functions via <code>RcppXPtrUtils</code>.</h2><span id='topic+compile_pref_func'></span>

<h3>Description</h3>

<p>Compile preference functions via <code>RcppXPtrUtils</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_pref_func(preference, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_pref_func_+3A_preference">preference</code></td>
<td>
<p>A list for defining the preference functions.</p>
</td></tr>
<tr><td><code id="compile_pref_func_+3A_directed">directed</code></td>
<td>
<p>Logical, whether to compile the preference functions for
directed networks. If missing, the preference functions
for both directed and undirected networks will be compiled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input list and their corresponding external pointers.
</p>

<hr>
<h2 id='create_wdnet'>Creates a <code>wdnet</code> object from input data.</h2><span id='topic+create_wdnet'></span>

<h3>Description</h3>

<p>This function creates a <code>wdnet</code> object from <code>edgelist</code> and
<code>edgeweight</code> or <code>adj</code> or returns the existing <code>wdnet</code> object.
For internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_wdnet(
  netwk,
  edgelist,
  edgeweight,
  nodegroup,
  directed,
  adj,
  weighted,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_wdnet_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object. If <code>NULL</code>, the function will use the
provided <code>edgelist</code> and <code>edgeweight</code>, or <code>adj</code> parameters to
create a new <code>wdnet</code> object.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing edges.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A vector representing the weights of the edges.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_nodegroup">nodegroup</code></td>
<td>
<p>A numeric vector of node groups.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether the network is directed.
Required if <code>netwk</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_weighted">weighted</code></td>
<td>
<p>A logical value indicating whether the network is weighted.</p>
</td></tr>
<tr><td><code id="create_wdnet_+3A_...">...</code></td>
<td>
<p>Additional components to be added to the wdnet list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wdnet</code> object.
</p>

<hr>
<h2 id='cvxr_control'>Parameters passed to CVXR::solve().</h2><span id='topic+cvxr_control'></span>

<h3>Description</h3>

<p>Defined for the convex optimization problems for solving <code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvxr_control(
  solver = "ECOS",
  ignore_dcp = FALSE,
  warm_start = FALSE,
  verbose = FALSE,
  parallel = FALSE,
  gp = FALSE,
  feastol = 1e-05,
  reltol = 1e-05,
  abstol = 1e-05,
  num_iter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvxr_control_+3A_solver">solver</code></td>
<td>
<p>(Optional) A string indicating the solver to use. Defaults to
&quot;ECOS&quot;.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_ignore_dcp">ignore_dcp</code></td>
<td>
<p>(Optional) A logical value indicating whether to override
the DCP check for a problem.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_warm_start">warm_start</code></td>
<td>
<p>(Optional) A logical value indicating whether the previous
solver result should be used to warm start.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_verbose">verbose</code></td>
<td>
<p>(Optional) A logical value indicating whether to print
additional solver output.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_parallel">parallel</code></td>
<td>
<p>(Optional) A logical value indicating whether to solve in
parallel if the problem is separable.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_gp">gp</code></td>
<td>
<p>(Optional) A logical value indicating whether the problem is a
geometric program. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.
Defaults to 1e-5.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap. Defaults to 1e-5.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap. Defaults to 1e-5.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="cvxr_control_+3A_...">...</code></td>
<td>
<p>Additional options that will be passed to the specific solver. In
general, these options will override any default settings imposed by CVXR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- cvxr_control(solver = "OSQP", abstol = 1e-5)
</code></pre>

<hr>
<h2 id='degree_c'>Degree-based centrality</h2><span id='topic+degree_c'></span>

<h3>Description</h3>

<p>Compute the degree centrality measures of the vertices in a weighted and
directed network represented through its adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_c(adj, alpha = 1, mode = "out")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_c_+3A_adj">adj</code></td>
<td>
<p>is an adjacency matrix of a weighted and directed network</p>
</td></tr>
<tr><td><code id="degree_c_+3A_alpha">alpha</code></td>
<td>
<p>is a tuning parameter. The value of alpha must be nonnegative.
By convention, alpha takes a value from 0 to 1 (default).</p>
</td></tr>
<tr><td><code id="degree_c_+3A_mode">mode</code></td>
<td>
<p>which mode to compute: &quot;out&quot; (default) or &quot;in&quot;? For undirected
networks, this setting is irrelevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of node names and associated degree centrality measures
</p>


<h3>Note</h3>

<p>Function <code>degree_c</code> is an extension of function <code>strength</code> in
package <code>igraph</code> and an alternative of function <code>degree_w</code> in
package <code>tnet</code>. Function <code>degree_c</code> uses adjacency matrix as
input.
</p>


<h3>References</h3>


<ul>
<li><p> Opsahl, T., Agneessens, F., Skvoretz, J. (2010). Node centrality
in weighted networks: Generalizing degree and shortest paths.
<em>Social Networks</em>, 32, 245&ndash;251.
</p>
</li>
<li><p> Zhang, P., Zhao, J. and Yan, J. (2020+) Centrality measures of
networks with application to world input-output tables
</p>
</li></ul>


<hr>
<h2 id='dprewire'>Degree preserving rewiring.</h2><span id='topic+dprewire'></span>

<h3>Description</h3>

<p>Rewire a given network to have predetermined assortativity coefficient(s)
while preserving node degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire(
  netwk,
  edgelist,
  directed,
  adj,
  target.assortcoef = list(outout = NULL, outin = NULL, inout = NULL, inin = NULL),
  control = list(iteration = 200, nattempts = NULL, history = FALSE, cvxr_control =
    cvxr_control(), eta.obj = function(x) 0),
  eta
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object representing an unweighted network. If
<code>NULL</code>, the function will construct a network using either
<code>edgelist</code>, or <code>adj</code>.</p>
</td></tr>
<tr><td><code id="dprewire_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix, each row represents an edge of the
network.</p>
</td></tr>
<tr><td><code id="dprewire_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed or not. It will be
ignored if <code>netwk</code> is provided.</p>
</td></tr>
<tr><td><code id="dprewire_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix of an unweighted network.</p>
</td></tr>
<tr><td><code id="dprewire_+3A_target.assortcoef">target.assortcoef</code></td>
<td>
<p>For directed networks, it is a list represents the
predetermined value or range of assortativity coefficients. For undirected
networks, it is a constant between -1 to 1. It will be ignored if
<code>eta</code> is provided.</p>
</td></tr>
<tr><td><code id="dprewire_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the rewiring process and
the process for solving <code>eta</code>. </p>
 <ul>
<li><p> 'iteration' An
integer, represents the number of rewiring iterations. Each iteration
consists of <code>nattempts</code> rewiring attempts. The assortativity
coefficient(s) of the network will be recorded after each iteration.
</p>
</li>
<li><p> 'nattempts' An integer representing the number of rewiring
attempts for each
iteration. Default value equals the number of rows of <code>edgelist</code>.
</p>
</li>
<li><p> 'history' Logical, whether the rewiring attempts should be
recorded and returned. </p>
</li>
<li><p> 'eta.obj' A convex function of
<code>eta</code> to be minimized when solving for <code>eta</code> with given
<code>target.assortcoef</code>. Defaults to 0. It will be ignored if <code>eta</code>
is provided. </p>
</li>
<li><p> 'cvxr_control' A list of parameters passed to
<code>CVXR::solve()</code> for solving <code>eta</code> with given
<code>target.assortcoef</code>. It will be ignored if <code>eta</code> is provided.</p>
</li></ul>
</td></tr>
<tr><td><code id="dprewire_+3A_eta">eta</code></td>
<td>
<p>A matrix represents the target network structure. If specified,
<code>target.assortcoef</code> will be ignored. For directed networks, the
element at row &quot;i-j&quot; and column &quot;k-l&quot; represents the proportion of directed
edges linking a source node with out-degree i and in-degree j to a target
node with out-degree k and in-degree l. For undirected networks, <code>eta</code>
is symmetric, the summation of the elements at row &quot;i&quot;, column &quot;j&quot; and row
&quot;j&quot;, column &quot;i&quot; represents the proportion of edges linking to a node with
degree i and a node with degree j.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm first solves for an appropriate <code>eta</code> using
<code>target.assortcoef</code>, <code>eta.obj</code>, and <code>cvxr_control</code>, then
proceeds to the rewiring process and rewire the network towards the solved
<code>eta</code>. If <code>eta</code> is given, the algorithm will skip the first step.
This function only works for unweighted networks.
</p>
<p>Each rewiring attempt samples two rows from <code>edgelist</code>, for instance
Edge 1:(v_1, v_2) and Edge 2:(v_3, v_4). For directed networks, if the
rewiring attempt is accepted, the sampled edges are rewired as (v_1, v_4),
(v_3, v_2); for undirected networks, the algorithm try to rewire the sampled
edges as {v_1, v_4}, {v_3, v_2} (type 1) or {v_1, v_3}, {v_2, v_4}
(type 2), each with probability 1/2.
</p>


<h3>Value</h3>

<p>Rewired network; assortativity coefficient(s) after each iteration;
rewiring history (including the index of sampled edges and rewiring result)
and solver results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
netwk1 &lt;- rpanet(1e4, control = rpa_control_scenario(
  alpha = 0.4, beta = 0.3, gamma = 0.3
))
## rewire a directed network
target.assortcoef &lt;- list("outout" = -0.2, "outin" = 0.2)
ret1 &lt;- dprewire(
  netwk = netwk1,
  target.assortcoef = target.assortcoef,
  control = list(iteration = 200)
)
plot(ret1$assortcoef$Iteration, ret1$assortcoef$"outout")
plot(ret1$assortcoef$Iteration, ret1$assortcoef$"outin")

## rewire an undirected network
netwk2 &lt;- rpanet(1e4,
  control = rpa_control_scenario(
    alpha = 0.3, beta = 0.1, gamma = 0.3, xi = 0.3
  ),
  initial.network = list(
    directed = FALSE)
)
ret2 &lt;- dprewire(
  netwk = netwk2,
  target.assortcoef = 0.3,
  control = list(
    iteration = 300, eta.obj = CVXR::norm2,
    history = TRUE
  )
)
plot(ret2$assortcoef$Iteration, ret2$assortcoef$Value)


</code></pre>

<hr>
<h2 id='dprewire_directed'>Degree preserving rewiring for directed networks</h2><span id='topic+dprewire_directed'></span>

<h3>Description</h3>

<p>Degree preserving rewiring towards the target structure <code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire_directed(
  edgelist,
  eta,
  iteration = 200,
  nattempts,
  rewire.history = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire_directed_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix, each row represents a directed edge from
the first column to the second column.</p>
</td></tr>
<tr><td><code id="dprewire_directed_+3A_eta">eta</code></td>
<td>
<p>A matrix generated by <code>wdnet::get_eta_directed()</code>.</p>
</td></tr>
<tr><td><code id="dprewire_directed_+3A_iteration">iteration</code></td>
<td>
<p>An integer, the number of rewiring iterations, with each
iteration consisting of <code>nattempts</code> rewiring attempts.</p>
</td></tr>
<tr><td><code id="dprewire_directed_+3A_nattempts">nattempts</code></td>
<td>
<p>An integer, the number of rewiring attempts for each
iteration. Default value equals the number of rows in <code>edgelist</code>.</p>
</td></tr>
<tr><td><code id="dprewire_directed_+3A_rewire.history">rewire.history</code></td>
<td>
<p>Logical, whether the rewiring history should be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rewired edgelist, degree based assortativity coefficients after each
iteration, rewiring history (including the index of sampled edges and
rewiring result). For each rewiring attempt, two rows are sampled form the
edgelist, for example Edge1:(v_1, v_2) and Edge2:(v_3, v_4). If the
rewiring attempt is accepted, the sampled edges are replaced as (v_1, v_4),
(v_3, v_2).
</p>

<hr>
<h2 id='dprewire_directed_cpp'>Degree preserving rewiring process for directed networks.</h2><span id='topic+dprewire_directed_cpp'></span>

<h3>Description</h3>

<p>Degree preserving rewiring process for directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire_directed_cpp(
  iteration,
  nattempts,
  tnode,
  sout,
  sin,
  tout,
  tin,
  index_s,
  index_t,
  eta,
  rewire_history
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire_directed_cpp_+3A_iteration">iteration</code></td>
<td>
<p>Integer, number of iterations for rewiring attempts.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_nattempts">nattempts</code></td>
<td>
<p>Integer, number of rewiring attempts per iteration.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_tnode">tnode</code></td>
<td>
<p>Vector, target node sequence - 1.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_sout">sout</code></td>
<td>
<p>Vector, source nodes' out-degree.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_sin">sin</code></td>
<td>
<p>Vector, source nodes' in-degree.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_tout">tout</code></td>
<td>
<p>Vector, target nodes' out-degree.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_tin">tin</code></td>
<td>
<p>Vector, target nodes' in-degree.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_index_s">index_s</code></td>
<td>
<p>Index of source nodes' out- and in-degree. 
<code>index_s</code>/<code>index_t</code> bridges the indices of source/target nodes and the 
target structure eta.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_index_t">index_t</code></td>
<td>
<p>Index of target nodes' out- and in-degree.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_eta">eta</code></td>
<td>
<p>Matrix, target structure eta generated by
<code>wdnet::get_eta_directed()</code>.</p>
</td></tr>
<tr><td><code id="dprewire_directed_cpp_+3A_rewire_history">rewire_history</code></td>
<td>
<p>Logical, whether the rewiring history should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns target node sequence, four directed assortativity coefficients after each iteration, and rewire history.
</p>

<hr>
<h2 id='dprewire_undirected'>Degree preserving rewiring for undirected networks</h2><span id='topic+dprewire_undirected'></span>

<h3>Description</h3>

<p>Degree preserving rewiring towards the target structure <code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire_undirected(
  edgelist,
  eta,
  iteration = 200,
  nattempts,
  rewire.history = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire_undirected_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix, each row represents an undirected edge.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_+3A_eta">eta</code></td>
<td>
<p>A matrix generated by <code>wdnet::get_eta_undirected()</code>.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_+3A_iteration">iteration</code></td>
<td>
<p>An integer, number of rewiring iterations, each iteration
consists of <code>nattempts</code> rewiring attempts.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_+3A_nattempts">nattempts</code></td>
<td>
<p>An integer, number of rewiring attempts for each iteration.
The default value equals the number of rows in <code>edgelist</code>.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_+3A_rewire.history">rewire.history</code></td>
<td>
<p>Logical, whether the rewiring history should be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rewired edgelist, assortativity coefficient after each iteration, and
rewiring history (including the index of sampled edges and rewiring
result). For each rewiring attempt, two rows are sampled from the
<code>edgelist</code>, for example Edge1:{v_1, v_2} and Edge2:{v_3, v_4}, the
function try to rewire the sampled edges as {v_1, v_4}, {v_3, v_2}
(rewire type 1) or {v_1, v_3}, {v_2, v_4} (rewire type 2) with
probability 1/2.
</p>

<hr>
<h2 id='dprewire_undirected_cpp'>Degree preserving rewiring process for undirected networks.</h2><span id='topic+dprewire_undirected_cpp'></span>

<h3>Description</h3>

<p>Degree preserving rewiring process for undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire_undirected_cpp(
  iteration,
  nattempts,
  node1,
  node2,
  degree1,
  degree2,
  index1,
  index2,
  e,
  rewire_history
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire_undirected_cpp_+3A_iteration">iteration</code></td>
<td>
<p>Integer, number of iterations for rewiring attempts.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_nattempts">nattempts</code></td>
<td>
<p>Integer, number of rewiring attempts per iteration.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_node1">node1</code></td>
<td>
<p>Vector, first column of edgelist.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_node2">node2</code></td>
<td>
<p>Vector, second column of edgelist.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_degree1">degree1</code></td>
<td>
<p>Vector, degree of node1 and node2.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_degree2">degree2</code></td>
<td>
<p>Vector, degree of node2 and node1. degree1 
and degree2 are used to calculate assortativity coefficient,
i.e., degree correlation.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_index1">index1</code></td>
<td>
<p>Index of the first column of edgelist. 
<code>index1</code> and <code>index2</code> bridge the nodes' degree and the 
structure <code>e</code>.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_index2">index2</code></td>
<td>
<p>Index of the second column of edgelist.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_e">e</code></td>
<td>
<p>Matrix, target structure (eta) generated by
<code>wdnet::get_eta_undirected()</code>.</p>
</td></tr>
<tr><td><code id="dprewire_undirected_cpp_+3A_rewire_history">rewire_history</code></td>
<td>
<p>Logical, whether the rewiring history should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns node sequences, assortativity coefficient after each iteration, and rewiring history.
</p>

<hr>
<h2 id='dprewire.range'>Range of assortativity coefficients.</h2><span id='topic+dprewire.range'></span>

<h3>Description</h3>

<p>The assortativity coefficient of a given network may not reach all the values
between -1 and 1 via degree preserving rewiring. This function calculates the
range of assortativity coefficients achievable through degree preserving
rewiring. The algorithm is designed for unweighted networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprewire.range(
  netwk,
  edgelist,
  adj,
  directed,
  which.range = c("outout", "outin", "inout", "inin"),
  control = cvxr_control(),
  target.assortcoef = list(outout = NULL, outin = NULL, inout = NULL, inin = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprewire.range_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object representing an unweighted network. If
<code>NULL</code>, the function will construct a network using either
<code>edgelist</code> or <code>adj</code>.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix, where each row represents an edge of the
network.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix of an unweighted network.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed or not. It will be
ignored if <code>netwk</code> is provided.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_which.range">which.range</code></td>
<td>
<p>The type of interested assortativity coefficient. For
directed networks, it takes one of the values: &quot;outout&quot;, &quot;outin&quot;, &quot;inout&quot;
and &quot;inin&quot;. It will be ignored if the network is undirected.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_control">control</code></td>
<td>
<p>A list of parameters passed to <code>CVXR::solve()</code> for
solving an appropriate <code>eta</code>, given the constraints
<code>target.assortcoef</code>.</p>
</td></tr>
<tr><td><code id="dprewire.range_+3A_target.assortcoef">target.assortcoef</code></td>
<td>
<p>A list of constraints, it contains the predetermined
value or range imposed on assortativity coefficients other than
<code>which.range</code>. It will be ignored if the network is undirected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranges are computed using convex optimization. The optimization problems
are defined and solved via the <code>R</code> package <code>CVXR</code>. For undirected
networks, the function returns the range of the assortativity coefficient.
For directed networks, the function computes the range of <code>which.range</code>
while other assortativity coefficients are restricted through
<code>target.assortcoef</code>.
</p>


<h3>Value</h3>

<p>Returns the range of the selected assortativity coefficient and the
results from the solver.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
netwk &lt;- rpanet(5e3,
  control =
    rpa_control_scenario(alpha = 0.5, beta = 0.5)
)
ret1 &lt;- dprewire.range(
  netwk = netwk, which.range = "outin",
  target.assortcoef = list("outout" = c(-0.3, 0.3), "inout" = 0.1)
)
ret1$range


</code></pre>

<hr>
<h2 id='dw_assort'>Compute the assortativity coefficient of a weighted and directed network.</h2><span id='topic+dw_assort'></span>

<h3>Description</h3>

<p>Compute the assortativity coefficient of a weighted and directed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw_assort(adj, type = c("outin", "inin", "outout", "inout"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw_assort_+3A_adj">adj</code></td>
<td>
<p>is an adjacency matrix of a weighted and directed network.</p>
</td></tr>
<tr><td><code id="dw_assort_+3A_type">type</code></td>
<td>
<p>which type of assortativity coefficient to compute: &quot;outin&quot;
(default), &quot;inin&quot;, &quot;outout&quot; or &quot;inout&quot;?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar of assortativity coefficient
</p>


<h3>Note</h3>

<p>When the adjacency matrix is binary (i.e., directed but unweighted
networks), <code>dw_assort</code> returns the assortativity coefficient proposed
in Foster et al. (2010).
</p>


<h3>References</h3>

 <ul>
<li><p> Foster, J.G., Foster, D.V., Grassberger, P. and
Paczuski, M. (2010). Edge direction and the structure of networks.
<em>Proceedings of the National Academy of Sciences of the United
States</em>, 107(24), 10815&ndash;10820. </p>
</li>
<li><p> Yuan, Y. Zhang, P. and Yan, J.
(2021).
Assortativity coefficients for weighted and directed networks. <em>Journal
of Complex Networks</em>, 9(2), cnab017. </p>
</li></ul>


<hr>
<h2 id='dw_feature_assort'>Feature based assortativity coefficient</h2><span id='topic+dw_feature_assort'></span>

<h3>Description</h3>

<p>Node feature based assortativity coefficients for weighted and directed
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw_feature_assort(netwk, f1, f2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw_feature_assort_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object that represents the network.</p>
</td></tr>
<tr><td><code id="dw_feature_assort_+3A_f1">f1</code></td>
<td>
<p>A vector, represents the first feature of existing nodes. Number of
nodes <code>= length(f1) = length(f2)</code>. Defined for directed networks. If
<code>NULL</code>, out-strength will be used.</p>
</td></tr>
<tr><td><code id="dw_feature_assort_+3A_f2">f2</code></td>
<td>
<p>A vector, represents the second feature of existing nodes. Defined
for directed networks. If <code>NULL</code>, in-strength will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Directed weighted assortativity coefficients between source nodes'
<code>f1</code> (or <code>f2</code>) and target nodes' <code>f2</code>(or <code>f1</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
adj &lt;- matrix(rbinom(400, 1, 0.2) * sample(1:3, 400, replace = TRUE), 20, 20)
f1 &lt;- runif(20)
f2 &lt;- abs(rnorm(20))
ret &lt;- assortcoef(adj = adj, f1 = f1, f2 = f2)

</code></pre>

<hr>
<h2 id='edgelist_to_adj'>Convert edgelist and edgeweight to adjacency matrix.</h2><span id='topic+edgelist_to_adj'></span>

<h3>Description</h3>

<p>Convert edgelist and edgeweight to adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_to_adj(edgelist, edgeweight, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist_to_adj_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix representing edges.</p>
</td></tr>
<tr><td><code id="edgelist_to_adj_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A vector representing the weight of edges. If <code>NULL</code>,
all edges are considered to have a weight of 1.</p>
</td></tr>
<tr><td><code id="edgelist_to_adj_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix.
</p>

<hr>
<h2 id='edgelist_to_wdnet'>Creates a <code>wdnet</code> object using <code>edgelist</code>.</h2><span id='topic+edgelist_to_wdnet'></span>

<h3>Description</h3>

<p>Creates a <code>wdnet</code> object using <code>edgelist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_to_wdnet(edgelist, edgeweight, directed, nodegroup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist_to_wdnet_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing the edges.</p>
</td></tr>
<tr><td><code id="edgelist_to_wdnet_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A numeric vector of edge weights with the same length as
the number of rows in edgelist. If <code>NULL</code>, all edges will be assigned
weight 1.</p>
</td></tr>
<tr><td><code id="edgelist_to_wdnet_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed (TRUE) or undirected
(FALSE).</p>
</td></tr>
<tr><td><code id="edgelist_to_wdnet_+3A_nodegroup">nodegroup</code></td>
<td>
<p>A numeric vector of node groups.</p>
</td></tr>
<tr><td><code id="edgelist_to_wdnet_+3A_...">...</code></td>
<td>
<p>Additional components to be added to the <code>wdnet</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wdnet</code> object with the specified <code>edgelist</code>,
<code>edgeweight</code> and <code>directed</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edgelist &lt;- matrix(c(1, 2, 2, 3, 3, 1), ncol = 2, byrow = TRUE)
edgeweight &lt;- c(1, 2, 3)
nodegroup &lt;- c(1, 1, 2)
netwk &lt;- edgelist_to_wdnet(
  edgelist = edgelist,
  edgeweight = edgeweight,
  directed = TRUE,
  nodegroup = nodegroup
)

</code></pre>

<hr>
<h2 id='fill_weight_cpp'>Fill edgeweight into the adjacency matrix.
Defined for function <code>edgelist_to_adj</code>.</h2><span id='topic+fill_weight_cpp'></span>

<h3>Description</h3>

<p>Fill edgeweight into the adjacency matrix.
Defined for function <code>edgelist_to_adj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_weight_cpp(adj, edgelist, edgeweight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_weight_cpp_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
<tr><td><code id="fill_weight_cpp_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix represents the edgelist.</p>
</td></tr>
<tr><td><code id="fill_weight_cpp_+3A_edgeweight">edgeweight</code></td>
<td>
<p>A vector represents the weight of edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency matrix with edge weight.
</p>

<hr>
<h2 id='find_node_cpp'>Fill missing nodes in the node sequence. Defined for <code>wdnet::rpanet</code>.</h2><span id='topic+find_node_cpp'></span>

<h3>Description</h3>

<p>Fill missing nodes in the node sequence. Defined for <code>wdnet::rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_node_cpp(nodes, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_node_cpp_+3A_nodes">nodes</code></td>
<td>
<p>Source/target nodes, missing nodes are denoted as 0.</p>
</td></tr>
<tr><td><code id="find_node_cpp_+3A_edges">edges</code></td>
<td>
<p>Sampled edges according to preferential attachment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Source/target nodes.
</p>

<hr>
<h2 id='find_node_undirected_cpp'>Fill missing values in node sequence. Defined for <code>wdnet::rpanet</code>.</h2><span id='topic+find_node_undirected_cpp'></span>

<h3>Description</h3>

<p>Fill missing values in node sequence. Defined for <code>wdnet::rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_node_undirected_cpp(node1, node2, start_edge, end_edge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_node_undirected_cpp_+3A_node1">node1</code></td>
<td>
<p>Nodes in the first column of edgelist, i.e., <code>edgelist[, 1]</code>.</p>
</td></tr>
<tr><td><code id="find_node_undirected_cpp_+3A_node2">node2</code></td>
<td>
<p>Nodes in the second column of edgelist, i.e., <code>edgelist[, 2]</code>.</p>
</td></tr>
<tr><td><code id="find_node_undirected_cpp_+3A_start_edge">start_edge</code></td>
<td>
<p>Index of sampled edges, corresponds to the missing nodes in node1 and node2.</p>
</td></tr>
<tr><td><code id="find_node_undirected_cpp_+3A_end_edge">end_edge</code></td>
<td>
<p>Index of sampled edges, corresponds to the missing nodes in node1 and node2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Node sequence.
</p>

<hr>
<h2 id='get_constr'>Get the constraints for the optimization problem. This function is defined
for <code>get_eta_directed()</code>.</h2><span id='topic+get_constr'></span>

<h3>Description</h3>

<p>Get the constraints for the optimization problem. This function is defined
for <code>get_eta_directed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_constr(constrs, target.assortcoef, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_constr_+3A_constrs">constrs</code></td>
<td>
<p>A list of constraints.</p>
</td></tr>
<tr><td><code id="get_constr_+3A_target.assortcoef">target.assortcoef</code></td>
<td>
<p>A list of target assortativity levels.</p>
</td></tr>
<tr><td><code id="get_constr_+3A_rho">rho</code></td>
<td>
<p>A list of variable objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of updated constraints.
</p>

<hr>
<h2 id='get_dist'>Get the node-level joint distributions and some empirical distributions with
given edgelist.</h2><span id='topic+get_dist'></span>

<h3>Description</h3>

<p>Get the node-level joint distributions and some empirical distributions with
given edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist(edgelist, directed = TRUE, joint_dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dist_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing the directed edges of a
network.</p>
</td></tr>
<tr><td><code id="get_dist_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the network is directed.</p>
</td></tr>
<tr><td><code id="get_dist_+3A_joint_dist">joint_dist</code></td>
<td>
<p>Logical, whether to return edge-level distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distributions and degree vectors.
</p>

<hr>
<h2 id='get_eta_directed'>Compute edge-level distributions for directed networks with respect to
desired assortativity level(s).</h2><span id='topic+get_eta_directed'></span>

<h3>Description</h3>

<p>Compute edge-level distributions for directed networks with respect to
desired assortativity level(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eta_directed(
  edgelist,
  target.assortcoef = list(outout = NULL, outin = NULL, inout = NULL, inin = NULL),
  eta.obj = function(x) 0,
  which.range,
  control = cvxr_control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eta_directed_+3A_edgelist">edgelist</code></td>
<td>
<p>A two-column matrix representing the directed edges of a
network.</p>
</td></tr>
<tr><td><code id="get_eta_directed_+3A_target.assortcoef">target.assortcoef</code></td>
<td>
<p>A list representing the predetermined value or range
of assortativity coefficients.</p>
</td></tr>
<tr><td><code id="get_eta_directed_+3A_eta.obj">eta.obj</code></td>
<td>
<p>A convex function of <code>eta</code> to be minimized when
<code>which.range</code> is <code>NULL</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="get_eta_directed_+3A_which.range">which.range</code></td>
<td>
<p>Character, &quot;outout&quot;, &quot;outin&quot;, &quot;inout&quot; or &quot;inin&quot;s,
represents the interested degree based assortativity coefficient.</p>
</td></tr>
<tr><td><code id="get_eta_directed_+3A_control">control</code></td>
<td>
<p>A list of parameters passed to <code>CVXR::solve()</code> when
solving for <code>eta</code> or computing the range of assortativity coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Assortativity coefficients and joint distributions. If
<code>which.range</code> is specified, the range of the interested coefficient
and the corresponding joint distributions will be returned, provided the
predetermined <code>target.assortcoef</code> is satisfied.
</p>

<hr>
<h2 id='get_eta_undirected'>Compute edge-level distribution for undirected networks with respect to
desired assortativity level.</h2><span id='topic+get_eta_undirected'></span>

<h3>Description</h3>

<p>Compute edge-level distribution for undirected networks with respect to
desired assortativity level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eta_undirected(
  edgelist,
  target.assortcoef = NULL,
  eta.obj = function(x) 0,
  control = cvxr_control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eta_undirected_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix representing the undirected edges of a
network.</p>
</td></tr>
<tr><td><code id="get_eta_undirected_+3A_target.assortcoef">target.assortcoef</code></td>
<td>
<p>Numeric, represents the predetermined assortativity
coefficient. If <code>NULL</code>, the range of assortativity coefficient and
corresponding joint distribution are returned.</p>
</td></tr>
<tr><td><code id="get_eta_undirected_+3A_eta.obj">eta.obj</code></td>
<td>
<p>A convex function of <code>eta</code> to be minimized when
<code>target.assortcoef</code> is not <code>NULL</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="get_eta_undirected_+3A_control">control</code></td>
<td>
<p>A list of parameters passed to <code>CVXR::solve()</code> when
solving for <code>eta</code> or computing the range of assortativity coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Assortativity level and corresponding edge-level distribution.
</p>

<hr>
<h2 id='get_values'>Get the value of an object from the optimization problem. This function is
defined for <code>get_eta_directed()</code>.</h2><span id='topic+get_values'></span>

<h3>Description</h3>

<p>Get the value of an object from the optimization problem. This function is
defined for <code>get_eta_directed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_values(object, result, mydist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_values_+3A_object">object</code></td>
<td>
<p>An object from the optimization problem.</p>
</td></tr>
<tr><td><code id="get_values_+3A_result">result</code></td>
<td>
<p>A list returned from <code>CVXR::solve()</code>.</p>
</td></tr>
<tr><td><code id="get_values_+3A_mydist">mydist</code></td>
<td>
<p>A list returned from <code>get_dist()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the object.
</p>

<hr>
<h2 id='igraph_to_wdnet'>Converts an <code>igraph</code> object to a <code>wdnet</code> object</h2><span id='topic+igraph_to_wdnet'></span>

<h3>Description</h3>

<p>Converts an <code>igraph</code> object to a <code>wdnet</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_to_wdnet(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_to_wdnet_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wdnet</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::sample_pa(50)
netwk &lt;- igraph_to_wdnet(g)

</code></pre>

<hr>
<h2 id='is_rpacontrol'>Checks whether the input is a <code>rpacontrol</code> object</h2><span id='topic+is_rpacontrol'></span>

<h3>Description</h3>

<p>Checks whether the input is a <code>rpacontrol</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rpacontrol(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rpacontrol_+3A_control">control</code></td>
<td>
<p>A <code>rpacontrol</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if the input is a <code>rpacontrol</code> object.
</p>

<hr>
<h2 id='is_wdnet'>Checks if the input is a <code>wdnet</code> object</h2><span id='topic+is_wdnet'></span>

<h3>Description</h3>

<p>Checks if the input is a <code>wdnet</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_wdnet(netwk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_wdnet_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if argument netwk is a <code>wdnet</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>netwk &lt;- rpanet(nstep = 1e3)
is_wdnet(netwk)

</code></pre>

<hr>
<h2 id='node_strength_cpp'>Aggregate edgeweight into nodes' strength.</h2><span id='topic+node_strength_cpp'></span>

<h3>Description</h3>

<p>Aggregate edgeweight into nodes' strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_strength_cpp(snode, tnode, weight, nnode, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_strength_cpp_+3A_snode">snode</code></td>
<td>
<p>Source nodes.</p>
</td></tr>
<tr><td><code id="node_strength_cpp_+3A_tnode">tnode</code></td>
<td>
<p>Target nodes.</p>
</td></tr>
<tr><td><code id="node_strength_cpp_+3A_weight">weight</code></td>
<td>
<p>Edgeweight.</p>
</td></tr>
<tr><td><code id="node_strength_cpp_+3A_nnode">nnode</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="node_strength_cpp_+3A_weighted">weighted</code></td>
<td>
<p>Logical, true if the edges are weighted, 
false if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Out-strength and in-strength.
</p>

<hr>
<h2 id='plot.wdnet'>Plots the input network</h2><span id='topic+plot.wdnet'></span>

<h3>Description</h3>

<p>Plots the input network via <code>igraph::plot.igraph()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wdnet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wdnet_+3A_x">x</code></td>
<td>
<p>A <code>wdnet</code> object.</p>
</td></tr>
<tr><td><code id="plot.wdnet_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>igraph::plot.igraph()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='print_control_details'>Prints <code>rpacontrol</code> in terminal</h2><span id='topic+print_control_details'></span>

<h3>Description</h3>

<p>Prints <code>rpacontrol</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_details(x, control_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_details_+3A_x">x</code></td>
<td>
<p>An object of class <code>rpacontrol</code>.</p>
</td></tr>
<tr><td><code id="print_control_details_+3A_control_name">control_name</code></td>
<td>
<p>A string, the name of the control component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print_control_edgeweight'>Prints <code>rpa_control_edgeweight()</code> in terminal</h2><span id='topic+print_control_edgeweight'></span>

<h3>Description</h3>

<p>Prints <code>rpa_control_edgeweight()</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_edgeweight(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_edgeweight_+3A_control">control</code></td>
<td>
<p>A list of control parameters for
<code>rpa_control_edgeweight()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print_control_newedge'>Prints <code>rpa_control_newedge()</code> in terminal</h2><span id='topic+print_control_newedge'></span>

<h3>Description</h3>

<p>Prints <code>rpa_control_newedge()</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_newedge(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_newedge_+3A_control">control</code></td>
<td>
<p>A list of control parameters for
<code>rpa_control_newedge()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print_control_preference'>Prints <code>rpa_control_preference()</code> in terminal</h2><span id='topic+print_control_preference'></span>

<h3>Description</h3>

<p>Prints <code>rpa_control_preference()</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_preference(control, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_preference_+3A_control">control</code></td>
<td>
<p>A list of control parameters for
<code>rpa_control_preference()</code>.</p>
</td></tr>
<tr><td><code id="print_control_preference_+3A_directed">directed</code></td>
<td>
<p>Logical, whether to print preference functions for directed
networks only. If missing, print preference functions for both directed
and undirected networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print_control_reciprocal'>Prints <code>rpa_control_reciprocal()</code> in terminal</h2><span id='topic+print_control_reciprocal'></span>

<h3>Description</h3>

<p>Prints <code>rpa_control_reciprocal()</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_reciprocal(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_reciprocal_+3A_control">control</code></td>
<td>
<p>A list of control parameters for
<code>rpa_control_reciprocal()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print_control_scenario'>Prints <code>rpa_control_scenario()</code> in terminal</h2><span id='topic+print_control_scenario'></span>

<h3>Description</h3>

<p>Prints <code>rpa_control_scenario()</code> in terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_control_scenario(control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_control_scenario_+3A_control">control</code></td>
<td>
<p>A list of control parameters for
<code>rpa_control_scenario()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='print.rpacontrol'>Prints <code>rpacontrol</code> objects</h2><span id='topic+print.rpacontrol'></span><span id='topic+summary.rpacontrol'></span>

<h3>Description</h3>

<p>These functions print <code>rpacontrol</code> objects in the terminal.
<code>print.rpacontrol()</code> shows only the current controls, whereas
<code>summary.rpacontrol()</code> includes both specified controls and the
unspecified controls that use default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpacontrol'
print(x, ...)

## S3 method for class 'rpacontrol'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rpacontrol_+3A_x">x</code></td>
<td>
<p>An object of class <code>rpacontrol</code>.</p>
</td></tr>
<tr><td><code id="print.rpacontrol_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="print.rpacontrol_+3A_object">object</code></td>
<td>
<p>An object of class <code>rpacontrol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the controls invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
control &lt;- rpa_control_scenario()
print(control)

</code></pre>

<hr>
<h2 id='print.wdnet'>Prints the input network</h2><span id='topic+print.wdnet'></span><span id='topic+summary.wdnet'></span>

<h3>Description</h3>

<p>These functions print a network to the terminal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wdnet'
print(x, node.attrs = TRUE, edge.attrs = TRUE, max.lines = 5, ...)

## S3 method for class 'wdnet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wdnet_+3A_x">x</code></td>
<td>
<p>A <code>wdnet</code> object.</p>
</td></tr>
<tr><td><code id="print.wdnet_+3A_node.attrs">node.attrs</code></td>
<td>
<p>Logical, whether to print node attributes, if available.</p>
</td></tr>
<tr><td><code id="print.wdnet_+3A_edge.attrs">edge.attrs</code></td>
<td>
<p>Logical, whether to print edge attributes, if available.</p>
</td></tr>
<tr><td><code id="print.wdnet_+3A_max.lines">max.lines</code></td>
<td>
<p>Integer, the maximum number of lines of edgelist and node
attributes to print. The rest of the output will be truncated.</p>
</td></tr>
<tr><td><code id="print.wdnet_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="print.wdnet_+3A_object">object</code></td>
<td>
<p>The graph of which the summary will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.wdnet</code> prints the number of nodes and edges, preference
functions, and whether the network is directed, weighted. <code>print.wdnet</code>
prints the same information, and also lists some edges and node attributes,
if available. Edge scenarios are 0: from initial network; 1: <code>alpha</code>; 2:
<code>beta</code>; 3: <code>gamma</code>; 4: <code>xi</code>; 5; <code>rho</code>; 6: reciprocal.
</p>

<hr>
<h2 id='rpa_control_default'>Default controls for <code>rpanet</code></h2><span id='topic+rpa_control_default'></span>

<h3>Description</h3>

<p>Default controls for <code>rpanet</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_default()
</code></pre>


<h3>Value</h3>

<p>Returns a list of default controls.
</p>

<hr>
<h2 id='rpa_control_edgeweight'>Control weight of new edges. Defined for <code>rpanet</code>.</h2><span id='topic+rpa_control_edgeweight'></span>

<h3>Description</h3>

<p>Control weight of new edges. Defined for <code>rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_edgeweight(sampler = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpa_control_edgeweight_+3A_sampler">sampler</code></td>
<td>
<p>A function used for sampling edge weights. If <code>NULL</code>, all
new edges will default to a weight of 1. If a function is provided, it must
accept a single argument, <code>n</code>, and return a vector of length <code>n</code>
that represents the sampled edge weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> containing the <code>sampler</code>
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample edge weights from Gamma(5, 0.2).
my_gamma &lt;- function(n) rgamma(n, shape = 5, scale = 0.2)
control &lt;- rpa_control_edgeweight(
  sampler = my_gamma
)

</code></pre>

<hr>
<h2 id='rpa_control_newedge'>Control new edges in each step. Defined for <code>rpanet</code>.</h2><span id='topic+rpa_control_newedge'></span>

<h3>Description</h3>

<p>Control new edges in each step. Defined for <code>rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_newedge(
  sampler = NULL,
  snode.replace = TRUE,
  tnode.replace = TRUE,
  node.replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpa_control_newedge_+3A_sampler">sampler</code></td>
<td>
<p>A function used for sampling the number of new edges to be
added at each step. If <code>NULL</code>, one new edge will be added at each
step. If a function is provided, it must accept a single argument,
<code>n</code>, and return a vector of length <code>n</code> that represents the
sampled number of new edges.</p>
</td></tr>
<tr><td><code id="rpa_control_newedge_+3A_snode.replace">snode.replace</code></td>
<td>
<p>Logical. Determines whether the source nodes in the same
step should be sampled with replacement. Defined for directed networks.</p>
</td></tr>
<tr><td><code id="rpa_control_newedge_+3A_tnode.replace">tnode.replace</code></td>
<td>
<p>Logical. Determines whether the target nodes in the same
step should be sampled with replacement. Defined for directed networks.</p>
</td></tr>
<tr><td><code id="rpa_control_newedge_+3A_node.replace">node.replace</code></td>
<td>
<p>Logical. Determines whether the nodes in the same step
should be sampled with replacement. Defined for undirected networks. If
FALSE, self-loops will not be allowed under beta scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> with components <code>sampler</code>,
<code>snode.replace</code>, <code>tnode.replace</code> and <code>node.replace</code> with
meanings as explained under 'Arguments'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_rpois &lt;- function(n) rpois(n, lambda = 2) + 1
control &lt;- rpa_control_newedge(
  sampler = my_rpois,
  node.replace = FALSE
)
</code></pre>

<hr>
<h2 id='rpa_control_preference'>Set preference function(s). Defined for <code>rpanet</code>.</h2><span id='topic+rpa_control_preference'></span>

<h3>Description</h3>

<p>Set preference function(s). Defined for <code>rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_preference(
  ftype = c("default", "customized"),
  sparams = c(1, 1, 0, 0, 1),
  tparams = c(0, 0, 1, 1, 1),
  params = c(1, 1),
  spref = "outs + 1",
  tpref = "ins + 1",
  pref = "s + 1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpa_control_preference_+3A_ftype">ftype</code></td>
<td>
<p>Preference function type. Either &quot;default&quot; or &quot;customized&quot;.
&quot;customized&quot; preference functions require &quot;binary&quot; or &quot;linear&quot; generation
methods. If using default preference functions, <code>sparams</code>,
<code>tparams</code> and <code>params</code> must be specified. If using customized
preference functions, <code>spref</code>, <code>tpref</code> and <code>pref</code> must be
specified.</p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_sparams">sparams</code></td>
<td>
<p>A numerical vector of length 5 giving the parameters of the
default source preference function. Defined for directed networks.
Probability of choosing an existing node as the source node is proportional
to <code>sparams[1] * out-strength^sparams[2] + sparams[3] *
in-strength^sparams[4] + sparams[5]</code>.</p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_tparams">tparams</code></td>
<td>
<p>A numerical vector of length 5 giving the parameters of the
default target preference function. Defined for directed networks.
Probability of choosing an existing node as the target node is proportional
to <code>tparams[1] * out-strength^tparams[2] + tparams[3] *
in-strength^tparams[4] + tparams[5]</code>.</p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_params">params</code></td>
<td>
<p>A numerical vector of length 2 giving the parameters of the
default preference function. Defined for undirected networks. Probability
of choosing an existing node is proportional to <code>strength^params[1] +
params[2].</code></p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_spref">spref</code></td>
<td>
<p>Character expression or an object of class <code>XPtr</code> giving
the customized source preference function. Defined for directed networks.
Default value is <code>"outs + 1"</code>, i.e., node out-strength + 1. See
Details and Examples for more information.</p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_tpref">tpref</code></td>
<td>
<p>Character expression or an object of class <code>XPtr</code> giving
the customized target preference function. Defined for directed networks.
Default value is <code>"ins + 1"</code>, i.e., node in-strength + 1.</p>
</td></tr>
<tr><td><code id="rpa_control_preference_+3A_pref">pref</code></td>
<td>
<p>Character expression or an object of class <code>XPtr</code> giving the
customized preference function. Defined for undirected networks. Default
value is <code>"s + 1"</code>, i.e, node strength + 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If choosing customized preference functions, <code>spref</code>,
<code>tpref</code> and <code>pref</code> will be used and the network generation method
must be &quot;binary&quot; or &quot;linear&quot;. <code>spref</code> (<code>tpref</code>) defines the
source (target) preference function, it can be a character expression or an
object of class <code>XPtr</code>. </p>
 <ul>
<li><p> Character expression; it
must be a one-line <code>C++</code> style expression of <code>outs</code>
(node out-strength) and
<code>ins</code> (node in-strength). For example, <code>"pow(outs, 2) + 1"</code>,
<code>"pow(outs, 2) + pow(ins, 2) + 1"</code>, etc. The expression will be used
to define an <code>XPtr</code> via <code>RcppXPtrUtils::cppXPtr</code>. The <code>XPtr</code>
will be passed to the network generation function. The expression must not
have variables other than <code>outs</code> and <code>ins</code>. </p>
</li>
<li><p> 'XPtr' an 
external pointer wrapped in an object of class <code>XPtr</code> defined via
<code>RcppXPtrUtils::cppXPtr</code>. An example for defining an <code>XPtr</code> with
<code>C++</code> source code is included in Examples. For more information
about passing function pointers, see
<a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers-rcppxptrutils/">https://gallery.rcpp.org/articles/passing-cpp-function-pointers-rcppxptrutils/</a>.
Please note the supplied <code>C++</code> function accepts two <code>double</code>
arguments and returns a <code>double</code>. The first and second arguments
represent node out- and in-strength, respectively. Note that the <code>XPtr</code> will
be invalid and cannot be used to control network generation
in another separate R session. Therefore, we recommend preserving the source code of your
preference function for future use.</p>
</li></ul>

<p><code>pref</code> is defined analogously. If using character expression, it must
be a one-line <code>C++</code> style expression of <code>s</code> (node strength). If
using <code>XPtr</code>, the supplied <code>C++</code> function accepts only one
<code>double</code> argument and returns a <code>double</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> with components <code>ftype</code>,
<code>sparams</code>, <code>tparams</code>, <code>params</code> or <code>ftype</code>,
<code>spref</code>, <code>tpref</code>, <code>pref</code> with function pointers
<code>spref.pointer</code>, <code>tpref.pointer</code>, <code>pref.pointer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set source preference as out-strength^2 + in-strength + 1,
# target preference as out-strength + in-strength^2 + 1.
# 1. use default preference functions
ctr1 &lt;- rpa_control_preference(
  ftype = "default",
  sparams = c(1, 2, 1, 1, 1), tparams = c(1, 1, 1, 2, 1)
)
# 2. use character expressions
ctr2 &lt;- rpa_control_preference(
  ftype = "customized",
  spref = "pow(outs, 2) + ins + 1", tpref = "outs + pow(ins, 2) + 1"
)
# 3. define XPtr's with C++ source code
spref.pointer &lt;- RcppXPtrUtils::cppXPtr(
  code =
    "double spref(double outs, double ins) {return pow(outs, 2) + ins + 1;}"
)
tpref.pointer &lt;- RcppXPtrUtils::cppXPtr(
  code =
    "double tpref(double outs, double ins) {return outs + pow(ins, 2) + 1;}"
)
ctr3 &lt;- rpa_control_preference(
  ftype = "customized",
  spref = spref.pointer,
  tpref = tpref.pointer
)
ret &lt;- rpanet(1e5, control = ctr3)

</code></pre>

<hr>
<h2 id='rpa_control_reciprocal'>Control reciprocal edges. Defined for <code>rpanet</code>.</h2><span id='topic+rpa_control_reciprocal'></span>

<h3>Description</h3>

<p>Control reciprocal edges. Defined for <code>rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_reciprocal(
  group.prob = NULL,
  recip.prob = NULL,
  selfloop.recip = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpa_control_reciprocal_+3A_group.prob">group.prob</code></td>
<td>
<p>A vector of probability weights for sampling the group of
new nodes. Defined for directed networks. Groups are from 1 to
<code>length(group.prob)</code>. Its length must equal to the number of rows of
<code>recip.prob</code>.</p>
</td></tr>
<tr><td><code id="rpa_control_reciprocal_+3A_recip.prob">recip.prob</code></td>
<td>
<p>A square matrix giving the probability of adding a
reciprocal edge after a new edge is introduced. Defined for directed
networks. Its element <code>p_{ij}</code> represents the probability of adding a
reciprocal edge from node <code>A</code>, which belongs to group <code>i</code>, to
node <code>B</code>, which belongs to group <code>j</code>, immediately after a
directed edge from <code>B</code> to <code>A</code> is added.</p>
</td></tr>
<tr><td><code id="rpa_control_reciprocal_+3A_selfloop.recip">selfloop.recip</code></td>
<td>
<p>Logical, whether reciprocal edge of self-loops are
allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> with components <code>group.prob</code>,
<code>recip.prob</code>, and <code>selfloop.recip</code> with meanings as explained
under 'Arguments'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- rpa_control_reciprocal(
  group.prob = c(0.4, 0.6),
  recip.prob = matrix(runif(4), ncol = 2)
)
</code></pre>

<hr>
<h2 id='rpa_control_scenario'>Control edge scenarios. Defined for <code>rpanet</code>.</h2><span id='topic+rpa_control_scenario'></span>

<h3>Description</h3>

<p>Control edge scenarios. Defined for <code>rpanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpa_control_scenario(
  alpha = 1,
  beta = 0,
  gamma = 0,
  xi = 0,
  rho = 0,
  beta.loop = TRUE,
  source.first = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpa_control_scenario_+3A_alpha">alpha</code></td>
<td>
<p>Probability of adding an edge from a new node to an existing
node.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_beta">beta</code></td>
<td>
<p>Probability of adding an edge between existing nodes.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_gamma">gamma</code></td>
<td>
<p>Probability of adding an edge from an existing node to a new
node.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_xi">xi</code></td>
<td>
<p>Probability of adding an edge between two new nodes.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_rho">rho</code></td>
<td>
<p>Probability of adding a new node with a self-loop.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_beta.loop">beta.loop</code></td>
<td>
<p>Logical. Determines whether self-loops are allowed under the
beta scenario. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rpa_control_scenario_+3A_source.first">source.first</code></td>
<td>
<p>Logical. Defined for <code>beta</code> scenario edges of
directed networks. If <code>TRUE</code>, the source node of a new edge is sampled
from existing nodes before the target node is sampled; if <code>FALSE</code>, the
target node is sampled from existing nodes before the source node is
sampled. Default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>rpacontrol</code> with components <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>xi</code>, <code>rho</code>, <code>beta.loop</code> and
<code>source.first</code> with meanings as explained under 'Arguments'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- rpa_control_scenario(alpha = 0.5, beta = 0.5, beta.loop = FALSE)

</code></pre>

<hr>
<h2 id='rpacontrol'>rpacontrol: Controls the Preferential Attachment (PA) Network Generation
Process</h2><span id='topic+rpacontrol'></span>

<h3>Description</h3>

<p>The <code>rpacontrol</code> object is designed to control the Preferential
Attachment (PA) network generation process within the <code>rpanet()</code>
function. It can have the following components:
</p>

<ul>
<li> <p><code>scenario</code>: controls the edge scenarios
at each step. For more information, please refer to
<code>rpa_control_scenario()</code>.
</p>
</li>
<li> <p><code>edgeweight</code>: controls the weight of
the edges; see <code>rpa_control_edgeweight()</code> for details.
</p>
</li>
<li> <p><code>newedge</code>: controls the creation of
new edges at each step; see <code>rpa_control_newedge()</code>
for details.
</p>
</li>
<li> <p><code>preference</code>: sets preference functions; see
<code>rpa_control_preference()</code> for details.
</p>
</li>
<li> <p><code>reciprocal</code>: controls the creation of reciprocal
edges; see <code>rpa_control_reciprocal()</code> for details.
</p>
</li></ul>


<hr>
<h2 id='rpanet'>Generate PA networks.</h2><span id='topic+rpanet'></span>

<h3>Description</h3>

<p>Generate preferential attachment (PA) networks with linear or non-linear
preference functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet(
  nstep,
  initial.network = list(edgelist = matrix(c(1, 2), nrow = 1), edgeweight = 1, directed =
    TRUE),
  control,
  method = c("binary", "linear", "bagx", "bag")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="rpanet_+3A_initial.network">initial.network</code></td>
<td>
<p>A <code>wdnet</code> object or a list representing the
initial network. By default, <code>initial.network</code> has one directed edge
from node 1 to node 2 with weight 1. It can contain the following components:
a two-column matrix <code>edgelist</code> representing the edges; a vector
<code>edgeweight</code> representing the weight of edges; a logical argument
<code>directed</code> indicating whether the initial network is directed. If
<code>edgeweight</code> is not specified, all edges from the initial network are
assumed to have weight 1. In addition, an integer vector
<code>nodegroup</code> can be added to the list for specifing node groups;
<code>nodegroup</code> is defined for directed networks, if <code>NULL</code>, all
nodes from the seed network are assumed to be in group 1.</p>
</td></tr>
<tr><td><code id="rpanet_+3A_control">control</code></td>
<td>
<p>An <code>rpacontrol</code> object controlling the PA network
generation process. If not specified, all the control parameters will be
set to default. For more details, see <code>rpa_control_scenario()</code>,
<code>rpa_control_newedge()</code>, <code>rpa_control_edgeweight()</code>,
<code>rpa_control_preference</code> and <code>rpa_control_reciprocal()</code>. Under
the default setup, at each step, a new edge of weight 1 is added from a new
node <code>A</code> to an existing node <code>B</code> (<code>alpha</code> scenario), where
<code>B</code> is chosen with probability proportional to its in-strength + 1.</p>
</td></tr>
<tr><td><code id="rpanet_+3A_method">method</code></td>
<td>
<p>Which method to use: <code>binary</code>, <code>linear</code>, <code>bagx</code>
or <code>bag</code>. For <code>bag</code> and <code>bagx</code> methods, <code>beta.loop</code>
must be <code>TRUE</code>, default preference functions must be used, and
<code>sparams</code> should be set to <code>c(1, 1, 0, 0, a)</code>, <code>tparams</code> to
<code>c(0, 0, 1, 1, b)</code>, and <code>param</code> to <code>c(1, c)</code>, where
<code>a</code>, <code>b</code>, and <code>c</code> are non-negative constants; furthermore,
reciprocal edges and sampling without replacement are not considered, i.e.,
option <code>rpa_control_reciprocal()</code> must be set as default,
<code>snode.replace</code>, <code>tnode.replace</code> and <code>node.replace</code> must be
<code>TRUE</code>. In addition, <code>bag</code> method only works for unweighted
networks and does not consider multiple edges, i.e.,
<code>rpa_control_edgeweight()</code> and <code>rpa_control_newedge()</code> must be
set as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>wdnet</code> object that includes the following components:
</p>

<ul>
<li> <p><code>directed</code>: Logical, whether the network is directed.
</p>
</li>
<li> <p><code>weighted</code>: Logical, whether the network is weighted.
</p>
</li>
<li> <p><code>edgelist</code>: A two-column matrix representing the edges.
</p>
</li>
<li> <p><code>edge.attr</code>: A data frame including edge weights and edge
scenarios (0: from initial network; 1: <code>alpha</code>; 2: <code>beta</code>;
3: <code>gamma</code>; 4: <code>xi</code>; 5; <code>rho</code>; 6: reciprocal edge).
</p>
</li>
<li> <p><code>node.attr</code>: A data frame including node out- and
in-strength, node source and target preference scores (for directed
networks), node strength and preference scores (for undirected
networks), and node group (if applicable).
</p>
</li>
<li> <p><code>newedge</code>: The number of new edges at each step, including
reciprocal edges.
</p>
</li>
<li> <p><code>control</code>: An <code>rpacontrol</code> object that is used to
generate the network.
</p>
</li></ul>



<h3>Note</h3>

<p>The <code>binary</code> method implements binary search algorithm;
<code>linear</code> represents linear search algorithm; <code>bag</code> method
implements the algorithm from Wan et al. (2017); <code>bagx</code> puts all the
edges into a bag, then samples edges and find the source/target node of the
sampled edge.
</p>


<h3>References</h3>

<ul>
<li><p> Wan P, Wang T, Davis RA, Resnick SI (2017).
Fitting the Linear Preferential Attachment Model. Electronic Journal of
Statistics, 11(2), 3738–3780.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Control edge scenario and edge weight through rpa_control_scenario()
# and rpa_control_edgeweight(), respectively,
# while keeping rpa_control_newedge(),
# rpa_control_preference() and rpa_control_reciprocal() as default.
set.seed(123)
control &lt;- rpa_control_scenario(alpha = 0.5, beta = 0.5) +
  rpa_control_edgeweight(
    sampler = function(n) rgamma(n, shape = 5, scale = 0.2)
  )
ret1 &lt;- rpanet(nstep = 1e3, control = control)

# In addition, set node groups and probability of creating reciprocal edges.
control &lt;- control + rpa_control_reciprocal(
  group.prob = c(0.4, 0.6),
  recip.prob = matrix(runif(4), ncol = 2)
)
ret2 &lt;- rpanet(nstep = 1e3, control = control)

# Further, set the number of new edges in each step as Poisson(2) + 1 and use
# ret2 as a seed network.
control &lt;- control + rpa_control_newedge(
  sampler = function(n) rpois(n, lambda = 2) + 1
)
ret3 &lt;- rpanet(nstep = 1e3, initial.network = ret2, control = control)

</code></pre>

<hr>
<h2 id='rpanet_bag_cpp'>Preferential attachment algorithm for simple situations,
i.e., edge weight equals 1, each step adds one new edge.</h2><span id='topic+rpanet_bag_cpp'></span>

<h3>Description</h3>

<p>Preferential attachment algorithm for simple situations,
i.e., edge weight equals 1, each step adds one new edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_bag_cpp(
  snode,
  tnode,
  scenario,
  nnode,
  nedge,
  delta_out,
  delta_in,
  directed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_bag_cpp_+3A_snode">snode</code></td>
<td>
<p>Source nodes.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_tnode">tnode</code></td>
<td>
<p>Target nodes.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_scenario">scenario</code></td>
<td>
<p>Sequence of alpha, beta, gamma, xi, rho scenarios.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_nnode">nnode</code></td>
<td>
<p>Number of nodes in seed network.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_nedge">nedge</code></td>
<td>
<p>Number of edges in seed network.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_delta_out">delta_out</code></td>
<td>
<p>Tuning parameter.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_delta_in">delta_in</code></td>
<td>
<p>Tuning parameter.</p>
</td></tr>
<tr><td><code id="rpanet_bag_cpp_+3A_directed">directed</code></td>
<td>
<p>Whether the network is directed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that includes the total number of nodes, sequences of source and target nodes.
</p>

<hr>
<h2 id='rpanet_binary_directed'>Preferential attachment network generation.</h2><span id='topic+rpanet_binary_directed'></span>

<h3>Description</h3>

<p>Preferential attachment network generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_binary_directed(
  nstep,
  m,
  new_node_id,
  new_edge_id,
  source_node,
  target_node,
  outs,
  ins,
  edgeweight,
  scenario,
  sample_recip,
  node_group,
  spref_vec,
  tpref_vec,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_binary_directed_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_m">m</code></td>
<td>
<p>Number of new edges in each step.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_new_node_id">new_node_id</code></td>
<td>
<p>New node ID.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_new_edge_id">new_edge_id</code></td>
<td>
<p>New edge ID.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_source_node">source_node</code></td>
<td>
<p>Sequence of source nodes.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_target_node">target_node</code></td>
<td>
<p>Sequence of target nodes.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_outs">outs</code></td>
<td>
<p>Sequence of out-strength.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_ins">ins</code></td>
<td>
<p>Sequence of in-strength.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_edgeweight">edgeweight</code></td>
<td>
<p>Weight of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_scenario">scenario</code></td>
<td>
<p>Scenario of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_sample_recip">sample_recip</code></td>
<td>
<p>Logical, whether reciprocal edges will be added.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_node_group">node_group</code></td>
<td>
<p>Sequence of node group.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_spref_vec">spref_vec</code></td>
<td>
<p>Sequence of node source preference.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_tpref_vec">tpref_vec</code></td>
<td>
<p>Sequence of node target preference.</p>
</td></tr>
<tr><td><code id="rpanet_binary_directed_+3A_control">control</code></td>
<td>
<p>List of controlling arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled network.
</p>

<hr>
<h2 id='rpanet_binary_undirected_cpp'>Preferential attachment network generation.</h2><span id='topic+rpanet_binary_undirected_cpp'></span>

<h3>Description</h3>

<p>Preferential attachment network generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_binary_undirected_cpp(
  nstep,
  m,
  new_node_id,
  new_edge_id,
  node_vec1,
  node_vec2,
  s,
  edgeweight,
  scenario,
  pref_vec,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_m">m</code></td>
<td>
<p>Number of new edges in each step.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_new_node_id">new_node_id</code></td>
<td>
<p>New node ID.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_new_edge_id">new_edge_id</code></td>
<td>
<p>New edge ID.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_node_vec1">node_vec1</code></td>
<td>
<p>Sequence of nodes in the first column of edgelist.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_node_vec2">node_vec2</code></td>
<td>
<p>Sequence of nodes in the second column of edgelist.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_s">s</code></td>
<td>
<p>Sequence of node strength.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_edgeweight">edgeweight</code></td>
<td>
<p>Weight of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_scenario">scenario</code></td>
<td>
<p>Scenario of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_pref_vec">pref_vec</code></td>
<td>
<p>Sequence of node preference.</p>
</td></tr>
<tr><td><code id="rpanet_binary_undirected_cpp_+3A_control">control</code></td>
<td>
<p>List of controlling arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled network.
</p>

<hr>
<h2 id='rpanet_general'>Internal functions for generating PA networks</h2><span id='topic+rpanet_general'></span><span id='topic+rpanet_simple'></span>

<h3>Description</h3>

<p>These functions generate a PA network with linear (<code>rpanet_simple</code>) or
non-linear (<code>rpanet_general</code>) preference functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_general(
  nstep,
  initial.network,
  control,
  m,
  sum_m,
  w,
  nnode,
  nedge,
  method,
  sample.recip
)

rpanet_simple(
  nstep,
  initial.network,
  control,
  m,
  sum_m,
  w,
  ex_node,
  ex_edge,
  method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_general_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps when generating a network.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_initial.network">initial.network</code></td>
<td>
<p>A <code>wdnet</code> object or a list that represents the
initial network. By default, <code>initial.network</code> has one directed edge from node 1
to node 2 with weight 1. It may have the following components: a two-column
matrix <code>edgelist</code> representing the edges; a vector <code>edgeweight</code>
representing the weight of edges; a logical argument <code>directed</code> indicating
whether the initial network is directed;
an integer vector <code>nodegroup</code>
representing the group of nodes. <code>nodegroup</code> is defined for directed
networks, if <code>NULL</code>, all nodes from the seed network are considered
from group 1.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_control">control</code></td>
<td>
<p>A list of parameters that controls the PA generation process.
The default value is <code>wdnet:::rpa_control_default()</code>. By default, in
each step, a new edge of weight 1 is added from a new node <code>A</code> to an
existing node <code>B</code> (<code>alpha</code> scenario), where $<code>B</code> is chosen
with probability proportional to its in-strength + 1.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_m">m</code></td>
<td>
<p>Integer vector, number of new edges in each step.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_sum_m">sum_m</code></td>
<td>
<p>Integer, summation of <code>m</code>.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_w">w</code></td>
<td>
<p>Vector, weight of new edges.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_nnode">nnode</code></td>
<td>
<p>Integer, number of nodes in <code>initial.network</code>.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_nedge">nedge</code></td>
<td>
<p>Integer, number of edges in <code>initial.network</code>.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_method">method</code></td>
<td>
<p>Which method to use when generating PA networks: &quot;binary&quot; or
&quot;linear&quot;.</p>
</td></tr>
<tr><td><code id="rpanet_general_+3A_sample.recip">sample.recip</code></td>
<td>
<p>Whether reciprocal edges will be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>wdnet</code> object that includes the following components:
</p>

<ul>
<li> <p><code>directed</code>: Logical, whether the network is directed.
</p>
</li>
<li> <p><code>weighted</code>: Logical, whether the network is weighted.
</p>
</li>
<li> <p><code>edgelist</code>: A two-column matrix representing the edges.
</p>
</li>
<li> <p><code>edge.attr</code>: A data frame including edge weights and edge
scenarios (0: from initial network; 1: <code>alpha</code>; 2: <code>beta</code>;
3: <code>gamma</code>; 4: <code>xi</code>; 5; <code>rho</code>; 6: reciprocal edge).
</p>
</li>
<li> <p><code>node.attr</code>: A data frame including node out- and
in-strength, node source and target preference scores (for directed
networks), node strength and preference scores (for undirected
networks), and node group (if applicable).
</p>
</li>
<li> <p><code>newedge</code>: The number of new edges at each step, including
reciprocal edges.
</p>
</li>
<li> <p><code>control</code>: An <code>rpacontrol</code> object that is used to
generate the network.
</p>
</li></ul>


<hr>
<h2 id='rpanet_linear_directed_cpp'>Preferential attachment network generation.</h2><span id='topic+rpanet_linear_directed_cpp'></span>

<h3>Description</h3>

<p>Preferential attachment network generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_linear_directed_cpp(
  nstep,
  m,
  new_node_id,
  new_edge_id,
  source_node,
  target_node,
  outs,
  ins,
  edgeweight,
  scenario,
  sample_recip,
  node_group,
  spref_vec,
  tpref_vec,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_m">m</code></td>
<td>
<p>Number of new edges in each step.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_new_node_id">new_node_id</code></td>
<td>
<p>New node ID.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_new_edge_id">new_edge_id</code></td>
<td>
<p>New edge ID.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_source_node">source_node</code></td>
<td>
<p>Sequence of source nodes.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_target_node">target_node</code></td>
<td>
<p>Sequence of target nodes.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_outs">outs</code></td>
<td>
<p>Sequence of out-strength.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_ins">ins</code></td>
<td>
<p>Sequence of in-strength.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_edgeweight">edgeweight</code></td>
<td>
<p>Weight of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_scenario">scenario</code></td>
<td>
<p>Scenario of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_sample_recip">sample_recip</code></td>
<td>
<p>Logical, whether reciprocal edges will be added.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_node_group">node_group</code></td>
<td>
<p>Sequence of node group.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_spref_vec">spref_vec</code></td>
<td>
<p>Sequence of node source preference.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_tpref_vec">tpref_vec</code></td>
<td>
<p>Sequence of node target preference.</p>
</td></tr>
<tr><td><code id="rpanet_linear_directed_cpp_+3A_control">control</code></td>
<td>
<p>List of controlling arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled network.
</p>

<hr>
<h2 id='rpanet_linear_undirected_cpp'>Preferential attachment network generation.</h2><span id='topic+rpanet_linear_undirected_cpp'></span>

<h3>Description</h3>

<p>Preferential attachment network generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpanet_linear_undirected_cpp(
  nstep,
  m,
  new_node_id,
  new_edge_id,
  node_vec1,
  node_vec2,
  s,
  edgeweight,
  scenario,
  pref_vec,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_nstep">nstep</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_m">m</code></td>
<td>
<p>Number of new edges in each step.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_new_node_id">new_node_id</code></td>
<td>
<p>New node ID.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_new_edge_id">new_edge_id</code></td>
<td>
<p>New edge ID.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_node_vec1">node_vec1</code></td>
<td>
<p>Sequence of nodes in the first column of edgelist.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_node_vec2">node_vec2</code></td>
<td>
<p>Sequence of nodes in the second column of edgelist.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_s">s</code></td>
<td>
<p>Sequence of node strength.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_edgeweight">edgeweight</code></td>
<td>
<p>Weight of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_scenario">scenario</code></td>
<td>
<p>Scenario of existing and new edges.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_pref_vec">pref_vec</code></td>
<td>
<p>Sequence of node preference.</p>
</td></tr>
<tr><td><code id="rpanet_linear_undirected_cpp_+3A_control">control</code></td>
<td>
<p>List of controlling arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled network.
</p>

<hr>
<h2 id='sample_node_cpp'>Uniformly draw a node from existing nodes for each time step.
Defined for <code>wdnet::rpanet()</code>.</h2><span id='topic+sample_node_cpp'></span>

<h3>Description</h3>

<p>Uniformly draw a node from existing nodes for each time step.
Defined for <code>wdnet::rpanet()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_node_cpp(total_node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_node_cpp_+3A_total_node">total_node</code></td>
<td>
<p>Number of existing nodes at each time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled nodes.
</p>

<hr>
<h2 id='wdnet_to_igraph'>Converts a <code>wdnet</code> object to an <code>igraph</code> object</h2><span id='topic+wdnet_to_igraph'></span>

<h3>Description</h3>

<p>Converts a <code>wdnet</code> object to an <code>igraph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wdnet_to_igraph(netwk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wdnet_to_igraph_+3A_netwk">netwk</code></td>
<td>
<p>A <code>wdnet</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>netwk &lt;- rpanet(nstep = 1e3)
g &lt;- wdnet_to_igraph(netwk)

</code></pre>

<hr>
<h2 id='wpr'>Weighted PageRank centrality</h2><span id='topic+wpr'></span>

<h3>Description</h3>

<p>Compute the weighted PageRank centrality measures of the vertices in a
weighted and directed network represented through its adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpr(adj, gamma = 0.85, theta = 1, prior.info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpr_+3A_adj">adj</code></td>
<td>
<p>is an adjacency matrix of a weighted and directed network</p>
</td></tr>
<tr><td><code id="wpr_+3A_gamma">gamma</code></td>
<td>
<p>is the damping factor; it takes 0.85 (default) if not given.</p>
</td></tr>
<tr><td><code id="wpr_+3A_theta">theta</code></td>
<td>
<p>is a tuning parameter leveraging node degree and strength; theta
= 0 does not consider edge weight; theta = 1 (default) fully considers edge
weight.</p>
</td></tr>
<tr><td><code id="wpr_+3A_prior.info">prior.info</code></td>
<td>
<p>vertex-specific prior information for restarting when
arriving at a sink. When it is not given (<code>NULL</code>), a random restart is
implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of node names with corresponding weighted PageRank scores
</p>


<h3>Note</h3>

<p>Function <code>wpr</code> is an extension of function <code>page_rank</code> in
package <code>igraph</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Zhang, P., Wang, T. and Yan, J. (2022) PageRank centrality and algorithms for
weighted, directed networks with applications to World Input-Output Tables.
<em>Physica A: Statistical Mechanics and its Applications</em>, 586, 126438.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
