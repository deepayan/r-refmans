<!DOCTYPE html><html><head><title>Help for package nzilbb.labbcat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nzilbb.labbcat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addDictionaryEntry'><p>Adds an entry to a dictionary.</p></a></li>
<li><a href='#addLayerDictionaryEntry'><p>Adds an entry to a layer dictionary.</p></a></li>
<li><a href='#annotatorExt'><p>Retrieve annotator's &quot;ext&quot; resource.</p></a></li>
<li><a href='#countAnnotations'><p>Gets the number of annotations on the given layer of the given transcript.</p></a></li>
<li><a href='#countMatchingAnnotations'><p>Gets the number of annotations matching a particular pattern.</p></a></li>
<li><a href='#deleteLayer'><p>Deletes an existing layer.</p></a></li>
<li><a href='#deleteLexicon'><p>Delete a previously loaded lexicon.</p></a></li>
<li><a href='#deleteParticipant'><p>Deletes a participant record.</p></a></li>
<li><a href='#deleteTranscript'><p>Delete a transcript from the corpus.</p></a></li>
<li><a href='#expressionFromAttributeValue'><p>Generates a query expression for matching a transcript/participant attribute, for use with</p>
getMatches.</a></li>
<li><a href='#expressionFromAttributeValues'><p>Generates a query expression for matching a transcript/participant attribute, for use with</p>
getMatches.</a></li>
<li><a href='#expressionFromIds'><p>Generates a query expression for matching transcripts or participants by ID, for use with</p>
getMatches.</a></li>
<li><a href='#expressionFromTranscriptTypes'><p>Generates a transcript query expression for matching transcripts by type, for use with</p>
getMatches or getMatchingTranscriptIds.</a></li>
<li><a href='#formatTranscript'><p>Gets transcript(s) in a given format.</p></a></li>
<li><a href='#generateLayer'><p>Generates a layer.</p></a></li>
<li><a href='#generateLayerUtterances'><p>Generates a layer for a given set of utterances.</p></a></li>
<li><a href='#getAllUtterances'><p>Get all utterances of participants.</p></a></li>
<li><a href='#getAnchors'><p>Gets the given anchors in the given transcript.</p></a></li>
<li><a href='#getAnnotations'><p>Gets the annotations on the given layer of the given transcript.</p></a></li>
<li><a href='#getAnnotatorDescriptor'><p>Gets annotator information.</p></a></li>
<li><a href='#getAvailableMedia'><p>List the media available for the given transcript.</p></a></li>
<li><a href='#getCorpusIds'><p>Gets a list of corpus IDs.</p></a></li>
<li><a href='#getDeserializerDescriptors'><p>Lists the descriptors of all registered deserializers.</p></a></li>
<li><a href='#getDictionaries'><p>List the dictionaries available.</p></a></li>
<li><a href='#getDictionaryEntries'><p>Lookup entries in a dictionary.</p></a></li>
<li><a href='#getFragmentAnnotations'><p>Gets annotations in fragments.</p></a></li>
<li><a href='#getFragments'><p>Gets transcript fragments in a given format.</p></a></li>
<li><a href='#getGraphIds'><p>Deprecated synonym for getTranscriptIds.</p></a></li>
<li><a href='#getGraphIdsInCorpus'><p>Deprecated synonym for getTranscriptIdsInCorpus.</p></a></li>
<li><a href='#getGraphIdsWithParticipant'><p>Deprecated synonym for getTranscriptIdsWithParticipant.</p></a></li>
<li><a href='#getId'><p>Gets the store's ID.</p></a></li>
<li><a href='#getLayer'><p>Gets a layer definition.</p></a></li>
<li><a href='#getLayerIds'><p>Gets a list of layer IDs.</p></a></li>
<li><a href='#getLayers'><p>Gets a list of layer definitions.</p></a></li>
<li><a href='#getMatchAlignments'><p>Gets temporal alignments of matches on a given layer.</p></a></li>
<li><a href='#getMatches'><p>Search for tokens.</p></a></li>
<li><a href='#getMatchingAnnotations'><p>Gets a list of annotations that match a particular pattern.</p></a></li>
<li><a href='#getMatchingGraphIds'><p>Deprecated synonym for getMatchingTranscriptIds.</p></a></li>
<li><a href='#getMatchingParticipantIds'><p>Gets a list of IDs of participants that match a particular pattern.</p></a></li>
<li><a href='#getMatchingTranscriptIds'><p>Gets a list of IDs of transcripts that match a particular pattern.</p></a></li>
<li><a href='#getMatchLabels'><p>Gets labels of annotations on a given layer, identified by given match IDs.</p></a></li>
<li><a href='#getMedia'><p>Downloads a given media track for a given transcript.</p></a></li>
<li><a href='#getMediaTracks'><p>List the predefined media tracks available for transcripts.</p></a></li>
<li><a href='#getMediaUrl'><p>Gets the URL of the given media track for a given transcript.</p></a></li>
<li><a href='#getParticipant'><p>Gets information about a single participant.</p></a></li>
<li><a href='#getParticipantAttributes'><p>Gets participant attribute values for given participant IDs.</p></a></li>
<li><a href='#getParticipantIds'><p>Gets a list of participant IDs.</p></a></li>
<li><a href='#getSerializerDescriptors'><p>Lists the descriptors of all registered serializers.</p></a></li>
<li><a href='#getSoundFragments'><p>Gets sound fragments from 'LaBB-CAT'.</p></a></li>
<li><a href='#getSystemAttribute'><p>Gets the value of the given system attribute.</p></a></li>
<li><a href='#getTranscriptAttributes'><p>Gets transcript attribute values for given transcript IDs.</p></a></li>
<li><a href='#getTranscriptIds'><p>Gets a list of transcript IDs.</p></a></li>
<li><a href='#getTranscriptIdsInCorpus'><p>Gets a list of transcript in a corpus.</p></a></li>
<li><a href='#getTranscriptIdsWithParticipant'><p>Gets a list of IDs of transcripts that include the given participant.</p></a></li>
<li><a href='#getUserInfo'><p>Gets information about the current user.</p></a></li>
<li><a href='#labbcatCredentials'><p>Sets the username and password that the package should use for connecting</p>
to a given LaBB-CAT server in future function calls.</a></li>
<li><a href='#labbcatTimeout'><p>Sets the timeout for request to the LaBB-CAT server in future function calls. The</p>
default timeout is 10 seconds.</a></li>
<li><a href='#labbcatVersionInfo'><p>Gets version information of all components of LaBB-CAT.</p></a></li>
<li><a href='#loadLexicon'><p>Upload a flat lexicon file for lexical tagging.</p></a></li>
<li><a href='#newLayer'><p>Creates a new layer.</p></a></li>
<li><a href='#newTranscript'><p>Upload a new transcript.</p></a></li>
<li><a href='#nzilbb.labbcat'><p>Accessing Data Stored in 'LaBB-CAT' Instances</p></a></li>
<li><a href='#praatScriptCentreOfGravity'><p>Generates a script for extracting the CoG, for use with processWithPraat.</p></a></li>
<li><a href='#praatScriptFastTrack'><p>Generates a script for extracting formants using FastTrack, for use with processWithPraat.</p></a></li>
<li><a href='#praatScriptFormants'><p>Generates a script for extracting formants, for use with processWithPraat.</p></a></li>
<li><a href='#praatScriptIntensity'><p>Generates a script for extracting maximum intensity, for use with processWithPraat.</p></a></li>
<li><a href='#praatScriptPitch'><p>Generates a script for extracting pitch, for use with processWithPraat.</p></a></li>
<li><a href='#processWithPraat'><p>Process a set of intervals with Praat.</p></a></li>
<li><a href='#removeDictionaryEntry'><p>Removes an entry from a dictionary.</p></a></li>
<li><a href='#removeLayerDictionaryEntry'><p>Removes an entry from a layer dictionary.</p></a></li>
<li><a href='#renameParticipants'><p>Renames a list of participants.</p></a></li>
<li><a href='#saveLayer'><p>Saves the details of an existing layer.</p></a></li>
<li><a href='#saveParticipant'><p>Saves information about a single participant.</p></a></li>
<li><a href='#updateFragment'><p>Update a transcript fragment.</p></a></li>
<li><a href='#updateTranscript'><p>Update an existing transcript.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Accessing Data Stored in 'LaBB-CAT' Instances</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, httr, stringr, utils, rstudioapi</td>
</tr>
<tr>
<td>Description:</td>
<td>'LaBB-CAT' is a web-based language corpus management
 system developed by the New Zealand Institute of Language, Brain
 and Behaviour (NZILBB) - see <a href="https://labbcat.canterbury.ac.nz">https://labbcat.canterbury.ac.nz</a>.
 This package defines functions for accessing corpus data in a 'LaBB-CAT'
 instance. You must have at least version 20230224.1731 of 'LaBB-CAT'
 to use this package.
 For more information about 'LaBB-CAT', see
 Robert Fromont and Jennifer Hay (2008) &lt;<a href="https://doi.org/10.3366%2FE1749503208000142">doi:10.3366/E1749503208000142</a>&gt;
 or 
 Robert Fromont (2017) &lt;<a href="https://doi.org/10.1016%2Fj.csl.2017.01.004">doi:10.1016/j.csl.2017.01.004</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>New Zealand Institute of Language, Brain and Behaviour,
University of Canterbury</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nzilbb.github.io/labbcat-R/">https://nzilbb.github.io/labbcat-R/</a>,
<a href="https://labbcat.canterbury.ac.nz">https://labbcat.canterbury.ac.nz</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-19 15:44:28 UTC; robert</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Fromont <a href="https://orcid.org/0000-0001-5271-5487"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Fromont &lt;robert.fromont@canterbury.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 16:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addDictionaryEntry'>Adds an entry to a dictionary.</h2><span id='topic+addDictionaryEntry'></span>

<h3>Description</h3>

<p>This function creates adds a new entry to the given dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDictionaryEntry(labbcat.url, manager.id, dictionary.id, key, entry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDictionaryEntry_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="addDictionaryEntry_+3A_manager.id">manager.id</code></td>
<td>
<p>The layer manager ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="addDictionaryEntry_+3A_dictionary.id">dictionary.id</code></td>
<td>
<p>The ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="addDictionaryEntry_+3A_key">key</code></td>
<td>
<p>The key (word) in the dictionary to add an entry for.</p>
</td></tr>
<tr><td><code id="addDictionaryEntry_+3A_entry">entry</code></td>
<td>
<p>The value (definition) for the given key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have edit privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL if the entry was added, or a list of error messages if not.
</p>


<h3>See Also</h3>

<p><a href="#topic+getDictionaries">getDictionaries</a>
</p>
<p><a href="#topic+getDictionaryEntries">getDictionaryEntries</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Add the word "robert" to the CELEX wordform pronunciation dictionary
addDictionaryEntry(labbcat.url, "CELEX-EN", "Phonology (wordform)", "robert", "'rQ-b@t")

## End(Not run)

</code></pre>

<hr>
<h2 id='addLayerDictionaryEntry'>Adds an entry to a layer dictionary.</h2><span id='topic+addLayerDictionaryEntry'></span>

<h3>Description</h3>

<p>This function adds a new entry to the dictionary that manages a given layer,
and updates all affected tokens in the corpus. Words can have multiple entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLayerDictionaryEntry(labbcat.url, layer.id, key, entry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLayerDictionaryEntry_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="addLayerDictionaryEntry_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer with a dictionary configured to manage it.</p>
</td></tr>
<tr><td><code id="addLayerDictionaryEntry_+3A_key">key</code></td>
<td>
<p>The key (word) in the dictionary to add an entry for.</p>
</td></tr>
<tr><td><code id="addLayerDictionaryEntry_+3A_entry">entry</code></td>
<td>
<p>The value (definition) for the given key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have edit privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL if the entry was added, or a list of error messages if not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateLayer">generateLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Add a pronunciation for the word "robert" to the phonemes layer dictionary
addLayerDictionaryEntry(labbcat.url, "phonemes", "robert", "'rQ-b@t")

## End(Not run)

</code></pre>

<hr>
<h2 id='annotatorExt'>Retrieve annotator's &quot;ext&quot; resource.</h2><span id='topic+annotatorExt'></span>

<h3>Description</h3>

<p>Retrieve a given resource from an annotator's &quot;ext&quot; web app. Annotators are modules
that perform different annotation tasks, and can optionally implement functionality for
providing extra data or extending functionality in an annotator-specific way. If the
annotator implements an &quot;ext&quot; web app, it can provide resources and implement a
mechanism for iterrogating the annotator. This function provides a mechanism for
accessing these resources via R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotatorExt(labbcat.url, annotator.id, resource, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotatorExt_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="annotatorExt_+3A_annotator.id">annotator.id</code></td>
<td>
<p>ID of the annotator to interrogate.</p>
</td></tr>
<tr><td><code id="annotatorExt_+3A_resource">resource</code></td>
<td>
<p>The name of the file to retrieve or instance method (function) to
invoke. Possible values for this depend on the specific annotator being interrogated.</p>
</td></tr>
<tr><td><code id="annotatorExt_+3A_parameters">parameters</code></td>
<td>
<p>Optional list of ordered parameters for the instance method (function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resource requested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get the version of the currently installed LabelMapper annotator:
annotatorExt(labbcat.url, "LabelMapper", "getVersion")

## Get the summary of the segment to speakerDependentPhone mapping
## implemented by the LabelMapper annotator:
summaryJson &lt;- annotatorExt(labbcat.url,
              "LabelMapper", "summarizeMapping", list("segment","speakerDependentPhone"))
summary &lt;- jsonlite::fromJSON(summaryJson)

## End(Not run)

</code></pre>

<hr>
<h2 id='countAnnotations'>Gets the number of annotations on the given layer of the given transcript.</h2><span id='topic+countAnnotations'></span>

<h3>Description</h3>

<p>Returns the number of annotations on the given layer of the given
transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countAnnotations(labbcat.url, id, layer.id, max.ordinal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countAnnotations_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="countAnnotations_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name)</p>
</td></tr>
<tr><td><code id="countAnnotations_+3A_layer.id">layer.id</code></td>
<td>
<p>A layer ID</p>
</td></tr>
<tr><td><code id="countAnnotations_+3A_max.ordinal">max.ordinal</code></td>
<td>
<p>The maximum ordinal for the counted annotations. e.g. a max.ordinal
of 1 will ensure that only the first annotation for each parent is returned. If
max.ordinal is null, then all annotations are counted, regardless of their ordinal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of annotations on that layer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTranscriptIds">getTranscriptIds</a></code>
<code><a href="#topic+getTranscriptIdsInCorpus">getTranscriptIdsInCorpus</a></code>
<code><a href="#topic+getTranscriptIdsWithParticipant">getTranscriptIdsWithParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Count the number of words in UC427_ViktoriaPapp_A_ENG.eaf
token.count &lt;- countAnnotations(labbcat.url, "UC427_ViktoriaPapp_A_ENG.eaf", "orthography")

## End(Not run)

</code></pre>

<hr>
<h2 id='countMatchingAnnotations'>Gets the number of annotations matching a particular pattern.</h2><span id='topic+countMatchingAnnotations'></span>

<h3>Description</h3>

<p>Returns the number of annotations in the corpus that match the given expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countMatchingAnnotations(labbcat.url, expression)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countMatchingAnnotations_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="countMatchingAnnotations_+3A_expression">expression</code></td>
<td>
<p>An expression that determines which annotations match. This must
match by either id or layer.id.
The expression language is currently not well defined, but is based on JavaScript
syntax. e.g.
</p>

<ul>
<li><p>id == 'ew_0_456'
</p>
</li>
<li><p>['ew_2_456', 'ew_2_789', 'ew_2_101112'].includes(id)
</p>
</li>
<li><p>layerId == 'orthography' &amp;&amp; !/th[aeiou].+/.test(label)
</p>
</li>
<li><p>graph.id == 'AdaAicheson-01.trs' &amp;&amp; layer.id == 'orthography' &amp;&amp;
start.offset &amp;gt; 10.5 
</p>
</li>
<li><p>layer.id == 'utterance' &amp;&amp; all('word').includes('ew_0_456')
</p>
</li>
<li><p>layerId = 'utterance' &amp;&amp; labels('orthography').includes('foo')
</p>
</li>
<li><p>layerId = 'utterance' &amp;&amp; labels('participant').includes('Ada')
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of annotations that match the expression.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMatchingAnnotations">getMatchingAnnotations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## count the number of topic tags that include the word 'quake'
countMatchingAnnotations(labbcat.url, "layer.id == 'topic' &amp;&amp; /.*quake.*/.test(label)")

## End(Not run)

</code></pre>

<hr>
<h2 id='deleteLayer'>Deletes an existing layer.</h2><span id='topic+deleteLayer'></span>

<h3>Description</h3>

<p>This function deletes an existing annotation layer, including all annotation data
associated with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteLayer(labbcat.url, layer.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteLayer_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="deleteLayer_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer to delete.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have administration privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL, or an error message if deletion failed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newLayer">newLayer</a></code>
<code><a href="#topic+saveLayer">saveLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Delete the phonemes layer
deleteLayer(labbcat.url, "phonemes")

## End(Not run)

</code></pre>

<hr>
<h2 id='deleteLexicon'>Delete a previously loaded lexicon.</h2><span id='topic+deleteLexicon'></span>

<h3>Description</h3>

<p>By default LaBB-CAT includes a layer manager called the Flat Lexicon Tagger, which can
be configured to annotate words with data from a dictionary loaded from a plain text
file (e.g. a CSV file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteLexicon(labbcat.url, lexicon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteLexicon_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="deleteLexicon_+3A_lexicon">lexicon</code></td>
<td>
<p>The name of the lexicon to delete, e.g. 'cmudict'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes such a lexicon, which was previously added using loadLexicon.
</p>
<p>You must have editing privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL if the deletion was successful, or an error message if not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadLexicon">loadLexicon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Delete the previously loaded CMU Pronouncing Dictionary lexicon
deleteLexicon(labbcat.url, "cmudict")

## End(Not run)

</code></pre>

<hr>
<h2 id='deleteParticipant'>Deletes a participant record.</h2><span id='topic+deleteParticipant'></span>

<h3>Description</h3>

<p>This function deletes the identified participant from the corpus, but only if they do
not appear in any transcripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteParticipant(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteParticipant_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="deleteParticipant_+3A_id">id</code></td>
<td>
<p>The participant ID - either the unique internal database ID, or their name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the participant's record was delete, FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParticipant">getParticipant</a></code>
<code><a href="#topic+saveParticipant">saveParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Create a new participant record
saveParticipant(labbcat.url, "Juan Perez")

### Delete the participant we just created
deleteParticipant(labbcat.url, "Juan Perez")

## End(Not run)

</code></pre>

<hr>
<h2 id='deleteTranscript'>Delete a transcript from the corpus.</h2><span id='topic+deleteTranscript'></span>

<h3>Description</h3>

<p>This function deletes the given transcript, and all associated files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteTranscript(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteTranscript_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="deleteTranscript_+3A_id">id</code></td>
<td>
<p>The ID transcript to delete.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the credentials used to connect to the server must have at
least 'edit' access.
</p>


<h3>Value</h3>

<p>The ID of the deleted transcript
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## delete a transcript from the server
deleteTranscript(labbcat.url, "my-transcript.eaf")

## End(Not run)
</code></pre>

<hr>
<h2 id='expressionFromAttributeValue'>Generates a query expression for matching a transcript/participant attribute, for use with
<a href="#topic+getMatches">getMatches</a>.</h2><span id='topic+expressionFromAttributeValue'></span>

<h3>Description</h3>

<p>This function generates a query expression fragment which can be passed as
the transcript.expression or participant.expression parameter of <a href="#topic+getMatches">getMatches</a>, (or
the expression parameter of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a> or
<a href="#topic+getMatchingParticipantIds">getMatchingParticipantIds</a>) using a list of possible values for a given
transcript attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expressionFromAttributeValue(transcript.attribute, values, not = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expressionFromAttributeValue_+3A_transcript.attribute">transcript.attribute</code></td>
<td>
<p>The transcript attribute to filter by.</p>
</td></tr>
<tr><td><code id="expressionFromAttributeValue_+3A_values">values</code></td>
<td>
<p>A list of possible values for transcript.attribute.</p>
</td></tr>
<tr><td><code id="expressionFromAttributeValue_+3A_not">not</code></td>
<td>
<p>Whether to match the given IDs (FALSE), or everything *except* the
given IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attribute defined by transcript.attribute is expected to have exactly one value. If
it may have multiple values, use <a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a> instead.
</p>


<h3>Value</h3>

<p>A transcript query expression which can be passed as the
transcript.expression parameter of <a href="#topic+getMatches">getMatches</a> or the expression parameter
of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a>
</p>
<p><a href="#topic+expressionFromTranscriptTypes">expressionFromTranscriptTypes</a>
</p>
<p><a href="#topic+expressionFromIds">expressionFromIds</a>
</p>
<p><a href="#topic+getMatches">getMatches</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
languages &lt;- c("en","en-NZ")
results &lt;- getMatches(labbcat.url, list(segment="I"),
                      transcript.expression = expressionFromAttributeValue(
                            "transcript_language", languages))

## End(Not run)
</code></pre>

<hr>
<h2 id='expressionFromAttributeValues'>Generates a query expression for matching a transcript/participant attribute, for use with
<a href="#topic+getMatches">getMatches</a>.</h2><span id='topic+expressionFromAttributeValues'></span>

<h3>Description</h3>

<p>This function generates a query expression fragment which can be passed as
the transcript.expression or participant.expression parameter of <a href="#topic+getMatches">getMatches</a>, (or
the expression parameter of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a> or
<a href="#topic+getMatchingParticipantIds">getMatchingParticipantIds</a>) using a list of possible values for a given
transcript attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expressionFromAttributeValues(transcript.attribute, values, not = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expressionFromAttributeValues_+3A_transcript.attribute">transcript.attribute</code></td>
<td>
<p>The transcript attribute to filter by.</p>
</td></tr>
<tr><td><code id="expressionFromAttributeValues_+3A_values">values</code></td>
<td>
<p>A list of possible values for transcript.attribute.</p>
</td></tr>
<tr><td><code id="expressionFromAttributeValues_+3A_not">not</code></td>
<td>
<p>Whether to match the given IDs (FALSE), or everything *except* the
given IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attribute defined by transcript.attribute is expected to have possibly more than
one value. If it can have only one value, use <a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a> instead.
</p>


<h3>Value</h3>

<p>A transcript query expression which can be passed as the
transcript.expression parameter of <a href="#topic+getMatches">getMatches</a> or the expression parameter
of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a>
</p>
<p><a href="#topic+expressionFromTranscriptTypes">expressionFromTranscriptTypes</a>
</p>
<p><a href="#topic+expressionFromIds">expressionFromIds</a>
</p>
<p><a href="#topic+getMatches">getMatches</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
languages &lt;- c("en","es")
results &lt;- getMatches(labbcat.url, list(segment="I"),
                      participant.expression = expressionFromAttributeValues(
                            "participant_languagesSpoken", languages))

## End(Not run)
</code></pre>

<hr>
<h2 id='expressionFromIds'>Generates a query expression for matching transcripts or participants by ID, for use with
<a href="#topic+getMatches">getMatches</a>.</h2><span id='topic+expressionFromIds'></span>

<h3>Description</h3>

<p>This function generates a query expression fragment which can be passed as
the transcript.expression or participant.expression parameter of <a href="#topic+getMatches">getMatches</a>,
using a list of corresponding IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expressionFromIds(ids, not = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expressionFromIds_+3A_ids">ids</code></td>
<td>
<p>A list of IDs.</p>
</td></tr>
<tr><td><code id="expressionFromIds_+3A_not">not</code></td>
<td>
<p>Whether to match the given IDs (FALSE), or everything *except* the
given IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A query expression which can be passed as the
transcript.expression or participant.expression parameter of <a href="#topic+getMatches">getMatches</a> 
or the expression parameter of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a> or
<a href="#topic+getMatchingParticipantIds">getMatchingParticipantIds</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a>
</p>
<p><a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a>
</p>
<p><a href="#topic+expressionFromTranscriptTypes">expressionFromTranscriptTypes</a>
</p>
<p><a href="#topic+getMatches">getMatches</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
transcript.ids &lt;- c("AP511_MikeThorpe.eaf", "BR2044_OllyOhlson.eaf")
results &lt;- getMatches(labbcat.url, list(segment="I"),
                      transcript.expression = expressionFromIds(transcript.ids))

## End(Not run)
</code></pre>

<hr>
<h2 id='expressionFromTranscriptTypes'>Generates a transcript query expression for matching transcripts by type, for use with
<a href="#topic+getMatches">getMatches</a> or <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a>.</h2><span id='topic+expressionFromTranscriptTypes'></span>

<h3>Description</h3>

<p>This function generates a transcript query expression fragment which can be passed as
the transcript.expression parameter of <a href="#topic+getMatches">getMatches</a>, (or the expression parameter
of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a>) in order to identify transcripts using a list of
transcript types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expressionFromTranscriptTypes(transcript.types, not = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expressionFromTranscriptTypes_+3A_transcript.types">transcript.types</code></td>
<td>
<p>A list of transcript types.</p>
</td></tr>
<tr><td><code id="expressionFromTranscriptTypes_+3A_not">not</code></td>
<td>
<p>Whether to match the given IDs (FALSE), or everything *except* the
given IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transcript query expression which can be passed as the
transcript.expression parameter of <a href="#topic+getMatches">getMatches</a> or the expression parameter
of <a href="#topic+getMatchingTranscriptIds">getMatchingTranscriptIds</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a>
</p>
<p><a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a>
</p>
<p><a href="#topic+expressionFromIds">expressionFromIds</a>
</p>
<p><a href="#topic+getMatches">getMatches</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search of interviews or monologues
transcript.types &lt;- c("interview","monologue")
results &lt;- getMatches(labbcat.url, list(segment="I"),
  transcript.expression = expressionFromTranscriptTypes(transcript.types))

## Perform a search of all transcripts that aren't word-lists.
results &lt;- getMatches(labbcat.url, list(segment="I"),
  transcript.expression = expressionFromTranscriptTypes("wordlist", NOT=true))

## End(Not run)
</code></pre>

<hr>
<h2 id='formatTranscript'>Gets transcript(s) in a given format.</h2><span id='topic+formatTranscript'></span>

<h3>Description</h3>

<p>This function gets whole transcripts from 'LaBB-CAT', 
converted to a given format (by default, Praat TextGrid).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatTranscript(
  labbcat.url,
  id,
  layer.ids,
  mime.type = "text/praat-textgrid",
  path = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatTranscript_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="formatTranscript_+3A_id">id</code></td>
<td>
<p>The transcript ID (transcript name) of the sound recording, or
a vector of transcript IDs. If the same ID appears more than one, the formatted
file is downloaded only once.</p>
</td></tr>
<tr><td><code id="formatTranscript_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs.</p>
</td></tr>
<tr><td><code id="formatTranscript_+3A_mime.type">mime.type</code></td>
<td>
<p>Optional content-type - &quot;text/praat-textgrid&quot; is the default, but your
LaBB-CAT installation may support other formats, which can be discovered using
<a href="#topic+getSerializerDescriptors">getSerializerDescriptors</a>.</p>
</td></tr>
<tr><td><code id="formatTranscript_+3A_path">path</code></td>
<td>
<p>Optional path to directory where the files should be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>NB</em> Although many formats will generate exactly one file for each interval
(e.g. mime.type=text/praat-textgrid), this is not guaranted; some formats generate
a single file or a fixed collection of files regardless of how many IDs there are.
</p>


<h3>Value</h3>

<p>The name of the file, which is saved in the current directory, or the given
path, or a list of names of files, if multiple id's were specified. 
</p>
<p>If a list of files is returned, they are in the order that they
were returned by the server, which *should* be the order that
they were specified in the id list.
</p>


<h3>See Also</h3>

<p><a href="#topic+getSerializerDescriptors">getSerializerDescriptors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get the TextGrid of a recording
textgrid.file &lt;- formatTranscript(labbcat.url, "AP2505_Nelson.eaf",
    c("word", "segment"), path="textgrids") 

## Get all the transcripts of a given participant
transcript.ids &lt;- getTranscriptIdsWithParticipant(labbcat.url, "AP2505_Nelson")

## Download all the TextGrids, including the utterances, transcript, and segment layers
textgrid.files &lt;- formatTranscript(
    labbcat.url, transcript.ids, c("utterance", "word", "segment"))


## End(Not run)
</code></pre>

<hr>
<h2 id='generateLayer'>Generates a layer.</h2><span id='topic+generateLayer'></span>

<h3>Description</h3>

<p>Generates annotations on a given layer for all transcripts in the corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateLayer(labbcat.url, layer.id, no.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateLayer_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="generateLayer_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer to generate.</p>
</td></tr>
<tr><td><code id="generateLayer_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to suppress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final status of the layer generation task.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAllUtterances">getAllUtterances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Generate all phonemic transcription annotations
generateLayer(labbcat.url, "phonemes")

## End(Not run)

</code></pre>

<hr>
<h2 id='generateLayerUtterances'>Generates a layer for a given set of utterances.</h2><span id='topic+generateLayerUtterances'></span>

<h3>Description</h3>

<p>Generates annotations on a given layer for a given set of utterances, e.g. force-align
selected utterances of a participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateLayerUtterances(
  labbcat.url,
  match.ids,
  layer.id,
  collection.name = NULL,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateLayerUtterances_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="generateLayerUtterances_+3A_match.ids">match.ids</code></td>
<td>
<p>A vector of annotation IDs, e.g. the MatchId column, or the URL column,
of a results set.</p>
</td></tr>
<tr><td><code id="generateLayerUtterances_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer to generate.</p>
</td></tr>
<tr><td><code id="generateLayerUtterances_+3A_collection.name">collection.name</code></td>
<td>
<p>An optional name for the collection, e.g. the participant ID.</p>
</td></tr>
<tr><td><code id="generateLayerUtterances_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final status of the layer generation task.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAllUtterances">getAllUtterances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all utterances of a participant
allUtterances &lt;- getAllUtterances(labbcat.url, "AP2505_Nelson")

## Force-align the participant's utterances
generateLayerUtterances(labbcat.url, allUtterances$MatchId, "htk", "AP2505_Nelson")

## End(Not run)

</code></pre>

<hr>
<h2 id='getAllUtterances'>Get all utterances of participants.</h2><span id='topic+getAllUtterances'></span>

<h3>Description</h3>

<p>Identifies all utterances of a given set of participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllUtterances(
  labbcat.url,
  participant.ids,
  transcript.types = NULL,
  main.participant = TRUE,
  max.matches = NULL,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAllUtterances_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getAllUtterances_+3A_participant.ids">participant.ids</code></td>
<td>
<p>A list of participant IDs to identify the utterances of.</p>
</td></tr>
<tr><td><code id="getAllUtterances_+3A_transcript.types">transcript.types</code></td>
<td>
<p>An optional list of transcript types to limit the results
to. If null, all transcript types will be searched.</p>
</td></tr>
<tr><td><code id="getAllUtterances_+3A_main.participant">main.participant</code></td>
<td>
<p>TRUE to search only main-participant utterances, FALSE to
search all utterances.</p>
</td></tr>
<tr><td><code id="getAllUtterances_+3A_max.matches">max.matches</code></td>
<td>
<p>The maximum number of matches to return, or null to return all.</p>
</td></tr>
<tr><td><code id="getAllUtterances_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame identifying matches, containing the following columns:
</p>

<ul>
<li><p><em>SearchName</em> A name based on the pattern &ndash; the same for all rows
</p>
</li>
<li><p><em>Number</em> Row number
</p>
</li>
<li><p><em>Transcript</em> Name of the transcript in which the match was found
</p>
</li>
<li><p><em>Line</em> The start offset of the utterance/line
</p>
</li>
<li><p><em>LineEnd</em> The end offset of the utterance/line
</p>
</li>
<li><p><em>MatchId</em> A unique ID for the matching target token
</p>
</li>
<li><p><em>Before.Match</em> Transcript text immediately before the match
</p>
</li>
<li><p><em>Text</em> Transcript text of the match
</p>
</li>
<li><p><em>Before.Match</em> Transcript text immediately after the match
</p>
</li>
<li><p><em>Target.word</em> Text of the target word token
</p>
</li>
<li><p><em>Target.word.start</em> Start offset of the target word token
</p>
</li>
<li><p><em>Target.word.end</em> End offset of the target word token
</p>
</li>
<li><p><em>Target.segment</em> Label of the target segment (only present if the segment
layer is included in the pattern)
</p>
</li>
<li><p><em>Target.segment.start</em> Start offset of the target segment (only present if the
segment layer is included in the pattern)
</p>
</li>
<li><p><em>Target.segment.end</em> End offset of the target segment (only present if the
segment layer is included in the pattern)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getParticipantIds">getParticipantIds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## get all utterances of the given participants
participant.ids &lt;- getParticipantIds(labbcat.url)[1:3]
results &lt;- getAllUtterances(labbcat.url, participant.ids)

## results$MatchId can be used to access results

## End(Not run)

</code></pre>

<hr>
<h2 id='getAnchors'>Gets the given anchors in the given transcript.</h2><span id='topic+getAnchors'></span>

<h3>Description</h3>

<p>Lists the given anchors in the given transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnchors(labbcat.url, id, anchor.id, page.length = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnchors_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getAnchors_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name)</p>
</td></tr>
<tr><td><code id="getAnchors_+3A_anchor.id">anchor.id</code></td>
<td>
<p>A vector of anchor IDs (or a string representing one anchor ID)</p>
</td></tr>
<tr><td><code id="getAnchors_+3A_page.length">page.length</code></td>
<td>
<p>In order to prevent timeouts when there are a large number of
matches or the network connection is slow, rather than retrieving anchors in one
big request, they are retrieved using many smaller requests. This parameter
controls the number of anchors retrieved per request.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of anchors, with members:
</p>

<ul>
<li><p><em>id</em> The annotation's unique ID,
</p>
</li>
<li><p><em>offset</em> The offset from the beginning (in seconds if it's a
transcript of a recording, or in characters if it's a text document)
</p>
</li>
<li><p><em>confidence</em> A rating from 0-100 of the confidence of the offset,
e.g. 10: default value, 50: force-aligned, 100: manually aligned
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+getAnnotations">getAnnotations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get the first 20 orthography tokens in UC427_ViktoriaPapp_A_ENG.eaf
orthography &lt;- getAnnotations(labbcat.url, "UC427_ViktoriaPapp_A_ENG.eaf", "orthography", 20, 0)

## Get the start anchors for the above tokens
word.starts &lt;- getAnchors(labbcat.url, "UC427_ViktoriaPapp_A_ENG.eaf", orthography$startId)

## End(Not run)

</code></pre>

<hr>
<h2 id='getAnnotations'>Gets the annotations on the given layer of the given transcript.</h2><span id='topic+getAnnotations'></span>

<h3>Description</h3>

<p>Returns the annotations on the given layer of the given transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnotations(
  labbcat.url,
  id,
  layer.id,
  max.ordinal = NULL,
  page.length = NULL,
  page.number = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnnotations_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getAnnotations_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name)</p>
</td></tr>
<tr><td><code id="getAnnotations_+3A_layer.id">layer.id</code></td>
<td>
<p>A layer ID</p>
</td></tr>
<tr><td><code id="getAnnotations_+3A_max.ordinal">max.ordinal</code></td>
<td>
<p>The maximum ordinal for the returned annotations. e.g. a max.ordinal
of 1 will ensure that only the first annotation for each parent is returned. If
max.ordinal is null, then all annotations are returned, regardless of their ordinal.</p>
</td></tr>
<tr><td><code id="getAnnotations_+3A_page.length">page.length</code></td>
<td>
<p>The maximum number of annotations to return, or null to return all</p>
</td></tr>
<tr><td><code id="getAnnotations_+3A_page.number">page.number</code></td>
<td>
<p>The zero-based page number to return, or null to return the first page</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of annotations, with members:
</p>

<ul>
<li><p><em>id</em> The annotation's unique ID
</p>
</li>
<li><p><em>layerId</em> The name of the layer it comes from
</p>
</li>
<li><p><em>label</em> The value of the annotation
</p>
</li>
<li><p><em>startId</em> The ID of the start anchor,
</p>
</li>
<li><p><em>endId</em> The ID of the end anchor,
</p>
</li>
<li><p><em>parentId</em> The ID of the parent annotation,
</p>
</li>
<li><p><em>ordinal</em> The ordinal of the annotation among its peers,
</p>
</li>
<li><p><em>confidence</em> A rating from 0-100 of the confidence of the label
e.g. 10: default value, 50: automatically generated, 100: manually annotated
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getTranscriptIds">getTranscriptIds</a></code>
<code><a href="#topic+getTranscriptIdsInCorpus">getTranscriptIdsInCorpus</a></code>
<code><a href="#topic+getTranscriptIdsWithParticipant">getTranscriptIdsWithParticipant</a></code>
<code><a href="#topic+countAnnotations">countAnnotations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all the orthography tokens in UC427_ViktoriaPapp_A_ENG.eaf
orthography &lt;- getAnnotations(labbcat.url, "UC427_ViktoriaPapp_A_ENG.eaf", "orthography")

## Get the first 20 orthography tokens in UC427_ViktoriaPapp_A_ENG.eaf
orthography &lt;- getAnnotations(labbcat.url, "UC427_ViktoriaPapp_A_ENG.eaf", "orthography", 20, 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='getAnnotatorDescriptor'>Gets annotator information.</h2><span id='topic+getAnnotatorDescriptor'></span>

<h3>Description</h3>

<p>Retrieve information about an annotator. Annotators are modules that perform different
annotation tasks. This function provides information about a given annotator, for
example the currently installed version of the module, what configuration parameters it
requires, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnotatorDescriptor(labbcat.url, annotator.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnnotatorDescriptor_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="getAnnotatorDescriptor_+3A_annotator.id">annotator.id</code></td>
<td>
<p>ID of the annotator module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The annotator info:
</p>

<ul>
<li><p><em>annotatorId</em> The annotators's unique ID
</p>
</li>
<li><p><em>version</em> The currently install version of the annotator.
</p>
</li>
<li><p><em>info</em> HTML-encoded description of the function of the annotator.
</p>
</li>
<li><p><em>infoText</em> A plain text version of $info (converted automatically).
</p>
</li>
<li><p><em>hasConfigWebapp</em> Determines whether the annotator includes a web-app for
installation or general configuration.
</p>
</li>
<li><p><em>configParameterInfo</em> An HTML-encoded definition of the installation config
parameters, including a list of all parameters, and the encoding of the parameter
string.
</p>
</li>
<li><p><em>configParameterInfoText</em> A plain text version of $configParameterInfo
(converted automatically). 
</p>
</li>
<li><p><em>hasTaskWebapp</em> Determines whether the annotator includes a web-app for
task parameter configuration.
</p>
</li>
<li><p><em>taskParameterInfo</em> An HTML-encoded definition of the task parameters,
including a list of all parameters, and the encoding of the parameter string.
</p>
</li>
<li><p><em>taskParameterInfoText</em> A plain text version of $taskParameterInfo
(converted automatically). 
</p>
</li>
<li><p><em>hasExtWebapp</em> Determines whether the annotator includes an extras web-app
which implements functionality for providing extra data or extending functionality
in an annotator-specific way.
</p>
</li>
<li><p><em>extApiInfo</em> An HTML-encoded document containing information about what
endpoints are published by the ext web-app.
</p>
</li>
<li><p><em>extApiInfoText</em> A plain text version of $extApiInfo
(converted automatically). 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+annotatorExt">annotatorExt</a></code>
<code><a href="#topic+newLayer">newLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get information about the BAS Annotator
basAnnotator &lt;- getAnnotatorDescriptor("https://labbcat.canterbury.ac.nz/demo/", "BASAnnotator")
cat(basAnnotator$infoText)

## End(Not run)

</code></pre>

<hr>
<h2 id='getAvailableMedia'>List the media available for the given transcript.</h2><span id='topic+getAvailableMedia'></span>

<h3>Description</h3>

<p>List the media available for the given transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAvailableMedia(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAvailableMedia_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getAvailableMedia_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of media files available for the given transcript, with members:
</p>

<ul>
<li><p><em>trackSuffix</em> The track suffix of the media
</p>
</li>
<li><p><em>mimeType</em> The MIME type of the file
</p>
</li>
<li><p><em>url</em> URL to the content of the file
</p>
</li>
<li><p><em>name</em> Name of the file
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+getTranscriptIds">getTranscriptIds</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## List the media files available for BR2044_OllyOhlson.eaf
media &lt;- getAvailableMedia(labbcat.url, "BR2044_OllyOhlson.eaf")

## End(Not run)

</code></pre>

<hr>
<h2 id='getCorpusIds'>Gets a list of corpus IDs.</h2><span id='topic+getCorpusIds'></span>

<h3>Description</h3>

<p>Returns a list of corpora in the given 'LaBB-CAT' instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCorpusIds(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCorpusIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of corpus IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List corpora
corpora &lt;- getCorpusIds("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getDeserializerDescriptors'>Lists the descriptors of all registered deserializers.</h2><span id='topic+getDeserializerDescriptors'></span>

<h3>Description</h3>

<p>Returns a list of deserializers, which are modules that import transcriptions and
annotation structures from a specific file format, e.g. Praat TextGrid, plain text, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDeserializerDescriptors(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDeserializerDescriptors_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of serializers, each including the following information:
</p>

<ul>
<li><p><em>name</em> The name of the format.
</p>
</li>
<li><p><em>version</em> The installed version of the serializer module.
</p>
</li>
<li><p><em>fileSuffixes</em> The normal file name suffixes (extensions) of the files.,
</p>
</li>
<li><p><em>mimeType</em> The MIME type of the format, i.e. the value to use as the
<em>mimeType</em> parameter of <a href="#topic+getFragments">getFragments</a>,
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List file upload formats supported
formats &lt;- getDeserializerDescriptors("https://labbcat.canterbury.ac.nz/demo/")

## can we upload as plain text?
plainTextSupported &lt;- "text/plain" %in% formats$mimeType

## End(Not run)

</code></pre>

<hr>
<h2 id='getDictionaries'>List the dictionaries available.</h2><span id='topic+getDictionaries'></span>

<h3>Description</h3>

<p>List the dictionaries available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDictionaries(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDictionaries_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of layer manager IDs, each of which containing a list of
dictionaries that the layer manager makes available.
</p>


<h3>See Also</h3>

<p><a href="#topic+getDictionaryEntries">getDictionaryEntries</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List the dictionaries available
dictionaries &lt;- getDictionaries("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getDictionaryEntries'>Lookup entries in a dictionary.</h2><span id='topic+getDictionaryEntries'></span>

<h3>Description</h3>

<p>Lookup entries in a dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDictionaryEntries(labbcat.url, manager.id, dictionary.id, keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDictionaryEntries_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getDictionaryEntries_+3A_manager.id">manager.id</code></td>
<td>
<p>The layer manager ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="getDictionaryEntries_+3A_dictionary.id">dictionary.id</code></td>
<td>
<p>The ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="getDictionaryEntries_+3A_keys">keys</code></td>
<td>
<p>A list of keys (words) identifying entries to look up</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the keys and their dictionary entries, if any.
</p>


<h3>See Also</h3>

<p><a href="#topic+getDictionaries">getDictionaries</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

keys &lt;- c("the", "quick", "brown", "fox")

## get the pronunciations according to CELEX
entries &lt;- getDictionaryEntries(labbcat.url, "CELEX-EN", "Phonology (wordform)", keys)

## End(Not run)

</code></pre>

<hr>
<h2 id='getFragmentAnnotations'>Gets annotations in fragments.</h2><span id='topic+getFragmentAnnotations'></span>

<h3>Description</h3>

<p>This function gets annotations between given start/end times on given layers. If more
than one annotation matches, labels are concatentated together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFragmentAnnotations(
  labbcat.url,
  transcript.id,
  participant.id,
  start,
  end,
  layer.ids,
  sep = " ",
  partial.containment = FALSE,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFragmentAnnotations_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_transcript.id">transcript.id</code></td>
<td>
<p>The transcript ID (transcript name) of the sound recording, or
a vector of transcript IDs.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_participant.id">participant.id</code></td>
<td>
<p>The participant ID of the annotations, or a vector of participant IDs.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_start">start</code></td>
<td>
<p>The start time in seconds, or a vector of start times.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_end">end</code></td>
<td>
<p>The end time in seconds, or a vector of end times.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_sep">sep</code></td>
<td>
<p>The separator to use when concatenating labels when multiple annotations are
in the given interval.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_partial.containment">partial.containment</code></td>
<td>
<p>Whether to include annotations that are only partially
contained in the given interval.</p>
</td></tr>
<tr><td><code id="getFragmentAnnotations_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns for each layer in layer.ids:
</p>

<ul>
<li><p>The annotation labels concatenated together
</p>
</li>
<li><p>The start time of the first annotation
</p>
</li>
<li><p>The end time of the last annotation
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+getFragments">getFragments</a>
</p>
<p><a href="#topic+getSoundFragments">getSoundFragments</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get some span-layer intervales
topics &lt;- getMatches(labbcat.url, list(topic = ".*quake.*"))

## Get concantenated word tokens for each topic annotation
topic.tokens &lt;- getFragmentAnnotations(
    labbcat.url, topics$Transcript, topics$Participant, topics$topic.start, topics$topic.end,
    c("word"))

## End(Not run)
</code></pre>

<hr>
<h2 id='getFragments'>Gets transcript fragments in a given format.</h2><span id='topic+getFragments'></span>

<h3>Description</h3>

<p>This function gets fragments of transcripts from 'LaBB-CAT', 
converted to a given format (by default, Praat TextGrid).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFragments(
  labbcat.url,
  id,
  start,
  end,
  layer.ids,
  mime.type = "text/praat-textgrid",
  path = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFragments_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getFragments_+3A_id">id</code></td>
<td>
<p>The transcript ID (transcript name) of the sound recording, or
a vector of transcript IDs.</p>
</td></tr>
<tr><td><code id="getFragments_+3A_start">start</code></td>
<td>
<p>The start time in seconds, or a vector of start times.</p>
</td></tr>
<tr><td><code id="getFragments_+3A_end">end</code></td>
<td>
<p>The end time in seconds, or a vector of end times.</p>
</td></tr>
<tr><td><code id="getFragments_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs.</p>
</td></tr>
<tr><td><code id="getFragments_+3A_mime.type">mime.type</code></td>
<td>
<p>Optional content-type - &quot;text/praat-textgrid&quot; is the default, but your
LaBB-CAT installation may support other formats, which can be discovered using
<a href="#topic+getSerializerDescriptors">getSerializerDescriptors</a>.</p>
</td></tr>
<tr><td><code id="getFragments_+3A_path">path</code></td>
<td>
<p>Optional path to directory where the files should be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>NB</em> Although many formats will generate exactly one file for each interval
(e.g. mime.type=text/praat-textgrid), this is not guaranted; some formats generate
a single file or a fixed collection of files regardless of how many fragments there are.
</p>


<h3>Value</h3>

<p>The name of the file, which is saved in the current
directory, or a list of names of files, if multiple
id's/start's/end's were specified 
</p>
<p>If a list of files is returned, they are in the order that they
were returned by the server, which *should* be the order that
they were specified in the id/start/end lists.
</p>


<h3>See Also</h3>

<p><a href="#topic+getSerializerDescriptors">getSerializerDescriptors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get the 5 seconds starting from 10s after the beginning of a recording
textgrid.file &lt;- getFragments(labbcat.url, "AP2505_Nelson.eaf", 10.0, 15.0,
    c("transcript", "phonemes"), path="samples") 

## Load some search results previously exported from LaBB-CAT
results &lt;- read.csv("results.csv", header=T)

## Get a list of fragment TextGrids, including the utterances, transcript, and phonemes layers
textgrid.files &lt;- getFragments(
    labbcat.url, results$Transcript, results$Line, results$LineEnd,
    c("utterance", "word", "phonemes"))

## Get a list of fragment TextGrids
textgrid.files &lt;- getFragments(
    labbcat.url, results$Transcript, results$Line, results$LineEnd)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGraphIds'>Deprecated synonym for getTranscriptIds.</h2><span id='topic+getGraphIds'></span>

<h3>Description</h3>

<p>Returns a list of graph IDs (i.e. transcript names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGraphIds(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGraphIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of graph IDs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTranscriptIds">getTranscriptIds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List all transcripts
transcripts &lt;- getGraphIds("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getGraphIdsInCorpus'>Deprecated synonym for getTranscriptIdsInCorpus.</h2><span id='topic+getGraphIdsInCorpus'></span>

<h3>Description</h3>

<p>Returns a list of corpora in the given 'LaBB-CAT' instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGraphIdsInCorpus(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGraphIdsInCorpus_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getGraphIdsInCorpus_+3A_id">id</code></td>
<td>
<p>The ID (name) of the corpus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of corpus IDs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getGraphIdsInCorpus">getGraphIdsInCorpus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List transcripts in the QB corpus
transcripts &lt;- getGraphIdsInCorpus("https://labbcat.canterbury.ac.nz/demo/", "QB")

## End(Not run)

</code></pre>

<hr>
<h2 id='getGraphIdsWithParticipant'>Deprecated synonym for getTranscriptIdsWithParticipant.</h2><span id='topic+getGraphIdsWithParticipant'></span>

<h3>Description</h3>

<p>Returns a list of IDs of graphs (i.e. transcript names) that include
the given participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGraphIdsWithParticipant(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGraphIdsWithParticipant_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getGraphIdsWithParticipant_+3A_id">id</code></td>
<td>
<p>A participant ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of graph IDs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTranscriptIdsWithParticipant">getTranscriptIdsWithParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## List transcripts in which UC427_ViktoriaPapp_A_ENG speaks
transcripts &lt;- getGraphIdsWithParticipant(labbcat.url, "UC427_ViktoriaPapp_A_ENG")

## End(Not run)

</code></pre>

<hr>
<h2 id='getId'>Gets the store's ID.</h2><span id='topic+getId'></span>

<h3>Description</h3>

<p>The store's ID - i.e. the ID of the 'LaBB-CAT' instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getId(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getId_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The annotation store's ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get ID of LaBB-CAT instance
instance.id &lt;- getId("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getLayer'>Gets a layer definition.</h2><span id='topic+getLayer'></span>

<h3>Description</h3>

<p>Gets a layer definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLayer(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLayer_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getLayer_+3A_id">id</code></td>
<td>
<p>ID of the layer to get the definition for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The definition of the given layer, with members:
</p>

<ul>
<li><p><em>id</em> The layer's unique ID
</p>
</li>
<li><p><em>parentId</em> The layer's parent layer ID
</p>
</li>
<li><p><em>description</em> The description of the layer
</p>
</li>
<li><p><em>alignment</em> The layer's alignment - 0 for none, 1 for point alignment, 2 for interval alignment
</p>
</li>
<li><p><em>peers</em> Whether children have peers or not
</p>
</li>
<li><p><em>peersOverlap</em> Whether child peers can overlap or not
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>saturated</em> Whether children must temporally fill the entire parent duration (true) or not (false)
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>type</em> The type for labels on this layer
</p>
</li>
<li><p><em>validLabels</em> List of valid label values for this layer
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getLayerIds">getLayerIds</a></code>
<code><a href="#topic+getLayers">getLayers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get the definition of the orthography layer
orthography.layer &lt;- getLayer("https://labbcat.canterbury.ac.nz/demo/", "orthography")

## End(Not run)

</code></pre>

<hr>
<h2 id='getLayerIds'>Gets a list of layer IDs.</h2><span id='topic+getLayerIds'></span>

<h3>Description</h3>

<p>Layer IDs are annotation 'types'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLayerIds(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLayerIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of layer IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get names of all layers
layer.ids &lt;- getLayerIds("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getLayers'>Gets a list of layer definitions.</h2><span id='topic+getLayers'></span>

<h3>Description</h3>

<p>Gets a list of layer definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLayers(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLayers_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of layer definitions, with members:
</p>

<ul>
<li><p><em>id</em> The layer's unique ID
</p>
</li>
<li><p><em>parentId</em> The layer's parent layer ID
</p>
</li>
<li><p><em>description</em> The description of the layer
</p>
</li>
<li><p><em>alignment</em> The layer's alignment - 0 for none, 1 for point alignment, 2 for interval alignment
</p>
</li>
<li><p><em>peers</em> Whether children have peers or not
</p>
</li>
<li><p><em>peersOverlap</em> Whether child peers can overlap or not
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>saturated</em> Whether children must temporally fill the entire parent duration (true) or not (false)
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>type</em> The type for labels on this layer
</p>
</li>
<li><p><em>validLabels</em> List of valid label values for this layer
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getLayerIds">getLayerIds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get definitions of all layers
layers &lt;- getLayers("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchAlignments'>Gets temporal alignments of matches on a given layer.</h2><span id='topic+getMatchAlignments'></span>

<h3>Description</h3>

<p>Gets labels and start/end offsets of annotations on a given layer, identified by given
match IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchAlignments(
  labbcat.url,
  match.ids,
  layer.ids,
  target.offset = 0,
  annotations.per.layer = 1,
  anchor.confidence.min = 50,
  include.match.ids = FALSE,
  page.length = 1000,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchAlignments_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_match.ids">match.ids</code></td>
<td>
<p>A vector of annotation IDs, e.g. the MatchId column, or the URL column,
of a results set.</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs.</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_target.offset">target.offset</code></td>
<td>
<p>The distance from the original target of the match, e.g.
</p>

<ul>
<li><p><em>0</em> &ndash; find annotations of the match target itself,
</p>
</li>
<li><p><em>1</em> &ndash; find annotations of the token immediately <em>after</em> match target
</p>
</li>
<li><p><em>-1</em> &ndash; find annotations of the token immediately <em>before</em> match target
</p>
</li></ul>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_annotations.per.layer">annotations.per.layer</code></td>
<td>
<p>The number of annotations on the given layer to
retrieve. In most cases, there's only one annotation available. However, tokens
may, for example, be annotated with &lsquo;all possible phonemic transcriptions&rsquo;, in which
case using a value of greater than 1 for this parameter provides other phonemic
transcriptions, for tokens that have more than one.</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_anchor.confidence.min">anchor.confidence.min</code></td>
<td>
<p>The minimum confidence for alignments, e.g.
</p>

<ul>
<li><p><em>0</em> &ndash; return all alignments, regardless of confidence;
</p>
</li>
<li><p><em>50</em> &ndash; return only alignments that have been at least automatically aligned;
</p>
</li>
<li><p><em>100</em> &ndash; return only manually-set alignments.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_include.match.ids">include.match.ids</code></td>
<td>
<p>Whether or not the data frame returned includes the original
MatchId column or not.</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_page.length">page.length</code></td>
<td>
<p>In order to prevent timeouts when there are a large number of
matches or the network connection is slow, rather than retrieving matches in one
big request, they are retrieved using many smaller requests. This parameter
controls the number of results retrieved per request.</p>
</td></tr>
<tr><td><code id="getMatchAlignments_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can specify a threshold for confidence in the alignment, which is a value from 0
(not aligned) to 100 (manually aligned). The default is 50 (automatically aligned), so
only alignments that have been at least automatically aligned are specified. For cases
where there's a token but its alignment confidence falls below the threshold, a label
is returned, but the start/end times are NA.
</p>


<h3>Value</h3>

<p>A data frame with label, start time, and end time, for each layer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMatches">getMatches</a></code>
<code><a href="#topic+getMatchLabels">getMatchLabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get the segment following the token, with alignment if it's been manually aligned
following.segment &lt;- getMatchAlignments(labbcat.url, results$MatchId, "segment",
    target.offset=1, anchor.confidence.min=100)

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatches'>Search for tokens.</h2><span id='topic+getMatches'></span>

<h3>Description</h3>

<p>Searches through transcripts for tokens matching the given pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatches(
  labbcat.url,
  pattern,
  participant.expression = NULL,
  transcript.expression = NULL,
  main.participant = TRUE,
  aligned = NULL,
  matches.per.transcript = NULL,
  words.context = 0,
  max.matches = NULL,
  overlap.threshold = NULL,
  anchor.confidence.min = NULL,
  page.length = 1000,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatches_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatches_+3A_pattern">pattern</code></td>
<td>
<p>An object representing the pattern to search for.
</p>
<p>This can be:
</p>

<ul>
<li><p>A string, representing a search of the orthography layer - spaces are
taken to be word boundaries
</p>
</li>
<li><p>A single named list, representing a one-column search - names are taken to be layer IDs
</p>
</li>
<li><p>A list of named lists, representing a multi-column search - the outer list
represents the columns of the search matrix where each column 'immediately
follows' the previous, and the names of the inner lists are taken to be layer IDs 
</p>
</li>
<li><p>A named list fully replicating the structure of the search matrix in the
LaBB-CAT browser interface, with one element called &ldquo;columns&rdquo;, containing a
named list for each column.
</p>
<p>Each element in the &ldquo;columns&rdquo; named list contains an element named &ldquo;layers&rdquo;, whose
value is a named list for patterns to match on each layer, and optionally an
element named &ldquo;adj&rdquo;, whose value is a number representing the maximum distance, in
tokens, between this column and the next column - if &ldquo;adj&rdquo; is not specified, the
value defaults to 1, so tokens are contiguous.
</p>
<p>Each element in the &ldquo;layers&rdquo; named list is named after the layer it matches, and the
value is a named list with the following possible elements:
</p>

<ul>
<li><p><em>pattern</em>  A regular expression to match against the label
</p>
</li>
<li><p><em>min</em>  An inclusive minimum numeric value for the label
</p>
</li>
<li><p><em>max</em>  An exclusive maximum numeric value for the label
</p>
</li>
<li><p><em>not</em>  TRUE to negate the match
</p>
</li>
<li><p><em>anchorStart</em>  TRUE to anchor to the start of the annotation on this layer
(i.e. the matching word token will be the first at/after the start of the matching
annotation on this layer)
</p>
</li>
<li><p><em>anchorEnd</em>  TRUE to anchor to the end of the annotation on this layer
(i.e. the matching word token will be the last before/at the end of the matching
annotation on this layer)
</p>
</li>
<li><p><em>target</em>  TRUE to make this layer the target of the search; the
results will contain one row for each match on the target layer
</p>
</li></ul>


</li></ul>

<p>Examples of valid pattern objects include:
</p>
<pre>
## the word 'the' followed immediately by a word starting with an orthographic vowel
pattern &lt;- "the [aeiou]"

## a word spelt with "k" but pronounced "n" word initially
pattern &lt;- list(orthography = "k.*", phonemes = "n.*")

## the word 'the' followed immediately by a word starting with an phonemic vowel
pattern &lt;- list(
    list(orthography = "the"),
    list(phonemes = "[cCEFHiIPqQuUV0123456789~#\$@].*"))

## the word 'the' followed immediately or with one intervening word by
## a hapax legomenon (word with a frequency of 1) that doesn't start with a vowel
pattern &lt;- list(columns = list(
    list(layers = list(
           orthography = list(pattern = "the")),
         adj = 2),
    list(layers = list(
           phonemes = list(not = TRUE, pattern = "[cCEFHiIPqQuUV0123456789~#\$@].*"),
           frequency = list(max = "2")))))
</pre></td></tr>
<tr><td><code id="getMatches_+3A_participant.expression">participant.expression</code></td>
<td>
<p>An optional participant query expression for identifying
participants to search the utterances of. This should be the output of
<a href="#topic+expressionFromIds">expressionFromIds</a>, <a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a>,
or <a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a>, or more than one concatentated together
and delimited by ' &amp;&amp; '. If not supplied, utterances of all participants will be searched.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_transcript.expression">transcript.expression</code></td>
<td>
<p>An optional transript query expression for identifying
transcripts to search in. This should be the output of <a href="#topic+expressionFromIds">expressionFromIds</a>,
<a href="#topic+expressionFromTranscriptTypes">expressionFromTranscriptTypes</a>, <a href="#topic+expressionFromAttributeValue">expressionFromAttributeValue</a>,
or <a href="#topic+expressionFromAttributeValues">expressionFromAttributeValues</a>, or more than one concatentated together
and delimited by ' &amp;&amp; '. If not supplied, all transcripts will be searched.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_main.participant">main.participant</code></td>
<td>
<p>TRUE to search only main-participant utterances, FALSE to
search all utterances.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_aligned">aligned</code></td>
<td>
<p>This parameter is deprecated and will be removed in future versions;
please use anchor.confidence.min=50 instead.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_matches.per.transcript">matches.per.transcript</code></td>
<td>
<p>Optional maximum number of matches per transcript to
return. NULL means all matches.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_words.context">words.context</code></td>
<td>
<p>Number of words context to include in the &lsquo;Before.Match&rsquo; and
&lsquo;After.Match&rsquo; columns in the results.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_max.matches">max.matches</code></td>
<td>
<p>The maximum number of matches to return, or null to return all.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_overlap.threshold">overlap.threshold</code></td>
<td>
<p>The percentage overlap with other utterances before
simultaneous speech is excluded, or null to include overlapping speech.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_anchor.confidence.min">anchor.confidence.min</code></td>
<td>
<p>The minimum confidence for alignments, e.g.
</p>

<ul>
<li><p><em>0</em> &ndash; return all alignments, regardless of confidence;
</p>
</li>
<li><p><em>50</em> &ndash; return only alignments that have been at least automatically aligned;
</p>
</li>
<li><p><em>100</em> &ndash; return only manually-set alignments.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getMatches_+3A_page.length">page.length</code></td>
<td>
<p>In order to prevent timeouts when there are a large number of
matches or the network connection is slow, rather than retrieving matches in one
big request, they are retrieved using many smaller requests. This parameter
controls the number of results retrieved per request.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame identifying matches, containing the following columns:
</p>

<ul>
<li><p><em>SearchName</em> A name based on the pattern &ndash; the same for all rows
</p>
</li>
<li><p><em>MatchId</em> A unique ID for the matching target token
</p>
</li>
<li><p><em>Transcript</em> Name of the transcript in which the match was found
</p>
</li>
<li><p><em>Participant</em> Name of the speaker
</p>
</li>
<li><p><em>Corpus</em> The corpus of the transcript
</p>
</li>
<li><p><em>Line</em> The start offset of the utterance/line
</p>
</li>
<li><p><em>LineEnd</em> The end offset of the utterance/line
</p>
</li>
<li><p><em>Before.Match</em> Transcript text immediately before the match
</p>
</li>
<li><p><em>Text</em> Transcript text of the match
</p>
</li>
<li><p><em>After.Match</em> Transcript text immediately after the match
</p>
</li>
<li><p><em>Number</em> Row number
</p>
</li>
<li><p><em>URL</em> URL of the first matching word token
</p>
</li>
<li><p><em>Target.word</em> Text of the target word token
</p>
</li>
<li><p><em>Target.word.start</em> Start offset of the target word token
</p>
</li>
<li><p><em>Target.word.end</em> End offset of the target word token
</p>
</li>
<li><p><em>Target.segment</em> Label of the target segment (only present if the segment
layer is included in the pattern)
</p>
</li>
<li><p><em>Target.segment.start</em> Start offset of the target segment (only present if the
segment layer is included in the pattern)
</p>
</li>
<li><p><em>Target.segment.end</em> End offset of the target segment (only present if the
segment layer is included in the pattern)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getFragments">getFragments</a></code>
</p>
<p><code><a href="#topic+getSoundFragments">getSoundFragments</a></code>
</p>
<p><code><a href="#topic+getMatchLabels">getMatchLabels</a></code>
</p>
<p><code><a href="#topic+getMatchAlignments">getMatchAlignments</a></code>
</p>
<p><code><a href="#topic+processWithPraat">processWithPraat</a></code>
</p>
<p><code><a href="#topic+getParticipantIds">getParticipantIds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## the word 'the' followed immediately by a word starting with an orthographic vowel
theThenOrthVowel &lt;- getMatches(labbcat.url, "the [aeiou]")

## a word spelt with "k" but pronounced "n" word initially
knWords &lt;- getMatches(labbcat.url, list(orthography = "k.*", phonemes = "n.*"))

## the word 'the' followed immediately by a word starting with an phonemic vowel
theThenPhonVowel &lt;- getMatches(
  labbcat.url, list(
    list(orthography = "the"),
    list(phonemes = "[cCEFHiIPqQuUV0123456789~#\\$@].*")))

## the word 'the' followed immediately or with one intervening word by
## a hapax legomenon (word with a frequency of 1) that doesn't start with a vowel
results &lt;- getMatches(
  labbcat.url, list(columns = list(
    list(layers = list(
           orthography = list(pattern = "the")),
         adj = 2),
    list(layers = list(
           phonemes = list(not=TRUE, pattern = "[cCEFHiIPqQuUV0123456789~#\\$@].*"),
           frequency = list(max = "2"))))),
  overlap.threshold = 5)

## all tokens of the KIT vowel, from the interview or monologue
## of the participants AP511_MikeThorpe and BR2044_OllyOhlson
results &lt;- getMatches(labbcat.url, list(segment="I"),
  participant.expression = expressionFromIds(c("AP511_MikeThorpe","BR2044_OllyOhlson")),
  transcript.expression = expressionFromTranscriptTypes(c("interview","monologue")))

## all tokens of the KIT vowel for male speakers who speak English
results &lt;- getMatches(labbcat.url, list(segment="I"),
  participant.expression = paste(
    expressionFromAttributeValue("participant_gender", "M"),
    expressionFromAttributeValues("participant_languages_spoken", "en"),
    sep=" &amp;&amp; "))

## results$Text is the text that matched
## results$MatchId can be used to access results using other functions

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchingAnnotations'>Gets a list of annotations that match a particular pattern.</h2><span id='topic+getMatchingAnnotations'></span>

<h3>Description</h3>

<p>Returns the annotations in the corpus that match the given expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchingAnnotations(
  labbcat.url,
  expression,
  page.length = NULL,
  page.number = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchingAnnotations_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchingAnnotations_+3A_expression">expression</code></td>
<td>
<p>An expression that determines which annotations match. This must
match by either id or layer.id.
The expression language is currently not well defined, but is based on JavaScript
syntax. e.g.
</p>

<ul>
<li><p>id == 'ew_0_456'
</p>
</li>
<li><p>['ew_2_456', 'ew_2_789', 'ew_2_101112'].includes(id)
</p>
</li>
<li><p>layerId == 'orthography' &amp;&amp; !/th[aeiou].+/.test(label)
</p>
</li>
<li><p>graph.id == 'AdaAicheson-01.trs' &amp;&amp; layer.id == 'orthography' &amp;&amp;
start.offset &amp;gt; 10.5 
</p>
</li>
<li><p>layer.id == 'utterance' &amp;&amp; all('word').includes('ew_0_456')
</p>
</li>
<li><p>layerId = 'utterance' &amp;&amp; labels('orthography').includes('foo')
</p>
</li>
<li><p>layerId = 'utterance' &amp;&amp; labels('participant').includes('Ada')
</p>
</li></ul>
</td></tr>
<tr><td><code id="getMatchingAnnotations_+3A_page.length">page.length</code></td>
<td>
<p>The maximum number of IDs to return, or null to return all</p>
</td></tr>
<tr><td><code id="getMatchingAnnotations_+3A_page.number">page.number</code></td>
<td>
<p>The zero-based page number to return, or null to return the first page</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results can be exhaustive, by omitting page.length and
page.number, or they  can be a subset (a 'page') of results, by
given page.length and page.number values.
</p>


<h3>Value</h3>

<p>A list of annotations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+countMatchingAnnotations">countMatchingAnnotations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## get all topic annotations whose label includes the word 'quake'
quake.topics &lt;- getMatchingAnnotations(
                   labbcat.url, "layer.id == 'topic' &amp;&amp; /.*quake.*/.test(label)")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchingGraphIds'>Deprecated synonym for getMatchingTranscriptIds.</h2><span id='topic+getMatchingGraphIds'></span>

<h3>Description</h3>

<p>Gets a list of IDs of graphs (i.e. transcript names) that match a
particular pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchingGraphIds(
  labbcat.url,
  expression,
  page.length = NULL,
  page.number = NULL,
  order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchingGraphIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchingGraphIds_+3A_expression">expression</code></td>
<td>
<p>An expression that determines which graphs match</p>
</td></tr>
<tr><td><code id="getMatchingGraphIds_+3A_page.length">page.length</code></td>
<td>
<p>The maximum number of IDs to return, or null to return all</p>
</td></tr>
<tr><td><code id="getMatchingGraphIds_+3A_page.number">page.number</code></td>
<td>
<p>The zero-based page number to return, or null to return the first page</p>
</td></tr>
<tr><td><code id="getMatchingGraphIds_+3A_order">order</code></td>
<td>
<p>An expression that determines the order the graphs are
listed in - if specified, this must include the keyword 'ASC' for ascending or 'DESC'
for descending order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results can be exhaustive, by omitting pageLength and
page.number, or they  can be a subset (a 'page') of results, by
given pageLength and page.number values.
</p>
<p>The order of the list can be specified.  If ommitted, the graphs
are listed in ID order.
</p>
<p>The expression language is currently not well defined, but is based on JavaScript
syntax.
</p>

<ul>
<li><p>The <em>labels</em> function can be used to represent a list of all the annotation
labels on a given layer. For example, each transcript can have multiple
participants, so the participant labels (names) are represented by:
<em>labels('participant')</em>
</p>
</li>
<li><p>Use the <em>includes</em> function on a list to test whether the list contains a
given element. e.g. to match transcripts that include the participant 'Joe' use:
<em>labels('participant').includes('Joe')</em>
</p>
</li>
<li><p>Use the <em>first</em> function to identify the first (or the only) annotation on
a given layer. e.g. the annotation representing the transcript's corpus is:
<em>first('corpus')</em>
</p>
</li>
<li><p>Single annotations have various attributes, including 'id', 'label', 'ordinal', etc.
e.g. the name of the transcript's corpus is:
<em>first('corpus').label</em>
</p>
</li>
<li><p>Regular expressions can be matched by using expressions like
'/regex/.test(str)', e.g. to test if the ID starts with 'BR' use:
<em>/^BR.+/.test(id)</em>
or to test if the transcript's corpus includes a B use:
<em>/.*B.*/.test(first('corpus').label)</em>
</p>
</li></ul>

<p>Expressions such as those in the examples can be used.
</p>


<h3>Value</h3>

<p>A list of graph IDs (i.e. transcript names)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all transcripts whose names start with "BR"
transcripts &lt;- getMatchingGraphIds(labbcat.url, "/^BR.+/.test(id)")

## Get the first twenty transcripts in the "QB" corpus
transcripts &lt;- getMatchingGraphIds(
        labbcat.url, "first('corpus').label = 'QB'", 20, 0)

## Get the second transcript that has "QB247_Jacqui" as a speaker
transcripts &lt;- getMatchingGraphIds(
        labbcat.url, "labels('participant').includes('QB247_Jacqui')", 1, 1)

## Get all transcripts in the QB corpus whose names start with "BR"
## in word-count order 
transcripts &lt;- getMatchingGraphIds(
        labbcat.url, "first('corpus').label = 'QB' &amp;&amp; /^BR.+/.test(id)", 
        order="first('transcript_word_count').label ASC")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchingParticipantIds'>Gets a list of IDs of participants that match a particular pattern.</h2><span id='topic+getMatchingParticipantIds'></span>

<h3>Description</h3>

<p>Gets a list of IDs of participants that match a particular pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchingParticipantIds(
  labbcat.url,
  expression,
  page.length = NULL,
  page.number = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchingParticipantIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchingParticipantIds_+3A_expression">expression</code></td>
<td>
<p>An expression that determines which participants match</p>
</td></tr>
<tr><td><code id="getMatchingParticipantIds_+3A_page.length">page.length</code></td>
<td>
<p>The maximum number of IDs to return, or null to return all</p>
</td></tr>
<tr><td><code id="getMatchingParticipantIds_+3A_page.number">page.number</code></td>
<td>
<p>The zero-based page number to return, or null to return the first page</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results can be exhaustive, by omitting page.length and
page.number, or they  can be a subset (a 'page') of results, by
given page.length and page.number values.
</p>
<p>The expression language is currently not well defined, but is based on JavaScript
syntax.
</p>

<ul>
<li><p>The <em>labels</em> function can be used to represent a list of all the annotation
labels on a given layer. For example, each participant can have multiple
corpora, so the corpus labels (names) are represented by:  
<em>labels('corpus')</em>
</p>
</li>
<li><p>Use the <em>includes</em> function on a list to test whether the list contains a
given element. e.g. to match participants that include the corpus 'QB' use:  
<em>labels('corpus').includes('QB')</em>
</p>
</li>
<li><p>Use the <em>first</em> function to identify the first (or the only) annotation on
a given layer. e.g. the annotation representing the participant's gender is:  
<em>first('participant_gender')</em>
</p>
</li>
<li><p>Single annotations have various attributes, including 'id', 'label', 'ordinal', etc.
e.g. the label of the participant's gender is:  
<em>first('participant_gender').label</em>
</p>
</li>
<li><p>Regular expressions can be matched by using expressions like
'/regex/.test(str)', e.g. to test if the ID starts with 'BR' use:  
<em>/^BR.+/.test(id)</em>  
or to test if the participant's gender includes 'binary' use:  
<em>/.*binary.*/.test(first('participant_gender').label)</em>
</p>
</li></ul>

<p>Expressions such as those in the examples can be used.
</p>


<h3>Value</h3>

<p>A list of paricipant IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all participants whose IDs start with "BR"
participants &lt;- getMatchingParticipantIds(labbcat.url, "/^BR.+/.test(id)")

## Get the first twenty transcripts in the "QB" corpus
participants &lt;- getMatchingParticipantIds(
        labbcat.url, "labels('corpus').includes('QB')", 20, 0)

## Get all participants in the "QB" corpus that have "Jacqui" as part of the ID
participants &lt;- getMatchingTranscriptParticipantIds(
        labbcat.url, "labels('corpus').includes('QB') &amp;&amp; /^BR.+/.test(id)")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchingTranscriptIds'>Gets a list of IDs of transcripts that match a particular pattern.</h2><span id='topic+getMatchingTranscriptIds'></span>

<h3>Description</h3>

<p>Gets a list of IDs of transcripts (i.e. transcript names) that match a
particular pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchingTranscriptIds(
  labbcat.url,
  expression,
  page.length = NULL,
  page.number = NULL,
  order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchingTranscriptIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchingTranscriptIds_+3A_expression">expression</code></td>
<td>
<p>An expression that determines which transcripts match</p>
</td></tr>
<tr><td><code id="getMatchingTranscriptIds_+3A_page.length">page.length</code></td>
<td>
<p>The maximum number of IDs to return, or null to return all</p>
</td></tr>
<tr><td><code id="getMatchingTranscriptIds_+3A_page.number">page.number</code></td>
<td>
<p>The zero-based page number to return, or null to return the first page</p>
</td></tr>
<tr><td><code id="getMatchingTranscriptIds_+3A_order">order</code></td>
<td>
<p>An expression that determines the order the transcripts are
listed in - if specified, this must include the keyword 'ASC' for ascending or 'DESC'
for descending order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results can be exhaustive, by omitting page.length and
page.number, or they  can be a subset (a 'page') of results, by
given page.length and page.number values.
</p>
<p>The order of the list can be specified.  If ommitted, the transcripts
are listed in ID order.
</p>
<p>The expression language is currently not well defined, but is based on JavaScript
syntax.
</p>

<ul>
<li><p>The <em>labels</em> function can be used to represent a list of all the annotation
labels on a given layer. For example, each transcript can have multiple
participants, so the participant labels (names) are represented by:  
<em>labels('participant')</em>
</p>
</li>
<li><p>Use the <em>includes</em> function on a list to test whether the list contains a
given element. e.g. to match transcripts that include the participant 'Joe' use:  
<em>labels('participant').includes('Joe')</em>
</p>
</li>
<li><p>Use the <em>first</em> function to identify the first (or the only) annotation on
a given layer. e.g. the annotation representing the transcript's corpus is:  
<em>first('corpus')</em>
</p>
</li>
<li><p>Single annotations have various attributes, including 'id', 'label', 'ordinal', etc.
e.g. the name of the transcript's corpus is:  
<em>first('corpus').label</em>
</p>
</li>
<li><p>Regular expressions can be matched by using expressions like
'/regex/.test(str)', e.g. to test if the ID starts with 'BR' use:  
<em>/^BR.+/.test(id)</em>  
or to test if the transcript's corpus includes a B use:  
<em>/.*B.*/.test(first('corpus').label)</em>
</p>
</li></ul>

<p>Expressions such as those in the examples can be used.
</p>


<h3>Value</h3>

<p>A list of transcript IDs (i.e. transcript names)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all transcripts whose names start with "BR"
transcripts &lt;- getMatchingTranscriptIds(labbcat.url, "/^BR.+/.test(id)")

## Get the first twenty transcripts in the "QB" corpus
transcripts &lt;- getMatchingTranscriptIds(
        labbcat.url, "first('corpus').label = 'QB'", 20, 0)

## Get the second transcript that has "QB247_Jacqui" as a speaker
transcripts &lt;- getMatchingTranscriptIds(
        labbcat.url, "labels('participant').includes('QB247_Jacqui')", 1, 1)

## Get all transcripts in the QB corpus whose names start with "BR"
## in word-count order 
transcripts &lt;- getMatchingTranscriptIds(
        labbcat.url, "first('corpus').label = 'QB' &amp;&amp; /^BR.+/.test(id)",
        order="first('transcript_word_count').label ASC")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMatchLabels'>Gets labels of annotations on a given layer, identified by given match IDs.</h2><span id='topic+getMatchLabels'></span>

<h3>Description</h3>

<p>Gets labels of annotations on a given layer, identified by given match IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatchLabels(
  labbcat.url,
  match.ids,
  layer.ids,
  target.offset = 0,
  annotations.per.layer = 1,
  include.match.ids = FALSE,
  page.length = 1000,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMatchLabels_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_match.ids">match.ids</code></td>
<td>
<p>A vector of annotation IDs, e.g. the MatchId column, or the URL column,
of a results set.</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs.</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_target.offset">target.offset</code></td>
<td>
<p>The distance from the original target of the match, e.g.
</p>

<ul>
<li><p><em>0</em> &ndash; find annotations of the match target itself,
</p>
</li>
<li><p><em>1</em> &ndash; find annotations of the token immediately <em>after</em> match target
</p>
</li>
<li><p><em>-1</em> &ndash; find annotations of the token immediately <em>before</em> match target
</p>
</li></ul>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_annotations.per.layer">annotations.per.layer</code></td>
<td>
<p>The number of annotations on the given layer to
retrieve. In most cases, there's only one annotation available. However, tokens
may, for example, be annotated with &lsquo;all possible phonemic transcriptions&rsquo;, in which
case using a value of greater than 1 for this parameter provides other phonemic
transcriptions, for tokens that have more than one.</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_include.match.ids">include.match.ids</code></td>
<td>
<p>Whether or not the data frame returned includes the original
MatchId column or not.</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_page.length">page.length</code></td>
<td>
<p>In order to prevent timeouts when there are a large number of
matches or the network connection is slow, rather than retrieving matches in one
big request, they are retrieved using many smaller requests. This parameter
controls the number of results retrieved per request.</p>
</td></tr>
<tr><td><code id="getMatchLabels_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of labels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMatches">getMatches</a></code>
<code><a href="#topic+getMatchAlignments">getMatchAlignments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(orthography="quake"))

## Get the topic annotations for the matches
topics &lt;- getMatchLabels(labbcat.url, results$MatchId, "topic")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMedia'>Downloads a given media track for a given transcript.</h2><span id='topic+getMedia'></span>

<h3>Description</h3>

<p>Downloads a given media track for a given transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMedia(
  labbcat.url,
  id,
  track.suffix = "",
  mime.type = "audio/wav",
  path = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMedia_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="getMedia_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name).</p>
</td></tr>
<tr><td><code id="getMedia_+3A_track.suffix">track.suffix</code></td>
<td>
<p>The track suffix of the media.</p>
</td></tr>
<tr><td><code id="getMedia_+3A_mime.type">mime.type</code></td>
<td>
<p>The MIME type of the media, e.g. &quot;audio/wav&quot; or &quot;application/f0&quot;.</p>
</td></tr>
<tr><td><code id="getMedia_+3A_path">path</code></td>
<td>
<p>Optional path to directory where the file should be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the file, which is saved in the current directory, or the given
path if specified
</p>


<h3>See Also</h3>

<p><a href="#topic+getTranscriptIds">getTranscriptIds</a>
</p>
<p><a href="#topic+getMediaUrl">getMediaUrl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Download the WAV file for BR2044_OllyOhlson.eaf
wav &lt;- getMedia(labbcat.url, "BR2044_OllyOhlson.eaf")

## Download the 'QuakeFace' video file for BR2044_OllyOhlson.eaf
quakeFaceMp4 &lt;- getMedia(labbcat.url, "BR2044_OllyOhlson.eaf", "_face", "video/mp4")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMediaTracks'>List the predefined media tracks available for transcripts.</h2><span id='topic+getMediaTracks'></span>

<h3>Description</h3>

<p>List the predefined media tracks available for transcripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMediaTracks(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMediaTracks_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of media track definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get the media tracks configured in LaBB-CAT
tracks &lt;- getMediaTracks("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getMediaUrl'>Gets the URL of the given media track for a given transcript.</h2><span id='topic+getMediaUrl'></span>

<h3>Description</h3>

<p>Gets the URL of the given media track for a given transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMediaUrl(labbcat.url, id, track.suffix = "", mime.type = "audio/wav")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMediaUrl_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="getMediaUrl_+3A_id">id</code></td>
<td>
<p>A transcript ID (i.e. transcript name).</p>
</td></tr>
<tr><td><code id="getMediaUrl_+3A_track.suffix">track.suffix</code></td>
<td>
<p>The track suffix of the media.</p>
</td></tr>
<tr><td><code id="getMediaUrl_+3A_mime.type">mime.type</code></td>
<td>
<p>The MIME type of the media, e.g. &quot;audio/wav&quot; or &quot;application/f0&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A URL to the given media for the given transcript.
</p>


<h3>See Also</h3>

<p><a href="#topic+getTranscriptIds">getTranscriptIds</a>
</p>
<p><a href="#topic+getMedia">getMedia</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get URL for the WAV file for BR2044_OllyOhlson.eaf
wavUrl &lt;- getMediaUrl(labbcat.url, "BR2044_OllyOhlson.eaf")

## Get URL for the 'QuakeFace' video file for BR2044_OllyOhlson.eaf
quakeFaceMp4Url &lt;- getMediaUrl(labbcat.url, "BR2044_OllyOhlson.eaf", "_face", "video/mp4")

## End(Not run)

</code></pre>

<hr>
<h2 id='getParticipant'>Gets information about a single participant.</h2><span id='topic+getParticipant'></span>

<h3>Description</h3>

<p>Returns a nested named list with the participant information, including the given
participant attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParticipant(labbcat.url, id, layer.ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParticipant_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getParticipant_+3A_id">id</code></td>
<td>
<p>A participant ID</p>
</td></tr>
<tr><td><code id="getParticipant_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs corresponding to participant attributes,
eg. c('participant_gender', 'participant_year_of_birth')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of representing the participant and its attributes, with members:
</p>

<ul>
<li><p><em>id</em> The participant's unique internal database ID
</p>
</li>
<li><p><em>label</em> The ID (name) of the participant
</p>
</li>
<li><p><em>annotations</em> A named list of participant attributes
e.g. the label of the participant's 'gender' attribute would be:
participant$annotations$participant_gender$label
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getParticipantAttributes">getParticipantAttributes</a></code>
<code><a href="#topic+saveParticipant">saveParticipant</a></code>
<code><a href="#topic+deleteParticipant">deleteParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get the gender and year of birth of AP511_MikeThorpe
participant &lt;- getParticipant(labbcat.url, "AP511_MikeThorpe",
                  c("participant_gender", "participant_year_of_birth"))

print(paste("ID:", participant$label,
            "Gender:", participant$annotations$participant_gender$label,
            "YOB:", participant$annotations$participant_year_of_birth$label))

## End(Not run)

</code></pre>

<hr>
<h2 id='getParticipantAttributes'>Gets participant attribute values for given participant IDs.</h2><span id='topic+getParticipantAttributes'></span>

<h3>Description</h3>

<p>Gets participant attribute values for given participant IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParticipantAttributes(labbcat.url, participant.ids, layer.ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParticipantAttributes_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getParticipantAttributes_+3A_participant.ids">participant.ids</code></td>
<td>
<p>A vector of participant IDs</p>
</td></tr>
<tr><td><code id="getParticipantAttributes_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs corresponding to participant attributes. In
general, these are layers whose ID is prefixed 'participant_', however formally it's
any layer where layer$parentId == 'participant' &amp;&amp; layer$alignment == 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of attribute value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get gender and age for all participants
attributes &lt;- getParticipantAttributes(labbcat.url,
            getParticipantIds(labbcat.url),
            c('participant_gender', 'participant_age'))


## End(Not run)

</code></pre>

<hr>
<h2 id='getParticipantIds'>Gets a list of participant IDs.</h2><span id='topic+getParticipantIds'></span>

<h3>Description</h3>

<p>Returns a list of participant IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParticipantIds(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParticipantIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of participant IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List all speakers
speakers &lt;- getParticipantIds("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getSerializerDescriptors'>Lists the descriptors of all registered serializers.</h2><span id='topic+getSerializerDescriptors'></span>

<h3>Description</h3>

<p>Returns a list of serializers, which are modules that export annotation structures as
a specific file format, e.g. Praat TextGrid, plain text, etc., so the
<em>mimeType</em> of descriptors reflects what <em>mimeType</em>s can be specified for
<a href="#topic+getFragments">getFragments</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSerializerDescriptors(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSerializerDescriptors_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of serializers, each including the following information:
</p>

<ul>
<li><p><em>name</em> The name of the format.
</p>
</li>
<li><p><em>version</em> The installed version of the serializer module.
</p>
</li>
<li><p><em>fileSuffixes</em> The normal file name suffixes (extensions) of the files.,
</p>
</li>
<li><p><em>mimeType</em> The MIME type of the format, i.e. the value to use as the
<em>mimeType</em> parameter of <a href="#topic+getFragments">getFragments</a>,
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+getFragments">getFragments</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List file export formats supported
formats &lt;- getSerializerDescriptors("https://labbcat.canterbury.ac.nz/demo/")

## can we export as plain text?
plainTextSupported &lt;- "text/plain" %in% formats$mimeType

## End(Not run)

</code></pre>

<hr>
<h2 id='getSoundFragments'>Gets sound fragments from 'LaBB-CAT'.</h2><span id='topic+getSoundFragments'></span>

<h3>Description</h3>

<p>Gets sound fragments from 'LaBB-CAT'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSoundFragments(
  labbcat.url,
  ids,
  start.offsets,
  end.offsets,
  sample.rate = NULL,
  path = "",
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSoundFragments_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_ids">ids</code></td>
<td>
<p>The transcript ID (transcript name) of the sound recording, or
a vector of transcript IDs.</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_start.offsets">start.offsets</code></td>
<td>
<p>The start time in seconds, or a vector of start times.</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_end.offsets">end.offsets</code></td>
<td>
<p>The end time in seconds, or a vector of end times.</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_sample.rate">sample.rate</code></td>
<td>
<p>Optional sample rate in Hz - if a positive
integer, then the result is a mono file with the given sample rate.</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_path">path</code></td>
<td>
<p>Optional path to directory where the files should be saved.</p>
</td></tr>
<tr><td><code id="getSoundFragments_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the file, which is saved in the current
directory, or a list of names of files, if multiple
id's/start's/end's were specified 
</p>
<p>If a list of files is returned, they are in the order that they
were returned by the server, which *should* be the order that
they were specified in the id/start/end lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get the 5 seconds starting from 10s after the beginning of a recording
wav.file &lt;- getSoundFragments(labbcat.url, "AP2505_Nelson.eaf", 10.0, 15.0, path="samples")

## Get the 5 seconds starting from 10s as a mono 22kHz file
wav.file &lt;- getSoundFragments(labbcat.url, "AP2505_Nelson.eaf", 10.0, 15.0, 22050)

## Load some search results previously exported from LaBB-CAT
results &lt;- read.csv("results.csv", header=T)

## Get a list of fragments
wav.files &lt;- getSoundFragments(labbcat.url, results$Transcript, results$Line, results$LineEnd)

## Get a list of fragments
wav.file &lt;- getSoundFragments(
              labbcat.url, results$Transcript, results$Line, results$LineEnd)

## End(Not run)
</code></pre>

<hr>
<h2 id='getSystemAttribute'>Gets the value of the given system attribute.</h2><span id='topic+getSystemAttribute'></span>

<h3>Description</h3>

<p>Gets the value of the given system attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSystemAttribute(labbcat.url, attribute)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSystemAttribute_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getSystemAttribute_+3A_attribute">attribute</code></td>
<td>
<p>Name of the attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the given attribute.
</p>
<p><code><a href="#topic+getLayers">getLayers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get the name of the LaBB-CAT instance
title &lt;- getSystemAttribute("https://labbcat.canterbury.ac.nz/demo/", "title")

## End(Not run)

</code></pre>

<hr>
<h2 id='getTranscriptAttributes'>Gets transcript attribute values for given transcript IDs.</h2><span id='topic+getTranscriptAttributes'></span>

<h3>Description</h3>

<p>Gets transcript attribute values for given transcript IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTranscriptAttributes(labbcat.url, transcript.ids, layer.ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTranscriptAttributes_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getTranscriptAttributes_+3A_transcript.ids">transcript.ids</code></td>
<td>
<p>A vector of transcript IDs</p>
</td></tr>
<tr><td><code id="getTranscriptAttributes_+3A_layer.ids">layer.ids</code></td>
<td>
<p>A vector of layer IDs corresponding to transcript attributes. In
general, these are layers whose ID is prefixed 'transcript_', however formally it's
any layer where layer$parentId == 'transcript' &amp;&amp; layer$alignment == 0, which includes
'corpus' as well as transcript attribute layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of attribute value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get language, duration, and corpus for transcripts starting with 'BR'
attributes &lt;- getTranscriptAttributes(labbcat.url,
            getMatchingTranscriptIds(labbcat.url, "/'BR.+'/.test(id)"),
            c('transcript_language', 'transcript_duration', 'corpus'))


## End(Not run)

</code></pre>

<hr>
<h2 id='getTranscriptIds'>Gets a list of transcript IDs.</h2><span id='topic+getTranscriptIds'></span>

<h3>Description</h3>

<p>Returns a list of transcript IDs (i.e. transcript names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTranscriptIds(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTranscriptIds_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of transcript IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List all transcripts
transcripts &lt;- getTranscriptIds("https://labbcat.canterbury.ac.nz/demo/")

## End(Not run)

</code></pre>

<hr>
<h2 id='getTranscriptIdsInCorpus'>Gets a list of transcript in a corpus.</h2><span id='topic+getTranscriptIdsInCorpus'></span>

<h3>Description</h3>

<p>Returns a list of transcript IDs in the given corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTranscriptIdsInCorpus(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTranscriptIdsInCorpus_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getTranscriptIdsInCorpus_+3A_id">id</code></td>
<td>
<p>The ID (name) of the corpus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of transcript IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List transcripts in the QB corpus
transcripts &lt;- getTranscriptIdsInCorpus("https://labbcat.canterbury.ac.nz/demo/", "QB")

## End(Not run)

</code></pre>

<hr>
<h2 id='getTranscriptIdsWithParticipant'>Gets a list of IDs of transcripts that include the given participant.</h2><span id='topic+getTranscriptIdsWithParticipant'></span>

<h3>Description</h3>

<p>Returns a list of IDs of transcripts (i.e. transcript names) that include
the given participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTranscriptIdsWithParticipant(labbcat.url, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTranscriptIdsWithParticipant_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="getTranscriptIdsWithParticipant_+3A_id">id</code></td>
<td>
<p>A participant ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of transcript IDs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParticipantIds">getParticipantIds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## List transcripts in which UC427_ViktoriaPapp_A_ENG speaks
transcripts &lt;- getTranscriptIdsWithParticipant(labbcat.url, "UC427_ViktoriaPapp_A_ENG")

## End(Not run)

</code></pre>

<hr>
<h2 id='getUserInfo'>Gets information about the current user.</h2><span id='topic+getUserInfo'></span>

<h3>Description</h3>

<p>Returns information about the current user, including the roles or groups they are in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUserInfo(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUserInfo_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing information about current the LaBB-CAT user.
</p>


<h3>See Also</h3>

<p><a href="#topic+labbcatCredentials">labbcatCredentials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## List file export formats supported
me &lt;- getUserInfo("https://labbcat.canterbury.ac.nz/demo/")

## am I an administrator?
admin &lt;- "admin" %in% me$roles

## End(Not run)

</code></pre>

<hr>
<h2 id='labbcatCredentials'>Sets the username and password that the package should use for connecting
to a given LaBB-CAT server in future function calls.</h2><span id='topic+labbcatCredentials'></span>

<h3>Description</h3>

<p>This step is optional, as all functions will prompt the user for the username
and password if required.  If the script is running in RStudio, then the
RStudio password input dialog is used, hiding the credentials from view.
Otherwise, the console is used, and credentials are visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labbcatCredentials(labbcat.url, username, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labbcatCredentials_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="labbcatCredentials_+3A_username">username</code></td>
<td>
<p>The LaBB-CAT username, if it is password-protected</p>
</td></tr>
<tr><td><code id="labbcatCredentials_+3A_password">password</code></td>
<td>
<p>The LaBB-CAT password, if it is password-protected</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recommended approach is to *not* use labbcatCredentials, to avoid saving
user credentials in script files that may eventually become visible to other.
Use labbcatCredentials *only* in cases where the script execution is unsupervised.
</p>


<h3>Value</h3>

<p>NULL if the username/password are correct, and a string describing the problem
if a problem occurred, e.g. &quot;Credentials rejected&quot; if the username/password are
incorrect, or a string starting &quot;Version mismatch&quot; if the server's version of
LaBB-CAT is lower than the minimum required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## specify the username/password in the script
## (only use labbcatCredentials for scripts that must execute unsupervised!)
labbcatCredentials(labbcat.url, "demo", "demo")

## End(Not run)

</code></pre>

<hr>
<h2 id='labbcatTimeout'>Sets the timeout for request to the LaBB-CAT server in future function calls. The
default timeout is 10 seconds.</h2><span id='topic+labbcatTimeout'></span>

<h3>Description</h3>

<p>Sets the timeout for request to the LaBB-CAT server in future function calls. The
default timeout is 10 seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labbcatTimeout(seconds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labbcatTimeout_+3A_seconds">seconds</code></td>
<td>
<p>The number of seconds before requests return with a timeout error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The request timeout in seconds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## the request timeout
labbcatTimeout(30)

## End(Not run)

</code></pre>

<hr>
<h2 id='labbcatVersionInfo'>Gets version information of all components of LaBB-CAT.</h2><span id='topic+labbcatVersionInfo'></span>

<h3>Description</h3>

<p>Version information includes versions of all components and modules installed on the
LaBB-CAT server, including format converters and annotator modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labbcatVersionInfo(labbcat.url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labbcatVersionInfo_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The versions of different components of LaBB-CAT, divided into sections:
</p>

<ul>
<li><p><em>System</em> Overall LaBB-CAT system components
</p>
</li>
<li><p><em>Formats</em> Annotation format conversion modules
</p>
</li>
<li><p><em>Layer Managers</em> Annotator module versions
</p>
</li>
<li><p><em>3rd Pary Software</em> Versions of software installed on the server that
LaBB-CAT integrates with, e.g. Praat, FastTrack, etc.
</p>
</li>
<li><p><em>RDBMS</em> MySQL Server version information
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get ID of LaBB-CAT instance
versionInfo &lt;- labbcatVersionInfo("https://labbcat.canterbury.ac.nz/demo/")
print(paste("LaBB-CAT version", versionInfo$System$`LaBB-CAT`, " Full version info:"))
print(t(as.data.frame(versionInfo)))

## End(Not run)

</code></pre>

<hr>
<h2 id='loadLexicon'>Upload a flat lexicon file for lexical tagging.</h2><span id='topic+loadLexicon'></span>

<h3>Description</h3>

<p>By default LaBB-CAT includes a layer manager called the Flat Lexicon Tagger, which can
be configured to annotate words with data from a dictionary loaded from a plain text
file (e.g. a CSV file). The file must have a 'flat' structure in the sense that it's a
simple list of dictionary entries with a fixed number of columns/fields, rather than
having a complex structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadLexicon(
  labbcat.url,
  file,
  lexicon,
  field.delimiter,
  field.names,
  quote = "",
  comment = "",
  skip.first.line = FALSE,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadLexicon_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_file">file</code></td>
<td>
<p>The full path name of the lexicon file.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_lexicon">lexicon</code></td>
<td>
<p>The name for the resulting lexicon. If the named lexicon already exists,
it will be completely replaced with the contents of the file (i.e. all existing
entries will be deleted befor adding new entries from the file).
e.g. 'cmudict'</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_field.delimiter">field.delimiter</code></td>
<td>
<p>The character used to delimit fields in the file.
If this is &quot; - &quot;, rows are split on only the &lt;em&gt;first&lt;/em&gt; space, in line with
common dictionary formats.
e.g. ',' for Comma Separated Values (CSV) files.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_field.names">field.names</code></td>
<td>
<p>A list of field names, delimited by field.delimiter,
e.g. 'Word,Pronunciation'.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_quote">quote</code></td>
<td>
<p>The character used to quote field values (if any), e.g. '&quot;'.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_comment">comment</code></td>
<td>
<p>The character used to indicate a line is a comment (not an entry) (if any)
e.g. '#'.</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_skip.first.line">skip.first.line</code></td>
<td>
<p>Whether to ignore the first line of the file (because it
contains field names).</p>
</td></tr>
<tr><td><code id="loadLexicon_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uploads such a lexicon file, for use in tagging tokens.
</p>
<p>You must have editing privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>An error message, or NULL if the upload was successful.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDictionaries">getDictionaries</a></code>
<code><a href="#topic+deleteLexicon">deleteLexicon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Upload the CMU Pronouncing Dictionary 
loadLexicon(labbcat.url, "cmudict", " - ", "", ";", "Word - Pron", FALSE, "cmudict.txt")

## End(Not run)

</code></pre>

<hr>
<h2 id='newLayer'>Creates a new layer.</h2><span id='topic+newLayer'></span>

<h3>Description</h3>

<p>This function creates a new annotation layer. The layer may be configured with a layer
manager ID and task parameters, for automatic annotation. If so, this function will
create the layer and the automation task, but automatic annotation will not be run by
this function. To generate the automatic annotations, use <a href="#topic+generateLayer">generateLayer</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newLayer(
  labbcat.url,
  layer.id,
  description,
  type = "string",
  alignment = 0,
  category = "General",
  parent.id = "word",
  annotator.id = NULL,
  annotator.task.parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newLayer_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="newLayer_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer to create, which must be unique to the LaBB-CAT instance.</p>
</td></tr>
<tr><td><code id="newLayer_+3A_description">description</code></td>
<td>
<p>A description of the annotations the layer will contain.</p>
</td></tr>
<tr><td><code id="newLayer_+3A_type">type</code></td>
<td>
<p>The type of data the labels will represent. Valid values are &quot;string&quot;,
&quot;number&quot;, &quot;ipa&quot; (for phoneme representations), or &quot;boolean&quot; (labels &quot;0&quot; or &quot;1&quot;).</p>
</td></tr>
<tr><td><code id="newLayer_+3A_alignment">alignment</code></td>
<td>
<p>How annotations on the layer will relate to time alignment; valid
values are 0 (no alignment; annototations are just tags on the parent annotation),
1 (instants; annotations mark a single point in time), or 2 (intervals; annotations
have a start and end time).</p>
</td></tr>
<tr><td><code id="newLayer_+3A_category">category</code></td>
<td>
<p>The project/category the layer belongs to.</p>
</td></tr>
<tr><td><code id="newLayer_+3A_parent.id">parent.id</code></td>
<td>
<p>The parent layer; valid values are &quot;word&quot; (for word layers), &quot;segment&quot;
(for segment layers) &quot;turn&quot; (for phrase layers), or &quot;transcript&quot; (for span layers).</p>
</td></tr>
<tr><td><code id="newLayer_+3A_annotator.id">annotator.id</code></td>
<td>
<p>The ID of the layer manager that automatically fills in
annotations on the layer, if any</p>
</td></tr>
<tr><td><code id="newLayer_+3A_annotator.task.parameters">annotator.task.parameters</code></td>
<td>
<p>The configuration the layer manager should use when
filling the layer with annotations. This is a string whose format is specific to
each layer manager.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have administration privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>The resulting layer definition, with members:
</p>

<ul>
<li><p><em>id</em> The layer's unique ID
</p>
</li>
<li><p><em>parentId</em> The layer's parent layer ID
</p>
</li>
<li><p><em>description</em> The description of the layer
</p>
</li>
<li><p><em>alignment</em> The layer's alignment - 0 for none, 1 for point alignment, 2 for interval alignment
</p>
</li>
<li><p><em>peers</em> Whether children have peers or not
</p>
</li>
<li><p><em>peersOverlap</em> Whether child peers can overlap or not
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>saturated</em> Whether children must temporally fill the entire parent duration (true) or not (false)
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>type</em> The type for labels on this layer
</p>
</li>
<li><p><em>validLabels</em> List of valid label values for this layer
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+generateLayer">generateLayer</a></code>
<code><a href="#topic+saveLayer">saveLayer</a></code>
<code><a href="#topic+deleteLayer">deleteLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Upload the CMU Pronouncing Dictionary 
loadLexicon(labbcat.url, "cmudict", " - ", "", ";", "Word - Pron", FALSE, "cmudict.txt")

## Create a layer that tags each token with its CMU Pronouncing Dictionary pronunciation
newLayer(labbcat.url, "pronunciation", "CMU Dict pronunciations encoded in ARPAbet",
         annotator.id="FlatFileDictionary",
         annotator.task.parameters=
             "tokenLayerId=orthography&amp;tagLayerId=phonemes&amp;dictionary=cmudict:Word-&gt;Pron")

## Generate the pronunciation tags
generateLayer(labbcat.url, "pronunciation")

## End(Not run)

</code></pre>

<hr>
<h2 id='newTranscript'>Upload a new transcript.</h2><span id='topic+newTranscript'></span>

<h3>Description</h3>

<p>This function adds a transcript and optionally a media file to the corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newTranscript(
  labbcat.url,
  transcript,
  media = NULL,
  transcript.type = NULL,
  corpus = NULL,
  episode = NULL,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newTranscript_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_transcript">transcript</code></td>
<td>
<p>The path to the transcript to upload.</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_media">media</code></td>
<td>
<p>The path to the media to upload, if any.</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_transcript.type">transcript.type</code></td>
<td>
<p>The transcript type.</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_corpus">corpus</code></td>
<td>
<p>The corpus to add the transcript to.</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_episode">episode</code></td>
<td>
<p>The transcript's episode.</p>
</td></tr>
<tr><td><code id="newTranscript_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the credentials used to connect to the server must have at
least 'edit' access.
</p>


<h3>Value</h3>

<p>The ID of the new transcript in the corpus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get attributes for new transcript
corpus &lt;- getCorpusIds(labbcat.url)[1]
transcript.type.layer &lt;- getLayer(labbcat.url, "transcript_type")
transcript.type &lt;- transcript.type.layer$validLabels[[1]]

## upload transcript
newTranscript(
    labbcat.url, "my-transcript.eaf", "my-transcript.wav",
    "", transcript.type, corpus, "episode-1")

## End(Not run)
</code></pre>

<hr>
<h2 id='nzilbb.labbcat'>Accessing Data Stored in 'LaBB-CAT' Instances</h2><span id='topic+nzilbb.labbcat'></span>

<h3>Description</h3>

<p>'LaBB-CAT' is a web-based language corpus management
 system developed by the New Zealand Institute of Language, Brain
 and Behaviour (NZILBB) - see &lt;https://labbcat.canterbury.ac.nz&gt;.
 This package defines functions for accessing corpus data in a 'LaBB-CAT'
 instance. You must have at least version 20230224.1731 of 'LaBB-CAT'
 to use this package.
 For more information about 'LaBB-CAT', see
 Robert Fromont and Jennifer Hay (2008) &lt;doi:10.3366/E1749503208000142&gt;
 or 
 Robert Fromont (2017) &lt;doi:10.1016/j.csl.2017.01.004&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> nzilbb.labbcat</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-19</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Accessing Data Stored in 'LaBB-CAT' Instances</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Robert", "Fromont", role = c("aut", "cre"),
                     email = "robert.fromont@canterbury.ac.nz",
                     comment = c(ORCID = "0000-0001-5271-5487")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> jsonlite, httr, stringr, utils, rstudioapi</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> 'LaBB-CAT' is a web-based language corpus management
 system developed by the New Zealand Institute of Language, Brain
 and Behaviour (NZILBB) - see &lt;https://labbcat.canterbury.ac.nz&gt;.
 This package defines functions for accessing corpus data in a 'LaBB-CAT'
 instance. You must have at least version 20230224.1731 of 'LaBB-CAT'
 to use this package.
 For more information about 'LaBB-CAT', see
 Robert Fromont and Jennifer Hay (2008) &lt;doi:10.3366/E1749503208000142&gt;
 or 
 Robert Fromont (2017) &lt;doi:10.1016/j.csl.2017.01.004&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
Copyright: </td><td style="text-align: left;"> New Zealand Institute of Language, Brain and Behaviour,
University of Canterbury</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://nzilbb.github.io/labbcat-R/, https://labbcat.canterbury.ac.nz</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> testthat (&gt;= 2.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robert Fromont [aut, cre] (&lt;https://orcid.org/0000-0001-5271-5487&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robert Fromont &lt;robert.fromont@canterbury.ac.nz&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
addDictionaryEntry      Adds an entry to a dictionary.
addLayerDictionaryEntry
                        Adds an entry to a layer dictionary.
annotatorExt            Retrieve annotator's "ext" resource.
countAnnotations        Gets the number of annotations on the given
                        layer of the given transcript.
countMatchingAnnotations
                        Gets the number of annotations matching a
                        particular pattern.
deleteLayer             Deletes an existing layer.
deleteLexicon           Delete a previously loaded lexicon.
deleteParticipant       Deletes a participant record.
deleteTranscript        Delete a transcript from the corpus.
expressionFromAttributeValue
                        Generates a query expression for matching a
                        transcript/participant attribute, for use with
                        getMatches.
expressionFromAttributeValues
                        Generates a query expression for matching a
                        transcript/participant attribute, for use with
                        getMatches.
expressionFromIds       Generates a query expression for matching
                        transcripts or participants by ID, for use with
                        getMatches.
expressionFromTranscriptTypes
                        Generates a transcript query expression for
                        matching transcripts by type, for use with
                        getMatches or getMatchingTranscriptIds.
formatTranscript        Gets transcript(s) in a given format.
generateLayer           Generates a layer.
generateLayerUtterances
                        Generates a layer for a given set of
                        utterances.
getAllUtterances        Get all utterances of participants.
getAnchors              Gets the given anchors in the given transcript.
getAnnotations          Gets the annotations on the given layer of the
                        given transcript.
getAnnotatorDescriptor
                        Gets annotator information.
getAvailableMedia       List the media available for the given
                        transcript.
getCorpusIds            Gets a list of corpus IDs.
getDeserializerDescriptors
                        Lists the descriptors of all registered
                        deserializers.
getDictionaries         List the dictionaries available.
getDictionaryEntries    Lookup entries in a dictionary.
getFragmentAnnotations
                        Gets annotations in fragments.
getFragments            Gets transcript fragments in a given format.
getGraphIds             Deprecated synonym for getTranscriptIds.
getGraphIdsInCorpus     Deprecated synonym for
                        getTranscriptIdsInCorpus.
getGraphIdsWithParticipant
                        Deprecated synonym for
                        getTranscriptIdsWithParticipant.
getId                   Gets the store's ID.
getLayer                Gets a layer definition.
getLayerIds             Gets a list of layer IDs.
getLayers               Gets a list of layer definitions.
getMatchAlignments      Gets temporal alignments of matches on a given
                        layer.
getMatchLabels          Gets labels of annotations on a given layer,
                        identified by given match IDs.
getMatches              Search for tokens.
getMatchingAnnotations
                        Gets a list of annotations that match a
                        particular pattern.
getMatchingGraphIds     Deprecated synonym for
                        getMatchingTranscriptIds.
getMatchingParticipantIds
                        Gets a list of IDs of participants that match a
                        particular pattern.
getMatchingTranscriptIds
                        Gets a list of IDs of transcripts that match a
                        particular pattern.
getMedia                Downloads a given media track for a given
                        transcript.
getMediaTracks          List the predefined media tracks available for
                        transcripts.
getMediaUrl             Gets the URL of the given media track for a
                        given transcript.
getParticipant          Gets information about a single participant.
getParticipantAttributes
                        Gets participant attribute values for given
                        participant IDs.
getParticipantIds       Gets a list of participant IDs.
getSerializerDescriptors
                        Lists the descriptors of all registered
                        serializers.
getSoundFragments       Gets sound fragments from 'LaBB-CAT'.
getSystemAttribute      Gets the value of the given system attribute.
getTranscriptAttributes
                        Gets transcript attribute values for given
                        transcript IDs.
getTranscriptIds        Gets a list of transcript IDs.
getTranscriptIdsInCorpus
                        Gets a list of transcript in a corpus.
getTranscriptIdsWithParticipant
                        Gets a list of IDs of transcripts that include
                        the given participant.
getUserInfo             Gets information about the current user.
labbcatCredentials      Sets the username and password that the package
                        should use for connecting to a given LaBB-CAT
                        server in future function calls.
labbcatTimeout          Sets the timeout for request to the LaBB-CAT
                        server in future function calls. The default
                        timeout is 10 seconds.
labbcatVersionInfo      Gets version information of all components of
                        LaBB-CAT.
loadLexicon             Upload a flat lexicon file for lexical tagging.
newLayer                Creates a new layer.
newTranscript           Upload a new transcript.
nzilbb.labbcat          Accessing Data Stored in 'LaBB-CAT' Instances
praatScriptCentreOfGravity
                        Generates a script for extracting the CoG, for
                        use with processWithPraat.
praatScriptFastTrack    Generates a script for extracting formants
                        using FastTrack, for use with processWithPraat.
praatScriptFormants     Generates a script for extracting formants, for
                        use with processWithPraat.
praatScriptIntensity    Generates a script for extracting maximum
                        intensity, for use with processWithPraat.
praatScriptPitch        Generates a script for extracting pitch, for
                        use with processWithPraat.
processWithPraat        Process a set of intervals with Praat.
removeDictionaryEntry   Removes an entry from a dictionary.
removeLayerDictionaryEntry
                        Removes an entry from a layer dictionary.
renameParticipants      Renames a list of participants.
saveLayer               Saves the details of an existing layer.
saveParticipant         Saves information about a single participant.
updateFragment          Update a transcript fragment.
updateTranscript        Update an existing transcript.
</pre>
<p>'LaBB-CAT' is a web-based language corpus management system and this
package provides access to data stored in a 'LaBB-CAT' instance.
You must have at least version 20230224.1731 'LaBB-CAT' to use
this package.
</p>


<h3>Author(s)</h3>

<p>NA
</p>


<h3>References</h3>

<p><cite>Robert Fromont and Jennifer Hay, &quot;ONZE Miner: the development of a browser-based research tool&quot;, 2008</cite>
<cite>Robert Fromont, &quot;Toward a format-neutral annotation store&quot;, 2017</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get the phonemic transcriptions for the matches
phonemes &lt;- getMatchLabels(labbcat.url, results$MatchId, "phonemes")

## Get sound fragments for the matches
wav.files &lt;- getSoundFragments(labbcat.url, results$Transcript, results$Line, results$LineEnd)

## End(Not run)

</code></pre>

<hr>
<h2 id='praatScriptCentreOfGravity'>Generates a script for extracting the CoG, for use with <a href="#topic+processWithPraat">processWithPraat</a>.</h2><span id='topic+praatScriptCentreOfGravity'></span>

<h3>Description</h3>

<p>This function generates a Praat script fragment which can be passed as the praat.script
parameter of <a href="#topic+processWithPraat">processWithPraat</a>, in order to extract one or more spectral centre
of gravity (CoG) measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>praatScriptCentreOfGravity(powers = c(2), spectrum.fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="praatScriptCentreOfGravity_+3A_powers">powers</code></td>
<td>
<p>A vector of numbers specifying which powers to query for to extract, e.g.
c(1.0,2.0).</p>
</td></tr>
<tr><td><code id="praatScriptCentreOfGravity_+3A_spectrum.fast">spectrum.fast</code></td>
<td>
<p>Whether to use the 'fast' option when creating the spectrum object
to query .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A script fragment which can be passed as the praat.script parameter of
<a href="#topic+processWithPraat">processWithPraat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+processWithPraat">processWithPraat</a>
</p>
<p><a href="#topic+praatScriptFormants">praatScriptFormants</a>
</p>
<p><a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
</p>
<p><a href="#topic+praatScriptPitch">praatScriptPitch</a>
</p>
<p><a href="#topic+praatScriptFastTrack">praatScriptFastTrack</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get centres of gravity for all matches
cog &lt;- processWithPraat(
              labbcat.url,
              results$MatchId, results$Target.segment.start, results$Target.segment.end,
              praatScriptCentreOfGravity(powers=c(1.0,2.0)))

## End(Not run)
</code></pre>

<hr>
<h2 id='praatScriptFastTrack'>Generates a script for extracting formants using FastTrack, for use with <a href="#topic+processWithPraat">processWithPraat</a>.</h2><span id='topic+praatScriptFastTrack'></span>

<h3>Description</h3>

<p>This function generates a Praat script fragment which can be passed as the praat.script
parameter of <a href="#topic+processWithPraat">processWithPraat</a>, in order to extract selected formants using the
FastTrack Praat plugin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>praatScriptFastTrack(
  formants = c(1, 2),
  sample.points = c(0.5),
  lowest.analysis.frequency = 5000,
  lowest.analysis.frequency.male = 4500,
  highest.analysis.frequency = 7000,
  highest.analysis.frequency.male = 6500,
  gender.attribute = "participant_gender",
  value.for.male = "M",
  time.step = 0.002,
  tracking.method = "burg",
  number.of.formants = 3,
  maximum.f1.frequency = 1200,
  maximum.f1.bandwidth = NULL,
  maximum.f2.bandwidth = NULL,
  maximum.f3.bandwidth = NULL,
  minimum.f4.frequency = 2900,
  enable.rhotic.heuristic = TRUE,
  enable.f3.f4.proximity.heuristic = TRUE,
  number.of.steps = 20,
  number.of.coefficients = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="praatScriptFastTrack_+3A_formants">formants</code></td>
<td>
<p>A vector of integers specifying which formants to extract, e.g c(1,2)
for the first and second formant.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_sample.points">sample.points</code></td>
<td>
<p>A vector of numbers (0 &lt;= sample.points &lt;= 1) specifying multiple
points at which to take the measurement.  The default is a single point at 0.5 -
this means one measurement will be taken halfway through the target interval.  If,
for example, you wanted eleven measurements evenly spaced throughout the interval,
you would specify sample.points as being
c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0).</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_lowest.analysis.frequency">lowest.analysis.frequency</code></td>
<td>
<p>Lowest analysis frequency (Hz) by default.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_lowest.analysis.frequency.male">lowest.analysis.frequency.male</code></td>
<td>
<p>Lowest analysis frequency (Hz) for male
speakers, or NULL to use the same value as lowest.analysis.frequency.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_highest.analysis.frequency">highest.analysis.frequency</code></td>
<td>
<p>Highest analysis frequency (Hz) by default.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_highest.analysis.frequency.male">highest.analysis.frequency.male</code></td>
<td>
<p>Highest analysis frequency (Hz) for male
speakers, or NULL to use the same value as highest.analysis.frequency.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_gender.attribute">gender.attribute</code></td>
<td>
<p>Name of the LaBB-CAT participant attribute that contains the
participant's gender - normally this is &quot;participant_gender&quot;.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_value.for.male">value.for.male</code></td>
<td>
<p>The value that the gender.attribute has when the participant is male.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_time.step">time.step</code></td>
<td>
<p>Time step in seconds.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_tracking.method">tracking.method</code></td>
<td>
<p>tracking_method parameter for trackAutoselectProcedure; &quot;burg&quot;
or &quot;robust&quot;.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_number.of.formants">number.of.formants</code></td>
<td>
<p>Number of formants to track - 3 or 4.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_maximum.f1.frequency">maximum.f1.frequency</code></td>
<td>
<p>Specifying a non-NULL value enables the F1 frequency
heuristic: Median F1 frequency should not be higher than this value.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_maximum.f1.bandwidth">maximum.f1.bandwidth</code></td>
<td>
<p>Specifying a non-NULL value (e.g. 500)
enables the F1 bandwidth heuristic: Median F1 bandwidth should not be higher than
this value.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_maximum.f2.bandwidth">maximum.f2.bandwidth</code></td>
<td>
<p>Specifying a non-NULL value (e.g. 600)
enables the F2 bandwidth heuristic: Median F2 bandwidth should not be higher than
this value.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_maximum.f3.bandwidth">maximum.f3.bandwidth</code></td>
<td>
<p>Specifying a non-NULL value (e.g. 900)
enables the F3 bandwidth heuristic: Median F3 bandwidth should not be higher than
this value.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_minimum.f4.frequency">minimum.f4.frequency</code></td>
<td>
<p>Specifying a non-NULL value enables the F4 frequency
heuristic: Median F4 frequency should not be lower than this value.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_enable.rhotic.heuristic">enable.rhotic.heuristic</code></td>
<td>
<p>Whether to enable the rhotic heuristic: If F3 &lt; 2000 Hz,
F1 and F2 should be at least 500 Hz apart.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_enable.f3.f4.proximity.heuristic">enable.f3.f4.proximity.heuristic</code></td>
<td>
<p>Whether to enable the F3/F4 proximity
heuristic: If (F4 - F3) &lt; 500 Hz, F1 and F2 should be at least 1500 Hz apart.</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_number.of.steps">number.of.steps</code></td>
<td>
<p>Number of analyses between low and high analysis limits. More
analysis steps may improve results, but will increase analysis time (50 percent more steps
= around 50 percent longer to analyze).</p>
</td></tr>
<tr><td><code id="praatScriptFastTrack_+3A_number.of.coefficients">number.of.coefficients</code></td>
<td>
<p>Number of coefficients for formant prediction. More
coefficients allow for more sudden, and 'wiggly' formant motion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FastTrack Praat plugin, developed by Santiago Barreda, automatically runs multiple
formant analyses on each segment, selects the best (the smoothest, with optional
heuristics), and makes the winning formant object available for measurement. For more
information, see <a href="https://github.com/santiagobarreda/FastTrack">https://github.com/santiagobarreda/FastTrack</a>
</p>


<h3>Value</h3>

<p>A script fragment which can be passed as the praat.script parameter of
<a href="#topic+processWithPraat">processWithPraat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+processWithPraat">processWithPraat</a>
</p>
<p><a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>
</p>
<p><a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
</p>
<p><a href="#topic+praatScriptPitch">praatScriptPitch</a>
</p>
<p><a href="#topic+praatScriptFormants">praatScriptFormants</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all tokens of the KIT vowel
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get the first 3 formants at three points during the vowel
formants &lt;- processWithPraat(
              labbcat.url,
              results$MatchId, results$Target.segment.start, results$Target.segment.end,
              window.offset=0.025,
              praatScriptFastTrack(formants=c(1,2,3),
              sample.points=c(0.25,0.5,0.75)))

## End(Not run)
</code></pre>

<hr>
<h2 id='praatScriptFormants'>Generates a script for extracting formants, for use with <a href="#topic+processWithPraat">processWithPraat</a>.</h2><span id='topic+praatScriptFormants'></span>

<h3>Description</h3>

<p>This function generates a Praat script fragment which can be passed as the praat.script
parameter of <a href="#topic+processWithPraat">processWithPraat</a>, in order to extract selected formants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>praatScriptFormants(
  formants = c(1, 2),
  sample.points = c(0.5),
  time.step = 0,
  max.number.formants = 5,
  max.formant = 5500,
  max.formant.male = 5000,
  gender.attribute = "participant_gender",
  value.for.male = "M",
  window.length = 0.025,
  preemphasis.from = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="praatScriptFormants_+3A_formants">formants</code></td>
<td>
<p>A vector of integers specifying which formants to extract, e.g c(1,2)
for the first and second formant.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_sample.points">sample.points</code></td>
<td>
<p>A vector of numbers (0 &lt;= sample.points &lt;= 1) specifying multiple
points at which to take the measurement.  The default is a single point at 0.5 -
this means one measurement will be taken halfway through the target interval.  If,
for example, you wanted eleven measurements evenly spaced throughout the interval,
you would specify sample.points as being
c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0).</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_time.step">time.step</code></td>
<td>
<p>Time step in seconds, or 0.0 for 'auto'.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_max.number.formants">max.number.formants</code></td>
<td>
<p>Maximum number of formants.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_max.formant">max.formant</code></td>
<td>
<p>Maximum formant value (Hz) for all speakers, or for female speakers,
if max.formant.male is also specified.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_max.formant.male">max.formant.male</code></td>
<td>
<p>Maximum formant value (Hz) for male speakers, or NULL to use
the same value as max.formant.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_gender.attribute">gender.attribute</code></td>
<td>
<p>Name of the LaBB-CAT participant attribute that contains the
participant's gender - normally this is &quot;participant_gender&quot;.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_value.for.male">value.for.male</code></td>
<td>
<p>The value that the gender.attribute has when the participant is male.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_window.length">window.length</code></td>
<td>
<p>Window length in seconds.</p>
</td></tr>
<tr><td><code id="praatScriptFormants_+3A_preemphasis.from">preemphasis.from</code></td>
<td>
<p>Pre-emphasis from (Hz)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+praatScriptFastTrack">praatScriptFastTrack</a> function provides an alternative to this function which
uses the FastTrack Praat plugin for formant analysis.
</p>


<h3>Value</h3>

<p>A script fragment which can be passed as the praat.script parameter of
<a href="#topic+processWithPraat">processWithPraat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+processWithPraat">processWithPraat</a>
</p>
<p><a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>
</p>
<p><a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
</p>
<p><a href="#topic+praatScriptPitch">praatScriptPitch</a>
</p>
<p><a href="#topic+praatScriptFastTrack">praatScriptFastTrack</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Get all tokens of the KIT vowel
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get the first 3 formants at three points during the vowel
formants &lt;- processWithPraat(
              labbcat.url,
              results$MatchId, results$Target.segment.start, results$Target.segment.end,
              window.offset=0.025,
              praatScriptFormants(formants=c(1,2,3),
              sample.points=c(0.25,0.5,0.75)))

## End(Not run)
</code></pre>

<hr>
<h2 id='praatScriptIntensity'>Generates a script for extracting maximum intensity, for use with <a href="#topic+processWithPraat">processWithPraat</a>.</h2><span id='topic+praatScriptIntensity'></span>

<h3>Description</h3>

<p>This function generates a Praat script fragment which can be passed as the praat.script
parameter of <a href="#topic+processWithPraat">processWithPraat</a>, in order to extract maximum intensity value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>praatScriptIntensity(
  minimum.pitch = 100,
  time.step = 0,
  subtract.mean = TRUE,
  get.maximum = TRUE,
  sample.points = NULL,
  interpolation = "cubic",
  skip.errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="praatScriptIntensity_+3A_minimum.pitch">minimum.pitch</code></td>
<td>
<p>Minimum pitch (Hz).</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_time.step">time.step</code></td>
<td>
<p>Time step in seconds, or 0.0 for 'auto'.</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_subtract.mean">subtract.mean</code></td>
<td>
<p>Whether to subtract the mean or not.</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_get.maximum">get.maximum</code></td>
<td>
<p>Extract the maximum intensity for the sample.</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_sample.points">sample.points</code></td>
<td>
<p>A vector of numbers (0 &lt;= sample.points &lt;= 1) specifying multiple
points at which to take the measurement.  The default is NULL, meaning no
individual measurements will be taken (only the aggregate values identified by
get.mean, get.minimum, and get.maximum).  A single point at 0.5 means one
measurement will be taken halfway through the target interval.  If, for example, 
you wanted eleven measurements evenly spaced throughout the interval, you would
specify sample.points as being 
c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0).</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_interpolation">interpolation</code></td>
<td>
<p>If sample.points are specified, this is the interpolation to use
when getting individual values. Possible values are 'nearest', 'linear', 'cubic',
'sinc70', or 'sinc700'.</p>
</td></tr>
<tr><td><code id="praatScriptIntensity_+3A_skip.errors">skip.errors</code></td>
<td>
<p>Sometimes, for some segments, Praat fails to create an Intensity
object. If skip.errors = TRUE, analysis those segments will be skipped, and corresponding
pitch values will be returned as &quot;&ndash;undefined&ndash;&quot;. If skip.errors = FALSE, the error
message from Praat will be returned in the Error field, but no pitch measures will
be returned for any segments in the same recording.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A script fragment which can be passed as the praat.script parameter of
<a href="#topic+processWithPraat">processWithPraat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+processWithPraat">processWithPraat</a>
</p>
<p><a href="#topic+praatScriptFormants">praatScriptFormants</a>
</p>
<p><a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>
</p>
<p><a href="#topic+praatScriptPitch">praatScriptPitch</a>
</p>
<p><a href="#topic+praatScriptFastTrack">praatScriptFastTrack</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="s"))

## Get max intensity, and intensity at three points during the segment, for all matches
intensity &lt;- processWithPraat(
              labbcat.url,
              results$MatchId, results$Target.segment.start, results$Target.segment.end,
              praatScriptIntensity(sample.points = c(.25, .5, .75)))

## End(Not run)
</code></pre>

<hr>
<h2 id='praatScriptPitch'>Generates a script for extracting pitch, for use with <a href="#topic+processWithPraat">processWithPraat</a>.</h2><span id='topic+praatScriptPitch'></span>

<h3>Description</h3>

<p>This function generates a Praat script fragment which can be passed as the praat.script
parameter of <a href="#topic+processWithPraat">processWithPraat</a>, in order to extract pitch information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>praatScriptPitch(
  get.mean = TRUE,
  get.minimum = FALSE,
  get.maximum = FALSE,
  time.step = 0,
  pitch.floor = 60,
  max.number.of.candidates = 15,
  very.accurate = FALSE,
  silence.threshold = 0.03,
  voicing.threshold = 0.5,
  octave.cost = 0.01,
  octave.jump.cost = 0.35,
  voiced.unvoiced.cost = 0.35,
  pitch.ceiling = 500,
  pitch.floor.male = 30,
  voicing.threshold.male = 0.4,
  pitch.ceiling.male = 250,
  gender.attribute = "participant_gender",
  value.for.male = "M",
  sample.points = NULL,
  interpolation = "linear",
  skip.errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="praatScriptPitch_+3A_get.mean">get.mean</code></td>
<td>
<p>Extract the mean pitch for the sample.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_get.minimum">get.minimum</code></td>
<td>
<p>Extract the minimum pitch for the sample.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_get.maximum">get.maximum</code></td>
<td>
<p>Extract the maximum pitch for the sample.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_time.step">time.step</code></td>
<td>
<p>Step setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_pitch.floor">pitch.floor</code></td>
<td>
<p>Minimum pitch (Hz) for all speakers, or for female speakers,
if pitch.floor.male is also specified.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_max.number.of.candidates">max.number.of.candidates</code></td>
<td>
<p>Maximum number of candidates setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_very.accurate">very.accurate</code></td>
<td>
<p>Accuracy setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_silence.threshold">silence.threshold</code></td>
<td>
<p>Silence threshold setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_voicing.threshold">voicing.threshold</code></td>
<td>
<p>Voicing threshold (Hz) for all speakers, or for female speakers,
if voicing.threshold.male is also specified.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_octave.cost">octave.cost</code></td>
<td>
<p>Octave cost setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_octave.jump.cost">octave.jump.cost</code></td>
<td>
<p>Octave jump cost setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_voiced.unvoiced.cost">voiced.unvoiced.cost</code></td>
<td>
<p>Voiced/unvoiced cost setting for praat command</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_pitch.ceiling">pitch.ceiling</code></td>
<td>
<p>Maximum pitch (Hz) for all speakers, or for female speakers,
if pitch.floor.male is also specified.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_pitch.floor.male">pitch.floor.male</code></td>
<td>
<p>Minimum pitch (Hz) for male speakers.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_voicing.threshold.male">voicing.threshold.male</code></td>
<td>
<p>Voicing threshold (Hz) for male speakers.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_pitch.ceiling.male">pitch.ceiling.male</code></td>
<td>
<p>Maximum pitch (Hz) for male speakers.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_gender.attribute">gender.attribute</code></td>
<td>
<p>Name of the LaBB-CAT participant attribute that contains the
participant's gender - normally this is &quot;participant_gender&quot;.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_value.for.male">value.for.male</code></td>
<td>
<p>The value that the gender.attribute has when the participant is male.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_sample.points">sample.points</code></td>
<td>
<p>A vector of numbers (0 &lt;= sample.points &lt;= 1) specifying multiple
points at which to take the measurement.  The default is NULL, meaning no
individual measurements will be taken (only the aggregate values identified by
get.mean, get.minimum, and get.maximum).  A single point at 0.5 means one
measurement will be taken halfway through the target interval.  If, for example, 
you wanted eleven measurements evenly spaced throughout the interval, you would
specify sample.points as being 
c(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0).</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_interpolation">interpolation</code></td>
<td>
<p>If sample.points are specified, this is the interpolation to use
when getting individual values. Possible values are 'nearest' or 'linear'.</p>
</td></tr>
<tr><td><code id="praatScriptPitch_+3A_skip.errors">skip.errors</code></td>
<td>
<p>Sometimes, for some segments, Praat fails to create a Pitch
object. If skip.errors = TRUE, analysis those segments will be skipped, and corresponding
pitch values will be returned as &quot;&ndash;undefined&ndash;&quot;. If skip.errors = FALSE, the error
message from Praat will be returned in the Error field, but no pitch measures will
be returned for any segments in the same recording.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A script fragment which can be passed as the praat.script parameter of
<a href="#topic+processWithPraat">processWithPraat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+processWithPraat">processWithPraat</a>
</p>
<p><a href="#topic+praatScriptFormants">praatScriptFormants</a>
</p>
<p><a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>
</p>
<p><a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
</p>
<p><a href="#topic+praatScriptFastTrack">praatScriptFastTrack</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="I"))

## Get pitch mean, max, and min, and the midpoint of the segment, for each match
pitch &lt;- processWithPraat(
              labbcat.url,
              results$MatchId, results$Target.segment.start, results$Target.segment.end,
              praatScriptPitch(get.mean=TRUE, get.minimum=TRUE, get.maximum=TRUE,
                               sample.points = c(.5)))

## End(Not run)
</code></pre>

<hr>
<h2 id='processWithPraat'>Process a set of intervals with Praat.</h2><span id='topic+processWithPraat'></span>

<h3>Description</h3>

<p>This function instructs the LaBB-CAT server to invoke Praat for a set of sound
intervals, in order to extract acoustic measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processWithPraat(
  labbcat.url,
  match.ids,
  start.offsets,
  end.offsets,
  praat.script,
  window.offset,
  gender.attribute = "participant_gender",
  attributes = NULL,
  no.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processWithPraat_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_match.ids">match.ids</code></td>
<td>
<p>A vector of annotation IDs, e.g. the MatchId column, or the URL column,
of a results set.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_start.offsets">start.offsets</code></td>
<td>
<p>The start time in seconds, or a vector of start times.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_end.offsets">end.offsets</code></td>
<td>
<p>The end time in seconds, or a vector of end times.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_praat.script">praat.script</code></td>
<td>
<p>Script to run on each match. This may be a single string or a
character vector.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_window.offset">window.offset</code></td>
<td>
<p>In many circumstances, you will want some context before and after
the sample start/end time.  For this reason, you can specify a &quot;window offset&quot; -
this is a number of seconds to subtract from the sample start and add to the sample
end time, before extracting that part of the audio for processing. For example, if
the sample starts at 2.0s and ends at 3.0s, and you set the window offset to 0.5s,
then Praat will extract a sample of audio from  1.5s to 3.5s, and do the selected
processing on that sample. The best value for this depends on what the praat.script
is doing; if you are getting formants from  vowels, including some context ensures
that he formants at the edges are more accurate (in LaBB-CAT's web interface, the
default value for this 0.025), but if you're getting max pitch or COG during a
segment, most likely you want a window.offset of 0 to ensure neighbouring segments
doesn't influence the measurement.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_gender.attribute">gender.attribute</code></td>
<td>
<p>Which participant attribute represents the participant's gender.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_attributes">attributes</code></td>
<td>
<p>Vector of participant attributes to make available to the script. For
example, if you want to use different acoustic parameters depending on what the
gender of the speaker is, including the &quot;participant_gender&quot; attribute will make a
variable called participant_gender$ available to the praat script, whose value will
be the gender of the speaker for that segment.</p>
</td></tr>
<tr><td><code id="processWithPraat_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact measurements to return depend on the praat.script that is invoked. This is a
Praat script fragment that will run once for each sound interval specified.
</p>
<p>There are functions to allow the generation of a number of pre-defined praat scripts
for common tasks such as formant, pitch, intensity, and centre of gravity &ndash; see
<a href="#topic+praatScriptFormants">praatScriptFormants</a>, <a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>, <a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
and <a href="#topic+praatScriptPitch">praatScriptPitch</a>.
</p>
<p>You can provide your own script, either by building a string with your code, or loading
one from a file.
</p>
<p>LaBB-CAT prefixes praat.script with code to open a sound file and extract a defined part
of it into a Sound object which is then selected.
</p>
<p>LaBB-CAT &lsquo;Remove&rsquo;s this Sound object after the script finishes executing. Any other objects
created by the script must be &lsquo;Remove&rsquo;d before the end of the script (otherwise Praat runs out
of memory during very large batches)
</p>
<p>LaBB-CAT assumes that all calls to the function 'print' correspond to fields for export
and each field must be printed on its own line. Specifically it scans for lines of the
form:
</p>
<p>print 'myOutputVariable' 'newline$'
</p>
<p>Variables that can be assumed to be already set in the context of the script are:
</p>

<ul>
<li><p><em>windowOffset</em>
&ndash; the value used for the Window Offset; how much context to include. 
</p>
</li>
<li><p><em>windowAbsoluteStart</em>
&ndash; the start time of the window extracted relative to the start of the original audio file. 
</p>
</li>
<li><p><em>windowAbsoluteEnd</em>
&ndash; the end time of the window extracted relative to the start of the original audio file. 
</p>
</li>
<li><p><em>windowDuration</em>
&ndash; the duration of the window extracted (including window offset).
</p>
</li>
<li><p><em>targetAbsoluteStart</em>
&ndash; the start time of the target interval relative to the start of the original audio file. 
</p>
</li>
<li><p><em>targetAbsoluteEnd</em>
&ndash; the end time of the target interval relative to the start of the original audio file. 
</p>
</li>
<li><p><em>targetStart</em>
&ndash; the start time of the target interval relative to the start of the window extracted. 
</p>
</li>
<li><p><em>targetEnd</em>
&ndash; the end time of the target interval relative to the start of the window extracted.
</p>
</li>
<li><p><em>targetDuration</em>
&ndash; the duration of the target interval.
</p>
</li>
<li><p><em>sampleNumber</em>
&ndash; the number of the sample within the set of samples being processed. 
</p>
</li>
<li><p><em>sampleName$</em>
&ndash; the name of the extracted/selected Sound object.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame of acoustic measures, one row for each matchId.
</p>


<h3>See Also</h3>

<p><a href="#topic+praatScriptFormants">praatScriptFormants</a>
</p>
<p><a href="#topic+praatScriptCentreOfGravity">praatScriptCentreOfGravity</a>
</p>
<p><a href="#topic+praatScriptIntensity">praatScriptIntensity</a>
</p>
<p><a href="#topic+praatScriptPitch">praatScriptPitch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Perform a search
results &lt;- getMatches(labbcat.url, list(segment="I"))

## get F1 and F2 for the mid point of the vowel
formants &lt;- processWithPraat(
       labbcat.url,
       results$MatchId, results$Target.segment.start, results$Target.segment.end,
       praatScriptFormants())

## get first 3 formants at three points during the sample, the mean, min, and max
## pitch, the max intensity, and the CoG using powers 1 and 2 
acoustic.measurements &lt;- processWithPraat(
       labbcat.url,
       results$MatchId, results$Target.segment.start, results$Target.segment.end,
       paste(
           praatScriptFormants(c(1,2,3), c(0.25,0.5,0.75)),
           praatScriptPitch(get.mean=TRUE, get.minimum=TRUE, get.maximum=TRUE),
           praatScriptIntensity(),
           praatScriptCentreOfGravity(powers=c(1.0,2.0))),
       window.offset=0.5)

## execute a custom script loaded form a file
acoustic.measurements &lt;- processWithPraat(
       labbcat.url,
       results$MatchId, results$Target.segment.start, result$Target.segment.end,
       readLines("acousticMeasurements.praat"))

## End(Not run)
</code></pre>

<hr>
<h2 id='removeDictionaryEntry'>Removes an entry from a dictionary.</h2><span id='topic+removeDictionaryEntry'></span>

<h3>Description</h3>

<p>This function removes an existing entry from the given dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeDictionaryEntry(
  labbcat.url,
  manager.id,
  dictionary.id,
  key,
  entry = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeDictionaryEntry_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="removeDictionaryEntry_+3A_manager.id">manager.id</code></td>
<td>
<p>The layer manager ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="removeDictionaryEntry_+3A_dictionary.id">dictionary.id</code></td>
<td>
<p>The ID of the dictionary, as returned by getDictionaries</p>
</td></tr>
<tr><td><code id="removeDictionaryEntry_+3A_key">key</code></td>
<td>
<p>The key (word) in the dictionary to remove an entry for.</p>
</td></tr>
<tr><td><code id="removeDictionaryEntry_+3A_entry">entry</code></td>
<td>
<p>The value (definition) for the given key, or NULL to remove all entries
for the key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have edit privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL if the entry was removed, or a list of error messages if not.
</p>


<h3>See Also</h3>

<p><a href="#topic+getDictionaries">getDictionaries</a>
</p>
<p><a href="#topic+getDictionaryEntries">getDictionaryEntries</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Remove a pronuciation of the word "robert" from the CELEX wordform pronunciation dictionary
removeDictionaryEntry(labbcat.url, "CELEX-EN", "Phonology (wordform)", "robert", "'rQ-bErt")

## End(Not run)

</code></pre>

<hr>
<h2 id='removeLayerDictionaryEntry'>Removes an entry from a layer dictionary.</h2><span id='topic+removeLayerDictionaryEntry'></span>

<h3>Description</h3>

<p>This function removes an existing entry from the dictionary that manages a given layer,
and updates all affected tokens in the corpus. Words can have multiple entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeLayerDictionaryEntry(labbcat.url, layer.id, key, entry = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeLayerDictionaryEntry_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="removeLayerDictionaryEntry_+3A_layer.id">layer.id</code></td>
<td>
<p>The ID of the layer with a dictionary configured to manage it.</p>
</td></tr>
<tr><td><code id="removeLayerDictionaryEntry_+3A_key">key</code></td>
<td>
<p>The key (word) in the dictionary to remove an entry from.</p>
</td></tr>
<tr><td><code id="removeLayerDictionaryEntry_+3A_entry">entry</code></td>
<td>
<p>The value (definition) for the given key, or NULL to remove all entries
for the given key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have edit privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>NULL if the entry was added, or a list of error messages if not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateLayer">generateLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Remove a pronunciation for "robert" from the phonemes layer dictionary
removeLayerDictionaryEntry(labbcat.url, "phonemes", "robert", "'rQ-bErt")

## End(Not run)

</code></pre>

<hr>
<h2 id='renameParticipants'>Renames a list of participants.</h2><span id='topic+renameParticipants'></span>

<h3>Description</h3>

<p>This function changes the IDs of a given set of participants, where possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameParticipants(labbcat.url, current.ids, new.ids, no.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameParticipants_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="renameParticipants_+3A_current.ids">current.ids</code></td>
<td>
<p>A vector of participant IDs that as they are currently defined in
the corpus.</p>
</td></tr>
<tr><td><code id="renameParticipants_+3A_new.ids">new.ids</code></td>
<td>
<p>A vector of new participant IDs, each element corresponding to an ID in
current.ids.</p>
</td></tr>
<tr><td><code id="renameParticipants_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of results, each element corresponding to an ID in current.ids. If the
ID was successfully changed, the corresponding element is TRUE. If the ID could not
be changed (e.g. because there is already an existing participant using the new ID),
then the corresponding element is FALSE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParticipantIds">getParticipantIds</a></code>
<code><a href="#topic+getMatchingParticipantIds">getMatchingParticipantIds</a></code>
<code><a href="#topic+getParticipant">getParticipant</a></code>
<code><a href="#topic+saveParticipant">saveParticipant</a></code>
<code><a href="#topic+deleteParticipant">deleteParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Create some new participant records
old.ids &lt;- c("test-id-1","test-id-2","test-id-3")
for (id in old.ids) saveParticipant(labbcat.url, id)

## Batch change the IDs
new.ids &lt;- c("test-id-1-changed","test-id-2-changed","test-id-3-changed")
renameParticipants(labbcat.url, old.ids, new.ids)

## Delete the participants we just created
for (id in new.ids) deleteParticipant(labbcat.url, id)

## End(Not run)

</code></pre>

<hr>
<h2 id='saveLayer'>Saves the details of an existing layer.</h2><span id='topic+saveLayer'></span>

<h3>Description</h3>

<p>This function saves the definition of an existing annotation layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveLayer(labbcat.url, layer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveLayer_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="saveLayer_+3A_layer">layer</code></td>
<td>
<p>A named list object representing the layer attributes, as would be
returned by <a href="#topic+getLayer">getLayer</a> or <a href="#topic+newLayer">newLayer</a>, with members:
</p>

<ul>
<li><p><em>id</em> The layer's unique ID
</p>
</li>
<li><p><em>parentId</em> The layer's parent layer ID
</p>
</li>
<li><p><em>description</em> The description of the layer
</p>
</li>
<li><p><em>alignment</em> The layer's alignment - 0 for none, 1 for point alignment, 2
for interval alignment 
</p>
</li>
<li><p><em>peers</em> Whether children have peers or not
</p>
</li>
<li><p><em>peersOverlap</em> Whether child peers can overlap or not
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>saturated</em> Whether children must temporally fill the entire parent
duration (true) or not (false) 
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>type</em> The type for labels on this layer
</p>
</li>
<li><p><em>validLabels</em> List of valid label values for this layer
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have administration privileges in LaBB-CAT in order to be able to use this function.
</p>


<h3>Value</h3>

<p>The resulting layer definition, with members:
</p>

<ul>
<li><p><em>id</em> The layer's unique ID
</p>
</li>
<li><p><em>parentId</em> The layer's parent layer ID
</p>
</li>
<li><p><em>description</em> The description of the layer
</p>
</li>
<li><p><em>alignment</em> The layer's alignment - 0 for none, 1 for point alignment, 2
for interval alignment 
</p>
</li>
<li><p><em>peers</em> Whether children have peers or not
</p>
</li>
<li><p><em>peersOverlap</em> Whether child peers can overlap or not
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>saturated</em> Whether children must temporally fill the entire parent
duration (true) or not (false) 
</p>
</li>
<li><p><em>parentIncludes</em> Whether the parent t-includes the child
</p>
</li>
<li><p><em>type</em> The type for labels on this layer
</p>
</li>
<li><p><em>validLabels</em> List of valid label values for this layer
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+newLayer">newLayer</a></code>
<code><a href="#topic+getLayer">getLayer</a></code>
<code><a href="#topic+deleteLayer">deleteLayer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Get the pronunciation layer definition
pronunciation &lt;- getLayer(labbcat.url, "pronunciation")

## Change some details of the definition
pronunciation$description &lt;- "CMU Dict pronunciations encoded in DISC"
pronunciation$type &lt;- "ipa"

## Save the changes to the layer definition
saveLayer(labbcat.url, pronunciation)

## End(Not run)

</code></pre>

<hr>
<h2 id='saveParticipant'>Saves information about a single participant.</h2><span id='topic+saveParticipant'></span>

<h3>Description</h3>

<p>This function allows the participant attributes and the ID of a given participant to be
updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveParticipant(labbcat.url, id, label = id, attributes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveParticipant_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="saveParticipant_+3A_id">id</code></td>
<td>
<p>The participant ID - either the unique internal database ID, or their name.</p>
</td></tr>
<tr><td><code id="saveParticipant_+3A_label">label</code></td>
<td>
<p>The new ID (name) for the participant</p>
</td></tr>
<tr><td><code id="saveParticipant_+3A_attributes">attributes</code></td>
<td>
<p>A named list of participant attribute values - the names are the
participant attribute layer IDs, and the values are the corresponding new attribute
values. The pass phrase for participant access can also be set by specifying a &quot;_password&quot;
attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To change the ID of an existing participant, pass the old/current ID as the <code>id</code>,
and pass the new ID as the <code>label</code>.
</p>
<p>If the participant ID does not already exist in the database, a new participant record
is created.
</p>


<h3>Value</h3>

<p>TRUE if the participant's record was updated, FALSE if there were no changes detected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParticipant">getParticipant</a></code>
</p>
<p><code><a href="#topic+deleteParticipant">deleteParticipant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## Create a new participant record
saveParticipant(labbcat.url, "Juan Perez", attributes=list(participant_gender="M"))

## Change the name and the gender of the participant record
saveParticipant(labbcat.url, "Juan Perez", "Maria Perez", list(participant_gender="F"))

### Delete the participant we just created
deleteParticipant(labbcat.url, "Maria Perez")

## End(Not run)

</code></pre>

<hr>
<h2 id='updateFragment'>Update a transcript fragment.</h2><span id='topic+updateFragment'></span>

<h3>Description</h3>

<p>This function uploads a file (e.g. Praat TextGrid) representing a fragment of a
transcript, with annotations or alignments to update in LaBB-CAT's version of the
transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateFragment(labbcat.url, fragment.path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateFragment_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="updateFragment_+3A_fragment.path">fragment.path</code></td>
<td>
<p>The path to the fragment to upload.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the credentials used to connect to the server must have at
least 'edit' access.
</p>


<h3>Value</h3>

<p>A named list with information about the fragment that was updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## upload new verison of transcript transcript
updateFragment(labbcat.url, "my-transcript__1.234-5.678.TextGrid")

## End(Not run)
</code></pre>

<hr>
<h2 id='updateTranscript'>Update an existing transcript.</h2><span id='topic+updateTranscript'></span>

<h3>Description</h3>

<p>This function uploads a new version of an existing transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateTranscript(labbcat.url, transcript.path, no.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateTranscript_+3A_labbcat.url">labbcat.url</code></td>
<td>
<p>URL to the LaBB-CAT instance</p>
</td></tr>
<tr><td><code id="updateTranscript_+3A_transcript.path">transcript.path</code></td>
<td>
<p>The path to the transcript to upload.</p>
</td></tr>
<tr><td><code id="updateTranscript_+3A_no.progress">no.progress</code></td>
<td>
<p>TRUE to supress visual progress bar. Otherwise, progress bar will be
shown when interactive().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the credentials used to connect to the server must have at
least 'edit' access.
</p>


<h3>Value</h3>

<p>The ID of the updated transcript in the corpus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define the LaBB-CAT URL
labbcat.url &lt;- "https://labbcat.canterbury.ac.nz/demo/"

## upload new verison of transcript transcript
updateTranscript(labbcat.url, "my-transcript.eaf")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
