<!DOCTYPE html><html lang="en-US"><head><title>Help for package ggmulti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggmulti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggmulti-package'><p>ggmulti: High Dimensional Data Visualization</p></a></li>
<li><a href='#add_serialaxes_layers'><p>Layers for serial axes coordinate</p></a></li>
<li><a href='#coord_radar-deprecated'><p>coord_radar (deprecated)</p></a></li>
<li><a href='#coord_radial'><p>Radial axes</p></a></li>
<li><a href='#coord_serialaxes'><p>Serial axes coordinates</p></a></li>
<li><a href='#dot_product'><p>Transformation Coefficients</p></a></li>
<li><a href='#geom_density_'><p>More general smoothed density estimates</p></a></li>
<li><a href='#geom_hist_'><p>More general histogram</p></a></li>
<li><a href='#geom_image_glyph'><p>Add image glyphs on scatter plot</p></a></li>
<li><a href='#geom_polygon_glyph'><p>Add polygon glyphs on scatter plot</p></a></li>
<li><a href='#geom_quantiles'><p>Add quantile layers on serial axes coordinate</p></a></li>
<li><a href='#geom_serialaxes'><p>Serial axes layer</p></a></li>
<li><a href='#geom_serialaxes_density'><p>Smoothed density estimates for &quot;widens&quot; data under serial axes coordinate</p></a></li>
<li><a href='#geom_serialaxes_glyph'><p>Add serial axes glyphs on scatter plot</p></a></li>
<li><a href='#geom_serialaxes_hist'><p>Histogram for &quot;widens&quot; data under serial axes coordinate</p></a></li>
<li><a href='#geom_serialaxes_quantile'><p>Quantile layer for serial axes coordinate</p></a></li>
<li><a href='#Geom-ggproto'><p>Base Geom ggproto classes for ggplot2</p></a></li>
<li><a href='#get_scaledData'><p>scale data</p></a></li>
<li><a href='#ggmulti-deprecated'><p>Deprecated functions in package <span class="pkg">ggmulti</span>.</p></a></li>
<li><a href='#NBAstats2021'><p>NBA 30 Teams Statistics in 20-21 Regular Season</p></a></li>
<li><a href='#polygon_glyph'><p>Polygon glyph coordinates</p></a></li>
<li><a href='#position_dodge_'><p>Dodge overlapping objects side-to-side</p></a></li>
<li><a href='#position_identity_'><p>Don't adjust position</p></a></li>
<li><a href='#position_stack_'><p>Stack overlapping objects on top of each another</p></a></li>
<li><a href='#Position-ggproto'><p>Base Position ggproto classes for ggplot2</p></a></li>
<li><a href='#Stat-ggproto'><p>Base Stat ggproto classes for ggplot2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Dimensional Data Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>It provides materials (i.e. 'serial axes' objects, Andrew's plot, various glyphs for scatter plot) to visualize high dimensional data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), methods, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, grid, dplyr, tidyr, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>png, tools, stringr, markdown, magrittr, gridExtra, tibble,
testthat, grDevices, knitr, rmarkdown, tidyverse, gtable, covr,
maps, nycflights13, ggplot2movies</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 13:22:24 UTC; zehaoxu</td>
</tr>
<tr>
<td>Author:</td>
<td>Zehao Xu [aut, cre],
  R. Wayne Oldford [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zehao Xu &lt;z267xu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-09 09:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggmulti-package'>ggmulti: High Dimensional Data Visualization</h2><span id='topic+ggmulti-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>It provides materials (i.e. 'serial axes' objects, Andrew's plot, various glyphs for scatter plot) to visualize high dimensional data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zehao Xu <a href="mailto:z267xu@uwaterloo.ca">z267xu@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> R. Wayne Oldford <a href="mailto:rwoldford@uwaterloo.ca">rwoldford@uwaterloo.ca</a>
</p>
</li></ul>


<hr>
<h2 id='add_serialaxes_layers'>Layers for serial axes coordinate</h2><span id='topic+add_serialaxes_layers'></span>

<h3>Description</h3>

<p>Project the regular <code>geom</code> layers onto the serial axes coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_serialaxes_layers(layer, plot, object, axes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_serialaxes_layers_+3A_layer">layer</code></td>
<td>
<p>a layer object</p>
</td></tr>
<tr><td><code id="add_serialaxes_layers_+3A_plot">plot</code></td>
<td>
<p>a <code>ggplot</code> object</p>
</td></tr>
<tr><td><code id="add_serialaxes_layers_+3A_object">object</code></td>
<td>
<p>some parameters used to modify this serial axes <code>ggplot</code> object (i.e. <code>axes.sequence</code>, ...)</p>
</td></tr>
<tr><td><code id="add_serialaxes_layers_+3A_axes">axes</code></td>
<td>
<p>canvas sequence axes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class is determined by layers you add. For example, you want to add a boxplot layer
on serial axes coordinate.
By the ggplot syntax, it should be <code>ggplot(data, mapping) + geom_boxplot() + coord_serialaxes()</code>
To make it work, object <code>add_serialaxes_layers.GeomBoxplot</code> must be created. In this function,
some computations will be applied.
</p>

<hr>
<h2 id='coord_radar-deprecated'>coord_radar (deprecated)</h2><span id='topic+coord_radar-deprecated'></span><span id='topic+coord_radar'></span>

<h3>Description</h3>

<p>use <code><a href="#topic+coord_radial">coord_radial</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_radar(theta = "x", start = 0, direction = 1, clip = "on")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coord_radar-deprecated_+3A_theta">theta</code></td>
<td>
<p>variable to map angle to (<code>x</code> or <code>y</code>)</p>
</td></tr>
<tr><td><code id="coord_radar-deprecated_+3A_start">start</code></td>
<td>
<p>Offset of starting point from 12 o'clock in radians. Offset
is applied clockwise or anticlockwise depending on value of <code>direction</code>.</p>
</td></tr>
<tr><td><code id="coord_radar-deprecated_+3A_direction">direction</code></td>
<td>
<p>1, clockwise; -1, anticlockwise</p>
</td></tr>
<tr><td><code id="coord_radar-deprecated_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. For details, please see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='coord_radial'>Radial axes</h2><span id='topic+coord_radial'></span>

<h3>Description</h3>

<p>A radial (spider) coordinate. A wrapper of the function <code>coord_polar()</code> by
forcing it linear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_radial(theta = "x", start = 0, direction = 1, clip = "on")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coord_radial_+3A_theta">theta</code></td>
<td>
<p>variable to map angle to (<code>x</code> or <code>y</code>)</p>
</td></tr>
<tr><td><code id="coord_radial_+3A_start">start</code></td>
<td>
<p>Offset of starting point from 12 o'clock in radians. Offset
is applied clockwise or anticlockwise depending on value of <code>direction</code>.</p>
</td></tr>
<tr><td><code id="coord_radial_+3A_direction">direction</code></td>
<td>
<p>1, clockwise; -1, anticlockwise</p>
</td></tr>
<tr><td><code id="coord_radial_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. For details, please see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The serial histogram and serial density cannot be applied on
a radial coordinate yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("dplyr")) {
ggplot(NBAstats2021, mapping = aes(colour = Playoff)) +
  geom_serialaxes(
    axes.sequence = c("PTS", "OPTS", "3PM", "O3PM", "PTS"),
      scaling = "variable"
    ) +
  coord_radial() +
  scale_x_continuous(
    breaks = 1:5,
    labels = c("Points",
               "Oppo Points",
               "3P Made",
               "Oppo 3P Made",
               "Points Per Game")) +
  scale_y_continuous(labels = NULL) +
  facet_wrap(~CONF)
  }
</code></pre>

<hr>
<h2 id='coord_serialaxes'>Serial axes coordinates</h2><span id='topic+coord_serialaxes'></span>

<h3>Description</h3>

<p>It is mainly used to visualize the high dimensional data set
either on the parallel coordinate or the radial coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_serialaxes(
  axes.layout = c("parallel", "radial"),
  scaling = c("data", "variable", "observation", "none"),
  axes.sequence = character(0L),
  positive = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coord_serialaxes_+3A_axes.layout">axes.layout</code></td>
<td>
<p>Serial axes layout, either &quot;parallel&quot; or &quot;radial&quot;.</p>
</td></tr>
<tr><td><code id="coord_serialaxes_+3A_scaling">scaling</code></td>
<td>
<p>One of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="coord_serialaxes_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector with variable names that defines the axes sequence.</p>
</td></tr>
<tr><td><code id="coord_serialaxes_+3A_positive">positive</code></td>
<td>
<p>If <code>y</code> is set as the density estimate, where the smoothed curved is faced to,
right (<code>positive</code>) or left (<code>negative</code>) as vertical layout;
up (<code>positive</code>) or down (<code>negative</code>) as horizontal layout?</p>
</td></tr>
<tr><td><code id="coord_serialaxes_+3A_...">...</code></td>
<td>
<p>other arguments used to modify layers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Serial axes coordinate system (parallel or radial) is different from the
Cartesian coordinate system or its transformed system (say <code>polar</code> in <code>ggplot2</code>)
since it does not have a formal transformation
(i.e. in polar coordinate system, &quot;x = rcos(theta)&quot;, &quot;y = rsin(theta)&quot;).
In serial axes coordinate system, mapping aesthetics does not really require &quot;x&quot; or &quot;y&quot;. Any &quot;non-aesthetics&quot;
components passed in the <code>mapping</code> system will be treated as an individual axis.
</p>
<p>To project a common <code>geom</code> layer on such serialaxes,
users can customize function <code><a href="#topic+add_serialaxes_layers">add_serialaxes_layers</a></code>.
</p>


<h3>Value</h3>

<p>a <code>ggproto</code> object
</p>


<h3>Potential Risk</h3>

<p>In package <code>ggmulti</code>, the function <code>ggplot_build.gg</code> is provided.
At the <code>ggplot</code> construction time, the system will call <code>ggplot_build.gg</code>
first. If the plot input is not a <code>CoordSerialaxes</code> coordinate system, the next method
<code>ggplot_build.ggplot</code> will be called to build a &quot;gg&quot; plot; else
some geometric transformations will be applied first, then the next method
<code>ggplot_build.ggplot</code> will be executed. So, the potential risk is, if some other packages
e.g. <code>foo</code>, also provide a function <code>ggplot_build.gg</code> that is used for their
specifications but the namespace is beyond the <code>ggmulti</code> (<code>ggmulti:::ggplot_build.gg</code> is
covered), error may occur. If so, please consider using the
<code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("dplyr")) {
# Data
nba &lt;- NBAstats2021 %&gt;%
  mutate(
    dPTS = PTS - OPTS,
    dREB = REB - OREB,
    dAST = AST - OAST,
    dTO = TO - OTO
  )
# set sequence by `axes.sequence`
p &lt;- ggplot(nba,
            mapping = aes(
              dPTS = dPTS,
              dREB = dREB,
              dAST = dAST,
              dTO = dTO,
              colour = Win
            )) +
       geom_path(alpha = 0.2) +
       coord_serialaxes(axes.layout = "radial") +
       scale_color_gradient(low="blue", high="red")
p
# quantile layer
p + geom_quantiles(quantiles = c(0.5),
                   colour = "green", linewidth = 1.2)

# facet
p +
  facet_grid(Playoff ~ CONF)
}
</code></pre>

<hr>
<h2 id='dot_product'>Transformation Coefficients</h2><span id='topic+dot_product'></span><span id='topic+andrews'></span><span id='topic+legendre'></span>

<h3>Description</h3>

<p>The dimension of the original data set is <code>n\*p</code>. It can be projected
onto a <code>n\*k</code> space. The functions below are to provide such transformations, e.g.
the <code>Andrews coefficient</code> (a Fourier transformation) and the <code>Legendre</code> polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>andrews(p = 4, k = 50 * (p - 1), ...)

legendre(p = 4, k = 50 * (p - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot_product_+3A_p">p</code></td>
<td>
<p>The number of dimensions</p>
</td></tr>
<tr><td><code id="dot_product_+3A_k">k</code></td>
<td>
<p>The sequence length</p>
</td></tr>
<tr><td><code id="dot_product_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Mainly used for customized transformation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains two named components
</p>

<ol>
<li><p> vector: A length <code>k</code> vector (define the domain)
</p>
</li>
<li><p> matrix: A <code>p\*k</code> transformed coefficient matrix
</p>
</li></ol>



<h3>References</h3>

<p>Andrews, David F. &quot;Plots of high-dimensional data.&quot; <em>Biometrics</em> (1972): 125-136.
</p>
<p>Abramowitz, Milton, and Irene A. Stegun, eds. &quot;Chapter 8&quot;
<em>Handbook of mathematical functions with formulas, graphs, and mathematical tables</em>.
Vol. 55. US Government printing office, 1948.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- andrews(p = 4)
dat &lt;- iris[, -5]
proj &lt;- t(as.matrix(dat) %*% x$matrix)
matplot(x$vector, proj,
        type = "l", lty = 1,
        col = "black",
        xlab = "x",
        ylab = "Andrews coefficients",
        main = "Iris")
</code></pre>

<hr>
<h2 id='geom_density_'>More general smoothed density estimates</h2><span id='topic+geom_density_'></span><span id='topic+stat_density_'></span>

<h3>Description</h3>

<p>Computes and draws kernel density estimate.
Compared with <code>geom_density()</code>, it provides more general cases that
accepting <code>x</code> and <code>y</code>. See details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_density_(
  mapping = NULL,
  data = NULL,
  stat = "density_",
  position = "identity_",
  ...,
  scale.x = NULL,
  scale.y = c("data", "group", "variable"),
  as.mix = FALSE,
  positive = TRUE,
  prop = 0.9,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_(
  mapping = NULL,
  data = NULL,
  geom = "density_",
  position = "stack_",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  trim = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_density__+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_density__+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_scale.x">scale.x</code></td>
<td>
<p>A sorted length 2 numerical vector representing
the range of the whole data will be scaled to. The default value is (0, 1).</p>
</td></tr>
<tr><td><code id="geom_density__+3A_scale.y">scale.y</code></td>
<td>
<p>one of <code>data</code> and <code>group</code> to specify.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
 <td style="text-align: left;"> data (default) </td><td style="text-align: left;"> The density estimates are scaled by the whole data set
</td>
</tr>
<tr>
 <td style="text-align: left;"> group </td><td style="text-align: left;"> The density estimates are scaled by each group
</td>
</tr>

</table>

<p>If the <code>scale.y</code> is <code>data</code>, it is meaningful to compare the density (shape and area) across all groups; else
it is only meaningful to compare the density within each group. See details.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_as.mix">as.mix</code></td>
<td>
<p>Logical. Within each group, if <code>TRUE</code>, the sum of the density estimate area is mixed and
scaled to maximum 1. The area of each subgroup (in general, within each group one color represents one subgroup)
is proportional to the count; if <code>FALSE</code> the area of each subgroup is the same, with maximum 1. See details.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_positive">positive</code></td>
<td>
<p>If <code>y</code> is set as the density estimate, where the smoothed curved is faced to,
right ('positive') or left ('negative') as vertical layout; up ('positive') or down ('negative') as horizontal layout?</p>
</td></tr>
<tr><td><code id="geom_density__+3A_prop">prop</code></td>
<td>
<p>adjust the proportional maximum height of the estimate (density, histogram, ...).</p>
</td></tr>
<tr><td><code id="geom_density__+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_geom">geom</code>, <code id="geom_density__+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_density()</code> and <code>stat_density()</code>.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density__+3A_n">n</code></td>
<td>
<p>number of equally spaced points at which the density is to be
estimated, should be a power of two, see <code><a href="stats.html#topic+density">density()</a></code> for
details</p>
</td></tr>
<tr><td><code id="geom_density__+3A_trim">trim</code></td>
<td>
<p>If <code>FALSE</code>, the default, each density is computed on the
full range of the data. If <code>TRUE</code>, each density is computed over the
range of that group: this typically means the estimated x values will
not line-up, and hence you won't be able to stack density values.
This parameter only matters if you are displaying multiple densities in
one plot or if you are manually adjusting the scale limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>x</code> (or <code>y</code>) is a group variable (categorical) and <code>y</code> (or <code>x</code>) is the target variable (numerical) to be plotted.
If only one of <code>x</code> or <code>y</code> is provided, it will treated as a target variable and
<code>ggplot2::geom_density</code> will be executed.
</p>
<p>There are four combinations of <code>scale.y</code> and <code>as.mix</code>.
</p>

<dl>
<dt><code>scale.y</code> = &quot;group&quot; and <code>as.mix</code> = FALSE</dt><dd><p>The density estimate area of each subgroup (represented by each color)
within the same group is the same.</p>
</dd>
<dt><code>scale.y</code> = &quot;group&quot; and <code>as.mix</code> = TRUE</dt><dd><p>The density estimate area of each subgroup (represented by each color)
within the same group is proportional to its own counts.</p>
</dd>
<dt><code>scale.y</code> = &quot;data&quot; and <code>as.mix</code> = FALSE</dt><dd><p>The sum of density estimate area of all groups is scaled to maximum of 1.
and the density area for each group is proportional to the its count. Within each group, the area of each subgroup is the same.</p>
</dd>
<dt><code>scale.y</code> = &quot;data&quot; and <code>as.mix</code> = TRUE</dt><dd><p>The sum of density estimate area of all groups is scaled to maximum of 1
and the area of each subgroup (represented by each color) is proportional to its own count.</p>
</dd>
</dl>

<p>See vignettes[https://great-northern-diver.github.io/ggmulti/articles/histogram-density-.html] for more intuitive explanation.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>See Also</h3>

<p><code>geom_density</code>, <code><a href="#topic+geom_hist_">geom_hist_</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(dplyr)) {
  mpg %&gt;%
    dplyr::filter(drv != "f") %&gt;%
    ggplot(mapping = aes(x = drv, y = cty, fill = factor(cyl))) +
    geom_density_(alpha = 0.1)

  # only `x` or `y` is provided
  # that would be equivalent to call function `geom_density()`
  diamonds %&gt;%
    dplyr::sample_n(500) %&gt;%
    ggplot(mapping = aes(x = price)) +
    geom_density_()

  # density and boxplot
  # set the density estimate on the left
  mpg %&gt;%
    dplyr::filter(drv != "f") %&gt;%
    ggplot(mapping = aes(x = drv, y = cty,
                         fill = factor(cyl))) +
    geom_density_(alpha = 0.1,
                  scale.y = "group",
                  as.mix = FALSE,
                  positive = FALSE) +
    geom_boxplot()

  # x as density
  set.seed(12345)
  suppressWarnings(
    diamonds %&gt;%
      dplyr::sample_n(500) %&gt;%
      ggplot(mapping = aes(x = price, y = cut, fill = color)) +
      geom_density_(orientation = "x", prop = 0.25,
                    position = "stack_",
                    scale.y = "group")
  )
}
# settings of `scale.y` and `as.mix`

ggplots &lt;- lapply(list(
                      list(scale.y = "data", as.mix = TRUE),
                      list(scale.y = "data", as.mix = FALSE),
                      list(scale.y = "group", as.mix = TRUE),
                      list(scale.y = "group", as.mix = FALSE)
                    ),
                   function(vars) {
                     scale.y &lt;- vars[["scale.y"]]
                     as.mix &lt;- vars[["as.mix"]]
                     ggplot(mpg,
                            mapping = aes(x = drv, y = cty, fill = factor(cyl))) +
                       geom_density_(alpha = 0.1, scale.y = scale.y, as.mix = as.mix) +
                       labs(title = paste("scale.y =", scale.y),
                            subtitle = paste("as.mix =", as.mix))
                   })
suppressWarnings(
  gridExtra::grid.arrange(grobs = ggplots)
)

</code></pre>

<hr>
<h2 id='geom_hist_'>More general histogram</h2><span id='topic+geom_hist_'></span><span id='topic+geom_histogram_'></span><span id='topic+geom_bar_'></span><span id='topic+stat_hist_'></span><span id='topic+stat_bin_'></span><span id='topic+stat_count_'></span>

<h3>Description</h3>

<p>More general histogram (<code>geom_histogram</code>) or bar plot (<code>geom_bar</code>).
Both <code>x</code> and <code>y</code> could be accommodated. See details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_hist_(
  mapping = NULL,
  data = NULL,
  stat = "hist_",
  position = "stack_",
  ...,
  scale.x = NULL,
  scale.y = c("data", "group", "variable"),
  as.mix = FALSE,
  binwidth = NULL,
  bins = NULL,
  positive = TRUE,
  prop = 0.9,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_histogram_(
  mapping = NULL,
  data = NULL,
  stat = "bin_",
  position = "stack_",
  ...,
  scale.x = NULL,
  scale.y = c("data", "group"),
  as.mix = FALSE,
  positive = TRUE,
  prop = 0.9,
  binwidth = NULL,
  bins = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_bar_(
  mapping = NULL,
  data = NULL,
  stat = "count_",
  position = "stack_",
  ...,
  scale.x = NULL,
  scale.y = c("data", "group"),
  positive = TRUE,
  prop = 0.9,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_hist_(
  mapping = NULL,
  data = NULL,
  geom = "bar_",
  position = "stack_",
  ...,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  breaks = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_(
  mapping = NULL,
  data = NULL,
  geom = "bar_",
  position = "stack_",
  ...,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  breaks = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_count_(
  mapping = NULL,
  data = NULL,
  geom = "bar_",
  position = "stack_",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_hist__+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Function <code>geom_hist_</code> and <code>geom_histogram_</code> understand <code>stack_</code> (stacks bars on top of each other),
or <code>dodge_</code> and <code>dodge2_</code> (overlapping objects side-to-side) instead of <code>stack</code>, <code>dodge</code> or <code>dodge2</code></p>
</td></tr>
<tr><td><code id="geom_hist__+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_scale.x">scale.x</code></td>
<td>
<p>A sorted length 2 numerical vector representing
the range of the whole data will be scaled to. The default value is (0, 1).</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_scale.y">scale.y</code></td>
<td>
<p>one of <code>data</code> and <code>group</code> to specify.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
 <td style="text-align: left;"> data (default) </td><td style="text-align: left;"> The density estimates are scaled by the whole data set
</td>
</tr>
<tr>
 <td style="text-align: left;"> group </td><td style="text-align: left;"> The density estimates are scaled by each group
</td>
</tr>

</table>

<p>If the <code>scale.y</code> is <code>data</code>, it is meaningful to compare the density (shape and area) across all groups; else
it is only meaningful to compare the density within each group. See details.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_as.mix">as.mix</code></td>
<td>
<p>Logical. Within each group, if <code>TRUE</code>, the sum of the density estimate area is mixed and
scaled to maximum 1. The area of each subgroup (in general, within each group one color represents one subgroup)
is proportional to the count; if <code>FALSE</code> the area of each subgroup is the same, with maximum 1. See details.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. Can be specified as a numeric value
or as a function that calculates width from unscaled x. Here, &quot;unscaled x&quot;
refers to the original x values in the data, before application of any
scale transformation. When specifying a function along with a grouping
structure, the function will be called once per group.
The default is to use the number of bins in <code>bins</code>,
covering the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.
</p>
<p>The bin width of a date variable is the number of days in each time; the
bin width of a time variable is the number of seconds.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_positive">positive</code></td>
<td>
<p>If <code>y</code> is set as the density estimate, where the smoothed curved is faced to,
right ('positive') or left ('negative') as vertical layout; up ('positive') or down ('negative') as horizontal layout?</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_prop">prop</code></td>
<td>
<p>adjust the proportional maximum height of the estimate (density, histogram, ...).</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_geom">geom</code>, <code id="geom_hist__+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between geom_hist_()/geom_histogram_()/geom_bar_() and
stat_hist_()/stat_bin_()/stat_count_().</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_center">center</code>, <code id="geom_hist__+3A_boundary">boundary</code></td>
<td>
<p>bin position specifiers. Only one, <code>center</code> or
<code>boundary</code>, may be specified for a single plot. <code>center</code> specifies the
center of one of the bins. <code>boundary</code> specifies the boundary between two
bins. Note that if either is above or below the range of the data, things
will be shifted by the appropriate integer multiple of <code>binwidth</code>.
For example, to center on integers use <code>binwidth = 1</code> and <code>center = 0</code>, even
if <code>0</code> is outside the range of the data. Alternatively, this same alignment
can be specified with <code>binwidth = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is
outside the range of the data.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_breaks">breaks</code></td>
<td>
<p>Alternatively, you can supply a numeric vector giving
the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>,
and <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures
frequency polygons touch 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_hist__+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the <code><a href="ggplot2.html#topic+resolution">resolution()</a></code> of the
data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> (or <code>y</code>) is a group variable (categorical) and <code>y</code> (or <code>x</code>) a target variable (numerical) to be plotted.
If only one of <code>x</code> or <code>y</code> is provided, it will treated as a target variable and
<code>ggplot2::geom_histogram</code> will be executed. Several things should be noticed:
</p>
<p>1. If both <code>x</code> and <code>y</code> are given, they can be one discrete one continuous or
two discrete. But they cannot be two continuous variables (which one will be considered as a group variable?).
</p>
<p>2. <code>geom_hist_</code> is a wrapper of <code>geom_histogram_</code> and <code>geom_count_</code>.
Suppose the <code>y</code> is our interest (<code>x</code> is the categorical variable),
<code>geom_hist_()</code> can accommodate either continuous or discrete <code>y</code>. While,
<code>geom_histogram_()</code> only accommodates the continuous <code>y</code> and
<code>geom_bar_()</code> only accommodates the discrete <code>y</code>.
</p>
<p>3. There are four combinations of <code>scale.y</code> and <code>as.mix</code>.
</p>

<dl>
<dt><code>scale.y</code> = &quot;group&quot; and <code>as.mix</code> = FALSE</dt><dd><p>The density estimate area of each subgroup (represented by each color)
within the same group is the same.</p>
</dd>
<dt><code>scale.y</code> = &quot;group&quot; and <code>as.mix</code> = TRUE</dt><dd><p>The density estimate area of each subgroup (represented by each color)
within the same group is proportional to its own counts.</p>
</dd>
<dt><code>scale.y</code> = &quot;data&quot; and <code>as.mix</code> = FALSE</dt><dd><p>The sum of density estimate area of all groups is scaled to maximum of 1.
and the density area for each group is proportional to the its count. Within each group, the area of each subgroup is the same.</p>
</dd>
<dt><code>scale.y</code> = &quot;data&quot; and <code>as.mix</code> = TRUE</dt><dd><p>The sum of density estimate area of all groups is scaled to maximum of 1
and the area of each subgroup (represented by each color) is proportional to its own count.</p>
</dd>
</dl>

<p>See vignettes[https://great-northern-diver.github.io/ggmulti/articles/histogram-density-.html] for more intuitive explanation.
Note that, if it is a grouped bar chart (both <code>x</code> and <code>y</code> are categorical),
parameter 'as.mix' is meaningless.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>See Also</h3>

<p><code>geom_histogram</code>, <code><a href="#topic+geom_density_">geom_density_</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(dplyr) &amp;&amp; require(tidyr)) {

  # histogram
  p0 &lt;- mpg %&gt;%
    dplyr::filter(manufacturer %in% c("dodge", "ford", "toyota", "volkswagen")) %&gt;%
    ggplot(mapping = aes(x = manufacturer, y = cty))
  p0 + geom_hist_()

  ## set position
  #### default is "stack_"
  p0 + geom_hist_(mapping = aes(fill = fl))
  #### "dodge_"
  p0 + geom_hist_(position = "dodge_",
                  mapping = aes(fill = fl))
  #### "dodge2_"
  p0 + geom_hist_(position = "dodge2_",
                  mapping = aes(fill = fl))

  # bar chart
  mpg %&gt;%
    ggplot(mapping = aes(x = drv, y = class)) +
    geom_hist_(orientation = "y")

  # scale.y as "group"
  p &lt;- iris %&gt;%
    tidyr::pivot_longer(cols = -Species,
                        names_to = "Outer sterile whorls",
                        values_to = "x") %&gt;%
    ggplot(mapping = aes(x = `Outer sterile whorls`,
                         y = x, fill = Species)) +
    stat_hist_(scale.y = "group",
               prop = 0.6,
               alpha = 0.5)
  p
  # with density on the left
  p + stat_density_(scale.y = "group",
                    prop = 0.6,
                    alpha = 0.5,
                    positive = FALSE)

  ########### only `x` or `y` is provided ###########
  # that would be equivalent to call function
  # `geom_histogram()` or `geom_bar()`
  ### histogram
  diamonds %&gt;%
    dplyr::sample_n(500) %&gt;%
    ggplot(mapping = aes(x = price)) +
    geom_hist_()
  ### bar chart
  diamonds %&gt;%
    dplyr::sample_n(500) %&gt;%
    ggplot(mapping = aes(x = cut)) +
    geom_hist_()
}
</code></pre>

<hr>
<h2 id='geom_image_glyph'>Add image glyphs on scatter plot</h2><span id='topic+geom_image_glyph'></span>

<h3>Description</h3>

<p>Each point glyph can be an image (png, jpeg, etc) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_image_glyph(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  images,
  imagewidth = 1.2,
  imageheight = 0.9,
  interpolate = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_image_glyph_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_images">images</code></td>
<td>
<p>a list of images (a raster object, bitmap image). If not provided, a point visual (<code>geom_point()</code>) will be displayed.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_imagewidth">imagewidth</code></td>
<td>
<p>Numerical; width of image</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_imageheight">imageheight</code></td>
<td>
<p>Numerical; height of image</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_interpolate">interpolate</code></td>
<td>
<p>A logical value indicating whether to linearly interpolate the image (the alternative is to use nearest-neighbour interpolation,
which gives a more blocky result). See <code><a href="grid.html#topic+rasterGrob">rasterGrob</a></code>.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_image_glyph_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>geom</code> layer
</p>


<h3>Aesthetics</h3>

<p>geom_..._glyph() understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>group
</p>
</li>
<li><p>size
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>stroke
</p>
</li></ul>

<p>The size unit is <code>cm</code>
</p>
<p>Note that the shape and stroke do not have real meanings unless the essential
argument <code>images</code> is missing. If so, a point visual will be displayed with
corresponding shape and stroke.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_serialaxes_glyph">geom_serialaxes_glyph</a></code>, <code><a href="#topic+geom_polygon_glyph">geom_polygon_glyph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# image glyph
if(require("png")) {
img_path &lt;- list.files(file.path(find.package(package = 'ggmulti'),
                                 "images"),
                       full.names = TRUE)
Raptors &lt;- png::readPNG(img_path[2L])
Warriors &lt;- png::readPNG(img_path[3L])

pg &lt;- ggplot(data = data.frame(x = 1:2, y = rep(1, 2)),
       mapping = aes(x = x, y = y)) +
  geom_image_glyph(images = list(Raptors,
                                 Warriors),
                   imagewidth = rep(1.2, 2),
                   imageheight = c(0.9, 1.2)) +
  coord_cartesian(xlim = extendrange(c(1,2)))
pg
# query the images (a numerical array)
build &lt;- ggplot2::ggplot_build(pg)
# `imageRaptors` and `imageWarriors` are three dimensional
# arrays (third dimension specifying the plane)
imageRaptors &lt;- build$data[[1]]$images[[1]]
imageWarriors &lt;- build$data[[1]]$images[[2]]

if(require("grid")) {
grid.newpage()
grid.raster(imageRaptors)
grid.newpage()
grid.raster(imageWarriors)
}

# THIS IS SLOW
mercLogo &lt;- png::readPNG(img_path[1L])

p &lt;- ggplot(mapping = aes(x = hp, y = mpg)) +
       geom_point(
         data = mtcars[!grepl("Merc", rownames(mtcars)), ],
         color = "skyblue") +
       geom_image_glyph(
         data = mtcars[grepl("Merc", rownames(mtcars)), ],
         images = mercLogo,
         imagewidth = 1.5
       )
p

}

</code></pre>

<hr>
<h2 id='geom_polygon_glyph'>Add polygon glyphs on scatter plot</h2><span id='topic+geom_polygon_glyph'></span>

<h3>Description</h3>

<p>Each point glyph can be a polygon object.
We provide some common polygon coords in <code><a href="#topic+polygon_glyph">polygon_glyph</a></code>. Also, users can
customize their own polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_polygon_glyph(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  polygon_x,
  polygon_y,
  linewidth = 1,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_polygon_glyph_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_polygon_x">polygon_x</code></td>
<td>
<p>nested list of x-coordinates of polygons, one list element for each scatterplot point.
If not provided, a point visual (<code>geom_point()</code>) will be displayed.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_polygon_y">polygon_y</code></td>
<td>
<p>nested list of y-coordinates of polygons, one list element for each scatterplot point.
If not provided, a point visual (<code>geom_point()</code>) will be displayed.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_linewidth">linewidth</code></td>
<td>
<p>line width of the &quot;glyph&quot; object</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_polygon_glyph_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>geom</code> layer
</p>


<h3>Aesthetics</h3>

<p>geom_..._glyph() understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>group
</p>
</li>
<li><p>size
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>stroke
</p>
</li></ul>

<p>The size unit is <code>cm</code>
</p>
<p>Note that the shape and stroke do not have real meanings unless the essential
argument  <code>polygon_x</code> or <code>polygon_y</code> is missing.
If so, a point visual will be displayed with corresponding shape and stroke.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_serialaxes_glyph">geom_serialaxes_glyph</a></code>, <code><a href="#topic+geom_image_glyph">geom_image_glyph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># polygon glyph
p &lt;- ggplot(data = data.frame(x = 1:4, y = 1:4),
            mapping = aes(x = x, y = y)) +
  geom_polygon_glyph(polygon_x = list(x_star, x_cross, x_hexagon, x_airplane),
                     polygon_y = list(y_star, y_cross, y_hexagon, y_airplane),
                     colour = 'black', fill = 'red')
p

# the coords of each polygons can be achieved by calling function `ggplot_build`
build &lt;- ggplot2::ggplot_build(p)
polygon_x &lt;- build$data[[1]]$polygon_x
polygon_y &lt;- build$data[[1]]$polygon_y

</code></pre>

<hr>
<h2 id='geom_quantiles'>Add quantile layers on serial axes coordinate</h2><span id='topic+geom_quantiles'></span>

<h3>Description</h3>

<p>In <code>ggplot2</code>, <code>geom_quantile()</code> is used to fit a quantile regression to the data and draws
the fitted quantiles with lines. However, <code>geom_quantiles()</code> is mainly used to draw quantile lines
on serial axes. See examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_quantiles(
  mapping = NULL,
  data = NULL,
  stat = "quantile",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_quantiles_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_quantiles_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+geom_serialaxes_quantile">geom_serialaxes_quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(iris,
            mapping = aes(
              Sepal.Length = Sepal.Length,
              Sepal.Width = Sepal.Width,
              Petal.Length = Petal.Length,
              Petal.Width = Petal.Width
            )
  ) +
  geom_path(alpha = 0.2)  +
  coord_serialaxes(scaling = "variable")
p + geom_quantiles(colour = c("red", "green", "blue"),
                   quantiles = c(0.25, 0.5, 0.75),
                   linewidth = 2)

</code></pre>

<hr>
<h2 id='geom_serialaxes'>Serial axes layer</h2><span id='topic+geom_serialaxes'></span><span id='topic+stat_serialaxes'></span><span id='topic+stat_dotProduct'></span>

<h3>Description</h3>

<p>Draw a serial axes layer, parallel axes under Cartesian system and radial axes under Polar system.
It only takes the &quot;widens&quot; data. Each non-aesthetics component defined in the mapping <code>aes()</code> will
be treated as an axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_serialaxes(
  mapping = NULL,
  data = NULL,
  stat = "serialaxes",
  position = "identity",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_serialaxes(
  mapping = NULL,
  data = NULL,
  geom = "serialaxes",
  position = "identity",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  axes.position = NULL,
  scaling = c("data", "variable", "observation", "none"),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_dotProduct(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  scaling = c("data", "variable", "observation", "none"),
  transform = andrews,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_serialaxes_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector to define the axes sequence. In serial axes coordinate, the sequence can be either
determined in <code>mapping</code> (function <code>aes()</code>) or by <code>axes.sequence</code>. The only difference is that
the <code>mapping</code> aesthetics will omit the duplicated axes (check examples in <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_merge">merge</code></td>
<td>
<p>Should <code>axes.sequence</code> be merged with mapping aesthetics
as a single mapping <code>uneval</code> object?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_axes.position">axes.position</code></td>
<td>
<p>A numerical vector to determine the axes sequence position;
the length should be the same with the length of <code>axes.sequence</code> (or mapping <code>aesthetics</code>, see examples).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_+3A_transform">transform</code></td>
<td>
<p>A transformation function, can be either <code>andrews</code>, <code>legendre</code> or
some other customized transformation functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between the &quot;lengthens&quot; data and &quot;widens&quot; data can be found in
<a href="http://vita.had.co.nz/papers/tidy-data.pdf">Tidy Data</a>.
How to transform one to the other is explained in <a href="https://tidyr.tidyverse.org/articles/pivot.html">tidyr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coord_serialaxes">coord_serialaxes</a></code>, <code><a href="#topic+geom_serialaxes_density">geom_serialaxes_density</a></code>,
<code><a href="#topic+geom_serialaxes_quantile">geom_serialaxes_quantile</a></code>, <code><a href="#topic+geom_serialaxes_hist">geom_serialaxes_hist</a></code>
</p>
<p>Andrews plot <code><a href="#topic+andrews">andrews</a></code>, Legendre polynomials <code><a href="#topic+legendre">legendre</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parallel coordinate
p &lt;- ggplot(NBAstats2021,
            mapping = aes(FGA = FGA,
                          `3PA` = `3PA`,
                          FTA = FTA,
                          OFGA = OFGA,
                          O3PA = O3PA,
                          OFTA = OFTA,
                          colour = CONF))

# Teams in West are more likely to make 3-point field goals.
# Besides, they have a better performance in restricting opponents
# to make 3-point field goals.
p +
  geom_serialaxes(scaling = "variable",
                  alpha = 0.4,
                  linewidth = 3) +
  scale_x_continuous(breaks = 1:6,
                     labels = c("FGA", "3PA", "FTA",
                                "OFGA", "O3PA", "OFTA")) +
  scale_y_continuous(labels = NULL)

# andrews plot
p + geom_serialaxes(stat = "dotProduct",
                    scaling = "variable",
                    transform = andrews) # default

# Legendre polynomials
p + geom_serialaxes(stat = "dotProduct",
                    scaling = "variable",
                    transform = legendre)


############# Determine axes sequence
# 1. set the duplicated axes by mapping aesthetics
ggplot(iris, mapping = aes(Sepal.Length = Sepal.Length,
                           Sepal.Width = Sepal.Width,
                           Sepal.Length = Sepal.Length,
                           Sepal.Width = Sepal.Width,
                           colour = Species)) +
  # only two axes, duplicated axes are removed
  geom_serialaxes()

# 2. set the duplicated axes by axes.sequence
ggplot(iris, mapping = aes(colour = Species)) +
  geom_serialaxes(
    axes.sequence = c("Sepal.Length", "Sepal.Width",
                      "Sepal.Length", "Sepal.Width"))

</code></pre>

<hr>
<h2 id='geom_serialaxes_density'>Smoothed density estimates for &quot;widens&quot; data under serial axes coordinate</h2><span id='topic+geom_serialaxes_density'></span><span id='topic+stat_serialaxes_density'></span>

<h3>Description</h3>

<p>Computes and draws kernel density estimates on serial axes coordinate
for each non-aesthetics component defined in the mapping <code>aes()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_serialaxes_density(
  mapping = NULL,
  data = NULL,
  stat = "serialaxes_density",
  position = "identity_",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  scale.y = c("data", "group"),
  as.mix = TRUE,
  positive = TRUE,
  prop = 0.9,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_serialaxes_density(
  mapping = NULL,
  data = NULL,
  geom = "serialaxes_density",
  position = "stack_",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  axes.position = NULL,
  scaling = c("data", "variable", "observation", "none"),
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  trim = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_serialaxes_density_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector to define the axes sequence. In serial axes coordinate, the sequence can be either
determined in <code>mapping</code> (function <code>aes()</code>) or by <code>axes.sequence</code>. The only difference is that
the <code>mapping</code> aesthetics will omit the duplicated axes (check examples in <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_merge">merge</code></td>
<td>
<p>Should <code>axes.sequence</code> be merged with mapping aesthetics
as a single mapping <code>uneval</code> object?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_scale.y">scale.y</code></td>
<td>
<p>one of <code>data</code> and <code>group</code> to specify.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
 <td style="text-align: left;"> data (default) </td><td style="text-align: left;"> The density estimates are scaled by the whole data set
</td>
</tr>
<tr>
 <td style="text-align: left;"> group </td><td style="text-align: left;"> The density estimates are scaled by each group
</td>
</tr>

</table>

<p>If the <code>scale.y</code> is <code>data</code>, it is meaningful to compare the density (shape and area) across all groups; else
it is only meaningful to compare the density within each group. See details.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_as.mix">as.mix</code></td>
<td>
<p>Logical. Within each group, if <code>TRUE</code>, the sum of the density estimate area is mixed and
scaled to maximum 1. The area of each subgroup (in general, within each group one color represents one subgroup)
is proportional to the count; if <code>FALSE</code> the area of each subgroup is the same, with maximum 1. See details.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_positive">positive</code></td>
<td>
<p>If <code>y</code> is set as the density estimate, where the smoothed curved is faced to,
right ('positive') or left ('negative') as vertical layout; up ('positive') or down ('negative') as horizontal layout?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_prop">prop</code></td>
<td>
<p>adjust the proportional maximum height of the estimate (density, histogram, ...).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_axes.position">axes.position</code></td>
<td>
<p>A numerical vector to determine the axes sequence position;
the length should be the same with the length of <code>axes.sequence</code> (or mapping <code>aesthetics</code>, see examples).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_n">n</code></td>
<td>
<p>number of equally spaced points at which the density is to be
estimated, should be a power of two, see <code><a href="stats.html#topic+density">density()</a></code> for
details</p>
</td></tr>
<tr><td><code id="geom_serialaxes_density_+3A_trim">trim</code></td>
<td>
<p>If <code>FALSE</code>, the default, each density is computed on the
full range of the data. If <code>TRUE</code>, each density is computed over the
range of that group: this typically means the estimated x values will
not line-up, and hence you won't be able to stack density values.
This parameter only matters if you are displaying multiple densities in
one plot or if you are manually adjusting the scale limits.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+geom_density_">geom_density_</a></code>, <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>,
<code><a href="#topic+geom_serialaxes_quantile">geom_serialaxes_quantile</a></code>, <code><a href="#topic+geom_serialaxes_hist">geom_serialaxes_hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(iris, mapping = aes(Sepal.Length = Sepal.Length,
                                Sepal.Width = Sepal.Width,
                                Petal.Length = Petal.Length,
                                Petal.Width = Petal.Width,
                                colour = Species,
                                fill = Species)) +
       geom_serialaxes(alpha = 0.2) +
       geom_serialaxes_density(alpha = 0.5) +
       scale_x_continuous(breaks = 1:4,
                          labels = colnames(iris)[-5]) +
       scale_y_continuous(labels = NULL) +
       xlab("variable") +
       ylab("") +
       theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
p
</code></pre>

<hr>
<h2 id='geom_serialaxes_glyph'>Add serial axes glyphs on scatter plot</h2><span id='topic+geom_serialaxes_glyph'></span>

<h3>Description</h3>

<p>To visualize high dimensional data on scatterplot.
Each point glyph is surrounded by a serial axes (parallel axes or radial axes) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_serialaxes_glyph(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  serialaxes.data,
  axes.sequence = character(0L),
  scaling = c("data", "variable", "observation", "none"),
  axes.layout = c("parallel", "radial"),
  andrews = FALSE,
  show.axes = FALSE,
  show.enclosing = FALSE,
  linewidth = 1,
  axescolour = "black",
  bboxcolour = "black",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_serialaxes_glyph_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_serialaxes.data">serialaxes.data</code></td>
<td>
<p>a serial axes numerical data set.
If not provided, a point visual (<code>geom_point()</code>) will be displayed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector to define the axes sequence. In serial axes coordinate, the sequence can be either
determined in <code>mapping</code> (function <code>aes()</code>) or by <code>axes.sequence</code>. The only difference is that
the <code>mapping</code> aesthetics will omit the duplicated axes (check examples in <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_axes.layout">axes.layout</code></td>
<td>
<p>either &quot;radial&quot; or &quot;parallel&quot;</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_andrews">andrews</code></td>
<td>
<p>Logical; Andrew's plot (a Fourier transformation)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_show.axes">show.axes</code></td>
<td>
<p>boolean to indicate whether axes should be shown or not</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_show.enclosing">show.enclosing</code></td>
<td>
<p>boolean to indicate whether enclosing should be shown or not</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_linewidth">linewidth</code></td>
<td>
<p>line width of the &quot;glyph&quot; object</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_axescolour">axescolour</code></td>
<td>
<p>axes color</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_bboxcolour">bboxcolour</code></td>
<td>
<p>bounding box color</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_glyph_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>geom</code> layer
</p>


<h3>Aesthetics</h3>

<p>geom_..._glyph() understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>group
</p>
</li>
<li><p>size
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>stroke
</p>
</li></ul>

<p>The size unit is <code>cm</code>
</p>
<p>Note that the shape and stroke do not have real meanings unless the essential
argument <code>serialaxes.data</code> is missing. If so, a point visual will be displayed with
corresponding shape and stroke.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_polygon_glyph">geom_polygon_glyph</a></code>, <code><a href="#topic+geom_image_glyph">geom_image_glyph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># serial axes glyph
p &lt;- ggplot(data = iris,
            mapping = aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) +
  geom_serialaxes_glyph(serialaxes.data = iris[, -5],
                        axes.layout = "radial")
p
</code></pre>

<hr>
<h2 id='geom_serialaxes_hist'>Histogram for &quot;widens&quot; data under serial axes coordinate</h2><span id='topic+geom_serialaxes_hist'></span><span id='topic+stat_serialaxes_hist'></span>

<h3>Description</h3>

<p>Computes and draws histogram on serial axes coordinate for each non-aesthetics component
defined in the mapping <code>aes()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_serialaxes_hist(
  mapping = NULL,
  data = NULL,
  stat = "serialaxes_hist",
  position = "stack_",
  ...,
  axes.sequence = character(0L),
  axes.position = NULL,
  merge = TRUE,
  scale.y = c("data", "group"),
  as.mix = TRUE,
  positive = TRUE,
  prop = 0.9,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_serialaxes_hist(
  mapping = NULL,
  data = NULL,
  geom = "serialaxes_hist",
  position = "stack_",
  ...,
  axes.sequence = character(0L),
  scaling = c("data", "variable", "observation", "none"),
  axes.position = NULL,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  breaks = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_serialaxes_hist_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector to define the axes sequence. In serial axes coordinate, the sequence can be either
determined in <code>mapping</code> (function <code>aes()</code>) or by <code>axes.sequence</code>. The only difference is that
the <code>mapping</code> aesthetics will omit the duplicated axes (check examples in <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_axes.position">axes.position</code></td>
<td>
<p>A numerical vector to determine the axes sequence position;
the length should be the same with the length of <code>axes.sequence</code> (or mapping <code>aesthetics</code>, see examples).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_merge">merge</code></td>
<td>
<p>Should <code>axes.sequence</code> be merged with mapping aesthetics
as a single mapping <code>uneval</code> object?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_scale.y">scale.y</code></td>
<td>
<p>one of <code>data</code> and <code>group</code> to specify.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
 <td style="text-align: left;"> data (default) </td><td style="text-align: left;"> The density estimates are scaled by the whole data set
</td>
</tr>
<tr>
 <td style="text-align: left;"> group </td><td style="text-align: left;"> The density estimates are scaled by each group
</td>
</tr>

</table>

<p>If the <code>scale.y</code> is <code>data</code>, it is meaningful to compare the density (shape and area) across all groups; else
it is only meaningful to compare the density within each group. See details.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_as.mix">as.mix</code></td>
<td>
<p>Logical. Within each group, if <code>TRUE</code>, the sum of the density estimate area is mixed and
scaled to maximum 1. The area of each subgroup (in general, within each group one color represents one subgroup)
is proportional to the count; if <code>FALSE</code> the area of each subgroup is the same, with maximum 1. See details.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_positive">positive</code></td>
<td>
<p>If <code>y</code> is set as the density estimate, where the smoothed curved is faced to,
right ('positive') or left ('negative') as vertical layout; up ('positive') or down ('negative') as horizontal layout?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_prop">prop</code></td>
<td>
<p>adjust the proportional maximum height of the estimate (density, histogram, ...).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. Can be specified as a numeric value
or as a function that calculates width from unscaled x. Here, &quot;unscaled x&quot;
refers to the original x values in the data, before application of any
scale transformation. When specifying a function along with a grouping
structure, the function will be called once per group.
The default is to use the number of bins in <code>bins</code>,
covering the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.
</p>
<p>The bin width of a date variable is the number of days in each time; the
bin width of a time variable is the number of seconds.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_center">center</code>, <code id="geom_serialaxes_hist_+3A_boundary">boundary</code></td>
<td>
<p>bin position specifiers. Only one, <code>center</code> or
<code>boundary</code>, may be specified for a single plot. <code>center</code> specifies the
center of one of the bins. <code>boundary</code> specifies the boundary between two
bins. Note that if either is above or below the range of the data, things
will be shifted by the appropriate integer multiple of <code>binwidth</code>.
For example, to center on integers use <code>binwidth = 1</code> and <code>center = 0</code>, even
if <code>0</code> is outside the range of the data. Alternatively, this same alignment
can be specified with <code>binwidth = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is
outside the range of the data.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_breaks">breaks</code></td>
<td>
<p>Alternatively, you can supply a numeric vector giving
the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>,
and <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures
frequency polygons touch 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_hist_+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the <code><a href="ggplot2.html#topic+resolution">resolution()</a></code> of the
data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+geom_hist_">geom_hist_</a></code>, <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>,
<code><a href="#topic+geom_serialaxes_quantile">geom_serialaxes_quantile</a></code>, <code><a href="#topic+geom_serialaxes_density">geom_serialaxes_density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(NBAstats2021,
            mapping = aes(`FG%` = `FG%`,
                          `3P%` = `3P%`,
                          `FT%` = `FT%`,
                          `OFG%` = `OFG%`,
                          `O3P%` = `O3P%`,
                          `OFT%` = `OFT%`,
                          colour = Playoff,
                          fill = Playoff)) +
            geom_serialaxes(alpha = 0.2,
                            scaling = "variable") +
            geom_serialaxes_hist(alpha = 0.5,
                                 prop = 0.7,
                                 scaling = "variable") +
            scale_x_continuous(breaks = 1:6,
                               labels = c("FG", "3P", "FT",
                                          "OFG", "O3P", "OFT")) +
            scale_y_continuous(labels = NULL) +
            xlab("variable") +
            ylab("") +
            theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
p
</code></pre>

<hr>
<h2 id='geom_serialaxes_quantile'>Quantile layer for serial axes coordinate</h2><span id='topic+geom_serialaxes_quantile'></span><span id='topic+stat_serialaxes_quantile'></span>

<h3>Description</h3>

<p>Draw a quantile layer for serial axes coordinate.
Don't be confused with <code>geom_quantile()</code> which is a quantile regression. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_serialaxes_quantile(
  mapping = NULL,
  data = NULL,
  stat = "serialaxes",
  position = "identity",
  ...,
  quantiles = seq(0, 1, 0.25),
  axes.sequence = character(0L),
  merge = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_serialaxes_quantile(
  mapping = NULL,
  data = NULL,
  geom = "serialaxes_quantile",
  position = "identity",
  ...,
  axes.sequence = character(0L),
  merge = TRUE,
  quantiles = seq(0, 1, 0.25),
  scaling = c("data", "variable", "observation", "none"),
  axes.position = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_serialaxes_quantile_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1]. (Values up to 2e-14 outside that
range are accepted and moved to the nearby endpoint.)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_axes.sequence">axes.sequence</code></td>
<td>
<p>A vector to define the axes sequence. In serial axes coordinate, the sequence can be either
determined in <code>mapping</code> (function <code>aes()</code>) or by <code>axes.sequence</code>. The only difference is that
the <code>mapping</code> aesthetics will omit the duplicated axes (check examples in <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>).</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_merge">merge</code></td>
<td>
<p>Should <code>axes.sequence</code> be merged with mapping aesthetics
as a single mapping <code>uneval</code> object?</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>)
to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="geom_serialaxes_quantile_+3A_axes.position">axes.position</code></td>
<td>
<p>A numerical vector to determine the axes sequence position;
the length should be the same with the length of <code>axes.sequence</code> (or mapping <code>aesthetics</code>, see examples).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+geom_density_">geom_density_</a></code>, <code><a href="#topic+geom_serialaxes">geom_serialaxes</a></code>,
<code><a href="#topic+geom_serialaxes_density">geom_serialaxes_density</a></code>, <code><a href="#topic+geom_serialaxes_hist">geom_serialaxes_hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># lower quantile, median and upper quantile
p &lt;- ggplot(iris, mapping = aes(Sepal.Length = Sepal.Length,
                                Sepal.Width = Sepal.Width,
                                Petal.Length = Petal.Length,
                                Petal.Width = Petal.Width)) +
       geom_serialaxes(stat = "dotProduct") +
       geom_serialaxes_quantile(stat = "dotProduct",
                                quantiles = c(0.25, 0.5, 0.75),
                                colour = c("red", "blue", "green"))
p

</code></pre>

<hr>
<h2 id='Geom-ggproto'>Base Geom ggproto classes for ggplot2</h2><span id='topic+Geom-ggproto'></span><span id='topic+GeomDensity_'></span><span id='topic+GeomBar_'></span><span id='topic+GeomImageGlyph'></span><span id='topic+GeomPolygonGlyph'></span><span id='topic+GeomQuantiles'></span><span id='topic+GeomSerialaxesDensity'></span><span id='topic+GeomSerialAxesGlyph'></span><span id='topic+GeomSerialaxesHist'></span><span id='topic+GeomSerialaxesQuantile'></span><span id='topic+GeomSerialaxes'></span>

<h3>Description</h3>

<p>All <code>geom_</code> functions (like <code>geom_point</code>) return a layer that contains a <code>Geom</code>
object (like <code>GeomPoint</code>). The <code>Geom</code> object is responsible for rendering the data in the plot.
Each of the <code>Geom</code> objects is a <code>ggproto</code> object,
descended from the top-level Geom, and each implements various methods and fields.
Compared to <code>Stat</code> and <code>Position</code>, <code>Geom</code> is a little different
because the execution of the setup and compute functions is split up.
setup_data runs before position adjustments, and <code>draw_layer</code>
is not run until render time, much later. This means there is no <code>setup_params</code>
because it's hard to communicate the changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomDensity_

GeomBar_

GeomImageGlyph

GeomPolygonGlyph

GeomQuantiles

GeomSerialaxesDensity

GeomSerialAxesGlyph

GeomSerialaxesHist

GeomSerialaxesQuantile

GeomSerialaxes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomDensity_</code> (inherits from <code>GeomRibbon</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>
<p>An object of class <code>GeomBar_</code> (inherits from <code>GeomBar</code>, <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>GeomImageGlyph</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 7.
</p>
<p>An object of class <code>GeomPolygonGlyph</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 7.
</p>
<p>An object of class <code>GeomQuantiles</code> (inherits from <code>GeomQuantile</code>, <code>GeomPath</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 1.
</p>
<p>An object of class <code>GeomSerialaxesDensity</code> (inherits from <code>GeomDensity_</code>, <code>GeomRibbon</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>GeomSerialAxesGlyph</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 7.
</p>
<p>An object of class <code>GeomSerialaxesHist</code> (inherits from <code>GeomBar_</code>, <code>GeomBar</code>, <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>GeomSerialaxesQuantile</code> (inherits from <code>GeomPath</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>GeomSerialaxes</code> (inherits from <code>GeomPath</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 3.
</p>

<hr>
<h2 id='get_scaledData'>scale data</h2><span id='topic+get_scaledData'></span>

<h3>Description</h3>

<p>It is mainly used in serial axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_scaledData(
  data,
  sequence = NULL,
  scaling = c("data", "variable", "observation", "none"),
  displayOrder = NULL,
  reserve = FALSE,
  as.data.frame = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_scaledData_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="get_scaledData_+3A_sequence">sequence</code></td>
<td>
<p>vector with variable names that defines the axes sequence.
If <code>NULL</code>, it will be set as the column names automatically.</p>
</td></tr>
<tr><td><code id="get_scaledData_+3A_scaling">scaling</code></td>
<td>
<p>one of <code>data</code>, <code>variable</code>, <code>observation</code> or
<code>none</code> (not suggested the layout is the same with <code>data</code>) to specify how the data is scaled.</p>
</td></tr>
<tr><td><code id="get_scaledData_+3A_displayorder">displayOrder</code></td>
<td>
<p>the order of the display</p>
</td></tr>
<tr><td><code id="get_scaledData_+3A_reserve">reserve</code></td>
<td>
<p>If <code>TRUE</code>, return the variables not shown in <code>sequence</code> as well;
else only return the variables defined in <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="get_scaledData_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>Return a matrix or a data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='ggmulti-deprecated'>Deprecated functions in package <span class="pkg">ggmulti</span>.</h2><span id='topic+ggmulti-deprecated'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned. Help pages for deprecated functions are
available at <code>help("coord_radar")</code>
</p>

<hr>
<h2 id='NBAstats2021'>NBA 30 Teams Statistics in 20-21 Regular Season</h2><span id='topic+NBAstats2021'></span>

<h3>Description</h3>

<p>A dataset containing the statistics (e.g. Points Per Game, Average Field Goals Made, etc)
of 30 NBA Teams in 2020-2021 regular season
</p>


<h3>Format</h3>

<p>A data frame with 30 rows (teams) and 42 variables:
</p>

<dl>
<dt>Team</dt><dd><p>Team Names.</p>
</dd>
<dt>CONF</dt><dd><p>Factor; Conference of Teams (West or East).</p>
</dd>
<dt>DIV</dt><dd><p>Factor; Division of Teams.</p>
</dd>
<dt>Playoff</dt><dd><p>Factor; Whether Teams are in (0 or 1) Playoffs.</p>
</dd>
<dt>PTS</dt><dd><p>Points Per Game.</p>
</dd>
<dt>FGM</dt><dd><p>Average Field Goals Made.</p>
</dd>
<dt>FGA</dt><dd><p>Average Field Goals Attempted.</p>
</dd>
<dt>FG%</dt><dd><p>Field Goal Percentage.</p>
</dd>
<dt>3PM</dt><dd><p>Average 3-Point Field Goals Made.</p>
</dd>
<dt>3PA</dt><dd><p>Average 3-Point Field Goals Attempted.</p>
</dd>
<dt>3P%</dt><dd><p>3-Point Field Goal Percentage.</p>
</dd>
<dt>FTM</dt><dd><p>Average Free Throws Made.</p>
</dd>
<dt>FTA</dt><dd><p>Average Free Throws Attempted.</p>
</dd>
<dt>FT%</dt><dd><p>Free Throw Percentage.</p>
</dd>
<dt>OR</dt><dd><p>Offensive Rebounds Per Game.</p>
</dd>
<dt>DR</dt><dd><p>Defensive Rebounds Per Game.</p>
</dd>
<dt>REB</dt><dd><p>Rebounds Per Game.</p>
</dd>
<dt>AST</dt><dd><p>Assists Per Game.</p>
</dd>
<dt>STL</dt><dd><p>Steals Per Game.</p>
</dd>
<dt>BLK</dt><dd><p>Blocks Per Game.</p>
</dd>
<dt>TO</dt><dd><p>Turnovers Per Game.</p>
</dd>
<dt>PF</dt><dd><p>Fouls Per Game.</p>
</dd>
<dt>OPTS</dt><dd><p>Opponent Points Per Game.</p>
</dd>
<dt>OFGM</dt><dd><p>Opponent Average Field Goals Made.</p>
</dd>
<dt>OFGA</dt><dd><p>Opponent Average Field Goals Attempted.</p>
</dd>
<dt>OFG%</dt><dd><p>Opponent Field Goal Percentage.</p>
</dd>
<dt>O3PM</dt><dd><p>Opponent Average 3-Point Field Goals Made.</p>
</dd>
<dt>O3PA</dt><dd><p>Opponent Average 3-Point Field Goals Attempted.</p>
</dd>
<dt>O3P%</dt><dd><p>Opponent 3-Point Field Goal Percentage.</p>
</dd>
<dt>OFTM</dt><dd><p>Opponent Average Free Throws Made.</p>
</dd>
<dt>OFTA</dt><dd><p>Opponent Average Free Throws Attempted.</p>
</dd>
<dt>OFT%</dt><dd><p>Opponent Free Throw Percentage.</p>
</dd>
<dt>OOR</dt><dd><p>Opponent Offensive Rebounds Per Game.</p>
</dd>
<dt>ODR</dt><dd><p>Opponent Defensive Rebounds Per Game.</p>
</dd>
<dt>OREB</dt><dd><p>Opponent Rebounds Per Game.</p>
</dd>
<dt>OAST</dt><dd><p>Opponent Assists Per Game.</p>
</dd>
<dt>OSTL</dt><dd><p>Opponent Steals Per Game.</p>
</dd>
<dt>OBLK</dt><dd><p>Opponent Blocks Per Game.</p>
</dd>
<dt>OTO</dt><dd><p>Opponent Turnovers Per Game.</p>
</dd>
<dt>OPF</dt><dd><p>Opponent Fouls Per Game.</p>
</dd>
<dt>Win</dt><dd><p>Win Games in Regular Season.</p>
</dd>
<dt>Lose</dt><dd><p>Loss Games in Regular Season.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Zehao Xu
</p>


<h3>Source</h3>

<p><a href="https://www.espn.com/nba/stats/team/_/season/2021">https://www.espn.com/nba/stats/team/_/season/2021</a>
</p>

<hr>
<h2 id='polygon_glyph'>Polygon glyph coordinates</h2><span id='topic+polygon_glyph'></span><span id='topic+x_star'></span><span id='topic+y_star'></span><span id='topic+x_cross'></span><span id='topic+y_cross'></span><span id='topic+x_hexagon'></span><span id='topic+y_hexagon'></span><span id='topic+x_airplane'></span><span id='topic+y_airplane'></span><span id='topic+x_maple'></span><span id='topic+y_maple'></span>

<h3>Description</h3>

<p>polygon coordinates scaled to (0, 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_star

y_star

x_cross

y_cross

x_hexagon

y_hexagon

x_airplane

y_airplane

x_maple

y_maple
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 10.
</p>
<p>An object of class <code>numeric</code> of length 10.
</p>
<p>An object of class <code>numeric</code> of length 12.
</p>
<p>An object of class <code>numeric</code> of length 12.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 32.
</p>
<p>An object of class <code>numeric</code> of length 32.
</p>
<p>An object of class <code>numeric</code> of length 26.
</p>
<p>An object of class <code>numeric</code> of length 26.
</p>


<h3>See Also</h3>

<p><a href="#topic+geom_polygon_glyph">geom_polygon_glyph</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("grid")) {
  library(grid)
  grid.newpage()
  grid.polygon(x=(x_star + 1)/2,
               y=(y_star + 1)/2)
  grid.newpage()
  grid.polygon(x=(x_cross + 1)/2,
               y=(y_cross + 1)/2)
  grid.newpage()
  grid.polygon(x=(x_hexagon + 1)/2,
               y=(y_hexagon + 1)/2)
  grid.newpage()
  grid.polygon(x=(x_airplane + 1)/2,
               y=(y_airplane + 1)/2)
  grid.newpage()
  grid.polygon(x=(x_maple + 1)/2,
               y=(y_maple + 1)/2)
}
</code></pre>

<hr>
<h2 id='position_dodge_'>Dodge overlapping objects side-to-side</h2><span id='topic+position_dodge_'></span><span id='topic+position_dodge2_'></span>

<h3>Description</h3>

<p>Dodging preserves the vertical position of an geom while adjusting the horizontal position.
<code>position_dodge_()</code> dodges bars side by side but conditional on locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_dodge_(width = NULL, preserve = c("total", "single"))

position_dodge2_(
  width = NULL,
  preserve = c("total", "single"),
  padding = 0.1,
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_dodge__+3A_width">width</code></td>
<td>
<p>Dodging width, when different to the width of the individual
elements. This is useful when you want to align narrow geoms with wider
geoms. See the examples.</p>
</td></tr>
<tr><td><code id="position_dodge__+3A_preserve">preserve</code></td>
<td>
<p>Should dodging preserve the <code>"total"</code> width of all elements
at a position, or the width of a <code>"single"</code> element?</p>
</td></tr>
<tr><td><code id="position_dodge__+3A_padding">padding</code></td>
<td>
<p>Padding between elements at the same position. Elements are
shrunk by this proportion to allow space between them. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="position_dodge__+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is built based on <code>position_dodge</code>, but used for multiple locations, such as
<code>geom_hist_()</code> or <code>geom_density_()</code>. Check examples to see the difference.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_hist_">geom_hist_</a></code> and <code><a href="#topic+geom_serialaxes_hist">geom_serialaxes_hist</a></code> for more examples.
</p>
<p>Other position adjustments for multiple locations:
<code><a href="#topic+position_identity_">position_identity_</a></code>,
<code><a href="#topic+position_stack_">position_stack_</a></code>, <code><a href="#topic+position_fill_">position_fill_</a></code>
</p>
<p>Parent: <code>position_dodge</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(dplyr)) {
p &lt;- iris %&gt;%
  tidyr::pivot_longer(cols = -Species,
                      names_to = "Outer sterile whorls",
                      values_to = "values") %&gt;%
  ggplot(data,
         mapping = aes(x = `Outer sterile whorls`,
                       y = values,
                       fill = Species))

p + geom_hist_(position = position_dodge_())
}


# all bins are shifted on the left
p +
  geom_hist_(position = position_dodge())



</code></pre>

<hr>
<h2 id='position_identity_'>Don't adjust position</h2><span id='topic+position_identity_'></span>

<h3>Description</h3>

<p>Don't adjust position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_identity_()
</code></pre>


<h3>See Also</h3>

<p>Other position adjustments for multiple locations:
<code><a href="#topic+position_stack_">position_stack_</a></code>, <code><a href="#topic+position_fill_">position_fill_</a></code>,
<code><a href="#topic+position_dodge_">position_dodge_</a></code>, <code><a href="#topic+position_dodge2_">position_dodge2_</a></code>
</p>

<hr>
<h2 id='position_stack_'>Stack overlapping objects on top of each another</h2><span id='topic+position_stack_'></span><span id='topic+position_fill_'></span>

<h3>Description</h3>

<p><code>position_stack_</code> stacks bars on top of each other, conditional on locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_stack_(vjust = 1, reverse = FALSE)

position_fill_(vjust = 1, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_stack__+3A_vjust">vjust</code></td>
<td>
<p>Vertical adjustment for geoms that have a position
(like points or lines), not a dimension (like bars or areas). Set to
<code>0</code> to align with the bottom, <code>0.5</code> for the middle,
and <code>1</code> (the default) for the top.</p>
</td></tr>
<tr><td><code id="position_stack__+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is built based on <code>position_stack</code>, but used for multiple locations, such as
<code><a href="#topic+geom_hist_">geom_hist_</a></code> or <code><a href="#topic+geom_density_">geom_density_</a></code>. Rather than stack everything on top of each other,
<code>position_stack_</code> stacks bars based on locations.
Check examples to see the difference.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_hist_">geom_hist_</a></code>, <code><a href="#topic+geom_density_">geom_density_</a></code>,
<code><a href="#topic+geom_serialaxes_density">geom_serialaxes_density</a></code> and <code><a href="#topic+geom_serialaxes_hist">geom_serialaxes_hist</a></code> for more examples.
</p>
<p>Other position adjustments for multiple locations:
<code><a href="#topic+position_identity_">position_identity_</a></code>,
<code><a href="#topic+position_dodge_">position_dodge_</a></code>, <code><a href="#topic+position_dodge2_">position_dodge2_</a></code>
</p>
<p>Parent: <code>position_stack</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(iris,
       mapping = aes(Sepal.Length = Sepal.Length,
                     Sepal.Width = Sepal.Width,
                     Petal.Length = Petal.Length,
                     Petal.Width = Petal.Width,
                     colour = Species))
p +
 geom_serialaxes_density(position = position_stack_())


p +
  geom_serialaxes_density(position = position_stack())


</code></pre>

<hr>
<h2 id='Position-ggproto'>Base Position ggproto classes for ggplot2</h2><span id='topic+Position-ggproto'></span><span id='topic+PositionDodge_'></span><span id='topic+PositionDodge2_'></span><span id='topic+PositionIdentity_'></span><span id='topic+PositionStack_'></span><span id='topic+PositionFill_'></span>

<h3>Description</h3>

<p>All <code>position_</code> functions (like <code>position_dodge</code>)
return a <code>Position</code> object (like <code>PositionDodge</code>).
The <code>Position</code> object is responsible for adjusting the position of overlapping geoms.
The way that the <code>position_</code> functions work is slightly different from the
<code>geom_</code> and <code>stat_</code> functions, because a <code>position_</code> function
actually &quot;instantiates&quot; the <code>Position</code> object by creating a descendant,
and returns that.
Each of the <code>Position</code> objects is a <code>ggproto</code> object,
descended from the top-level <code>Position</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PositionDodge_

PositionDodge2_

PositionIdentity_

PositionStack_

PositionFill_
</code></pre>


<h3>Format</h3>

<p>An object of class <code>PositionDodge_</code> (inherits from <code>PositionDodge</code>, <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>PositionDodge2_</code> (inherits from <code>PositionDodge2</code>, <code>PositionDodge</code>, <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>PositionIdentity_</code> (inherits from <code>PositionIdentity</code>, <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 3.
</p>
<p>An object of class <code>PositionStack_</code> (inherits from <code>PositionStack</code>, <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 3.
</p>
<p>An object of class <code>PositionFill_</code> (inherits from <code>PositionStack_</code>, <code>PositionStack</code>, <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>

<hr>
<h2 id='Stat-ggproto'>Base Stat ggproto classes for ggplot2</h2><span id='topic+Stat-ggproto'></span><span id='topic+StatDensity_'></span><span id='topic+StatHist_'></span><span id='topic+StatBin_'></span><span id='topic+StatCount_'></span><span id='topic+StatSerialaxesDensity'></span><span id='topic+StatSerialaxesHist'></span><span id='topic+StatSerialaxes'></span><span id='topic+StatDotProduct'></span>

<h3>Description</h3>

<p>All <code>stat_</code> functions (like <code>stat_bin()</code>)
return a layer that contains a <code>Stat</code> object (like <code>StatBin</code>).
The  <code>Stat</code> object is responsible for rendering the data in the plot.
Each of the <code>Stat</code> objects is a <code>ggproto</code> object,
descended from the top-level <code>Stat</code>, and each implements various methods and fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatDensity_

StatHist_

StatBin_

StatCount_

StatSerialaxesDensity

StatSerialaxesHist

StatSerialaxes

StatDotProduct
</code></pre>


<h3>Format</h3>

<p>An object of class <code>StatDensity_</code> (inherits from <code>StatDensity</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>StatHist_</code> (inherits from <code>StatBin</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>StatBin_</code> (inherits from <code>StatHist_</code>, <code>StatBin</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>StatCount_</code> (inherits from <code>StatHist_</code>, <code>StatBin</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>StatSerialaxesDensity</code> (inherits from <code>StatDensity</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>StatSerialaxesHist</code> (inherits from <code>StatBin</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>
<p>An object of class <code>StatSerialaxes</code> (inherits from <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>
<p>An object of class <code>StatDotProduct</code> (inherits from <code>StatSerialaxes</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
