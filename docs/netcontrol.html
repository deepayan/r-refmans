<!DOCTYPE html><html lang="en"><head><title>Help for package netcontrol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netcontrol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netcontrol'><p>netcontrol</p></a></li>
<li><a href='#ave_control_centrality'><p>Average Control Centrality</p></a></li>
<li><a href='#average_control'><p><code>average_control</code> - Average controllability as defined by the trace of the Gramian</p></a></li>
<li><a href='#control_gramian'><p>Controllability Gramian</p></a></li>
<li><a href='#control_scheme_DLI_freestate'><p>Discrete Linear Time-Invariant Free Final State Classic Control Scheme</p></a></li>
<li><a href='#control_traj'><p>Calculate the trajectory of a discrete linear time invariant system under a given control scheme</p></a></li>
<li><a href='#dlyap'><p>Discrete Lyapunov Equation Solver</p></a></li>
<li><a href='#inv_average_control'><p>Trace of the Inverse Gramian</p></a></li>
<li><a href='#LQR'><p>Linear Quadratic Regulator</p></a></li>
<li><a href='#modal_control'><p>Modal Control</p></a></li>
<li><a href='#modal_control_centrality'><p>Modal Control Centrality</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Control Theory Methods for Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Teague R. Henry</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Teague R. Henry &lt;trhenry@email.unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of various control theory methods for use 
            in brain and psychological networks. Contains controllability
            statistics from Pasqualetti, Zampieri &amp; Bullo (2014) &lt;<a href="https://doi.org/10.1109%2FTCNS.2014.2310254">doi:10.1109/TCNS.2014.2310254</a>&gt;,
            optimal control algorithms from Lewis, Vrabie &amp; Syrmos (2012, ISBN:978-0-470-63349-6), and various utilities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), Rdpack, Matrix, MASS, pracma, expm</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-10 16:51:33 UTC; Teague</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-19 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='netcontrol'>netcontrol</h2><span id='topic+netcontrol'></span><span id='topic+netcontrol-package'></span>

<h3>Description</h3>

<p>Description of your package
</p>


<h3>Author(s)</h3>

<p>Teague Henry
</p>

<hr>
<h2 id='ave_control_centrality'>Average Control Centrality</h2><span id='topic+ave_control_centrality'></span>

<h3>Description</h3>

<p>Calculates the average control centrality of a system defined by <code class="reqn">x_(t+1) = Ax_(t) + Bu_(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ave_control_centrality(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ave_control_centrality_+3A_a">A</code></td>
<td>
<p>An n by n matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length n vector of average control centrality measures (Pasqualetti et al. 2014), representing the overall average control of each node in the system.
</p>


<h3>References</h3>

<p>Pasqualetti F, Zampieri S, Bullo F (2014).
&ldquo;Controllability Metrics, Limitations and Algorithms for Complex Networks.&rdquo;
In <em>2014 American Control Conference</em>, 3287&ndash;3292.
ISBN 978-1-4799-3274-0 978-1-4799-3272-6 978-1-4799-3271-9, doi: <a href="https://doi.org/10/ggkhs9">10/ggkhs9</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)

ave_control_centrality(A)
</code></pre>

<hr>
<h2 id='average_control'><code>average_control</code> - Average controllability as defined by the trace of the Gramian</h2><span id='topic+average_control'></span>

<h3>Description</h3>

<p>A commonly used measure (Pasqualetti et al. 2014) of the overall controllability of a system defined by <code class="reqn">x_(t+1) = Ax_(t) + Bu_(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_control(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_control_+3A_a">A</code></td>
<td>
<p>A <code class="reqn">n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="average_control_+3A_b">B</code></td>
<td>
<p>A <code class="reqn">n x m</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trace of the infinite time Gramian.
</p>


<h3>References</h3>

<p>Pasqualetti F, Zampieri S, Bullo F (2014).
&ldquo;Controllability Metrics, Limitations and Algorithms for Complex Networks.&rdquo;
In <em>2014 American Control Conference</em>, 3287&ndash;3292.
ISBN 978-1-4799-3274-0 978-1-4799-3272-6 978-1-4799-3271-9, doi: <a href="https://doi.org/10/ggkhs9">10/ggkhs9</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)
B = diag(3)

average_control(A, B)
</code></pre>

<hr>
<h2 id='control_gramian'>Controllability Gramian</h2><span id='topic+control_gramian'></span>

<h3>Description</h3>

<p>Compute the (infinite time) controllability Gramian for the discrete linear time invariant system described by <code class="reqn">x(t+1) = Ax(t) + Bu(t)</code>. 
The infinite time controllability Gramian is the solution to the discrete Lyapunov equation <code class="reqn">AWA^\prime-W = -BB^\prime</code>, while the finite time Gramian for time <code class="reqn">T</code> is 
</p>
<p style="text-align: center;"><code class="reqn">W_t = \sum_{t = 0}^T A^tBB^\prime(A^\prime)^t</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>control_gramian(A, B, t = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control_gramian_+3A_a">A</code></td>
<td>
<p><code class="reqn">n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="control_gramian_+3A_b">B</code></td>
<td>
<p><code class="reqn">n x m</code> matrix.</p>
</td></tr>
<tr><td><code id="control_gramian_+3A_t">t</code></td>
<td>
<p>Either NA for infinite time Gramian, or a positive non-zero integer. Defaults to NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The infinite time or finite time controllability Gramian
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)
B = diag(3)

#Infinite time Gramian
W_inf = control_gramian(A, B)

#4 time Gramian
W_4 = control_gramian(A,B,4)
</code></pre>

<hr>
<h2 id='control_scheme_DLI_freestate'>Discrete Linear Time-Invariant Free Final State Classic Control Scheme</h2><span id='topic+control_scheme_DLI_freestate'></span>

<h3>Description</h3>

<p>Given a system dynamics <code class="reqn">A</code>, control input matrix <code class="reqn">B</code>, final state weighting matrix <code class="reqn">S</code>,
intermediate state weighting matrix sequence <code class="reqn">Q_seq</code>, and cost matrix sequence <code class="reqn">R_seq</code>, 
calculates the Kalman gain sequence to minimize the LQR by time <code class="reqn">t_max</code>.
See section 2.2 of (Lewis et al. 2012) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_scheme_DLI_freestate(t_max, A, B, S, Q_seq, R_seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control_scheme_DLI_freestate_+3A_t_max">t_max</code></td>
<td>
<p>Required. An integer total number of time points to determine the trajectory over</p>
</td></tr>
<tr><td><code id="control_scheme_DLI_freestate_+3A_a">A</code></td>
<td>
<p>Required. A <code class="reqn">p x p</code> matrix of system coefficients</p>
</td></tr>
<tr><td><code id="control_scheme_DLI_freestate_+3A_b">B</code></td>
<td>
<p>Required. A <code class="reqn">p x q</code> matrix of control weights</p>
</td></tr>
<tr><td><code id="control_scheme_DLI_freestate_+3A_s">S</code></td>
<td>
<p>A <code class="reqn">p x p</code> final state weighting matrix</p>
</td></tr>
<tr><td><code id="control_scheme_DLI_freestate_+3A_q_seq">Q_seq</code></td>
<td>
<p>A list of <code class="reqn">t</code> <code class="reqn">p x p</code> intermediate state weighting matrices or a single <code class="reqn">p x p</code> intermediate state weighting matrix</p>
</td></tr>
<tr><td><code id="control_scheme_DLI_freestate_+3A_r_seq">R_seq</code></td>
<td>
<p>A list of <code class="reqn">t</code> <code class="reqn">q x q</code> intermediate cost matrices or a single <code class="reqn">q x q</code> cost matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an entry labeled <code>gain_seq</code> containing either 1 or <code>t_max - 1</code> Kalman gain matrices and an entry labeled <code>cost_func</code> which contains a LQR function.
</p>


<h3>References</h3>

<p>Lewis FL, Vrabie DL, Syrmos VL (2012).
<em>Optimal Control</em>, 3rd ed edition.
Wiley, Hoboken.
ISBN 978-0-470-63349-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)

#Normalize rows to sum to 1
A = solve(diag(rowSums(A))) %*% A

B = S = Q_seq = R_seq = diag(3)

CS = control_scheme_DLI_freestate(100, A, B, S, Q_seq, R_seq)

</code></pre>

<hr>
<h2 id='control_traj'>Calculate the trajectory of a discrete linear time invariant system under a given control scheme</h2><span id='topic+control_traj'></span>

<h3>Description</h3>

<p>This function is designed to work with control_scheme objects generated by <code>control_scheme_DLI_freestate</code> 
In future versions of <code>netcontrol</code> this function will be used to simulate any control trajectory. 
For general details on control theory trajectories, see (Lewis et al. 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_traj(t_max, x_0, A, B, theta = NA, gamma = NA, control_scheme,
  delta = NA, d_nosign = F, d_toggle = F, upper_bounds = NA,
  lower_bounds = NA, u_pos = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control_traj_+3A_t_max">t_max</code></td>
<td>
<p>Required. An integer total number of time points to determine the trajectory over</p>
</td></tr>
<tr><td><code id="control_traj_+3A_x_0">x_0</code></td>
<td>
<p>Required. A <code class="reqn">p</code> length numeric vector of starting values</p>
</td></tr>
<tr><td><code id="control_traj_+3A_a">A</code></td>
<td>
<p>Required. A <code class="reqn">p x p</code> matrix of system coefficients</p>
</td></tr>
<tr><td><code id="control_traj_+3A_b">B</code></td>
<td>
<p>Required. A <code class="reqn">p x q</code> matrix of control weights</p>
</td></tr>
<tr><td><code id="control_traj_+3A_theta">theta</code></td>
<td>
<p>Optional. A <code class="reqn">p x p</code> covariance matrix for state errors. If <code>NA</code>, state mechanics will be deterministic</p>
</td></tr>
<tr><td><code id="control_traj_+3A_gamma">gamma</code></td>
<td>
<p>Optional. A <code class="reqn">p x p</code> covariance matrix for observation errors. If <code>NA</code>, no observation/measurement error will be modelled.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_control_scheme">control_scheme</code></td>
<td>
<p>Required. A list containing an entry labeled <code>gain_seq</code> containing either 1 or <code>t_max - 1</code> Kalman gain matrices and an entry labeled <code>cost_func</code> which contains an appropriately constructed cost function</p>
</td></tr>
<tr><td><code id="control_traj_+3A_delta">delta</code></td>
<td>
<p>Optional. A vector of length 2, where the first entry contains the point of saturation for control inputs, and the second entry contains the saturation value for control inputs.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_d_nosign">d_nosign</code></td>
<td>
<p>Optional. Boolean. If <code>TRUE</code> and <code>delta</code> is not <code>NA</code>, control inputs are forced to be positive.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_d_toggle">d_toggle</code></td>
<td>
<p>Optional. Boolean. If <code>TRUE</code> and <code>delta</code> is not <code>NA</code>, control inputs are either 0 or the saturation value.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_upper_bounds">upper_bounds</code></td>
<td>
<p>Optional. A <code class="reqn">p</code> length vector of upper bounds on state values.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_lower_bounds">lower_bounds</code></td>
<td>
<p>Optional. A <code class="reqn">p</code> length vector of lower bounds on state values.</p>
</td></tr>
<tr><td><code id="control_traj_+3A_u_pos">u_pos</code></td>
<td>
<p>Optional. Boolean. If <code>TRUE</code> restricts control inputs to be positive,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAUTION: Use of saturation parameters and/or bound parameters <code>delta, d_nosign, d_toggle, upper.bound, lower.bound, u.pos</code> 
leads to estimates of the optimal trajectory to be sub-optimal, as the Kalman gain calculations do not take any of those restrictions into account.
This functionality will be added later, and this caution statement removed at that time.
</p>


<h3>Value</h3>

<p>A list containing 4 entries: a 't_max x p' state value matrix, a 't_max x p' observation matrix, a 't_max-1 x q' matrix of control inputs and a 't_max' length vector of cost function values.
</p>


<h3>References</h3>

<p>Lewis FL, Vrabie DL, Syrmos VL (2012).
<em>Optimal Control</em>, 3rd ed edition.
Wiley, Hoboken.
ISBN 978-0-470-63349-6..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)

#Normalize rows to sum to 1
A = solve(diag(rowSums(A))) %*% A

B = S = Q_seq = R_seq = diag(3)

CS = control_scheme_DLI_freestate(100, A, B, S, Q_seq, R_seq)

traj = control_traj(100, rep(100,3), A, B, control_scheme = CS)

#First 5 control inputs
print(head(traj[[3]]))
</code></pre>

<hr>
<h2 id='dlyap'>Discrete Lyapunov Equation Solver</h2><span id='topic+dlyap'></span>

<h3>Description</h3>

<p>Computes the solution of <code class="reqn">AXA^T - X + W = 0</code> using the Barraud 1977 approach, adapted from Datta 2004.
This implementation is equivalent to the Matlab implementation of dylap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlyap(A, W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlyap_+3A_a">A</code></td>
<td>
<p><code class="reqn">n x n</code> numeric or complex matrix.</p>
</td></tr>
<tr><td><code id="dlyap_+3A_w">W</code></td>
<td>
<p><code class="reqn">n x n</code> numeric or complex matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution to the above Lyapunov equation.
</p>


<h3>References</h3>

<p>Barraud A (1977).
&ldquo;A numerical algorithm to solve \$ A^TXA - X = Q\$.&rdquo;
<em>IEEE Transactions on Automatic Control</em>, <b>22</b>(5), 883&ndash;885.
ISSN 0018-9286, doi: <a href="https://doi.org/10/fr9gs7">10/fr9gs7</a>, <a href="http://ieeexplore.ieee.org/document/1101604/">http://ieeexplore.ieee.org/document/1101604/</a>.
</p>
<p>Datta BN (2004).
<em>Numerical methods for linear control systems: design and analysis</em>.
Elsevier Academic Press, Amsterdam ; Boston.
ISBN 978-0-12-203590-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)
C = matrix(c(-2,-8,11,2,-6,13,-3,-5,-2), 3,3)
X = dlyap(t(A), C)

print(sum(abs(A %*% X %*% t(A) - X + C)))
</code></pre>

<hr>
<h2 id='inv_average_control'>Trace of the Inverse Gramian</h2><span id='topic+inv_average_control'></span>

<h3>Description</h3>

<p>A commonly used measure of the overall controllability of a system defined by <code class="reqn">x_(t+1) = Ax_(t) + Bu_(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_average_control(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_average_control_+3A_a">A</code></td>
<td>
<p>A <code class="reqn">n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="inv_average_control_+3A_b">B</code></td>
<td>
<p>A <code class="reqn">n x m</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trace of the inverse infinite time Gramian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)
B = diag(3)

inv_average_control(A, B)
</code></pre>

<hr>
<h2 id='LQR'>Linear Quadratic Regulator</h2><span id='topic+LQR'></span>

<h3>Description</h3>

<p>Creates a function that can be used to calculate the cumulative value of the LQR
for any set of states and control inputs. By setting eval to True, 
the LQR is immediately calculated. See (Lewis et al. 2012)
</p>
<p>NOTE: LQR functions, as they are calculated forward in time, go to 0 by the maximum time regardless of input. 
This is expected behavior, but that does make using the LQR value to evaluate control efficacy somewhat difficult.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LQR(X, U, S, Q_seq, R_seq, eval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LQR_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">t x p</code> matrix of state values</p>
</td></tr>
<tr><td><code id="LQR_+3A_u">U</code></td>
<td>
<p>A <code class="reqn">t-1 x q</code> matrix of control inputs'</p>
</td></tr>
<tr><td><code id="LQR_+3A_s">S</code></td>
<td>
<p>A <code class="reqn">p x p</code> final state weighting matrix</p>
</td></tr>
<tr><td><code id="LQR_+3A_q_seq">Q_seq</code></td>
<td>
<p>A list of <code class="reqn">t</code> <code class="reqn">p x p</code> intermediate state weighting matrices or a single <code class="reqn">p x p</code> intermediate state weighting matrix</p>
</td></tr>
<tr><td><code id="LQR_+3A_r_seq">R_seq</code></td>
<td>
<p>A list of <code class="reqn">t</code> <code class="reqn">q x q</code> intermediate cost matrices or a single <code class="reqn">q x q</code> cost matrix</p>
</td></tr>
<tr><td><code id="LQR_+3A_eval">eval</code></td>
<td>
<p>Boolean, if <code>FALSE</code> returns a function, if <code>TRUE</code> calculates the LQR series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function or a <code class="reqn">t</code> length numeric vector
</p>


<h3>References</h3>

<p>Lewis FL, Vrabie DL, Syrmos VL (2012).
<em>Optimal Control</em>, 3rd ed edition.
Wiley, Hoboken.
ISBN 978-0-470-63349-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X = matrix(1, 100, 3)
U = matrix(-1, 99, 3)
S = Q_seq = R_seq = diag(3)

print(LQR(X,U, S, Q_seq, R_seq)[1:5])

</code></pre>

<hr>
<h2 id='modal_control'>Modal Control</h2><span id='topic+modal_control'></span>

<h3>Description</h3>

<p>Calculates the modal control (Hamdan and Nayfeh 1989) of a system defined by <code class="reqn">x_(t+1) = Ax_(t) + Bu_(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modal_control(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modal_control_+3A_a">A</code></td>
<td>
<p>A <code class="reqn">n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="modal_control_+3A_b">B</code></td>
<td>
<p>A <code class="reqn">n x m</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">m x n</code> matrix representing the control of the <code class="reqn">n</code>th mode by the mth control input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)
B = diag(3)

modal_control(A, B)
</code></pre>

<hr>
<h2 id='modal_control_centrality'>Modal Control Centrality</h2><span id='topic+modal_control_centrality'></span>

<h3>Description</h3>

<p>Calculates the modal control centrality of a system defined by <code class="reqn">x_(t+1) = Ax_(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modal_control_centrality(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modal_control_centrality_+3A_a">A</code></td>
<td>
<p>An n by n matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length n vector of modal control centrality measures(Pasqualetti et al. 2014), representing the overall modal control of each node in the system.
</p>


<h3>References</h3>

<p>Pasqualetti F, Zampieri S, Bullo F (2014).
&ldquo;Controllability Metrics, Limitations and Algorithms for Complex Networks.&rdquo;
In <em>2014 American Control Conference</em>, 3287&ndash;3292.
ISBN 978-1-4799-3274-0 978-1-4799-3272-6 978-1-4799-3271-9, doi: <a href="https://doi.org/10/ggkhs9">10/ggkhs9</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,-3,-2,2,-2,1,-1,2,-1), 3,3)

modal_control_centrality(A)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
