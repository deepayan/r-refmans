<!DOCTYPE html><html><head><title>Help for package CoMiRe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CoMiRe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.risk'><p>Additional risk function</p></a></li>
<li><a href='#as.classCoMiRe'><p>classCoMiRe class constructor</p></a></li>
<li><a href='#betaplot'><p><code class="reqn">\beta(x)</code> plot</p></a></li>
<li><a href='#BMD'><p>Benchmark dose</p></a></li>
<li><a href='#bmd.plot'><p>Benchmark dose plot</p></a></li>
<li><a href='#CoMiRe-package'>
<p>Convex Mixture Regression</p></a></li>
<li><a href='#comire.gibbs'><p>Gibbs sampler for CoMiRe model</p></a></li>
<li><a href='#comire.internal'><p>Internal Functions of CoMiRe package</p></a></li>
<li><a href='#CPP'><p>Collaborative Perinatal Project data</p></a></li>
<li><a href='#fit.pdf.mcmc'><p>Posterior mean density plot for dose intervals</p></a></li>
<li><a href='#plot.classCoMiRe'><p>CoMiRe plot</p></a></li>
<li><a href='#post.pred.check'><p>Posterior predictive check plot</p></a></li>
<li><a href='#predict_new_z'><p>comire.gibbs for different fixed values of z</p></a></li>
<li><a href='#print.classCoMiRe'><p>CoMiRe print</p></a></li>
<li><a href='#riskplot'><p>Additional risk function plot</p></a></li>
<li><a href='#summary.classCoMiRe'><p>CoMiRe summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convex Mixture Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Canale [aut, cre], Daniele Durante [ctb], Arianna Falcioni [aut], Luisa Galtarossa [aut], Tommaso Rigon [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Canale &lt;antonio.canale@unipd.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Posterior inference under the convex mixture regression (CoMiRe) models introduced by Canale, Durante, and Dunson (2018) &lt;<a href="https://doi.org/10.1111%2Fbiom.12917">doi:10.1111/biom.12917</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), KernSmooth, ggplot2, gtools, mvtnorm,
splines2 (&ge; 0.3.1), truncnorm, rlang</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 17:00:03 UTC; tony</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 09:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.risk'>Additional risk function</h2><span id='topic+add.risk'></span>

<h3>Description</h3>

<p>Additional risk function estimated from the object <code>fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.risk(y, x, fit, mcmc, a, alpha=0.05, 
x.grid=NULL, y.grid=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.risk_+3A_y">y</code></td>
<td>
<p>optional numeric vector for the response used in <code>comire.gibbs</code>. If <code>y</code> is missing, <code>y.grid</code> must be provided.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_fit">fit</code></td>
<td>
<p>the output of <code>comire.gibbs</code>. an object of the class <code>classCoMiRe</code>.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_a">a</code></td>
<td>
<p>threshold of clinical interest for the response variable</p>
</td></tr>
<tr><td><code id="add.risk_+3A_alpha">alpha</code></td>
<td>
<p>level of the credible bands.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_x.grid">x.grid</code></td>
<td>
<p>optional numerical vector giving the actual values of the grid for x for plotting the additional risk function. If <code class="reqn">x.gird</code> is not provided, standard grids are automatically used.</p>
</td></tr>
<tr><td><code id="add.risk_+3A_y.grid">y.grid</code></td>
<td>
<p>optional numerical vector giving the actual values of the grid for y for plotting the additional risk function. If <code class="reqn">y.gird</code> is not provided, standard grids are automatically used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arguments for generating posterior output. It contains:
</p>

<ul>
<li><p><code>mcmc.risk</code> a matrix containing in the lines the MCMC chains, after thinning, of the additional risk function over <code>x.grid</code>, in the columns. 
</p>
</li>
<li><p><code>summary.risk</code> a data frame with four variables: the posterior means of the additional risk function over <code>x.grid</code>, the respective <code class="reqn">\alpha/2</code> and <code class="reqn">1-\alpha/2</code> quantiles, and <code>x.grid</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, 
    a = 37, x.grid = seq(0, max(dde), length = 100))
riskplot(risk.data$summary.risk, xlab="DDE", x = dde, xlim = c(0,150))
                    

## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit1 &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)
 
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit1, mcmc = mcmc, 
a = 37, x.grid = seq(0, max(dde), length = 100))
riskplot(risk.data$summary.risk, xlab="DDE", x = dde, xlim = c(0,150))


}
</code></pre>

<hr>
<h2 id='as.classCoMiRe'>classCoMiRe class constructor</h2><span id='topic+as.classCoMiRe'></span>

<h3>Description</h3>

<p>A constructor for the <code>classCoMiRe</code> class. The class <code>classCoMiRe</code> is a named list containing
the output of the posterior estimation of CoMiRe model implemented in <code>comire.gibbs</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.classCoMiRe(call = NULL, out = NULL, z = NULL, z.val = NULL, f0 = NULL, f1 = NULL, 
nrep, nb, bin = FALSE, univariate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.classCoMiRe_+3A_call">call</code></td>
<td>
<p>a formula for <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_out">out</code></td>
<td>
<p>an output of <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_z">z</code></td>
<td>
<p>optional numeric vector or matrix for the confounding covariates.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_z.val">z.val</code></td>
<td>
<p>optional numeric vector containing a fixed value of interest for each of the confounding covariates to be used for the plots. Default value is <code>mean(z)</code> for numeric covariates or the mode for factorial covariates.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_f0">f0</code>, <code id="as.classCoMiRe_+3A_f1">f1</code></td>
<td>
<p>optional matrices containing simulated values of the mixture densities at low and high dose exposure; default values are simulated with <code>comire.gibbs</code>. It is possible to change these for differente fixed values of <code>z</code>: see <code>predict_new_z</code> function.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_nrep">nrep</code></td>
<td>
<p>integer giving the total number of iterations used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_nb">nb</code></td>
<td>
<p>integer giving the number of burn-in iterations used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_bin">bin</code></td>
<td>
<p>logical. It is <code>TRUE</code> if y is drawn for a binomial distribution.</p>
</td></tr>
<tr><td><code id="as.classCoMiRe_+3A_univariate">univariate</code></td>
<td>
<p>logical. It is <code>TRUE</code> if the model is univariate.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>

<hr>
<h2 id='betaplot'><code class="reqn">\beta(x)</code> plot</h2><span id='topic+betaplot'></span>

<h3>Description</h3>

<p>Posterior mean (continuous lines) and pointwise credible bands (shaded areas) for <code class="reqn">\beta(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaplot(x, fit, x.grid = NULL, xlim = c(0, max(x)), xlab = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaplot_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="betaplot_+3A_fit">fit</code></td>
<td>
<p>the output of <code>comire.gibbs</code> opportunely trasformed in <code>classCoMiRe</code> class.</p>
</td></tr>
<tr><td><code id="betaplot_+3A_x.grid">x.grid</code></td>
<td>
<p>optional numerical vector giving the actual values of the grid for x for plotting <code class="reqn">\beta(x)</code>. 
If <code>x.gird</code> is not provided, standard grids are automatically used.</p>
</td></tr>
<tr><td><code id="betaplot_+3A_xlim">xlim</code></td>
<td>
<p>numeric vectors of length 2, giving the x coordinates ranges for the plot.</p>
</td></tr>
<tr><td><code id="betaplot_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
betaplot(x=dde, fit=fit.dummy, x.grid=seq(0,180, length=100), xlim=c(0,150))


## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit1 &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)

                         
betaplot(x=dde, fit=fit1, x.grid=seq(0,180, length=100), xlim=c(0,150))


}
</code></pre>

<hr>
<h2 id='BMD'>Benchmark dose</h2><span id='topic+BMD'></span>

<h3>Description</h3>

<p>Benchmark dose associated to a particular risk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMD(level, risk, x, alpha=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BMD_+3A_level">level</code></td>
<td>
<p>dose level of interest.</p>
</td></tr>
<tr><td><code id="BMD_+3A_risk">risk</code></td>
<td>
<p><code>summary.risk$mcmc.risk</code> from the output of <code>add.risk</code> function.</p>
</td></tr>
<tr><td><code id="BMD_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="BMD_+3A_alpha">alpha</code></td>
<td>
<p>level of the credible bands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing as variables:
</p>

<ul>
<li><p><code>q</code> the dose level of interest.
</p>
</li>
<li><p><code>BMD</code> the benchmark dose.
</p>
</li>
<li><p><code>low</code> lower credible limit.
</p>
</li>
<li><p><code>upp</code> upper credible limit.
</p>
</li>
<li><p><code>BMDL</code> a more conservative benchmark dose.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Antonio Canale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, 
    a = 37, x.grid = seq(0, max(dde), length = 100))
bmd.data &lt;- BMD(seq(0,.20, length=50), risk.data$mcmc.risk, 
x=seq(0,max(dde), length=100), alpha=0.05)
bmd.plot(bmd.data)       
                     

## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)


risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit, mcmc = mcmc,
a = 37, x.grid = seq(0, max(dde), length = 100))
bmd.data &lt;- BMD(seq(0,.20, length=50), risk.data$mcmc.risk, 
x=seq(0,max(dde), length=100), alpha=0.05)
bmd.plot(bmd.data)       


}
</code></pre>

<hr>
<h2 id='bmd.plot'>Benchmark dose plot</h2><span id='topic+bmd.plot'></span>

<h3>Description</h3>

<p>Posterior mean (continuous lines) and pointwise credible bands (shaded areas) for the benchmark dose in function of the increase in risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmd.plot(bmd.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmd.plot_+3A_bmd.data">bmd.data</code></td>
<td>
<p>output of <code>BMD</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, 
    a = 37, x.grid = seq(0, max(dde), length = 100))
bmd.data &lt;- BMD(seq(0,.20, length=50), risk.data$mcmc.risk, 
x=seq(0,max(dde), length=100), alpha=0.05)
bmd.plot(bmd.data)       


## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)
                     
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit, mcmc = mcmc, 
a = 37, x.grid = seq(0, max(dde), length = 100))
bmd.data &lt;- BMD(seq(0,.20, length=50), risk.data$mcmc.risk, 
x=seq(0,max(dde), length=100), alpha=0.05)
bmd.plot(bmd.data)       


}
</code></pre>

<hr>
<h2 id='CoMiRe-package'>
Convex Mixture Regression
</h2><span id='topic+CoMiRe-package'></span><span id='topic+CoMiRe'></span>

<h3>Description</h3>

<p>Posterior inference under the convex mixture regression (CoMiRe) models introduced by Canale, Durante, and Dunson (2018) &lt;doi:10.1111/biom.12917&gt;.
</p>


<h3>Details</h3>

<p>The <code>CoMiRe</code> package implements the convex mixture regresion approach of Canale, Durante, and Dunson (2018) and some extensions to deal with binary response variables or to account for the presence of continuous and categorical confunders. Estimation is conducted via Gibbs sampler. Posterior plots for inference and goodness-of-fit tests are also available.</p>


<h3>Author(s)</h3>

<p>Antonio Canale [aut, cre], Daniele Durante [ctb], Arianna Falcioni [aut], Luisa Galtarossa [aut], Tommaso Rigon [ctb]
Maintainer: Antonio Canale &lt;antonio.canale@unipd.it&gt;
</p>


<h3>References</h3>

<p>Canale, A., Durante, D., and Dunson, D. (2018), Convex Mixture Regression for Quantitative Risk Assessment, Biometrics, 74, 1331-1340
</p>

<hr>
<h2 id='comire.gibbs'>Gibbs sampler for CoMiRe model</h2><span id='topic+comire.gibbs'></span>

<h3>Description</h3>

<p>Posterior inference via Gibbs sampler for CoMiRe model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comire.gibbs(y, x, z = NULL, family = 'continuous', 
       grid = NULL, mcmc, prior, 
       state = NULL, seed, max.x = max(x), z.val = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comire.gibbs_+3A_y">y</code></td>
<td>
<p>numeric vector for the response:
when <code>family="continuous"</code> <code>y</code> must be a numeric vector; if <code>family="binary"</code> <code>y</code> must assume values <code>0</code> or <code>1</code>.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_z">z</code></td>
<td>
<p>numeric vector for the confunders; a vector if there is only one 
confounder or a matrix for two or more confunders</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_family">family</code></td>
<td>
<p>type of <code>y</code>. This can be <code>"continuous"</code> or <code>"binary"</code>. Default  <code>"continuous"</code>.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_grid">grid</code></td>
<td>
<p>a list giving the parameters for plotting the posterior mean density and the posterior mean <code class="reqn">\beta(x)</code> over finite grids
if <code>family="continuous"</code> and <code>z=NULL</code>. It must include the following values:
</p>

<ul>
<li> <p><code>grids</code>, logical value (if <code>TRUE</code> the provided grids are used, otherwise standard grids are automatically used); 
</p>
</li>
<li> <p><code>xgrid</code> and <code>ygrid</code>, numerical vectors with the actual values of the grid for y and x.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. It must include the following integers: <code>nb</code> giving the number of burn-in iterations, <code>nrep</code> giving the total number of iterations, <code>thin</code> giving the thinning interval, <code>ndisplay</code> giving the multiple of iterations to be displayed on screen while the algorithm is running (a message will be printed every <code>ndisplay</code> iterations).</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_prior">prior</code></td>
<td>
<p>a list containing the values of the hyperparameters. 
</p>
<p>If <code>family = "continuous"</code>, it must include the following values: 
</p>

<ul>
<li> <p><code>mu.theta</code>, the prior mean <code class="reqn">\mu_\theta</code> for each location parameter <code class="reqn">\theta_{0h}</code> and <code class="reqn">\theta_1</code>, 
</p>
</li>
<li> <p><code>k.theta</code>, the prior variance <code class="reqn">k_\theta</code> for each location paramter <code class="reqn">\theta_{0h}</code> and <code class="reqn">\theta_1</code>, 
</p>
</li>
<li> <p><code>mu.gamma</code> (if <code>p</code> confounding covariates are included in the model) a <code>p</code>-dimentional vector of prior means <code class="reqn">\mu_\gamma</code> of the parameters <code class="reqn">\gamma</code> corresponding to the confounders,
</p>
</li>
<li> <p><code>k.gamma</code>, the prior variance <code class="reqn">k_\gamma</code> for parameter corresponding to the confounding covariate (if <code>p=1</code>) or <code>sigma.gamma</code> (if <code>p&gt;1</code>), that is the covariance matrix <code class="reqn">\Sigma_\gamma</code> for the parameters corresponding to the <code>p</code> confounding covariates; this must be a symmetric positive definite matrix.
</p>
</li>
<li> <p><code>eta</code>, numeric vector of size <code>J</code> for the Dirichlet prior on the beta basis weights, 
</p>
</li>
<li> <p><code>alpha</code>, prior for the mixture weights,
</p>
</li>
<li> <p><code>a</code> and <code>b</code>, prior scale and shape parameter for the gamma distribution of each precision parameter, 
</p>
</li>
<li> <p><code>J</code>, parameter controlling the number of elements of the I-spline basis,
</p>
</li>
<li> <p><code>H</code>, total number of components in the mixture at <code class="reqn">x_0</code>.
</p>
</li></ul>

<p>If <code>family="binary"</code> it must include the following values: 
</p>

<ul>
<li> <p><code>eta</code>, numeric vector of size <code>J</code> for the Dirichlet prior on the beta basis weights, 
</p>
</li>
<li> <p><code>a.pi0</code> and <code>b.pi0</code>, the prior parameters of the prior beta distribution for <code class="reqn">\pi_0</code>,
</p>
</li>
<li> <p><code>J</code>, parameter controlling the number of elements of the Ispline basis.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_state">state</code></td>
<td>
<p>if <code>family="continuous"</code>, a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a previous analysis or if we want to start the MCMC algorithm from some particular value of the parameters.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_seed">seed</code></td>
<td>
<p>seed for random initialization.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_max.x">max.x</code></td>
<td>
<p>maximum value allowed for <code>x</code>.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_z.val">z.val</code></td>
<td>
<p>optional numeric vector containing a fixed value of interest for each of the confounding covariates to be used for the plots. Default value is <code>mean(z)</code> for numeric covariates or the mode for factorial covariates.</p>
</td></tr>
<tr><td><code id="comire.gibbs_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code> a message on the status of the MCMC algorithm is printed to the console. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fit a convex mixture regression (<code>CoMiRe</code>) model (Canale, Durante, Dunson, 2018) via Gibbs sampler. 
For continuous outcome <code class="reqn">y \in \mathcal{Y}</code>, adverse esposure level <code class="reqn">x \in \mathcal{X}</code> and no confunding 
variables, one can set <code>family = 'continuous'</code> and <code>z = NULL</code> and fit model
<br />
<code class="reqn"> f_x(y) = \{1-\beta(x)\} \sum_{h=1}^{H}\nu_{0h} \phi(y; \theta_{0h}, \tau_{0h}^{-1}) + \beta(x) \phi(y; \theta_{\infty}, \tau_{\infty}^{-1})</code> ;<br />
<br />
where <code class="reqn">\beta(x) = \sum_{j=1}^{J} \omega_j \psi_j(x), x\ge0,</code> 
is a a monotone nondecreasing interpolation function, constrained between 0 and 1 and  <code class="reqn">\psi_1,...,\psi_J</code> are monotone nondecreasing I-splines basis. 
<br />
If <code class="reqn">p \ge 1</code> confounding covariates <code class="reqn">z \in \mathcal{Z}</code> are available, passing the argument <code>z</code> 
the function fits model<br />
<br />
<code class="reqn">f(y; x,z) = \{1-\beta(x)\} f_0(y;z) + \beta(x) f_\infty(y;z)</code> ;<br />
<br />
where: <br />
<code class="reqn">f_0(y;z)= \sum_{h=1}^{H} \nu_{0h} \phi(y;\theta_{0h}+z^\mathsf{T}\gamma,\tau_{0h}^{-1})</code>, and 
<code class="reqn">f_\infty(y;z)= \phi(y;\theta_\infty+ z^\mathsf{T}\gamma,\tau_{\infty}^{-1})</code>. <br />
<br />
Finally, if <code class="reqn">y</code> is a binary response, one can set <code>family = 'binary'</code> and fit model <br />
<br />
<code class="reqn">p_x(y) = (\pi_x)^y (1 - \pi_x)^{1-y}</code> ; <br />
<br />
where <code class="reqn">\pi_x = P(Y=1 | x)</code> is 
<code class="reqn">\pi_x = \{1-\beta(x)\} \pi_0 + \beta(x) \pi_\infty</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>classCoMiRe</code>, i.e. a list of arguments for generating posterior output. It contains:
</p>

<ul>
<li><p><code>call</code>the model formula
</p>
</li>
<li><p><code>post.means</code> a list containing the posterior mean density beta over the grid, of all the mixture parameters and, 
if <code>family = "continuous"</code> and <code>z = NULL</code>, of <code class="reqn">f_0</code> and <code class="reqn">f_{inf}</code> over the <code>y.grid</code>.
</p>
</li>
<li><p><code>ci</code> a list containing the 95% credible intervals for all the quantities stored in <code>post.means</code>.
</p>
</li>
<li><p><code>mcmc</code> a list containing all the MCMC chains.
</p>
</li>
<li><p><code>z</code> the same of the input
</p>
</li>
<li><p><code>z.val</code> the same of the input
</p>
</li>
<li><p><code>f0,f1</code> MCMC replicates of the density in the two extremes (only if <code>family = 'continuous'</code>)
</p>
</li>
<li><p><code>nrep,nb</code> the same values of the list <code>mcmc</code> in the input arguments
</p>
</li>
<li><p><code>bin</code> logical, equal to <code>TRUE</code> if <code>family = 'binary'</code>
</p>
</li>
<li><p><code>univariate</code> logical, equal to <code>TRUE</code> if <code>z</code> is null or a vector
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Antonio Canale [aut, cre], Daniele Durante [ctb], Arianna Falcioni [aut], Luisa Galtarossa [aut], Tommaso Rigon [ctb]
</p>


<h3>References</h3>

<p>Canale, A., Durante, D., and Dunson, D. (2018), Convex Mixture Regression for Quantitative Risk Assessment, Biometrics, 74, 1331-1340
</p>
<p>Galtarossa, L., Canale, A., (2019), A Convex Mixture Model for Binomial Regression, Book of Short Papers SIS 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 


prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
summary(fit.dummy)
 


## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4) 

## 1. binary case ##

prior &lt;- list(pi0=mean(gestage), eta=rep(1, J)/J, 
             a.pi0=27, b.pi0=360, J=J)
             
fit_binary&lt;- comire.gibbs(premature, dde, family="binary", 
                          mcmc=mcmc, prior=prior, seed=5, max.x=180)
                          
                          
## 2. continuous case ##

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit1 &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)


## 2.2 One confunder ##

mage_std &lt;- scale(mage, center = TRUE, scale = TRUE) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, mu.gamma=0, k.gamma=10, 
              eta=rep(1, J)/J, alpha=1/H, a=2, b=2, H=H, J=J)
              
fit2 &lt;- comire.gibbs(gestage, dde, mage_std, family="continuous", 
              mcmc=mcmc, prior=prior, seed=5, max.x=180)


## 2.3 More confunders ##

Z &lt;- cbind(mage, mbmi, sei)
Z &lt;- scale(Z, center = TRUE, scale = TRUE)
Z &lt;- as.matrix(cbind(Z, CPP$smoke))
colnames(Z) &lt;- c("age", "BMI", "sei", "smoke")

mod &lt;- lm(gestage ~ dde + Z)
prior &lt;- list(mu.theta = mod$coefficients[1], k.theta = 10,
              mu.gamma = mod$coefficients[-c(1, 2)], sigma.gamma = diag(rep(10, 4)),
              eta = rep(1, J)/J, alpha = 1/H, a = 2, b = 2, H = H, J = J)
              
fit3 &lt;- comire.gibbs(y = gestage, x = dde, z = Z, family = "continuous", mcmc = mcmc, 
                     prior = prior, seed = 5)

 
}



</code></pre>

<hr>
<h2 id='comire.internal'>Internal Functions of CoMiRe package</h2><span id='topic+comire.internal'></span><span id='topic+.labelling_b_C'></span><span id='topic+.labelling_bb_C'></span><span id='topic+.labelling_c_C'></span><span id='topic+.mixdensity_C'></span><span id='topic+.pssq_gaussian'></span><span id='topic+.labelling_b_uni'></span><span id='topic+.labelling_c_uni'></span><span id='topic+.mixdensity_uni'></span><span id='topic+.pssq_uni'></span><span id='topic+.psdp_uni'></span><span id='topic+.labelling_b_multi'></span><span id='topic+.labelling_c_multi'></span><span id='topic+.mixdensity_multi'></span><span id='topic+.pssq_multi'></span><span id='topic+.psdp_multi'></span>

<h3>Description</h3>

<p>Internal Functions of CoMiRe package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.labelling_b_C(w, phi, f0i, f1i)

.labelling_bb_C(w, phi, P0, P1)

.labelling_c_C(y, logpi, mu, tau)

.mixdensity_C(y, pi, mu, tau)

.pssq_gaussian(index, data, cluster, locations)

.labelling_b_uni(i, w, phi, f0i, f1i)

.labelling_c_uni(i, y, z, nu, theta, tau, ga)

.mixdensity_uni(i, y, z, nu, theta, tau, ga)

.pssq_uni(index, y, z, cluster, theta, gamma)

.psdp_uni(index, y, z, cluster)

.labelling_b_multi(i, w, phi, f0i, f1i)

.labelling_c_multi(i, y, z, nu, theta, tau, ga)

.mixdensity_multi(i, y, z, nu, theta, tau, ga)

.pssq_multi(y, times, z, gamma, theta)

.psdp_multi(index, y, z, cluster)
</code></pre>

<hr>
<h2 id='CPP'>Collaborative Perinatal Project data</h2><span id='topic+CPP'></span>

<h3>Description</h3>

<p>A subset of the Collaborative Perinatal Project data set (Klebanoff, 2009)
focusing on studying the effect of DDE exposure on pregnancies (Longnecker et al., 2001).
The dataset contains the following variables for each pregnant women enrolled in the study:
</p>

<ul>
<li><p> hosp, factor denoting the hospital where the woman was hospitalized;
</p>
</li>
<li><p> dde, Dichlorodiphenyldichloroethylene (DDE) concentration in maternal serum;
</p>
</li>
<li><p> gestage, gestational age (in weeks);
</p>
</li>
<li><p> mage, age of the moter (in years);
</p>
</li>
<li><p> mweight, pre pregnancy weigth of the mother (in lbs);
</p>
</li>
<li><p> mbmi, pre pregnancy BMI of the mother;
</p>
</li>
<li><p> sei, socio economic index of the mother;
</p>
</li>
<li><p> smoke, factor. It takes value 2 if the woman is a smoker, 1 otherwise;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(CPP)
</code></pre>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>References</h3>

<p>Klebanoff M. A. (2009) The collaborative perinatal project: a 50-year retrospective.
Paediatric and perinatal epidemiology, 23, 2.
</p>
<p>Longnecker, M. P., Klebanof, M. A., Zhou, H., Brock, J. (2001)
Association between maternal serum concentration of the DDT metabolite
DDE and preterm and small-for-gestational-age babies at birth. The Lancet, 358, 110-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CPP)
str(CPP)

</code></pre>

<hr>
<h2 id='fit.pdf.mcmc'>Posterior mean density plot for dose intervals</h2><span id='topic+fit.pdf.mcmc'></span>

<h3>Description</h3>

<p>Pointwise posterior mean (continuous blue lines), and credible bands (shaded blue areas) for f (y | x, z) 
calculated in <code>x.val</code> under the the model fitted in <code>fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.pdf.mcmc(y, x, fit, mcmc, J=10, H = 10, alpha = 0.05, 
max.x = max(x), x.val, y.grid = NULL, xlim = c(0, max(x)), 
ylim = c(0, 1), xlab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.pdf.mcmc_+3A_y">y</code></td>
<td>
<p>optional numeric vector for the response used in <code>comire.gibbs</code>. If <code>y</code> is missing, <code>y.grid</code> must be provided.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_fit">fit</code></td>
<td>
<p>the output of <code>comire.gibbs</code> opportunely trasformed in <code>classCoMiRe</code> class.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_j">J</code></td>
<td>
<p>parameter controlling the number of elements of the I-spline basis</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_h">H</code></td>
<td>
<p>total number of components in the mixture at <code class="reqn">x_0</code>.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_alpha">alpha</code></td>
<td>
<p>level of the credible bands.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_max.x">max.x</code></td>
<td>
<p>maximum value allowed for x.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_x.val">x.val</code></td>
<td>
<p>central points of each dose interval to be used in the posterior estimation of the probability density function.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_y.grid">y.grid</code></td>
<td>
<p>optional numerical vector giving the actual values of the grid for y for plotting the posterior mean density. If <code>y.grid</code> is not provided, standard grids are automatically used.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_xlim">xlim</code>, <code id="fit.pdf.mcmc_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges for the plot.</p>
</td></tr>
<tr><td><code id="fit.pdf.mcmc_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
fit.pdf.mcmc(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, J = 10, H = 10, 
                         alpha = 0.05, max.x = max(dde), x.val = 125, 
                         xlim = c(25,48), ylim = c(0,0.25),
                         xlab = "Gest. age. for DDE = 125")
                         

## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit1 &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)
          
fit.pdf.mcmc(y = gestage, x = dde, fit = fit1, mcmc = mcmc, J = 10, H = 10, 
                         alpha = 0.05, max.x = max(dde), x.val = 125, 
                         xlim = c(25,48), ylim = c(0,0.25),
                         xlab = "Gest. age. for DDE = 125")
                         

}
</code></pre>

<hr>
<h2 id='plot.classCoMiRe'>CoMiRe plot</h2><span id='topic+plot.classCoMiRe'></span>

<h3>Description</h3>

<p>An S3 plot method for an object of <code>classCoMiRe</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classCoMiRe'
plot(
  x,
  y,
  xobs,
  mcmc,
  J = 10,
  H = 10,
  a = NULL,
  max.x = max(xobs),
  bandwidth = 20,
  x.grid = NULL,
  xlim = c(0, max(xobs)),
  ylim = c(0, 1),
  xlab = "x",
  alpha = 0.05,
  risk = TRUE,
  bmd = TRUE,
  level,
  oneevery = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.classCoMiRe_+3A_x">x</code></td>
<td>
<p>the output of <code>comire.gibbs</code>, an object of the <code>classCoMiRe</code> class.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_y">y</code></td>
<td>
<p>numeric vector for the response used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_xobs">xobs</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_j">J</code></td>
<td>
<p>parameter controlling the number of elements of the I-spline basis</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_h">H</code></td>
<td>
<p>total number of components in the mixture at <code class="reqn">x_0</code>.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_a">a</code></td>
<td>
<p>optional threshold of clinical interest for the response variable.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_max.x">max.x</code></td>
<td>
<p>maximum value allowed for x.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter for the <code>post.pred.check</code> plot.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_x.grid">x.grid</code></td>
<td>
<p>optional numerical vector giving the actual values of the grid for x for plotting the additional risk function. If <code class="reqn">x.gird</code> is not provided, standard grids are automatically used.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_xlim">xlim</code>, <code id="plot.classCoMiRe_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges for the plot.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_alpha">alpha</code></td>
<td>
<p>level of the credible bands, default 0.05</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_risk">risk</code></td>
<td>
<p>if <code>TRUE</code> the additional risk plot via <code>riskplot</code> is computed.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_bmd">bmd</code></td>
<td>
<p>if <code>TRUE</code> the benchmark dose plot via <code>bmd.plot</code> is computed.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_level">level</code></td>
<td>
<p>if <code>bmd=TRUE</code>, dose levels of interest for BMD plot.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_oneevery">oneevery</code></td>
<td>
<p>integer number representing how many MCMC draws to plot in the posterior predictive check. It draws one sample every <code>oneevery</code>.</p>
</td></tr>
<tr><td><code id="plot.classCoMiRe_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a list of 
<code>ggplot2</code> plots containing the result of the <code>betaplot</code> function and, if the threshold <code>a</code> is provided, of 
<code>post.pred.check</code>, <code>riskplot</code>, <code>bmd.plot</code>.
</p>


<h3>Value</h3>

<p>If <code>a=NULL</code> returns only <code>betaplot</code> otherwise, if <code>risk=FALSE</code> and 
<code>bmd=FALSE</code> returns a list containing <code>betaplot</code> (which is automatically plotted) 
and <code>post.pred.check</code> plot. Finally, if <code>a</code> is provided, <code>risk=TRUE</code> and <code>bmd=TRUE</code>
returns a list with <code>betaplot</code>, <code>post.pred.check</code>, <code>riskplot</code> and <code>bmd.plot</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>

<hr>
<h2 id='post.pred.check'>Posterior predictive check plot</h2><span id='topic+post.pred.check'></span>

<h3>Description</h3>

<p>A plot for an object of <code>classCoMiRe</code> class. The plot is a goodness-of-fit assessment of CoMiRe model. 
Since Version 0.8 if <code>z</code> is provided into the <code>fit</code> object, an error message is returned.
If <code>family = 'continuous'</code>, a smoothed empirical estimate of F(a|x) = pr(y &lt; a | x) is computed from the observed data (black line) 
and from some of the data sets simulated from the posterior predictive distribution in  the <code>fit</code> object (grey lines).
If <code>family = 'binary'</code>, a smoothed empirical estimate of the proportion of events (black line) and of the smoothed empirical 
proportion of data simulated from the posterior predictive distribution in the <code>fit</code> object (grey lines). 
In the x axis are reported the observed exposures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.pred.check(y, x, fit, mcmc, J=10, H=10, a, max.x=max(x), 
xlim=c(0, max(x)), bandwidth = 20, oneevery = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post.pred.check_+3A_y">y</code></td>
<td>
<p>numeric vector for the response used in <code>comire.gibbs</code></p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code></p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_fit">fit</code></td>
<td>
<p>the output of <code>comire.gibbs</code> opportunely trasformed in <code>classCoMiRe</code> class</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_j">J</code></td>
<td>
<p>parameter controlling the number of elements of the I-spline basis</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_h">H</code></td>
<td>
<p>total number of components in the mixture at <code class="reqn">x_0</code></p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_a">a</code></td>
<td>
<p>threshold of clinical interest to compute the F(a|x,z)</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_max.x">max.x</code></td>
<td>
<p>maximum value allowed for x</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_xlim">xlim</code></td>
<td>
<p>numeric vectors of length 2, giving the x coordinates ranges for the plot</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter</p>
</td></tr>
<tr><td><code id="post.pred.check_+3A_oneevery">oneevery</code></td>
<td>
<p>integer number representing how many MCMC draws to plot in the posterior predictive check. It draws one sample every <code>oneevery</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
post.pred.check(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, J = 10, H = 10, a = 37, 
                max.x = max(dde), xlim = c(0,150), oneevery = 4)
                

## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit1 &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)

post.pred.check(y = gestage, x = dde, fit = fit1, mcmc = mcmc, J = 10, H = 10, a = 37, 
                max.x = max(dde), xlim = c(0,150))


}
</code></pre>

<hr>
<h2 id='predict_new_z'>comire.gibbs for different fixed values of z</h2><span id='topic+predict_new_z'></span>

<h3>Description</h3>

<p>This function computes the predicted values of the density al low 
dose <code>f_0</code> and of the density at high dose <code>f_{inf}</code>, for fixed values 
of the confounders <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_new_z(fit, y, z.val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_new_z_+3A_fit">fit</code></td>
<td>
<p>the output of <code>comire.gibbs</code> opportunely trasformed in <code>classCoMiRe</code> class</p>
</td></tr>
<tr><td><code id="predict_new_z_+3A_y">y</code></td>
<td>
<p>numeric vector for the response used in <code>comire.gibbs</code></p>
</td></tr>
<tr><td><code id="predict_new_z_+3A_z.val">z.val</code></td>
<td>
<p>optional numeric vector containing a fixed value of interest for each of the confounding covariates to be used for the plots. Default value is <code>mean(z)</code> for numeric covariates or the mode for factorial covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>classCoMiRe</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>

<hr>
<h2 id='print.classCoMiRe'>CoMiRe print</h2><span id='topic+print.classCoMiRe'></span>

<h3>Description</h3>

<p>The <code>print.classCoMiRe</code> method prints the type of a <code>classCoMiRe</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classCoMiRe'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.classCoMiRe_+3A_x">x</code></td>
<td>
<p>an object of class <code>classCoMiRe</code>;</p>
</td></tr>
<tr><td><code id="print.classCoMiRe_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale, Arianna Falcioni
</p>

<hr>
<h2 id='riskplot'>Additional risk function plot</h2><span id='topic+riskplot'></span>

<h3>Description</h3>

<p>Posterior mean (continuous lines) and pointwise credible bands (shaded areas) for <code class="reqn">Ra(x, a)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskplot(risk.data, xlab = NULL, x = NULL, ylim=c(0,1), xlim=c(0, max(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskplot_+3A_risk.data">risk.data</code></td>
<td>
<p>output of <code>add.risk</code> function.</p>
</td></tr>
<tr><td><code id="riskplot_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
<tr><td><code id="riskplot_+3A_x">x</code></td>
<td>
<p>numeric vector for the covariate relative to the dose of exposure used in <code>comire.gibbs</code>.</p>
</td></tr>
<tr><td><code id="riskplot_+3A_xlim">xlim</code>, <code id="riskplot_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges for the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
data(CPP)
attach(CPP)

n &lt;- NROW(CPP)
J &lt;- H &lt;- 10

premature &lt;- as.numeric(gestage&lt;=37)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## too few iterations to be meaningful. see below for safer and more comprehensive results

mcmc &lt;- list(nrep=10, nb=2, thin=1, ndisplay=4) 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit.dummy &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=1, max.x=180)
                     
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit.dummy, mcmc = mcmc, 
    a = 37, x.grid = seq(0, max(dde), length = 100))
riskplot(risk.data$summary.risk, xlab="DDE", x = dde, xlim = c(0,150))


## safer procedure with more iterations (it may take some time)

mcmc &lt;- list(nrep=5000, nb=2000, thin=5, ndisplay=4)

## Fit the model for continuous y 

prior &lt;- list(mu.theta=mean(gestage), k.theta=10, eta=rep(1, J)/J, 
              alpha=rep(1,H)/H, a=2, b=2, J=J, H=H)
              
fit &lt;- comire.gibbs(gestage, dde, family="continuous", 
                     mcmc=mcmc, prior=prior, seed=5, max.x=180)
 
risk.data &lt;- add.risk(y = gestage, x = dde, fit = fit, mcmc = mcmc, 
a = 37, x.grid = seq(0, max(dde), length = 100))
riskplot(risk.data$summary.risk, xlab="DDE", 
x = dde, xlim = c(0,150))


}
</code></pre>

<hr>
<h2 id='summary.classCoMiRe'>CoMiRe summary</h2><span id='topic+summary.classCoMiRe'></span>

<h3>Description</h3>

<p>The <code>summary.classCoMiRe</code> method provides summary information on <code>classCoMiRe</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classCoMiRe'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.classCoMiRe_+3A_object">object</code></td>
<td>
<p>an object of class <code>classCoMiRe</code>;</p>
</td></tr>
<tr><td><code id="summary.classCoMiRe_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Canale Arianna Falcioni
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
