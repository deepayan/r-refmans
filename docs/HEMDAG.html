<!DOCTYPE html><html><head><title>Help for package HEMDAG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HEMDAG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HEMDAG-package'><p>HEMDAG: Hierarchical Ensemble Methods for Directed Acyclic Graphs</p></a></li>
<li><a href='#adj.upper.tri'><p>Binary upper triangular adjacency matrix</p></a></li>
<li><a href='#auprc'><p>AUPRC measures</p></a></li>
<li><a href='#auroc'><p>AUROC measures</p></a></li>
<li><a href='#build.ancestors'><p>Build ancestors</p></a></li>
<li><a href='#build.children'><p>Build children</p></a></li>
<li><a href='#build.consistent.graph'><p>Build consistent graph</p></a></li>
<li><a href='#build.descendants'><p>Build descendants</p></a></li>
<li><a href='#build.edges.from.hpo.obo'><p>Parse an HPO obo file</p></a></li>
<li><a href='#build.parents'><p>Build parents</p></a></li>
<li><a href='#build.scores.matrix'><p>Build scores matrix</p></a></li>
<li><a href='#build.subgraph'><p>Build subgraph</p></a></li>
<li><a href='#build.submatrix'><p>Build submatrix</p></a></li>
<li><a href='#check.annotation.matrix.integrity'><p>Annotation matrix checker</p></a></li>
<li><a href='#check.dag.integrity'><p>DAG checker</p></a></li>
<li><a href='#compute.flipped.graph'><p>Flip graph</p></a></li>
<li><a href='#constraints.matrix'><p>Constraints matrix</p></a></li>
<li><a href='#create.stratified.fold.df'><p>DataFrame for stratified cross validation</p></a></li>
<li><a href='#distances.from.leaves'><p>Distances from leaves</p></a></li>
<li><a href='#example.datasets'><p>Small real example datasets</p></a></li>
<li><a href='#find.best.f'><p>Best hierarchical F-score</p></a></li>
<li><a href='#find.leaves'><p>Leaves</p></a></li>
<li><a href='#fmax'><p>Compute Fmax</p></a></li>
<li><a href='#full.annotation.matrix'><p>Full annotation matrix</p></a></li>
<li><a href='#gpav'><p>Generalized Pool-Adjacent Violators (GPAV)</p></a></li>
<li><a href='#gpav.holdout'><p>GPAV holdout</p></a></li>
<li><a href='#gpav.over.examples'><p>GPAV over examples</p></a></li>
<li><a href='#gpav.parallel'><p>GPAV over examples &ndash; parallel implementation</p></a></li>
<li><a href='#gpav.vanilla'><p>GPAV vanilla</p></a></li>
<li><a href='#graph.levels'><p>Build graph levels</p></a></li>
<li><a href='#hierarchical.checkers'><p>Hierarchical constraints checker</p></a></li>
<li><a href='#htd'><p>HTD-DAG</p></a></li>
<li><a href='#htd.holdout'><p>HTD-DAG holdout</p></a></li>
<li><a href='#htd.vanilla'><p>HTD-DAG vanilla</p></a></li>
<li><a href='#lexicographical.topological.sort'><p>Lexicographical topological sorting</p></a></li>
<li><a href='#multilabel.F.measure'><p>multilabel F-measure</p></a></li>
<li><a href='#normalize.max'><p>Max normalization</p></a></li>
<li><a href='#obozinski.heuristic.methods'><p>Obozinski heuristic methods</p></a></li>
<li><a href='#obozinski.holdout'><p>Obozinski's heuristic methods &ndash; holdout</p></a></li>
<li><a href='#obozinski.methods'><p>Obozinski's heuristic methods calling</p></a></li>
<li><a href='#pxr'><p>Precision-Recall curves</p></a></li>
<li><a href='#read.graph'><p>Read a directed graph from a file</p></a></li>
<li><a href='#read.undirected.graph'><p>Read an undirected graph from a file</p></a></li>
<li><a href='#root.node'><p>Root node</p></a></li>
<li><a href='#scores.normalization'><p>Scores normalization function</p></a></li>
<li><a href='#specific.annotation.list'><p>Specific annotations list</p></a></li>
<li><a href='#specific.annotation.matrix'><p>Specific annotation matrix</p></a></li>
<li><a href='#stratified.cross.validation'><p>Stratified cross validation</p></a></li>
<li><a href='#tpr.dag'><p>TPR-DAG ensemble variants</p></a></li>
<li><a href='#tpr.dag.cv'><p>TPR-DAG cross-validation experiments</p></a></li>
<li><a href='#tpr.dag.holdout'><p>TPR-DAG holdout experiments</p></a></li>
<li><a href='#transitive.closure.annotations'><p>Transitive closure of annotations</p></a></li>
<li><a href='#tupla.matrix'><p>Tupla matrix</p></a></li>
<li><a href='#unstratified.cv.data'><p>Unstratified cross validation</p></a></li>
<li><a href='#weighted.adjacency.matrix'><p>Weighted adjacency matrix</p></a></li>
<li><a href='#write.graph'><p>Write a directed graph on file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Hierarchical Ensemble Methods for Directed Acyclic Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Notaro <a href="https://orcid.org/0000-0003-4309-2200"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alessandro Petrini
    <a href="https://orcid.org/0000-0002-0587-1484"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Giorgio Valentini <a href="https://orcid.org/0000-0002-5694-3919"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Notaro &lt;marco.notaro@unimi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of several Hierarchical Ensemble Methods (HEMs) for Directed Acyclic Graphs (DAGs). 'HEMDAG' package: 1) reconciles flat predictions with the topology of the ontology; 2) can enhance the predictions of virtually any flat learning methods by taking into account the hierarchical relationships between ontology classes; 3) provides biologically meaningful predictions that always obey the true-path-rule, the biological and logical rule that governs the internal coherence of biomedical ontologies; 4) is specifically designed for exploiting the hierarchical relationships of DAG-structured taxonomies, such as the Human Phenotype Ontology (HPO) or the Gene Ontology (GO), but can be safely applied to tree-structured taxonomies as well (as FunCat), since trees are DAGs; 5) scales nicely both in terms of the complexity of the taxonomy and in the cardinality of the examples; 6) provides several utility functions to process and analyze graphs; 7) provides several performance metrics to evaluate HEMs algorithms. (Marco Notaro, Max Schubach, Peter N. Robinson and Giorgio Valentini (2017) &lt;<a href="https://doi.org/10.1186%2Fs12859-017-1854-y">doi:10.1186/s12859-017-1854-y</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hemdag.readthedocs.io">https://hemdag.readthedocs.io</a>
<a href="https://github.com/marconotaro/hemdag">https://github.com/marconotaro/hemdag</a>
<a href="https://anaconda.org/bioconda/r-hemdag">https://anaconda.org/bioconda/r-hemdag</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marconotaro/hemdag/issues">https://github.com/marconotaro/hemdag/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>graph, RBGL, precrec, preprocessCore, methods, plyr, foreach,
doParallel, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rgraphviz, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-12 14:19:11 UTC; marco</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-12 15:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HEMDAG-package'>HEMDAG: Hierarchical Ensemble Methods for Directed Acyclic Graphs</h2><span id='topic+HEMDAG-package'></span><span id='topic+HEMDAG'></span>

<h3>Description</h3>

<p>The HEMDAG package:
</p>

<ul>
<li><p> provides an implementation of several Hierarchical Ensemble Methods (HEMs) for Directed Acyclic Graphs (DAGs);
</p>
</li>
<li><p> reconciles flat predictions with the topology of the ontology;
</p>
</li>
<li><p> can enhance predictions of virtually any flat learning methods by taking into account the hierarchical relationships between ontology classes;
</p>
</li>
<li><p> provides biologically meaningful predictions that obey the true-path-rule, the biological and logical rule that governs the internal coherence of biomedical ontologies;
</p>
</li>
<li><p> is specifically designed for exploiting the hierarchical relationships of DAG-structured taxonomies, such as the Human Phenotype Ontology (HPO) or the Gene Ontology (GO), but can be safely applied to tree-structured taxonomies as well (as FunCat), since trees are DAGs;
</p>
</li>
<li><p> scales nicely both in terms of the complexity of the taxonomy and in the cardinality of the examples;
</p>
</li>
<li><p> provides several utility functions to process and analyze graphs;
</p>
</li>
<li><p> provides several performance metrics to evaluate HEMs algorithms;
</p>
</li></ul>

<p>A comprehensive tutorial showing how to apply HEMDAG to real case bio-medical case studies is available at <a href="https://hemdag.readthedocs.io">https://hemdag.readthedocs.io</a>.
</p>


<h3>Details</h3>

<p>The HEMDAG package implements the following Hierarchical Ensemble Methods for DAGs:
</p>

<ol>
<li> <p><b>HTD-DAG</b>: Hierarchical Top Down (<code><a href="#topic+htd">htd</a></code>);
</p>
</li>
<li> <p><b>GPAV-DAG</b>: Generalized Pool-Adjacent Violators, <cite>Burdakov et al.</cite> (<code><a href="#topic+gpav">gpav</a></code>);
</p>
</li>
<li> <p><b>TPR-DAG</b>: True-Path Rule (<code><a href="#topic+tpr.dag">tpr.dag</a></code>);
</p>
</li>
<li> <p><b>DESCENS</b>: Descendants Ensemble Classifier (<code><a href="#topic+tpr.dag">tpr.dag</a></code>);
</p>
</li>
<li> <p><b>ISO-TPR</b>: Isotonic-True-Path Rule (<code><a href="#topic+tpr.dag">tpr.dag</a></code>);
</p>
</li>
<li> <p><b>Max</b>, <b>And</b>, <b>Or</b>: Heuristic Methods, <cite>Obozinski et al.</cite> (<code><a href="#topic+obozinski.heuristic.methods">obozinski.heuristic.methods</a></code>);
</p>
</li></ol>


<h3>Author(s)</h3>

<p><em>Marco Notaro</em><code class="reqn">^1</code> (<a href="https://orcid.org/0000-0003-4309-2200">https://orcid.org/0000-0003-4309-2200</a>);<br />
<em>Alessandro Petrini</em><code class="reqn">^1</code> (<a href="https://orcid.org/0000-0002-0587-1484">https://orcid.org/0000-0002-0587-1484</a>);<br />
<em>Giorgio Valentini</em><code class="reqn">^1</code> (<a href="https://orcid.org/0000-0002-5694-3919">https://orcid.org/0000-0002-5694-3919</a>);<br />
</p>
<p>Maintainer:
<em>Marco Notaro</em>
<a href="mailto:marco.notaro@unimi.it">marco.notaro@unimi.it</a><br />
</p>
<p><code class="reqn">^1</code> <a href="https://sites.google.com/site/anacletolaboratory/">AnacletoLab</a>, Computational Biology and Bioinformatics Laboratory, Computer Science Department, University of Milan, Italy</p>


<h3>References</h3>

<p>Marco Notaro, Max Schubach, Peter N. Robinson and Giorgio Valentini,
<em>Prediction of Human Phenotype Ontology terms by means of Hierarchical Ensemble methods</em>,
BMC Bioinformatics 2017, 18(1):449, doi: <a href="https://doi.org/10.1186/s12859-017-1854-y">10.1186/s12859-017-1854-y</a>
</p>

<hr>
<h2 id='adj.upper.tri'>Binary upper triangular adjacency matrix</h2><span id='topic+adj.upper.tri'></span>

<h3>Description</h3>

<p>Compute a binary square upper triangular matrix where rows and columns correspond to the nodes' name of the graph <code>g</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.upper.tri(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj.upper.tri_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNELL</code> representing the hierarchy of the class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nodes of the matrix are topologically sorted (by using the <code>tsort</code> function of the <span class="pkg">RBGL</span> package).
Let's denote with <code>adj</code> our adjacency matrix. Then <code>adj</code> represents a partial order data set in which the class <code>j</code>
dominates the class <code>i</code>. In other words, <code>adj[i,j]=1</code> means that <code>j</code> dominates <code>i</code>; <code>adj[i,j]=0</code> means that there
is no edge between the class <code>i</code> and the class <code>j</code>. Moreover the nodes of <code>adj</code> are ordered such that <code>adj[i,j]=1</code>
implies <code class="reqn">i &lt; j</code>, i.e. <code>adj</code> is upper triangular.
</p>


<h3>Value</h3>

<p>An adjacency matrix which is square, logical and upper triangular.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
adj &lt;- adj.upper.tri(g);
</code></pre>

<hr>
<h2 id='auprc'>AUPRC measures</h2><span id='topic+auprc'></span><span id='topic+auprc.single.class'></span><span id='topic+auprc.single.over.classes'></span>

<h3>Description</h3>

<p>Compute the Area under the Precision Recall Curve (AUPRC) through <span class="pkg">precrec</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auprc.single.class(labels, scores, folds = NULL, seed = NULL)

auprc.single.over.classes(target, predicted, folds = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auprc_+3A_labels">labels</code></td>
<td>
<p>vector of the true labels (0 negative, 1 positive examples).</p>
</td></tr>
<tr><td><code id="auprc_+3A_scores">scores</code></td>
<td>
<p>a numeric vector of the values of the predicted labels (scores).</p>
</td></tr>
<tr><td><code id="auprc_+3A_folds">folds</code></td>
<td>
<p>number of folds on which computing the AUPRC. If <code>folds=NULL</code> (<code>def.</code>), the AUPRC is computed one-shot,
otherwise the AUPRC is computed averaged across folds.</p>
</td></tr>
<tr><td><code id="auprc_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds. Set <code>seed</code> only if <code>folds</code><code class="reqn">\neq</code><code>NULL</code>.
If <code>seed=NULL</code> and <code>folds</code><code class="reqn">\neq</code><code>NULL</code>, the AUPRC averaged across folds is computed without seed initialization.</p>
</td></tr>
<tr><td><code id="auprc_+3A_target">target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="auprc_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with predicted values (scores): rows correspond to examples and columns to classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AUPRC (for a single class or for a set of classes) is computed either one-shot or averaged across stratified folds.
</p>
<p><code>auprc.single.class</code> computes the AUPRC just for a given class.
</p>
<p><code>auprc.single.over.classes</code> computes the AUPRC for a set of classes, returning also the averaged values across the classes.
</p>
<p>For all those classes having zero annotations, the AUPRC is set to 0. These classes are discarded in the computing of the AUPRC
averaged across classes, both when the AUPRC is computed one-shot or averaged across stratified folds.
</p>
<p>Names of rows and columns of <code>labels</code> and <code>predicted</code> matrix must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p><code>auprc.single.class</code> returns a numeric value corresponding to the AUPRC for the considered class;
<code>auprc.single.over.classes</code> returns a list with two elements:
</p>

<ol>
<li><p> average: the average AUPRC across classes;
</p>
</li>
<li><p> per.class: a named vector with AUPRC for each class. Names correspond to classes.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
data(scores);
data(graph);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
prc.single.class &lt;- auprc.single.class(L[,3], S[,3], folds=5, seed=23);
prc.over.classes &lt;- auprc.single.over.classes(L, S, folds=5, seed=23);
</code></pre>

<hr>
<h2 id='auroc'>AUROC measures</h2><span id='topic+auroc'></span><span id='topic+auroc.single.class'></span><span id='topic+auroc.single.over.classes'></span>

<h3>Description</h3>

<p>Compute the Area under the ROC Curve (AUROC) through <span class="pkg">precrec</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auroc.single.class(labels, scores, folds = NULL, seed = NULL)

auroc.single.over.classes(target, predicted, folds = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auroc_+3A_labels">labels</code></td>
<td>
<p>vector of the true labels (0 negative, 1 positive examples).</p>
</td></tr>
<tr><td><code id="auroc_+3A_scores">scores</code></td>
<td>
<p>a numeric vector of the values of the predicted labels (scores).</p>
</td></tr>
<tr><td><code id="auroc_+3A_folds">folds</code></td>
<td>
<p>number of folds on which computing the AUROC. If <code>folds=NULL</code> (<code>def.</code>), the AUROC is computed one-shot,
otherwise the AUROC is computed averaged across folds.</p>
</td></tr>
<tr><td><code id="auroc_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds. Set <code>seed</code> only if <code>folds</code><code class="reqn">\neq</code><code>NULL</code>.
If <code>seed=NULL</code> and <code>folds</code><code class="reqn">\neq</code><code>NULL</code>, the AUROC averaged across folds is computed without seed initialization.</p>
</td></tr>
<tr><td><code id="auroc_+3A_target">target</code></td>
<td>
<p>annotation matrix: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="auroc_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with predicted values (scores): rows correspond to examples and columns to classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AUROC (for a single class or for a set of classes) is computed either one-shot or averaged across stratified folds.
</p>
<p><code>auroc.single.class</code> computes the AUROC just for a given class.
</p>
<p><code>auroc.single.over.classes</code> computes the AUROC for a set of classes, including their average values across all the classes.
</p>
<p>For all those classes having zero annotations, the AUROC is set to 0.5. These classes are included in the computing of the AUROC
averaged across classes, both when the AUROC is computed one-shot or averaged across stratified folds.
</p>
<p>The AUROC is set to 0.5 to all those classes having zero annotations.
Names of rows and columns of <code>labels</code> and <code>predicted</code> must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p><code>auroc.single.class</code> returns a numeric value corresponding to the AUROC for the considered class;
<code>auprc.single.over.classes</code> returns a list with two elements:
</p>

<ol>
<li><p> average: the average AUROC across classes;
</p>
</li>
<li><p> per.class: a named vector with AUROC for each class. Names correspond to classes.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
data(scores);
data(graph);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
auc.single.class &lt;- auroc.single.class(L[,3], S[,3], folds=5, seed=23);
auc.over.classes &lt;- auroc.single.over.classes(L, S, folds=5, seed=23);
</code></pre>

<hr>
<h2 id='build.ancestors'>Build ancestors</h2><span id='topic+build.ancestors'></span><span id='topic+build.ancestors.per.level'></span><span id='topic+build.ancestors.bottom.up'></span>

<h3>Description</h3>

<p>Build ancestors for each node of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.ancestors(g)

build.ancestors.per.level(g, levels)

build.ancestors.bottom.up(g, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.ancestors_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="build.ancestors_+3A_levels">levels</code></td>
<td>
<p>a list of character vectors. Each component represents a graph level and the elements of any component correspond to nodes.
The level 0 coincides with the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build.ancestos</code> returns a named list of vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph and its vector
is the set of its ancestors including also <code class="reqn">x</code>.
</p>
<p><code>build.ancestors.per.level</code> returns a named list of vectors. Each component corresponds to a node <code class="reqn">x</code>
of the graph and its vector is the set of its ancestors including also <code class="reqn">x</code>. The nodes are ordered from root (included) to leaves.
</p>
<p><code>build.ancestors.bottom.up</code> a named list of vectors. Each component corresponds to a node <code class="reqn">x</code> of the
graph and its vector is the set of its ancestors including also <code class="reqn">x</code>. The nodes are ordered from leaves to root (included).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
anc &lt;- build.ancestors(g);
lev &lt;- graph.levels(g, root=root);
anc.tod &lt;-build.ancestors.per.level(g,lev);
anc.bup &lt;- build.ancestors.bottom.up(g,lev);
</code></pre>

<hr>
<h2 id='build.children'>Build children</h2><span id='topic+build.children'></span><span id='topic+build.children.top.down'></span><span id='topic+build.children.bottom.up'></span>

<h3>Description</h3>

<p>Build children for each node of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.children(g)

build.children.top.down(g, levels)

build.children.bottom.up(g, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.children_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="build.children_+3A_levels">levels</code></td>
<td>
<p>a list of character vectors. Each component represents a graph level and the elements of any
component correspond to nodes. The level 0 coincides with the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build.children</code> returns a named list of vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph and its vector
is the set of its children.
</p>
<p><code>build.children.top.down</code> returns a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code>
of the graph (i.e. parent node) and its vector is the set of its children. The nodes are ordered from root (included) to leaves.
</p>
<p><code>build.children.bottom.up</code> returns a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code>
of the graph (i.e. parent node) and its vector is the set of its children. The nodes are ordered from leaves (included) to root.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
children &lt;- build.children(g);
lev &lt;- graph.levels(g, root=root);
children.tod &lt;- build.children.top.down(g,lev);
children.bup &lt;- build.children.bottom.up(g,lev);
</code></pre>

<hr>
<h2 id='build.consistent.graph'>Build consistent graph</h2><span id='topic+build.consistent.graph'></span>

<h3>Description</h3>

<p>Build a graph in which all nodes are reachable from root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.consistent.graph(g = g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.consistent.graph_+3A_g">g</code></td>
<td>
<p>an object of class <code>graphNEL</code>.</p>
</td></tr>
<tr><td><code id="build.consistent.graph_+3A_root">root</code></td>
<td>
<p>name of the class that is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All nodes not accessible from root (if any) are removed from the graph and printed on stdout.
</p>


<h3>Value</h3>

<p>A graph (as an object of class <code>graphNEL</code>) in which all nodes are accessible from root.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
G &lt;- graph::addNode(c("X","Y","Z"), g);
G &lt;- graph::addEdge(c("X","Y","Z"), c("HP:0011844","HP:0009810","HP:0012385"), G);
G &lt;- build.consistent.graph(G, root=root);
</code></pre>

<hr>
<h2 id='build.descendants'>Build descendants</h2><span id='topic+build.descendants'></span><span id='topic+build.descendants.per.level'></span><span id='topic+build.descendants.bottom.up'></span>

<h3>Description</h3>

<p>Build descendants for each node of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.descendants(g)

build.descendants.per.level(g, levels)

build.descendants.bottom.up(g, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.descendants_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="build.descendants_+3A_levels">levels</code></td>
<td>
<p>a list of character vectors. Each component represents a graph level and the elements of any component correspond to nodes.
The level 0 coincides with the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build.descendants</code> returns a named list of vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph, and its vector
is the set of its descendants including also <code class="reqn">x</code>.
</p>
<p><code>build.descendants.per.level</code> returns a named list of vectors.
Each component corresponds to a node <code class="reqn">x</code> of the graph and its vector is the set of its descendants including also <code class="reqn">x</code>.
The nodes are ordered from root (included) to leaves.
</p>
<p><code>build.descendants.bottom.up</code> returns a named list of vectors. Each component corresponds to a node <code class="reqn">x</code> of
the graph and its vector is the set of its descendants including also <code class="reqn">x</code>. The nodes are ordered from leaves to root (included).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
desc &lt;- build.descendants(g);
lev &lt;- graph.levels(g, root=root);
desc.tod &lt;- build.descendants.per.level(g,lev);
desc.bup &lt;- build.descendants.bottom.up(g,lev);
</code></pre>

<hr>
<h2 id='build.edges.from.hpo.obo'>Parse an HPO obo file</h2><span id='topic+build.edges.from.hpo.obo'></span>

<h3>Description</h3>

<p>Read an HPO obo file (<a href="http://human-phenotype-ontology.github.io/">HPO</a>) and write the edges of the dag on a plain text file.
The format of the file is a sequence of rows and each row corresponds to an edge represented through a pair of vertexes separated by blank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.edges.from.hpo.obo(obofile = "hp.obo", file = "edge.file")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.edges.from.hpo.obo_+3A_obofile">obofile</code></td>
<td>
<p>an HPO obo file. The extension of the obofile can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
<tr><td><code id="build.edges.from.hpo.obo_+3A_file">file</code></td>
<td>
<p>name of the file of the edges to be written. The extension of the file can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A faster and more flexible parser to handle <em>obo</em> file can be found <a href="https://github.com/marconotaro/obogaf-parser">here</a>.
</p>


<h3>Value</h3>

<p>A text file representing the edges in the format: source  destination (i.e. one row for each edge).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hpobo &lt;- "http://purl.obolibrary.org/obo/hp.obo";
build.edges.from.hpo.obo(obofile=hpobo, file="hp.edge");
## End(Not run)
</code></pre>

<hr>
<h2 id='build.parents'>Build parents</h2><span id='topic+build.parents'></span><span id='topic+build.parents.top.down'></span><span id='topic+build.parents.bottom.up'></span><span id='topic+build.parents.topological.sorting'></span>

<h3>Description</h3>

<p>Build parents for each node of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.parents(g, root = "00")

build.parents.top.down(g, levels, root = "00")

build.parents.bottom.up(g, levels, root = "00")

build.parents.topological.sorting(g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.parents_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="build.parents_+3A_root">root</code></td>
<td>
<p>name of the class that it is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
<tr><td><code id="build.parents_+3A_levels">levels</code></td>
<td>
<p>a list of character vectors. Each component represents a graph level and the elements of any component correspond to nodes.
The level 0 represents the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build.parents</code> returns a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph (i.e. child node)
and its vector is the set of its parents (the root node is not included).
</p>
<p><code>build.parents.top.down</code> returns a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph (i.e. child node)
and its vector is the set of its parents. The order of nodes follows the levels of the graph from root (excluded) to leaves.
</p>
<p><code>build.parents.bottom.up</code> returns a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code> of the
graph (i.e. child node) and its vector is the set of its parents. The nodes are ordered from leaves to root (excluded).
</p>
<p><code>build.parents.topological.sorting</code> a named list of character vectors. Each component corresponds to a node <code class="reqn">x</code> of the graph (i.e. child node)
and its vector is the set of its parents. The nodes are ordered according to a topological sorting, i.e. parents node come before children node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g)
parents &lt;- build.parents(g, root=root);
lev &lt;- graph.levels(g, root=root);
parents.tod &lt;- build.parents.top.down(g, lev, root=root);
parents.bup &lt;- build.parents.bottom.up(g, lev, root=root);
parents.tsort &lt;- build.parents.topological.sorting(g, root=root);
</code></pre>

<hr>
<h2 id='build.scores.matrix'>Build scores matrix</h2><span id='topic+build.scores.matrix'></span><span id='topic+build.scores.matrix.from.list'></span><span id='topic+build.scores.matrix.from.tupla'></span>

<h3>Description</h3>

<p>Build a scores matrix from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.scores.matrix.from.list(file = "scores.list.txt", split = "[(\t,|)]")

build.scores.matrix.from.tupla(file = "scores.tupla.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.scores.matrix_+3A_file">file</code></td>
<td>
<p>name of the text file to be read. The matrix of the input file can be either a list (e.g in the form <code>example nodeX|score</code>),
or a tupla (i.e. in the form <code>example nodeX score</code>).The file extension can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
<tr><td><code id="build.scores.matrix_+3A_split">split</code></td>
<td>
<p>character vector containing a regular expression use for splitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named scores matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file.list  &lt;- system.file("extdata/scores.list.txt.gz", package="HEMDAG");
file.tupla &lt;- system.file("extdata/scores.tupla.txt.gz", package="HEMDAG");
S &lt;- build.scores.matrix.from.list(file.list, split="[(\t,|)]");
S &lt;- build.scores.matrix.from.tupla(file.tupla);
</code></pre>

<hr>
<h2 id='build.subgraph'>Build subgraph</h2><span id='topic+build.subgraph'></span>

<h3>Description</h3>

<p>Build a subgraph with only the supplied nodes and any edges between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.subgraph(nd, g, edgemode = "directed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.subgraph_+3A_nd">nd</code></td>
<td>
<p>a vector with the nodes for which the subgraph must be built.</p>
</td></tr>
<tr><td><code id="build.subgraph_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="build.subgraph_+3A_edgemode">edgemode</code></td>
<td>
<p>can be &quot;directed&quot; or &quot;undirected&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subgraph with only the supplied nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
anc &lt;- build.ancestors(g);
nd &lt;- anc[["HP:0001371"]];
subg &lt;- build.subgraph(nd, g, edgemode="directed");
</code></pre>

<hr>
<h2 id='build.submatrix'>Build submatrix</h2><span id='topic+build.submatrix'></span>

<h3>Description</h3>

<p>Terms having less than n annotations are pruned. Terms having exactly n annotations are discarded as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.submatrix(ann, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.submatrix_+3A_ann">ann</code></td>
<td>
<p>the annotation matrix (0/1). Rows are examples and columns are functional terms.</p>
</td></tr>
<tr><td><code id="build.submatrix_+3A_n">n</code></td>
<td>
<p>an integer number representing the number of annotations to be pruned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An annotation matrix having only those terms with more than n annotations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
subm &lt;- build.submatrix(L,5);
</code></pre>

<hr>
<h2 id='check.annotation.matrix.integrity'>Annotation matrix checker</h2><span id='topic+check.annotation.matrix.integrity'></span>

<h3>Description</h3>

<p>Assess the integrity of an annotation matrix where a transitive closure of annotations was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.annotation.matrix.integrity(anc, ann.spec, ann)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.annotation.matrix.integrity_+3A_anc">anc</code></td>
<td>
<p>the ancestor list.</p>
</td></tr>
<tr><td><code id="check.annotation.matrix.integrity_+3A_ann.spec">ann.spec</code></td>
<td>
<p>the annotation matrix of the most specific annotations (0/1): rows are genes and columns are terms.</p>
</td></tr>
<tr><td><code id="check.annotation.matrix.integrity_+3A_ann">ann</code></td>
<td>
<p>the full annotation matrix (0/1), i.e. the matrix where the transitive closure of the annotation was performed.
Rows are examples and columns are terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the transitive closure of the annotations is performed correctly, <code>OK</code> is returned, otherwise an error message is printed on the stdout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(labels);
anc &lt;- build.ancestors(g);
tca &lt;- transitive.closure.annotations(L, anc);
check.annotation.matrix.integrity(anc, L, tca);
</code></pre>

<hr>
<h2 id='check.dag.integrity'>DAG checker</h2><span id='topic+check.dag.integrity'></span>

<h3>Description</h3>

<p>Check the integrity of a dag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.dag.integrity(g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.dag.integrity_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="check.dag.integrity_+3A_root">root</code></td>
<td>
<p>name of the class that is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all the nodes are accessible from the root &quot;dag is ok&quot; is printed, otherwise a message error and the list of
the not accessible nodes is printed on the stdout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
check.dag.integrity(g, root=root);
</code></pre>

<hr>
<h2 id='compute.flipped.graph'>Flip graph</h2><span id='topic+compute.flipped.graph'></span>

<h3>Description</h3>

<p>Compute a directed graph with edges in the opposite direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.flipped.graph(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.flipped.graph_+3A_g">g</code></td>
<td>
<p>a <code>graphNEL</code> directed graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph (as an object of class <code>graphNEL</code>) with edges in the opposite direction w.r.t. <code>g</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
g.flipped &lt;- compute.flipped.graph(g);
</code></pre>

<hr>
<h2 id='constraints.matrix'>Constraints matrix</h2><span id='topic+constraints.matrix'></span>

<h3>Description</h3>

<p>Return a matrix with two columns and as many rows as there are edges. The entries of the first columns are the index of the node the edge
comes from (i.e. children nodes), the entries of the second columns indicate the index of node the edge is to (i.e. parents nodes).
Referring to a dag this matrix defines a partial order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.matrix(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.matrix_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNELL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A constraints matrix w.r.t the graph <code>g</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
m &lt;- constraints.matrix(g);
</code></pre>

<hr>
<h2 id='create.stratified.fold.df'>DataFrame for stratified cross validation</h2><span id='topic+create.stratified.fold.df'></span>

<h3>Description</h3>

<p>Create a data frame for stratified cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.stratified.fold.df(labels, scores, folds = 5, seed = 23)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.stratified.fold.df_+3A_labels">labels</code></td>
<td>
<p>vector of the true labels (0 negative, 1 positive).</p>
</td></tr>
<tr><td><code id="create.stratified.fold.df_+3A_scores">scores</code></td>
<td>
<p>a numeric vector of the values of the predicted labels.</p>
</td></tr>
<tr><td><code id="create.stratified.fold.df_+3A_folds">folds</code></td>
<td>
<p>number of folds of the cross validation (<code>def. folds=5</code>).</p>
</td></tr>
<tr><td><code id="create.stratified.fold.df_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds (<code>def. seed=23</code>).
If <code>seed=NULL</code>, the stratified folds are generated without seed initialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Folds are <em>stratified</em>, i.e. contain the same amount of positive and negative examples.
</p>


<h3>Value</h3>

<p>A data frame with three columns:
</p>

<ul>
<li> <p><code>scores</code>: contains the predicted scores;
</p>
</li>
<li> <p><code>labels</code>: contains the labels as <code>pos</code> or <code>neg</code>;
</p>
</li>
<li> <p><code>folds</code>: contains the index of the fold in which the example falls.
The index can range from 1 to the number of folds.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
data(scores);
df &lt;- create.stratified.fold.df(L[,3], S[,3], folds=5, seed=23);
</code></pre>

<hr>
<h2 id='distances.from.leaves'>Distances from leaves</h2><span id='topic+distances.from.leaves'></span>

<h3>Description</h3>

<p>Compute the minimum distance of each node from one of the leaves of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distances.from.leaves(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances.from.leaves_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector. The names are the names of the nodes of the graph <code>g</code>, and their values represent the distance from the leaves.
A value equal to 0 is assigned to the leaves, 1 to nodes with distance 1 from a leaf and so on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
dist.leaves &lt;- distances.from.leaves(g);
</code></pre>

<hr>
<h2 id='example.datasets'>Small real example datasets</h2><span id='topic+example.datasets'></span><span id='topic+g'></span><span id='topic+L'></span><span id='topic+S'></span><span id='topic+W'></span><span id='topic+test.index'></span>

<h3>Description</h3>

<p>Collection of real sub-datasets used in the examples of the <span class="pkg">HEMDAG</span> package</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graph)
data(labels)
data(scores)
data(wadj)
data(test.index)
</code></pre>


<h3>Details</h3>

<p>The DAG <code>g</code> contained in <code>graph</code> data is an object of class <code>graphNEL</code>. The graph <code>g</code> has 23 nodes and 30 edges and
represents the &quot;ancestors view&quot; of the HPO term <em>Camptodactyly of finger</em> (<code>"HP:0100490"</code>).
</p>
<p>The matrix <code>L</code> contained in the <code>labels</code> data is a 100 X 23 matrix, whose rows correspond to genes
(<em>Entrez GeneID</em>) and columns to HPO classes.
<code class="reqn">L[i,j]=1</code> means that the gene <code class="reqn">i</code> belong to class <code class="reqn">j</code>, <code class="reqn">L[i,j]=0</code> means that the gene <code class="reqn">i</code> does not belong to class <code class="reqn">j</code>.
The classes of the matrix <code>L</code> correspond to the nodes of the graph <code>g</code>.
</p>
<p>The matrix <code>S</code> contained in the <code>scores</code> data is a named 100 X 23 flat scores matrix, representing the likelihood
that a given gene belongs to a given class: higher the value higher the likelihood. The classes of the matrix <code class="reqn">S</code> correspond
to the nodes of the graph <code>g</code>.
</p>
<p>The matrix <code>W</code> contained in the <code>wadj</code> data is a named 100 X 100 symmetric weighted adjacency matrix, whose rows and
columns correspond to genes.The genes names (<em>Entrez GeneID</em>) of the adjacency matrix <code>W</code> correspond to the genes names of the
flat scores matrix <code>S</code> and to genes names of the target multilabel matrix <code>L</code>.
</p>
<p>The vector of integer numbers <code>test.index</code> contained in the <code>test.index</code> data refers to the index of the examples of the scores
matrix <code>S</code> to be used in the test set. It is useful only in holdout experiments.
</p>


<h3>Note</h3>

<p>Some examples of full data sets for the prediction of HPO terms are available at the following <a href="https://homes.di.unimi.it/notaro/DATA/DATA_BMC/">link</a>.
Note that the processing of the full datasets should be done similarly to the processing of the small data examples provided directly in this package.
Please read the <code>README</code> clicking the link above to know more details about the available full datasets.
</p>

<hr>
<h2 id='find.best.f'>Best hierarchical F-score</h2><span id='topic+find.best.f'></span>

<h3>Description</h3>

<p>Select the best hierarchical F-score by choosing an appropriate threshold in the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.best.f(
  target,
  predicted,
  n.round = 3,
  verbose = TRUE,
  b.per.example = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.best.f_+3A_target">target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="find.best.f_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with continuous predicted values (scores): rows correspond to examples and columns to classes.</p>
</td></tr>
<tr><td><code id="find.best.f_+3A_n.round">n.round</code></td>
<td>
<p>number of rounding digits to be applied to predicted (<code>default=3</code>).</p>
</td></tr>
<tr><td><code id="find.best.f_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value. If <code>TRUE</code> (def.) the number of iterations are printed on stdout.</p>
</td></tr>
<tr><td><code id="find.best.f_+3A_b.per.example">b.per.example</code></td>
<td>
<p>a boolean value.
</p>

<ul>
<li> <p><code>TRUE</code>: results are returned for each example;
</p>
</li>
<li> <p><code>FALSE</code>: only the average results are returned;
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>All the examples having no positive annotations are discarded. The predicted scores matrix (<code>predicted</code>) is rounded
according to parameter <code>n.round</code> and all the values of <code>predicted</code> are divided by <code>max(predicted)</code>.
Then all the thresholds corresponding to all the different values included in <code>predicted</code> are attempted, and the threshold
leading to the maximum F-measure is selected.
</p>
<p>Names of rows and columns of <code>target</code> and <code>predicted</code> matrix must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p>Two different outputs respect to the input parameter <code>b.per.example</code>:
</p>

<ul>
<li> <p><code>b.per.example==FALSE</code>: a list with a single element average. A named vector with 7 elements relative to the best result in terms
of the F.measure: Precision (P), Recall (R), Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T).
F is the F-measure computed as the harmonic mean between the average precision and recall; av.F is the F-measure computed as the average across
examples and T is the best selected threshold;
</p>
</li>
<li> <p><code>b.per.example==FALSE</code>: a list with two elements:
</p>

<ol>
<li><p> average: a named vector with with 7 elements relative to the best result in terms of the F.measure: Precision (P), Recall (R),
Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T);
</p>
</li>
<li><p> per.example: a named matrix with the Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F)
and the best selected Threshold (T) for each example. Row names correspond to examples, column names correspond respectively
to Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F) and the best selected Threshold (T);
</p>
</li></ol>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(labels);
data(scores);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
fscore &lt;- find.best.f(L, S, n.round=3, verbose=TRUE, b.per.example=TRUE);
</code></pre>

<hr>
<h2 id='find.leaves'>Leaves</h2><span id='topic+find.leaves'></span>

<h3>Description</h3>

<p>Find leaves of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.leaves(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.leaves_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the names of the leaves of g.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
leaves &lt;- find.leaves(g);
</code></pre>

<hr>
<h2 id='fmax'>Compute Fmax</h2><span id='topic+fmax'></span><span id='topic+compute.fmax'></span>

<h3>Description</h3>

<p>Compute the best hierarchical Fmax either one-shot or averaged across folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.fmax(
  target,
  predicted,
  n.round = 3,
  verbose = TRUE,
  b.per.example = FALSE,
  folds = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmax_+3A_target">target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="fmax_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with predicted values (scores): rows correspond to examples and columns to classes.</p>
</td></tr>
<tr><td><code id="fmax_+3A_n.round">n.round</code></td>
<td>
<p>number of rounding digits to be applied to predicted (<code>default=3</code>).</p>
</td></tr>
<tr><td><code id="fmax_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value. If <code>TRUE</code> (def.) the number of iterations are printed on stdout.</p>
</td></tr>
<tr><td><code id="fmax_+3A_b.per.example">b.per.example</code></td>
<td>
<p>a boolean value.
</p>

<ul>
<li> <p><code>TRUE</code>: results are returned for each example;
</p>
</li>
<li> <p><code>FALSE</code>: only the average results are returned;
</p>
</li></ul>
</td></tr>
<tr><td><code id="fmax_+3A_folds">folds</code></td>
<td>
<p>number of folds on which computing the Fmax If <code>folds=NULL</code> (<code>def.</code>), the Fmax is computed one-shot,
otherwise the Fmax is computed averaged across folds.</p>
</td></tr>
<tr><td><code id="fmax_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds. Set <code>seed</code> only if <code>folds</code><code class="reqn">\neq</code><code>NULL</code>.
If <code>seed=NULL</code> and <code>folds</code><code class="reqn">\neq</code><code>NULL</code>, the Fmax averaged across folds is computed without seed initialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names of rows and columns of <code>target</code> and <code>predicted</code> matrix must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p>Two different outputs respect to the input parameter <code>b.per.example</code>:
</p>

<ul>
<li> <p><code>b.per.example==FALSE</code>: a list with a single element average. A named vector with 7 elements relative to the best result in terms
of the F.measure: Precision (P), Recall (R), Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T).
F is the F-measure computed as the harmonic mean between the average precision and recall; av.F is the F-measure computed as the average across
examples and T is the best selected threshold;
</p>
</li>
<li> <p><code>b.per.example==FALSE</code>: a list with two elements:
</p>

<ol>
<li><p> average: a named vector with with 7 elements relative to the best result in terms of the F.measure: Precision (P), Recall (R),
Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T);
</p>
</li>
<li><p> per.example: a named matrix with the Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F)
and the best selected Threshold (T) for each example. Row names correspond to examples, column names correspond respectively
to Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F) and the best selected Threshold (T);
</p>
</li></ol>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(labels);
data(scores);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
fmax &lt;- compute.fmax(L, S, n.round=3, verbose=TRUE, b.per.example=TRUE, folds=5, seed=23);
</code></pre>

<hr>
<h2 id='full.annotation.matrix'>Full annotation matrix</h2><span id='topic+full.annotation.matrix'></span>

<h3>Description</h3>

<p>Build a full annotations matrix using the ancestor list and the most specific annotations matrix w.r.t. a given weighted adjacency matrix (wadj).
The rows of the full annotation matrix correspond to all the examples of the given weighted adjacency matrix and the columns to the class/terms.
The transitive closure of the annotations is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full.annotation.matrix(W, anc, ann.spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full.annotation.matrix_+3A_w">W</code></td>
<td>
<p>a symmetric adjacency weighted matrix of the graph.</p>
</td></tr>
<tr><td><code id="full.annotation.matrix_+3A_anc">anc</code></td>
<td>
<p>the ancestor list.</p>
</td></tr>
<tr><td><code id="full.annotation.matrix_+3A_ann.spec">ann.spec</code></td>
<td>
<p>the annotation matrix of the most specific annotations (0/1): rows are genes and columns are terms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The examples present in the annotation matrix (<code>ann.spec</code>) but not in the adjacency weighted matrix (<code>W</code>) are purged.
</p>


<h3>Value</h3>

<p>A full annotation table T, that is a matrix where the transitive closure of annotations is performed.
Rows correspond to genes of the weighted adjacency matrix and columns to terms.
<code class="reqn">T[i,j]=1</code> means that gene <code class="reqn">i</code> is annotated for the term <code class="reqn">j</code>, <code class="reqn">T[i,j]=0</code> means that gene <code class="reqn">i</code> is not annotated for the term <code class="reqn">j</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wadj);
data(graph);
data(labels);
anc &lt;- build.ancestors(g);
full.ann &lt;- full.annotation.matrix(W, anc, L);
</code></pre>

<hr>
<h2 id='gpav'>Generalized Pool-Adjacent Violators (GPAV)</h2><span id='topic+gpav'></span>

<h3>Description</h3>

<p>Implementation of <code>GPAV</code> (Generalized Pool-Adjacent Violators) algorithm.
(<cite>Burdakov et al., In: Di Pillo G, Roma M, editors. An O(n2) Algorithm for Isotonic Regression. Boston, MA: Springer US; 2006.
p. 25–33. Available from: doi: <a href="https://doi.org/10.1007/0-387-30065-1_3">10.1007/0-387-30065-1_3</a></cite>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpav(Y, W = NULL, adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpav_+3A_y">Y</code></td>
<td>
<p>vector of scores relative to a single example. <code>Y</code> must be a numeric named vector, where names
correspond to classes' names, i.e. nodes of the graph <code>g</code> (root node included).</p>
</td></tr>
<tr><td><code id="gpav_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that
<code>W</code> is a unitary vector of the same length of the columns' number of the matrix <code>S</code> (root node included).</p>
</td></tr>
<tr><td><code id="gpav_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix of the graph which must be sparse, logical and upper triangular. Number of columns of <code>adj</code> must be
equal to the length of <code>Y</code> and <code>W</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the constraints adjacency matrix of the graph, a vector of scores <code class="reqn">\hat{y} \in R^n</code> and a vector of strictly positive
weights <code class="reqn">w \in R^n</code>, the <code>GPAV</code> algorithm returns a vector <code class="reqn">\bar{y}</code> which is as close as possible, in the least-squares sense,
to the response vector <code class="reqn">\hat{y}</code> and whose components are partially ordered in accordance with the constraints matrix <code>adj</code>.
In other words, <code>GPAV</code> solves the following problem:
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{y} = \left\{
  \begin{array}{l}
   \min \sum_{i \in V} (\hat{y}_i - \bar{y}_i )^2\\\\
   \forall i, \quad  j \in par(i) \Rightarrow  \bar{y}_j  \geq \bar{y}_i
  \end{array}
\right.
</code>
</p>

<p>where <code class="reqn">V</code> are the number of vertexes of the graph.
</p>


<h3>Value</h3>

<p>A list of 3 elements:
</p>

<ul>
<li> <p><code>YFit</code>: a named vector with the scores of the classes corrected according to the <code>GPAV</code> algorithm.
</p>
</li>
<li> <p><code>blocks</code>: list of vectors, containing the partitioning of nodes (represented with an integer number) into blocks;
</p>
</li>
<li> <p><code>W</code>: vector of weights.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
Y &lt;- S[3,];
adj &lt;- adj.upper.tri(g);
Y.gpav &lt;- gpav(Y,W=NULL,adj);
</code></pre>

<hr>
<h2 id='gpav.holdout'>GPAV holdout</h2><span id='topic+gpav.holdout'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the <code>GPAV</code> algorithm by applying a classical holdout procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpav.holdout(
  S,
  g,
  testIndex,
  W = NULL,
  parallel = FALSE,
  ncores = 1,
  norm = TRUE,
  norm.type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpav.holdout_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns (root node included).</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_testindex">testIndex</code></td>
<td>
<p>a vector of integer numbers corresponding to the indexes of the elements (rows) of the scores matrix <code>S</code> to be used in the test set.</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that
<code>W</code> is a unitary vector of the same length of the columns' number of the matrix <code>S</code> (root node included).</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value. Should the parallel version <code>GPAV</code> be run?
</p>

<ul>
<li> <p><code>TRUE</code>: execute the parallel implementation of <code>GPAV</code> (<code><a href="#topic+gpav.parallel">gpav.parallel</a></code>);
</p>
</li>
<li> <p><code>FALSE</code> (<code>def.</code>): execute the sequential implementation of <code>GPAV</code> (<code><a href="#topic+gpav.over.examples">gpav.over.examples</a></code>);
</p>
</li></ul>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution. Set <code>ncores=1</code> if <code>parallel=FALSE</code>,
otherwise set <code>ncores</code> to the desired number of cores.</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="gpav.holdout_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the <code>GPAV</code> algorithm. Rows of the matrix are shrunk to <code>testIndex</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(test.index);
S.gpav &lt;- gpav.holdout(S, g, testIndex=test.index, norm=FALSE, norm.type=NULL);
</code></pre>

<hr>
<h2 id='gpav.over.examples'>GPAV over examples</h2><span id='topic+gpav.over.examples'></span>

<h3>Description</h3>

<p>Compute <code>GPAV</code> across all the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpav.over.examples(S, g, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpav.over.examples_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns (root node included).</p>
</td></tr>
<tr><td><code id="gpav.over.examples_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="gpav.over.examples_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that
<code>W</code> is a unitary vector of the same length of the columns' number of the matrix <code>S</code> (root node included).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the <code>GPAV</code> algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpav.parallel">gpav.parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
S.gpav &lt;- gpav.over.examples(S,W=NULL,g);
</code></pre>

<hr>
<h2 id='gpav.parallel'>GPAV over examples &ndash; parallel implementation</h2><span id='topic+gpav.parallel'></span>

<h3>Description</h3>

<p>Compute <code>GPAV</code> across all the examples (parallel implementation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpav.parallel(S, g, W = NULL, ncores = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpav.parallel_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns (root node included).</p>
</td></tr>
<tr><td><code id="gpav.parallel_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="gpav.parallel_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that
<code>W</code> is a unitary vector of the same length of the columns' number of the matrix <code>S</code> (root node included).</p>
</td></tr>
<tr><td><code id="gpav.parallel_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution (<code>def. 8</code>).
If <code>ncores=0</code>, the maximum number of cores minus one are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the <code>GPAV</code> algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
if(Sys.info()['sysname']!="Windows"){
   S.gpav &lt;- gpav.parallel(S,W=NULL,g,ncores=2);
}
</code></pre>

<hr>
<h2 id='gpav.vanilla'>GPAV vanilla</h2><span id='topic+gpav.vanilla'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the <code>GPAV</code> algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpav.vanilla(
  S,
  g,
  W = NULL,
  parallel = FALSE,
  ncores = 1,
  norm = FALSE,
  norm.type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpav.vanilla_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns (root node included).</p>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that
<code>W</code> is a unitary vector of the same length of the columns' number of the matrix <code>S</code> (root node included).</p>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value. Should the parallel version <code>GPAV</code> be run?
</p>

<ul>
<li> <p><code>TRUE</code>: execute the parallel implementation of <code>GPAV</code> (<code><a href="#topic+gpav.parallel">gpav.parallel</a></code>);
</p>
</li>
<li> <p><code>FALSE</code> (<code>def.</code>): execute the sequential implementation of <code>GPAV</code> (<code><a href="#topic+gpav.over.examples">gpav.over.examples</a></code>);
</p>
</li></ul>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution. Set <code>ncores=1</code> if <code>parallel=FALSE</code>,
otherwise set <code>ncores</code> to the desired number of cores.</p>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="gpav.vanilla_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the <code>GPAV</code> algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
S.gpav &lt;- gpav.vanilla(S, g, W=NULL, parallel=FALSE, ncores=1, norm=FALSE, norm.type=NULL);
</code></pre>

<hr>
<h2 id='graph.levels'>Build graph levels</h2><span id='topic+graph.levels'></span>

<h3>Description</h3>

<p>Group a set of nodes in according to their maximum depth in the graph. Firstly, it inverts the weights
of the graph and then it applies the Bellman Ford algorithm to find the shortest path, achieving in this way the longest path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.levels(g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.levels_+3A_g">g</code></td>
<td>
<p>an object of class <code>graphNEL</code>.</p>
</td></tr>
<tr><td><code id="graph.levels_+3A_root">root</code></td>
<td>
<p>name of the class that it is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the nodes grouped w.r.t. the distance from the root: the first element of the list corresponds to the root node (level 0),
the second to nodes at maximum distance 1 (level 1), the third to the node at maximum distance 3 (level 2) and so on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
lev &lt;- graph.levels(g, root=root);
</code></pre>

<hr>
<h2 id='hierarchical.checkers'>Hierarchical constraints checker</h2><span id='topic+hierarchical.checkers'></span><span id='topic+check.hierarchy.single.sample'></span><span id='topic+check.hierarchy'></span>

<h3>Description</h3>

<p>Check if the true path rule is violated or not. In other words this function checks if the score of a parent or an ancestor node is
always larger or equal than that of its children or descendants nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.hierarchy.single.sample(y.hier, g, root = "00")

check.hierarchy(S.hier, g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchical.checkers_+3A_y.hier">y.hier</code></td>
<td>
<p>vector of scores relative to a single example. It must be a named numeric vector (names are functional classes).</p>
</td></tr>
<tr><td><code id="hierarchical.checkers_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="hierarchical.checkers_+3A_root">root</code></td>
<td>
<p>name of the class that is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
<tr><td><code id="hierarchical.checkers_+3A_s.hier">S.hier</code></td>
<td>
<p>the matrix with the scores of the classes corrected in according to hierarchy. It must be a named matrix: rows are examples and
columns are functional classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements:
</p>

<ul>
<li><p> status:
</p>

<ul>
<li> <p><code>OK</code> if none hierarchical constraints have bee broken;
</p>
</li>
<li> <p><code>NOTOK</code> if there is at least one hierarchical constraints broken;
</p>
</li></ul>

</li>
<li><p> hierarchy_constraints_broken:
</p>

<ul>
<li><p> TRUE: example did not respect the hierarchical constraints;
</p>
</li>
<li><p> FALSE: example broke the hierarchical constraints;
</p>
</li></ul>

</li>
<li><p> hierarchy_constraints_satisfied: how many terms satisfied the hierarchical constraint;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
root &lt;- root.node(g);
S.hier &lt;- htd(S,g,root);
S.hier.single.example &lt;- S.hier[sample(ncol(S.hier),1),];
check.hierarchy.single.sample(S.hier.single.example, g, root=root);
check.hierarchy(S.hier, g, root);
</code></pre>

<hr>
<h2 id='htd'>HTD-DAG</h2><span id='topic+htd'></span>

<h3>Description</h3>

<p>Implementation of the top-down procedure to correct the scores of the hierarchy according to the constraints that the score of a
node cannot be greater than a score of its parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htd(S, g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htd_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="htd_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="htd_+3A_root">root</code></td>
<td>
<p>name of the class that it is the top-level of the hierarchy (<code>def:00</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>HTD-DAG</code> algorithm modifies the flat scores according to the hierarchy of a DAG <code class="reqn">G</code> through a unique run across
the nodes of the graph. For a given example <code class="reqn">x</code>, the flat predictions <code class="reqn">f(x) = \hat{y}</code> are hierarchically corrected to
<code class="reqn">\bar{y}</code>, by per-level visiting the nodes of the DAG from top to bottom according to the following simple rule:
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{y}_i := \left\{
  \begin{array}{lll}
   \hat{y}_i  &amp; {\rm if} \quad i \in root(G) \\
   \min_{j \in par(i)} \bar{y}_j &amp; {\rm if} \quad \min_{j \in par(i)} \bar{y}_j &lt; \hat{y}_i \\
   \hat{y}_i &amp; {\rm otherwise}
  \end{array}
 \right.
</code>
</p>

<p>The node levels correspond to their maximum path length from the root.
</p>


<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the <code>HTD-DAG</code> algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
root &lt;- root.node(g);
S.htd &lt;- htd(S,g,root);
</code></pre>

<hr>
<h2 id='htd.holdout'>HTD-DAG holdout</h2><span id='topic+htd.holdout'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the <code>HTD-DAG</code> algorithm applying a classical holdout procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htd.holdout(S, g, testIndex, norm = FALSE, norm.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htd.holdout_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="htd.holdout_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="htd.holdout_+3A_testindex">testIndex</code></td>
<td>
<p>a vector of integer numbers corresponding to the indexes of the elements (rows) of the scores matrix <code>S</code> to be used in the test set.</p>
</td></tr>
<tr><td><code id="htd.holdout_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="htd.holdout_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the <code>HTD-DAG</code> algorithm. Rows of the matrix are shrunk to <code>testIndex</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(test.index);
S.htd &lt;- htd.holdout(S, g, testIndex=test.index, norm=FALSE, norm.type=NULL);
</code></pre>

<hr>
<h2 id='htd.vanilla'>HTD-DAG vanilla</h2><span id='topic+htd.vanilla'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the <code>HTD-DAG</code> algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htd.vanilla(S, g, norm = FALSE, norm.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htd.vanilla_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="htd.vanilla_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="htd.vanilla_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="htd.vanilla_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the <code>HTD-DAG</code> algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
S.htd &lt;- htd.vanilla(S, g, norm=FALSE, norm.type=NULL);
</code></pre>

<hr>
<h2 id='lexicographical.topological.sort'>Lexicographical topological sorting</h2><span id='topic+lexicographical.topological.sort'></span>

<h3>Description</h3>

<p>Nodes of a graph are sorted according to a lexicographical topological ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lexicographical.topological.sort(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lexicographical.topological.sort_+3A_g">g</code></td>
<td>
<p>an object of class <code>graphNEL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A topological sorting is a linear ordering of the nodes such that given an edge from <code>u</code> to <code>v</code>, the node <code>u</code> comes before
node <code>v</code> in the ordering. Topological sorting is not possible if the graph <code>g</code> contains self-loop.
To implement the topological sorting algorithm we applied the Kahn’s algorithm.
</p>


<h3>Value</h3>

<p>A vector in which the nodes of the graph <code>g</code> are sorted according to a lexicographical topological order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
T &lt;- lexicographical.topological.sort(g);
</code></pre>

<hr>
<h2 id='multilabel.F.measure'>multilabel F-measure</h2><span id='topic+multilabel.F.measure'></span><span id='topic+F.measure.multilabel'></span><span id='topic+F.measure.multilabel+2Cmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Method for computing Precision, Recall, Specificity, Accuracy and F-measure for multiclass and multilabel classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.measure.multilabel(target, predicted, b.per.example = FALSE)

## S4 method for signature 'matrix,matrix'
F.measure.multilabel(target, predicted, b.per.example = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilabel.F.measure_+3A_target">target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="multilabel.F.measure_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with discrete predicted values: rows correspond to examples and columns to classes.
<code class="reqn">predicted[i,j]=1</code> if example <code class="reqn">i</code> is predicted belonging to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="multilabel.F.measure_+3A_b.per.example">b.per.example</code></td>
<td>
<p>a boolean value.
</p>

<ul>
<li> <p><code>TRUE</code>: results are returned for each example;
</p>
</li>
<li> <p><code>FALSE</code>: only the average results are returned;
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Names of rows and columns of <code>target</code> and <code>predicted</code> matrix must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p>Two different outputs respect to the input parameter <code>b.per.example</code>:
</p>

<ul>
<li> <p><code>b.per.example==FALSE</code>: a list with a single element average. A named vector with average precision (P), recall (R),
specificity (S), F-measure (F), average F-measure (avF) and Accuracy (A) across examples. F is the F-measure computed as the
harmonic mean between the average precision and recall; av.F is the F-measure computed as average across examples;
</p>
</li>
<li> <p><code>b.per.example==FALSE</code>: a list with two elements:
</p>

<ol>
<li><p> average: a named vector with average precision (P), recall (R), specificity (S), F-measure (F), average F-measure (avF)
and Accuracy (A) across examples;
</p>
</li>
<li><p> per.example: a named matrix with the Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F) and
av.F-measure (av.F) for each example. Row names correspond to examples, column names correspond respectively to Precision (P), Recall (R),
Specificity (S), Accuracy (A), F-measure (F) and av.F-measure (av.F);
</p>
</li></ol>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
data(scores);
data(graph);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
S[S&gt;0.7] &lt;- 1;
S[S&lt;0.7] &lt;- 0;
fscore &lt;- F.measure.multilabel(L,S);
</code></pre>

<hr>
<h2 id='normalize.max'>Max normalization</h2><span id='topic+normalize.max'></span>

<h3>Description</h3>

<p>Normalize the scores of a scores matrix by dividing the score values of each class for the maximum score of the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize.max(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize.max_+3A_s">S</code></td>
<td>
<p>a scores matrix. Rows are examples and columns are classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scores matrix with the scores normalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scores);
maxnorm &lt;- normalize.max(S);
</code></pre>

<hr>
<h2 id='obozinski.heuristic.methods'>Obozinski heuristic methods</h2><span id='topic+obozinski.heuristic.methods'></span><span id='topic+obozinski.max'></span><span id='topic+obozinski.and'></span><span id='topic+obozinski.or'></span>

<h3>Description</h3>

<p>Implementation of the Obozinski's heuristic methods <code>Max</code>, <code>And</code>, <code>Or</code> (<cite>Obozinski et al., Genome Biology, 2008,
doi: <a href="https://doi.org/10.1186/gb-2008-9-s1-s6">10.1186/gb-2008-9-s1-s6</a></cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obozinski.max(S, g, root = "00")

obozinski.and(S, g, root = "00")

obozinski.or(S, g, root = "00")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obozinski.heuristic.methods_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="obozinski.heuristic.methods_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="obozinski.heuristic.methods_+3A_root">root</code></td>
<td>
<p>name of the class that it is the top-level of the hierarchy (<code>def:00</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obozinski's heuristic methods:
</p>

<ol>
<li> <p><b>Max</b>: reports the largest logistic regression (LR) value of self and all descendants: <code class="reqn">p_i = max_{j \in descendants(i)} \hat{p_j}</code>;
</p>
</li>
<li> <p><b>And</b>: reports the product of LR values of all ancestors and self. This is equivalent to computing the probability that all
ancestral terms are &quot;on&quot; assuming that, conditional on the data, all predictions are independent: <code class="reqn">p_i = \prod_{j \in ancestors(i)} \hat{p_j}</code>;
</p>
</li>
<li> <p><b>Or</b>: computes the probability that at least one of the descendant terms is &quot;on&quot; assuming again that, conditional on the data,
all predictions are independent: <code class="reqn">1 - p_i = \prod_{j \in descendants(i)} (1 - \hat{p_j})</code>;
</p>
</li></ol>



<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the chosen Obozinski's heuristic algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
root  &lt;- root.node(g);
S.max &lt;- obozinski.max(S,g,root);
S.and &lt;- obozinski.and(S,g,root);
S.or  &lt;- obozinski.or(S,g,root);
</code></pre>

<hr>
<h2 id='obozinski.holdout'>Obozinski's heuristic methods &ndash; holdout</h2><span id='topic+obozinski.holdout'></span>

<h3>Description</h3>

<p>Compute the Obozinski's heuristic methods <code>Max</code>, <code>And</code>, <code>Or</code> (<cite>Obozinski et al., Genome Biology, 2008</cite>)
applying a classical holdout procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obozinski.holdout(
  S,
  g,
  testIndex,
  heuristic = "and",
  norm = FALSE,
  norm.type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obozinski.holdout_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="obozinski.holdout_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="obozinski.holdout_+3A_testindex">testIndex</code></td>
<td>
<p>a vector of integer numbers corresponding to the indexes of the elements (rows) of the scores matrix <code>S</code> to be used in the test set.</p>
</td></tr>
<tr><td><code id="obozinski.holdout_+3A_heuristic">heuristic</code></td>
<td>
<p>a string character. It can be one of the following three values:
</p>

<ol>
<li><p> &quot;max&quot;: run the method <code>heuristic.max</code>;
</p>
</li>
<li><p> &quot;and&quot;: run the method <code>heuristic.and</code>;
</p>
</li>
<li><p> &quot;or&quot;: run the method <code>heuristic.or</code>;
</p>
</li></ol>
</td></tr>
<tr><td><code id="obozinski.holdout_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="obozinski.holdout_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the chosen heuristic algorithm. Rows of the matrix are shrunk to <code>testIndex</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(test.index);
S.and &lt;- obozinski.holdout(S, g, testIndex=test.index, heuristic="and", norm=FALSE, norm.type=NULL);
</code></pre>

<hr>
<h2 id='obozinski.methods'>Obozinski's heuristic methods calling</h2><span id='topic+obozinski.methods'></span>

<h3>Description</h3>

<p>Compute the Obozinski's heuristic methods <code>Max</code>, <code>And</code>, <code>Or</code> (<cite>Obozinski et al., Genome Biology, 2008</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obozinski.methods(S, g, heuristic = "and", norm = FALSE, norm.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obozinski.methods_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="obozinski.methods_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="obozinski.methods_+3A_heuristic">heuristic</code></td>
<td>
<p>a string character. It can be one of the following three values:
</p>

<ol>
<li><p> &quot;max&quot;: run the method <code>obozinski.max</code>;
</p>
</li>
<li><p> &quot;and&quot;: run the method <code>obozinski.and</code>;
</p>
</li>
<li><p> &quot;or&quot;: run the method <code>obozinski.or</code>;
</p>
</li></ol>
</td></tr>
<tr><td><code id="obozinski.methods_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="obozinski.methods_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the scores of the classes corrected according to the chosen heuristic algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
S.and &lt;- obozinski.methods(S, g, heuristic="and", norm=TRUE, norm.type="maxnorm");
</code></pre>

<hr>
<h2 id='pxr'>Precision-Recall curves</h2><span id='topic+pxr'></span><span id='topic+precision.at.all.recall.levels.single.class'></span><span id='topic+precision.at.given.recall.levels.over.classes'></span>

<h3>Description</h3>

<p>Compute the Precision-Recall (PxR) values through <span class="pkg">precrec</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision.at.all.recall.levels.single.class(labels, scores)

precision.at.given.recall.levels.over.classes(
  target,
  predicted,
  folds = NULL,
  seed = NULL,
  recall.levels = seq(from = 0.1, to = 1, by = 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pxr_+3A_labels">labels</code></td>
<td>
<p>vector of the true labels (0 negative, 1 positive examples).</p>
</td></tr>
<tr><td><code id="pxr_+3A_scores">scores</code></td>
<td>
<p>a numeric vector of the values of the predicted labels (scores).</p>
</td></tr>
<tr><td><code id="pxr_+3A_target">target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td></tr>
<tr><td><code id="pxr_+3A_predicted">predicted</code></td>
<td>
<p>a numeric matrix with predicted values (scores): rows correspond to examples and columns to classes.</p>
</td></tr>
<tr><td><code id="pxr_+3A_folds">folds</code></td>
<td>
<p>number of folds on which computing the PXR. If <code>folds=NULL</code> (<code>def.</code>), the PXR is computed one-shot,
otherwise the PXR is computed averaged across folds.</p>
</td></tr>
<tr><td><code id="pxr_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds. Set <code>seed</code> only if <code>folds</code><code class="reqn">\neq</code><code>NULL</code>.
If <code>seed=NULL</code> and <code>folds</code><code class="reqn">\neq</code><code>NULL</code>, the PXR averaged across folds is computed without seed initialization.</p>
</td></tr>
<tr><td><code id="pxr_+3A_recall.levels">recall.levels</code></td>
<td>
<p>a vector with the desired recall levels (<code>def:</code> <code>from:0.1</code>, <code>to:0.9</code>, <code>by:0.1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>precision.at.all.recall.levels.single.class</code> computes the precision at all recall levels just for a single class.
</p>
<p><code>precision.at.given.recall.levels.over.classes</code> computes the precision at fixed recall levels over classes.
</p>


<h3>Value</h3>

<p><code>precision.at.all.recall.levels.single.class</code> returns a two-columns matrix, representing a pair of precision and recall values.
The first column is the precision, the second the recall;
<code>precision.at.given.recall.levels.over.classes</code> returns a list with two elements:
</p>

<ol>
<li><p> average: a vector with the average precision at different recall levels across classes;
</p>
</li>
<li><p> fixed.recall: a matrix with the precision at different recall levels: rows are classes, columns precision at different recall levels;
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
data(scores);
data(graph);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
labels &lt;- L[,1];
scores &lt;- S[,1];
rec.levels &lt;- seq(from=0.25, to=1, by=0.25);
pxr.single &lt;- precision.at.all.recall.levels.single.class(labels, scores);
pxr &lt;- precision.at.given.recall.levels.over.classes(L, S, folds=5, seed=23,
         recall.levels=rec.levels);
</code></pre>

<hr>
<h2 id='read.graph'>Read a directed graph from a file</h2><span id='topic+read.graph'></span>

<h3>Description</h3>

<p>Read a directed graph from a file and build a <code>graphNEL</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.graph(file = "graph.txt.gz")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.graph_+3A_file">file</code></td>
<td>
<p>name of the file to be read. The format of the file is a sequence of rows and each row corresponds to an edge represented
through a pair of vertexes separated by blanks. The extension of the file can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>graphNEL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ed &lt;- system.file("extdata/graph.edges.txt.gz", package= "HEMDAG");
g &lt;- read.graph(file=ed);
</code></pre>

<hr>
<h2 id='read.undirected.graph'>Read an undirected graph from a file</h2><span id='topic+read.undirected.graph'></span>

<h3>Description</h3>

<p>Read a graph from a file and build a <code>graphNEL</code> object. The format of the input file is a sequence of rows.
Each row corresponds to an edge represented through a pair of vertexes (blank separated) and the weight of the edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.undirected.graph(file = "graph.txt.gz")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.undirected.graph_+3A_file">file</code></td>
<td>
<p>name of the file to be read. The extension of the file can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph of class <code>graphNEL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edges &lt;- system.file("extdata/edges.txt.gz", package="HEMDAG");
g &lt;- read.undirected.graph(file=edges);
</code></pre>

<hr>
<h2 id='root.node'>Root node</h2><span id='topic+root.node'></span>

<h3>Description</h3>

<p>Find the root node of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root.node(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root.node_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of the root node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
root &lt;- root.node(g);
</code></pre>

<hr>
<h2 id='scores.normalization'>Scores normalization function</h2><span id='topic+scores.normalization'></span>

<h3>Description</h3>

<p>Normalize a scores matrix w.r.t. max normalization (<code>maxnorm</code>) or quantile normalization (<code>qnorm</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores.normalization(norm.type = "maxnorm", S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores.normalization_+3A_norm.type">norm.type</code></td>
<td>
<p>can be one of the following two values:
</p>

<ul>
<li><p> maxnorm (<code>def.</code>): each score is divided w.r.t. the max of each class;
</p>
</li>
<li><p> qnorm: a quantile normalization is applied. Package preprocessCore is used;
</p>
</li></ul>
</td></tr>
<tr><td><code id="scores.normalization_+3A_s">S</code></td>
<td>
<p>A named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To apply the quantile normalization the <span class="pkg">preprocessCore</span> package must be properly installed.
</p>


<h3>Value</h3>

<p>The matrix of the scores flat normalized w.r.t. <code>maxnorm</code> or <code>qnorm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scores);
norm.types &lt;- c("maxnorm","qnorm");
for(norm.type in norm.types){
    scores.normalization(norm.type=norm.type, S=S);
}
</code></pre>

<hr>
<h2 id='specific.annotation.list'>Specific annotations list</h2><span id='topic+specific.annotation.list'></span>

<h3>Description</h3>

<p>Build the annotation list starting from the matrix of the most specific annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specific.annotation.list(ann)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specific.annotation.list_+3A_ann">ann</code></td>
<td>
<p>an annotation matrix (0/1). Rows are examples and columns are the most specific functional terms. It must be a named matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, where names of each component correspond to examples (genes) and elements of each component are the associated functional terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
spec.list &lt;- specific.annotation.list(L);
</code></pre>

<hr>
<h2 id='specific.annotation.matrix'>Specific annotation matrix</h2><span id='topic+specific.annotation.matrix'></span>

<h3>Description</h3>

<p>Build the annotation matrix of the most specific functional terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specific.annotation.matrix(file = "gene2pheno.txt.gz")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specific.annotation.matrix_+3A_file">file</code></td>
<td>
<p>text file representing the associations gene-OBO terms. The file must be written as sequence of rows.
Each row represents a gene/protein and all its associations with an ontology term (pipe separated), i.e. in the form <em>e.g.: gene1 |obo1|obo2|...|oboN</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input plain text file (representing the associations gene-OBO terms) can be obtained by cloning the GitHub repository
<a href="https://github.com/marconotaro/obogaf-parser">obogaf-parser</a>, a perl5 module specifically designed to handle HPO and GO obo file and
their gene annotation file (gaf file).
</p>


<h3>Value</h3>

<p>The annotation matrix of the most specific annotations (0/1): rows are genes and columns are functional terms (such as GO or HPO).
Let's denote <code class="reqn">M</code> the labels matrix. If <code class="reqn">M[i,j]=1</code>, means that the gene <code class="reqn">i</code> is annotated with the class <code class="reqn">j</code>, otherwise <code class="reqn">M[i,j]=0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene2pheno &lt;- system.file("extdata/gene2pheno.txt.gz", package="HEMDAG");
spec.ann &lt;- specific.annotation.matrix(file=gene2pheno);
</code></pre>

<hr>
<h2 id='stratified.cross.validation'>Stratified cross validation</h2><span id='topic+stratified.cross.validation'></span><span id='topic+stratified.cv.data.single.class'></span><span id='topic+stratified.cv.data.over.classes'></span>

<h3>Description</h3>

<p>Generate data for the stratified cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratified.cv.data.single.class(examples, positives, kk = 5, seed = NULL)

stratified.cv.data.over.classes(labels, examples, kk = 5, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratified.cross.validation_+3A_examples">examples</code></td>
<td>
<p>indices or names of the examples. Can be either a vector of integers or a vector of names.</p>
</td></tr>
<tr><td><code id="stratified.cross.validation_+3A_positives">positives</code></td>
<td>
<p>vector of integers or vector of names. The indices (or names) refer to the indices (or names) of 'positive' examples.</p>
</td></tr>
<tr><td><code id="stratified.cross.validation_+3A_kk">kk</code></td>
<td>
<p>number of folds (<code>def. kk=5</code>).</p>
</td></tr>
<tr><td><code id="stratified.cross.validation_+3A_seed">seed</code></td>
<td>
<p>seed of the random generator (<code>def. seed=NULL</code>). If is set to <code>NULL</code> no initialization is performed.</p>
</td></tr>
<tr><td><code id="stratified.cross.validation_+3A_labels">labels</code></td>
<td>
<p>labels matrix. Rows are genes and columns are classes. Let's denote <code class="reqn">M</code> the labels matrix.
If <code class="reqn">M[i,j]=1</code>, means that the gene <code class="reqn">i</code> is annotated with the class <code class="reqn">j</code>, otherwise <code class="reqn">M[i,j]=0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Folds are <em>stratified</em>, i.e. contain the same amount of positive and negative examples.
</p>


<h3>Value</h3>

<p><code>stratified.cv.data.single.class</code> returns a list with 2 two component:
</p>

<ul>
<li><p> fold.non.positives: a list with <code class="reqn">k</code> components. Each component is a vector with the indices (or names) of the non-positive elements.
Indexes (or names) refer to row numbers (or names) of a data matrix;
</p>
</li>
<li><p> fold.positives: a list with <code class="reqn">k</code> components. Each component is a vector with the indices (or names) of the positive elements.
Indexes (or names) refer to row numbers (or names) of a data matrix;
</p>
</li></ul>

<p><code>stratified.cv.data.over.classes</code> returns a list with <code class="reqn">n</code> components, where <code class="reqn">n</code> is the number of classes of the labels matrix.
Each component <code class="reqn">n</code> is in turn a list with <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of folds.
Each fold contains an equal amount of positives and negatives examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(labels);
examples.index &lt;- 1:nrow(L);
examples.name &lt;- rownames(L);
positives &lt;- which(L[,3]==1);
x &lt;- stratified.cv.data.single.class(examples.index, positives, kk=5, seed=23);
y &lt;- stratified.cv.data.single.class(examples.name, positives, kk=5, seed=23);
z &lt;- stratified.cv.data.over.classes(L, examples.index, kk=5, seed=23);
k &lt;- stratified.cv.data.over.classes(L, examples.name, kk=5, seed=23);
</code></pre>

<hr>
<h2 id='tpr.dag'>TPR-DAG ensemble variants</h2><span id='topic+tpr.dag'></span>

<h3>Description</h3>

<p>Collection of the true-path-rule-based hierarchical learning ensemble algorithms and its variants.
</p>
<p><code>TPR-DAG</code> is a family of algorithms on the basis of the choice of the <strong>bottom-up</strong> step adopted for the selection of
<em>positive</em> children (or descendants) and of the <strong>top-down</strong> step adopted to assure ontology-based predictions.
Indeed, in their more general form the <code>TPR-DAG</code> algorithms adopt a two step learning strategy:
</p>

<ol>
<li><p> in the first step they compute a <em>per-level bottom-up</em> visit from leaves to root to propagate <em>positive</em> predictions across the hierarchy;
</p>
</li>
<li><p> in the second step they compute a <em>per-level top-down</em> visit from root to leaves in order to assure the consistency of the predictions.
</p>
</li></ol>

<p>It is worth noting that levels (both in the first and second step) are defined in terms of the maximum distance from
the root node (see <code><a href="#topic+graph.levels">graph.levels</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpr.dag(
  S,
  g,
  root = "00",
  positive = "children",
  bottomup = "threshold.free",
  topdown = "gpav",
  t = 0,
  w = 0,
  W = NULL,
  parallel = FALSE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpr.dag_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_root">root</code></td>
<td>
<p>name of the class that it is on the top-level of the hierarchy (<code>def. root="00"</code>).</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_positive">positive</code></td>
<td>
<p>choice of the <em>positive</em> nodes to be considered in the bottom-up strategy. Can be one of the following values:
</p>

<ul>
<li> <p><code>children</code> (<code>def.</code>): positive children are are considered for each node;
</p>
</li>
<li> <p><code>descendants</code>: positive descendants are are considered for each node;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag_+3A_bottomup">bottomup</code></td>
<td>
<p>strategy to enhance the flat predictions by propagating the positive predictions from leaves to root. It can be one of the following values:
</p>

<ul>
<li> <p><code>threshold.free</code> (<code>def.</code>): positive nodes are selected on the basis of the <code>threshold.free</code> strategy;
</p>
</li>
<li> <p><code>threshold</code>: positive nodes are selected on the basis of the <code>threshold</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold.free</code>: positive nodes are selected on the basis of the <code>weighted.threshold.free</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold</code>: positive nodes are selected on the basis of the <code>weighted.threshold</code> strategy;
</p>
</li>
<li> <p><code>tau</code>: positive nodes are selected on the basis of the <code>tau</code> strategy.
NOTE: <code>tau</code> is only a <code>DESCENS</code> variant. If you select <code>tau</code> strategy you must set <code>positive=descendants</code>;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag_+3A_topdown">topdown</code></td>
<td>
<p>strategy to make scores &ldquo;hierarchy-aware&rdquo;. It can be one of the following values:
</p>

<ul>
<li> <p><code>htd</code>: <code>HTD-DAG</code> strategy is applied (<code><a href="#topic+htd">htd</a></code>);
</p>
</li>
<li> <p><code>gpav</code> (<code>def.</code>): <code>GPAV</code> strategy is applied (<code><a href="#topic+gpav">gpav</a></code>);
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag_+3A_t">t</code></td>
<td>
<p>threshold for the choice of positive nodes (<code>def. t=0</code>). Set <code>t</code> only for the variants requiring a threshold for the
selection of the positive nodes, otherwise set <code>t=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_w">w</code></td>
<td>
<p>weight to balance between the contribution of the node <code class="reqn">i</code> and that of its positive nodes. Set <code>w</code> only for
the <em>weighted</em> variants, otherwise set <code>w=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that <code>W</code> is a unitary vector of the
same length of the columns' number of the matrix <code>S</code> (root node included). Set <code>W</code> only if <code>topdown=gpav</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value:
</p>

<ul>
<li> <p><code>TRUE</code>: execute the parallel implementation of GPAV (<code><a href="#topic+gpav.parallel">gpav.parallel</a></code>);
</p>
</li>
<li> <p><code>FALSE</code> (def.): execute the sequential implementation of GPAV (<code><a href="#topic+gpav.over.examples">gpav.over.examples</a></code>);
</p>
</li></ul>

<p>Use <code>parallel</code> only if <code>topdown=GPAV</code>; otherwise set <code>parallel=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution. Set <code>ncores=1</code> if <code>parallel=FALSE</code>, otherwise set <code>ncores</code> to
the desired number of cores. Set <code>ncores</code> if and only if <code>topdown=GPAV</code>; otherwise set <code>ncores=1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>vanilla</em> <code>TPR-DAG</code> adopts a per-level bottom-up traversal of the DAG to correct the flat predictions
<code class="reqn">\hat{y}_i</code> according to the following formula:
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{y}_i := \frac{1}{1 + |\phi_i|} (\hat{y}_i + \sum_{j \in \phi_i} \bar{y}_j)
</code>
</p>

<p>where <code class="reqn">\phi_i</code> are the positive children of <code class="reqn">i</code>.
Different strategies to select the positive children <code class="reqn">\phi_i</code> can be applied:
</p>

<ol>
<li> <p><strong>threshold-free</strong> strategy: the positive nodes are those children that can increment the score of the node <code class="reqn">i</code>, that is those nodes
that achieve a score higher than that of their parents:
</p>
<p style="text-align: center;"><code class="reqn">
     \phi_i := \{ j \in child(i) | \bar{y}_j &gt; \hat{y}_i \}
  </code>
</p>

</li>
<li> <p><strong>threshold</strong> strategy: the positive children are selected on the basis of a threshold that can be selected in two different ways:
</p>

<ol>
<li><p> for each node a constant threshold <code class="reqn">\bar{t}</code> is a priori selected:
</p>
<p style="text-align: center;"><code class="reqn">
     \phi_i := \{ j \in child(i) | \bar{y}_j &gt; \bar{t} \}
    </code>
</p>

<p>For instance if the predictions represent probabilities it could be meaningful to a priori select <code class="reqn">\bar{t}=0.5</code>.
</p>
</li>
<li><p> the threshold is selected to maximize some performance metric <code class="reqn">\mathcal{M}</code> estimated on the training data, as for instance
the Fmax or the AUPRC. In other words the threshold is selected to maximize some measure of accuracy of the predictions
<code class="reqn">\mathcal{M}(j,t)</code> on the training data for the class <code class="reqn">j</code> with respect to the threshold <code class="reqn">t</code>.
The corresponding set of positives <code class="reqn">\forall i \in V</code> is:
</p>
<p style="text-align: center;"><code class="reqn">
     \phi_i := \{ j \in child(i) | \bar{y}_j &gt; t_j^*,  t_j^* = \arg \max_{t} \mathcal{M}(j,t) \}
    </code>
</p>

<p>For instance <code class="reqn">t_j^*</code> can be selected from a set of <code class="reqn">t \in (0,1)</code> through internal cross-validation techniques.
</p>
</li></ol>

</li></ol>

<p>The weighted <code>TPR-DAG</code> version can be designed by adding a weight <code class="reqn">w \in [0,1]</code> to balance between the
contribution of the node <code class="reqn">i</code> and that of its positive children <code class="reqn">\phi</code>, through their convex combination:
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{y}_i := w \hat{y}_i + \frac{(1 - w)}{|\phi_i|} \sum_{j \in \phi_i} \bar{y}_j
</code>
</p>

<p>If <code class="reqn">w=1</code> no weight is attributed to the children and the <code>TPR-DAG</code> reduces to the <code>HTD-DAG</code> algorithm, since in this
way only the prediction for node <code class="reqn">i</code> is used in the bottom-up step of the algorithm. If <code class="reqn">w=0</code> only the predictors
associated to the children nodes vote to predict node <code class="reqn">i</code>. In the intermediate cases we attribute more importance to the predictor for the
node <code class="reqn">i</code> or to its children depending on the values of <code class="reqn">w</code>.
By combining the weighted and the threshold variant, we design the weighted-threshold variant.
</p>
<p>Since the contribution of the descendants of a given node decays exponentially with their distance from the node itself, to enhance the
contribution of the most specific nodes to the overall decision of the ensemble we design the ensemble variant <code>DESCENS</code>.
The novelty of <code>DESCENS</code> consists in strongly considering the contribution of all the descendants of each node instead of
only that of its children. Therefore <code>DESCENS</code> predictions are more influenced by the information embedded in the leaves nodes,
that are the classes containing the most informative and meaningful information from a biological and medical standpoint.
For the choice of the &ldquo;positive&rdquo; descendants we use the same strategies adopted for the selection of the &ldquo;positive&rdquo;
children shown above. Furthermore, we designed a variant specific only for <code>DESCENS</code>, that we named <code>DESCENS</code>-<code class="reqn">\tau</code>.
The <code>DESCENS</code>-<code class="reqn">\tau</code> variant balances the contribution between the &ldquo;positives&rdquo; children of a node <code class="reqn">i</code>
and that of its &ldquo;positives&rdquo; descendants excluding its children by adding a weight <code class="reqn">\tau \in [0,1]</code>:
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{y}_i := \frac{\tau}{1+|\phi_i|}(\hat{y}_i + \sum_{j \in \phi_i} \bar{y}_j) + \frac{1-\tau}{1+|\delta_i|}(\hat{y}_i + \sum_{j\in \delta_i} \bar{y}_j)
</code>
</p>

<p>where <code class="reqn">\phi_i</code> are the &ldquo;positive&rdquo; children of <code class="reqn">i</code> and <code class="reqn">\delta_i=\Delta_i \setminus \phi_i</code> the descendants of <code class="reqn">i</code> without its children.
If <code class="reqn">\tau=1</code> we consider only the contribution of the &ldquo;positive&rdquo; children of <code class="reqn">i</code>; if <code class="reqn">\tau=0</code> only the descendants that are not
children contribute to the score, while for intermediate values of <code class="reqn">\tau</code> we can balance the contribution of <code class="reqn">\phi_i</code> and
<code class="reqn">\delta_i</code> positive nodes.
</p>
<p>Simply by replacing the <code>HTD-DAG</code> top-down step (<code><a href="#topic+htd">htd</a></code>) with the <code>GPAV</code> approach (<code><a href="#topic+gpav">gpav</a></code>) we design the <code>ISO-TPR</code> variant.
The most important feature of <code>ISO-TPR</code> is that it maintains the hierarchical constraints by construction and it selects the closest
solution (in the least square sense) to the bottom-up predictions that obeys the <em>True Path Rule</em>.
</p>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the chosen <code>TPR-DAG</code> ensemble algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpav">gpav</a></code>, <code><a href="#topic+htd">htd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(labels);
root &lt;- root.node(g);
S.tpr &lt;- tpr.dag(S, g, root, positive="children", bottomup="threshold.free",
topdown="gpav", t=0, w=0, W=NULL, parallel=FALSE, ncores=1);
</code></pre>

<hr>
<h2 id='tpr.dag.cv'>TPR-DAG cross-validation experiments</h2><span id='topic+tpr.dag.cv'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the a <code>TPR-DAG</code> ensemble variant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpr.dag.cv(
  S,
  g,
  ann,
  norm = FALSE,
  norm.type = NULL,
  positive = "children",
  bottomup = "threshold",
  topdown = "gpav",
  W = NULL,
  parallel = FALSE,
  ncores = 1,
  threshold = seq(from = 0.1, to = 0.9, by = 0.1),
  weight = 0,
  kk = 5,
  seed = 23,
  metric = "auprc",
  n.round = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpr.dag.cv_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_ann">ann</code></td>
<td>
<p>an annotation matrix: rows correspond to examples and columns to classes. <code class="reqn">ann[i,j]=1</code> if example <code class="reqn">i</code> belongs to
class <code class="reqn">j</code>, <code class="reqn">ann[i,j]=0</code> otherwise. <code>ann</code> matrix is necessary to maximize the hyper-parameter(s) of the chosen parametric
<code>TPR-DAG</code> ensemble variant respect to the metric selected in <code>metric</code>. For the parametric-free ensemble variant set <code>ann=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>. If <code>norm=TRUE</code> the matrix <code>S</code>
is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class (<code><a href="#topic+scores.normalization">scores.normalization</a></code>);
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used (<code><a href="#topic+scores.normalization">scores.normalization</a></code>);
</p>
</li></ol>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_positive">positive</code></td>
<td>
<p>choice of the <em>positive</em> nodes to be considered in the bottom-up strategy. Can be one of the following values:
</p>

<ul>
<li> <p><code>children</code> (<code>def.</code>): positive children are are considered for each node;
</p>
</li>
<li> <p><code>descendants</code>: positive descendants are are considered for each node;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_bottomup">bottomup</code></td>
<td>
<p>strategy to enhance the flat predictions by propagating the positive predictions from leaves to root. It can be one of the following values:
</p>

<ul>
<li> <p><code>threshold.free</code>: positive nodes are selected on the basis of the <code>threshold.free</code> strategy;
</p>
</li>
<li> <p><code>threshold</code> (<code>def.</code>): positive nodes are selected on the basis of the <code>threshold</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold.free</code>: positive nodes are selected on the basis of the <code>weighted.threshold.free</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold</code>: positive nodes are selected on the basis of the <code>weighted.threshold</code> strategy;
</p>
</li>
<li> <p><code>tau</code>: positive nodes are selected on the basis of the <code>tau</code> strategy.
NOTE: <code>tau</code> is only a <code>DESCENS</code> variant. If you select <code>tau</code> strategy you must set <code>positive=descendants</code>;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_topdown">topdown</code></td>
<td>
<p>strategy to make the scores hierarchy-consistent. It can be one of the following values:
</p>

<ul>
<li> <p><code>htd</code>: <code>HTD-DAG</code> strategy is applied (<code><a href="#topic+htd">htd</a></code>);
</p>
</li>
<li> <p><code>gpav</code> (<code>def.</code>): <code>GPAV</code> strategy is applied (<code><a href="#topic+gpav">gpav</a></code>);
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that <code>W</code> is a unitary vector of the same length
of the columns' number of the matrix <code>S</code> (root node included). Set <code>W</code> only if <code>topdown=gpav</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value:
</p>

<ul>
<li> <p><code>TRUE</code>: execute the parallel implementation of GPAV (<code><a href="#topic+gpav.parallel">gpav.parallel</a></code>);
</p>
</li>
<li> <p><code>FALSE</code> (def.): execute the sequential implementation of GPAV (<code><a href="#topic+gpav.over.examples">gpav.over.examples</a></code>);
</p>
</li></ul>

<p>Use <code>parallel</code> only if <code>topdown=gpav</code>; otherwise set <code>parallel=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution. Set <code>ncores=1</code> if <code>parallel=FALSE</code>, otherwise set <code>ncores</code> to the
desired number of cores. Set <code>ncores</code> if <code>topdown=gpav</code>, otherwise set <code>ncores=1</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_threshold">threshold</code></td>
<td>
<p>range of threshold values to be tested in order to find the best threshold (<code>def:</code> <code>from:0.1</code>, <code>to:0.9</code>, <code>by:0.1</code>).
The denser the range is, the higher the probability to find the best threshold is, but the execution time will be higher.
For the <em>threshold-free</em> variants, set <code>threshold=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_weight">weight</code></td>
<td>
<p>range of weight values to be tested in order to find the best weight (<code>def:</code> <code>from:0.1</code>, <code>to:0.9</code>, <code>by:0.1</code>).
The denser the range is, the higher the probability to find the best threshold is, but the execution time will be higher.
For the <em>weight-free</em> variants, set <code>weight=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_kk">kk</code></td>
<td>
<p>number of folds of the cross validation (<code>def: kk=5</code>) on which tuning the parameters <code>threshold</code>, <code>weight</code> and <code>tau</code> of
the parametric ensemble variants. For the parametric-free variants (i.e. if <code>bottomup = threshold.free</code>), set <code>kk=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds (<code>def. 23</code>). If <code>seed=NULL</code> folds are generated without seed
initialization. If <code>bottomup=threshold.free</code>, set <code>seed=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_metric">metric</code></td>
<td>
<p>a string character specifying the performance metric on which maximizing the parametric ensemble variant. It can be one of the following values:
</p>

<ol>
<li> <p><code>auprc</code> (def.): the parametric ensemble variant is maximized on the basis of AUPRC (<code><a href="#topic+auprc">auprc</a></code>);
</p>
</li>
<li> <p><code>fmax</code>: the parametric ensemble variant is maximized on the basis of Fmax (<code><a href="#topic+multilabel.F.measure">multilabel.F.measure</a></code>;
</p>
</li>
<li> <p><code>NULL</code>: <code>threshold.free</code> variant is parameter-free, so none optimization is needed.
</p>
</li></ol>
</td></tr>
<tr><td><code id="tpr.dag.cv_+3A_n.round">n.round</code></td>
<td>
<p>number of rounding digits (def. <code>3</code>) to be applied to the hierarchical scores matrix for choosing the best threshold on the basis of
the best Fmax. If <code>bottomup==threshold.free</code> or <code>metric="auprc"</code>, set <code>n.round=NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametric hierarchical ensemble variants are cross-validated maximizing the parameter on the metric selected in <code>metric</code>.
</p>


<h3>Value</h3>

<p>A named matrix with the scores of the functional terms corrected according to the chosen <code>TPR-DAG</code> ensemble algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(labels);
S.tpr &lt;- tpr.dag.cv(S, g, ann=NULL, norm=FALSE, norm.type=NULL, positive="children",
bottomup="threshold.free", topdown="gpav", W=NULL, parallel=FALSE, ncores=1,
threshold=0, weight=0, kk=NULL, seed=NULL, metric=NULL, n.round=NULL);
</code></pre>

<hr>
<h2 id='tpr.dag.holdout'>TPR-DAG holdout experiments</h2><span id='topic+tpr.dag.holdout'></span>

<h3>Description</h3>

<p>Correct the computed scores in a hierarchy according to the selected <code>TPR-DAG</code> ensemble variant by applying a classical holdout procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpr.dag.holdout(
  S,
  g,
  ann,
  testIndex,
  norm = FALSE,
  norm.type = NULL,
  W = NULL,
  parallel = FALSE,
  ncores = 1,
  positive = "children",
  bottomup = "threshold",
  topdown = "htd",
  threshold = seq(from = 0.1, to = 0.9, by = 0.1),
  weight = seq(from = 0.1, to = 0.9, by = 0.1),
  kk = 5,
  seed = 23,
  metric = "auprc",
  n.round = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpr.dag.holdout_+3A_s">S</code></td>
<td>
<p>a named flat scores matrix with examples on rows and classes on columns.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>. It represents the hierarchy of the classes.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_ann">ann</code></td>
<td>
<p>an annotation matrix: rows correspond to examples and columns to classes. <code class="reqn">ann[i,j]=1</code> if example <code class="reqn">i</code> belongs to
class <code class="reqn">j</code>, <code class="reqn">ann[i,j]=0</code> otherwise. <code>ann</code> matrix is necessary to maximize the hyper-parameter(s) of the chosen parametric <code>TPR-DAG</code> ensemble
variant respect to the metric selected in <code>metric</code>. For the parametric-free ensemble variant set <code>ann=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_testindex">testIndex</code></td>
<td>
<p>a vector of integer numbers corresponding to the indexes of the elements (rows) of the scores matrix <code>S</code> to be used in the test set.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_norm">norm</code></td>
<td>
<p>a boolean value. Should the flat score matrix be normalized? By default <code>norm=FALSE</code>.
If <code>norm=TRUE</code> the matrix <code>S</code> is normalized according to the normalization type selected in <code>norm.type</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_norm.type">norm.type</code></td>
<td>
<p>a string character. It can be one of the following values:
</p>

<ol>
<li> <p><code>NULL</code> (def.): none normalization is applied (<code>norm=FALSE</code>)
</p>
</li>
<li> <p><code>maxnorm</code>: each score is divided for the maximum value of each class;
</p>
</li>
<li> <p><code>qnorm</code>: quantile normalization. <span class="pkg">preprocessCore</span> package is used;
</p>
</li></ol>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_w">W</code></td>
<td>
<p>vector of weight relative to a single example. If <code>W=NULL</code> (def.) it is assumed that <code>W</code> is a unitary vector of the same
length of the columns' number of the matrix <code>S</code> (root node included). Set <code>W</code> only if <code>topdown=gpav</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value:
</p>

<ul>
<li> <p><code>TRUE</code>: execute the parallel implementation of GPAV (<code><a href="#topic+gpav.parallel">gpav.parallel</a></code>);
</p>
</li>
<li> <p><code>FALSE</code> (def.): execute the sequential implementation of GPAV (<code><a href="#topic+gpav.over.examples">gpav.over.examples</a></code>);
</p>
</li></ul>

<p>Use <code>parallel</code> only if <code>topdown=gpav</code>; otherwise set <code>parallel=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel execution. Set <code>ncores=1</code> if <code>parallel=FALSE</code>, otherwise set <code>ncores</code>
to the desired number of cores. Set <code>ncores</code> if and only if <code>topdown=gpav</code>; otherwise set <code>ncores=1</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_positive">positive</code></td>
<td>
<p>choice of the <em>positive</em> nodes to be considered in the bottom-up strategy. Can be one of the following values:
</p>

<ul>
<li> <p><code>children</code> (<code>def.</code>): positive children are are considered for each node;
</p>
</li>
<li> <p><code>descendants</code>: positive descendants are are considered for each node;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_bottomup">bottomup</code></td>
<td>
<p>strategy to enhance the flat predictions by propagating the positive predictions from leaves to root. It can be one of the following values:
</p>

<ul>
<li> <p><code>threshold.free</code>: positive nodes are selected on the basis of the <code>threshold.free</code> strategy (<code>def.</code>);
</p>
</li>
<li> <p><code>threshold</code> (<code>def.</code>): positive nodes are selected on the basis of the <code>threshold</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold.free</code>: positive nodes are selected on the basis of the <code>weighted.threshold.free</code> strategy;
</p>
</li>
<li> <p><code>weighted.threshold</code>: positive nodes are selected on the basis of the <code>weighted.threshold</code> strategy;
</p>
</li>
<li> <p><code>tau</code>: positive nodes are selected on the basis of the <code>tau</code> strategy.
NOTE: <code>tau</code> is only a <code>DESCENS</code> variant. If you select <code>tau</code> strategy you must set <code>positive=descendants</code>;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_topdown">topdown</code></td>
<td>
<p>strategy to make the scores hierarchy-consistent. It can be one of the following values:
</p>

<ul>
<li> <p><code>htd</code>: <code>HTD-DAG</code> strategy is applied (<code><a href="#topic+htd">htd</a></code>);
</p>
</li>
<li> <p><code>gpav</code> (<code>def.</code>): <code>GPAV</code> strategy is applied (<code><a href="#topic+gpav">gpav</a></code>);
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_threshold">threshold</code></td>
<td>
<p>range of threshold values to be tested in order to find the best threshold (<code>def:</code> <code>from:0.1</code>, <code>to:0.9</code>, <code>by:0.1</code>).
The denser the range is, the higher the probability to find the best threshold is, but the execution time will be higher.
For the <em>threshold-free</em> variants, set <code>threshold=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_weight">weight</code></td>
<td>
<p>range of weight values to be tested in order to find the best weight (<code>def:</code> <code>from:0.1</code>, <code>to:0.9</code>, <code>by:0.1</code>).
The denser the range is, the higher the probability to find the best threshold is, but the execution time will be higher.
For the <em>weight-free</em> variants, set <code>weight=0</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_kk">kk</code></td>
<td>
<p>number of folds of the cross validation (<code>def: kk=5</code>) on which tuning the parameters <code>threshold</code>, <code>weight</code> and <code>tau</code>
of the parametric ensemble variants. For the parametric-free variants (i.e. if <code>bottomup = threshold.free</code>), set <code>kk=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_seed">seed</code></td>
<td>
<p>initialization seed for the random generator to create folds (<code>def. 23</code>). If <code>seed=NULL</code> folds are generated
without seed initialization. If <code>bottomup=threshold.free</code>, set <code>seed=NULL</code>.</p>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_metric">metric</code></td>
<td>
<p>a string character specifying the performance metric on which maximizing the parametric ensemble variant. It can be one of the following values:
</p>

<ol>
<li> <p><code>auprc</code> (def.): the parametric ensemble variant is maximized on the basis of AUPRC (<code><a href="#topic+auprc">auprc</a></code>);
</p>
</li>
<li> <p><code>fmax</code>: the parametric ensemble variant is maximized on the basis of Fmax (<code><a href="#topic+multilabel.F.measure">multilabel.F.measure</a></code>;
</p>
</li>
<li> <p><code>NULL</code>: <code>threshold.free</code> variant is parameter-free, so none optimization is needed.
</p>
</li></ol>
</td></tr>
<tr><td><code id="tpr.dag.holdout_+3A_n.round">n.round</code></td>
<td>
<p>number of rounding digits (def. <code>3</code>) to be applied to the hierarchical scores matrix for choosing the best threshold
on the basis of the best Fmax. If <code>bottomup==threshold.free</code> or <code>metric="auprc"</code>, set <code>n.round=NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametric hierarchical ensemble variants are cross-validated maximizing the parameter on the metric selected in <code>metric</code>,
</p>


<h3>Value</h3>

<p>A named matrix with the scores of the classes corrected according to the chosen <code>TPR-DAG</code> ensemble algorithm.
Rows of the matrix are shrunk to <code>testIndex</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(scores);
data(labels);
data(test.index);
S.tpr &lt;- tpr.dag.holdout(S, g, ann=NULL, testIndex=test.index, norm=FALSE, norm.type=NULL,
positive="children", bottomup="threshold.free", topdown="gpav", W=NULL, parallel=FALSE,
ncores=1, threshold=0, weight=0, kk=NULL, seed=NULL, metric=NULL, n.round=NULL);
</code></pre>

<hr>
<h2 id='transitive.closure.annotations'>Transitive closure of annotations</h2><span id='topic+transitive.closure.annotations'></span>

<h3>Description</h3>

<p>Perform the transitive closure of the annotations using ancestors and the most specific annotation matrix.
The annotations are propagated from bottom to top, enriching the most specific annotations table. Rows correspond to genes and columns to functional terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitive.closure.annotations(ann.spec, anc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitive.closure.annotations_+3A_ann.spec">ann.spec</code></td>
<td>
<p>the annotation matrix of the most specific annotations (0/1): rows are genes and columns are functional terms.</p>
</td></tr>
<tr><td><code id="transitive.closure.annotations_+3A_anc">anc</code></td>
<td>
<p>the ancestor list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The annotation table T: rows correspond to genes and columns to OBO terms. <code class="reqn">T[i,j]=1</code> means that gene <code class="reqn">i</code> is annotated for the term <code class="reqn">j</code>,
<code class="reqn">T[i,j]=0</code> means that gene <code class="reqn">i</code> is not annotated for the term <code class="reqn">j</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
data(labels);
anc &lt;- build.ancestors(g);
tca &lt;- transitive.closure.annotations(L, anc);
</code></pre>

<hr>
<h2 id='tupla.matrix'>Tupla matrix</h2><span id='topic+tupla.matrix'></span>

<h3>Description</h3>

<p>Transform a named score matrix in a tupla, i.e. in the form <code>nodeX nodeY score</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tupla.matrix(m, output.file = "net.file.gz", digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tupla.matrix_+3A_m">m</code></td>
<td>
<p>a named score matrix. It can be either a <code>m x n</code> matrix (where <code>m</code> are example and <code>n</code>
are functional terms, e.g. GO terms) or it can be a square named matrix <code>m x m</code>, where <code>m</code> are examples.</p>
</td></tr>
<tr><td><code id="tupla.matrix_+3A_output.file">output.file</code></td>
<td>
<p>name of the file on which the matrix must be written.</p>
</td></tr>
<tr><td><code id="tupla.matrix_+3A_digits">digits</code></td>
<td>
<p>number of digits to be used to save scores of <code>m</code> (<code>def. digits=3</code>).
The extension of the file can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the <em>non-zero</em> interactions are kept, while the <em>zero</em> interactions are discarded.
</p>


<h3>Value</h3>

<p>A tupla score matrix stored in output.file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wadj);
file &lt;- tempfile();
tupla.matrix(W, output.file=file, digits=3);
</code></pre>

<hr>
<h2 id='unstratified.cv.data'>Unstratified cross validation</h2><span id='topic+unstratified.cv.data'></span>

<h3>Description</h3>

<p>This function splits a dataset in k-fold in an unstratified way, i.e. a fold does not contain an equal amount of positive
and negative examples. This function is used to perform k-fold cross-validation experiments in a hierarchical correction contest where
splitting dataset in a stratified way is not needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstratified.cv.data(S, kk = 5, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstratified.cv.data_+3A_s">S</code></td>
<td>
<p>matrix of the flat scores. It must be a named matrix, where rows are example (e.g. genes) and columns are classes/terms (e.g. GO terms).</p>
</td></tr>
<tr><td><code id="unstratified.cv.data_+3A_kk">kk</code></td>
<td>
<p>number of folds in which to split the dataset (<code>def. k=5</code>).</p>
</td></tr>
<tr><td><code id="unstratified.cv.data_+3A_seed">seed</code></td>
<td>
<p>seed for random generator. If <code>NULL</code> (def.) no initialization is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code class="reqn">k=kk</code> components (folds). Each component of the list is a character vector contains the index of the examples,
i.e. the index of the rows of the matrix S.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scores);
foldIndex &lt;- unstratified.cv.data(S, kk=5, seed=23);
</code></pre>

<hr>
<h2 id='weighted.adjacency.matrix'>Weighted adjacency matrix</h2><span id='topic+weighted.adjacency.matrix'></span>

<h3>Description</h3>

<p>Build a symmetric weighted adjacency matrix (wadj matrix) of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.adjacency.matrix(file = "edges.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.adjacency.matrix_+3A_file">file</code></td>
<td>
<p>name of the plain text file to be read (<code>def. edges</code>). The format of the file is a sequence of rows.
Each row corresponds to an edge represented through a pair of vertexes (blank separated) and the weight of the edges.
For instance: <code>nodeX nodeY score</code>. The file extension can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named symmetric weighted adjacency matrix of the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edges &lt;- system.file("extdata/edges.txt.gz", package="HEMDAG");
W &lt;- weighted.adjacency.matrix(file=edges);
</code></pre>

<hr>
<h2 id='write.graph'>Write a directed graph on file</h2><span id='topic+write.graph'></span>

<h3>Description</h3>

<p>Read an object of class <code>graphNEL</code> and write the graph as sequence of rows on a plain text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.graph(g, file = "graph.txt.gz")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.graph_+3A_g">g</code></td>
<td>
<p>a graph of class <code>graphNEL</code>.</p>
</td></tr>
<tr><td><code id="write.graph_+3A_file">file</code></td>
<td>
<p>name of the file to be written. The extension of the file can be plain (&quot;.txt&quot;) or compressed (&quot;.gz&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plain text file representing the graph. Each row corresponds to an edge represented through a pair of vertexes separated by blank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graph);
file &lt;- tempfile();
write.graph(g, file=file);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
