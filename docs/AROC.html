<!DOCTYPE html><html><head><title>Help for package AROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AROC-package'>
<p>Covariate-Adjusted Receiver Operating Characteristic Curve Inference</p></a></li>
<li><a href='#AROC.bnp'>
<p>Nonparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#AROC.bsp'>
<p>Semiparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#AROC.kernel'>
<p>Non parametric kernel-based estimation of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#AROC.sp'>
<p>Semiparametric frequentist inference of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#compute.threshold.AROC.bnp'>
<p>AROC-based threshold values.</p></a></li>
<li><a href='#compute.threshold.AROC.bsp'>
<p>AROC-based threshold values.</p></a></li>
<li><a href='#compute.threshold.AROC.kernel'>
<p>AROC-based threshold values.</p></a></li>
<li><a href='#compute.threshold.AROC.sp'>
<p>AROC-based threshold values.</p></a></li>
<li><a href='#compute.threshold.pooledROC.BB'>
<p>Pooled ROC-based threshold values.</p></a></li>
<li><a href='#compute.threshold.pooledROC.emp'>
<p>Pooled ROC-based threshold values.</p></a></li>
<li><a href='#paauccontrol'>
<p>Partial area under the covariate-adjusted ROC curve (pAAUC).</p></a></li>
<li><a href='#plot.AROC'>
<p>Default AROC plotting</p></a></li>
<li><a href='#pooledROC.BB'>
<p>Bayesian bootstrap estimation of the pooled ROC curve.</p></a></li>
<li><a href='#pooledROC.emp'>
<p>Empirical estimation of the pooled ROC curve.</p></a></li>
<li><a href='#predictive.checks.AROC.bnp'>
<p>Posterior predictive checks.</p></a></li>
<li><a href='#predictive.checks.AROC.bsp'>
<p>Posterior predictive checks.</p></a></li>
<li><a href='#print.AROC'>
<p>Print method for <code>AROC</code> objects</p></a></li>
<li><a href='#psa'>
<p>Prostate specific antigen (PSA) biomarker study.</p></a></li>
<li><a href='#summary.AROC'>
<p>Summary method for <code>AROC</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariate-Adjusted Receiver Operating Characteristic Curve
Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-18</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics, splines, np, Matrix, Hmisc, MASS,
moments, nor1mix, spatstat.geom</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates the covariate-adjusted Receiver Operating Characteristic (AROC) curve and pooled (unadjusted) ROC curve by different methods. Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018) &lt;<a href="https://arxiv.org/abs/1806.00473">arXiv:1806.00473</a>&gt;. NOTE: We have created a new package, 'ROCnReg', with more functionalities. It also implements all the methods included in 'AROC'. We, therefore, recommend using 'ROCnReg' ('AROC' will no longer be maintained).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-18 09:30:32 UTC; mrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Xose Rodriguez-Alvarez
    <a href="https://orcid.org/0000-0002-1329-9238"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Vanda Inacio <a href="https://orcid.org/0000-0001-8084-1616"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-21 13:30:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='AROC-package'>
Covariate-Adjusted Receiver Operating Characteristic Curve Inference
</h2><span id='topic+AROC-package'></span><span id='topic+AROC'></span>

<h3>Description</h3>

<p>Estimates the covariate-adjusted Receiver Operating Characteristic (AROC) curve and pooled (unadjusted) ROC curve by different methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> AROC</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-02-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maria Xose Rodriguez-Alvarez and Vanda Inacio.
</p>
<p>Maintainer: Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.es&gt;
</p>


<h3>References</h3>

<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, 96(2), 371 - 382.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, 21(4), 483 - 499.
</p>

<hr>
<h2 id='AROC.bnp'>
Nonparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.bnp'></span>

<h3>Description</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) using the nonparametric Bayesian approach proposed by Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.bnp(formula.healthy, group, tag.healthy, data, scale = TRUE, 
  p = seq(0, 1, l = 101), paauc = paauccontrol(), 
  compute.lpml = FALSE, compute.WAIC = FALSE, 
  m0, S0, nu, Psi, alpha = 1, a = 2, b = 0.5, L = 10, nsim = 10000, nburn = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.bnp_+3A_formula.healthy">formula.healthy</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the B-splines dependent Dirichlet process mixture model for the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population (see Note).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_tag.healthy">tag.healthy</code></td>
<td>
<p>The value codifying the healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_scale">scale</code></td>
<td>
<p>A logical value. If TRUE the test outcomes are scaled, i.e., are divided by the standard deviation. The default is TRUE.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_paauc">paauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+paauccontrol">paauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve (pAAUC) should be computed and at which FPF.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_compute.lpml">compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_compute.waic">compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_m0">m0</code></td>
<td>
<p>A numeric vector. Hyperparameter; mean vector of the (multivariate) normal prior distribution for the mean of the normal component of the centering distribution. If missing, it is set to a vector of zeros of length <code>Q</code> (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_s0">S0</code></td>
<td>
<p>A numeric matrix. Hyperparameter; covariance matrix of the (multivariate) normal prior distribution for the mean of the normal component of the centering distribution. If missing, it is set to a diagonal matrix of dimension <code>Q</code>x<code>Q</code> with 100 in the diagonal (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_nu">nu</code></td>
<td>
<p>A numeric value. Hyperparameter; degrees of freedom of the Wishart prior distribution for the precision matrix of the the normal component of the centering distribution. If missing, it is set to <code>Q + 2</code> (see Details)</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_psi">Psi</code></td>
<td>
<p>A numeric matrix. Hyperparameter; scale matrix of the Wishart distribution for the precision matrix of the the normal component of the centering distribution. If missing, it is set to an identity matrix of dimension <code>Q</code>x<code>Q</code> (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value. Precision parameter of the Dirichlet Process. The default is 1 (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_a">a</code></td>
<td>
<p>A numeric value. Hyperparameter; shape parameter of the gamma prior distribution for the precision (inverse variance). The default is 2 (scaled data) (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_b">b</code></td>
<td>
<p>A numeric value. Hyperparameter; rate parameter of the gamma prior distribution for the precision (inverse variance). The default is 0.5 (scaled data) (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_l">L</code></td>
<td>
<p>A numeric value. Maximum number of mixture components for the B-splines dependent Dirichlet process mixture model. The default is 10 (see Details)</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_nsim">nsim</code></td>
<td>
<p>A numeric value. Total number of Gibbs sampler iterates (including the burn-in). The default is 10000.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_nburn">nburn</code></td>
<td>
<p>A numeric value. Number of burn-in iterations. The default is 2000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(t\right) = Pr\{1 - F_{\bar{D}}(Y_D | \mathbf{X}_{D}) \leq t\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> denotes the conditional distribution function for <code class="reqn">Y_{\bar{D}}</code> conditional on the vector of covariates <code class="reqn">\mathbf{X}_{\bar{D}}</code>. In particular, the method implemented in this function combines a B-splines dependent Dirichlet process mixture model to estimate <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> and the Bayesian bootstrap (Rubin, 1981) to estimate the outside probability. More precisely, and letting <code class="reqn">\{(\mathbf{x}_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code> be a random sample from the nondiseased population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}|\mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = \sum_{l=1}^{L}\omega_l\Phi(y_{\bar{D}i}\mid\mu_{l}(\mathbf{x}_{\bar{D}i}),\sigma_l^2),</code>
</p>

<p>where <code class="reqn">\mu_{l}(\mathbf{x}_{\bar{D}i}) = \mathbf{z}_{\bar{D}i}^{T}\mathbf{\beta}_l</code> and <code class="reqn">L</code> is pre-specified (maximum number of mixture components). The <code class="reqn">\omega_l</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_1=v_1</code>; <code class="reqn">\omega_l=v_l\prod_{r&lt;l}(1-v_r)</code>, <code class="reqn">l=2,\ldots,L</code>; <code class="reqn">v_1,\ldots,v_{L-1}\sim</code> Beta <code class="reqn">(1,\alpha)</code>; <code class="reqn">v_L=1</code>), <code class="reqn">\mathbf{\beta}_l\sim N_{Q}(\mathbf{m},\mathbf{S})</code>, and <code class="reqn">\sigma_l^{-2}\sim\Gamma(a,b)</code>. It is assumed that <code class="reqn">\mathbf{m} \sim N_{Q}(\mathbf{m}_0,\mathbf{S}_0)</code> and <code class="reqn">\mathbf{S}^{-1}\sim W(\nu,(\nu\Psi)^{-1})</code>. Here <code class="reqn">W(\nu,(\nu\Psi)^{-1})</code> denotes a Wishart distribution with <code class="reqn">\nu</code> degrees of freedom and expectation <code class="reqn">\Psi^{-1}</code>, and <code class="reqn">Q</code> denotes the dimension of vector <code class="reqn">\mathbf{z}_{\bar{D}i}</code>. For a detailed description, we refer to Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If required, estimated partial area under the covariate-adjusted ROC curve (pAAUC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>If required, list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>If required, widely applicable information criterion (WAIC).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Results of the fitting process. It is a list with the following components: (1) <code>mm</code>: information needed to construct the model matrix associated with the B-splines dependent Dirichlet process mixture model. (2) <code>beta</code>: array of dimension <code>N</code>x<code>L</code>x<code>Q</code> with the sampled regression coefficients. Here, <code>N</code> is the number of Gibbs sampler iterates after burn-in, <code>L</code> is the maximum number of mixture components, and <code>Q</code> is the dimension of vector <code class="reqn">\mathbf{Z}_{\bar{D}}</code> (see also Details). (3) <code>sd</code>: matrix of dimension <code>N</code>x<code>L</code> with the sampled variances. Here, <code>N</code> is the number of Gibbs sampler iterates after burn-in, and <code>L</code> is the maximum number of mixture components (see also Details). (4) <code>probs</code>: matrix of dimension <code>N</code>x<code>L</code> with the sampled components' weights. Here, <code>N</code> is the number of Gibbs sampler iterates after burn-in and <code>L</code> is the maximum number of mixture components (see also Details).</p>
</td></tr>
<tr><td><code>data_model</code></td>
<td>
<p>List with the data used in the fit: observed diagnostic test outcome and B-spline design matrices, separately for the healthy and diseased groups.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The input argument <code>formula.healthy</code> is similar to that used for the <code><a href="stats.html#topic+glm">glm</a></code> function, except that flexible specifications can be added by means of function <code>f()</code>. For instance, specification <code class="reqn">y \sim x1 + f(x2, K = 3)</code> would assume a linear effect of <code>x1</code> and the effect of <code>x2</code> would be modeled using B-splines basis functions. The argument <code>K = 3</code> indicates that <code>3</code> internal knots will be used, with the quantiles of <code>x2</code> used for their location. Categorical variables (factors) can be also incorporated, as well as factor-by-curve interaction terms. For example, to include the interaction between <code>age</code> and <code>gender</code> we need to specify <code class="reqn">y \sim gender + f(age, by = gender, K = 3)</code>.</p>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rubin, D. B. (1981). The Bayesian bootstrap. The Annals of Statistics, 9(1), 130-134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

summary(m0)

plot(m0)


</code></pre>

<hr>
<h2 id='AROC.bsp'>
Semiparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.bsp'></span>

<h3>Description</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) using the semiparametric Bayesian normal linear regression model discussed in Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.bsp(formula.healthy, group, tag.healthy, data, scale = TRUE, 
  p = seq(0, 1, l = 101), paauc = paauccontrol(),
  compute.lpml = FALSE, compute.WAIC = FALSE, 
  m0, S0, nu, Psi, a = 2, b = 0.5, nsim = 5000, nburn = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.bsp_+3A_formula.healthy">formula.healthy</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the Bayesian normal linear regression model for the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_tag.healthy">tag.healthy</code></td>
<td>
<p>The value codifying the healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_scale">scale</code></td>
<td>
<p>A logical value. If TRUE the test outcomes are scaled, i.e., are divided by the standard deviation. The default is TRUE.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_compute.lpml">compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_paauc">paauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+paauccontrol">paauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve (pAAUC) should be computed and at which FPF.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_compute.waic">compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_m0">m0</code></td>
<td>
<p>A numeric vector.  Hyperparameter; mean vector of the (multivariate) normal distribution for the mean of the regression coefficients. If missing, it is set to a vector of zeros of length <code>p+1</code> (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_s0">S0</code></td>
<td>
<p>A numeric matrix. Hyperprior. If missing, it is set to a diagonal matrix of dimension <code>(p+1)</code>x<code>(p+1)</code> with 100 in the diagonal (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_nu">nu</code></td>
<td>
<p>A numeric value. Hyperparameter; degrees of freedom of the Wishart distribution for the precision matrix of the regression coefficients. If missing, it is set to <code>p + 3</code> (see Details)</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_psi">Psi</code></td>
<td>
<p>A numeric matrix. Hyperparameter; scale matrix of the Wishart distribution for the precision matrix of the regression coefficients. If missing, it is set to an identity matrix of dimension <code>(p+1)</code>x<code>(p+1)</code> (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_a">a</code></td>
<td>
<p>A numeric value. Hyperparameter; shape parameter of the gamma distribution for the precision (inverse variance). The default is 2 (scaled data) (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_b">b</code></td>
<td>
<p>A numeric value. Hyperparameter; rate parameter of the gamma distribution for the precision (inverse variance). The default is 0.5 (scaled data) (see Details).</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_nsim">nsim</code></td>
<td>
<p>A numeric value. Total number of Gibbs sampler iterates (including the burn-in). The default is 5000.</p>
</td></tr>
<tr><td><code id="AROC.bsp_+3A_nburn">nburn</code></td>
<td>
<p>A numeric value. Number of burn-in iterations. The default is 1500.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(t\right) = Pr\{1 - F_{\bar{D}}(Y_D | \mathbf{X}_{D}) \leq t\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> denotes the conditional distribution function for <code class="reqn">Y_{\bar{D}}</code> conditional on the vector of covariates <code class="reqn">X_{\bar{D}}</code>. In particular, the method implemented in this function combines a Bayesian normal linear regression model to estimate <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> and the Bayesian bootstrap (Rubin, 1981) to estimate the outside probability. More precisely, and letting <code class="reqn">\{(\mathbf{x}_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code> be a random sample from the nondiseased population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}|\mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = \Phi(y_{\bar{D}i}\mid \mathbf{x}_{\bar{D}i}^{*T}\mathbf{\beta}^{*},\sigma^2),</code>
</p>

<p>where <code class="reqn">\mathbf{x}_{\bar{D}i}^{*T} = (1, \mathbf{x}_{\bar{D}i}^{T})</code>, <code class="reqn">\mathbf{\beta}^{*}\sim N_{p+1} (\mathbf{m},\mathbf{S})</code> and <code class="reqn">\sigma^{-2}\sim\Gamma(a,b)</code>. It is assumed that <code class="reqn">\mathbf{m} \sim N_{p+1}(\mathbf{m}_0,\mathbf{S}_0)</code> and <code class="reqn">\mathbf{S}^{-1}\sim W(\nu,(\nu\Psi)^{-1})</code>, where <code class="reqn">p+1</code> denotes the number of columns of the design matrix <code class="reqn">\mathbf{X}_{\bar{D}}^{*}</code>. Here <code class="reqn">W(\nu,(\nu\Psi)^{-1})</code> denotes a Wishart distribution with <code class="reqn">\nu</code> degrees of freedom and expectation <code class="reqn">\Psi^{-1}</code>. For a detailed description, we refer to Inacio de Carvalho and Rodriguez-Alvarez (2018). 
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If required in the call to the function, estimated partial area under the covariate-adjusted ROC curve (pAAUC) (posterior mean), and 95% pointwise posterior credible band.</p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>If required, list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>If required, widely applicable information criterion (WAIC).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Results of the fitting process. It is a list with the following components: (1) <code>mm</code>: information needed to construct the model matrix associated with the B-splines dependent Dirichlet process mixture model. (2) <code>beta</code>: matrix of dimension <code>N</code>x<code>p+1</code> with the sampled regression coefficients. Here, <code>N</code> is the number of Gibbs sampler iterates after burn-in, and <code>p+1</code> the number of columns of the design matrix (see also Details). (3) <code>sd</code>: vector of length <code>N</code> with the sampled variances (see also Details).</p>
</td></tr>
<tr><td><code>data_model</code></td>
<td>
<p>List with the data used in the fit: observed diagnostic test outcome and B-spline design matrices, separately for the healthy and diseased groups.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rubin, D. B. (1981). The Bayesian bootstrap. The Annals of Statistics, 9(1), 130-134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m1 &lt;- AROC.bsp(formula.healthy = l_marker1 ~ age,
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, nsim = 5000, nburn = 1500)

summary(m1)

plot(m1)


</code></pre>

<hr>
<h2 id='AROC.kernel'>
Non parametric kernel-based estimation of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.kernel'></span>

<h3>Description</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011). The method, as it stands now, can only deal with one continuous covariate. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.kernel(marker, covariate, group, tag.healthy, data, p = seq(0, 1, l = 101), B = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.kernel_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_covariate">covariate</code></td>
<td>
<p>A character string with the name of the continuous covariate.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_tag.healthy">tag.healthy</code></td>
<td>
<p>The value codifying the healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. By default 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(t\right) = Pr\{1 - F_{\bar{D}}(Y_D | X_{D}) \leq t\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(\cdot|X_{D})</code> denotes the conditional distribution function for <code class="reqn">Y_{\bar{D}}</code> conditional on the vector of covariates <code class="reqn">X_{\bar{D}}</code>. In particular, the method implemented in this function estimates the outer probability empirically (see Janes and Pepe, 2008) and <code class="reqn">F_{\bar{D}}(\cdot|X_{\bar{D}})</code> is estimated assuming a nonparametric location-scale regression model for <code class="reqn">Y_{\bar{D}}</code>, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mu_{\bar{D}}(X_{\bar{D}}) + \sigma_{\bar{D}}(X_{\bar{D}})\varepsilon_{\bar{D}},</code>
</p>

<p>where <code class="reqn">\mu_{\bar{D}}</code> is the regression funcion, <code class="reqn">\sigma_{\bar{D}}</code> is the variance function, and <code class="reqn">\varepsilon_{\bar{D}}</code> has zero mean, variance one, and
distribution function <code class="reqn">F_{\bar{D}}</code>. As a consequence, and for a random sample <code class="reqn">\{(x_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code>
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i} | X_{\bar{D}}= x_{\bar{D}i}) = F_{\bar{D}}\left(\frac{y_{\bar{D}i}-\mu_{\bar{D}}(x_{\bar{D}i})}{\sigma_{\bar{D}}(x_{\bar{D}i})}\right).</code>
</p>
 
<p>Both the regression and variance functions are estimated using the Nadaraya-Watson estimator, and the bandwidth are selected using least-squares cross-validation. Implementation relies on the <code>R</code>-package <code><a href="np.html#topic+np">np</a></code>. No assumption is made about the distribution of <code class="reqn">\varepsilon_{\bar{D}}</code>, which is empirically estimated on the basis of standardised residuals. 
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC), and 95% pointwise confidence intervals (if required)</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC), and 95% pointwise confidence intervals (if required).</p>
</td></tr>
<tr><td><code>bw.mean</code></td>
<td>
<p>An object of class <code><a href="np.html#topic+npregbw">npregbw</a></code> with the selected bandwidth for the nonparametric regression function. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np">np</a></code>.</p>
</td></tr>
<tr><td><code>bw.var</code></td>
<td>
<p>An object of class <code><a href="np.html#topic+npregbw">npregbw</a></code> with the selected bandwidth for the nonparametric variance function. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np">np</a></code>.</p>
</td></tr>
<tr><td><code>fit.mean</code></td>
<td>
<p>An object of class <code><a href="np.html#topic+npreg">npreg</a></code> with the nonparametric regression function estimate. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np">np</a></code>.</p>
</td></tr>
<tr><td><code>fit.var</code></td>
<td>
<p>An object of class <code><a href="np.html#topic+npreg">npreg</a></code> with the nonparametric variance function estimate. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np">np</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hayfield, T., and Racine, J. S.(2008). Nonparametric Econometrics: The np Package. Journal of Statistical Software 27(5). URL http://www.jstatsoft.org/v27/i05/.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, 21(4), 483 - 499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m2 &lt;- AROC.kernel(marker = "l_marker1", covariate = "age",
group = "status", tag.healthy = 0, data = newpsa, 
p = seq(0,1,l=101), B = 500)

summary(m2)

plot(m2)


</code></pre>

<hr>
<h2 id='AROC.sp'>
Semiparametric frequentist inference of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.sp'></span>

<h3>Description</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) using the semiparametric approach proposed by Janes and Pepe (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.sp(formula.healthy, group, tag.healthy, data, 
	est.surv.h = c("normal", "empirical"), p = seq(0, 1, l = 101), B = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.sp_+3A_formula.healthy">formula.healthy</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the location regression model to be fitted in healthy population (see Details).</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_tag.healthy">tag.healthy</code></td>
<td>
<p>The value codifying the healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_est.surv.h">est.surv.h</code></td>
<td>
<p>A character string. It indicates how the conditional distribution function of the diagnostic test in healthy population is estimated. Options are &quot;normal&quot; and &quot;empirical&quot; (see Details). The default is &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. By default 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(t\right) = Pr\{1 - F_{\bar{D}}(Y_D | \mathbf{X}_{D}) \leq t\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> denotes the conditional distribution function for <code class="reqn">Y_{\bar{D}}</code> conditional on the vector of covariates <code class="reqn">\mathbf{X}_{\bar{D}}</code>. In particular, the method implemented in this function estimates the outer probability empirically (see Janes and Pepe, 2008) and <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> is estimated assuming a semiparametric location regression model for <code class="reqn">Y_{\bar{D}}</code>, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mathbf{X}_{\bar{D}}^{T}\mathbf{\beta}_{\bar{D}} + \sigma_{\bar{D}}\varepsilon_{\bar{D}},</code>
</p>

<p>such that, for a random sample <code class="reqn">\{(\mathbf{x}_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code> from the healthy population, we have
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y | \mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = F_{\bar{D}}\left(\frac{y-\mathbf{x}_{\bar{D}i}^{T}\mathbf{\beta}_{\bar{D}}}{\sigma_{\bar{D}}}\right),</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}</code> is the distribution function of <code class="reqn">\varepsilon_{\bar{D}}</code>. In line with the assumptions made about the distribution of <code class="reqn">\varepsilon_{\bar{D}}</code>, estimators will be referred to as: (a) &quot;normal&quot;, where Gaussian error is assumed, i.e., <code class="reqn">F_{\bar{D}}(y) = \Phi(y)</code>; and, (b) &quot;empirical&quot;, where no assumption is made about the distribution (in this case, the distribution function <code class="reqn">F_{\bar{D}}</code> is empirically estimated on the basis of standardised residuals).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC), and 95% pointwise confidence intervals (if required)</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC), and 95% pointwise confidence intervals (if required).</p>
</td></tr>
<tr><td><code>fit.h</code></td>
<td>
<p>Object of class <code><a href="stats.html#topic+lm">lm</a></code> with the fitted regression model in the healthy population.</p>
</td></tr>
<tr><td><code>est.surv.h</code></td>
<td>
<p>The value of the argument <code>est.surv.h</code> used in the call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, 96(2), 371 - 382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m3 &lt;- AROC.sp(formula.healthy = l_marker1 ~ age,
group = "status", tag.healthy = 0, data = newpsa,
p = seq(0,1,l=101), B = 500)

summary(m3)

plot(m3)


</code></pre>

<hr>
<h2 id='compute.threshold.AROC.bnp'>
AROC-based threshold values.
</h2><span id='topic+compute.threshold.AROC.bnp'></span>

<h3>Description</h3>

<p>Estimates AROC-based threshold values using the nonparametric Bayesian approach proposed by Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.AROC.bnp(object, newdata, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.AROC.bnp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.bnp">AROC.bnp</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.bnp_+3A_newdata">newdata</code></td>
<td>
<p>Data frame with the covariate values at which threshold values are required.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.bnp_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the AROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the covariate-adjusted ROC curve (AROC) using the nonparametric Bayesian approach proposed by Inacio de Carvalho and Rodriguez-Alvarez (2018) involves the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{X}_{\bar{D}}) = Pr\{Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}}\}.</code>
</p>

<p>This function makes use of this estimate in order to calculate AROC-based threshold values. In particular, for a covariate value <code class="reqn">\mathbf{x}</code> and a FPF = t, the AROC-based threshold value at the <code class="reqn">s</code>-th posterior sample (<code class="reqn">s = 1,\ldots,S</code>) is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{(s)}_{\mathbf{x}} = \hat{F}^{-1(s)}_{\bar{D}}(1-t|\mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>from which the posterior mean can be computed
</p>
<p style="text-align: center;"><code class="reqn">\hat{c}_{\mathbf{x}} = \frac{1}{S}\sum_{s = 1}^{S}c^{(s)}_{\mathbf{x}}.</code>
</p>



<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>thresholds.est</code></td>
<td>
<p>A matrix with the posterior mean of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
<tr><td><code>thresholds.ql</code></td>
<td>
<p>A matrix with the posterior 2.5% quantile of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
<tr><td><code>thresholds.qh</code></td>
<td>
<p>A matrix with the posterior 97.5% quantile of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)


m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

# Compute the threshold values
FPF = c(0.1, 0.3)
newdata &lt;- data.frame(age = seq(52, 80, l = 50))

th_bnp &lt;- compute.threshold.AROC.bnp(m0, newdata, FPF)
names(th_bnp)


</code></pre>

<hr>
<h2 id='compute.threshold.AROC.bsp'>
AROC-based threshold values.
</h2><span id='topic+compute.threshold.AROC.bsp'></span>

<h3>Description</h3>

<p>Estimates AROC-based threshold values using the semiparametric Bayesian normal linear regression model discussed in Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.AROC.bsp(object, newdata, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.AROC.bsp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.bsp_+3A_newdata">newdata</code></td>
<td>
<p>Data frame with the covariate values at which threshold values are required.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.bsp_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the AROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the covariate-adjusted ROC curve (AROC) using the semiparametric Bayesian normal linear regression model discussed in Inacio de Carvalho and Rodriguez-Alvarez (2018) involves the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{X}_{\bar{D}}) = Pr\{Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}}\}.</code>
</p>

<p>This function makes use of this estimate in order to calculate AROC-based threshold values. In particular, for a covariate value <code class="reqn">\mathbf{x}</code> and a FPF = t, the AROC-based threshold value at the <code class="reqn">s</code>-th posterior sample (<code class="reqn">s = 1,\ldots,S</code>) is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{(s)}_{\mathbf{x}} = \hat{F}^{-1(s)}_{\bar{D}}(1-t|\mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>from which the posterior mean can be computed
</p>
<p style="text-align: center;"><code class="reqn">\hat{c}_{\mathbf{x}} = \frac{1}{S}\sum_{s = 1}^{S}c^{(s)}_{\mathbf{x}}.</code>
</p>



<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>thresholds.est</code></td>
<td>
<p>A matrix with the posterior mean of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
<tr><td><code>thresholds.ql</code></td>
<td>
<p>A matrix with the posterior 2.5% quantile of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
<tr><td><code>thresholds.qh</code></td>
<td>
<p>A matrix with the posterior 97.5% quantile of the AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bsp">AROC.bsp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m1 &lt;- AROC.bsp(formula.healthy = l_marker1 ~ age,
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, nsim = 5000, nburn = 1500)

# Compute the threshold values
FPF = c(0.1, 0.3)
newdata &lt;- data.frame(age = seq(52, 80, l = 50))

th_bsp &lt;- compute.threshold.AROC.bsp(m1, newdata, FPF)
names(th_bsp)


</code></pre>

<hr>
<h2 id='compute.threshold.AROC.kernel'>
AROC-based threshold values.
</h2><span id='topic+compute.threshold.AROC.kernel'></span>

<h3>Description</h3>

<p>Estimates AROC-based threshold values using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.AROC.kernel(object, newcovariate, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.AROC.kernel_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.kernel_+3A_newcovariate">newcovariate</code></td>
<td>
<p>Numeric vector with the covariate values at which threshold values are required.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.kernel_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the AROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the covariate-adjusted ROC curve (AROC) using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011) involves the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|X_{\bar{D}}) = Pr\{Y_{\bar{D}} \leq y | X_{\bar{D}}\}.</code>
</p>

<p>This function makes use of this estimate in order to calculate AROC-based threshold values. In particular, for a covariate value <code class="reqn">x</code> and a FPF = t, the AROC-based threshold value is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">\hat{c}_{\mathbf{x}} = \hat{F}^{-1}_{\bar{D}}(1-t|\mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>



<h3>Value</h3>

<p>A matrix with the computed AROC-based threshold values. The matrix has as many columns as different covariate values, and as many rows as different FPFs.</p>


<h3>References</h3>

<p>Hayfield, T., and Racine, J. S.(2008). Nonparametric Econometrics: The np Package. Journal of Statistical Software 27(5). URL http://www.jstatsoft.org/v27/i05/.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, 21(4), 483 - 499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.kernel">AROC.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m2 &lt;- AROC.kernel(marker = "l_marker1", covariate = "age",
group = "status", tag.healthy = 0, data = newpsa, 
p = seq(0,1,l=101), B = 500)

# Compute the threshold values
cov.values &lt;- seq(52, 80, l = 50)
FPF = c(0.1, 0.3)

th_np &lt;- compute.threshold.AROC.kernel(m2, cov.values, FPF)


</code></pre>

<hr>
<h2 id='compute.threshold.AROC.sp'>
AROC-based threshold values.
</h2><span id='topic+compute.threshold.AROC.sp'></span>

<h3>Description</h3>

<p>Estimates AROC-based threshold values using the semiparametric approach proposed by Janes and Pepe (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.AROC.sp(object, newdata, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.AROC.sp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.sp">AROC.sp</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.sp_+3A_newdata">newdata</code></td>
<td>
<p>Data frame with the covariate values at which threshold values are required.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC.sp_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the AROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the covariate-adjusted ROC curve (AROC) using the semiparametric approach proposed by Janes and Pepe (2009) involves the estimation of the conditional distribution function for the diagnostic test outcome in the healthy population
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{X}_{\bar{D}}) = Pr\{Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}}\}.</code>
</p>

<p>This function makes use of this estimate in order to calculate AROC-based threshold values. In particular, for a covariate value <code class="reqn">\mathbf{x}</code> and a FPF = t, the AROC-based threshold value is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">\hat{c}_{\mathbf{x}} = \hat{F}^{-1}_{\bar{D}}(1-t|\mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>
  


<h3>Value</h3>

<p>A matrix with the computed AROC-based threshold values. The matrix has as many columns as different covariate vector values, and as many rows as different FPFs.</p>


<h3>References</h3>

<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, 96(2), 371 - 382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.sp">AROC.sp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m3 &lt;- AROC.sp(formula.healthy = l_marker1 ~ age,
group = "status", tag.healthy = 0, data = newpsa,
p = seq(0,1,l=101), B = 500)

FPF = c(0.1, 0.3)
newdata &lt;- data.frame(age = seq(52, 80, l = 50))

th_sp &lt;- compute.threshold.AROC.sp(m3, newdata, FPF)
names(th_sp)


</code></pre>

<hr>
<h2 id='compute.threshold.pooledROC.BB'>
Pooled ROC-based threshold values.
</h2><span id='topic+compute.threshold.pooledROC.BB'></span>

<h3>Description</h3>

<p>Estimates pooled ROC-based threshold values using the Bayesian bootstrap estimator proposed by Gu et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.pooledROC.BB(object, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.pooledROC.BB_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC.BB_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the pooled ROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>thresholds</code></td>
<td>
<p>A matrix with the posterior mean and posterior 2.5% and 97.5% quantiles of the pooled ROC-based threshold values. The matrix has as many rows as different FPFs.</p>
</td></tr>
<tr><td><code>FPF</code></td>
<td>
<p>the supplied FPF argument</p>
</td></tr>
<tr><td><code>TPF</code></td>
<td>
<p>TPFs corresponding to the estimated threshold. In addition to the posterior mean, the 95% pointwise credible band is also returned.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, J., Ghosal, S., and Roy, A. (2008). Bayesian bootstrap estimation of ROC curve. Statistics in Medicine, <b>27</b>, 5407&ndash;5420.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)


m0_BB &lt;- pooledROC.BB(y0 = newpsa$l_marker1[newpsa$status == 0], 
            y1 = newpsa$l_marker1[newpsa$status == 1], p = seq(0,1,l=101), B = 5000)

### Threshold values for a fixed FPF
th_m0_BB &lt;- compute.threshold.pooledROC.BB(m0_BB, FPF = 0.1)

th_m0_BB$threshold

</code></pre>

<hr>
<h2 id='compute.threshold.pooledROC.emp'>
Pooled ROC-based threshold values.
</h2><span id='topic+compute.threshold.pooledROC.emp'></span>

<h3>Description</h3>

<p>Estimates pooled ROC-based threshold values using the empirical estimator proposed by Hsieh and Turnbull (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.pooledROC.emp(object, FPF = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.pooledROC.emp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC.emp_+3A_fpf">FPF</code></td>
<td>
<p>Numeric vector with the FPF at which to calculate the pooled ROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>thresholds</code></td>
<td>
<p>A vector with the estimated pooled ROC-based threshold values, one for each specified FPF.</p>
</td></tr>
<tr><td><code>FPF</code></td>
<td>
<p>the supplied FPF argument</p>
</td></tr>
<tr><td><code>TPF</code></td>
<td>
<p>TPFs corresponding to the estimated threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hsieh, F., and Turnbull, B.W. (1996). Nonparametric and semiparametric estimation of the receiver operating characteristic curve, The Annals of Statistics, <b>24</b>, 25&ndash;40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)


m0_emp &lt;- pooledROC.emp(y0 = newpsa$l_marker1[newpsa$status == 0], 
            y1 = newpsa$l_marker1[newpsa$status == 1], p = seq(0,1,l=101), B = 500)

### Threshold values for a fixed FPF
th_m0_emp &lt;- compute.threshold.pooledROC.emp(m0_emp, FPF = 0.1)

th_m0_emp$threshold

</code></pre>

<hr>
<h2 id='paauccontrol'>
Partial area under the covariate-adjusted ROC curve (pAAUC).
</h2><span id='topic+paauccontrol'></span>

<h3>Description</h3>

<p>Used to set various parameters controlling the estimation of the partial area under the covariate-adjusted ROC curve (pAAUC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paauccontrol(compute = FALSE, value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paauccontrol_+3A_compute">compute</code></td>
<td>
<p>Logical value. If TRUE the partial area under the covariate-adjusted ROC curve (pAAUC) is estimated.</p>
</td></tr>
<tr><td><code id="paauccontrol_+3A_value">value</code></td>
<td>
<p>Numeric value. Pre-specified maximum false positive fraction (FPF) at which to calculate the pAAUC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by this function is used as a control argument of the <code><a href="#topic+AROC.bnp">AROC.bnp</a></code> and <code><a href="#topic+AROC.bsp">AROC.bsp</a></code> functions.
</p>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.</p>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. Technical report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code> and <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), paauc = list(compute = TRUE, value = 0.3),
compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

summary(m0)


</code></pre>

<hr>
<h2 id='plot.AROC'>
Default AROC plotting
</h2><span id='topic+plot.AROC'></span>

<h3>Description</h3>

<p>Takes a fitted <code>AROC</code> object produced by <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code> and plots the covariate-adjusted ROC curve (AROC) and associated area under the AROC (AAUC); or the pooled ROC curve and associated AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.AROC_+3A_x">x</code></td>
<td>
<p>an object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code></p>
</td></tr>
<tr><td><code id="plot.AROC_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

plot(m0)


</code></pre>

<hr>
<h2 id='pooledROC.BB'>
Bayesian bootstrap estimation of the pooled ROC curve.
</h2><span id='topic+pooledROC.BB'></span>

<h3>Description</h3>

<p>Estimates the pooled ROC curve using the Bayesian bootstrap estimator proposed by Gu et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.BB(y0, y1, p = seq(0, 1, l = 101), B = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.BB_+3A_y0">y0</code></td>
<td>
<p>Diagnostic test outcomes in the healthy group.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_y1">y1</code></td>
<td>
<p>Diagnostic test outcomes in the diseased group.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of Bayesian bootstrap resamples. By default 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding 95% credible intervals</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding 95% credible intervals.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, J., Ghosal, S., and Roy, A. (2008). Bayesian bootstrap estimation of ROC curve. Statistics in Medicine, 27(26), 5407 - 5420.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_BB &lt;- pooledROC.BB(newpsa$l_marker1[newpsa$status == 0],
newpsa$l_marker1[newpsa$status == 1], p = seq(0,1,l=101), B = 5000)

summary(m0_BB)

plot(m0_BB)


</code></pre>

<hr>
<h2 id='pooledROC.emp'>
Empirical estimation of the pooled ROC curve.
</h2><span id='topic+pooledROC.emp'></span>

<h3>Description</h3>

<p>Estimates the pooled ROC curve using the empirical estimator proposed by Hsieh and Turnbull (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.emp(y0, y1, p = seq(0, 1, l = 101), B = 500, 
	method = c("ncoutcome", "coutcome"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.emp_+3A_y0">y0</code></td>
<td>
<p>Diagnostic test outcomes in the healthy group.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_y1">y1</code></td>
<td>
<p>Diagnostic test outcomes in the diseased group.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. By default 500.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_method">method</code></td>
<td>
<p>A character string specifying if bootstrap resampling (for the confidence intervals) should be done with or without regard to the disease status (&ldquo;coutcome&rdquo; or &ldquo;noutcome&rdquo;). In both cases, a naive bootstrap is used. By default, the resampling is done conditionally on the disease status.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding 95% confidence intervals (if required)</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding 95% confidence intervals (if required).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hsieh, F., and Turnbull, B.W. (1996). Nonparametric and semiparametric estimation of the receiver operating characteristic curve, The Annals of Statistics, 24, 25-40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_emp &lt;- pooledROC.emp(newpsa$l_marker1[newpsa$status == 0],
newpsa$l_marker1[newpsa$status == 1], p = seq(0,1,l=101), B = 500)

summary(m0_emp)

plot(m0_emp)


</code></pre>

<hr>
<h2 id='predictive.checks.AROC.bnp'>
Posterior predictive checks.
</h2><span id='topic+predictive.checks.AROC.bnp'></span>

<h3>Description</h3>

<p>Implements posterior predictive checks. Compares a selected test statistic computed based on the diagnostic test outcome in the nondiseased group against the same test statistics computed based on generated data from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group obtained using a B-splines dependent Dirichlet process mixture model as described in Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive.checks.AROC.bnp(object, 
	statistics = c("min", "max", "kurtosis", "skewness"), devnew = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive.checks.AROC.bnp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.bnp">AROC.bnp</a></code>.</p>
</td></tr>
<tr><td><code id="predictive.checks.AROC.bnp_+3A_statistics">statistics</code></td>
<td>
<p>Character vector. Statistics to be used for the posterior predictive checking. By default, &quot;min&quot;, &quot;max&quot;, &quot;kurtosis&quot; and &quot;skewness&quot;</p>
</td></tr>
<tr><td><code id="predictive.checks.AROC.bnp_+3A_devnew">devnew</code></td>
<td>
<p>logical. If TRUE, each plot is depicted in a new graphic device.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following graphics are depicted: (1) histograms of the desired statistics computed from a number of simulated datasets drawn from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group. In these plots, the estimated statistics from the observed diagnostic test outcome in the nondiseased group are also depicted. (2) Kernel density estimates computed from a number of simulated datasets drawn from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group. In these plots, the kernel density estimate of the observed diagnostic test outcome in the nondiseased group is also depicted. For a detailed discussion about predictive checks, see Gabry et al. (2017).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>yrep</code></td>
<td>
<p>Matrix. Each column corresponds to a dataset generated from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group.</p>
</td></tr>
<tr><td><code>y0</code></td>
<td>
<p>Numeric vector. Observed diagnostic test outcome in the nondiseased group.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gabry, J., Simpson, D., Vehtari, A., Betancourt, M., and Gelman, A. (2017). Visualization in Bayesian workflow. arXiv preprint arXiv:1709.01449.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

predictive.checks.AROC.bnp(m0, statistics = "skewness")


</code></pre>

<hr>
<h2 id='predictive.checks.AROC.bsp'>
Posterior predictive checks.
</h2><span id='topic+predictive.checks.AROC.bsp'></span>

<h3>Description</h3>

<p>Implements posterior predictive checks. Compares a selected test statistic computed based on the diagnostic test outcome in the nondiseased group against the same test statistics computed based on generated data from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group obtained using a Bayesian normal linear regression model as discussed in Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive.checks.AROC.bsp(object, 
	statistics = c("min", "max", "median", "skewness"), devnew = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive.checks.AROC.bsp_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>.</p>
</td></tr>
<tr><td><code id="predictive.checks.AROC.bsp_+3A_statistics">statistics</code></td>
<td>
<p>Character vector. Statistics to be used for the posterior predictive checking. By default, &quot;min&quot;, &quot;max&quot;, &quot;median&quot; and &quot;skewness&quot;</p>
</td></tr>
<tr><td><code id="predictive.checks.AROC.bsp_+3A_devnew">devnew</code></td>
<td>
<p>logical. If TRUE, each plot is depicted in a new graphic device.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following graphics are depicted: (1) histograms of the desired test statistics computed from a number of simulated datasets drawn from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group. In these plots, the estimated statistics from the observed diagnostic test outcome in the nondiseased group are also depicted. (2) Kernel density estimates computed from a number of simulated datasets drawn from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group. In these plots, the kernel density estimate of the observed diagnostic test outcome in the nondiseased group is also depicted. For a detailed discussion about predictive checks, see Gabry et al. (2017).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>yrep</code></td>
<td>
<p>Matrix. Each column corresponds to a dataset generated from the posterior predictive distribution of the diagnostic test outcome in the nondiseased group.</p>
</td></tr>
<tr><td><code>y0</code></td>
<td>
<p>Numeric vector. Observed diagnostic test outcome in the nondiseased group.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gabry, J., Simpson, D., Vehtari, A., Betancourt, M., and Gelman, A. (2017). Visualization in Bayesian workflow. arXiv preprint arXiv:1709.01449.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bsp">AROC.bsp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m1 &lt;- AROC.bsp(formula.healthy = l_marker1 ~ age,
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, nsim = 5000, nburn = 1500)

predictive.checks.AROC.bsp(m1, statistics = "mean")


</code></pre>

<hr>
<h2 id='print.AROC'>
Print method for <code>AROC</code> objects
</h2><span id='topic+print.AROC'></span>

<h3>Description</h3>

<p>Default print method for objects fitted with <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.AROC_+3A_x">x</code></td>
<td>
<p>an object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code></p>
</td></tr>
<tr><td><code id="print.AROC_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed including: TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

m0


</code></pre>

<hr>
<h2 id='psa'>
Prostate specific antigen (PSA) biomarker study.
</h2><span id='topic+psa'></span>

<h3>Description</h3>

<p>The dataset contains 71 prostate cases and 71 controls who participated in a lung cancer prevention trial (CARET, Beta-carotene and retinol trial). For details, see  Etzioni et al. (1999) and Pepe (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("psa")</code></pre>


<h3>Format</h3>

<p>A data frame with 683 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Patient identifier.</p>
</dd>
<dt><code>marker1</code></dt><dd><p>total prostate specific antigen (PSA).</p>
</dd>
<dt><code>marker2</code></dt><dd><p>free prostate specific antigen (PSA)</p>
</dd>
<dt><code>status</code></dt><dd><p>presence/absence of prostate cancer. The non-cancer patients are controls matched to cases on age and number of serum samples available for analysis (see Details).</p>
</dd>
<dt><code>age</code></dt><dd><p>patient age at blood draw (serum sample).</p>
</dd>
<dt><code>t</code></dt><dd><p>time (years) relative to prostate cancer diagnosis.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The CARET enrolled 12000 men, aged between 50 and 65 years, at high risk of lung cancer. For each subject on the study, serum samples were drawn at baseline and at two-year intervals after that. The data presented here represent a subsample of the original sample, and it was reported by Etzioni et al. (1999). It contains 71 cases of prostate cancer that occurred during the study. All these cases had, at least, three and up to eight serum samples. As far as controls are concerned, they were selected from the participants of the CARET study verifying that they had not been diagnosed with prostate cancer by the time of the original study, and the selection was done by matching to cases on date of birth and number of serum samples available for analysis.
</p>


<h3>Source</h3>

<p>The dataset can be downloaded from <a href="https://research.fredhutch.org/diagnostic-biomarkers-center/en/datasets.html">https://research.fredhutch.org/diagnostic-biomarkers-center/en/datasets.html</a>.
</p>


<h3>References</h3>

<p>Pepe, M. S. (2003). The Statistical Evaluation of Medical Tests for Classification and Prediction. Oxford Statistical Science Series. Oxford University Press, New York. 
</p>
<p>Etzioni, R., Pepe, M. S., Longton, G., Hu. C., and Goodman, G. (1999). Incorporating the time dimension in receiver operating characteristic curves: A case study of prostate cancer. Medical Decision Making, 19(3), 242-251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(psa)
summary(psa)
</code></pre>

<hr>
<h2 id='summary.AROC'>
Summary method for <code>AROC</code> objects
</h2><span id='topic+summary.AROC'></span>

<h3>Description</h3>

<p>Default summary method for objects fitted with <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.AROC_+3A_object">object</code></td>
<td>
<p>an object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.bsp()</code>, <code>AROC.sp()</code>, <code>AROC.kernel()</code>, <code>pooledROC.BB()</code> or <code>pooledROC.emp()</code></p>
</td></tr>
<tr><td><code id="summary.AROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed including the area under the covariate-adjusted ROC curve (AAUC) or the area under the pooled ROC curve (AUC), and if required, the partial area under the covariate-adjusted ROC curve (pAAUC). For the Bayesian methods, and if required, the function also provides the log pseudo marginal likelihood (LPML) and/or widely applicable information criterion (WAIC).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.bsp">AROC.bsp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code> or <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(AROC)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.healthy = l_marker1 ~ f(age, K = 0),
group = "status", tag.healthy = 0, data = newpsa, scale = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
a = 2, b = 0.5, L = 10, nsim = 5000, nburn = 1000)

summary(m0)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
