<!DOCTYPE html><html><head><title>Help for package ads</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ads}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ads-internal'><p>Internal ads functions</p></a></li>
<li><a href='#Allogny'><p>Spatial pattern of oaks suffering from frost shake in Allogny, France.</p></a></li>
<li><a href='#area.swin'><p>Area of a sampling window</p></a></li>
<li><a href='#BPoirier'><p>Tree spatial pattern in Beau Poirier plot, Haye forest, France</p></a></li>
<li><a href='#Couepia'><p>Spatial pattern of Couepia caryophylloides in Paracou, a canopy tree species of French Guiana.</p></a></li>
<li><a href='#demopat'><p>Artificial Data Point Pattern from <code>spatstat.data</code> package.</p></a></li>
<li><a href='#dval'><p>Multiscale local density of a spatial point pattern</p></a></li>
<li><a href='#inside.swin'><p>Test whether points are inside a sampling window</p></a></li>
<li><a href='#k12fun'><p>Multiscale second-order neighbourhood analysis of a bivariate spatial point pattern</p></a></li>
<li><a href='#k12val'><p>Multiscale local second-order neighbour density of a bivariate spatial point pattern</p></a></li>
<li><a href='#kdfun'><p>Multiscale second-order neighbourhood analysis of a spatial phylogenetic or functional community pattern from fully mapped data</p></a></li>
<li><a href='#kfun'><p>Multiscale second-order neighbourhood analysis of an univariate spatial point pattern</p></a></li>
<li><a href='#kmfun'><p>Multiscale second-order neighbourhood analysis of a marked spatial point pattern</p></a></li>
<li><a href='#kp.fun'><p> Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern</p></a></li>
<li><a href='#kpqfun'><p>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern</p></a></li>
<li><a href='#krfun'><p>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern using Rao quadratic entropy</p></a></li>
<li><a href='#ksfun'><p>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern using Simpson diversity</p></a></li>
<li><a href='#kval'><p>Multiscale local second-order neighbour density of a spatial point pattern</p></a></li>
<li><a href='#mimetic'><p>Univariate point pattern simulation by mimetic point process</p></a></li>
<li><a href='#Paracou15'><p>Tree spatial pattern in control plot 15, Paracou experimental station, French Guiana</p></a></li>
<li><a href='#plot.fads'><p>Plot second-order neighbourhood functions</p></a></li>
<li><a href='#plot.spp'><p>Plot a Spatial Point Pattern object</p></a></li>
<li><a href='#plot.vads'><p>Plot local density values</p></a></li>
<li><a href='#spp'><p>Creating a spatial point pattern</p></a></li>
<li><a href='#swin'><p>Creating a sampling window</p></a></li>
<li><a href='#triangulate'><p>Triangulate polygon</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Point Patterns Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://forge.ird.fr/amap/ads">https://forge.ird.fr/amap/ads</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://forge.ird.fr/amap/ads/-/issues">https://forge.ird.fr/amap/ads/-/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, spatstat.geom</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform first- and second-order multi-scale analyses derived from Ripley K-function (Ripley B. D. (1977) &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1977.tb01615.x">doi:10.1111/j.2517-6161.1977.tb01615.x</a>&gt;), for univariate,
 multivariate and marked mapped data in rectangular, circular or irregular shaped sampling windows, with tests of 
 statistical significance based on Monte Carlo simulations.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 17:56:18 UTC; lamonica</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphael Pelissier [aut],
  Francois Goreaud [aut],
  Dominique Lamonica [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominique Lamonica &lt;dominique.lamonica@ird.fr&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 07:40:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='ads-internal'>Internal ads functions</h2><span id='topic+adjust.marks.size'></span><span id='topic+area.poly'></span><span id='topic+convert'></span><span id='topic+convert2'></span><span id='topic+in.circle'></span><span id='topic+in.poly'></span><span id='topic+in.rectangle'></span><span id='topic+in.triangle'></span><span id='topic+is.poly'></span><span id='topic+overlap.poly'></span><span id='topic+overlap.trapez'></span><span id='topic+overlapping.polygons'></span><span id='topic+print.fads'></span><span id='topic+print.fads.k12fun'></span><span id='topic+print.fads.kfun'></span><span id='topic+print.fads.kp.fun'></span><span id='topic+print.fads.kpqfun'></span><span id='topic+print.fads.kmfun'></span><span id='topic+print.fads.ksfun'></span><span id='topic+print.fads.krfun'></span><span id='topic+print.vads'></span><span id='topic+print.vads.dval'></span><span id='topic+print.vads.k12val'></span><span id='topic+print.vads.kval'></span><span id='topic+read.tri'></span><span id='topic+sortmat'></span><span id='topic+summary.vads'></span><span id='topic+summary.vads.dval'></span><span id='topic+summary.vads.k12val'></span><span id='topic+summary.vads.kval'></span><span id='topic+testIC'></span><span id='topic+testInteger'></span><span id='topic+transpose'></span><span id='topic+subsetdist'></span>

<h3>Description</h3>

<p>Internal <code>ads</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.marks.size(marks,window,maxsize=NULL)
area.poly(xp, yp)
convert(x)
convert2(x)
in.circle(x, y, x0, y0, r0, bdry=TRUE)
in.poly(x, y, poly, bdry=FALSE)
in.rectangle(x, y, xmin, ymin, xmax, ymax, bdry=TRUE)
in.triangle(x, y, ax, ay, bx, by, cx, cy, bdry=TRUE)
is.poly(p)
overlap.poly(P, Q)
overlap.trapez(xa, ya, xb, yb, verb=FALSE)
overlapping.polygons(listpoly)
## S3 method for class 'fads'
print(x,...)
## S3 method for class 'vads'
print(x,...)
read.tri(X)
## S3 method for class 'vads'
summary(object,...)
sortmat(dis,ind)
subsetdist(dis,sub)
testIC(nbSimu, lev)
testInteger(i)
transpose(x, y)
</code></pre>


<h3>Details</h3>

<p>These are usually not to be called by the user.
</p>

<hr>
<h2 id='Allogny'>Spatial pattern of oaks suffering from frost shake in Allogny, France.</h2><span id='topic+Allogny'></span>

<h3>Description</h3>

<p>Spatial pattern of sound and split oaks (<em>Quercus petraea</em>) suffering from frost shake in a 2.35-ha plot in Allogny, France.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Allogny)</code></pre>


<h3>Format</h3>

<p>A list with 4 components:<br />
<code>$rect   </code> is a vector of coordinates <code class="reqn">(xmin,ymin,xmax,ymax)</code> of the origin and the opposite corner of a 125 by 188 m square plot.<br />
<code>$trees  </code> is a list of tree coordinates <code class="reqn">(x,y)</code>.<br />
<code>$status </code> is a factor with 2 levels <code class="reqn">("splited","sound")</code>.<br />
</p>


<h3>Source</h3>

<p>Grandjean, G., Jabiol, B., Bruchiamacchie, M. and Roustan, F. 1990. <em>Recherche de correlations entre les parametres edaphiques, et plus specialement texture, hydromorphie et drainage interne, et la reponse individuelle des chenes sessiles et pedoncules ? la gelivure.</em> Rapport de recherche ENITEF, Nogent sur Vernisson, France.
</p>


<h3>References</h3>

<p>Goreaud, F. &amp; Pelissier, R. 2003. Avoiding misinterpretation of biotic interactions with the intertype <em>K12</em>-function: population independence vs. random labelling hypotheses. <em>Journal of Vegetation Science</em>, 14: 681-692.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Allogny)
allo.spp &lt;- spp(Allogny$trees, mark=Allogny$status, window=Allogny$rect)
plot(allo.spp)
</code></pre>

<hr>
<h2 id='area.swin'>Area of a sampling window</h2><span id='topic+area.swin'></span>

<h3>Description</h3>

<p>Function <code>area.swin</code> computes the area of a sampling window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.swin(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.swin_+3A_w">w</code></td>
<td>
<p>an object of class <code>"swin"</code> defining the sampling window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>"simple"</code> sampling windows, returns simply the area of the rectangle or circle delineating the study region.<br />
For <code>"complex"</code> sampling windows, returns the area of the initial rectangle or circle, minus the total area of the 
triangles to remove (see <code><a href="#topic+swin">swin</a></code>).
</p>


<h3>Value</h3>

<p>The area of the sampling window.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swin">swin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: rectangle of size [0,110] x [0,90]
  wr&lt;-swin(c(0,0,110,90))
  area.swin(wr)
  
  ## Not run: circle with radius 50 centred on (55,45)
  wc&lt;-swin(c(55,45,50))
  area.swin(wc)
  
 ## Not run: polygon (diamond shape)
 t1 &lt;- c(0,0,55,0,0,45)
 t2 &lt;- c(55,0,110,0,110,45)
 t3 &lt;- c(0,45,0,90,55,90)
 t4 &lt;- c(55,90,110,90,110,45)
 wp &lt;- swin(wr, rbind(t1,t2,t3,t4))
 area.swin(wp)
</code></pre>

<hr>
<h2 id='BPoirier'>Tree spatial pattern in Beau Poirier plot, Haye forest, France</h2><span id='topic+BPoirier'></span>

<h3>Description</h3>

<p>Spatial pattern of 162 beeches, 72 oaks and 3 hornbeams in a 1-ha 140 yr-old temperate forest plot in Haye, France. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BPoirier)</code></pre>


<h3>Format</h3>

<p>A list with 8 components:<br />
<code>$rect    </code> is a vector of coordinates <code class="reqn">(xmin,ymin,xmax,ymax)</code> of the origin and the opposite corner of a 110 by 90 m rectangular plot.<br />
<code>$tri1    </code> is a list of vertex coordinates <code class="reqn">(ax,ay,bx,by,cx,cy)</code> of contiguous triangles covering the denser part of the plot.<br />
<code>$tri2    </code> is a list of vertex coordinates <code class="reqn">(ax,ay,bx,by,cx,cy)</code> of contiguous triangles covering the sparser part of the plot.<br />
<code>$poly1   </code> is a list of vertex coordinates <code class="reqn">(x,y)</code> of the polygon enclosing <code>BPoirier$tri1</code>.<br />
<code>$poly2   </code> is a list of two polygons vertex coordinates <code class="reqn">(x,y)</code> enclosing <code>BPoirier$tri2</code>.<br />
<code>$trees   </code> is a list of tree coordinates <code class="reqn">(x,y)</code>.<br />
<code>$species </code> is a factor with 3 levels <code class="reqn">("beech","oak","hornbeam")</code> corresponding to species names of the trees.<br />
<code>$dbh     </code> is a vector of tree size (diameter at breast height in cm). 
</p>


<h3>Source</h3>

<p>Parde, J. 1981. De 1882 a 1976/80 : les places d'experience de sylviculture du hetre en foret domaniale de Haye. <em>Revue Forestiere Francaise</em>, 33: 41-64.
</p>


<h3>References</h3>

<p>Goreaud, F. 2000. <em>Apports de l'analyse de la structure spatiale en foret temperee a l'etude et la modelisation des peuplements complexes</em>. These de doctorat, ENGREF, Nancy, France.<br /><br />
Pelissier, R. &amp; Goreaud, F. 2001. A practical approach to the study of spatial structure in simple cases of heterogeneous vegetation. <em>Journal of Vegetation Science</em>, 12: 99-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BPoirier)
BP.spp &lt;- spp(BPoirier$trees, mark=BPoirier$species, window=BPoirier$rect)
plot(BP.spp)
</code></pre>

<hr>
<h2 id='Couepia'>Spatial pattern of Couepia caryophylloides in Paracou, a canopy tree species of French Guiana.</h2><span id='topic+Couepia'></span>

<h3>Description</h3>

<p>Spatial pattern of 34 mature individuals and 173 young individuals of the tree species <em>Couepia caryophylloides</em> (Chrysobalanaceae) in a 25-ha forest plot in Paracou, French Guiana.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Couepia)</code></pre>


<h3>Format</h3>

<p>A list with 4 components:<br />
<code>$rect  </code> is a vector of coordinates <code class="reqn">(xmin,ymin,xmax,ymax)</code> of the origin and the opposite corner of a 500 by 500 m rectangular plot.<br />
<code>$tri   </code> is a list of vertex coordinates <code class="reqn">(ax,ay,bx,by,cx,cy)</code> of contiguous triangles covering swampy parts of the plot.<br />
<code>$trees </code> is a list of tree coordinates <code class="reqn">(x,y)</code>.<br />
<code>$stage </code> is a factor with 2 levels <code class="reqn">("mature","young")</code>.<br />
</p>


<h3>Source</h3>

<p>Collinet, F. 1997. <em>Essai de regroupement des principales especes structurantes d'une foret dense humide d'apres l'analyse de leur repartition spatiale (foret de Paracou - Guyane).</em> These de doctorat, Universite Claude Bernard, Lyon, France.
</p>


<h3>References</h3>

<p>Goreaud, F. &amp; P?Pelissier, R. 2003. Avoiding misinterpretation of biotic interactions with the intertype <em>K12</em>-function: population independence vs. random labelling hypotheses. <em>Journal of Vegetation Science</em>, 14: 681-692.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Couepia)
coca.spp &lt;- spp(Couepia$trees, mark=Couepia$stage, window=Couepia$rect, triangles=Couepia$tri)
plot(coca.spp)
</code></pre>

<hr>
<h2 id='demopat'>Artificial Data Point Pattern from <code>spatstat.data</code> package.</h2><span id='topic+demopat'></span>

<h3>Description</h3>

<p>This is an artificial dataset, for use in testing and demonstrating compatibility between <code>spatstat</code> and <code>ads</code> objects. It is a multitype point pattern in an irregular polygonal window.
There are two types of points. The window contains a polygonal hole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demopat)</code></pre>


<h3>Format</h3>

<p>An object of class &quot;ppp&quot; representing a <code>spatstat.core</code> point pattern.
</p>


<h3>Source</h3>

<p>data(demopat) in <code>spatstat.data</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(demopat)
	demo.spp&lt;-ppp2spp(demopat)
	plot(demo.spp)
</code></pre>

<hr>
<h2 id='dval'>Multiscale local density of a spatial point pattern</h2><span id='topic+dval'></span><span id='topic+print.dval'></span><span id='topic+summary.dval'></span><span id='topic+print.summary.dval'></span>

<h3>Description</h3>

<p>Computes local density estimates of a spatial point pattern, i.e. the number of points per unit area,
within sample circles of regularly increasing radii <code class="reqn">r</code>, centred at the nodes of
a grid covering a simple (rectangular or circular) or complex sampling window (see Details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dval(p, upto, by, nx, ny)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dval_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="dval_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="dval_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="dval_+3A_nx">nx</code>, <code id="dval_+3A_ny">ny</code></td>
<td>
<p>number of sample circles regularly spaced out in <code class="reqn">x</code> and <code class="reqn">y</code> directions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local density is estimated for a regular sequence of sample circles radii given by <code>seq(by,upto,by)</code> (see <code><a href="base.html#topic+seq">seq</a></code>).
The sample circles are centred at the nodes of a regular grid with size <code class="reqn">nx</code> by <code class="reqn">ny</code>. Ripley's edge effect correction is applied when 
the sample circles overlap boundary of the sampling window (see Ripley (1977) or Goreaud &amp; P?Pelissier (1999) for an extension to circular and complex 
sampling windows). Due to edge effect correction, <code>upto</code>, the maximum radius of the sample circles, is half the longer side for a rectangle sampling
window (i.e. <code class="reqn">0.5*max((xmax-xmin),(ymax-ymin))</code>) and the radius <code class="reqn">r0</code> for a circular sampling window (see <code><a href="#topic+swin">swin</a></code>).
</p>


<h3>Value</h3>

<p>A list of class <code>c("vads","dval")</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>a data frame of <code class="reqn">(nx*ny)</code> observations giving <code class="reqn">(x,y)</code> coordinates of the centres of the sample circles (the grid nodes).</p>
</td></tr>
<tr><td><code>cval</code></td>
<td>
<p>a matrix of size <code class="reqn">(nx*ny,length(r))</code> giving the estimated number of points of the pattern per sample circle with radius <code class="reqn">r</code>.</p>
</td></tr>
<tr><td><code>dval</code></td>
<td>
<p>a matrix of size <code class="reqn">(nx*ny,length(r))</code> giving the estimated number of points of the pattern per unit area per sample circle with radius <code class="reqn">r</code>.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>In its current version, function <code>dval</code> ignores the marks of multivariate and marked point patterns (they are all considered to be univariate patterns).
</p>


<h3>Note</h3>

<p>There are printing, summary and plotting methods for <code>"vads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Goreaud, F. and P?Pelissier, R. 1999. On explicit formula of edge effect correction for Ripley's <em>K</em>-function. <em>Journal of Vegetation Science</em>, 10:433-438.<br /><br />
P?Pelissier, R. and Goreaud, F. 2001. A practical approach to the study of spatial structure in simple cases of heterogeneous vegetation. <em>Journal of Vegetation Science</em>, 12:99-108.<br /><br />
Ripley, B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.vads">plot.vads</a></code>,
<code><a href="#topic+spp">spp</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swr &lt;- spp(BP$trees, win=BP$rect)
  dswr &lt;- dval(swr,25,1,11,9)
  summary(dswr)
  plot(dswr)
  
  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45))
  dswc &lt;- dval(swc,25,1,9,9)
  summary(dswc)
  plot(dswc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri1)
  dswrt &lt;- dval(swrt,25,1,11,9)
  summary(dswrt)
  plot(dswrt)
</code></pre>

<hr>
<h2 id='inside.swin'>Test whether points are inside a sampling window</h2><span id='topic+inside.swin'></span>

<h3>Description</h3>

<p>Function <code>inside.swin</code> tests whether points lie inside or outside a given sampling window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside.swin(x, y, w, bdry=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside.swin_+3A_x">x</code></td>
<td>
<p>a vector of <code>x</code> coordinates of points.</p>
</td></tr>
<tr><td><code id="inside.swin_+3A_y">y</code></td>
<td>
<p>a vector of <code>y</code> coordinates of points.</p>
</td></tr>
<tr><td><code id="inside.swin_+3A_w">w</code></td>
<td>
<p>an object of class <code>"swin"</code> (see <code><a href="#topic+swin">swin</a></code>) defining the sampling window.</p>
</td></tr>
<tr><td><code id="inside.swin_+3A_bdry">bdry</code></td>
<td>
<p>by default <code>bdry = TRUE</code>. If <code>FALSE</code>, points located 
on the boundary of the sampling window are considered to be outside.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector whose <code>ith</code> entry is <code>TRUE</code> if the corresponding point <code class="reqn">(x[i],y[i])</code> is inside w, <code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p>For <code>"complex"</code> sampling windows, points inside the triangles to remove or on their boundary, are considered outside.  
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swin">swin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  wr &lt;- swin(BP$rect)
  sum(inside.swin(BP$trees$x, BP$trees$y, wr))
  
  wc &lt;- swin(c(55,45,45))
  sum(inside.swin(BP$trees$x, BP$trees$y, wc))
  
  wrt &lt;- swin(BP$rect, triangles=BP$tri1)
  sum(inside.swin(BP$trees$x, BP$trees$y,wrt))
</code></pre>

<hr>
<h2 id='k12fun'>Multiscale second-order neighbourhood analysis of a bivariate spatial point pattern</h2><span id='topic+k12fun'></span>

<h3>Description</h3>

<p>Computes estimates of the intertype <em>K12</em>-function and associated neighbourhood functions from a bivariate spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypotheses of population independence or random labelling (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k12fun(p, upto, by, nsim=0, H0=c("pitor","pimim","rl"), prec=0.01, nsimax=3000, conv=50,
 rep=10, alpha=0.01,  marks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k12fun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a multivariate spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="k12fun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="k12fun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="k12fun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the selected null hypothesis (see Details).
By default <code>nsim=0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_h0">H0</code></td>
<td>
<p>one of <code>c("pitor","pimim","rl")</code> to select either the null hypothesis of population independence using toroidal shift (<code>H0="pitor"</code>) or mimetic point process (<code>H0="pimim"</code>), or of random labelling (<code>H0="rl"</code>) (see Details).
By default, the null hypothesis is population independence using toroidal shift.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_prec">prec</code></td>
<td>
<p>if <code>nsim&gt;0</code> and <code>H0="pitor"</code> or <code>H0="pimim"</code>, precision of the random vector or point coordinates generated during simulations. By default <code>prec=0.01</code>.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_nsimax">nsimax</code></td>
<td>
<p>if <code>nsim&gt;0</code> and <code>H0="pimim"</code>, maximum number of simulations allowed (see <code><a href="#topic+mimetic">mimetic</a></code>. By default <code>nsimax=3000</code>.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_conv">conv</code></td>
<td>
<p>if <code>nsim&gt;0</code> and <code>H0="pimim"</code>, convergence criterion (see <code><a href="#topic+mimetic">mimetic</a></code>. By default <code>conv=50</code>.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_rep">rep</code></td>
<td>
<p>if <code>nsim&gt;0</code> and <code>H0="pimim"</code>, controls for convergence failure of the mimetic point process (see details). By default <code>rep=10</code> so that the function aborts after 10 consecutive failures in mimetic point process convergence.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha=0.01</code>.</p>
</td></tr>
<tr><td><code id="k12fun_+3A_marks">marks</code></td>
<td>
<p>by default c(1,2), otherwise a vector of two numbers or character strings identifying the types (the <code>p$marks</code> levels)
of points of type 1 and 2, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>k12fun</code> computes the intertype <code class="reqn">K12(r)</code> function of second-order neighbourhood analysis and the associated functions <code class="reqn">g12(r)</code>,
<code class="reqn">n12(r)</code> and <code class="reqn">L12(r)</code>.<br /><br />
For a homogeneous isotropic bivariate point process of intensities <code class="reqn">\lambda1</code> and <code class="reqn">\lambda2</code>,
the second-order property could be characterized by a function <code class="reqn">K12(r)</code> (Lotwick &amp; Silverman 1982), so that the expected
number of neighbours of type 2 within a distance <code class="reqn">r</code> of an arbitrary point of type 1 is:
<code class="reqn">N12(r) = \lambda2*K12(r)</code>.<br /><br />
<code class="reqn">K12(r)</code> is an intensity standardization of <code class="reqn">N12(r)</code>: <code class="reqn">K12(r) = N12(r)/\lambda2</code>.<br /><br />
<code class="reqn">n12(r)</code> is an area standardization of of <code class="reqn">N12(r)</code>: <code class="reqn">n12(r) = N12(r)/(\pi*r^2)</code>, where <code class="reqn">\pi*r^2</code> is the area of the disc of radius <code class="reqn">r</code>.<br /><br />
<code class="reqn">L12(r)</code> is a linearized version of <code class="reqn">K12(r)</code>, which has an expectation of 0 under population independence: <code class="reqn">L12(r) = \sqrt(K12(r)/\pi)-r</code>. <code class="reqn">L12(r)</code> becomes positive when the two population show attraction and negative when they show repulsion.
Under the null hypothesis of random labelling, the expectation of <code class="reqn">L12(r)</code> is <code class="reqn">L(r)</code>. It becomes greater than <code class="reqn">L(r)</code> when the types tend to be positively correlated and lower when they tend to be negatively correlated.<br /><br />
<code class="reqn">g12(r)</code> is the derivative of <code class="reqn">K12(r)</code> or bivariate pair density function, so that the expected
number of points of type 2 at a distance <code class="reqn">r</code> of an arbitrary point of type 1 (i.e. within an annuli between two successive circles with radii <code class="reqn">r</code> and <code class="reqn">r-by</code>) is:
<code class="reqn">O12(r) = \lambda2*g12(r)</code> (Wiegand &amp; Moloney 2004).<br /><br />
</p>
<p>The program introduces an edge effect correction term according to the method proposed by Ripley (1977)
and extended to circular and complex sampling windows by Goreaud &amp; Pelissier (1999).<br /><br />
</p>
<p>Theoretical values under the null hypothesis of either population independence or random labelling as well as
local Monte Carlo confidence limits and p-values of departure from the null hypothesis (Besag &amp; Diggle 1977) are estimated at each distance <code class="reqn">r</code>.<br />
</p>
<p>The population independence hypothesis assumes that the location of points of a given population is independent from the location 
of points of the other. It is therefore tested conditionally to the intrinsic spatial pattern of each population. Two different procedures are available:
<code>H0="pitor"</code> just shifts the pattern of type 1 points around a torus following Lotwick &amp; Silverman (1982); <code>H0="pimim"</code> uses a mimetic point process (Goreaud et al. 2004)
to mimic the pattern of type 1 points (see <code><a href="#topic+mimetic">mimetic</a></code>.<br />
The random labelling hypothesis <code>"rl"</code> assumes that the probability to bear a given mark is the same for all points of the pattern and
doesn't depends on neighbours. It is therefore tested conditionally to the whole spatial pattern, by randomizing the marks over the points'
locations kept unchanged (see Goreaud &amp; Pelissier 2003 for further details). 
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>g12</code></td>
<td>
<p>a data frame containing values of the bivariate pair density function <code class="reqn">g12(r)</code>.</p>
</td></tr>
<tr><td><code>n12</code></td>
<td>
<p>a data frame containing values of the bivariate local neighbour density function <code class="reqn">n12(r)</code>.</p>
</td></tr>
<tr><td><code>k12</code></td>
<td>
<p>a data frame containing values of the intertype function <code class="reqn">K12(r)</code>.</p>
</td></tr>
<tr><td><code>l12</code></td>
<td>
<p>a data frame containing values of the modified intertype function <code class="reqn">L12(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the selected null hypothesis.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of the selected null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of the selected null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from the selected null hypothesis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Besag J.E. &amp; Diggle P.J. 1977. Simple Monte Carlo tests spatial patterns. <em>Applied Statistics</em>, 26:327-333.<br /><br />
Goreaud F. &amp; Pelissier R. 1999. On explicit formulas of edge effect correction for Ripley's K-function. <em>Journal of Vegetation Science</em>, 10:433-438.<br /><br />
Goreaud, F. &amp; Pelissier, R. 2003. Avoiding misinterpretation of biotic interactions with the intertype <em>K12</em>-function: population independence vs. random labelling hypotheses. <em>Journal of Vegetation Science</em>, 14: 681-692.<br /><br />
Lotwick, H.W. &amp; Silverman, B.W. 1982. Methods for analysing spatial processes of several types of points. <em>Journal of the Royal Statistical Society B</em>, 44:403-413.<br /><br />
Ripley B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-192.<br /><br />
Wiegand, T. &amp; Moloney, K.A. 2004. Rings, circles, and null-models for point pattern analysis in ecology. <em>Oikos</em>, 104:209-229.
Goreaud F., Loussier, B., Ngo Bieng, M.-A. &amp; Allain R. 2004. Simulating realistic spatial structure for forest stands: a mimetic point process. In <em>Proceedings of Interdisciplinary Spatial Statistics Workshop</em>, 2-3 December, 2004. Paris, France.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+k12val">k12val</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+kijfun">kijfun</a></code>,
<code><a href="#topic+ki.fun">ki.fun</a></code>,
<code><a href="#topic+mimetic">mimetic</a></code>,
<code><a href="#topic+kmfun">kmfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
  #testing population independence hypothesis
  k12swrm.pi &lt;- k12fun(swrm, 25, 1, 500, marks=c("beech","oak"))
  plot(k12swrm.pi)
  #testing random labelling hypothesis
  k12swrm.rl &lt;- k12fun(swrm, 25, 1, 500, H0="rl", marks=c("beech","oak"))
  plot(k12swrm.rl)

  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45), marks=BP$species)
  k12swc.pi &lt;- k12fun(swc, 25, 1, 500, marks=c("beech","oak"))
  plot(k12swc.pi)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt.rl &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri2, marks=BP$species)
  k12swrt.rl &lt;- k12fun(swrt.rl, 25, 1, 500, H0="rl",marks=c("beech","oak"))
  plot(k12swrt.rl)
  ## Not run: testing population independence hypothesis requires minimizing the outer polygon
  xr&lt;-range(BP$tri3$ax,BP$tri3$bx,BP$tri3$cx)
  yr&lt;-range(BP$tri3$ay,BP$tri3$by,BP$tri3$cy)
  rect.min&lt;-swin(c(xr[1], yr[1], xr[2], yr[2]))
  swrt.pi &lt;- spp(BP$trees, window = rect.min, triangles = BP$tri3, marks=BP$species)
  k12swrt.pi &lt;- k12fun(swrt.pi, 25, 1, nsim = 500, marks = c("beech", "oak"))
  plot(k12swrt.pi)
</code></pre>

<hr>
<h2 id='k12val'>Multiscale local second-order neighbour density of a bivariate spatial point pattern</h2><span id='topic+k12val'></span><span id='topic+print.k12val'></span><span id='topic+summary.k12val'></span><span id='topic+print.summary.k12val'></span>

<h3>Description</h3>

<p>Computes local second-order neighbour density estimates for a bivariate spatial point pattern, i.e. the number of neighbours of type 2 per unit area
within sample circles of regularly increasing radii <code class="reqn">r</code>, centred at each type 1 point of the pattern (see Details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> k12val(p, upto, by, marks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k12val_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a multivariate spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="k12val_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="k12val_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="k12val_+3A_marks">marks</code></td>
<td>
<p>by default <code>c(1,2)</code>, otherwise a vector of two numbers or character strings identifying the types (the <code>p$marks</code> levels)
of points of type 1 and 2, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>K12val</code> returns individual values of <em>K12(r)</em> and associated functions (see <code><a href="#topic+k12fun">k12fun</a></code>)
estimated at each type 1 point of the pattern. For a given distance <em>r</em>, these values can be mapped within the sampling window, as in
Getis &amp; Franklin 1987 or P?Pelissier &amp; Goreaud 2001. 
</p>


<h3>Value</h3>

<p>A list of class <code>c("vads","k12val")</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>a data frame with 2 components giving <code class="reqn">(x,y)</code> coordinates of type 1 points of the pattern.</p>
</td></tr>
<tr><td><code>g12val</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of the bivariate pair density function <code class="reqn">g12(r)</code>.</p>
</td></tr>
<tr><td><code>n12val</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of the bivariate neighbour density function <code class="reqn">n12(r)</code>.</p>
</td></tr>
<tr><td><code>k12val</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of the intertype function <code class="reqn">K12(r)</code>.</p>
</td></tr>
<tr><td><code>l12val</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values the modified intertype function <code class="reqn">L12(r)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing, summary and plotting methods for <code>"vads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>References</h3>

 
<p>Getis, A. and Franklin, J. 1987. Second-order neighborhood analysis of mapped point patterns. <em>Ecology</em>, 68:473-477.<br /><br />
P?Pelissier, R. and Goreaud, F. 2001. A practical approach to the study of spatial structure in simple cases of heterogeneous vegetation. <em>Journal of Vegetation Science</em>, 12:99-108.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+plot.vads">plot.vads</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+dval">dval</a></code>,
<code><a href="#topic+kval">kval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
  k12vswrm &lt;- k12val(swrm, 25, 1, marks=c("beech","oak"))
  summary(k12vswrm)
  plot(k12vswrm)
 
  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45), marks=BP$species)
  k12vswc &lt;- k12val(swc, 25, 1, marks=c("beech","oak"))
  summary(k12vswc)
  plot(k12vswc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri2, marks=BP$species)
  k12vswrt &lt;- k12val(swrt, 25, 1, marks=c("beech","oak"))
  summary(k12vswrt)
  plot(k12vswrt)
</code></pre>

<hr>
<h2 id='kdfun'>Multiscale second-order neighbourhood analysis of a spatial phylogenetic or functional community pattern from fully mapped data</h2><span id='topic+kdfun'></span>

<h3>Description</h3>

<p>Computes distance-dependent estimates of Shen et al. (2014) phylogenetic or functional mark correlation functions from a multivariate spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypothesis of species equivalence (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdfun(p, upto, by, dis, nsim=0, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kdfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kdfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="kdfun_+3A_dis">dis</code></td>
<td>
<p>a <code>"dist"</code> object defining Euclidean distances between species.</p>
</td></tr>
<tr><td><code id="kdfun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the null hypothesis of a random allocation of species distances (species equivalence; see Details).
By default <code>nsim = 0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="kdfun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha = 0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kdfun</code> computes Shen et al. (2014) <code class="reqn">Kd</code> and <em>gd</em>-functions. For a multivariate point pattern consisting of <code class="reqn">S</code> species with intensity <code class="reqn">\lambda</code>p, such functions can be estimated from the bivariate <code class="reqn">Kpq</code>-functions between each pair of different species <code class="reqn">p</code> and <code class="reqn">q</code>.
Function <code>kdfun</code> is thus a simple wrapper of <code><a href="#topic+k12fun">k12fun</a></code> (P?Pelissier &amp; Goreaud 2014):
</p>
<p><code class="reqn">Kd(r) = D * Kr(r) / HD * Ks(r) = D * sum(\lambda p * \lambda q * Kpq(r) * dpq) / HD * sum(\lambda p * \lambda q * Kpq(r))</code>.<br />
<code class="reqn">gd(r) = D * g(r) / HD * gs(r) = D * sum(\lambda p * \lambda q * gpq(r) * dpq) / HD * sum(\lambda p * \lambda q * gpq(r))</code>.<br /><br />
</p>
<p>where <code class="reqn">Ks(r)</code> and <code class="reqn">gs(r)</code> are distance-dependent versions of Simpson's diversity index, <code class="reqn">D</code> (see <code><a href="#topic+ksfun">ksfun</a></code>), <code class="reqn">Kr(r)</code> and <code class="reqn">gr(r)</code> are distance-dependent versions of Rao's diversity coefficient (see <code><a href="#topic+krfun">krfun</a></code>); 
<code class="reqn">dpq</code> is the distance between species <code class="reqn">p</code> and <code class="reqn">q</code> defined by matrix <code>dis</code>, typically a taxonomic, phylogenetic or functional distance. The advantage here is that as the edge effects vanish between <code class="reqn">Kr(r)</code> and <code class="reqn">Ks(r)</code>,
implementation is fast for a sampling window of any shape. <code class="reqn">Kd(r)</code> provides the expected phylogenetic or functional distance of two heterospecific individuals a distance less than <em>r</em> apart (Shen et al. 2014), while <code class="reqn">gd(r)</code> 
provides the same within an annuli between two consecutive distances of <em>r</em> and <em>r-by</em>.
</p>
<p>Theoretical values under the null hypothesis of species equivalence as well as local Monte Carlo confidence limits and p-values of departure from the null hypothesis (Besag &amp; Diggle 1977) are estimated at each distance <code class="reqn">r</code>, 
by randomizing the between-species distances, keeping the point locations and distribution of species labels unchanged. The theoretical expectations of <code class="reqn">gd(r)</code> and <code class="reqn">Kd(r)</code> are thus <code class="reqn">1</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>gd</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">gd(r)</code>.</p>
</td></tr>
<tr><td><code>kd</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">Kd(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the null hypothesis of species equivalence.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of a random distribution of the null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of a random distribution of the null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from the null hypothesis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Shen, G., Wiegand, T., Mi, X. &amp; He, F. (2014). Quantifying spatial phylogenetic structures of fully stem-mapped plant communities. <em>Methods in Ecology and Evolution</em>, 4, 1132-1141.
</p>
<p>P?Pelissier, R. &amp; Goreaud, F. ads package for R: A fast unbiased implementation of the K-function family for studying spatial point patterns in irregular-shaped sampling windows. <em>Journal of Statistical Software</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+ksfun">ksfun</a></code>,
<code><a href="#topic+krfun">krfun</a></code>,
<code><a href="ade4.html#topic+divc">divc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Paracou15)
  P15&lt;-Paracou15
  ## Not run: spatial point pattern in a rectangle sampling window of size 125 x 125
  swmr &lt;- spp(P15$trees, win = c(175, 175, 250, 250), marks = P15$species)
  ## Not run: testing the species equivalence hypothesis
  kdswmr &lt;- kdfun(swmr, dis = P15$spdist, 50, 2, 100)
  ## Not run: running more simulations is slow
  kdswmr &lt;- kdfun(swmr, dis = P15$spdist, 50, 2, 500)
  plot(kdswmr)

 ## Not run: spatial point pattern in a circle with radius 50 centred on (125,125)
  swmc &lt;- spp(P15$trees, win = c(125,125,50), marks = P15$species)
  kdswmc &lt;- kdfun(swmc, dis = P15$spdist, 50, 2, 100)
  ## Not run: running more simulations is slow
  kdswmc &lt;- kdfun(swmc, dis = P15$spdist, 50, 2, 500)
  plot(kdswmc)
  
 ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(P15$trees, win = c(125,125,250,250), tri = P15$tri, marks = P15$species)
  kdswrt &lt;- kdfun(swrt, dis = P15$spdist, 50, 2, 100)
  ## Not run: running simulations is slow
  kdswrt &lt;- kdfun(swrt, dis = P15$spdist, 50, 2, 500)
  plot(kdswrt)
</code></pre>

<hr>
<h2 id='kfun'>Multiscale second-order neighbourhood analysis of an univariate spatial point pattern</h2><span id='topic+kfun'></span>

<h3>Description</h3>

<p>Computes estimates of Ripley's <em>K</em>-function and associated neighbourhood functions from an univariate spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypothesis of Complete Spatial Randomness (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfun(p, upto, by, nsim=0, prec=0.01, alpha=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="kfun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the null hypothesis of complete spatial randomness (CSR) (see Details).
By default <code>nsim=0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="kfun_+3A_prec">prec</code></td>
<td>
<p>if <code>nsim&gt;0</code>, precision of points' coordinates generated during simulations. By default <code>prec=0.01</code>.</p>
</td></tr>
<tr><td><code id="kfun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha=0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kfun</code> computes Ripley's <code class="reqn">K(r)</code> function of second-order neighbourhood analysis and the associated functions <code class="reqn">g(r)</code>, <code class="reqn">n(r)</code> and <code class="reqn">L(r)</code>.<br /><br />
For a homogeneous isotropic point process of intensity <code class="reqn">\lambda</code>, Ripley (1977) showed that
the second-order property could be characterized by a function <code class="reqn">K(r)</code>, so that the expected
number of neighbours within a distance <code class="reqn">r</code> of an arbitrary point of the pattern is:
<code class="reqn">N(r) = \lambda*K(r)</code>.<br /><br />
<code class="reqn">K(r)</code> is a intensity standardization of <code class="reqn">N(r)</code>, which has an expectation of <code class="reqn">\pi*r^2</code> under the null hypothesis of CSR: <code class="reqn">K(r) = N(r)/\lambda</code>.<br /><br />
<code class="reqn">n(r)</code> is an area standardization of <code class="reqn">N(r)</code>, which has an expectation of <code class="reqn">\lambda</code> under the null hypothesis of CSR: <code class="reqn">n(r) = N(r)/(\pi*r^2)</code>, where <code class="reqn">\pi*r^2</code> is the area of the disc of radius <code class="reqn">r</code>.<br /><br />
<code class="reqn">L(r)</code> is a linearized version of <code class="reqn">K(r)</code> (Besag 1977), which has an expectation of 0 under the null hypothesis of CSR: <code class="reqn">L(r) = \sqrt(K(r)/\pi)-r</code>. <em>L(r)</em> becomes positive when the pattern tends to clustering and negative when it tends to regularity.<br /><br />
<code class="reqn">g(r)</code> is the derivative of <code class="reqn">K(r)</code> or pair density function (Stoyan et al. 1987), so that the expected
number of neighbours at a distance <code class="reqn">r</code> of an arbitrary point of the pattern (i.e. within an annuli between two successive circles with radii <code class="reqn">r</code> and <code class="reqn">r-by</code>) is:
<code class="reqn">O(r) = \lambda*g(r)</code>.<br /><br />
</p>
<p>The program introduces an edge effect correction term according to the method proposed by Ripley (1977)
and extended to circular and complex sampling windows by Goreaud &amp; P?Pelissier (1999).<br /><br />
</p>
<p>Theoretical values under the null hypothesis of CSR as well as
local Monte Carlo confidence limits and p-values of departure from CSR (Besag &amp; Diggle 1977) are estimated at each distance <code class="reqn">r</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>a data frame containing values of the pair density function <code class="reqn">g(r)</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a data frame containing values of the local neighbour density function <code class="reqn">n(r)</code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>a data frame containing values of Ripley's function <code class="reqn">K(r)</code>.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>a data frame containing values of the modified Ripley's function <code class="reqn">L(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected for a Poisson pattern.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of a Poisson pattern at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of a Poisson pattern at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from a Poisson pattern.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Function <code>kfun</code> ignores the marks of multivariate and marked point patterns, which are analysed as univariate patterns.
</p>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Besag J.E. 1977. Discussion on Dr Ripley's paper. <em>Journal of the Royal Statistical Society B</em>, 39:193-195.
</p>
<p>Besag J.E. &amp; Diggle P.J. 1977. Simple Monte Carlo tests spatial patterns. <em>Applied Statistics</em>, 26:327-333.
</p>
<p>Goreaud F. &amp; P?Pelissier R. 1999. On explicit formulas of edge effect correction for Ripley's K-function. <em>Journal of Vegetation Science</em>, 10:433-438.
</p>
<p>Ripley B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-192.
</p>
<p>Stoyan D., Kendall W.S. &amp; Mecke J. 1987. <em>Stochastic geometry and its applications</em>. Wiley, New-York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kval">kval</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+kijfun">kijfun</a></code>,
<code><a href="#topic+ki.fun">ki.fun</a></code>,
<code><a href="#topic+kmfun">kmfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swr &lt;- spp(BP$trees, win=BP$rect)
  kswr &lt;- kfun(swr,25,1,500)
  plot(kswr)

  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45))
  kswc &lt;- kfun(swc, 25, 1, 500)
  plot(kswc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri1)
  kswrt &lt;- kfun(swrt, 25, 1, 500)
  plot(kswrt)
</code></pre>

<hr>
<h2 id='kmfun'>Multiscale second-order neighbourhood analysis of a marked spatial point pattern</h2><span id='topic+kmfun'></span>

<h3>Description</h3>

<p>Computes estimates of the mark correlation <em>Km</em>-function and associated neighbourhood functions from a marked spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypothesis of no correlation between marks (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmfun(p, upto, by, nsim=0, alpha=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a marked spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kmfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kmfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="kmfun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the null hypothesis of no correlation between marks (see Details).
By default <code>nsim=0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="kmfun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha=0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kmfun</code> computes the mark correlation function <code class="reqn">Km(r)</code> and the associated function <code class="reqn">gm(r)</code>.<br /><br />
It is defined from a general definition of spatial autocorrelation (Goreaud 2000) as:<br />
</p>
<p><code class="reqn">Km(r) = (COV(Xi,Xj)|d(i,j)&lt;r) / VAR(X)</code><br />
</p>
<p>where <code class="reqn">X</code> is a quantitative random variable attached to each point of the pattern.
</p>
<p><em>Km(r)</em> has a very similar interpretation than more classical correlation functions, such as Moran's <em>I</em>: it takes values between -1 and 1, with an expectation of 0 under the null hypothesis of no spatial correlation between the values of <em>X</em>, becomes positive when values of <code class="reqn">X</code> at distance <em>r</em> are positively correlated and negative when values of <code class="reqn">X</code> at distance <em>r</em> are negatively correlated.
</p>
<p><code class="reqn">gm(r)</code> is the derivative of <code class="reqn">Km(r)</code> or pair mark correlation function, which gives the correlation of marks within an annuli between two successive circles with radii <code class="reqn">r</code> and <code class="reqn">r-by</code>).<br /><br />
</p>
<p>The program introduces an edge effect correction term according to the method proposed by Ripley (1977) and extended to circular and complex sampling windows by Goreaud &amp; P?Pelissier (1999).
</p>
<p>Local Monte Carlo confidence limits and p-values of departure from the null hypothesis of no correlation are estimated at each distance <code class="reqn">r</code>, after reallocating at random the values of <em>X</em> over all points of the pattern, the location of trees being kept unchanged.
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>gm</code></td>
<td>
<p>a data frame containing values of the pair mark correlation function <code class="reqn">gm(r)</code>.</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>a data frame containing values of the mark correlation function <code class="reqn">Km(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected for the null hypothesis of no correlation between marks.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of the null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of the null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from the null hypothesis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Applications of this function can be found in Oddou-Muratorio <em>et al.</em> (2004) and Madelaine <em>et al.</em> (submitted).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Goreaud, F. 2000. <em>Apports de l'analyse de la structure spatiale en foret tempere a l'etude et la modelisation des peuplements complexes</em>. These de doctorat, ENGREF, Nancy, France.<br /><br />
Goreaud F. &amp; P?Pelissier R. 1999. On explicit formulas of edge effect correction for Ripley's K-function. <em>Journal of Vegetation Science</em>, 10:433-438.<br /><br />
Madelaine, C., Pelissier, R., Vincent, G., Molino, J.-F., Sabatier, D., Prevost, M.-F. &amp; de Namur, C. 2007. Mortality and recruitment in a lowland tropical rainforest of French Guiana: effects of soil type and species guild. <em>Journal of Tropical Ecology</em>, 23:277-287.
</p>
<p>Oddou-Muratorio, S., Demesure-Musch, B., Pelissier, R. &amp; Gouyon, P.-H. 2004. Impacts of gene flow and logging history on the local genetic structure of a scattered tree species, Sorbus torminalis L. <em>Molecular Ecology</em>, 13:3689-3702.
</p>
<p>Ripley B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-192.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+kijfun">kijfun</a></code>,
<code><a href="#topic+ki.fun">ki.fun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$dbh)
  kmswrm &lt;- kmfun(swrm, 25, 2, 500)
  plot(kmswrm)
  
  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45), marks=BP$dbh)
  kmswc &lt;- kmfun(swc, 25, 2, 500)
  plot(kmswc)

  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri2, marks=BP$dbh)
  kmswrt &lt;- kmfun(swrt, 25, 2, 500)
  plot(kmswrt)

</code></pre>

<hr>
<h2 id='kp.fun'> Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern</h2><span id='topic+kp.fun'></span><span id='topic+ki.fun'></span>

<h3>Description</h3>

<p>(Formerly <code>ki.fun</code>) Computes a set of <em>K12</em>-functions between all possible marks <code class="reqn">p</code> and the other marks in
a multivariate spatial point pattern defined in a simple (rectangular or circular) 
or complex sampling window (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kp.fun(p, upto, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kp.fun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a multivariate spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kp.fun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kp.fun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kp.fun</code> is simply a wrapper to <code><a href="#topic+k12fun">k12fun</a></code>, which computes <em>K12(r)</em> between each mark <code class="reqn">p</code> of the pattern
and all other marks grouped together (the <code class="reqn">j</code> points).
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>labp</code></td>
<td>
<p>a vector containing the levels <code class="reqn">i</code> of <code>p$marks</code>.</p>
</td></tr>
<tr><td><code>gp.</code></td>
<td>
<p>a data frame containing values of the pair density function <code class="reqn">g12(r)</code>.</p>
</td></tr>
<tr><td><code>np.</code></td>
<td>
<p>a data frame containing values of the local neighbour density function <code class="reqn">n12(r)</code>.</p>
</td></tr>
<tr><td><code>kp.</code></td>
<td>
<p>a data frame containing values of the <code class="reqn">K12(r)</code> function.</p>
</td></tr>
<tr><td><code>lp.</code></td>
<td>
<p>a data frame containing values of the modified <code class="reqn">L12(r)</code> function.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the null hypothesis of population independence (see <code><a href="#topic+k12fun">k12fun</a></code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+kpqfun">kpqfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: multivariate spatial point pattern in a rectangle sampling window
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
  kp.swrm &lt;- kp.fun(swrm, 25, 1)
  plot(kp.swrm)
  
 ## Not run: multivariate spatial point pattern in a circle with radius 50 centred on (55,45)
  swcm &lt;- spp(BP$trees, win=c(55,45,45), marks=BP$species)
  kp.swcm &lt;- kp.fun(swcm, 25, 1)
  plot(kp.swcm)
  
  ## Not run: multivariate spatial point pattern in a complex sampling window
  swrtm &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri2, marks=BP$species)
  kp.swrtm &lt;- kp.fun(swrtm, 25, 1)
  plot(kp.swrtm)
</code></pre>

<hr>
<h2 id='kpqfun'>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern</h2><span id='topic+kpqfun'></span><span id='topic+kijfun'></span>

<h3>Description</h3>

<p>(Formerly <code>kijfun</code>) Computes a set of <em>K</em>- and <em>K12</em>-functions for all possible pairs of marks <code class="reqn">(p,q)</code> in a multivariate spatial 
point pattern defined in a simple (rectangular or circular) 
or complex sampling window (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> kpqfun(p, upto, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kpqfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a multivariate spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kpqfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kpqfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kpqfun</code> is simply a wrapper to <code><a href="#topic+kfun">kfun</a></code> and <code><a href="#topic+k12fun">k12fun</a></code>, which computes either <em>K(r)</em> 
for points of mark <code class="reqn">p</code> when <code class="reqn">p=q</code> or <em>K12(r)</em> between the marks <code class="reqn">p</code> and <code class="reqn">q</code> otherwise.
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>labpq</code></td>
<td>
<p>a vector containing the <code class="reqn">(p,q)</code> paired levels of <code>p$marks</code>.</p>
</td></tr>
<tr><td><code>gpq</code></td>
<td>
<p>a data frame containing values of the pair density functions <code class="reqn">g(r)</code> and <code class="reqn">g12(r)</code>.</p>
</td></tr>
<tr><td><code>npq</code></td>
<td>
<p>a data frame containing values of the local neighbour density functions <code class="reqn">n(r)</code> and <code class="reqn">n12(r)</code>.</p>
</td></tr>
<tr><td><code>kpq</code></td>
<td>
<p>a data frame containing values of the <code class="reqn">K(r)</code> and <code class="reqn">K12(r)</code> functions.</p>
</td></tr>
<tr><td><code>lpq</code></td>
<td>
<p>a data frame containing values of the modified <code class="reqn">L(r)</code> and <code class="reqn">L12(r)</code> functions.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the null hypotheses of spatial randomness (see <code><a href="#topic+kfun">kfun</a></code>) and
population independence (see <code><a href="#topic+k12fun">k12fun</a></code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+kp.fun">kp.fun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
 ## Not run: multivariate spatial point pattern in a rectangle sampling window
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
  kpqswrm &lt;- kpqfun(swrm, 25, 1)
  plot(kpqswrm)
  
 ## Not run: multivariate spatial point pattern in a circle with radius 50 centred on (55,45)
  swcm &lt;- spp(BP$trees, win=c(55,45,45), marks=BP$species)
  kpqswcm &lt;- kpqfun(swcm, 25, 1)
  plot(kpqswcm)
  
  ## Not run: multivariate spatial point pattern in a complex sampling window
  swrtm &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri2, marks=BP$species)
  kpqswrtm &lt;- kpqfun(swrtm, 25, 1)
  plot(kpqswrtm)

</code></pre>

<hr>
<h2 id='krfun'>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern using Rao quadratic entropy</h2><span id='topic+krfun'></span>

<h3>Description</h3>

<p>Computes distance-dependent estimates of Rao's quadratic entropy from a multivariate spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypothesis of either a random labelling or a species equivalence (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krfun(p, upto, by, nsim=0, dis = NULL, H0 = c("rl", "se"), alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="krfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="krfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="krfun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the null hypothesis of a random allocation of species labels (see Details).
By default <code>nsim = 0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="krfun_+3A_dis">dis</code></td>
<td>
<p>(optional) a <code>"dist"</code> object defining Euclidean distances between species. By default <code class="reqn">dis = NULL</code> so that species are considered equidistant.</p>
</td></tr>
<tr><td><code id="krfun_+3A_h0">H0</code></td>
<td>
<p>one of c(&quot;rl&quot;,&quot;se&quot;) to select either the null hypothesis of random labelling (H0 = &quot;rl&quot;) or species equivalence (H0 = &quot;se&quot;) (see Details). By default, the null hypothesis is random labelling.</p>
</td></tr>
<tr><td><code id="krfun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha = 0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>krfun</code> computes distance-dependent functions of Rao (1982) quadratic entropy (see <code><a href="ade4.html#topic+divc">divc</a></code> in package <code>ade4</code>).<br /><br />
For a multivariate point pattern consisting of <code class="reqn">S</code> species with intensity <code class="reqn">\lambda</code>p, such functions can be estimated from the bivariate <code class="reqn">Kpq</code>-functions between each pair of different species <code class="reqn">p</code> and <code class="reqn">q</code>.
Function <code>krfun</code> is thus a simple wrapper function of <code><a href="#topic+k12fun">k12fun</a></code> and <code><a href="#topic+kfun">kfun</a></code>, standardized by Rao diversity coefficient (Pelissier &amp; Goreaud 2014):
</p>
<p><code class="reqn">Kr(r) = sum(\lambda p * \lambda q * Kpq(r)*dpq) / (\lambda * \lambda * K(r) * HD)</code>.<br />
<code class="reqn">gr(r) = sum(\lambda p * \lambda q * gpq(r)*dpq) / (\lambda * \lambda * g(r) * HD)</code>.<br /><br />
</p>
<p>where <code class="reqn">dpq</code> is the distance between species <code class="reqn">p</code> and <code class="reqn">q</code> defined by matrix <code>dis</code>, typically a taxonomic, phylogenetic or functional distance, and <code class="reqn">HD=sum(Np*Nq*dpq/(N(N - 1)))</code> is the unbiased version of Rao diversity coefficient (see Shimatani 2001). When <code>dis = NULL</code>, species are considered each other equidistant and <code>krfun</code> returns the same results than <code><a href="#topic+ksfun">ksfun</a></code>. 
</p>
<p>The program introduces an edge effect correction term according to the method proposed by Ripley (1977)
and extended to circular and complex sampling windows by Goreaud &amp; Pelissier (1999).<br /><br />
</p>
<p>Theoretical values under the null hypothesis of either random labelling or species equivalence as well as local Monte Carlo confidence limits and p-values of departure from the null hypothesis (Besag &amp; Diggle 1977) are estimated at each distance <code class="reqn">r</code>.
</p>
<p>The random labelling hypothesis (H0 = &quot;rl&quot;) is tested by reallocating species labels at random among all points of the pattern, keeping the point locations unchanged, so that expectations of <code class="reqn">gr(r)</code> and <code class="reqn">Kr(r)</code> are 1 for all <code class="reqn">r</code>.
The species equivalence hypothesis (H0 = &quot;se&quot;) is tested by randomizing the between-species distances, keeping the point locations and distribution of species labels unchanged. The theoretical expectations of <code class="reqn">gr(r)</code> and <code class="reqn">Kr(r)</code> are thus <code class="reqn">gs(r)</code> and <code class="reqn">Ks(r)</code>, respectively (see <code><a href="#topic+ksfun">ksfun</a></code>).
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>gr</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">gr(r)</code>.</p>
</td></tr>
<tr><td><code>kr</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">Kr(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the selected null hypothesis.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of a random distribution of the selected null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of a random distribution of the selected null hypothesis at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from the selected null hypothesis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Rao, C.R. 1982. Diversity and dissimilarity coefficient: a unified approach. <em>Theoretical Population Biology</em>, 21:24-43.
</p>
<p>Shimatani, K. 2001. On the measurement of species diversity incorporating species differences. <em>Oikos</em>, 93, 135-147.
</p>
<p>Goreaud F. &amp; Pelissier R. 1999. On explicit formulas of edge effect correction for Ripley's K-function. <em>Journal of Vegetation Science</em>, 10:433-438.
</p>
<p>Ripley B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-192.
</p>
<p>Pelissier, R. &amp; Goreaud, F. 2014. ads package for R: A fast unbiased implementation of the k-function family for studying spatial point patterns in irregular-shaped sampling windows. <em>Journal of Statistical Software</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+ksfun">ksfun</a></code>,
<code><a href="#topic+kdfun">kdfun</a></code>,
<code><a href="ade4.html#topic+divc">divc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Paracou15)
  P15&lt;-Paracou15
  ## Not run: spatial point pattern in a rectangle sampling window of size 125 x 125
  swmr &lt;- spp(P15$trees, win = c(175, 175, 250, 250), marks = P15$species)
  ## Not run: testing the random labeling hypothesis
  krwmr.rl &lt;- krfun(swmr, dis = P15$spdist, H0 = "rl", 25, 2, 50)
  ## Not run: running more simulations is slow
  krwmr.rl &lt;- krfun(swmr, dis = P15$spdist, H0 = "rl", 25, 2, 500)
  plot(krwmr.rl)
  ## Not run: testing the species equivalence hypothesis
  krwmr.se &lt;- krfun(swmr, dis = P15$spdist, H0 = "se", 25, 2, 50)
  ## Not run: running more simulations is slow
  krwmr.se &lt;- krfun(swmr, dis = P15$spdist, H0 = "se", 25, 2, 500)
  plot(krwmr.se)

  ## Not run: spatial point pattern in a circle with radius 50 centred on (125,125)
  swmc &lt;- spp(P15$trees, win = c(125,125,50), marks = P15$species)
  krwmc &lt;- krfun(swmc, dis = P15$spdist, H0 = "rl", 25, 2, 100)
  ## Not run: running more simulations is slow
  krwmc &lt;- krfun(swmc, dis = P15$spdist, H0 = "rl", 25, 2, 500)
  plot(krwmc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(P15$trees, win = c(125,125,250,250), tri = P15$tri, marks = P15$species)
  krwrt &lt;- krfun(swrt, dis = P15$spdist, H0 = "rl", 25, 2)
  ## Not run: running simulations is slow
  krwrt &lt;- krfun(swrt, dis = P15$spdist, H0 = "rl", 25, 2, 500)
  plot(krwrt)
</code></pre>

<hr>
<h2 id='ksfun'>Multiscale second-order neighbourhood analysis of a multivariate spatial point pattern using Simpson diversity</h2><span id='topic+ksfun'></span>

<h3>Description</h3>

<p>Computes estimates of Shimatani <em>alpha</em> and <em>beta</em> functions of Simpson diversity from a multivariate spatial point pattern 
in a simple (rectangular or circular) or complex sampling window. Computes optionally local confidence limits of the functions
under the null hypothesis of a random allocation of species labels (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksfun(p, upto, by, nsim=0, alpha=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksfun_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="ksfun_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="ksfun_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
<tr><td><code id="ksfun_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations to estimate local confidence limits of the null hypothesis of a random allocation of species labels (see Details).
By default <code>nsim=0</code>, so that no confidence limits are computed.</p>
</td></tr>
<tr><td><code id="ksfun_+3A_alpha">alpha</code></td>
<td>
<p>if <code>nsim&gt;0</code>, significant level of the confidence limits. By default <code class="reqn">\alpha=0.01</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ksfun</code> computes Shimatani <code class="reqn">\alpha(r)</code> and <code class="reqn">\beta(r)</code> functions of Simpson diversity, called here <code class="reqn">Ks(r)</code> and <code class="reqn">gs(r)</code>, respectively.<br /><br />
For a multivariate point pattern consisting of <code class="reqn">S</code> species with intensity <code class="reqn">\lambda</code>p, Shimatani (2001) showed that
a distance-dependent measure of Simpson (1949) diversity can be estimated from Ripley (1977) <code class="reqn">K</code>-function computed for each species separately and for all the points grouped together (see also Eckel et al. 2008).
Function <code>ksfun</code> is thus a simple wrapper function of <code><a href="#topic+kfun">kfun</a></code>, standardized by Simpson diversity coefficient:
</p>
<p><code class="reqn">Ks(r) = 1 - sum(\lambda p * \lambda p * Kp(r)) / (\lambda * \lambda * K(r) * D)</code> which is a standardized estimator of <code class="reqn">\alpha(r)</code> in Shimatani (2001).<br /><br />
<code class="reqn">gs(r) = 1 - sum(\lambda p * \lambda p * gp(r)) / (\lambda * \lambda * g(r) * D)</code> corresponding to a standardized version of <code class="reqn">\beta(r)</code> in Shimatani (2001).<br /><br />
</p>
<p><code class="reqn">Kp(r)</code> and <code class="reqn">K(r)</code> (resp. <code class="reqn">gp(r)</code> and <code class="reqn">g(r)</code>) are univariate K-functions computed for species <code class="reqn">p</code> and for all species together; <code class="reqn">D = 1 - sum(Np * (Np - 1) / (N*(N - 1)))</code> is the unbiased version of Simpson diversity,
with <code class="reqn">Np</code> the number of individuals of species <code class="reqn">p</code> in the sample and <code class="reqn">N = sum(Np)</code>.
</p>
<p>The program introduces an edge effect correction term according to the method proposed by Ripley (1977)
and extended to circular and complex sampling windows by Goreaud &amp; P?Pelissier (1999).<br /><br />
</p>
<p>The theoretical values of <code class="reqn">gr(r)</code> and <code class="reqn">Kr(r)</code> under the null hypothesis of random labelling is 1 for all <code class="reqn">r</code>.
Local Monte Carlo confidence limits and p-values of departure from this hypothesis are estimated at each distance <code class="reqn">r</code> by reallocating at random the species labels among points of the pattern, keeping the point locations unchanged.
</p>


<h3>Value</h3>

<p>A list of class <code>"fads"</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>gs</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">gs(r)</code>.</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>a data frame containing values of the function <code class="reqn">Ks(r)</code>.<br /></p>
</td></tr>
</table>
<p>Each component except <code>r</code> is a data frame with the following variables:<br />
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>a vector of estimated values for the observed point pattern.</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values expected under the null hypothesis of random labelling, i.e. 1 for all <code class="reqn">r</code>.</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the upper local confidence limits of a random distribution of species labels at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of the lower local confidence limits of a random distribution of species labels at a significant level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>(optional) if <code>nsim&gt;0</code> a vector of local p-values of departure from a random distribution of species labels.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"fads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Shimatani K. 2001. Multivariate point processes and spatial variation in species diversity. <em>Forest Ecology and Management</em>, 142:215-229.
</p>
<p>Eckel, S., Fleisher, F., Grabarnik, P. and Schmidt V. 2008. An investigation of the spatial correlations for relative purchasing power in Baden-Wurttemberg. <em>AstA - Advances in Statistical Analysis</em>, 92:135-152.
</p>
<p>Simpson, E.H. 1949. Measurement of diversity. <em>Nature</em>, 688:163.
</p>
<p>Goreaud F. &amp; P?Pelissier R. 1999. On explicit formulas of edge effect correction for Ripley's K-function. <em>Journal of Vegetation Science</em>, 10:433-438.
</p>
<p>Ripley B.D. 1977. Modelling spatial patterns. <em>Journal of the Royal Statistical Society B</em>, 39:172-192.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fads">plot.fads</a></code>,
<code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+kpqfun">kpqfun</a></code>,
<code><a href="#topic+kp.fun">kp.fun</a></code>,
<code><a href="#topic+krfun">krfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Paracou15)
  P15&lt;-Paracou15
  ## Not run: spatial point pattern in a rectangle sampling window of size 125 x 125
  swmr &lt;- spp(P15$trees, win = c(125, 125, 250, 250), marks = P15$species)
  kswmr &lt;- ksfun(swmr, 50, 5, 500)
  plot(kswmr)

  ## Not run: spatial point pattern in a circle with radius 50 centred on (125,125)
  swmc &lt;- spp(P15$trees, win = c(125, 125, 50), marks = P15$species)
  kswmc &lt;- ksfun(swmc, 50, 5, 500)
  plot(kswmc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(P15$trees, win = c(125, 125, 250, 250), tri=P15$tri, marks=P15$species)
  kswrt &lt;- ksfun(swrt, 50, 5, 500)
  plot(kswrt)
</code></pre>

<hr>
<h2 id='kval'>Multiscale local second-order neighbour density of a spatial point pattern</h2><span id='topic+kval'></span><span id='topic+print.kval'></span><span id='topic+summary.kval'></span><span id='topic+print.summary.kval'></span>

<h3>Description</h3>

<p>Computes local second-order neighbour density estimates for an univariate spatial point pattern, i.e. the number of neighbours per unit area
within sample circles of regularly increasing radii <code class="reqn">r</code>, centred at each point of the pattern (see Details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kval(p, upto, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kval_+3A_p">p</code></td>
<td>
<p>a <code>"spp"</code> object defining a spatial point pattern in a given sampling window (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="kval_+3A_upto">upto</code></td>
<td>
<p>maximum radius of the sample circles (see Details).</p>
</td></tr>
<tr><td><code id="kval_+3A_by">by</code></td>
<td>
<p>interval length between successive sample circles radii (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>kval</code> returns individual values of <em>K(r)</em> and associated functions (see <code><a href="#topic+kfun">kfun</a></code>)
estimated for each point of the pattern. For a given distance <em>r</em>, these values can be mapped within the sampling window 
(Getis &amp; Franklin 1987, P?Pelissier &amp; Goreaud 2001).  
</p>


<h3>Value</h3>

<p>A list of class <code>c("vads","kval")</code> with essentially the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of regularly spaced out distances (<code>seq(by,upto,by)</code>).</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>a data frame with 2 components giving <code class="reqn">(x,y)</code> coordinates of points of the pattern.</p>
</td></tr>
<tr><td><code>gval</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of the pair density function <code class="reqn">g(r)</code>.</p>
</td></tr>
<tr><td><code>nval</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of the neighbour density function <code class="reqn">n(r)</code>.</p>
</td></tr>
<tr><td><code>kval</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values of Ripley's function <code class="reqn">K(r)</code>.</p>
</td></tr>
<tr><td><code>lval</code></td>
<td>
<p>a matrix of size <code class="reqn">(length(xy),length(r))</code> giving individual values the modified Ripley's function <code class="reqn">L(r)</code>.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Function <code>kval</code> ignores the marks of multivariate and marked point patterns (they are all considered to be univariate patterns).
</p>


<h3>Note</h3>

<p>There are printing, summary and plotting methods for <code>"vads"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>References</h3>

 
<p>Getis, A. and Franklin, J. 1987. Second-order neighborhood analysis of mapped point patterns. <em>Ecology</em>, 68:473-477.<br /><br />
P?Pelissier, R. and Goreaud, F. 2001. A practical approach to the study of spatial structure in simple cases of heterogeneous vegetation. <em>Journal of Vegetation Science</em>, 12:99-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.vads">plot.vads</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+dval">dval</a></code>,
<code><a href="#topic+k12val">k12val</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: spatial point pattern in a rectangle sampling window of size [0,110] x [0,90]
  swr &lt;- spp(BP$trees, win=BP$rect)
  kvswr &lt;- kval(swr, 25, 1)
  summary(kvswr)
  plot(kvswr)

  ## Not run: spatial point pattern in a circle with radius 50 centred on (55,45)
  swc &lt;- spp(BP$trees, win=c(55,45,45))
  kvswc &lt;- kval(swc, 25, 1)
  summary(kvswc)
  plot(kvswc)
  
  ## Not run: spatial point pattern in a complex sampling window
  swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri1)
  kvswrt &lt;- kval(swrt, 25, 1)
  summary(kvswrt)
  plot(kvswrt)
</code></pre>

<hr>
<h2 id='mimetic'>Univariate point pattern simulation by mimetic point process</h2><span id='topic+mimetic'></span><span id='topic+plot.mimetic'></span>

<h3>Description</h3>

<p>Simulates replicates of an observed univariate point pattern by stochastic optimization of its L-function properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mimetic(x,upto=NULL,by=NULL,prec=NULL,nsimax=3000,conv=50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mimetic_+3A_x">x</code></td>
<td>
<p>either a <code>("fads", "kfun")</code> object or a <code>"spp"</code> object of type &quot;univariate&quot; defining a spatial point pattern in a given sampling window (see <code><a href="#topic+kfun">kfun</a></code> or <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="mimetic_+3A_upto">upto</code></td>
<td>
<p>(optional) maximum radius of the sample circles when <code>x</code> is a <code>"spp"</code> object.</p>
</td></tr>
<tr><td><code id="mimetic_+3A_by">by</code></td>
<td>
<p>(optional) interval length between successive sample circles radii when <code>x</code> is a <code>"spp"</code> object.</p>
</td></tr>
<tr><td><code id="mimetic_+3A_prec">prec</code></td>
<td>
<p>precision of point coordinates generated during simulations when <code>x</code> is a <code>"spp"</code> object. By default prec=0.01 or the value used in function <code>kfun</code> when <code>x</code> is a <code>("fads", "kfun")</code> object.</p>
</td></tr>
<tr><td><code id="mimetic_+3A_nsimax">nsimax</code></td>
<td>
<p>maximum number of simulations allowed. By default the process stops after <code>nsimax=3000</code> if convergence is not reached.</p>
</td></tr>
<tr><td><code id="mimetic_+3A_conv">conv</code></td>
<td>
<p>maximum number of simulations without optimization gain (convergence criterion).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>mimetic</code> uses a stepwise depletion-replacement algorithm to generate a point pattern whose L-function is optimized with regards to an observed one, following the mimetic point process principle (Goreaud et al. 2004).  
Four points are randomly deleted at each step of the process and replaced by new points that minimize the following cost function:||<code class="reqn">Lobs(r) - Lsim (r)</code>||)^2. The simulation stops as soon as the cost function doesn't decrease 
after <code>conv</code> simulations or after a maximum of <code>nsimax</code> simulations. The process apply to rectangular, circular or complex sampling windows (see <code><a href="#topic+spp">spp</a></code>). There exist a <code>plot</code> method that displays diagnostic 
plots, i.e. the observed and simulated L-function, the simulated point pattern and the successive values of the cost function. 
</p>


<h3>Value</h3>

<p>A list of class <code>"mimetic"</code> with essentially the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>fads</code></td>
<td>
<p>an object of class <code>("fads", "mimetic")</code> with 2 components:<br /><br /></p>
</td></tr>
<tr><td><code>..r</code></td>
<td>
<p>a vector of regularly spaced out distances corresponding to seq(by,upto,by).</p>
</td></tr>
<tr><td><code>..l</code></td>
<td>
<p>a dataframe with 2 components:<br /><br /></p>
</td></tr>
<tr><td><code>.. ..obs</code></td>
<td>
<p>a vector of values of the L-function estimated for the initial observed pattern</p>
</td></tr>
<tr><td><code>.. ..sim</code></td>
<td>
<p>a vector of values of the L-function estimated for the simulated pattern</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>a object of class <code>"spp"</code> corresponding to the simulated point pattern (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>a vector of theoretical values, i.e. Simpson <code class="reqn">D</code> for all the points.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>a vector of the successive values of the cost function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing and plotting methods for <code>"mimetic"</code> objects.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>References</h3>

<p>Goreaud F., Loussier, B., Ngo Bieng, M.-A. &amp; Allain R. 2004. Simulating realistic spatial structure for forest stands: a mimetic point process. In Proceedings of Interdisciplinary Spatial Statistics Workshop, 2-3 December, 2004. Paris, France.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+kfun">kfun</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP&lt;-BPoirier
  ## Not run: performing point pattern analysis in a rectangle sampling window
  swr &lt;- spp(BP$trees, win=BP$rect)
  plot(swr)
  
  ## Not run: performing the mimetic point process from "spp" object
  mimswr &lt;- mimetic(swr, 20, 2)
  plot(mimswr)

  ## Not run: performing the mimetic point process from "fads" object
  mimkswr &lt;- mimetic(kfun(swr, 20, 2))
  plot(mimkswr)
  
  </code></pre>

<hr>
<h2 id='Paracou15'>Tree spatial pattern in control plot 15, Paracou experimental station, French Guiana</h2><span id='topic+Paracou15'></span>

<h3>Description</h3>

<p>Spatial pattern of 4128 trees of 332 different species in a 250 m X 250 m control plot in Paracou experimental station, French Guiana. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Paracou15)</code></pre>


<h3>Format</h3>

<p>A list with 5 components:<br />
<code>$rect     </code> is a vector of coordinates <code class="reqn">(xmin,ymin,xmax,ymax)</code> of the origin and the opposite corner of a 250 by 250 m rectangular plot.<br />
<code>$trees    </code> is a list of tree coordinates <code class="reqn">(x,y)</code>.<br />
<code>$species  </code> is a factor with 332 levels corresponding to species names of the trees.<br />
<code>$spdist </code> is an object of class <code>"dist"</code> giving between-species distances based on functional traits (see Paine et al. 2011).<br />
</p>


<h3>Source</h3>

<p>Gourlet-Fleury, S., Ferry, B., Molino, J.-F., Petronelli, P. &amp; Schmitt, L. 2004. <em>Experimental plots: key features.</em> Pp. 3-60 In Gourlet-Fleury, S., Guehl, J.-M. &amp; Laroussinie, O. (Eds.), Ecology and Management of a Neotropical rainforest - Lessons drawn from Paracou, a long-term experimental research site in French Guiana. Elsevier SAS, France.
</p>


<h3>References</h3>

<p>Paine, C. E. T., Baraloto, C., Chave, J. &amp; Herault, B. 2011. Functional traits of individual trees reveal ecological constraints on community assembly in tropical rain forests. <em>Oikos</em>, 120: 720-727.<br /><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Paracou15)
P15.spp &lt;- spp(Paracou15$trees, mark = Paracou15$species, window = Paracou15$rect)
plot(P15.spp, chars = rep("o", 332), cols = rainbow(332), legend = FALSE, maxsize = 0.5)
</code></pre>

<hr>
<h2 id='plot.fads'>Plot second-order neighbourhood functions</h2><span id='topic+plot.fads'></span><span id='topic+plot.fads.kfun'></span><span id='topic+plot.fads.k12fun'></span><span id='topic+plot.fads.kpqfun'></span><span id='topic+plot.fads.kp.fun'></span><span id='topic+plot.fads.kmfun'></span><span id='topic+plot.fads.ksfun'></span><span id='topic+plot.fads.krfun'></span><span id='topic+plot.fads.kdfun'></span><span id='topic+plot.fads.mimetic'></span>

<h3>Description</h3>

<p>Plot second-order neighbourhood function estimates returned by functions <code><a href="#topic+kfun">kfun</a>, <a href="#topic+k12fun">k12fun</a>, <a href="#topic+kmfun">kmfun</a></code>, <br />
<code> <a href="#topic+kijfun">kijfun</a> or <a href="#topic+ki.fun">ki.fun</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fads'
plot(x, opt, cols, lty, main, sub, legend, csize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fads_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fads"</code> (see Details).</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_opt">opt</code></td>
<td>
<p>one of <code>c("all","L","K","n","g")</code> to display either all or one of the functions in a single window. By default <code>opt = "all"</code> for <code>fads</code> 
objects of subclass <code>"kfun"</code>, <code>"k12fun"</code>, or <code>"kmfun"</code>;  by default <code>opt = "L"</code> for <code>fads</code> objects of subclass <code>"kij"</code>, or <code>"ki."</code>.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_cols">cols</code></td>
<td>
<p>(optional) colours used for plotting functions.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_lty">lty</code></td>
<td>
<p>(optional) line types used for plotting functions.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_main">main</code></td>
<td>
<p>by default, the value of argument x, otherwise a text to be displayed as a title of the plot. <code>main=NULL</code> displays no title.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_sub">sub</code></td>
<td>
<p>by default, the name of the function displayed, otherwise a text to be displayed as function subtitle. <code>sub=NULL</code> displays no subtitle.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_legend">legend</code></td>
<td>
<p>If <code>legend = TRUE</code> (the default) a legend for the plotting functions is displayed.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_csize">csize</code></td>
<td>
<p>scaling factor for font size so that actual font size is <code>par("cex")*csize</code>. By default <code>csize = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.fads_+3A_...">...</code></td>
<td>
<p>extra arguments that will be passed to the plotting functions <code><a href="#topic+plot.swin">plot.swin</a></code>, <br />
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+symbols">symbols</a></code> and/or <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>plot.fads</code> displays second-order neighbourhood function estimates as a function of interpoint distance, with expected values 
as well as confidence interval limits when computed. Argument <code>x</code> can be any <code>fads</code> object returned by functions <code><a href="#topic+kfun">kfun</a>,
  <a href="#topic+k12fun">k12fun</a>, <a href="#topic+kmfun">kmfun</a>, <a href="#topic+kijfun">kijfun</a> or <a href="#topic+ki.fun">ki.fun</a></code>. 
</p>


<h3>Value</h3>

<p>none.</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+kfun">kfun</a></code>,
<code><a href="#topic+k12fun">k12fun</a></code>,
<code><a href="#topic+kmfun">kmfun</a></code>,
<code><a href="#topic+kijfun">kijfun</a></code>,
<code><a href="#topic+ki.fun">ki.fun</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: Ripley's function
  swr &lt;- spp(BP$trees, win=BP$rect)
  k.swr &lt;- kfun(swr, 25, 1, 500)
  plot(k.swr)
  
  ## Not run: Intertype function
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
  k12.swrm &lt;- k12fun(swrm, 25, 1, 500, marks=c("beech","oak"))
  plot(k12.swrm, opt="L", cols=1)
  
  ## Not run: Mark correlation function
  swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$dbh)
  km.swrm &lt;- kmfun(swrm, 25, 1, 500)
  plot(km.swrm, main="Example 1", sub=NULL, legend=FALSE)

</code></pre>

<hr>
<h2 id='plot.spp'>Plot a Spatial Point Pattern object</h2><span id='topic+plot.spp'></span>

<h3>Description</h3>

<p>Plot a Spatial Point Pattern object returned by function <code><a href="#topic+spp">spp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spp'
plot(x, main, out=FALSE, use.marks=TRUE, cols, chars, cols.out, chars.out,
maxsize, scale=TRUE, add=FALSE, legend=TRUE, csize=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spp_+3A_x">x</code></td>
<td>
<p>an object of class <code>"spp"</code> (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_main">main</code></td>
<td>
<p>by default, the value of argument <code>x</code>, otherwise a text to be displayed as a title of the plot.<code>main=NULL</code> displays no title.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_out">out</code></td>
<td>
<p>by default <code>out = FALSE</code>. If <code>TRUE</code> points of the pattern located outside the sampling window are plotted.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_use.marks">use.marks</code></td>
<td>
<p>by default <code>use.marks = TRUE</code>. If <code>FALSE</code> different symbols are not used for each mark of multivariate
or marked point patterns, so that they are plotted as univariate (see <code><a href="#topic+spp">spp</a></code>).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_cols">cols</code></td>
<td>
<p>(optional) the colour(s) used to plot points located inside the sampling window (see Details).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_chars">chars</code></td>
<td>
<p>(optional) plotting character(s) used to plot points located inside the sampling window (see Details).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_cols.out">cols.out</code></td>
<td>
<p>(optional) if <code>out = TRUE</code>, the colour(s) used to plot points located outside the sampling window (see Details).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_chars.out">chars.out</code></td>
<td>
<p>(optional) if <code>out = TRUE</code>, plotting character(s) used to plot points located outside the sampling window (see Details).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_maxsize">maxsize</code></td>
<td>
<p>(optional) maximum size of plotting symbols. By default <code>maxsize</code> is automatically adjusted to plot size.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_csize">csize</code></td>
<td>
<p>scaling factor for font size so that actual font size is <code>par("cex")*csize</code>. By default <code>csize = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_scale">scale</code></td>
<td>
<p>If <code>scale = TRUE</code> (the default) graduations giving plot size are displayed.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_legend">legend</code></td>
<td>
<p>If <code>legend = TRUE</code> (the default) a legend for plot symbols is displayed (multivariate and marked types only).</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_add">add</code></td>
<td>
<p>by default <code>add = FALSE</code>. If <code>TRUE</code> a new window is not created and just the points are plotted over the existing plot.</p>
</td></tr>
<tr><td><code id="plot.spp_+3A_...">...</code></td>
<td>
<p>extra arguments that will be passed to the plotting functions <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+points">points</a></code> and/or <code><a href="graphics.html#topic+symbols">symbols</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling window <code>x$window</code> is plotted first, through a call to function <code><a href="#topic+plot.swin">plot.swin</a></code>.
Then the points themselves are plotted, in a fashion that depends on the type of spatial point pattern (see <code><a href="#topic+spp">spp</a></code>).
</p>

<ul>
<li>
<p><b>univariate pattern:</b>
if <code>x$type = c("univariate")</code>, i.e. the point pattern does not have marks, or if <code>use.marks = FALSE</code>, then the locations of all 
points is plotted using a single plot character.
</p>
</li>
<li>
<p><b>multivariate pattern:</b>
if <code>x$type = c("multivariate")</code>, i.e. the marks are levels of a factor, then each level is represented by a different plot character.
</p>
</li>
<li>
<p><b>marked pattern:</b>
if <code>x$type = c("marked")</code>, i.e. the marks are real numbers, then points are represented by circles (argument <code>chars = "circles"</code>, the default) or squares 
(argument <code>chars = "squares"</code>) proportional to their marks' value (positive values are filled, while negative values are unfilled).
</p>
</li></ul>

<p>Arguments <code>cols</code> and <code>cols.out</code> (if <code>out = TRUE</code>) determine the colour(s) used to display the points located inside and outside the sampling window, respectively.
Colours may be specified as codes or colour names (see <code><a href="graphics.html#topic+par">par</a>("col")</code>). For univariate and marked point patterns, <code>cols</code> and <code>cols.out</code> are single character strings, while 
for multivariate point patterns they are character vectors of same length as <code>levels(x$marks)</code> and <code>levels(x$marksout)</code>, respectively.
</p>
<p>Arguments <code>chars</code> and <code>chars.out</code> (if <code>out = TRUE</code>) determine the symbol(s) used to display the points located inside and outside the sampling window, respectively.
Symbols may be specified as codes or character strings (see <code><a href="graphics.html#topic+par">par</a>("pch")</code>). For univariate point patterns, <code>chars</code> and <code>chars.out</code> are single character strings, while 
for multivariate point patterns they are character vectors of same length as <code>levels(x$marks)</code> and <code>levels(x$marksout)</code>, respectively. For marked point patterns, 
<code>chars</code> and <code>chars.out</code> can only take the value <code>"circles"</code> or <code>"squares"</code>.	
</p>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+swin">swin</a></code>,
<code><a href="#topic+plot.swin">plot.swin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP&lt;-BPoirier
  
  ## Not run: a univariate point pattern in a rectangle sampling window
  plot(spp(BP$trees, win=BP$rect))
  
  ## Not run: a univariate point pattern in a circular sampling window
 plot(spp(BP$trees, win=c(55,45,45)), out=TRUE, scale=TRUE)
 
 ## Not run: a univariate point pattern in a complex sampling window
 ## Not run: (points outside the sampling window displayed in red colour)
 plot(spp(BP$trees, win=BP$rect, tri=BP$tri1), out=TRUE)
  
 ## Not run: a multivariate point pattern in a rectangle sampling window
 plot(spp(BP$trees, win=BP$rect, marks=BP$species))
 
 ## Not run: a multivariate point pattern in a circular sampling window
 ## Not run: (points inside/outside the sampling window displayed in blue colour/as red crosses)
 plot(spp(BP$trees, win=c(55,45,45), marks=BP$species), out=TRUE, cols=c("blue","blue","blue"), 
 chars.out=c("+","+","+"), cols.out=c("red","red","red"))
 
  ## Not run: a marked point pattern in a rectangle sampling window with circles in green colour
  plot(spp(BP$trees, win=BP$rect, marks=BP$dbh), cols="green")

  ## Not run: a marked point pattern in a circular sampling window
  ## Not run: (squares in red colour inside and circles in blue colour outside)
  plot(spp(BP$trees, win=c(55,45,45), marks=BP$dbh), out=TRUE, chars="squares", 
  cols="red", cols.out="blue")
</code></pre>

<hr>
<h2 id='plot.vads'>Plot local density values</h2><span id='topic+plot.vads'></span><span id='topic+plot.vads.dval'></span><span id='topic+plot.vads.k12val'></span><span id='topic+plot.vads.kval'></span>

<h3>Description</h3>

<p>Plot local density estimates returned by functions <code><a href="#topic+dval">dval</a>,
  <a href="#topic+kval">kval</a> or <a href="#topic+k12val">k12val</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vads'
plot(x, main, opt, select, chars, cols, maxsize, char0, col0, legend, csize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vads_+3A_x">x</code></td>
<td>
<p>an object of class <code>'vads'</code> (see Details).</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_main">main</code></td>
<td>
<p>by default, the value of argument x, otherwise a text to be displayed as a title of the plot. <code>main=NULL</code> displays no title.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_opt">opt</code></td>
<td>
<p>(optional) a character string to change the type of values to be plotted (see Details).</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_select">select</code></td>
<td>
<p>(optional) a vector of selected distances in <code>x$r</code>. By default, a multiple window displays all distances.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_chars">chars</code></td>
<td>
<p>one of <code>c("circles","squares")</code> plotting symbols with areas proportional to local density values. By default, circles are plotted.</p>
</td></tr> 
<tr><td><code id="plot.vads_+3A_cols">cols</code></td>
<td>
<p>(optional) the colour used for the plotting symbols. Black colour is the default.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_maxsize">maxsize</code></td>
<td>
<p>(optional) maximum size of the circles/squares plotted. By default, maxsize is automatically adjusted to plot size.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_char0">char0</code></td>
<td>
<p>(optional) the plotting symbol used to represent null values. By default, null values are not plotted.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_col0">col0</code></td>
<td>
<p>(optional) the colour used for the null values plotting symbol. By default, the same as argument <code>cols</code>.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_legend">legend</code></td>
<td>
<p>If <code>legend = TRUE</code> (the default) a legend for the plotting values is displayed.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_csize">csize</code></td>
<td>
<p>scaling factor for font size so that actual font size is <code>par("cex")*csize</code>. By default <code>csize = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.vads_+3A_...">...</code></td>
<td>
<p>extra arguments that will be passed to the plotting functions <code><a href="#topic+plot.swin">plot.swin</a></code>, <br />
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+symbols">symbols</a></code> and/or <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>plot.vads</code> displays a map of first-order local density or second-order local neighbour density values as symbols with areas proportional 
to the values estimated at the plotted points. 
Positive values are represented by coloured symbols, while negative values are represented by open symbols. The plotted function values depend upon the 
type of <code>'vads'</code> object: 
</p>

<ul>
<li>
<p>if <code>class(x)=c("vads","dval")</code>, the plotted values are first-order local densities and argument <code>opt="dval"</code> by default, but
is potentially one of <code>c("dval","cval")</code> returned by <code><a href="#topic+dval">dval</a></code>.<br />
</p>
</li>
<li>
<p>if <code>class(x)=c("vads","kval")</code> or <code>class(x)=c("vads","k12val")</code>, the plotted values are univariate or bivariate second-order 
local neighbour densities. Argument <code>opt="lval"</code> by default, but is potentially one of <code>c("lval","kval","nval","gval")</code> 
returned by <code><a href="#topic+kval">kval</a></code> and <code><a href="#topic+k12val">k12val</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dval">dval</a></code>,
<code><a href="#topic+kval">kval</a></code>,
<code><a href="#topic+k12val">k12val</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  ## Not run: local density in a rectangle sampling window
  dswr &lt;- dval(spp(BP$trees, win=BP$rect), 25, 1, 11, 9)
  plot(dswr)
  ## Not run: display only distance r from 5 to 10 with null symbols as red crosses
  plot(dswr, select=c(5:10), char0=3, col0="red")
  
  ## Not run: local L(r) values in a circular sampling window
  lvswc &lt;- kval(spp(BP$trees, win=c(55,45,45)), 25, 0.5)
  plot(lvswc)
  ## Not run: display square symbols in blue for selected values of r and remove title
  plot(lvswc, chars="squares", cols="blue", select=c(5,7.5,10,12.5,15), main=NULL)
  
  ## Not run: local K12(r) values (1="beech", 2="oak") in a complex sampling window
  k12swrt &lt;- k12val(spp(BP$trees, win=BP$rect, tri=BP$tri1, marks=BP$species), 25, 1)
  plot(k12swrt, opt="kval")
</code></pre>

<hr>
<h2 id='spp'>Creating a spatial point pattern</h2><span id='topic+spp'></span><span id='topic+print.spp'></span><span id='topic+summary.spp'></span><span id='topic+print.summary.spp'></span><span id='topic+ppp2spp'></span>

<h3>Description</h3>

<p>Function <code>spp</code> creates an object of class <code>"spp"</code>, which represents a
spatial point pattern observed in a finite sampling window (or study region).
The <code>ads</code> library supports univariate, multivariate and marked point patterns
observed in simple (rectangular or circular) or complex sampling windows. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp(x, y=NULL, window, triangles, marks, int2fac=TRUE)
ppp2spp(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp_+3A_x">x</code>, <code id="spp_+3A_y">y</code></td>
<td>
<p>if <code>y=NULL</code>, <code class="reqn">x</code> is a list of two vectors of point coordinates, else both <code class="reqn">x</code> and <code class="reqn">y</code> are atomic vectors of point coordinates.</p>
</td></tr>
<tr><td><code id="spp_+3A_window">window</code></td>
<td>
<p>a <code>"swin"</code> object or a vector defining the limits of a simple sampling 
window: <code>c(xmin,ymin,xmax,ymax)</code> for a rectangle ; <code>c(x0,y0,r0)</code> for a circle.</p>
</td></tr>
<tr><td><code id="spp_+3A_triangles">triangles</code></td>
<td>
<p>(optional) a list of triangles removed from a simple initial window to define a 
complex sampling window (see <code><a href="#topic+swin">swin</a></code>).</p>
</td></tr>
<tr><td><code id="spp_+3A_marks">marks</code></td>
<td>
<p>(optional) a vector of mark values, which may be factor levels or numerical values (see Details).</p>
</td></tr>
<tr><td><code id="spp_+3A_int2fac">int2fac</code></td>
<td>
<p>if TRUE, integer marks are automatically coerced into factor levels.</p>
</td></tr>
<tr><td><code id="spp_+3A_p">p</code></td>
<td>
<p>a <code>"ppp"</code> object from package <code>spatstat.geom</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A spatial point pattern is assumed to have been observed within a specific
sampling window (a finite study region) defined by the <code>window</code> argument. If <code>window</code> is a simple <code>"swin"</code> object, 
it may be coerced into a complex type by adding a <code>triangles</code> argument (see <code><a href="#topic+swin">swin</a></code>). A spatial point pattern may be of 3 different types.
</p>

<ul>
<li>
<p><b>univariate pattern:</b>
by default when argument <code>marks</code> is not given.
</p>
</li>
<li>
<p><b>multivariate pattern:</b>
<code>marks</code> is a factor, which levels are interpreted as categorical marks (e.g. colours, species, etc.) attached to points of the pattern.
Integer marks may be automatically coerced into factor levels when argument <code>int2fac = TRUE</code>.
</p>
</li>
<li>
<p><b>marked pattern:</b>
<code>marks</code> is a vector of real numbers attached to points of the pattern. Integer values may also be considered as numerical values 
if argument <code>int2fac = FALSE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"spp"</code> describing a spatial point pattern observed in a given sampling window.
</p>
<table>
<tr><td><code>$type</code></td>
<td>
<p>a character string indicating if the spatial point pattern is <code>"univariate"</code>, <code>"multivariate"</code> or <code>"marked"</code>.</p>
</td></tr>
<tr><td><code>$window</code></td>
<td>
<p>an <code>swin</code> object describing the sampling window (see <code><a href="#topic+swin">swin</a></code>).</p>
</td></tr>
<tr><td><code>$n</code></td>
<td>
<p>an integer value giving the number of points of the pattern located inside the sampling window (points on the boundary are considered to be inside).</p>
</td></tr>
<tr><td><code>$x</code></td>
<td>
<p>a vector of <code class="reqn">x</code> coordinates of points located inside the sampling window.</p>
</td></tr>
<tr><td><code>$y</code></td>
<td>
<p>a vector of <code class="reqn">y</code> coordinates of points located inside the sampling window.</p>
</td></tr>
<tr><td><code>$nout</code></td>
<td>
<p>(optional) an integer value giving the number of points of the pattern located outside the sampling window.</p>
</td></tr>
<tr><td><code>$xout</code></td>
<td>
<p>(optional) a vector of <code class="reqn">x</code> coordinates of points located outside the sampling window.</p>
</td></tr>
<tr><td><code>$yout</code></td>
<td>
<p>(optional) a vector of <code class="reqn">y</code> coordinates of points located outside the sampling window.</p>
</td></tr>
<tr><td><code>$marks</code></td>
<td>
<p>(optional) a vector of the marks attached to points located inside the sampling window.</p>
</td></tr>
<tr><td><code>$marksout</code></td>
<td>
<p>(optional) a vector of the marks attached to points located outside the sampling window.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing, summary and plotting methods for <code>"spp"</code> objects.<br />
Function <code>ppp2spp</code> converts an <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> from package <code>spatstat.geom</code> into an <code>"spp"</code> object.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>References</h3>

<p>Goreaud, F. and P?Pelissier, R. 1999. On explicit formula of edge effect correction for Ripley's <em>K</em>-function. <em>Journal of Vegetation Science</em>, 10:433-438.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.spp">plot.spp</a></code>,
<code><a href="#topic+swin">swin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(BPoirier)
	BP &lt;- BPoirier
	## Not run: univariate pattern in a rectangle of size [0,110] x [0,90]
	swr &lt;- spp(BP$trees, win=BP$rect)
	## Not run: an alternative using atomic vectors of point coordinates
	swr &lt;- spp(BP$trees, win=BP$rect) 
	summary(swr)
	plot(swr)
	
	## Not run: univariate pattern in a circle with radius 50 centred on (55,45)
	swc &lt;- spp(BP$trees, win=c(55,45,50))
	summary(swc)
	plot(swc)
	plot(swc, out=TRUE) # plot points outside the circle

	## Not run: multivariate pattern in a rectangle of size [0,110] x [0,90]
	swrm &lt;- spp(BP$trees, win=BP$rect, marks=BP$species)
	summary(swrm)
	plot(swrm)
	plot(swrm, chars=c("b","h","o")) # replace symbols by letters
	
	## Not run: marked pattern in a rectangle of size [0,110] x [0,90]
	swrn &lt;- spp(BP$trees, win=BP$rect, marks=BP$dbh)
	summary(swrn)
	plot(swrn)
	
	## Not run: multivariate pattern in a complex sampling window
	swrt &lt;- spp(BP$trees, win=BP$rect, tri=BP$tri1, marks=BP$species)
	summary(swrt)
	plot(swrt)
	plot(swrt, out=TRUE) # plot points outside the sampling window
	
	
	## Not run: converting a ppp object from spatstat.geom
	data(demopat)
	demo.spp&lt;-ppp2spp(demopat)
	plot(demo.spp)
</code></pre>

<hr>
<h2 id='swin'>Creating a sampling window</h2><span id='topic+swin'></span><span id='topic+print.swin'></span><span id='topic+summary.swin'></span><span id='topic+print.summary.swin'></span><span id='topic+plot.swin'></span><span id='topic+owin2swin'></span>

<h3>Description</h3>

<p>Function <code>swin</code> creates an object of class <code>"swin"</code>, which represents 
the sampling window (or study region) in which a spatial point pattern was
observed. The <code>ads</code> library supports simple (rectangular or circular) and complex
sampling windows.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'> swin(window, triangles)
 owin2swin(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swin_+3A_window">window</code></td>
<td>
<p>a vector defining the limits of a simple sampling window: <code>c(xmin,ymin,xmax,ymax)</code>
for a rectangle ; <code>c(x0,y0,r0)</code> for a circle.</p>
</td></tr>
<tr><td><code id="swin_+3A_triangles">triangles</code></td>
<td>
<p>(optional) a list of triangles removed from a simple initial window to define a complex 
sampling window (see Details).</p>
</td></tr></table>
<p>'
</p>
<table>
<tr><td><code id="swin_+3A_w">w</code></td>
<td>
<p>a <code>"owin"</code> object from package <code>spatstat.geom</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sampling window may be of simple or complex type. A simple sampling window may be a rectangle or a circle.
A complex sampling window is defined by removing triangular surfaces from a simple (rectangular or circular)
initial sampling window.
</p>

<ul>
<li>
<p><b>rectangular window:</b>
<code>window=c(ximn,ymin,xmax,ymax)</code> a vector of length 4 giving the coordinates <code class="reqn">(ximn,ymin)</code> and <code class="reqn">(xmax,ymax)</code>
of the origin and the opposite corner of a rectangle.
</p>
</li>
<li>
<p><b>circular window:</b>
<code>window=c(x0,y0,r0)</code> a vector of length 3 giving the coordinates <code class="reqn">(x0,y0)</code>
of the centre and the radius <code class="reqn">r0</code> of a circle.
</p>
</li>
<li>
<p><b>complex window:</b>
<code>triangles</code> is a list of 6 variables giving the vertices coordinates <br />
<code class="reqn">(ax,ay,bx,by,cx,cy)</code> of the triangles to remove from a simple (rectangular or circular) initial window. The triangles may be removed 
near the boundary of a rectangular window in order to design a polygonal sampling window, or within a rectangle
or a circle, to delineating holes in the initial sampling window (see Examples). The triangles do not overlap each other, nor overlap boundary
of the initial sampling window. Any polygon (possibly with holes) can be decomposed into contiguous triangles using <code><a href="#topic+triangulate">triangulate</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"swin"</code> describing the sampling window. It may be of four different types
with different arguments:
</p>
<table>
<tr><td><code>$type</code></td>
<td>
<p>a vector of two character strings defining the type of sampling window among <code>c("simple","rectangle")</code>, <code>c("simple","circle")</code>, <code>c("complex","rectangle")</code> or <code>c("complex","circle")</code>.</p>
</td></tr>
<tr><td><code>$xmin</code>, <code>$ymin</code>, <code>$xmax</code>, <code>$ymax</code></td>
<td>
<p>(optional) coordinates of the origin and the opposite corner for a rectangular sampling window (see details).</p>
</td></tr>
<tr><td><code>$x0</code>, <code>$y0</code>, <code>$r0</code></td>
<td>
<p>(optional) coordinates of the centre and radius for a circular sampling window (see details).</p>
</td></tr>
<tr><td><code>$triangles</code></td>
<td>
<p>(optional) vertices coordinates of triangles for a complex sampling window (see details).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are printing, summary and plotting methods for <code>"swin"</code> objects.<br />
Function <code>owin2swin</code> converts an <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code> from package <code>spatstat.geom</code> into an <code>"swin"</code> object.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>References</h3>

<p>Goreaud, F. and P?Pelissier, R. 1999. On explicit formula of edge effect correction for Ripley's <em>K</em>-function. <em>Journal of Vegetation Science</em>, 10:433-438.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.swin">area.swin</a></code>,
<code><a href="#topic+inside.swin">inside.swin</a></code>,
<code><a href="#topic+spp">spp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: rectangle of size [0,110] x [0,90]
  wr &lt;- swin(c(0,0,110,90))
  summary(wr)
  plot(wr)
  
  ## Not run: circle with radius 50 centred on (55,45)
  wc &lt;- swin(c(55,45,50))
  summary(wc)
  plot(wc)
  
 ## Not run: polygon (diamond shape)
 t1 &lt;- c(0,0,55,0,0,45)
 t2 &lt;- c(55,0,110,0,110,45)
 t3 &lt;- c(0,45,0,90,55,90)
 t4 &lt;- c(55,90,110,90,110,45)
 wp &lt;- swin(wr, rbind(t1,t2,t3,t4))
 summary(wp)
 plot(wp)
 
 ## Not run: rectangle with a hole
 h1 &lt;- c(25,45,55,75,85,45)
 h2 &lt;- c(25,45,55,15,85,45)
 wrh &lt;- swin(wr, rbind(h1,h2))
 summary(wrh)
 plot(wrh)

 ## Not run: circle with a hole
 wch &lt;- swin(wc, rbind(h1,h2))
 summary(wch)
 plot(wch)
 
 ## Not run: converting an owin object from spatstat.geom
 data(demopat)
 demo.swin&lt;-owin2swin(demopat$window)
 plot(demo.swin)
</code></pre>

<hr>
<h2 id='triangulate'>Triangulate polygon</h2><span id='topic+triangulate'></span>

<h3>Description</h3>

<p>Function <code>triangulate</code> decomposes a simple polygon (optionally having holes) into contiguous triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(outer.poly, holes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate_+3A_outer.poly">outer.poly</code></td>
<td>
<p>a list with two component vectors <code>x</code> and <code>y</code> giving vertex coordinates of the polygon 
or a vector <code>(xmin,ymin,xmax,ymax)</code> giving coordinates <code class="reqn">(ximn,ymin)</code> and <code class="reqn">(xmax,ymax)</code> of the origin and the
opposite corner of a rectangle sampling window (see <code><a href="#topic+swin">swin</a></code>).  </p>
</td></tr>
<tr><td><code id="triangulate_+3A_holes">holes</code></td>
<td>
<p>(optional) a list (or a list of list) with two component vectors <code>x</code> and <code>y</code> giving vertices 
coordinates of inner polygon(s) delineating hole(s) within the <code>outer.poly</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In argument <code>outer.poly</code>, the vertices must be listed following boundary of the polygon without any repetition (i.e. do not repeat the first vertex).
Argument <code>holes</code> may be a list of vertices coordinates of a single hole (i.e. with <code class="reqn">x</code> and <code class="reqn">y</code> component vectors) or a list of list for multiple holes,
where each <code>holes[[i]]</code> is a list with <code class="reqn">x</code> and <code class="reqn">y</code> component vectors. Holes' vertices must all be inside the <code>outer.poly</code> boundary (vertices on the boundary 
are considered outside). Multiple holes do not overlap each others.
</p>


<h3>Value</h3>

<p>A list of 6 variables, suitable for using in <code><a href="#topic+swin">swin</a></code> and <code><a href="#topic+spp">spp</a></code>, and giving the vertices coordinates <code class="reqn">(ax,ay,bx,by,cx,cy)</code> of the triangles that
pave the polygon. For a polygon with <em>t</em> holes totaling <code class="reqn">n</code> vertices (outer contour + holes), the number of triangles produced 
is <code class="reqn">(n-2)+2t</code>, with <code class="reqn">n&lt;200</code> in this version of the program.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:Raphael.Pelissier@ird.fr">Raphael.Pelissier@ird.fr</a>
</p>


<h3>References</h3>

<p>Goreaud, F. and P?Pelissier, R. 1999. On explicit formula of edge effect correction for Ripley's <em>K</em>-function. <em>Journal of Vegetation Science</em>, 10:433-438.<br /><br />
Narkhede, A. &amp; Manocha, D. 1995. Fast polygon triangulation based on Seidel's algorithm. Pp 394-397 In A.W. Paeth (Ed.)
<em>Graphics Gems V</em>. Academic Press. <a href="http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html">http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spp">spp</a></code>,
<code><a href="#topic+swin">swin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BPoirier)
  BP &lt;- BPoirier
  plot(BP$poly1$x, BP$poly1$y)
  
  ## Not run: a single polygon triangulation
  tri1 &lt;- triangulate(BP$poly1)
  plot(swin(BP$rect, tri1))
  
  ## Not run: a single polygon with a hole
  tri2 &lt;- triangulate(c(-10,-10,120,100), BP$poly1)
  plot(swin(c(-10,-10,120,100), tri2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
