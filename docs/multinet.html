<!DOCTYPE html><html><head><title>Help for package multinet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multinet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multinet-package'>
<p>Multilayer social network analysis and mining</p></a></li>
<li><a href='#multinet.actor_measures'>
<p>Network analysis measures</p></a></li>
<li><a href='#multinet.attributes'>
<p>Managing attributes</p></a></li>
<li><a href='#multinet.classes'>
<p>Classes defined by the package</p></a></li>
<li><a href='#multinet.communities'>
<p>Community detection algorithms and evaluation functions</p></a></li>
<li><a href='#multinet.community.generation'>
<p>Generation of multilayer networks with a predefined community structure</p></a></li>
<li><a href='#multinet.conversion'>
<p>Conversion to a simple or multi graph</p></a></li>
<li><a href='#multinet.distance'>
<p>Network analysis measures: distance based</p></a></li>
<li><a href='#multinet.edge_directionality'>
<p>Controlling edge directionality</p></a></li>
<li><a href='#multinet.generation'>
<p>Generation of multilayer networks</p></a></li>
<li><a href='#multinet.IO'>
<p>Reading and writing multilayer networks from/to file</p></a></li>
<li><a href='#multinet.layer_comparison'>
<p>Network analysis measures</p></a></li>
<li><a href='#multinet.layout'>
<p>Layouts</p></a></li>
<li><a href='#multinet.navigation'>
<p>Functions to extract neighbors of vertices, to navigate the network</p></a></li>
<li><a href='#multinet.plotting'>
<p>Drawing a multilayer network</p></a></li>
<li><a href='#multinet.predefined'>
<p>Loading predefined multilayer networks</p></a></li>
<li><a href='#multinet.properties'>
<p>Listing network properties</p></a></li>
<li><a href='#multinet.transformation'>
<p>Functions to transform existing layers into new ones.</p></a></li>
<li><a href='#multinet.update'>
<p>Manipulation of multilayer networks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis and mining of multilayer social networks</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Magnani &lt;matteo.magnani@it.uu.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the creation/generation and analysis of multilayer social networks &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i08">doi:10.18637/jss.v098.i08</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph (&ge; 1.2), Rcpp (&ge; 1.0), methods, RColorBrewer</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>multinet</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Note:</td>
<td>a previous version of the library (main version number: 3) was
developed as part of the European Union's Horizon 2020 research
and innovation programme under grant agreement No. 727040
(Virt-EU). The package uses functions from eclat
&lt;https://borgelt.net/eclat.html&gt;, for association rule mining,
Infomap &lt;https://www.mapequation.org&gt;, for the Infomap
community detection method (please refer to their web site for
up-to-date code), and Howard Hinnant's date and time library
&lt;https://github.com/HowardHinnant/date&gt;. The code from these
libraries has been included in our source package.</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-12 18:29:54 UTC; matteomagnani</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Magnani [aut, cre],
  Luca Rossi [aut] (API design),
  Davide Vega [aut] (API and code design),
  Obaida Hanteer [ctb] (mdlpa, flat_ec, flat_nw, some community
    evaluation functions)</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-14 10:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='multinet-package'>
Multilayer social network analysis and mining
</h2><span id='topic+multinet-package'></span><span id='topic+multinet'></span>

<h3>Description</h3>

<p>This package defines a class to store multilayer networks and functions to pre-process, analyze and mine them.
</p>
<p>With <em>multilayer social network</em> we indicate a network where vertices (V) are organized into multiple layers (L) and each node corresponds to an actor (A), where the same actor can be mapped to nodes in different layers. Formally, a multilayer social network as implemented in this package is a graph G = (V, E) where V is a subset of A x L.
</p>
<p>In this manual, <em><a href="#topic+multinet.IO">multinet.IO</a></em> describes functions to read and write multilayer networks from/to file and the file format. To quickly test some features of the library, some existing multilayer networks are also included (<em><a href="#topic+multinet.predefined">multinet.predefined</a></em>). A synthetic multilayer network can be generated using the growing models described in <em><a href="#topic+multinet.generation">multinet.generation</a></em>.
</p>
<p>Updating and getting information about the basic components of a multilayer network (layers, actors, vertices and edges) can be done using the methods described in <em><a href="#topic+multinet.properties">multinet.properties</a></em>, <em><a href="#topic+multinet.update">multinet.update</a></em> and <em><a href="#topic+multinet.edge_directionality">multinet.edge_directionality</a></em>. <em><a href="#topic+multinet.navigation">multinet.navigation</a></em> shows how to retrieve the neighbors of a node. Attribute values can also be attached to the basic objects in a multilayer network (actors, layers, vertices and edges). Attribute management is described in <em><a href="#topic+multinet.attributes">multinet.attributes</a></em>.
</p>
<p>Each individual layer as well as combination of layers obtained using the data pre-processing (flattening) functions described in <em><a href="#topic+multinet.transformation">multinet.transformation</a></em> can be analyzed as a single-layer network using the iGraph package, by converting them as shown in <em><a href="#topic+multinet.conversion">multinet.conversion</a></em>. We can also visualize small networks using the method described in <em><a href="#topic+multinet.plotting">multinet.plotting</a></em> and the layouts in <em><a href="#topic+multinet.layout">multinet.layout</a></em>.
</p>
<p>Multilayer network analysis measures are described in <em><a href="#topic+multinet.actor_measures">multinet.actor_measures</a></em> (for single-actor, degree-based measures), <em><a href="#topic+multinet.distance">multinet.distance</a></em> (for measures based on geodesic distances) and <em><a href="#topic+multinet.layer_comparison">multinet.layer_comparison</a></em> (to compare different layers).
</p>
<p>Communities can be extracted using various clustering algorithms, described in <em><a href="#topic+multinet.communities">multinet.communities</a></em>.
</p>
<p>Most of the methods provided by this package are described in the book &quot;Multilayer Social Networks&quot;. These methods have been proposed by many different authors: extensive references are available in the book, and in the documentation of each function we indicate the main reference we have followed for the implementation. For a few methods developed after the book was published we give specific references to the corresponding literature.
</p>


<h3>Author(s)</h3>

<p>Matteo Magnani <a href="mailto:matteo.magnani@it.uu.se">matteo.magnani@it.uu.se</a>
</p>


<h3>References</h3>

<p>Dickison, Magnani, and Rossi, 2016. Multilayer Social Networks. Cambridge University Press. ISBN: 978-1107438750
</p>
<p>Magnani, Rossi, and Vega, 2021. Analysis of Multiplex Social Networks with R. Journal of Statistical Software 98(8), 1-30. doi: 10.18637/jss.v098.i08
</p>

<hr>
<h2 id='multinet.actor_measures'>
Network analysis measures
</h2><span id='topic+multinet.actor_measures'></span><span id='topic+degree_ml'></span><span id='topic+degree_deviation_ml'></span><span id='topic+neighborhood_ml'></span><span id='topic+xneighborhood_ml'></span><span id='topic+connective_redundancy_ml'></span><span id='topic+relevance_ml'></span><span id='topic+xrelevance_ml'></span>

<h3>Description</h3>

<p>These functions compute network analysis measures providing a basic description of the actors in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_ml(n, actors = character(0), layers = character(0), mode = "all")
degree_deviation_ml(n, actors = character(0),
  layers = character(0), mode = "all")
neighborhood_ml(n, actors = character(0),layers = character(0), mode = "all")
xneighborhood_ml(n, actors = character(0),layers = character(0), mode = "all")
connective_redundancy_ml(n, actors = character(0),
  layers = character(0), mode = "all")
relevance_ml(n, actors = character(0),layers = character(0), mode = "all")
xrelevance_ml(n, actors = character(0),layers = character(0), mode = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.actor_measures_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.actor_measures_+3A_actors">actors</code></td>
<td>
<p>An array of names of actors.</p>
</td></tr>
<tr><td><code id="multinet.actor_measures_+3A_layers">layers</code></td>
<td>
<p>An array of names of layers.</p>
</td></tr>
<tr><td><code id="multinet.actor_measures_+3A_mode">mode</code></td>
<td>
<p>This argument can take values &quot;in&quot;, &quot;out&quot; or &quot;all&quot; to count respectively incoming edges, outgoing edges or both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>degree_ml</code> returns the number of edges adjacent to the input actor restricted to the specified layers.
<code>degree_deviation_ml</code> returns the standard deviation of the degree of an actor on the input layers. An actor with the same
degree on all layers will have deviation 0, while an actor with a lot of neighbors on one layer and only a few on another will have
a high degree deviation, showing an uneven usage of the layers (or layers with different densities).
</p>
<p><code>neighborhood_ml</code> returns the number of actors adjacent to the input actor restricted to the specified layers. <code>xneighborhood_ml</code> returns the number of actors adjacent to the input actor restricted to the specified layers and not present in the other layers.
</p>
<p><code>connective_redundancy_ml</code> returns 1 minus neighborhood divided by degree_
</p>
<p><code>relevance_ml</code> returns the percentage of neighbors present on the specified layers. <code>xrelevance_ml</code> returns the percentage of neighbors present on the specified layers and not on others.
</p>


<h3>References</h3>


<ul>
<li><p> Berlingerio, Michele, Michele Coscia, Fosca Giannotti, Anna Monreale, and Dino Pedreschi. 2011. &quot;Foundations of Multidimensional Network Analysis.&quot; In International Conference on Social Network Analysis and Mining (ASONAM), 485-89. IEEE Computer Society.
</p>
</li>
<li><p> Magnani, Matteo, and Luca Rossi. 2011. &quot;The ML-Model for Multi-Layer Social Networks.&quot; In International conference on Social Network Analysis and Mining (ASONAM), 5-12. IEEE Computer Society.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
# degrees of all actors, considering edges on all layers
degree_ml(net)
# degree of actors U54 and U3, only considering layers work and coauthor
degree_ml(net,c("U54","U3"),c("work","coauthor"),"in")
# an indication of whether U54 and U3 are selectively active only on some layers
degree_deviation_ml(net,c("U54","U3"))
# co-workers of U3
neighborhood_ml(net,"U3","work")
# co-workers of U3 who are not connected to U3 on other layers
xneighborhood_ml(net,"U3","work")
# percentage of neighbors of U3 who are also co-workers
relevance_ml(net,"U3","work")
# redundancy between work and lunch
connective_redundancy_ml(net,"U3",c("work","lunch"))
# percentage of neighbors of U3 who would no longer
# be neighbors by removing this layer
xrelevance_ml(net,"U3","work")
</code></pre>

<hr>
<h2 id='multinet.attributes'>
Managing attributes
</h2><span id='topic+multinet.attributes'></span><span id='topic+add_attributes_ml'></span><span id='topic+attributes_ml'></span><span id='topic+set_values_ml'></span><span id='topic+get_values_ml'></span>

<h3>Description</h3>

<p>These functions are used to assign and retrieve values to/from actors, vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attributes_ml(n, attributes, type="string", target="actor",
	layer="", layer1="", layer2="")
attributes_ml(n, target="actor")
get_values_ml(n, attribute, actors=character(0),
	vertices =character(0), edges=character(0))
set_values_ml(n, attribute, actors=character(0),
	vertices=character(0), edges=character(0), values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.attributes_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_attributes">attributes</code></td>
<td>
<p>Name(s) of the attributes to be created.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_target">target</code></td>
<td>
<p>Can be &quot;actor&quot; (attributes attached to actors), &quot;vertex&quot; (attributes attached to vertices) or &quot;edge&quot; (attributes attached to edges). Layer attributes are not available in this version.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_type">type</code></td>
<td>
<p>Can be &quot;string&quot; or &quot;numeric&quot;.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_layer">layer</code></td>
<td>
<p>This can be specified only for targets &quot;vertex&quot; (so that the attribute exists only for the vertices in that layer) or &quot;edge&quot; (in which case the attribute applies to intra-layer edges in that layer).</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_layer1">layer1</code></td>
<td>
<p>This can be specified only for target &quot;edge&quot;, together with layer2, so that the attribute applies to inter-layer edges from layer1 to layer2. If <code>layer1</code> and <code>layer2</code> are specified, the parameter <code>layer</code> should not be used.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_layer2">layer2</code></td>
<td>
<p>See layer1.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_attribute">attribute</code></td>
<td>
<p>The name of the attribute to be updated.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_actors">actors</code></td>
<td>
<p>A dataframe containing a vector of actor names (&quot;actor&quot;). If this is specified, layers, vertices and edges should not.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_vertices">vertices</code></td>
<td>
<p>A dataframe of vertices to be updated. The first column specifies actor names, the second layer names. If this is specified, actors, layers and edges should not.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_edges">edges</code></td>
<td>
<p>A dataframe containing the vertices to be connected. The four columns must contain, in this order: actor1 name, layer1 name, actor2 name, layer2 name. If this is specified, actors, layers and vertices should not.</p>
</td></tr>
<tr><td><code id="multinet.attributes_+3A_values">values</code></td>
<td>
<p>A vector of values to be set for the corresponding actors, vertices or edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>attributes_ml</code> returns a data frame with columns: &quot;name&quot;, and &quot;type&quot;. If vertex attributes are listed, an additional &quot;layer&quot; column is used. If edge attributes are listed, two columns &quot;layer1&quot; and &quot;layer2&quot; are included.
<code>get_values_ml</code> returns a data frame with the values for the requested objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.properties">multinet.properties</a>, <a href="#topic+multinet.edge_directionality">multinet.edge_directionality</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
attributes_ml(net)
# actor attributes, of string type (default)
add_attributes_ml(net,c("name","surname"))
# a numeric attribute associated to the layers (not available in this version)
# add_attributes_ml(net,"num vertices",type="numeric",target="layer")
# attributes for vertices on the facebook layer
add_attributes_ml(net,"username",type="string",target="vertex",layer="facebook")
# attributes for edges on the work layer
add_attributes_ml(net,"strength",type="numeric",target="edge",layer="work")
# listing the attributes
attributes_ml(net)
# attributes_ml(net,"layer") # not available in this version
attributes_ml(net,"vertex")
attributes_ml(net,"edge")
# setting some values for the newly created attributes
set_values_ml(net,"name",actors=data.frame(actor=c("U54","U139")),values=c("John","Johanna"))
e &lt;- data.frame(
    c("U139","U139"),
    c("work","work"),
    c("U71","U97"),
    c("work","work"))
set_values_ml(net,"strength",edges=e,values=.47)
# getting the values back
get_values_ml(net,"name",actors=data.frame(actor="U139"))
get_values_ml(net,"strength",edges=e)
# setting attributes based on network properties: create a "degree"
# attribute and set its value to the degree of each actor
actors_ml(net)$actor -&gt; a
layers_ml(net) -&gt; l
degree_ml(net,actors=a,layers=l,mode="all") -&gt; d
add_attributes_ml(net,target="actor",type="numeric",attributes="degree")
set_values_ml(net,attribute="degree",actors=data.frame(actor=a),values=d)
get_values_ml(net,attribute="degree",actors=data.frame(actor="U54"))
# select actors based on attribute values (e.g., with degree greater than 40)
get_values_ml(net,attribute="degree",actors=data.frame(actor=a)) -&gt; values
a[values$degree&gt;40]
# list all the attributes again
attributes_ml(net)
</code></pre>

<hr>
<h2 id='multinet.classes'>
Classes defined by the package
</h2><span id='topic+multinet.classes'></span><span id='topic+RMLNetwork-class'></span><span id='topic+REvolutionModel'></span><span id='topic+Rcpp_REvolutionModel-class'></span>

<h3>Description</h3>

<p>The multinet package defines two classes to represent multilayer networks (RMLNetwork) and evolutionary models for the generation of networks (REvolutionModel). Objects of these types are used as input or returned as output of the functions provided by the package, as detailed in the description of each function.
</p>

<hr>
<h2 id='multinet.communities'>
Community detection algorithms and evaluation functions
</h2><span id='topic+multinet.communities'></span><span id='topic+abacus_ml'></span><span id='topic+clique_percolation_ml'></span><span id='topic+glouvain_ml'></span><span id='topic+flat_ec_ml'></span><span id='topic+flat_nw_ml'></span><span id='topic+infomap_ml'></span><span id='topic+mdlp_ml'></span><span id='topic+get_community_list_ml'></span><span id='topic+modularity_ml'></span><span id='topic+nmi_ml'></span><span id='topic+omega_index_ml'></span>

<h3>Description</h3>

<p>Various algorithms to compute communities in multiplex networks, based on flattening (flat_ec, weighted, and flat_wc, unweighted), frequent itemset mining (abacus), adjacent cliques (clique percolation), modularity optimization (generalized louvain), random walks (infomap) and label propagation (mdlp). glouvain2_ml is a more efficient implementation of the original glouvain_ml, no longer based on matrices: it is equivalent to glouvain_ml with gamma set by default to 1.0 (apart from undeterministic behaviour: individual executions are not guaranteed to return the same result). get_community_list_ml is a commodity function translating the result of these algorithms into a list of vertex identifiers, and is internally used by the plotting function.
</p>
<p>There are also algorithms to evaluate the resulting communities: generalized modularity (as optimized by
glouvain) and normalized mutual information (nmi_ml) and omega index (omega_index_ml) to compare
respectively partitioning and general communities. Please consider that both comparison functions use
the number of vertices in the network to make a computation, so the absence of actors from some layers
would change their result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abacus_ml(n, min.actors=3, min.layers=1)
flat_ec_ml(n)
flat_nw_ml(n)
clique_percolation_ml(n, k=3, m=1)
glouvain_ml(n, gamma=1, omega=1)
infomap_ml(n, overlapping=FALSE, directed=FALSE, self.links=TRUE)
mdlp_ml(n)

modularity_ml(n, comm.struct, gamma=1, omega=1)
nmi_ml(n, com1, com2)
omega_index_ml(n, com1, com2)
get_community_list_ml(comm.struct, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.communities_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_min.actors">min.actors</code></td>
<td>
<p>Minimum number of actors to form a community.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_min.layers">min.layers</code></td>
<td>
<p>Minimum number of times two actors must be in the same single-layer community to be considered in the same multi-layer community.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_k">k</code></td>
<td>
<p>Minimum number of actors in a clique. Must be at least 3.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_m">m</code></td>
<td>
<p>Minimum number of common layers in a clique.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_gamma">gamma</code></td>
<td>
<p>Resolution parameter for modularity in the generalized louvain method.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_omega">omega</code></td>
<td>
<p>Inter-layer weight parameter in the generalized louvain method.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_overlapping">overlapping</code></td>
<td>
<p>Specifies if overlapping clusters can be returned.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_directed">directed</code></td>
<td>
<p>Specifies whether the edges should be considered as directed.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_self.links">self.links</code></td>
<td>
<p>Specifies whether self links should be considered or not.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_comm.struct">comm.struct</code></td>
<td>
<p>The result of a community detection method.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_com1">com1</code></td>
<td>
<p>The result of a community detection method.</p>
</td></tr>
<tr><td><code id="multinet.communities_+3A_com2">com2</code></td>
<td>
<p>The result of a community detection method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All community detection algorithms return a data frame where each row contains actor name, layer name and community identifier.
</p>
<p>The evaluation functions return a number between -1 and 1. For the comparison functions, 1 indicates
that the two community structures are equivalent. The maximum possible value of modularity is &lt;= 1
and depends on the network, so modularity results should not be compared across different networks.
Also, notice that modularity is only defined for partitioning community structures.
</p>
<p><code>get_community_list_ml</code> transforms the output of a community detection function into a list by grouping all the nodes having the same community identifier and the same layer.
</p>


<h3>References</h3>


<ul>
<li><p> Berlingerio, Michele, Pinelli, Fabio, and Calabrese, Francesco (2013). ABACUS: frequent pAttern mining-BAsed Community discovery in mUltidimensional networkS. Data Mining and Knowledge Discovery, 27(3), 294-320. (for abacus_ml())
</p>
</li>
<li><p> Afsarmanesh, Nazanin, and Magnani, Matteo (2018). Partial and overlapping community detection in multiplex social networks. Social informatics (for clique_percolation_ml())
</p>
</li>
<li><p> Mucha, Peter J., Richardson, Thomas, Macon, Kevin, Porter, Mason A., and Onnela, Jukka-Pekka (2010). Community structure in time-dependent, multiscale, and multiplex networks. Science (New York, N.Y.), 328(5980), 876-8. Data Analysis, Statistics and Probability; Physics and Society. (for glouvain_ml())
</p>
</li>
<li><p> Michele Berlingerio, Michele Coscia, and Fosca Giannotti. Finding and characterizing communities in multidimensional networks. In International Conference on Advances in Social Networks Analysis and Mining (ASONAM), pages 490-494. IEEE Computer Society Washington, DC, USA, 2011  (for flat_ec_ml() and flat_nw_ml())
</p>
</li>
<li><p> De Domenico, M., Lancichinetti, A., Arenas, A., and Rosvall, M. (2015)
Identifying Modular Flows on Multilayer Networks Reveals Highly Overlapping Organization in Interconnected Systems. PHYSICAL REVIEW X 5, 011027 (for infomap_ml())
</p>
</li>
<li><p> Oualid Boutemine and Mohamed Bouguessa. Mining Community Structures in Multidimensional Networks. ACM Transactions on Knowledge Discovery from Data, 11(4):1-36, 2017 (for mdlp_ml())
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+multinet.plotting">multinet.plotting</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_florentine()
abacus_ml(net)
flat_ec_ml(net)
flat_nw_ml(net)
clique_percolation_ml(net)
glouvain_ml(net)
infomap_ml(net)
mdlp_ml(net)

# evaluation

c1 &lt;- glouvain_ml(net)
modularity_ml(net, c1)

c2 &lt;- flat_ec_ml(net)
nmi_ml(net, c1, c2)

c3 &lt;- abacus_ml(net)
omega_index_ml(net, c1, c2)
</code></pre>

<hr>
<h2 id='multinet.community.generation'>
Generation of multilayer networks with a predefined community structure
</h2><span id='topic+multinet.community.generation'></span><span id='topic+generate_communities_ml'></span>

<h3>Description</h3>

<p>The generate_communities_ml function generates a simple community structure and a corresponding
network with edges sampled according to that structure. Four simple models are available at the
moment, all generating communities of equal size. In pillar community structures each actor belongs to
the same community on all layers, while in semipillar community structures the communities in one
layer are different from the other layers. In partitioning community structures each vertex belongs
to one community, while in overlapping community structures some vertices belong to multiple
communities. The four mode are: PEP (pillar partitioning), PEO (pillar overlapping),
SEP (semipillar partitioning), SEO (semipillar overlapping).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_communities_ml(type, num.actors, num.layers, num.communities, overlap=0,
    pr.internal=.4, pr.external=.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.community.generation_+3A_type">type</code></td>
<td>
<p>Type of community structure: pep, peo, sep or seo.</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_num.actors">num.actors</code></td>
<td>
<p>The number of actors in the generated network.</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_num.layers">num.layers</code></td>
<td>
<p>The number of layers in the generated network.</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_num.communities">num.communities</code></td>
<td>
<p>The number of communities in the generated network.</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_overlap">overlap</code></td>
<td>
<p>Number of actors at the end of one community to be also included in the following community.</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_pr.internal">pr.internal</code></td>
<td>
<p>A vector with the probability of adjacency for two vertices on the same layer
and community (either a single value, or one value for each layer).</p>
</td></tr>
<tr><td><code id="multinet.community.generation_+3A_pr.external">pr.external</code></td>
<td>
<p>A vector with the probability of adjacency for two vertices on the same layer
but different communities (either a single value, or one value for each layer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>generate_communities_ml</code> returns a list with two elements: a multilayer network and the
community structure used to generate it.
</p>


<h3>References</h3>

<p>Matteo Magnani, Obaida Hanteer, Roberto Interdonato, Luca Rossi, and Andrea Tagarelli (2021).
Community Detection in Multiplex Networks. ACM Computing Surveys.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.generation">multinet.generation</a>, <a href="#topic+multinet.IO">multinet.IO</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we generate a network with three layers and 10 communities.
generate_communities_ml("pep", 50, 3, 10)
# the following command also adds some overlapping (1 actor shared between consecutive communities).
generate_communities_ml("pep", 50, 3, 10, 1)
# the following command adds 10 different communities on the last layer.
generate_communities_ml("sep", 50, 3, 20)
# here we add some noise and make communities less dense than the defaults.
generate_communities_ml("pep", 50, 3, 10, pr.internal=.3, pr.external=.05)
</code></pre>

<hr>
<h2 id='multinet.conversion'>
Conversion to a simple or multi graph
</h2><span id='topic+multinet.conversion'></span><span id='topic+as.igraph.multinet'></span><span id='topic+as.igraph.Rcpp_RMLNetwork'></span>

<h3>Description</h3>

<p>Constructs a single graph resulting from merging one or more layers of the network and converts it into an iGraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_RMLNetwork'
as.igraph(x, layers = NULL, merge.actors = TRUE, all.actors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.conversion_+3A_x">x</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.conversion_+3A_layers">layers</code></td>
<td>
<p>A vector of names of layers. If <code>NULL</code>, all layers are included in the result.</p>
</td></tr>
<tr><td><code id="multinet.conversion_+3A_merge.actors">merge.actors</code></td>
<td>
<p>Whether the vertices corresponding to each actor should be merged into a single vertex (true) or kept separated (false).</p>
</td></tr>
<tr><td><code id="multinet.conversion_+3A_all.actors">all.actors</code></td>
<td>
<p>Whether all actors in the multilayer network should be included in the result (true) or only those present in at least one of the input layers (false). This option does not currently make any difference, as only actors who are present in at least one layer can exist since version 4.0.</p>
</td></tr>
<tr><td><code id="multinet.conversion_+3A_...">...</code></td>
<td>
<p>Additional arguments. None currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class iGraph.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.transformation">multinet.transformation</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
# using the default merge.actors=TRUE we create a multigraph,
# where each actor corresponds to a vertex in the result
multigraph &lt;- as.igraph(net)
# this is a simple graph corresponding to the facebook layer
facebook1 &lt;- as.igraph(net, "facebook")
# this includes also the actors without a facebook account
facebook2 &lt;- as.igraph(net, "facebook", all.actors=TRUE)
# two layers are converted to an igraph object, where two
# vertices are used for each actor: one corresponding to the
# vertex on facebook, one to the vertex on lunch
f_l_net &lt;- as.igraph(net, c("facebook","lunch"),
    merge.actors=FALSE)
</code></pre>

<hr>
<h2 id='multinet.distance'>
Network analysis measures: distance based
</h2><span id='topic+multinet.distance'></span><span id='topic+distance_ml'></span>

<h3>Description</h3>

<p>This function is based on the concept of multilayer distance. This concept generalizes single-layer distance to a vector with the distance traveled on each layer (in the &quot;multiplex&quot; case). Therefore, non-dominated path lengths are returned instead of shortest path length, where one path length dominates another if it is not longer on all layers, and shorter on at least one. A non-dominated path length is also known as a Pareto distance. Finding all multilayer distances can be very time-consuming for large networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_ml(n, from, to=character(0), method="multiplex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.distance_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.distance_+3A_from">from</code></td>
<td>
<p>The actor from which the distance is computed.</p>
</td></tr>
<tr><td><code id="multinet.distance_+3A_to">to</code></td>
<td>
<p>The actor(s) to which the distance is computed. If not specified, all actors are considered.</p>
</td></tr>
<tr><td><code id="multinet.distance_+3A_method">method</code></td>
<td>
<p>This argument can take values &quot;simple&quot;, &quot;multiplex&quot;, &quot;full&quot;. Only &quot;multiplex&quot; is currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each non-dominated distance, specifying the number of steps in each layer.
</p>


<h3>References</h3>

<p>Magnani, Matteo, and Rossi, Luca (2013). Pareto Distance for Multi-layer Network Analysis. In Social Computing, Behavioral-Cultural Modeling and Prediction (Vol. 7812, pp. 249-256). Springer Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.actor_measures">multinet.actor_measures</a>, <a href="#topic+multinet.layer_comparison">multinet.layer_comparison</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
distance_ml(net,"U54","U3")
</code></pre>

<hr>
<h2 id='multinet.edge_directionality'>
Controlling edge directionality
</h2><span id='topic+multinet.edge_directionality'></span><span id='topic+set_directed_ml'></span><span id='topic+is_directed_ml'></span>

<h3>Description</h3>

<p>Functions to get and set the edge directionality of one or more pairs of layers (that is, the directionality of edges connecting nodes in those layers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_directed_ml(n, directionalities)
is_directed_ml(n, layers1 = character(0), layers2 = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.edge_directionality_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.edge_directionality_+3A_directionalities">directionalities</code></td>
<td>
<p>A dataframe with three columns where each row contains a pair of layers (l1,l2) and 0 or 1 (indicating resp. undirected and directed edges). Directionality is automatically set for both (l1,l2) and (l2,l1).</p>
</td></tr>
<tr><td><code id="multinet.edge_directionality_+3A_layers1">layers1</code></td>
<td>
<p>The layer(s) from where the edges start. If <code>layers1</code> is not provided, all layers are considered.</p>
</td></tr>
<tr><td><code id="multinet.edge_directionality_+3A_layers2">layers2</code></td>
<td>
<p>The layer(s) where the edges end. If an empty list of layers is passed (default), the ending layers are set as equal to those in parameter <code>layers1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_directed_ml</code> returns a data frame where each row contains the name of two layers and the corresponding type of edges (directed/undirected).
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.properties">multinet.properties</a>, <a href="#topic+multinet.attributes">multinet.attributes</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_empty()
# Adding some layers, one directed and one undirected
add_layers_ml(net,c("l1","l2"),c(TRUE,FALSE))
# Setting the directionality of inter-layer edges
layers = c("l1","l2")
dir &lt;- data.frame(layers,layers,c(0,1))
set_directed_ml(net,dir)
# retrieving all directionalities
dir &lt;- is_directed_ml(net)
# copying directionalities to a new network
net2 &lt;- ml_empty()
add_layers_ml(net2,c("l1","l2"))
set_directed_ml(net2,dir)
</code></pre>

<hr>
<h2 id='multinet.generation'>
Generation of multilayer networks
</h2><span id='topic+multinet.generation'></span><span id='topic+grow_ml'></span><span id='topic+evolution_pa_ml'></span><span id='topic+evolution_er_ml'></span>

<h3>Description</h3>

<p>The grow_ml function generates a multilayer network by letting it grow for a number of steps, where for each step three events can happen: (1) evolution according to internal dynamics (in which case a specific internal evolution model is used), (2) evolution importing edges from another layer, and (3) no action. The functions evolution_pa_ml and evolution_er_ml define, respectively, an evolutionary model based on preferential attachment and an evolutionary model where edges are created by choosing random end points, as in the ER random graph model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_ml(num.actors, num.steps, models, pr.internal, pr.external, dependency)
evolution_pa_ml(m0,m)
evolution_er_ml(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.generation_+3A_num.actors">num.actors</code></td>
<td>
<p>The number of actors from which new nodes are selected during the generation process.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of timestamps.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_models">models</code></td>
<td>
<p>A vector containing one evolutionary model for each layer to be generated. Evolutionary models are defined using the <code>evolution_*_ml</code> functions.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_pr.internal">pr.internal</code></td>
<td>
<p>A vector with (for each layer) the probability that at each step the layer evolves according to the internal evolutionary model.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_pr.external">pr.external</code></td>
<td>
<p>A vector with (for each layer) the probability that at each step the layer evolves importing edges from another layer.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_dependency">dependency</code></td>
<td>
<p>A matrix LxL where element (i,j) indicates the probability that layer i will import an edge from layer j in case an external event is triggered.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_m0">m0</code></td>
<td>
<p>Initial number of nodes.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_m">m</code></td>
<td>
<p>Number of edges created for each new vertex joining the network.</p>
</td></tr>
<tr><td><code id="multinet.generation_+3A_n">n</code></td>
<td>
<p>Number of vertices (created at the beginning, before starting adding edges).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>grow_ml</code> returns a multilayer network. <code>evolution_*_ml</code> return evolutionary models that are used by <code>grow_ml</code> to decide how each layer should grow.
</p>


<h3>References</h3>

<p>Magnani, Matteo, and Luca Rossi. 2013. Formation of Multiple Networks. In Social Computing, Behavioral-Cultural Modeling and Prediction, 257-264. Springer Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.predefined">multinet.predefined</a>, <a href="#topic+multinet.IO">multinet.IO</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we generate a network with two layers, one growing according
# to the Preferential Attachment model and one growing by selecting
# new edges uniformly at random.
models &lt;- c(evolution_pa_ml(3,1), evolution_er_ml(50))
# all the probability vectors must have the same number of
# fields, one for each layer: two in this example
# by defining pr.internal and pr.external, we are also implicitely defining
# pr.no.action (1 minus the other probabilities, for each field/layer).
pr_external &lt;- c(.5,0)
pr_internal &lt;- c(.5,.5)
# each layer will import edges from the other if needed
# (not the second layer in this example: it has 0 probability of external events)
dependency &lt;- matrix(c(0,1,1,0),2,2)
# 100 steps of network growing, adding actors from a pool of 100
grow_ml(100, 100, models, pr_internal, pr_external, dependency)
</code></pre>

<hr>
<h2 id='multinet.IO'>
Reading and writing multilayer networks from/to file
</h2><span id='topic+multinet.IO'></span><span id='topic+read_ml'></span><span id='topic+write_ml'></span>

<h3>Description</h3>

<p>These functions are used to store a multilayer network to a file or load it from a file.
</p>
<p>There are two network formats accepted: multiplex (default) or multilayer. A full multiplex network input file has the following format:
</p>
<p><code style="white-space: pre;">&#8288;
 -- comment lines start with two dashes (--)
 #VERSION
 3.0

 #TYPE
 multiplex

 #ACTOR ATTRIBUTES
 AttributeName1,STRING
 AttributeName2,NUMERIC
 -- etc.

 #NODE ATTRIBUTES
 LayerName1,AttributeName1,STRING
 LayerName1,AttributeName2,NUMERIC
 LayerName2,AttributeName3,STRING
 -- etc.

 #EDGE ATTRIBUTES
 -- edge attributes can be defined for specific layers (called local attributes):
 LayerName1,AttributeName,STRING
 LayerName1,AttributeName,NUMERIC
-- or for all layers (called global attributes):
AnotherAttributeName,NUMERIC
 -- etc.

 #LAYERS
 LayerName1,UNDIRECTED
 LayerName2,DIRECTED
 LayerName3,UNDIRECTED,LOOPS
 -- etc.
 -- LOOPS indicates that edges from one vertex to itself (called loops) are allowed on that layer

 #ACTORS
 ActorName1,AttributeValueList...
 ActorName2,AttributeValueList...
 -- etc.

 #VERTICES
 ActorName1,LayerName1,AttributeValueList...
 ActorName1,LayerName2,AttributeValueList...
 -- etc.

 #EDGES
 ActorName1,ActorName2,LayerName1,LocalAttributeValueList,GlobalAttributeValueList...
 -- etc.
 -- the attribute values must be specified in the same order in which they are defined above

 ----------------------------------
&#8288;</code>
</p>
<p>If the #LAYERS section is empty, all edges are created as undirected.
</p>
<p>If the #ACTOR ATTRIBUTES, #VERTEX ATTRIBUTES or #EDGE ATTRIBUTES sections are empty,
no attributes are created.
</p>
<p>The #LAYERS, #ACTORS and #VERTICES sections are useful only if attributes are present, or if there
are actors that are not present in any layer (#ACTORS), or if there are isolated vertices
(#VERTICES), otherwise they can be omitted.
</p>
<p>If no section is specified, #EDGES is the default.
</p>
<p>Therefore, a non attributed, undirected multiplex network file can be as simple as:
<code style="white-space: pre;">&#8288;
 ----------------------------------
 Actor1,Actor2,Layer1
 Actor1,Actor3,Layer1
 Actor4,Actor2,Layer2
 ----------------------------------
 &#8288;</code>
</p>
<p>If interlayer edges exist, then type &quot;multilayer&quot; must be specified, and layers and edges
are formatted in a different way:
</p>
<p><code style="white-space: pre;">&#8288;
#VERSION
3.0

#TYPE
multilayer

#ACTOR ATTRIBUTES
AttributeName1,STRING
AttributeName2,NUMERIC
-- etc.

#NODE ATTRIBUTES
LayerName1,AttributeName1,STRING
LayerName1,AttributeName2,NUMERIC
LayerName2,AttributeName3,STRING
-- etc.

#EDGE ATTRIBUTES
-- edge attributes can be defined for specific layers:
LayerName1,AttributeName,STRING
LayerName1,AttributeName,NUMERIC
-- or for all layers (called global attributes):
AnotherAttributeName,NUMERIC
-- etc.

#LAYERS
-- LayerName1,LayerName1,UNDIRECTED
-- LayerName2,LayerName2,DIRECTED
-- LayerName3,LayerName3,DIRECTED,LOOPS
-- LayerName1,LayerName2,DIRECTED
-- etc.
-- all intra-layer specifications (where the first and second layers are the same)
-- should be listed first.
-- LOOPS is only allowed for intra-layer specifications.

#ACTORS
ActorName1,AttributeValueList...
ActorName2,AttributeValueList...
-- etc.

#VERTICES
ActorName1,LayerName1,AttributeValueList...
ActorName1,LayerName2,AttributeValueList...
-- etc.

#EDGES
-- ActorName1,LayerName1,ActorName2,LayerName2,LocalAttributeValueList,GlobalAttributeValueList...
-- etc.

----------------------------------
&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ml(file, name = "unnamed", sep = ',', aligned = FALSE)
write_ml(n, file, format = "multilayer", layers = character(0),
  sep = ',', merge.actors = TRUE, all.actors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.IO_+3A_file">file</code></td>
<td>
<p>The path of the file storing the multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_name">name</code></td>
<td>
<p>The name of the multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_layers">layers</code></td>
<td>
<p>If specific layers are passed to the function, only those layers are saved to file.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_format">format</code></td>
<td>
<p>Either &quot;multilayer&quot;, to use the package's internal format, or &quot;graphml&quot;.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_sep">sep</code></td>
<td>
<p>The character used in the file to separate text fields.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_aligned">aligned</code></td>
<td>
<p>If <code>true</code>, all actors are added to all layers.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_merge.actors">merge.actors</code></td>
<td>
<p>Whether the nodes corresponding to each single actor should be merged into a single node (<code>true</code>) or kept separated (<code>false</code>), when <code>format = "graphml"</code> is used.</p>
</td></tr>
<tr><td><code id="multinet.IO_+3A_all.actors">all.actors</code></td>
<td>
<p>Whether all actors in the multilayer network should be included in the output file (true) or only those present in at least one of the input layers (false), when <code>format = "graphml"</code> and <code>merge.actors = TRUE</code> are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_ml</code> returns a multilayer network. <code>write_ml</code> does not return any value.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.predefined">multinet.predefined</a>, <a href="#topic+multinet.generation">multinet.generation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># writing a network to file...
file &lt;- tempfile("aucs.mpx")
net &lt;- ml_aucs()
write_ml(net,file)
# ...and reading it back into a variable
net &lt;- read_ml(file,"AUCS")
net
# the following network has more nodes, because all
# actors are replicated to all graphs
net_aligned &lt;- read_ml(file,"AUCS",aligned=TRUE)
net_aligned
</code></pre>

<hr>
<h2 id='multinet.layer_comparison'>
Network analysis measures
</h2><span id='topic+multinet.layer_comparison'></span><span id='topic+layer_summary_ml'></span><span id='topic+layer_comparison_ml'></span>

<h3>Description</h3>

<p>These functions can be used to compare different layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_summary_ml(n, layer, method = "entropy.degree", mode = "all")
layer_comparison_ml(n, layers = character(0),
method = "jaccard.edges", mode = "all", K = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.layer_comparison_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.layer_comparison_+3A_layer">layer</code></td>
<td>
<p>The name of a layer.</p>
</td></tr>
<tr><td><code id="multinet.layer_comparison_+3A_layers">layers</code></td>
<td>
<p>Names of the layers to be compared. If not specified, all layers are used.</p>
</td></tr>
<tr><td><code id="multinet.layer_comparison_+3A_method">method</code></td>
<td>
<p>This argument can take several values. For layer summary:
&quot;min.degree&quot;, &quot;max.degree&quot;, &quot;sum.degree&quot;, &quot;mean.degree&quot;, &quot;sd.degree&quot;, &quot;skewness.degree&quot;, &quot;kurtosis.degree&quot;, &quot;entropy.degree&quot;, &quot;CV.degree&quot;, &quot;jarque.bera.degree&quot;.
For layer comparison:
</p>

<ul>
<li><p>Overlapping:&quot;jaccard.actors&quot;, &quot;jaccard.edges&quot;, &quot;jaccard.triangles&quot;, &quot;coverage.actors&quot;, &quot;coverage.edges&quot;,  &quot;coverage.triangle&quot;,&quot;sm.actors&quot;, &quot;sm.edges&quot;, &quot;sm.triangles&quot;, &quot;rr.actors&quot;, &quot;rr.edges&quot;, &quot;rr.triangles&quot;, &quot;kulczynski2.actors&quot;, &quot;kulczynski2.edges&quot;, &quot;kulczynski2.triangles&quot;, &quot;hamann.actors&quot;, &quot;hamann.edges&quot;, &quot;hamann.triangles&quot;. The first part of the value indicates the type of comparison function (Jaccard, Coverage, Simple Matching, Russell Rao, Kulczynski, Hamann), the second part indicates the configurations to which the comparison function is applied.
</p>
</li>
<li><p>Distribution dissimilarity:&quot;dissimilarity.degree&quot;, &quot;KL.degree&quot;, &quot;jeffrey.degree&quot;. Notice that these are dissimilarity functions: 0 means highest similarity
</p>
</li>
<li><p>Correlation:&quot;pearson.degree&quot; and &quot;rho.degree&quot;
</p>
</li></ul>

</td></tr>
<tr><td><code id="multinet.layer_comparison_+3A_mode">mode</code></td>
<td>
<p>This argument is used for distribution dissimilarities and correlations (that is, those methods based on node degree) and can take values &quot;in&quot;, &quot;out&quot; or &quot;all&quot; to consider respectively incoming edges, outgoing edges or both.</p>
</td></tr>
<tr><td><code id="multinet.layer_comparison_+3A_k">K</code></td>
<td>
<p>This argument is used for distribution dissimilarity measures and indicates the number of histogram bars used to compute the divergence. If 0 is specified, then a &quot;typical&quot; value is used, close to the logarithm of the number of actors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with layer-by-layer comparisons. For each pair of layers, the data frame contains a value between 0 and 1 (for overlapping and distribution dissimilarity) or -1 and 1 (for correlation).
</p>


<h3>References</h3>

<p>Brodka, P., Chmiel, A., Magnani, M., and Ragozini, G. (2018). Quantifying layer similarity in multiplex networks: a systematic study. Royal Sociwty Open Science 5(8)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()

# computing similarity between layer summaries
s1 = layer_summary_ml(net,"facebook",method="entropy.degree")
s2 = layer_summary_ml(net,"lunch",method="entropy.degree")
relative.difference=abs(s1-s2)*2/(abs(s1)+abs(s2))
# other layer summaries
layer_summary_ml(net,"facebook",method="min.degree")
layer_summary_ml(net,"facebook",method="max.degree")
layer_summary_ml(net,"facebook",method="sum.degree")
layer_summary_ml(net,"facebook",method="mean.degree")
layer_summary_ml(net,"facebook",method="sd.degree")
layer_summary_ml(net,"facebook",method="skewness.degree")
layer_summary_ml(net,"facebook",method="kurtosis.degree")
layer_summary_ml(net,"facebook",method="entropy.degree")
layer_summary_ml(net,"facebook",method="CV.degree")
layer_summary_ml(net,"facebook",method="jarque.bera.degree")

# returning the number of common edges divided by the union of all
# edges for all pairs of layers (jaccard.edges)
layer_comparison_ml(net)
# returning the number of common edges divided by the union of all
# edges only for "lunch" and "facebook" (jaccard.edges)
layer_comparison_ml(net,layers=c("lunch","facebook"))
# returning the percentage of actors in the lunch layer that are
# also present in the facebook layer
layer_comparison_ml(net,method="coverage.actors")
# all overlapping-based measures:
layer_comparison_ml(net,method="jaccard.actors")
layer_comparison_ml(net,method="jaccard.edges")
layer_comparison_ml(net,method="jaccard.triangles")
layer_comparison_ml(net,method="coverage.actors")
layer_comparison_ml(net,method="coverage.edges")
layer_comparison_ml(net,method="coverage.triangles")
layer_comparison_ml(net,method="sm.actors")
layer_comparison_ml(net,method="sm.edges")
layer_comparison_ml(net,method="sm.triangles")
layer_comparison_ml(net,method="rr.actors")
layer_comparison_ml(net,method="rr.edges")
layer_comparison_ml(net,method="rr.triangles")
layer_comparison_ml(net,method="kulczynski2.actors")
layer_comparison_ml(net,method="kulczynski2.edges")
layer_comparison_ml(net,method="kulczynski2.triangles")
layer_comparison_ml(net,method="hamann.actors")
layer_comparison_ml(net,method="hamann.edges")
layer_comparison_ml(net,method="hamann.triangles")

# comparison of degree distributions (divergences)
layer_comparison_ml(net,method="dissimilarity.degree")
layer_comparison_ml(net,method="KL.degree")
layer_comparison_ml(net,method="jeffrey.degree")

# statistical degree correlation
layer_comparison_ml(net,method="pearson.degree")
layer_comparison_ml(net,method="rho.degree")
</code></pre>

<hr>
<h2 id='multinet.layout'>
Layouts
</h2><span id='topic+multinet.layout'></span><span id='topic+layout_multiforce_ml'></span><span id='topic+layout_circular_ml'></span>

<h3>Description</h3>

<p>These functions compute xyz coordinates for each node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_multiforce_ml(n, w_in = 1, w_inter = 1, gravity = 0, iterations = 100)
layout_circular_ml(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.layout_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.layout_+3A_w_in">w_in</code></td>
<td>
<p>An array with weights for intralayer forces, or a single number if weights are the same for all layers. When <code>w_in</code> is positive, vertices in the corresponding layer will be positioned as if a force was applied to them, repelling vertices that are close to each other and attracting adjacent vertices, all proportional to the specified weight.</p>
</td></tr>
<tr><td><code id="multinet.layout_+3A_w_inter">w_inter</code></td>
<td>
<p>An array with weights for interlayer forces, or a single number if weights are the same for all layers. When <code>w_inter</code> is positive, vertices in the corresponding layer will be positioned as if a force was applied to them, trying to keep them aligned with the vertices corresponding to the same actors on other layers, proportionally to the specified weight.</p>
</td></tr>
<tr><td><code id="multinet.layout_+3A_gravity">gravity</code></td>
<td>
<p>An array with weights for gravity forces, or a single number if weights are the same for all layers. This parameter results in the application of a force to the vertices, directed toward the center of the plot. It can be useful when there there are multiple components, so that they do not drift away from each other because of the repulsion force applied to their vertices.</p>
</td></tr>
<tr><td><code id="multinet.layout_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return a data frame with columns: actor, layer, x, y, z. Each value of z corresponds to one layer, and x and y are the coordinates of the actor inside that layer.</p>


<h3>References</h3>

<p>Fatemi, Zahra, Salehi, Mostafa, &amp; Magnani, Matteo (2018). A generalised force-based layout for multiplex sociograms. Social Informatics
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.plotting">multinet.plotting</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_florentine()
layout_multiforce_ml(net)
l &lt;- layout_circular_ml(net)
## Not run: 
plot(net,layout=l)
## End(Not run)
</code></pre>

<hr>
<h2 id='multinet.navigation'>
Functions to extract neighbors of vertices, to navigate the network
</h2><span id='topic+multinet.navigation'></span><span id='topic+neighbors_ml'></span><span id='topic+xneighbors_ml'></span>

<h3>Description</h3>

<p>These functions return actors who are connected to the input actor through an edge. They can be used to navigate the graph, following paths inside it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbors_ml(n, actor, layers = character(0), mode = "all")
xneighbors_ml(n, actor, layers = character(0), mode = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.navigation_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.navigation_+3A_actor">actor</code></td>
<td>
<p>An actor name present in the network, whose neighbors are extracted.</p>
</td></tr>
<tr><td><code id="multinet.navigation_+3A_layers">layers</code></td>
<td>
<p>An array of layers belonging to the network. Only the nodes in these layers are returned. If the array is empty, all the nodes in the network are returned.</p>
</td></tr>
<tr><td><code id="multinet.navigation_+3A_mode">mode</code></td>
<td>
<p>This argument can take values &quot;in&quot;, &quot;out&quot; or &quot;all&quot; to indicate respectively neighbors reachable via incoming edges, via outgoing edges or both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>neighbors_ml</code> returns the actors who are connected to the input actor on at least one of the specified layers. <code>xneighbors_ml</code> (eXclusive neighbors) returns the actors who are connected to the input actor on at least one of the specified layers, and on none of the other layers. Exclusive neighbors are those neighbors that would be lost by removing the input layers.
</p>


<h3>References</h3>

<p>Berlingerio, Michele, Michele Coscia, Fosca Giannotti, Anna Monreale, and Dino Pedreschi. 2011. &quot;Foundations of Multidimensional Network Analysis.&quot; In International Conference on Social Network Analysis and Mining (ASONAM), 485-89. IEEE Computer Society.
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.properties">multinet.properties</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
# out-neighbors of U54, that is, all A such that there is an edge ("U54",A)
neigh &lt;- neighbors_ml(net, "U54", mode="out")
# all in-neighbors of U54 on the "work" layer who are not in-neighbors
# in any other layer
xneigh &lt;- xneighbors_ml(net, "U54", "work", mode="in")
# all neighbors (in- and out-) of U54 on the "work" and "lunch" layers
# who are not neighbors in any other layer
xneigh &lt;- xneighbors_ml(net, "U54", c("work","lunch"))
</code></pre>

<hr>
<h2 id='multinet.plotting'>
Drawing a multilayer network
</h2><span id='topic+multinet.plotting'></span><span id='topic+plot.Rcpp_RMLNetwork'></span><span id='topic+plot.ml'></span><span id='topic+plot.multinet'></span><span id='topic+values2graphics'></span>

<h3>Description</h3>

<p>The plot function draws a multilayer network. values2graphics is a support function translating discrete attribute values to graphical parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_RMLNetwork'
plot(x,
layout = NULL, grid = NULL, mai = c(.1,.1,.1,.1),
layers = NULL,
vertex.shape = 21, vertex.cex = 1, vertex.size = vertex.cex, vertex.color = 1,
vertex.labels = NULL, vertex.labels.pos = 3,
vertex.labels.offset = .5, vertex.labels.cex = 1, vertex.labels.col=1,
edge.type = 1, edge.width = 1, edge.col = 1, edge.alpha=.5,
edge.arrow.length = 0.1, edge.arrow.angle = 20,
legend.x = NULL, legend.y = NULL,
legend.pch = 20, legend.cex = 0.5,
legend.inset = c(0, 0),
com = NULL, com.cex = 1,
show.layer.names=TRUE, layer.names.cex=1, ...)

values2graphics(values, output = "color")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.plotting_+3A_x">x</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_layout">layout</code></td>
<td>
<p>A data frame indicating the position of nodes. If NULL, the function layout.multiforce.ml is used to compute it.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_grid">grid</code></td>
<td>
<p>A vector of size 2 indicating the number of rows and columns where to draw the layers.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_mai">mai</code></td>
<td>
<p>Percentage of each frame reserved as internal margin (left, top, right, bottom). This only concerns vertices: text labels can be printed inside the margin or even outside the frame depending on their offset.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_layers">layers</code></td>
<td>
<p>A vector of layer names, that determine which layers and in which order are plotted.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.shape">vertex.shape</code></td>
<td>
<p>Symbol to use for nodes, corresponding to the parameter pch of the R <code>points</code> function.  This can either
be a single character or an integer code for one of a set of
graphics symbols.  See <code>?points</code> for more details.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.size">vertex.size</code></td>
<td>
<p>synonim of <code>vertex.cex</code>.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.cex">vertex.cex</code></td>
<td>
<p>Numeric *c*haracter *ex*pansion factor; multiplied by
<code>par("cex")</code> yields the final node size.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Color of the vertexes. If <code>NULL</code>, all vertexes in the same layer are plotted using the same color.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.labels">vertex.labels</code></td>
<td>
<p>A character vector or expression specifying the text to be
written besides each node. It corresponds to the parameter <code>labels</code> of the R <code>text</code> function.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.labels.pos">vertex.labels.pos</code></td>
<td>
<p>A position specifier for the text. Values of '1', '2', '3' and
'4', respectively indicate positions below, to the left of,
above and to the right of the specified coordinates. It corresponds to the parameter <code>pos</code> of the R <code>text</code> function.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.labels.offset">vertex.labels.offset</code></td>
<td>
<p>When <code>vertex.labels.pos</code> is specified, this value gives the offset of the label from the specified coordinate in fractions of a
character width. It corresponds to the parameter <code>offset</code> of the R <code>text</code> function.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.labels.cex">vertex.labels.cex</code></td>
<td>
<p>Numeric *c*haracter *ex*pansion factor; multiplied by
'par(&quot;cex&quot;)' yields the final character size.  'NULL' and
'NA' are equivalent to '1.0'. It corresponds to the parameter <code>cex</code> of the R <code>text</code> function.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_vertex.labels.col">vertex.labels.col</code></td>
<td>
<p>Color of the labels.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.type">edge.type</code></td>
<td>
<p>Edge line type, corresponding to the 'lty' parameter of the R par function.  Line types can either be specified as an
integer (0=blank, 1=solid (default), 2=dashed, 3=dotted,
4=dotdash, 5=longdash, 6=twodash) or as one of the character
strings '&quot;blank&quot;', '&quot;solid&quot;', '&quot;dashed&quot;', '&quot;dotted&quot;',
'&quot;dotdash&quot;', '&quot;longdash&quot;', or '&quot;twodash&quot;', where '&quot;blank&quot;'
uses 'invisible lines' (i.e., does not draw them). See <code>?par</code> for more details. It accepts a vector of values which are recycled.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.width">edge.width</code></td>
<td>
<p>Edge line width, corresponding to the 'lwd' parameter of the R 'par' function. See <code>?par</code> for more details. It accepts a vector of
values which are recycled.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.col">edge.col</code></td>
<td>
<p>Color of the edges.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.alpha">edge.alpha</code></td>
<td>
<p>Transparency of the edges.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.arrow.length">edge.arrow.length</code></td>
<td>
<p>Length of the edges of the arrow head (in inches) - corresponding to the parameter of the R <code>arrows</code> function with the same name.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_edge.arrow.angle">edge.arrow.angle</code></td>
<td>
<p>Angle from the shaft of the arrow to the edge of the arrow
head - corresponding to the parameter of the R <code>arrows</code> function with the same name.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_legend.x">legend.x</code>, <code id="multinet.plotting_+3A_legend.y">legend.y</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <a href="grDevices.html#topic+xy.coords">xy.coords</a>.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_legend.pch">legend.pch</code></td>
<td>
<p>the plotting symbols appearing in the legend, as numeric vector or a vector of 1-character strings</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_legend.cex">legend.cex</code></td>
<td>
<p>character expansion factor relative to current par(&quot;cex&quot;). Used for text.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_legend.inset">legend.inset</code></td>
<td>
<p>inset distance(s) from the margins as a fraction of the plot region when legend is placed by keyword.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_com">com</code></td>
<td>
<p>The result of a community detection algorithm. When this parameter is set, a colored area is added behind each community.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_com.cex">com.cex</code></td>
<td>
<p>Increases (&gt;1) or decreases (&lt;1) the margin around the nodes when the colored areas are drawn around the communities.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_show.layer.names">show.layer.names</code></td>
<td>
<p>if TRUE adds the name of each layer at the center bottom of it.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_layer.names.cex">layer.names.cex</code></td>
<td>
<p>Increases (&gt;1) or decreases (&lt;1) the size of the layer names.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_...">...</code></td>
<td>
<p>Other graphical parameters.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_values">values</code></td>
<td>
<p>A vector with values.</p>
</td></tr>
<tr><td><code id="multinet.plotting_+3A_output">output</code></td>
<td>
<p>The type of graphical objects the values should be translated to. It can currently take values &quot;color&quot; and &quot;shape&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot</code> returns no value. <code>values2graphics</code> returns an object with fields: legend.text, legend.pch, legend.col and color or shape, containing respectively the text entries for the legend, their characher shapes, their colours, and the color or shape of the entities in the <code>values</code> input parameter.</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.layout">multinet.layout</a>, <a href="#topic+multinet.communities">multinet.communities</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_florentine()
## Not run: 
plot(net)
c &lt;- clique_percolation_ml(net)
plot(net, vertex.labels.cex=.5, com=c)

## End(Not run)
net &lt;- ml_aucs()
## Not run: 
plot(net, vertex.labels=NA)
title("AUCS network")

## End(Not run)
values2graphics(c("a", "b", "b", "c"))
</code></pre>

<hr>
<h2 id='multinet.predefined'>
Loading predefined multilayer networks
</h2><span id='topic+multinet.predefined'></span><span id='topic+ml_empty'></span><span id='topic+ml_aucs'></span><span id='topic+ml_bankwiring'></span><span id='topic+ml_florentine'></span><span id='topic+ml_monastery'></span><span id='topic+ml_tailorshop'></span><span id='topic+ml_toy'></span>

<h3>Description</h3>

<p>Creates predefined multilayer networks from the literature.
</p>

<ul>
<li> <p><code>ml_empty</code> returns an empty multilayer network, not containing any actor, layer, node or edge.
</p>
</li>
<li> <p><code>ml_aucs</code> returns the AUCS multiplex network described in <cite>Rossi and Magnani, 2015. &quot;Towards effective visual analytics on multiplex networks&quot;. Chaos, Solitons and Fractals. Elsevier.</cite>
</p>
</li>
<li> <p><code>ml_bankwiring</code> returns Padgett's Florentine Families multiplex network.
</p>
</li>
<li> <p><code>ml_florentine</code> returns Padgett's Florentine Families multiplex network.
</p>
</li>
<li> <p><code>ml_monastery</code> returns Sampson's monastery multiplex network.
</p>
</li>
<li> <p><code>ml_tailorshop</code> returns Kapferer's' tailorshop multiplex network.
</p>
</li>
<li> <p><code>ml_toy</code> returns the toy network used as a running example in <cite>Dickison, Magnani and Rossi. &quot;Multilayer Social Networks&quot;. Cambridge University Press.</cite>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ml_empty(name="")
ml_aucs()
ml_bankwiring()
ml_florentine()
ml_monastery()
ml_tailorshop()
ml_toy()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.predefined_+3A_name">name</code></td>
<td>
<p>The name of the new multilayer network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All these functions return a multilayer network.
</p>


<h3>References</h3>


<ul>
<li><p> Rossi, Luca, and Magnani, Matteo (2015). Towards effective visual analytics on multiplex and multilayer networks. Chaos, Solitons and Fractals, 72, 68-76. (for ml_aucs()).
</p>
</li>
<li><p> Padgett, John F., and McLean, Paul D. (2006). Organizational Invention and Elite Transformation: The Birth of Partnership Systems in Renaissance Florence. American Journal of Sociology, 111(5), 1463-1568. (for ml_florentine()).
</p>
</li>
<li><p> Breiger, R. and Boorman, S. and Arabic, P. (1975). An algorithm for clustering relational data with applications to social network analysis and comparison with multidimensional scaling. Journal of Mathematical Psychology, 12 (for ml_monastery() and ml_bankwiring() - these authors prepared the datasets, see multilayer.it.uu.se/datasets.html for references to the data collectors).
</p>
</li>
<li><p> Kapferer, Bruce (1972). Strategy and Transaction in an African Factory: African Workers and Indian Management in a Zambian Town. Manchester University Press (for ml_tailorshop()).
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+multinet.IO">multinet.IO</a>, <a href="#topic+multinet.generation">multinet.generation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>empty &lt;- ml_empty("new network")
aucs &lt;- ml_aucs()
bankwiring &lt;- ml_bankwiring()
florentine &lt;- ml_florentine()
monastery &lt;- ml_monastery()
tailorshop &lt;- ml_tailorshop()
</code></pre>

<hr>
<h2 id='multinet.properties'>
Listing network properties
</h2><span id='topic+multinet.properties'></span><span id='topic+actors_ml'></span><span id='topic+layers_ml'></span><span id='topic+vertices_ml'></span><span id='topic+edges_ml'></span><span id='topic+edges_idx_ml'></span><span id='topic+num_actors_ml'></span><span id='topic+num_layers_ml'></span><span id='topic+num_vertices_ml'></span><span id='topic+num_edges_ml'></span><span id='topic+nodes_ml'></span><span id='topic+num_nodes_ml'></span>

<h3>Description</h3>

<p>These functions are used to list basic information about the components of a multilayer network (actors, layers, vertices and edges). 
</p>
<p>The functions <code>nodes_ml</code> and <code>num_nodes_ml</code> are deprecated in the current version of the library. The names vertex/vertices are now preferentially used over node/nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layers_ml(n)
actors_ml(n, layers = character(0), attributes = FALSE)
vertices_ml(n, layers = character(0), attributes = FALSE)
edges_ml(n, layers1 = character(0), layers2 = character(0), attributes = FALSE)
edges_idx_ml(n)

num_layers_ml(n)
num_actors_ml(n, layers = character(0))
num_vertices_ml(n, layers = character(0))
num_edges_ml(n, layers1 = character(0), layers2 = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.properties_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.properties_+3A_layers">layers</code></td>
<td>
<p>An array of names of layers belonging to the network. Only the actors/vertices in these layers are returned. If the array is empty, all the vertices in the network are returned. Notice that this may not correspond to the list of actors: there can be actors that are not present in any layer. These would be returned only using the <code>actors_ml</code> function.</p>
</td></tr>
<tr><td><code id="multinet.properties_+3A_layers1">layers1</code></td>
<td>
<p>The layer(s) from where the edges to be extracted start. If an empty list of layers is passed (default), all the layers are considered.</p>
</td></tr>
<tr><td><code id="multinet.properties_+3A_layers2">layers2</code></td>
<td>
<p>The layer(s) where the edges to be extracted end. If an empty list of layers is passed (default), the ending layers are set as equal to those in parameter layer1.</p>
</td></tr>
<tr><td><code id="multinet.properties_+3A_attributes">attributes</code></td>
<td>
<p>If set to TRUE, one column for each attribute is added to the data frame,
with the corresponding attribute value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>layers_ml</code> returns an array of layer names. <code>actors_ml</code> returns a data frame with one column, containing actors names. <code>vertices_ml</code> returns a data frame where each row contains the name of the actor corresponding to that vertex and the layer of the vertex. <code>edges_ml</code> returns a data frame where each row contains two actor names (i.e., an edge), the name of the two layers connected by the edge (which can be the same layer if it is an intra-layer edge) and the type of edge (directed/undirected).
</p>
<p><code>edges_idx_ml</code> returns the index of the vertex as returned by the <code>vertices_ml</code> function instead of its name - this is used internally by the plotting function.
</p>
<p>The functions num_* compute the number of objects of the requested type.</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.attributes">multinet.attributes</a>,
<a href="#topic+multinet.update">multinet.update</a>, <a href="#topic+multinet.edge_directionality">multinet.edge_directionality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
actors_ml(net, attributes = TRUE)
layers_ml(net)
vertices_ml(net, attributes = TRUE)
# only vertices in the "facebook" layer
vertices_ml(net,"facebook")
# all edges
edges_ml(net)
# Only edges inside the "lunch" layer
edges_ml(net,"lunch","lunch")
# Does the same as in the previous line
edges_ml(net,"lunch")
# Returns an empty  data frame, because there are no edges from the
# "lunch" layer to the "facebook" layer
edges_ml(net,"lunch","facebook")

num_actors_ml(net)
num_layers_ml(net)
num_vertices_ml(net)
# Only vertices in the "facebook" layer are counted
num_vertices_ml(net,"facebook")
num_edges_ml(net)
# Only edges inside the "lunch" layer are counted
num_edges_ml(net,"lunch","lunch")
# Does the same as in the previous line
num_edges_ml(net,"lunch")
# Returns 0, because there are no edges from the "lunch" layer to
# the "facebook" layer
num_edges_ml(net,"lunch","facebook")
</code></pre>

<hr>
<h2 id='multinet.transformation'>
Functions to transform existing layers into new ones.
</h2><span id='topic+multinet.transformation'></span><span id='topic+flatten_ml'></span><span id='topic+project_ml'></span>

<h3>Description</h3>

<p>These functions merge multiple layers into one. The new layer is added to the network. If the input layers are no longer necessary, they must be explicitely erased.
</p>
<p><code>flatten_ml</code> adds a new layer with the actors in the input layers and an edge between A and B if they are connected in any of the merged layers.
</p>
<p><code>project_ml</code> adds a new layer with the actors in the first input layer and an edge between A and B if they are connected to the same actor in the second layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_ml(n, new.layer = "flattening", layers = character(0),
  method = "weighted", force.directed = FALSE, all.actors = FALSE)
project_ml(n, new.layer = "projection", layer1, layer2,
method = "clique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.transformation_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_new.layer">new.layer</code></td>
<td>
<p>Name of the new layer.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_layers">layers</code></td>
<td>
<p>An array of layers belonging to the network.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_layer1">layer1</code></td>
<td>
<p>Name of a layer belonging to the network.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_layer2">layer2</code></td>
<td>
<p>Name of a layer belonging to the network.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_method">method</code></td>
<td>
<p>This argument can take values &quot;weighted&quot; or &quot;or&quot; for <code>flatten_ml</code> and &quot;clique&quot;
for <code>project_ml</code>. &quot;weighted&quot; adds an attribute to the new edges with the number of
layers where the two actors are connected.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_force.directed">force.directed</code></td>
<td>
<p>The new layer is set as directed. If this is false, the new layer is set as directed if at least one of the merged layers is directed.</p>
</td></tr>
<tr><td><code id="multinet.transformation_+3A_all.actors">all.actors</code></td>
<td>
<p>If TRUE, then all the actors are included in the new layer, even if they are not present in any of the merged layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return no value: they modify the input network.</p>


<h3>References</h3>

<p>Dickison, Magnani, and Rossi, 2016. Multilayer Social Networks. Cambridge University Press. ISBN: 978-1107438750
</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.conversion">multinet.conversion</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_aucs()
# A new layer is added to the network, with a flattening of all the other layers
flatten_ml(net, layers = layers_ml(net))
# Bipartite network
from_actor=c("A","B")
to_actor=c("1","1")
from_layer=c("l1","l1")
to_layer=c("l2","l2")
edges = data.frame(from_actor, from_layer, to_actor, to_layer)
n = ml_empty()
add_edges_ml(n, edges)
project_ml(n, layer1 = "l1", layer2="l2")
</code></pre>

<hr>
<h2 id='multinet.update'>
Manipulation of multilayer networks
</h2><span id='topic+multinet.update'></span><span id='topic+add_layers_ml'></span><span id='topic+add_vertices_ml'></span><span id='topic+add_edges_ml'></span><span id='topic+add_igraph_layer_ml'></span><span id='topic+delete_layers_ml'></span><span id='topic+delete_actors_ml'></span><span id='topic+delete_vertices_ml'></span><span id='topic+delete_edges_ml'></span><span id='topic+add_nodes_ml'></span><span id='topic+delete_nodes_ml'></span>

<h3>Description</h3>

<p>Functions to add or remove objects in a multilayer network.
</p>
<p>The functions <code>add_vertices_ml</code> and <code>delete_vertices_ml</code> add/remove the input actors to/from the input layers. Since version 3.1, the actors in the network correspond to the union of all the actors in the various layers (that is, the vertices).
</p>
<p>A layer can also be added from an igraph object, where the vertex attribute <code>name</code> represents the actor name, using the <code>add_igraph_layer_ml</code> function.
</p>
<p>The functions <code>add_nodes_ml</code> and <code>delete_nodes_ml</code> are deprecated in the current version of the library. The names vertex/vertices are now
preferentially used over node/nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_layers_ml(n, layers, directed=FALSE)
add_vertices_ml(n, vertices)
add_edges_ml(n, edges)

add_igraph_layer_ml(n, g, name)

delete_layers_ml(n, layers)
delete_actors_ml(n, actors)
delete_vertices_ml(n, vertices)
delete_edges_ml(n, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinet.update_+3A_n">n</code></td>
<td>
<p>A multilayer network.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_layers">layers</code></td>
<td>
<p>An array of names of layers.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_actors">actors</code></td>
<td>
<p>An array of names of actors.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_g">g</code></td>
<td>
<p>An igraph object with simple edges and a vertex attribute called name storing the actor name corresponding to the vertex.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_name">name</code></td>
<td>
<p>Name of the new layer.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_directed">directed</code></td>
<td>
<p>Determines if the layer(s) is (are) directed or undirected. If multiple layers are specified, directed should be either a single value or an array with as many values as the number of layers.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_vertices">vertices</code></td>
<td>
<p>A dataframe of vertices to be updated or deleted. The first column specifies actor names, the second layer names.</p>
</td></tr>
<tr><td><code id="multinet.update_+3A_edges">edges</code></td>
<td>
<p>A dataframe containing the edges to be connected or deleted. The four columns must contain, in this order: actor1 name, layer1 name, actor2 name, layer2 name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return no value: they modify the input network.</p>


<h3>See Also</h3>

<p><a href="#topic+multinet.properties">multinet.properties</a>, <a href="#topic+multinet.edge_directionality">multinet.edge_directionality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- ml_empty()
# Adding some layers
add_layers_ml(net,"l1")
add_layers_ml(net,c("l2","l3"),c(TRUE,FALSE))
layers_ml(net)
# Adding some vertices (actor A3 is not present in layer l3: no corresponding vertex there)
vertices &lt;- data.frame(
    c("A1","A2","A3","A1","A2","A3"),
    c("l1","l1","l1","l2","l2","l2"))
add_vertices_ml(net,vertices)
vertices &lt;- data.frame(
    c("A1","A2"),
    c("l3","l3"))
add_vertices_ml(net,vertices)
vertices_ml(net)
# Verifying that the actors have been added correctly
num_actors_ml(net)
actors_ml(net)
# We create a data frame specifying two edges:
# A2,l2 -- A3,l1
# A2,l2 -- A3,l2
edges &lt;- data.frame(
    c("A2","A2"),
    c("l2","l2"),
    c("A3","A3"),
    c("l1","l2"))
add_edges_ml(net,edges)
edges_ml(net)

# The following deletes layer 1, and also deletes
# all vertices from "l1" and the edge with an end-point in "l1"
delete_layers_ml(net,"l1")
# The following also deletes the vertices associated to
# "A1" in layers "l2" and "l3"
delete_actors_ml(net,"A1")
# deleting vertex A2,l3 and edge A2,l2 -- A3,l2
delete_vertices_ml(net,data.frame("A2","l3"))
edges &lt;- data.frame("A2","l2","A3","l2")
delete_edges_ml(net,edges)
net
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
