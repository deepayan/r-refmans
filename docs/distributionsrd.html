<!DOCTYPE html><html lang="en"><head><title>Help for package distributionsrd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distributionsrd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#burr'><p>The Burr distribution</p></a></li>
<li><a href='#burr_plt'><p>Burr coefficients after power-law transformation</p></a></li>
<li><a href='#clauset.xmax'><p>Pareto scale determination à la Clauset</p></a></li>
<li><a href='#clauset.xmin'><p>Pareto scale determination à la Clauset</p></a></li>
<li><a href='#coeffcomposite'><p>Parametrise two-/three- composite distribution</p></a></li>
<li><a href='#combdist'><p>Combined distributions</p></a></li>
<li><a href='#combdist_plt'><p>Combined coefficients of power-law transformed combined distribution</p></a></li>
<li><a href='#combdist.mle'><p>Combined distributions MLE</p></a></li>
<li><a href='#composite'><p>The two- or three-composite distribution</p></a></li>
<li><a href='#composite_plt'><p>Composite coefficients after power-law transformation</p></a></li>
<li><a href='#composite.mle'><p>Composite MLE</p></a></li>
<li><a href='#doubleparetolognormal'><p>The Double-Pareto Lognormal distribution</p></a></li>
<li><a href='#doubleparetolognormal_plt'><p>Double-Pareto Lognormal coefficients of power-law transformed Double-Pareto Lognormal</p></a></li>
<li><a href='#doubleparetolognormal.mle'><p>Double-Pareto Lognormal MLE</p></a></li>
<li><a href='#empirical'><p>The empirical distribution</p></a></li>
<li><a href='#exp'><p>The Exponential distribution</p></a></li>
<li><a href='#fit_US_cities'><p>Fitted distributions to the US Census 2000 city size distribution.</p></a></li>
<li><a href='#frechet'><p>The Fréchet distribution</p></a></li>
<li><a href='#frechet_plt'><p>Fréchet coefficients after power-law transformation</p></a></li>
<li><a href='#frechet.mle'><p>Fréchet MLE</p></a></li>
<li><a href='#gamma'><p>The Gamma distribution</p></a></li>
<li><a href='#invpareto'><p>The Inverse Pareto distribution</p></a></li>
<li><a href='#invpareto_plt'><p>Inverse Pareto coefficients after power-law transformation</p></a></li>
<li><a href='#invpareto.mle'><p>Inverse Pareto MLE</p></a></li>
<li><a href='#leftparetolognormal'><p>The Left-Pareto Lognormal distribution</p></a></li>
<li><a href='#leftparetolognormal_plt'><p>Left-Pareto Lognormal coefficients of power-law transformed Left-Pareto Lognormal</p></a></li>
<li><a href='#leftparetolognormal.mle'><p>Left-Pareto Lognormal MLE</p></a></li>
<li><a href='#llr_vuong'><p>Vuong's closeness test</p></a></li>
<li><a href='#lnorm'><p>The Lognormal distribution</p></a></li>
<li><a href='#lnorm_plt'><p>Log Normal coefficients of power-law transformed log normal</p></a></li>
<li><a href='#nmad_test'><p>Normalized Absolute Deviation</p></a></li>
<li><a href='#pareto'><p>The Pareto distribution</p></a></li>
<li><a href='#pareto_plt'><p>Pareto coefficients after power-law transformation</p></a></li>
<li><a href='#pareto.mle'><p>Pareto MLE</p></a></li>
<li><a href='#rightparetolognormal'><p>The Right-Pareto Lognormal distribution</p></a></li>
<li><a href='#rightparetolognormal_plt'><p>Right-Pareto Lognormal coefficients of power-law transformed Right-Pareto Lognormal</p></a></li>
<li><a href='#rightparetolognormal.mle'><p>Right-Pareto Lognormal MLE</p></a></li>
<li><a href='#truncdist'><p>Truncated distribution</p></a></li>
<li><a href='#weibull'><p>The Weibull distribution</p></a></li>
<li><a href='#weibull_plt'><p>Weibull coefficients of power-law transformed Weibull</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Distribution Fitting and Evaluation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A library of density, distribution function, quantile function, (bounded) raw moments and random generation for a collection of distributions relevant for the firm size literature. Additionally, the package contains tools to fit these distributions using maximum likelihood and evaluate these distributions based on (i) log-likelihood ratio and (ii) deviations between the empirical and parametrically implied moments of the distributions. We add flexibility by allowing the considered distributions to be combined into piecewise composite or finite mixture distributions, as well as to be used when truncated. See Dewitte (2020) <a href="https://hdl.handle.net/1854/LU-8644700">https://hdl.handle.net/1854/LU-8644700</a> for a description and application of methods available in this package. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, stats, flexmix, modeltools, methods</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tidyverse, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-15 16:43:21 UTC; ruben</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruben Dewitte [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruben Dewitte &lt;ruben0dewitte@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-25 18:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='burr'>The Burr distribution</h2><span id='topic+burr'></span><span id='topic+dburr'></span><span id='topic+pburr'></span><span id='topic+qburr'></span><span id='topic+mburr'></span><span id='topic+rburr'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for the Burr distribution, also known as the Burr Type XII distribution or the Singh-Maddala distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburr(x, shape1 = 2, shape2 = 1, scale = 0.5, log = FALSE)

pburr(q, shape1 = 2, shape2 = 1, scale = 0.5, log.p = FALSE, lower.tail = TRUE)

qburr(p, shape1 = 2, shape2 = 1, scale = 0.5, log.p = FALSE, lower.tail = TRUE)

mburr(
  r = 0,
  truncation = 0,
  shape1 = 2,
  shape2 = 1,
  scale = 0.5,
  lower.tail = TRUE
)

rburr(n, shape1 = 2, shape2 = 1, scale = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="burr_+3A_x">x</code>, <code id="burr_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="burr_+3A_shape1">shape1</code>, <code id="burr_+3A_shape2">shape2</code>, <code id="burr_+3A_scale">scale</code></td>
<td>
<p>Shape1, shape2 and scale of the Burr distribution, defaults to 2, 1 and 0.5.</p>
</td></tr>
<tr><td><code id="burr_+3A_log">log</code>, <code id="burr_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="burr_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="burr_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="burr_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution</p>
</td></tr>
<tr><td><code id="burr_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter</p>
</td></tr>
<tr><td><code id="burr_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) =\frac{\frac{kc}{scale}(\frac{\omega}{scale})^{shape2-1}}{(1+(\frac{\omega}{scale})^shape2)^{shape1+1}}, \qquad F_X(x) = 1-\frac{1}{(1+(\frac{\omega}{scale})^shape2)^shape1}</code>
</p>

<p>The y-bounded r-th raw moment of the Fréchet distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">scale^{r} shape1 [\boldsymbol{B}(\frac{r}{shape2} +1,shape1-\frac{r}{shape2}) - \boldsymbol{B}(\frac{(\frac{y}{scale})^{shape2}}{1+(\frac{y}{scale})^{shape2}};\frac{r}{shape2} +1,shape1-\frac{r}{shape2})],  \qquad shape2&gt;r, kc&gt;r</code>
</p>



<h3>Value</h3>

<p>dburr returns the density, pburr the distribution function, qburr the quantile function, mburr the rth moment of the distribution and rburr generates random deviates.
</p>
<p>The length of the result is determined by n for rburr, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Burr density
plot(x = seq(0, 5, length.out = 100), y = dburr(x = seq(0, 5, length.out = 100)))
plot(x = seq(0, 5, length.out = 100), y = dburr(x = seq(0, 5, length.out = 100), shape2 = 3))

## Demonstration of log functionality for probability and quantile function
qburr(pburr(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
pburr(2)
mburr(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a
#(truncated) random sample, for large enough samples.
x &lt;- rburr(1e5, shape2 = 3)

mean(x)
mburr(r = 1, shape2 = 3, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mburr(r = 1, shape2 = 3, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='burr_plt'>Burr coefficients after power-law transformation</h2><span id='topic+burr_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Burr distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>burr_plt(shape1 = 2, shape2 = 1, scale = 0.5, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="burr_plt_+3A_shape1">shape1</code>, <code id="burr_plt_+3A_shape2">shape2</code>, <code id="burr_plt_+3A_scale">scale</code></td>
<td>
<p>Shape1, shape2 and scale of the Burr distribution, defaults to 2, 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="burr_plt_+3A_a">a</code>, <code id="burr_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="burr_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable x is Burr distributed with scale shape and shape scale, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Burr distributed with shape1 <code class="reqn">shape1</code>, shape2 <code class="reqn">b*shape2</code> and scale <code class="reqn"> ( \frac{scale}{a})^{\frac{1}{b}} </code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
pburr(3,shape1=2,shape2=3,scale=1)
coeff = burr_plt(shape1=2,shape2=3,scale=1,a=5,b=7)$coefficients
pburr(5*3^7,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>
<p>pburr(5*0.9^7,shape1=2,shape2=3,scale=1)
coeff = burr_plt(shape1=2,shape2=3,scale=1,a=5,b=7, inv=TRUE)$coefficients
pburr(0.9,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>
<p>## Comparing the first moments and sample means of power-law transformed variables for large enough samples
x = rburr(1e5,shape1=2,shape2=3,scale=1)
coeff = burr_plt(shape1=2,shape2=3,scale=1,a=2,b=0.5)$coefficients
y = rburr(1e5,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],scale=coeff[[&quot;scale&quot;]])
mean(2*x^0.5)
mean(y)
mburr(r=1,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],scale=coeff[[&quot;scale&quot;]],lower.tail=FALSE)
</p>

<hr>
<h2 id='clauset.xmax'>Pareto scale determination à la Clauset</h2><span id='topic+clauset.xmax'></span>

<h3>Description</h3>

<p>This method determines the optimal scale parameter of the Inverse Pareto distribution using the iterative method (Clauset et al. 2009) that minimizes the Kolmogorov-Smirnov distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clauset.xmax(x, q = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clauset.xmax_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="clauset.xmax_+3A_q">q</code></td>
<td>
<p>Percentage of data to search over (starting from the smallest values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>KS</dt><dd><p>Minimum Kolmogorov-Smirnov distance</p>
</dd>
<dt>n</dt><dd><p>Number of observations in the Inverse Pareto tail</p>
</dd>
<dt>coeff.evo</dt><dd><p>Evolution of the Inverse Pareto shape parameter over the iterations</p>
</dd>
</dl>



<h3>References</h3>

<p>Clauset A, Shalizi CR, Newman ME (2009).
&ldquo;Power-law distributions in empirical data.&rdquo;
<em>SIAM review</em>, <b>51</b>(4), 661&ndash;703.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Determine cuttof from compostie InvPareto-Lognormal distribution using Clauset's method
dist &lt;- c("invpareto", "lnorm")
coeff &lt;- c(coeff1.k = 1.5, coeff2.meanlog = 1, coeff2.sdlog = 0.5)
x &lt;- rcomposite(1e3, dist = dist, coeff = coeff)
out &lt;- clauset.xmax(x = x)
out$coefficients
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))$coeff1

## Speed up method by considering values above certain quantile only
dist &lt;- c("invpareto", "lnorm")
coeff &lt;- c(coeff1.k = 1.5, coeff2.meanlog = 1, coeff2.sdlog = 0.5)
x &lt;- rcomposite(1e3, dist = dist, coeff = coeff)
out &lt;- clauset.xmax(x = x, q = 0.5)
out$coefficients
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))$coeff1
</code></pre>

<hr>
<h2 id='clauset.xmin'>Pareto scale determination à la Clauset</h2><span id='topic+clauset.xmin'></span>

<h3>Description</h3>

<p>This method determines the optimal scale parameter of the Pareto distribution using the iterative method (Clauset et al. 2009)that minimizes the Kolmogorov-Smirnov distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clauset.xmin(x, q = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clauset.xmin_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="clauset.xmin_+3A_q">q</code></td>
<td>
<p>Percentage of data to search over (starting from the largest values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>KS</dt><dd><p>Minimum Kolmogorov-Smirnov distance</p>
</dd>
<dt>n</dt><dd><p>Number of observations in the Pareto tail</p>
</dd>
<dt>coeff.evo</dt><dd><p>Evolution of the Pareto shape parameter over the iterations</p>
</dd>
</dl>



<h3>References</h3>

<p>Clauset A, Shalizi CR, Newman ME (2009).
&ldquo;Power-law distributions in empirical data.&rdquo;
<em>SIAM review</em>, <b>51</b>(4), 661&ndash;703.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Determine cuttof from compostie lognormal-Pareto distribution using Clauset's method
dist &lt;- c("lnorm", "pareto")
coeff &lt;- c(coeff1.meanlog = -0.5, coeff1.sdlog = 0.5, coeff2.k = 1.5)
x &lt;- rcomposite(1e3, dist = dist, coeff = coeff)
out &lt;- clauset.xmin(x = x)
out$coefficients
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))$coeff2

## Speed up method by considering values above certain quantile only
dist &lt;- c("lnorm", "pareto")
coeff &lt;- c(coeff1.meanlog = -0.5, coeff1.sdlog = 0.5, coeff2.k = 1.5)
x &lt;- rcomposite(1e3, dist = dist, coeff = coeff)
out &lt;- clauset.xmin(x = x, q = 0.5)
out$coefficients
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))$coeff2
</code></pre>

<hr>
<h2 id='coeffcomposite'>Parametrise two-/three- composite distribution</h2><span id='topic+coeffcomposite'></span>

<h3>Description</h3>

<p>Determines the weights and cutoffs of the three-composite distribution numerically applying te continuity- and differentiability condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffcomposite(dist, coeff, startc = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coeffcomposite_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution of the first-, second- (and third) component respectively. If only two components are provided, the distribution reduces to the two-component distribution.</p>
</td></tr>
<tr><td><code id="coeffcomposite_+3A_coeff">coeff</code></td>
<td>
<p>named numeric vector holding the coefficients of the first-, second- (and third) component, predeced by coeff1., coeff2. (and  coeff3.), respectively. Coefficients for the last component do not have to be provided for the two-component distribution and will be disregarded.</p>
</td></tr>
<tr><td><code id="coeffcomposite_+3A_startc">startc</code></td>
<td>
<p>starting values for the lower and upper cutoff, defaults to c(1,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The continuity condition implies
</p>
<p style="text-align: center;"><code class="reqn"> \alpha_1 = \frac{m_2(c_1) M_1(c_1)}{m_1(c_1)[M_2(c_2) - M_2(c_1)]}, \qquad \alpha_2 = \frac{m_2(c_2) [1 - M_3(c_2)]}{m_3(c_2) [M_2(c_2) - M_2(c_1)]} </code>
</p>

<p>The differentiability condition implies
</p>
<p style="text-align: center;"><code class="reqn"> \frac{d}{dc_1} ln[\frac{m_1(c_1)}{m_2(c_1)}] = 0, \qquad \frac{d}{dc_2} ln[\frac{m_2(c_2)}{m_3(c_2)}] = 0 </code>
</p>



<h3>Value</h3>

<p>Returns a named list containing a the separate distributions and their respective coefficients, as well as the cutoffs and weights of the composite distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Three-composite distribution
dist &lt;- c("invpareto", "lnorm", "pareto")
coeff &lt;- c(coeff1.k = 1, coeff2.meanlog = -0.5, coeff2.sdlog = 0.5, coeff3.k = 1)
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))

# Two-composite distribution
dist &lt;- c("lnorm", "pareto")
coeff &lt;- c(coeff1.meanlog = -0.5, coeff1.sdlog = 0.5, coeff2.k = 1.5)
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))

dist &lt;- c("invpareto", "lnorm")
coeff &lt;- c(coeff1.k = 1.5, coeff2.meanlog = 2, coeff2.sdlog = 0.5)
coeffcomposite(dist = dist, coeff = coeff, startc = c(1, 1))
#'
</code></pre>

<hr>
<h2 id='combdist'>Combined distributions</h2><span id='topic+combdist'></span><span id='topic+dcombdist'></span><span id='topic+pcombdist'></span><span id='topic+qcombdist'></span><span id='topic+mcombdist'></span><span id='topic+rcombdist'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for combined (empirical, single, composite and finite mixture) truncated or complete distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcombdist(
  x,
  dist,
  prior = c(1),
  coeff,
  log = FALSE,
  compress = TRUE,
  lowertrunc = 0,
  uppertrunc = Inf
)

pcombdist(
  q,
  dist,
  prior = 1,
  coeff,
  log.p = FALSE,
  lower.tail = TRUE,
  compress = TRUE,
  lowertrunc = NULL,
  uppertrunc = NULL
)

qcombdist(p, dist, prior, coeff, log.p = FALSE, lower.tail = TRUE)

mcombdist(
  r,
  truncation = NULL,
  dist,
  prior = 1,
  coeff,
  lower.tail = TRUE,
  compress = TRUE,
  uppertrunc = 0,
  lowertrunc = Inf
)

rcombdist(n, dist, prior, coeff, uppertrunc = NULL, lowertrunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combdist_+3A_x">x</code>, <code id="combdist_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="combdist_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution(s).</p>
</td></tr>
<tr><td><code id="combdist_+3A_prior">prior</code></td>
<td>
<p>Numeric vector of prior coefficients, defaults to single vector with value one.</p>
</td></tr>
<tr><td><code id="combdist_+3A_coeff">coeff</code></td>
<td>
<p>list of parameters for the distribution(s).</p>
</td></tr>
<tr><td><code id="combdist_+3A_log">log</code>, <code id="combdist_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="combdist_+3A_compress">compress</code></td>
<td>
<p>Logical indicating whether return values from individual densities of finite mixtures should be gathered or not, defaults to TRUE.</p>
</td></tr>
<tr><td><code id="combdist_+3A_lowertrunc">lowertrunc</code>, <code id="combdist_+3A_uppertrunc">uppertrunc</code></td>
<td>
<p>lowertrunc- and uppertrunc truncation points, defaults to 0 and Inf respectively</p>
</td></tr>
<tr><td><code id="combdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \leq x]</code> <code class="reqn">(E[x^r|X \leq y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="combdist_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="combdist_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="combdist_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter</p>
</td></tr>
<tr><td><code id="combdist_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dcombdist gives the density, pcombdist gives the distribution function, qcombdist gives the quantile function, mcombdist gives the rth moment of the distribution and rcombdist generates random deviates.
</p>
<p>The length of the result is determined by n for rcombdist, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load necessary tools
data("fit_US_cities")
library(tidyverse)
x &lt;- rcombdist(
  n = 25359, dist = "lnorm",
  prior = subset(fit_US_cities, (dist == "lnorm" &amp; components == 5))$prior[[1]],
  coeff = subset(fit_US_cities, (dist == "lnorm" &amp; components == 5))$coefficients[[1]]
) # Generate data from one of the fitted functions

# Evaluate functioning of dcomdist by calculating log likelihood for all distributions
loglike &lt;- fit_US_cities %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(loglike = sum(dcombdist(dist = .[["dist"]], x = sort(x), prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]], log = TRUE))) %&gt;%
  unnest(cols = loglike) %&gt;%
  mutate(NLL = -loglike, AIC = 2 * np - 2 * (loglike), BIC = log(n) * np - 2 * (loglike)) %&gt;%
  arrange(NLL)

# Evaluate functioning of mcombdist and pcombdist by calculating NMAD
#(equivalent to the Kolmogorov-Smirnov test statistic for the zeroth moment
#of the distribution) for all distributions
nmad &lt;- fit_US_cities %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(
    KS = max(abs(pempirical(q = sort(x), data = x) - pcombdist(dist = .[["dist"]],
    q = sort(x), prior = .[["prior"]][[1]], coeff = .[["coefficients"]][[1]]))),
    nmad_0 = nmad_test(r = 0, dist = .[["dist"]], x = sort(x), prior = .[["prior"]][[1]],
    coeff = .[["coefficients"]][[1]], stat = "max"),
    nmad_1 = nmad_test(r = 1, dist = .[["dist"]], x = sort(x), prior = .[["prior"]][[1]],
    coeff = .[["coefficients"]][[1]], stat = "max")
  ) %&gt;%
  unnest(cols = c(KS, nmad_0, nmad_1)) %&gt;%
  arrange(nmad_0)

# Evaluate functioning of qcombdist pcombdist by calculating NMAD (equivalent to the Kolmogorov-
#Smirnov test statistic for the zeroth moment of the distribution) for all distributions
test &lt;- fit_US_cities %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(out = qcombdist(pcombdist(2, dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]], log.p = TRUE),
    dist = .[["dist"]], prior = .[["prior"]][[1]], coeff = .[["coefficients"]][[1]],
    log.p = TRUE
  )) %&gt;%
  unnest(cols = c(out))


</code></pre>

<hr>
<h2 id='combdist_plt'>Combined coefficients of power-law transformed combined distribution</h2><span id='topic+combdist_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed combined distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combdist_plt(
  dist,
  prior = NULL,
  coeff,
  a = 1,
  b = 1,
  inv = FALSE,
  nested = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combdist_plt_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution(s).</p>
</td></tr>
<tr><td><code id="combdist_plt_+3A_prior">prior</code></td>
<td>
<p>Numeric vector of prior coefficients, defaults to single vector with value one.</p>
</td></tr>
<tr><td><code id="combdist_plt_+3A_coeff">coeff</code></td>
<td>
<p>list of parameters for the distribution(s).</p>
</td></tr>
<tr><td><code id="combdist_plt_+3A_a">a</code>, <code id="combdist_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="combdist_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="combdist_plt_+3A_nested">nested</code></td>
<td>
<p>logical indicating whether results should be returned in a nested list or flat list, defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested or flat list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>


# Load necessary tools
data("fit_US_cities")
library(tidyverse)


## Comparing probabilites of power-law transformed transformed variables
prob &lt;- fit_US_cities %&gt;%
  filter(!(dist %in% c(
    "exp", "invpareto_exp_pareto", "exp_pareto", "invpareto_exp",
    "gamma", "invpareto_gamma_pareto", "gamma_pareto", "invpareto_gamma"
  ))) %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(prob = pcombdist(q = 1.1, dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]])) %&gt;%
  unnest(cols = c(prob))
fit_US_cities_plt &lt;- fit_US_cities %&gt;%
  filter(!(dist %in% c(
    "exp", "invpareto_exp_pareto", "exp_pareto", "invpareto_exp",
    "gamma", "invpareto_gamma_pareto", "gamma_pareto", "invpareto_gamma"
  ))) %&gt;%
  group_by(dist, components, np, n, convergence) %&gt;%
  do(results = as_tibble(combdist_plt(dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]], a = 2, b = 0.5, nested = TRUE))) %&gt;%
  unnest(cols = c(results))
prob$prob_plt &lt;- fit_US_cities_plt %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(prob_plt = pcombdist(q = 2 * 1.1^0.5, dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]])) %&gt;%
  unnest(cols = c(prob_plt)) %&gt;%
  .$prob_plt
prob &lt;- prob %&gt;%
  mutate(check = abs(prob - prob_plt))

prob &lt;- fit_US_cities %&gt;%
  filter(!(dist %in% c(
    "exp", "invpareto_exp_pareto", "exp_pareto", "invpareto_exp",
    "gamma", "invpareto_gamma_pareto", "gamma_pareto", "invpareto_gamma"
  ))) %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(prob = pcombdist(q = 2 * 1.1^0.5, dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]])) %&gt;%
  unnest(cols = c(prob))
fit_US_cities_plt &lt;- fit_US_cities %&gt;%
  filter(!(dist %in% c(
    "exp", "invpareto_exp_pareto", "exp_pareto", "invpareto_exp",
    "gamma", "invpareto_gamma_pareto", "gamma_pareto", "invpareto_gamma"
  ))) %&gt;%
  group_by(dist, components, np, n, convergence) %&gt;%
  do(results = as_tibble(combdist_plt(dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]], a = 2, b = 0.5, nested = TRUE, inv = TRUE))) %&gt;%
  unnest(cols = c(results))
prob$prob_plt &lt;- fit_US_cities_plt %&gt;%
  group_by(dist, components, np, n) %&gt;%
  do(prob_plt = pcombdist(q = 1.1, dist = .[["dist"]], prior = .[["prior"]][[1]],
  coeff = .[["coefficients"]][[1]])) %&gt;%
  unnest(cols = c(prob_plt)) %&gt;%
  .$prob_plt
prob &lt;- prob %&gt;%
  mutate(check = abs(prob - prob_plt))


</code></pre>

<hr>
<h2 id='combdist.mle'>Combined distributions MLE</h2><span id='topic+combdist.mle'></span>

<h3>Description</h3>

<p>Maximum Likelihood estimation for combined ( single, composite and finite mixture) truncated or complete distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combdist.mle(
  x,
  dist,
  start = NULL,
  lower = NULL,
  upper = NULL,
  components = 1,
  nested = FALSE,
  steps = 1,
  lowertrunc = 0,
  uppertrunc = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combdist.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution(s).</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_start">start</code></td>
<td>
<p>named numeric vector holding the starting values for the coefficients.</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_lower">lower</code>, <code id="combdist.mle_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bounds to the estimated coefficients, defaults to -Inf and Inf respectively.</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_components">components</code></td>
<td>
<p>number of components for a mixture distribution.</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_nested">nested</code></td>
<td>
<p>logical indicating whether results should be returned in a nested list or a flat list  form, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_steps">steps</code></td>
<td>
<p>number of steps taken in stepflexmix, defaults to 1.</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_lowertrunc">lowertrunc</code>, <code id="combdist.mle_+3A_uppertrunc">uppertrunc</code></td>
<td>
<p>lowertrunc- and uppertrunc truncation points, defaults to 0 and Inf respectively</p>
</td></tr>
<tr><td><code id="combdist.mle_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>dist</dt><dd><p>Character vector denoting the distributions, separated by an underscore</p>
</dd>
<dt>components</dt><dd><p>Nr. of combined distributions</p>
</dd>
<dt>prior</dt><dd><p>Weights assigned to the respective component distributions</p>
</dd>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- rdoubleparetolognormal(1e3)
combdist.mle(x = x, dist = "doubleparetolognormal") # Double-Pareto Lognormal
combdist.mle(x = x, components = 2, dist = "lnorm", steps = 20) # FMM with 2 components
combdist.mle( x = x, dist = c("invpareto", "lnorm", "pareto"),
start = c(coeff1.k = 1, coeff2.meanlog = mean(log(x)), coeff2.sdlog = sd(log(x)), coeff3.k = 1),
lower = c(1e-10, -Inf, 1e-10, 1e-10), upper = c(Inf, Inf, Inf, Inf), nested = TRUE)
# composite distribution


</code></pre>

<hr>
<h2 id='composite'>The two- or three-composite distribution</h2><span id='topic+composite'></span><span id='topic+dcomposite'></span><span id='topic+pcomposite'></span><span id='topic+qcomposite'></span><span id='topic+mcomposite'></span><span id='topic+rcomposite'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for the two- or three-composite distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcomposite(x, dist, coeff, startc = c(1, 1), log = FALSE)

pcomposite(q, dist, coeff, startc = c(1, 1), log.p = FALSE, lower.tail = TRUE)

qcomposite(p, dist, coeff, startc = c(1, 1), log.p = FALSE, lower.tail = TRUE)

mcomposite(
  r = 0,
  truncation = 0,
  dist,
  coeff,
  startc = c(1, 1),
  lower.tail = TRUE
)

rcomposite(n, dist, coeff, startc = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composite_+3A_x">x</code>, <code id="composite_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="composite_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution of the first-, second- (and third) component respectively. If only two components are provided, the distribution reduces to the two-component distribution.</p>
</td></tr>
<tr><td><code id="composite_+3A_coeff">coeff</code></td>
<td>
<p>named numeric vector holding the coefficients of the first-, second- (and third) component, predeced by coeff1., coeff2. (and  coeff3.), respectively. Coefficients for the last component do not have to be provided for the two-component distribution and will be disregarded.</p>
</td></tr>
<tr><td><code id="composite_+3A_startc">startc</code></td>
<td>
<p>starting values for the lower and upper cutoff, defaults to c(1,1).</p>
</td></tr>
<tr><td><code id="composite_+3A_log">log</code>, <code id="composite_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="composite_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \leq x]</code> <code class="reqn">(E[x^r|X \leq y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="composite_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="composite_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="composite_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter</p>
</td></tr>
<tr><td><code id="composite_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These derivations are based on the two-composite distribution proposed by (Bakar et al. 2015). Probability Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) =  \{ \begin{array}{lrl}
 \frac{\alpha_1}{1 + \alpha_1 + \alpha_2} \frac{m_1(x)}{M_1(c_1)}  &amp; { if} &amp; 0&lt;x \leq c_1 \\
 \frac{1}{1 + \alpha_1 + \alpha_2} \frac{m_2(x)}{M_2(c_2) - M_2(c_1)} &amp; { if} &amp; c_1&lt;x \leq c_2 \\
 \frac{\alpha_2}{1 + \alpha_1 + \alpha_2} \frac{m_3(x)}{1-M_3(c_2)}  &amp; { if} &amp; c_{2}&lt;x &lt; \infty \\
 \end{array} .  </code>
</p>

<p>Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">  \{
 \begin{array}{lrl}
 \frac{\alpha_1}{1 + \alpha_1 + \alpha_2} \frac{M_1(x)}{M_1(c_1)} &amp; { if} &amp; 0&lt;x \leq c_1 \\
 \frac{\alpha_1}{1 + \alpha_1 + \alpha_2} + \frac{1}{1 + \alpha_1 + \alpha_2}\frac{M_2(x) - M_2(c_1)}{M_2(c_2) - M_2(c_1)} &amp; { if} &amp; c_1&lt;x \leq c_2 \\
 \frac{1+\alpha_1}{1 + \alpha_1 + \alpha_2} + \frac{\alpha_2}{1 + \alpha_1 + \alpha_2} \frac{M_3(x) - M_3(c_2)}{1-M_3(c_2)} &amp; { if} &amp; c_{2}&lt;x &lt; \infty \\
 \end{array}
 .
 </code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
 Q(p) =  \{
 \begin{array}{lrl}
 Q_1( \frac{1 + \alpha_1 + \alpha_2}{\alpha_1} p  M_1(c_1) )  &amp; { if} &amp; 0&lt;x \leq \frac{\alpha_1}{1 + \alpha_1 + \alpha_2} \\
 Q_2[((p - \frac{\alpha_1}{1 + \alpha_1 + \alpha_2})(1 + \alpha_1 + \alpha_2)(M_2(c_2) - M_2(c_1))) + M_2(c_1)] &amp; { if} &amp; \frac{\alpha_1}{1 + \alpha_1 + \alpha_2}&lt;x \leq \frac{1+\alpha_1}{1 + \alpha_1 + \alpha_2} \\
 Q_3[((p - \frac{1+\alpha_1}{1 + \alpha_1 + \alpha_2})(\frac{1 + \alpha_1 + \alpha_2}{\alpha_2})(1 - M_3(c_2))) + M_3(c_2)] &amp; { if} &amp; \frac{1+\alpha_1}{1 + \alpha_1 + \alpha_2}&lt;x &lt; \infty \\
 \end{array}
 .
 </code>
</p>

<p>The lower y-bounded r-th raw moment of the distribution equals
</p>
<p style="text-align: center;"><code class="reqn">
 \mu_y^r =
 \{
 \begin{array}{lrl}
 \frac{\alpha_1}{1 + \alpha_1 + \alpha_2}\frac{ (\mu_1)_y^r - (\mu_1)_{c_1}^r}{M_1(c_1)} +  \frac{1}{1 + \alpha_1 + \alpha_2}\frac{ (\mu_2)_{c_1}^r - (\mu_2)_{c_2}^r }{M_2(c_2) - M_2(c_1)} + \frac{\alpha_2}{1 + \alpha_1 + \alpha_2} \frac{(\mu_3)_y^r}{1-M_3(c_2)} &amp; { if} &amp; 0&lt; y \leq c_2 \\
 \frac{1}{1 + \alpha_1 + \alpha_2} \frac{(\mu_2)_y^r - (\mu_2)_{c_2}^r }{M_2(c_2) - M_2(c_1)} + \frac{\alpha_2}{1 + \alpha_1 + \alpha_2} \frac{(\mu_3)_{c_2}^r}{1-M_3(c_2)} &amp; { if} &amp; c_1&lt; y \leq c_2\\
 \frac{\alpha_2}{1 + \alpha_1 + \alpha_2} \frac{(\mu_3)_y^r}{1-M_3(c_2)}  &amp; { if} &amp; c_2&lt; y &lt; \infty \\
 \end{array}
 .
 </code>
</p>



<h3>Value</h3>

<p>dcomposite returns the density, pcomposite the distribution function, qcomposite the quantile function, mcomposite the rth moment of the distribution and rcomposite generates random deviates.
</p>
<p>The length of the result is determined by n for rcomposite, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>References</h3>

<p>Bakar SA, Hamzah N, Maghsoudi M, Nadarajah S (2015).
&ldquo;Modeling loss data using composite models.&rdquo;
<em>Insurance: Mathematics and Economics</em>, <b>61</b>, 146&ndash;154.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' ## Three-component distribution
dist &lt;- c("invpareto", "lnorm", "pareto")
coeff &lt;- c(coeff2.meanlog = -0.5, coeff2.sdlog = 0.5, coeff3.k = 1.5, coeff1.k = 1.5)

# Compare density with the Double-Pareto Lognormal distribution
plot(x = seq(0, 5, length.out = 1e3), y = dcomposite(x = seq(0, 5, length.out = 1e3),
dist = dist, coeff = coeff))
lines(x = seq(0, 5, length.out = 1e3), y = ddoubleparetolognormal(x = seq(0, 5, length.out = 1e3)))

# Demonstration of log functionality for probability and quantile function
qcomposite(pcomposite(2, dist = dist, coeff = coeff, log.p = TRUE), dist = dist,
coeff = coeff, log.p = TRUE)

# The zeroth truncated moment is equivalent to the probability function
pcomposite(2, dist = dist, coeff = coeff)
mcomposite(truncation = 2, dist = dist, coeff = coeff)

# The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
coeff &lt;- c(coeff2.meanlog = -0.5, coeff2.sdlog = 0.5, coeff3.k = 3, coeff1.k = 1.5)
x &lt;- rcomposite(1e5, dist = dist, coeff = coeff)

mean(x)
mcomposite(r = 1, lower.tail = FALSE, dist = dist, coeff = coeff)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mcomposite(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE, dist = dist, coeff = coeff)

## Two-component distribution
dist &lt;- c("lnorm", "pareto")
coeff &lt;- coeff &lt;- c(coeff2.k = 1.5, coeff1.meanlog = -0.5, coeff1.sdlog = 0.5)

# Compare density with the Right-Pareto Lognormal distribution
plot(x = seq(0, 5, length.out = 1e3), y = dcomposite(x = seq(0, 5, length.out = 1e3),
dist = dist, coeff = coeff))
lines(x = seq(0, 5, length.out = 1e3), y = drightparetolognormal(x = seq(0, 5, length.out = 1e3)))

# Demonstration of log functionality for probability and quantile function
qcomposite(pcomposite(2, dist = dist, coeff = coeff, log.p = TRUE), dist = dist,
coeff = coeff, log.p = TRUE)

# The zeroth truncated moment is equivalent to the probability function
pcomposite(2, dist = dist, coeff = coeff)
mcomposite(truncation = 2, dist = dist, coeff = coeff)

# The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
coeff &lt;- c(coeff1.meanlog = -0.5, coeff1.sdlog = 0.5, coeff2.k = 3)
x &lt;- rcomposite(1e5, dist = dist, coeff = coeff)

mean(x)
mcomposite(r = 1, lower.tail = FALSE, dist = dist, coeff = coeff)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mcomposite(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE, dist = dist, coeff = coeff)
</code></pre>

<hr>
<h2 id='composite_plt'>Composite coefficients after power-law transformation</h2><span id='topic+composite_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed composite distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite_plt(dist, coeff, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composite_plt_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution of the first-, second- (and third) component respectively. If only two components are provided, the distribution reduces to the two-component distribution.</p>
</td></tr>
<tr><td><code id="composite_plt_+3A_coeff">coeff</code></td>
<td>
<p>named numeric vector holding the coefficients of the first-, second- (and third) component, predeced by coeff1., coeff2. (and  coeff3.), respectively. Coefficients for the last component do not have to be provided for the two-component distribution and will be disregarded.</p>
</td></tr>
<tr><td><code id="composite_plt_+3A_a">a</code>, <code id="composite_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="composite_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
dist &lt;- c(&quot;invpareto&quot;, &quot;lnorm&quot;, &quot;pareto&quot;)
coeff &lt;- c(coeff2.meanlog = -0.5, coeff2.sdlog = 0.5, coeff3.k = 1.5, coeff1.k = 1.5)
</p>
<p>pcomposite(3,dist=dist,coeff=coeff)
newcoeff = composite_plt(dist=dist,coeff=coeff,a=5,b=7)$coefficients
pcomposite(5*3^7,dist=dist,coeff=newcoeff)
</p>
<p>pcomposite(5*0.9^3,dist=dist,coeff=coeff)
newcoeff = composite_plt(dist=dist,coeff=coeff,a=5,b=3,inv=TRUE)$coefficients
pcomposite(0.9,dist=dist,coeff=newcoeff)
</p>

<hr>
<h2 id='composite.mle'>Composite MLE</h2><span id='topic+composite.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the parameters of the two-/three- composite distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite.mle(x, dist, start, lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composite.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="composite.mle_+3A_dist">dist</code></td>
<td>
<p>character vector denoting the distribution of the first-, second- (and third) component respectively. If only two components are provided, the distribution reduces to the two-component distribution.</p>
</td></tr>
<tr><td><code id="composite.mle_+3A_start">start</code></td>
<td>
<p>named numeric vector holding the coefficients of the first-, second- (and third) component, predeced by coeff1., coeff2. (and  coeff3.), respectively. Coefficients for the last component do not have to be provided for the two-component distribution and will be disregarded.</p>
</td></tr>
<tr><td><code id="composite.mle_+3A_lower">lower</code>, <code id="composite.mle_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bounds to the estimated coefficients, defaults to -Inf and Inf respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>cutoffs</dt><dd><p>Cutoffs of the composite distribution</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
<dt>components</dt><dd><p>Nr. of components</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
dist &lt;- c("invpareto", "lnorm", "pareto")
coeff &lt;- c(
  coeff1.k = 1.5, coeff2.meanlog = -0.5,
  coeff2.sdlog = 0.5, coeff3.k = 1.5
)
lower &lt;- c(1e-10, -Inf, 1e-10, 1e-10)
upper &lt;- c(Inf, Inf, Inf, Inf)
x &lt;- rcomposite(1e3, dist = dist, coeff = coeff)

composite.mle(x = x, dist = dist, start = coeff + 0.2, lower = lower, upper = upper)

#'
</code></pre>

<hr>
<h2 id='doubleparetolognormal'>The Double-Pareto Lognormal distribution</h2><span id='topic+doubleparetolognormal'></span><span id='topic+ddoubleparetolognormal'></span><span id='topic+pdoubleparetolognormal'></span><span id='topic+qdoubleparetolognormal'></span><span id='topic+mdoubleparetolognormal'></span><span id='topic+rdoubleparetolognormal'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Double-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddoubleparetolognormal(
  x,
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  log = FALSE
)

pdoubleparetolognormal(
  q,
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

qdoubleparetolognormal(
  p,
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

mdoubleparetolognormal(
  r = 0,
  truncation = 0,
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE
)

rdoubleparetolognormal(
  n,
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleparetolognormal_+3A_x">x</code>, <code id="doubleparetolognormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_shape1">shape1</code>, <code id="doubleparetolognormal_+3A_shape2">shape2</code>, <code id="doubleparetolognormal_+3A_meanlog">meanlog</code>, <code id="doubleparetolognormal_+3A_sdlog">sdlog</code></td>
<td>
<p>Shapes, mean and variance of the Double-Pareto Lognormal distribution respectively, defaults to shape1=1.5, shape2=1.5, meanlog=-0.5, sdlog=0.5.</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_log">log</code>, <code id="doubleparetolognormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to xmin</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function as provided by (Reed and Jorgensen 2004):
</p>
<p><code class="reqn">f(x) = \frac{shape2shape1}{shape2 + shape1}[ x^{-shape2-1}e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\Phi(\frac{lnx - meanlog - shape2 sdlog^2}{sdlog}) +  x^{shape1-1}e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\Phi^c(\frac{lnx - meanlog +shape1 sdlog^2}{sdlog}) ], \newline F_X(x) = \Phi(\frac{lnx - meanlog }{sdlog}) - \frac{1}{shape2 + shape1}[  shape1 x^{-shape2}e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\Phi(\frac{lnx - meanlog - shape2 sdlog^2}{sdlog}) - shape2 x^{shape1}e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\Phi^c(\frac{lnx - meanlog +shape1 sdlog^2}{sdlog})  ]</code>
</p>
<p>The y-bounded r-th raw moment of the Double-Pareto Lognormal distribution equals:
</p>
<p><code class="reqn">meanlog^{r}_{y} = -\frac{shape2shape1}{shape2 + shape1}e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\frac{y^{r- shape2}}{r - shape2}\Phi(\frac{lny - meanlog - shape2 sdlog^2}{sdlog}) \newline \qquad- \frac{shape2shape1}{shape2 + shape1} \frac{1}{r-shape2} e^{\frac{ r^2sdlog^2 + 2meanlog r }{2}}\Phi^c(\frac{lny -  rsdlog^2 - meanlog}{sdlog}) \newline  \qquad -\frac{shape2shape1}{shape2 + shape1}e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\frac{y^{r + shape1}}{r + shape1}\Phi^c(\frac{lny - meanlog + shape1 sdlog^2}{sdlog}) \newline  \qquad + \frac{shape2shape1}{shape2 + shape1} \frac{1}{r+shape1} e^{\frac{ r^2sdlog^2 + 2meanlog r }{2}}\Phi^c(\frac{lny -  rsdlog^2 - meanlog}{sdlog}),  \qquad shape2&gt;r</code>
</p>


<h3>Value</h3>

<p>ddoubleparetolognormal returns the density, pdoubleparetolognormal the distribution function, qdoubleparetolognormal the quantile function, mdoubleparetolognormal the rth moment of the distribution and rdoubleparetolognormal generates random deviates.
</p>
<p>The length of the result is determined by n for rdoubleparetolognormal, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>References</h3>

<p>Reed WJ, Jorgensen M (2004).
&ldquo;The Double Pareto-Lognormal Distribution&ndash;A New Parametric Model for Size Distributions.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>33</b>(8), 1733&ndash;1753.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Double-Pareto Lognormal density
plot(x = seq(0, 5, length.out = 100), y = ddoubleparetolognormal(x = seq(0, 5, length.out = 100)))
plot(x = seq(0, 5, length.out = 100), y = ddoubleparetolognormal(x = seq(0, 5, length.out = 100),
 shape2 = 1))

## Double-Pareto Lognormal relates to the right-pareto Lognormal distribution if
#shape1 goes to infinity
pdoubleparetolognormal(q = 6, shape1 = 1e20, shape2 = 1.5, meanlog = -0.5, sdlog = 0.5)
prightparetolognormal(q = 6, shape2 = 1.5, meanlog = -0.5, sdlog = 0.5)

## Double-Pareto Lognormal relates to the left-pareto Lognormal distribution if
# shape2 goes to infinity
pdoubleparetolognormal(q = 6, shape1 = 1.5, shape2 = 1e20, meanlog = -0.5, sdlog = 0.5)
pleftparetolognormal(q = 6, shape1 = 1.5, meanlog = -0.5, sdlog = 0.5)

## Double-Pareto Lognormal relates to the Lognormal if both shape parameters go to infinity
pdoubleparetolognormal(q = 6, shape1 = 1e20, shape2 = 1e20, meanlog = -0.5, sdlog = 0.5)
plnorm(q = 6, meanlog = -0.5, sdlog = 0.5)

## Demonstration of log functionality for probability and quantile function
qdoubleparetolognormal(pdoubleparetolognormal(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
pdoubleparetolognormal(2)
mdoubleparetolognormal(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rdoubleparetolognormal(1e5, shape2 = 3)

mean(x)
mdoubleparetolognormal(r = 1, shape2 = 3, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mdoubleparetolognormal(r = 1, shape2 = 3, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='doubleparetolognormal_plt'>Double-Pareto Lognormal coefficients of power-law transformed Double-Pareto Lognormal</h2><span id='topic+doubleparetolognormal_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Double-Pareto Lognormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleparetolognormal_plt(
  shape1 = 1.5,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  a = 1,
  b = 1,
  inv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleparetolognormal_plt_+3A_shape1">shape1</code>, <code id="doubleparetolognormal_plt_+3A_shape2">shape2</code>, <code id="doubleparetolognormal_plt_+3A_meanlog">meanlog</code>, <code id="doubleparetolognormal_plt_+3A_sdlog">sdlog</code></td>
<td>
<p>Shapes, mean and variance of the Double-Pareto Lognormal distribution respectively.</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_plt_+3A_a">a</code>, <code id="doubleparetolognormal_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="doubleparetolognormal_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable y is Double-Pareto Lognormal distributed with mean meanlog and standard deviation sdlog, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Double-Pareto Lognormal distributed with <code class="reqn"> shape1*b, \frac{meanlog-log(a)}{b}, \frac{sdlog}{b}, shape2*b </code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
pdoubleparetolognormal(3,shape1 = 1.5, shape2 = 3, meanlog = -0.5, sdlog = 0.5)
coeff = doubleparetolognormal_plt(shape1 = 1.5, shape2 = 3, meanlog = -0.5, sdlog = 0.5,a=5,b=7)$coefficients
pdoubleparetolognormal(5*3^7,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>
<p>pdoubleparetolognormal(5*0.9^7,shape1 = 1.5, shape2 = 3, meanlog = -0.5, sdlog = 0.5)
coeff = doubleparetolognormal_plt(shape1 = 1.5, shape2 = 3, meanlog = -0.5, sdlog = 0.5,a=5,b=7, inv=TRUE)$coefficients
pdoubleparetolognormal(0.9,shape1=coeff[[&quot;shape1&quot;]],shape2=coeff[[&quot;shape2&quot;]],meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>

<hr>
<h2 id='doubleparetolognormal.mle'>Double-Pareto Lognormal MLE</h2><span id='topic+doubleparetolognormal.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the parameters of the Double-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleparetolognormal.mle(
  x,
  lower = c(1e-10, 1e-10, 1e-10),
  upper = c(Inf, Inf, Inf),
  start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleparetolognormal.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="doubleparetolognormal.mle_+3A_lower">lower</code>, <code id="doubleparetolognormal.mle_+3A_upper">upper</code></td>
<td>
<p>Upper and lower bounds for the estimation procedure on the parameters c(shape2,shape1,sdlog), defaults to c(1e-10,1e-10,1e-10) and c(Inf,Inf,Inf) respectively.</p>
</td></tr>
<tr><td><code id="doubleparetolognormal.mle_+3A_start">start</code></td>
<td>
<p>named vector with starting values, default to c(shape2=2,shape1=2,sdlog=sd(log(x)))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rdoubleparetolognormal(1e3)

## Pareto fit with xmin set to the minium of the sample
doubleparetolognormal.mle(x = x)
</code></pre>

<hr>
<h2 id='empirical'>The empirical distribution</h2><span id='topic+empirical'></span><span id='topic+dempirical'></span><span id='topic+pempirical'></span><span id='topic+qempirical'></span><span id='topic+mempirical'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and raw moments for the empirical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dempirical(x, data, log = FALSE)

pempirical(q, data, log.p = FALSE, lower.tail = TRUE)

qempirical(p, data, lower.tail = TRUE, log.p = FALSE)

mempirical(r = 0, data, truncation = NULL, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empirical_+3A_x">x</code>, <code id="empirical_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="empirical_+3A_data">data</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="empirical_+3A_log">log</code>, <code id="empirical_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="empirical_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), moments are <code class="reqn">E[x^r|X \le y]</code>, otherwise, <code class="reqn">E[x^r|X &gt; y]</code></p>
</td></tr>
<tr><td><code id="empirical_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="empirical_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="empirical_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function is a standard Kernel density estimation for 1e6 equally spaced points. The cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">F_n(x) = \frac{1}{n}\sum_{i=1}^{n}I_{x_i \leq x}</code>
</p>

<p>The y-bounded r-th raw moment of the empirical distribution equals:
</p>
<p style="text-align: center;"><code class="reqn"> \mu^{r}_{y} = \frac{1}{n}\sum_{i=1}^{n}I_{x_i \leq x}x^r</code>
</p>



<h3>Value</h3>

<p>dempirical returns the density, pempirical the distribution function, qempirical the quantile function, mempirical gives the rth moment of the distribution or a function that allows to evaluate the rth moment of the distribution if truncation is NULL..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'
## Generate random sample to work with
x &lt;- rlnorm(1e5, meanlog = -0.5, sdlog = 0.5)

## Empirical density
plot(x = seq(0, 5, length.out = 100), y = dempirical(x = seq(0, 5, length.out = 100), data = x))

# Compare empirical and parametric quantities
dlnorm(0.5, meanlog = -0.5, sdlog = 0.5)
dempirical(0.5, data = x)

plnorm(0.5, meanlog = -0.5, sdlog = 0.5)
pempirical(0.5, data = x)

qlnorm(0.5, meanlog = -0.5, sdlog = 0.5)
qempirical(0.5, data = x)

mlnorm(r = 0, truncation = 0.5, meanlog = -0.5, sdlog = 0.5)
mempirical(r = 0, truncation = 0.5, data = x)

mlnorm(r = 1, truncation = 0.5, meanlog = -0.5, sdlog = 0.5)
mempirical(r = 1, truncation = 0.5, data = x)

## Demonstration of log functionailty for probability and quantile function
quantile(x, 0.5, type = 1)
qempirical(p = pempirical(q = quantile(x, 0.5, type = 1), data = x, log.p = TRUE),
data = x, log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
pempirical(q = quantile(x, 0.5, type = 1), data = x)
mempirical(truncation = quantile(x, 0.5, type = 1), data = x)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
mean(x)
mempirical(r = 1, data = x, truncation = 0, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mempirical(r = 1, data = x, truncation = quantile(x, 0.1), lower.tail = FALSE)
#'
</code></pre>

<hr>
<h2 id='exp'>The Exponential distribution</h2><span id='topic+exp'></span><span id='topic+mexp'></span>

<h3>Description</h3>

<p>Raw moments for the exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexp(r = 0, truncation = 0, rate = 1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution, defaults to 1.</p>
</td></tr>
<tr><td><code id="exp_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to 0.</p>
</td></tr>
<tr><td><code id="exp_+3A_rate">rate</code></td>
<td>
<p>rate of the distribution with default values of 1.</p>
</td></tr>
<tr><td><code id="exp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), moments are <code class="reqn">E[x^r|X \le y]</code>, otherwise, <code class="reqn">E[x^r|X &gt; y]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{s}e^{-\frac{\omega}{s}} , \qquad F_X(x) = 1-e^{-\frac{\omega}{s}}</code>
</p>

<p>The y-bounded r-th raw moment of the distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">s^{\sigma_s - 1} \Gamma\left(\sigma_s +1, \frac{y}{s} \right)</code>
</p>

<p>where <code class="reqn">\Gamma(,)</code> denotes the upper incomplete gamma function.
</p>


<h3>Value</h3>

<p>Returns the truncated rth raw moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The zeroth truncated moment is equivalent to the probability function
pexp(2, rate = 1)
mexp(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rexp(1e5, rate = 1)
mean(x)
mexp(r = 1, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mexp(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='fit_US_cities'>Fitted distributions to the US Census 2000 city size distribution.</h2><span id='topic+fit_US_cities'></span>

<h3>Description</h3>

<p>A dataset containing 52 distribution fits to the US Census 2000 city size distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_US_cities
</code></pre>


<h3>Format</h3>

<p>A data frame with 52 rows and 7 variables:
</p>

<dl>
<dt>dist</dt><dd><p>distribution</p>
</dd>
<dt>components</dt><dd><p>number of components</p>
</dd>
<dt>prior</dt><dd><p>list of prior weights for the individual distribution components of FMM</p>
</dd>
<dt>coefficients</dt><dd><p>list of coefficients for the distributions</p>
</dd>
<dt>np</dt><dd><p>Number of paramters</p>
</dd>
<dt>n</dt><dd><p>Number of observations</p>
</dd>
<dt>convergence</dt><dd><p>Logical indicating whether the fitting procedure converged</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://doi.org/10.3886/E113328V1">http://doi.org/10.3886/E113328V1</a>
</p>

<hr>
<h2 id='frechet'>The Fréchet distribution</h2><span id='topic+frechet'></span><span id='topic+dfrechet'></span><span id='topic+pfrechet'></span><span id='topic+qfrechet'></span><span id='topic+mfrechet'></span><span id='topic+rfrechet'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for the Fréchet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrechet(x, shape = 1.5, scale = 0.5, log = FALSE)

pfrechet(q, shape = 1.5, scale = 0.5, log.p = FALSE, lower.tail = TRUE)

qfrechet(p, shape = 1.5, scale = 0.5, log.p = FALSE, lower.tail = TRUE)

mfrechet(r = 0, truncation = 0, shape = 1.5, scale = 0.5, lower.tail = TRUE)

rfrechet(n, shape = 1.5, scale = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frechet_+3A_x">x</code>, <code id="frechet_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="frechet_+3A_shape">shape</code>, <code id="frechet_+3A_scale">scale</code></td>
<td>
<p>Shape and scale of the Fréchet distribution, defaults to 1.5 and 0.5 respectively.</p>
</td></tr>
<tr><td><code id="frechet_+3A_log">log</code>, <code id="frechet_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="frechet_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">\left(E[x^r|X \le y]\right)</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">\left(E[x^r|X &gt; y]\right)</code></p>
</td></tr>
<tr><td><code id="frechet_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="frechet_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution</p>
</td></tr>
<tr><td><code id="frechet_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter</p>
</td></tr>
<tr><td><code id="frechet_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) =\frac{shape}{scale}\left(\frac{\omega}{scale}\right)^{-1-shape} e^{-\left(\frac{\omega}{scale}\right)^{-shape}}, \qquad F_X(x) = e^{-\left(\frac{\omega}{scale}\right)^{-shape}}</code>
</p>

<p>The y-bounded r-th raw moment of the Fréchet distribution equals:
</p>
<p style="text-align: center;"><code class="reqn"> \mu^{r}_{y} = scale^{\sigma_s - 1} \left[1-\Gamma\left(1-\frac{\sigma_s - 1}{shape}, \left(\frac{y}{scale}\right)^{-shape} \right)\right],  \qquad shape&gt;r</code>
</p>



<h3>Value</h3>

<p>dfrechet returns the density, pfrechet the distribution function, qfrechet the quantile function, mfrechet the rth moment of the distribution and rfrechet generates random deviates.
</p>
<p>The length of the result is determined by n for rfrechet, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Frechet density
plot(x = seq(0, 5, length.out = 100), y = dfrechet(x = seq(0, 5, length.out = 100),
shape = 1, scale = 1))
plot(x = seq(0, 5, length.out = 100), y = dfrechet(x = seq(0, 5, length.out = 100),
shape = 2, scale = 1))
plot(x = seq(0, 5, length.out = 100), y = dfrechet(x = seq(0, 5, length.out = 100),
shape = 3, scale = 1))
plot(x = seq(0, 5, length.out = 100), y = dfrechet(x = seq(0, 5, length.out = 100),
shape = 3, scale = 2))

## frechet is also called the inverse weibull distribution, which is available in the stats package
pfrechet(q = 5, shape = 2, scale = 1.5)
1 - pweibull(q = 1 / 5, shape = 2, scale = 1 / 1.5)

## Demonstration of log functionality for probability and quantile function
qfrechet(pfrechet(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
pfrechet(2)
mfrechet(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rfrechet(1e5, scale = 1)

mean(x)
mfrechet(r = 1, lower.tail = FALSE, scale = 1)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mfrechet(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE, scale = 1)
</code></pre>

<hr>
<h2 id='frechet_plt'>Fréchet coefficients after power-law transformation</h2><span id='topic+frechet_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Fréchet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechet_plt(shape = 1.5, scale = 0.5, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frechet_plt_+3A_shape">shape</code>, <code id="frechet_plt_+3A_scale">scale</code></td>
<td>
<p>Scale and shape of the Fréchet distribution, defaults to 1.5 and 0.5 respectively.</p>
</td></tr>
<tr><td><code id="frechet_plt_+3A_a">a</code>, <code id="frechet_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="frechet_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable x is Fréchet distributed with scale shape and shape scale, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Fréchet distributed with scale <code class="reqn"> \left( \frac{scale}{a}\right)^{\frac{1}{b}} </code> and shape <code class="reqn">b*k</code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
pfrechet(3,shape=2,scale=1)
coeff = frechet_plt(shape=2,scale=1,a=5,b=7)$coefficients
pfrechet(5*3^7,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>
<p>pfrechet(5*0.8^7,shape=2,scale=1)
coeff = frechet_plt(shape=2,scale=1,a=5,b=7,inv=TRUE)$coefficients
pfrechet(0.8,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>

<hr>
<h2 id='frechet.mle'>Fréchet MLE</h2><span id='topic+frechet.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the coefficients of the Fréchet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechet.mle(
  x,
  weights = NULL,
  start = c(shape = 1.5, scale = 0.5),
  lower = c(1e-10, 1e-10),
  upper = c(Inf, Inf)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frechet.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="frechet.mle_+3A_weights">weights</code></td>
<td>
<p>numeric vector for weighted MLE, should have the same length as data vector x</p>
</td></tr>
<tr><td><code id="frechet.mle_+3A_start">start</code></td>
<td>
<p>named vector with starting values, default to c(shape=1.5,scale=0.5)</p>
</td></tr>
<tr><td><code id="frechet.mle_+3A_lower">lower</code>, <code id="frechet.mle_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bounds to the estimated shape parameter, defaults to 1e-10 and Inf respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>

<p>x = rfrechet(1e3)
</p>
<p>## Pareto fit with xmin set to the minium of the sample
frechet.mle(x=x)
</p>

<hr>
<h2 id='gamma'>The Gamma distribution</h2><span id='topic+gamma'></span><span id='topic+mgamma'></span>

<h3>Description</h3>

<p>Raw moments for the Gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgamma(
  r = 0,
  truncation = 0,
  shape = 2,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution, defaults to 1.</p>
</td></tr>
<tr><td><code id="gamma_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to 0.</p>
</td></tr>
<tr><td><code id="gamma_+3A_shape">shape</code>, <code id="gamma_+3A_rate">rate</code>, <code id="gamma_+3A_scale">scale</code></td>
<td>
<p>shape, rate and scale of the distribution with default values of 2 and 1 respectively.</p>
</td></tr>
<tr><td><code id="gamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), moments are <code class="reqn">E[x^r|X \le y]</code>, otherwise, <code class="reqn">E[x^r|X &gt; y]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{s^k\Gamma(k)}\omega^{k-1}e^{-\frac{\omega}{s}},\qquad F_X(x) = \frac{1}{\Gamma(k)}\gamma(k,\frac{\omega}{s})</code>
</p>
<p>,
</p>
<p>where <code class="reqn">\Gamma(x)</code> stands for the upper incomplete gamma function function, while <code class="reqn">\gamma(s,x)</code> stands for the lower incomplete Gamma function with upper bound <code class="reqn">x</code>.
</p>
<p>The y-bounded r-th raw moment of the distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">\mu^r_y =   \frac{s^{r}}{\Gamma(k)} \Gamma\left(r + k , \frac{y}{s} \right)  </code>
</p>



<h3>Value</h3>

<p>Provides the truncated rth raw moment of the distribution.
</p>
<p>## The zeroth truncated moment is equivalent to the probability function
pgamma(2,shape=2,rate=1)
mgamma(truncation=2)
</p>
<p>## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x = rgamma(1e5,shape=2,rate=1)
mean(x)
mgamma(r=1,lower.tail=FALSE)
</p>
<p>sum(x[x&gt;quantile(x,0.1)])/length(x)
mgamma(r=1,truncation=quantile(x,0.1),lower.tail=FALSE)
</p>

<hr>
<h2 id='invpareto'>The Inverse Pareto distribution</h2><span id='topic+invpareto'></span><span id='topic+dinvpareto'></span><span id='topic+pinvpareto'></span><span id='topic+qinvpareto'></span><span id='topic+minvpareto'></span><span id='topic+rinvpareto'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for the Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvpareto(x, k = 1.5, xmax = 5, log = FALSE, na.rm = FALSE)

pinvpareto(
  q,
  k = 1.5,
  xmax = 5,
  lower.tail = TRUE,
  log.p = FALSE,
  log = FALSE,
  na.rm = FALSE
)

qinvpareto(p, k = 1.5, xmax = 5, lower.tail = TRUE, log.p = FALSE)

minvpareto(r = 0, truncation = 0, k = 1.5, xmax = 5, lower.tail = TRUE)

rinvpareto(n, k = 1.5, xmax = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invpareto_+3A_x">x</code>, <code id="invpareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="invpareto_+3A_xmax">xmax</code>, <code id="invpareto_+3A_k">k</code></td>
<td>
<p>Scale and shape of the Inverse Pareto distribution, defaults to 5 and 1.5 respectively.</p>
</td></tr>
<tr><td><code id="invpareto_+3A_log">log</code>, <code id="invpareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="invpareto_+3A_na.rm">na.rm</code></td>
<td>
<p>Removes values that fall outside the support of the distribution</p>
</td></tr>
<tr><td><code id="invpareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="invpareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="invpareto_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Inverse Pareto distribution</p>
</td></tr>
<tr><td><code id="invpareto_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to xmin</p>
</td></tr>
<tr><td><code id="invpareto_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) =\frac{k x_{max}^{-k}}{x^{-k+1}}, \qquad F_X(x) = (\frac{x_{max} }{x})^{-k}</code>
</p>

<p>The y-bounded r-th raw moment of the Inverse Pareto distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">\mu^r_y =k\omega_{max}^{-k}\frac{\omega_{max}^{r+k}- y^{r+k}}{r+k}  </code>
</p>



<h3>Value</h3>

<p>dinvpareto returns the density, pinvpareto the distribution function, qinvpareto the quantile function, minvpareto the rth moment of the distribution and rinvpareto generates random deviates.
</p>
<p>The length of the result is determined by n for rinvpareto, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Inverse invpareto density
plot(x = seq(0, 5, length.out = 100), y = dinvpareto(x = seq(0, 5, length.out = 100)))

## Demonstration of log functionality for probability and quantile function
qinvpareto(pinvpareto(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
pinvpareto(2)
minvpareto(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rinvpareto(1e5)

mean(x)
minvpareto(r = 1, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
minvpareto(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='invpareto_plt'>Inverse Pareto coefficients after power-law transformation</h2><span id='topic+invpareto_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Inverse Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invpareto_plt(xmax = 5, k = 1.5, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invpareto_plt_+3A_xmax">xmax</code>, <code id="invpareto_plt_+3A_k">k</code></td>
<td>
<p>Scale and shape of the Inverse Pareto distribution, defaults to 5 and 1.5 respectively.</p>
</td></tr>
<tr><td><code id="invpareto_plt_+3A_a">a</code>, <code id="invpareto_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="invpareto_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable x is Inverse Pareto-distributed with scale xmin and shape k, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Inverse Pareto distributed with scale <code class="reqn"> ( \frac{xmin}{a})^{\frac{1}{b}} </code> and shape <code class="reqn">b*k</code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
pinvpareto(3,k=2,xmax=5)
coeff = invpareto_plt(xmax=5,k=2,a=5,b=7)$coefficients
pinvpareto(5*3^7,k=coeff[[&quot;k&quot;]],xmax=coeff[[&quot;xmax&quot;]])
</p>
<p>pinvpareto(5*0.9^7,k=2,xmax=5)
coeff = invpareto_plt(xmax=5,k=2,a=5,b=7, inv=TRUE)$coefficients
pinvpareto(0.9,k=coeff[[&quot;k&quot;]],xmax=coeff[[&quot;xmax&quot;]])
</p>

<hr>
<h2 id='invpareto.mle'>Inverse Pareto MLE</h2><span id='topic+invpareto.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the Inverse Pareto shape parameter using the Hill estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invpareto.mle(x, xmax = NULL, clauset = FALSE, q = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invpareto.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="invpareto.mle_+3A_xmax">xmax</code></td>
<td>
<p>scale parameter of the Inverse Pareto distribution, set to max(x) if not provided</p>
</td></tr>
<tr><td><code id="invpareto.mle_+3A_clauset">clauset</code></td>
<td>
<p>Indicator variable for calculating the scale parameter using the clauset method, overrides provided xmax</p>
</td></tr>
<tr><td><code id="invpareto.mle_+3A_q">q</code></td>
<td>
<p>Percentage of data to search over (starting from the smallest values), dafults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hill estimator equals
</p>
<p style="text-align: center;"><code class="reqn">\hat{k} =- \frac{1}{\frac{1}{n}\sum_{i=1}^{n}log\frac{x_{max}}{x_i}}</code>
</p>



<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rinvpareto(1e3, k = 1.5, xmax = 5)

## Pareto fit with xmin set to the minium of the sample
invpareto.mle(x = x)

## Pareto fit with xmin set to its real value
invpareto.mle(x = x, xmax = 5)

## Pareto fit with xmin determined by the Clauset method
invpareto.mle(x = x, clauset = TRUE)
</code></pre>

<hr>
<h2 id='leftparetolognormal'>The Left-Pareto Lognormal distribution</h2><span id='topic+leftparetolognormal'></span><span id='topic+dleftparetolognormal'></span><span id='topic+pleftparetolognormal'></span><span id='topic+qleftparetolognormal'></span><span id='topic+mleftparetolognormal'></span><span id='topic+rleftparetolognormal'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Left-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dleftparetolognormal(x, shape1 = 1.5, meanlog = -0.5, sdlog = 0.5, log = FALSE)

pleftparetolognormal(
  q,
  shape1 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

qleftparetolognormal(
  p,
  shape1 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

mleftparetolognormal(
  r = 0,
  truncation = 0,
  shape1 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE
)

rleftparetolognormal(n, shape1 = 1.5, meanlog = -0.5, sdlog = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leftparetolognormal_+3A_x">x</code>, <code id="leftparetolognormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_shape1">shape1</code>, <code id="leftparetolognormal_+3A_meanlog">meanlog</code>, <code id="leftparetolognormal_+3A_sdlog">sdlog</code></td>
<td>
<p>Shape, mean and variance of the Left-Pareto Lognormal distribution respectively.</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_log">log</code>, <code id="leftparetolognormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to xmin</p>
</td></tr>
<tr><td><code id="leftparetolognormal_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function as provided by (Reed and Jorgensen 2004):
</p>
<p><code class="reqn">f(x) = shape1\omega^{shape1-1}e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\Phi^c(\frac{ln\omega - meanlog +shape1 sdlog^2}{sdlog}), \newline F_X(x) = \Phi(\frac{ln\omega - meanlog }{sdlog}) -  		\omega^{shape1}e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\Phi^c(\frac{ln\omega - meanlog +shape1 sdlog^2}{sdlog})</code>
</p>
<p>The y-bounded r-th raw moment of the Let-Pareto Lognormal distribution equals:
</p>
<p><code class="reqn">meanlog^{r}_{y} = -shape1e^{-shape1 meanlog + \frac{shape1^2sdlog^2}{2}}\frac{y^{\sigma_s + shape1-1}}{\sigma_s + shape1 - 1}\Phi^c(\frac{lny - meanlog + shape1 sdlog^2}{sdlog}) \newline \qquad + \frac{shape1}{r+shape1} e^{\frac{ r^2sdlog^2 + 2meanlog r }{2}}\Phi^c(\frac{lny -  rsdlog^2 + meanlog}{sdlog})</code>
</p>


<h3>Value</h3>

<p>dleftparetolognormal gives the density, pleftparetolognormal gives the distribution function, qleftparetolognormal gives the quantile function, mleftparetolognormal gives the rth moment of the distribution and rleftparetolognormal generates random deviates.
</p>
<p>The length of the result is determined by n for rleftparetolognormal, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>References</h3>

<p>Reed WJ, Jorgensen M (2004).
&ldquo;The Double Pareto-Lognormal Distribution&ndash;A New Parametric Model for Size Distributions.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>33</b>(8), 1733&ndash;1753.
</p>
<p>## Left-Pareto Lognormal density
plot(x=seq(0,5,length.out=100),y=dleftparetolognormal(x=seq(0,5,length.out=100)))
plot(x=seq(0,5,length.out=100),y=dleftparetolognormal(x=seq(0,5,length.out=100),shape1=1))
</p>
<p>## Left-Pareto Lognormal relates to the Lognormal if the shape parameter goes to infinity
pleftparetolognormal(q=6,shape1=1e20,meanlog=-0.5,sdlog=0.5)
plnorm(q=6,meanlog=-0.5,sdlog=0.5)
</p>
<p>## Demonstration of log functionality for probability and quantile function
qleftparetolognormal(pleftparetolognormal(2,log.p=TRUE),log.p=TRUE)
</p>
<p>## The zeroth truncated moment is equivalent to the probability function
pleftparetolognormal(2)
mleftparetolognormal(truncation=2)
</p>
<p>## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x = rleftparetolognormal(1e5)
</p>
<p>mean(x)
mleftparetolognormal(r=1,lower.tail=FALSE)
</p>
<p>sum(x[x&gt;quantile(x,0.1)])/length(x)
mleftparetolognormal(r=1,truncation=quantile(x,0.1),lower.tail=FALSE)
</p>

<hr>
<h2 id='leftparetolognormal_plt'>Left-Pareto Lognormal coefficients of power-law transformed Left-Pareto Lognormal</h2><span id='topic+leftparetolognormal_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Left-Pareto Lognormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leftparetolognormal_plt(
  shape1 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  a = 1,
  b = 1,
  inv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leftparetolognormal_plt_+3A_shape1">shape1</code>, <code id="leftparetolognormal_plt_+3A_meanlog">meanlog</code>, <code id="leftparetolognormal_plt_+3A_sdlog">sdlog</code></td>
<td>
<p>Shapes, mean and variance of the Left-Pareto Lognormal distribution respectively.</p>
</td></tr>
<tr><td><code id="leftparetolognormal_plt_+3A_a">a</code>, <code id="leftparetolognormal_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="leftparetolognormal_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable y is Left-Pareto Lognormal distributed with mean meanlog and standard deviation sdlog, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Left-Pareto Lognormal distributed with <code class="reqn"> shape1*b, \frac{meanlog-log(a)}{b}, \frac{sdlog}{b} </code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
## Comparing probabilites of power-law transformed transformed variables
pleftparetolognormal(3, shape1 = 1.5, meanlog = -0.5, sdlog = 0.5)
coeff &lt;- leftparetolognormal_plt(shape1 = 1.5, meanlog = -0.5, sdlog = 0.5,
a = 5, b = 7)$coefficients
pleftparetolognormal(5 * 3^7, shape1 = coeff[["shape1"]], meanlog = coeff[["meanlog"]],
sdlog = coeff[["sdlog"]])

pleftparetolognormal(5 * 0.9^7, shape1 = 1.5, meanlog = -0.5, sdlog = 0.5)
coeff &lt;- leftparetolognormal_plt(shape1 = 1.5, meanlog = -0.5, sdlog = 0.5, a = 5, b = 7,
inv = TRUE)$coefficients
pleftparetolognormal(0.9, shape1 = coeff[["shape1"]], meanlog = coeff[["meanlog"]],
 sdlog = coeff[["sdlog"]])
</code></pre>

<hr>
<h2 id='leftparetolognormal.mle'>Left-Pareto Lognormal MLE</h2><span id='topic+leftparetolognormal.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the parameters of the Left-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leftparetolognormal.mle(
  x,
  lower = c(1e-10, 1e-10),
  upper = c(Inf, Inf),
  start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leftparetolognormal.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="leftparetolognormal.mle_+3A_lower">lower</code>, <code id="leftparetolognormal.mle_+3A_upper">upper</code></td>
<td>
<p>Upper and lower bounds for the estimation procedure on the parameters c(shape1,sdlog), defaults to c(1e-10,1e-10) and c(Inf,Inf) respectively.</p>
</td></tr>
<tr><td><code id="leftparetolognormal.mle_+3A_start">start</code></td>
<td>
<p>named vector with starting values, default to c(shape1=2,sdlog=sd(log(x)))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>

<p>x = rleftparetolognormal(1e3)
</p>
<p>## Pareto fit with xmin set to the minium of the sample
leftparetolognormal.mle(x=x)
</p>

<hr>
<h2 id='llr_vuong'>Vuong's closeness test</h2><span id='topic+llr_vuong'></span>

<h3>Description</h3>

<p>Likelihood ratio test for model selection using the Kullback-Leibler information criterion (Vuong 1989)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llr_vuong(x, y, np.x, np.y, corr = c("none", "BIC", "AIC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llr_vuong_+3A_x">x</code>, <code id="llr_vuong_+3A_y">y</code></td>
<td>
<p>vector of log-likelihoods</p>
</td></tr>
<tr><td><code id="llr_vuong_+3A_np.x">np.x</code>, <code id="llr_vuong_+3A_np.y">np.y</code></td>
<td>
<p>Number of paremeters respectively</p>
</td></tr>
<tr><td><code id="llr_vuong_+3A_corr">corr</code></td>
<td>
<p>type of correction for parameters, defaults to none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns data frame with test statistic, p-value and character vector indicating the test outcome.
</p>


<h3>References</h3>

<p>Vuong QH (1989).
&ldquo;Likelihood Ratio Tests for Model Selection and Non-Nested Hypotheses.&rdquo;
<em>Econometrica</em>, <b>57</b>(2), 307&ndash;333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlnorm(1e4, meanlog = -0.5, sdlog = 0.5)
pareto_fit &lt;- combdist.mle(x = x, dist = "pareto")
pareto_loglike &lt;- dcombdist(x = x, dist = "pareto", coeff = pareto_fit$coefficients, log = TRUE)
lnorm_fit &lt;- combdist.mle(x = x, dist = "lnorm")
lnorm_loglike &lt;- dcombdist(x = x, dist = "lnorm", coeff = lnorm_fit$coefficients, log = TRUE)

llr_vuong(x = pareto_loglike, y = lnorm_loglike, np.x = pareto_fit$np, np.y = lnorm_fit$np)

# BIC type parameter correction
llr_vuong(x = pareto_loglike, y = lnorm_loglike, np.x = pareto_fit$np, np.y = lnorm_fit$np,
corr = "BIC")

# AIC type parameter correction
llr_vuong(x = pareto_loglike, y = lnorm_loglike, np.x = pareto_fit$np, np.y = lnorm_fit$np,
corr = "AIC")
</code></pre>

<hr>
<h2 id='lnorm'>The Lognormal distribution</h2><span id='topic+lnorm'></span><span id='topic+mlnorm'></span>

<h3>Description</h3>

<p>Raw moments for the Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlnorm(r = 0, truncation = 0, meanlog = -0.5, sdlog = 0.5, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lnorm_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution, defaults to 1.</p>
</td></tr>
<tr><td><code id="lnorm_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to 0.</p>
</td></tr>
<tr><td><code id="lnorm_+3A_meanlog">meanlog</code>, <code id="lnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>mean and standard deviation of the distribution on the log scale with default values of 0 and 1 respectively.</p>
</td></tr>
<tr><td><code id="lnorm_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), moments are <code class="reqn">E[x^r|X \le y]</code>, otherwise, <code class="reqn">E[x^r|X &gt; y]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{{x Var \sqrt {2\pi } }}e^{- (lnx - \mu  )^2/ 2Var^2} , \qquad F_X(x) = \Phi(\frac{lnx- \mu}{Var})</code>
</p>

<p>The y-bounded r-th raw moment of the Lognormal distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">\mu^r_y =  e^{\frac{r (rVar^2 + 2\mu)}{2}}[1-\Phi(\frac{lny - (rVar^2 + \mu)}{Var})]  </code>
</p>



<h3>Value</h3>

<p>Provides the y-bounded, rth raw moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The zeroth truncated moment is equivalent to the probability function
plnorm(2, meanlog = -0.5, sdlog = 0.5)
mlnorm(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rlnorm(1e5, meanlog = -0.5, sdlog = 0.5)
mean(x)
mlnorm(r = 1, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mlnorm(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='lnorm_plt'>Log Normal coefficients of power-law transformed log normal</h2><span id='topic+lnorm_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed log normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnorm_plt(meanlog = 0, sdlog = 1, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lnorm_plt_+3A_meanlog">meanlog</code>, <code id="lnorm_plt_+3A_sdlog">sdlog</code></td>
<td>
<p>mean and standard deviation of the log normal distributed variable, defaults to 0 and 1 respectively.</p>
</td></tr>
<tr><td><code id="lnorm_plt_+3A_a">a</code>, <code id="lnorm_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="lnorm_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable y is log normally distributed with mean meanlog and standard deviation sdlog, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is log normally distributed with mean <code class="reqn"> \frac{meanlog - ln(a)}{b} </code> and standard deviation <code class="reqn">\frac{sdlog}{b}</code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
plnorm(3,meanlog=-0.5,sdlog=0.5)
coeff = lnorm_plt(meanlog=-0.5,sdlog=0.5,a=5,b=7)$coefficients
plnorm(5*3^7,meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>
<p>plnorm(5*0.8^7,meanlog=-0.5,sdlog=0.5)
coeff = lnorm_plt(meanlog=-0.5,sdlog=0.5,a=5,b=7,inv=TRUE)$coefficients
plnorm(0.8,meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>
<p>## Comparing the first moments and sample means of power-law transformed variables for large enough samples
x = rlnorm(1e5,meanlog=-0.5,sdlog=0.5)
coeff = lnorm_plt(meanlog=-0.5,sdlog=0.5,a=2,b=0.5)$coefficients
y = rlnorm(1e5,meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
mean(2*x^0.5)
mean(y)
mlnorm(r=1,meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]],lower.tail=FALSE)
</p>

<hr>
<h2 id='nmad_test'>Normalized Absolute Deviation</h2><span id='topic+nmad_test'></span>

<h3>Description</h3>

<p>Calculates the Normalized Absolute Deviation between the empirical moments and the moments of the provided distribution. Corresponds to the Kolmogorov-Smirnov test statistic for the zeroth moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmad_test(
  x,
  r = 0,
  dist,
  prior = 1,
  coeff,
  stat = c("NULL", "max", "sum"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmad_test_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_r">r</code></td>
<td>
<p>moment parameter</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_dist">dist</code></td>
<td>
<p>character vector containing distribution</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_prior">prior</code></td>
<td>
<p>named list of priors, defaults to 1</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_coeff">coeff</code></td>
<td>
<p>named list of coefficients</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_stat">stat</code></td>
<td>
<p>character vector indicating which statistic should be calculated: none (NULL), the maximum deviation &quot;max&quot; or the sum of deviations &quot;sum&quot;. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="nmad_test_+3A_...">...</code></td>
<td>
<p>Additional arguments can be passed to the parametric moment call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlnorm(1e2, meanlog = -0.5, sdlog = 0.5)
nmad_test(x = x, r = 0, dist = "lnorm", coeff = c(meanlog = -0.5, sdlog = 0.5))
nmad_test(x = x, r = 0, dist = "lnorm", coeff = c(meanlog = -0.5, sdlog = 0.5), stat = "max")
nmad_test(x = x, r = 0, dist = "lnorm", coeff = c(meanlog = -0.5, sdlog = 0.5), stat = "sum")
</code></pre>

<hr>
<h2 id='pareto'>The Pareto distribution</h2><span id='topic+pareto'></span><span id='topic+dpareto'></span><span id='topic+ppareto'></span><span id='topic+qpareto'></span><span id='topic+mpareto'></span><span id='topic+rpareto'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for the Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto(x, k = 2, xmin = 1, log = FALSE, na.rm = FALSE)

ppareto(q, k = 2, xmin = 1, lower.tail = TRUE, log.p = FALSE, na.rm = FALSE)

qpareto(p, k = 2, xmin = 1, lower.tail = TRUE, log.p = FALSE)

mpareto(r = 0, truncation = xmin, k = 2, xmin = 1, lower.tail = TRUE)

rpareto(n, k = 2, xmin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pareto_+3A_x">x</code>, <code id="pareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="pareto_+3A_xmin">xmin</code>, <code id="pareto_+3A_k">k</code></td>
<td>
<p>Scale and shape of the Pareto distribution, defaults to 1 and 2 respectively.</p>
</td></tr>
<tr><td><code id="pareto_+3A_log">log</code>, <code id="pareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="pareto_+3A_na.rm">na.rm</code></td>
<td>
<p>Removes values that fall outside the support of the distribution</p>
</td></tr>
<tr><td><code id="pareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn"> (E[x^r|X \le y] )</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn"> (E[x^r|X &gt; y] )</code></p>
</td></tr>
<tr><td><code id="pareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="pareto_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="pareto_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to xmin</p>
</td></tr>
<tr><td><code id="pareto_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{kx_{min}^{k}}{x^{k+1}}, \qquad F_X(x) = 1-(\frac{x_{min} }{x})^{k}</code>
</p>

<p>The y-bounded r-th raw moment of the Pareto distribution equals:
</p>
<p style="text-align: center;"><code class="reqn"> \mu^{r}_{y} = k x_{min}^k \frac{- y^{r-k} }{r-k},  \qquad k&gt;r</code>
</p>



<h3>Value</h3>

<p>dpareto returns the density, ppareto the distribution function, qpareto the quantile function, mpareto the rth moment of the distribution and rpareto generates random deviates.
</p>
<p>The length of the result is determined by n for rpareto, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Pareto density
plot(x = seq(1, 5, length.out = 100), y = dpareto(x = seq(1, 5, length.out = 100), k = 2, xmin = 1))

## Pareto relates to the exponential distribution available in the stats package
ppareto(q = 5, k = 2, xmin = 3)
pexp(q = log(5 / 3), rate = 2)

## Demonstration of log functionality for probability and quantile function
qpareto(ppareto(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
ppareto(2)
mpareto(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rpareto(1e5)

mean(x)
mpareto(r = 1, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mpareto(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='pareto_plt'>Pareto coefficients after power-law transformation</h2><span id='topic+pareto_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_plt(xmin = 1, k = 2, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pareto_plt_+3A_xmin">xmin</code>, <code id="pareto_plt_+3A_k">k</code></td>
<td>
<p>Scale and shape of the Pareto distribution, defaults to 1 and 2 respectively.</p>
</td></tr>
<tr><td><code id="pareto_plt_+3A_a">a</code>, <code id="pareto_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="pareto_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable x is Pareto-distributed with scale xmin and shape k, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Pareto distributed with scale <code class="reqn"> ( \frac{xmin}{a})^{\frac{1}{b}} </code> and shape <code class="reqn">b*k</code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
## Comparing probabilites of power-law transformed transformed variables
ppareto(3, k = 2, xmin = 2)
coeff &lt;- pareto_plt(xmin = 2, k = 2, a = 5, b = 7)$coefficients
ppareto(5 * 3^7, k = coeff[["k"]], xmin = coeff[["xmin"]])

ppareto(5 * 0.9^7, k = 2, xmin = 2)
coeff &lt;- pareto_plt(xmin = 2, k = 2, a = 5, b = 7, inv = TRUE)$coefficients
ppareto(0.9, k = coeff[["k"]], xmin = coeff[["xmin"]])

## Comparing the first moments and sample means of power-law transformed variables for
#large enough samples
x &lt;- rpareto(1e5, k = 2, xmin = 2)
coeff &lt;- pareto_plt(xmin = 2, k = 2, a = 2, b = 0.5)$coefficients
y &lt;- rpareto(1e5, k = coeff[["k"]], xmin = coeff[["xmin"]])
mean(2 * x^0.5)
mean(y)
mpareto(r = 1, k = coeff[["k"]], xmin = coeff[["xmin"]], lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='pareto.mle'>Pareto MLE</h2><span id='topic+pareto.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the Pareto shape parameter using the Hill estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto.mle(x, xmin = NULL, clauset = FALSE, q = 0, lower = 1e-10, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pareto.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="pareto.mle_+3A_xmin">xmin</code></td>
<td>
<p>scale parameter of the Pareto distribution, set to min(x) if not provided</p>
</td></tr>
<tr><td><code id="pareto.mle_+3A_clauset">clauset</code></td>
<td>
<p>Indicator variable for calculating the scale parameter using the clauset method, overrides provided xmin</p>
</td></tr>
<tr><td><code id="pareto.mle_+3A_q">q</code></td>
<td>
<p>Percentage of data to search over (starting from the largest values), defaults to 0.</p>
</td></tr>
<tr><td><code id="pareto.mle_+3A_lower">lower</code>, <code id="pareto.mle_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bounds to the estimated shape parameter, defaults to 1e-10 and Inf respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hill estimator equals
</p>
<p style="text-align: center;"><code class="reqn"> \hat{k} = \frac{1}{ \frac{1}{n} \sum_{i=1}^{n} log \frac{x_i}{x_{min}}} </code>
</p>



<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rpareto(1e3, k = 2, xmin = 2)

## Pareto fit with xmin set to the minium of the sample
pareto.mle(x = x)

## Pareto fit with xmin set to its real value
pareto.mle(x = x, xmin = 2)

## Pareto fit with xmin determined by the Clauset method
pareto.mle(x = x, clauset = TRUE)
</code></pre>

<hr>
<h2 id='rightparetolognormal'>The Right-Pareto Lognormal distribution</h2><span id='topic+rightparetolognormal'></span><span id='topic+drightparetolognormal'></span><span id='topic+prightparetolognormal'></span><span id='topic+qrightparetolognormal'></span><span id='topic+mrightparetolognormal'></span><span id='topic+rrightparetolognormal'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Right-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drightparetolognormal(
  x,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  log = FALSE
)

prightparetolognormal(
  q,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

qrightparetolognormal(
  p,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

mrightparetolognormal(
  r = 0,
  truncation = 0,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE
)

rrightparetolognormal(
  n,
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  lower.tail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rightparetolognormal_+3A_x">x</code>, <code id="rightparetolognormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_shape2">shape2</code>, <code id="rightparetolognormal_+3A_meanlog">meanlog</code>, <code id="rightparetolognormal_+3A_sdlog">sdlog</code></td>
<td>
<p>Shape, mean and variance of the Right-Pareto Lognormal distribution respectively.</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_log">log</code>, <code id="rightparetolognormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_r">r</code></td>
<td>
<p>rth raw moment of the Pareto distribution</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to xmin</p>
</td></tr>
<tr><td><code id="rightparetolognormal_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function as provided by (Reed and Jorgensen 2004):
</p>
<p><code class="reqn">f(x) = shape2 \omega^{-shape2-1}e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\Phi(\frac{lnx - meanlog - shape2 sdlog^2}{sdlog}), \newline F_X(x) = \Phi(\frac{lnx - meanlog }{sdlog}) -  \omega^{-shape2}e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\Phi(\frac{lnx - meanlog - shape2 sdlog^2}{sdlog})</code>
</p>
<p>The y-bounded r-th raw moment of the Right-Pareto Lognormal distribution equals:
</p>
<p><code class="reqn">meanlog^{r}_{y} = -shape2e^{shape2 meanlog + \frac{shape2^2sdlog^2}{2}}\frac{y^{\sigma_s - shape2-1}}{\sigma_s - shape2 - 1}\Phi(\frac{lny - meanlog - shape2 sdlog^2}{sdlog}) \newline \qquad - \frac{shape2}{r-shape2} e^{\frac{ r^2sdlog^2 + 2meanlog r }{2}}\Phi^c(\frac{lny -  rsdlog^2 + meanlog}{sdlog}),  \qquad shape2&gt;r</code>
</p>


<h3>Value</h3>

<p>drightparetolognormal gives the density, prightparetolognormal gives the distribution function, qrightparetolognormal gives the quantile function, mrightparetolognormal gives the rth moment of the distribution and rrightparetolognormal generates random deviates.
</p>
<p>The length of the result is determined by n for rrightparetolognormal, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>References</h3>

<p>Reed WJ, Jorgensen M (2004).
&ldquo;The Double Pareto-Lognormal Distribution&ndash;A New Parametric Model for Size Distributions.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>33</b>(8), 1733&ndash;1753.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Right-Pareto Lognormal density
plot(x = seq(0, 5, length.out = 100), y = drightparetolognormal(x = seq(0, 5, length.out = 100)))
plot(x = seq(0, 5, length.out = 100), y = drightparetolognormal(x = seq(0, 5, length.out = 100),
shape2 = 1))

## Right-Pareto Lognormal relates to the Lognormal if the shape parameter goes to infinity
prightparetolognormal(q = 6, shape2 = 1e20, meanlog = -0.5, sdlog = 0.5)
plnorm(q = 6, meanlog = -0.5, sdlog = 0.5)

## Demonstration of log functionality for probability and quantile function
qrightparetolognormal(prightparetolognormal(2, log.p = TRUE), log.p = TRUE)

## The zeroth truncated moment is equivalent to the probability function
prightparetolognormal(2)
mrightparetolognormal(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rrightparetolognormal(1e5, shape2 = 3)

mean(x)
mrightparetolognormal(r = 1, shape2 = 3, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mrightparetolognormal(r = 1, shape2 = 3, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='rightparetolognormal_plt'>Right-Pareto Lognormal coefficients of power-law transformed Right-Pareto Lognormal</h2><span id='topic+rightparetolognormal_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Right-Pareto Lognormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rightparetolognormal_plt(
  shape2 = 1.5,
  meanlog = -0.5,
  sdlog = 0.5,
  a = 1,
  b = 1,
  inv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rightparetolognormal_plt_+3A_shape2">shape2</code>, <code id="rightparetolognormal_plt_+3A_meanlog">meanlog</code>, <code id="rightparetolognormal_plt_+3A_sdlog">sdlog</code></td>
<td>
<p>Shapes, mean and variance of the Right-Pareto Lognormal distribution respectively.</p>
</td></tr>
<tr><td><code id="rightparetolognormal_plt_+3A_a">a</code>, <code id="rightparetolognormal_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="rightparetolognormal_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable y is Right-Pareto Lognormal distributed with mean meanlog and standard deviation sdlog, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Right-Pareto Lognormal distributed with <code class="reqn"> \frac{meanlog-log(a)}{b}, \frac{sdlog}{b}, shape2*b </code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
prightparetolognormal(3, shape2 = 3, meanlog = -0.5, sdlog = 0.5)
coeff = rightparetolognormal_plt( shape2 = 3, meanlog = -0.5, sdlog = 0.5,a=5,b=7)$coefficients
prightparetolognormal(5*3^7,shape2=coeff[[&quot;shape2&quot;]],meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>
<p>prightparetolognormal(5*0.9^7,shape2 = 3, meanlog = -0.5, sdlog = 0.5)
coeff = rightparetolognormal_plt(shape2 = 3, meanlog = -0.5, sdlog = 0.5,a=5,b=7, inv=TRUE)$coefficients
prightparetolognormal(0.9,shape2=coeff[[&quot;shape2&quot;]],meanlog=coeff[[&quot;meanlog&quot;]],sdlog=coeff[[&quot;sdlog&quot;]])
</p>

<hr>
<h2 id='rightparetolognormal.mle'>Right-Pareto Lognormal MLE</h2><span id='topic+rightparetolognormal.mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the parameters of the Right-Pareto Lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rightparetolognormal.mle(
  x,
  lower = c(1e-10, 1e-10),
  upper = c(Inf, Inf),
  start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rightparetolognormal.mle_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="rightparetolognormal.mle_+3A_lower">lower</code>, <code id="rightparetolognormal.mle_+3A_upper">upper</code></td>
<td>
<p>Upper and lower bounds for the estimation procedure on the parameters c(shape2,sdlog), defaults to c(1e-10,1e-10) and c(Inf,Inf) respectively.</p>
</td></tr>
<tr><td><code id="rightparetolognormal.mle_+3A_start">start</code></td>
<td>
<p>named vector with starting values, default to c(shape2=2,sdlog=sd(log(x)))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing a
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
<dt>convergence</dt><dd><p>logical indicator of convergence</p>
</dd>
<dt>n</dt><dd><p>Length of the fitted data vector</p>
</dd>
<dt>np</dt><dd><p>Nr. of coefficients</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rrightparetolognormal(1e3)

## Pareto fit with xmin set to the minium of the sample
rightparetolognormal.mle(x = x)
</code></pre>

<hr>
<h2 id='truncdist'>Truncated distribution</h2><span id='topic+truncdist'></span><span id='topic+dtruncdist'></span><span id='topic+ptruncdist'></span><span id='topic+qtruncdist'></span><span id='topic+mtruncdist'></span><span id='topic+rtruncdist'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, raw moments and random generation for a truncated distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtruncdist(
  x,
  dist = c("lnormtrunc"),
  coeff = list(meanlog = 0, sdlog = 1),
  lowertrunc = 0,
  uppertrunc = Inf,
  log = FALSE
)

ptruncdist(
  q,
  dist = c("lnormtrunc"),
  coeff = list(meanlog = 0, sdlog = 1),
  lowertrunc = 0,
  uppertrunc = Inf,
  log.p = FALSE,
  lower.tail = TRUE
)

qtruncdist(
  p,
  dist = c("lnormtrunc"),
  coeff = list(meanlog = 0, sdlog = 1),
  lowertrunc = 0,
  uppertrunc = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)

mtruncdist(
  r,
  truncation = 0,
  dist = c("lnormtrunc"),
  coeff = list(meanlog = 0, sdlog = 1),
  lowertrunc = 0,
  uppertrunc = Inf,
  lower.tail = TRUE
)

rtruncdist(
  n,
  dist = c("lnormtrunc"),
  coeff = list(meanlog = 0, sdlog = 1),
  lowertrunc = 0,
  uppertrunc = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncdist_+3A_x">x</code>, <code id="truncdist_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="truncdist_+3A_dist">dist</code></td>
<td>
<p>distribution to be truncated, defaults to lnorm</p>
</td></tr>
<tr><td><code id="truncdist_+3A_coeff">coeff</code></td>
<td>
<p>list of parameters for the truncated distribution, defaults to list(meanlog=0,sdlog=1)</p>
</td></tr>
<tr><td><code id="truncdist_+3A_lowertrunc">lowertrunc</code>, <code id="truncdist_+3A_uppertrunc">uppertrunc</code></td>
<td>
<p>lowertrunc- and uppertrunc truncation points, defaults to 0 and Inf respectively</p>
</td></tr>
<tr><td><code id="truncdist_+3A_log">log</code>, <code id="truncdist_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="truncdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities (moments) are <code class="reqn">P[X \le x]</code> <code class="reqn">(E[x^r|X \le y])</code>, otherwise, <code class="reqn">P[X &gt; x]</code> <code class="reqn">(E[x^r|X &gt; y])</code></p>
</td></tr>
<tr><td><code id="truncdist_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="truncdist_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution</p>
</td></tr>
<tr><td><code id="truncdist_+3A_truncation">truncation</code></td>
<td>
<p>lowertrunc truncation parameter, defaults to 0.</p>
</td></tr>
<tr><td><code id="truncdist_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{g(x)}{F(uppertrunc)-F(lowertrunc)}, \qquad F_X(x) = \frac{F(x)-F(lowertrunc)}{F(uppertrunc)-F(lowertrunc)}</code>
</p>



<h3>Value</h3>

<p>dtruncdist gives the density, ptruncdist gives the distribution function, qtruncdist gives the quantile function, mtruncdist gives the rth moment of the distribution and rtruncdist generates random deviates.
</p>
<p>The length of the result is determined by n for rpareto, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Truncated lognormal density
plot(x = seq(0.5, 3, length.out = 100), y = dtruncdist(x = seq(0.5, 5, length.out = 100),
dist = "lnorm", coeff = list(meanlog = 0.5, sdlog = 0.5), lowertrunc = 0.5, uppertrunc = 5))
lines(x = seq(0, 6, length.out = 100), y = dlnorm(x = seq(0, 6, length.out = 100),
meanlog = 0.5, sdlog = 0.5))

# Compare quantities
dtruncdist(0.5)
dlnorm(0.5)
dtruncdist(0.5, lowertrunc = 0.5, uppertrunc = 3)

ptruncdist(2)
plnorm(2)
ptruncdist(2, lowertrunc = 0.5, uppertrunc = 3)

qtruncdist(0.25)
qlnorm(0.25)
qtruncdist(0.25, lowertrunc = 0.5, uppertrunc = 3)

mtruncdist(r = 0, truncation = 2)
mlnorm(r = 0, truncation = 2, meanlog = 0, sdlog = 1)
mtruncdist(r = 0, truncation = 2, lowertrunc = 0.5, uppertrunc = 3)

mtruncdist(r = 1, truncation = 2)
mlnorm(r = 1, truncation = 2, meanlog = 0, sdlog = 1)
mtruncdist(r = 1, truncation = 2, lowertrunc = 0.5, uppertrunc = 3)
</code></pre>

<hr>
<h2 id='weibull'>The Weibull distribution</h2><span id='topic+weibull'></span><span id='topic+mweibull'></span>

<h3>Description</h3>

<p>Raw moments for the Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mweibull(r = 0, truncation = 0, shape = 2, scale = 1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibull_+3A_r">r</code></td>
<td>
<p>rth raw moment of the distribution, defaults to 1.</p>
</td></tr>
<tr><td><code id="weibull_+3A_truncation">truncation</code></td>
<td>
<p>lower truncation parameter, defaults to 0.</p>
</td></tr>
<tr><td><code id="weibull_+3A_shape">shape</code>, <code id="weibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale of the distribution with default values of 2 and 1 respectively.</p>
</td></tr>
<tr><td><code id="weibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), moments are <code class="reqn">E[x^r|X \le y]</code>, otherwise, <code class="reqn">E[x^r|X &gt; y]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability and Cumulative Distribution Function:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{shape}{scale}(\frac{\omega}{scale})^{shape-1}e^{-(\frac{\omega}{scale})^shape} , \qquad F_X(x) = 1-e^{-(\frac{\omega}{scale})^shape}</code>
</p>

<p>The y-bounded r-th raw moment of the distribution equals:
</p>
<p style="text-align: center;"><code class="reqn">\mu^r_y =   scale^{r} \Gamma(\frac{r}{shape} +1, (\frac{y}{scale})^shape ) </code>
</p>

<p>where <code class="reqn">\Gamma(,)</code> denotes the upper incomplete gamma function.
</p>


<h3>Value</h3>

<p>returns the truncated rth raw moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The zeroth truncated moment is equivalent to the probability function
pweibull(2, shape = 2, scale = 1)
mweibull(truncation = 2)

## The (truncated) first moment is equivalent to the mean of a (truncated) random sample,
#for large enough samples.
x &lt;- rweibull(1e5, shape = 2, scale = 1)
mean(x)
mweibull(r = 1, lower.tail = FALSE)

sum(x[x &gt; quantile(x, 0.1)]) / length(x)
mweibull(r = 1, truncation = quantile(x, 0.1), lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='weibull_plt'>Weibull coefficients of power-law transformed Weibull</h2><span id='topic+weibull_plt'></span>

<h3>Description</h3>

<p>Coefficients of a power-law transformed Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weibull_plt(scale = 1, shape = 2, a = 1, b = 1, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibull_plt_+3A_shape">shape</code>, <code id="weibull_plt_+3A_scale">scale</code></td>
<td>
<p>shape and scale of the distribution with default values of 2 and 1 respectively.</p>
</td></tr>
<tr><td><code id="weibull_plt_+3A_a">a</code>, <code id="weibull_plt_+3A_b">b</code></td>
<td>
<p>constant and power of power-law transformation, defaults to 1 and 1 respectively.</p>
</td></tr>
<tr><td><code id="weibull_plt_+3A_inv">inv</code></td>
<td>
<p>logical indicating whether coefficients of the outcome variable of the power-law transformation should be returned (FALSE) or whether coefficients of the input variable being power-law transformed should be returned (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the random variable y is Weibull distributed with mean meanlog and standard deviation sdlog, then the power-law transformed variable
</p>
<p style="text-align: center;"><code class="reqn"> y = ax^b </code>
</p>

<p>is Weibull distributed with scale <code class="reqn"> ( \frac{scale}{a})^{\frac{1}{b}} </code> and shape <code class="reqn">b*shape</code>.
</p>


<h3>Value</h3>

<p>Returns a named list containing
</p>

<dl>
<dt>coefficients</dt><dd><p>Named vector of coefficients</p>
</dd>
</dl>

<p>## Comparing probabilites of power-law transformed transformed variables
pweibull(3,shape=2,scale=1)
coeff = weibull_plt(shape=2,scale=1,a=5,b=7)$coefficients
pweibull(5*3^7,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>
<p>pweibull(5*0.8^7,shape=2,scale=1)
coeff = weibull_plt(shape=2,scale=1,a=5,b=7,inv=TRUE)$coefficients
pweibull(0.8,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]])
</p>
<p>## Comparing the first moments and sample means of power-law transformed variables for large enough samples
x = rweibull(1e5,shape=2,scale=1)
coeff = weibull_plt(shape=2,scale=1,a=2,b=0.5)$coefficients
y = rweibull(1e5,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]])
mean(2*x^0.5)
mean(y)
mweibull(r=1,shape=coeff[[&quot;shape&quot;]],scale=coeff[[&quot;scale&quot;]],lower.tail=FALSE)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
