<!DOCTYPE html><html><head><title>Help for package endorse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {endorse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#endorse'>
<p>Fitting the Measurement Model of Political Support via Markov Chain</p>
Monte Carlo</a></li>
<li><a href='#endorse.plot'>
<p>Descriptive Plot of Endorsement Experiment Data</p></a></li>
<li><a href='#GeoCount'>
<p>Counting Incidents around Points</p></a></li>
<li><a href='#GeoId'>
<p>Getting Indices of Incidents around a specified point</p></a></li>
<li><a href='#pakistan'><p>Pakistan Survey Experiment on Support for Militant Groups</p></a></li>
<li><a href='#predict.endorse'><p>Predict Method for the Measurement Model of Political Support</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-5-2</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Measurement Models for Analyzing Endorsement
Experiments</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuki Shiraito [aut, cre],
  Kosuke Imai [aut],
  Bryn Rosenfeld [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuki Shiraito &lt;shiraito@umich.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>coda, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit the hierarchical and non-hierarchical Bayesian measurement models proposed by Bullock, Imai, and Shapiro (2011) &lt;<a href="https://doi.org/10.1093%2Fpan%2Fmpr031">doi:10.1093/pan/mpr031</a>&gt; to analyze endorsement experiments.  Endorsement experiments are a survey methodology for eliciting truthful responses to sensitive questions.  This methodology is helpful when measuring support for socially sensitive political actors such as militant groups.  The model is fitted with a Markov chain Monte Carlo algorithm and produces the output containing draws from the posterior distribution. </td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SensitiveQuestions/endorse/">https://github.com/SensitiveQuestions/endorse/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-02 06:43:44 UTC; yuki</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-02 07:00:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='endorse'>
Fitting the Measurement Model of Political Support via Markov Chain
Monte Carlo
</h2><span id='topic+endorse'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of the
measurement model of political support. Individual-level covariates
may be included in the model. The details of the model are given under
&lsquo;Details&rsquo;. See also Bullock et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endorse(Y, data, data.village = NA, village = NA, treat = NA,
        na.strings = 99, identical.lambda = TRUE,
        covariates = FALSE, formula.indiv = NA,
        hierarchical = FALSE, formula.village = NA, h = NULL,
        group = NULL, x.start = 0, s.start = 0,
        beta.start = 1, tau.start = NA, lambda.start = 0,
        omega2.start = .1, theta.start = 0, phi2.start = .1,
        kappa.start = 0, psi2.start = 1, delta.start = 0,
        zeta.start = 0, rho2.start = 1, mu.beta = 0, mu.x = 0,
        mu.theta = 0, mu.kappa = 0, mu.delta = 0, mu.zeta = 0,
        precision.beta = 0.04, precision.x = 1,
        precision.theta = 0.04, precision.kappa = 0.04,
        precision.delta = 0.04, precision.zeta = 0.04,
        s0.omega2= 1, nu0.omega2 = 10, s0.phi2 = 1,
        nu0.phi2 = 10, s0.psi2 = 1, nu0.psi2 = 10,
        s0.sig2 = 1, nu0.sig2 = 400, s0.rho2 = 1,
        nu0.rho2 = 10, MCMC = 20000, burn = 1000, thin = 1,
        mh = TRUE, prop = 0.001, x.sd = TRUE,
        tau.out = FALSE, s.out = FALSE, omega2.out = TRUE,
        phi2.out = TRUE, psi2.out = TRUE, verbose = TRUE,
        seed.store = FALSE, update = FALSE,
        update.start = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endorse_+3A_y">Y</code></td>
<td>
<p>a list of the variable names for the responses. It should
take the following form:
</p>
<p><code>list(Q1 = c("varnameQ1.1", "varnameQ1.2", ...),...)</code>.
</p>
<p>If <code>treat</code> is <code>NA</code>, the first
variable for each question should be the responses of the
control observations while each of the other variables should
correspond to each endorser. <code>treat</code> should be supplied if
only one variable name is provided for a question in this argument.
If auxiliary information is included, it is assumed that <code>Y</code> is 
coded such that higher values indicate more of the sensitive trait.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_data">data</code></td>
<td>
<p>data frame containing the individual-level variables.
The cases must be complete, i.e., no <code>NA</code>'s are allowed.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_data.village">data.village</code></td>
<td>
<p>data frame containing the village-level variables.
The cases must be complete, i.e., no <code>NA</code>'s are allowed. If 
auxiliary information is included, the data frame should include only
the unique group identifier and the unique identifier for the units at 
which prediction is desired. The package does not currently support 
the inclusion of covariates in models with auxiliary information.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_village">village</code></td>
<td>
<p>character.  The variable name of the village indicator
in the individual-level data. If auxiliary information is included,
this should correspond to the variable name of the units at which
prediction is desired. 
</p>
</td></tr>
<tr><td><code id="endorse_+3A_treat">treat</code></td>
<td>
<p>An optional matrix of non negative integers indicating
the treatment
status of each observation and each question.
Rows are observations
and columns are questions. 0 represents the control status while
positive integers indicate treatment statuses.
If <code>treat</code> is set to <code>NA</code>, the function generates the    
treatment matrix using <code>Y</code>.
The default is <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_na.strings">na.strings</code></td>
<td>
<p>a scalar or a vector indicating the values of the
response variable that are to be interpreted as &ldquo;Don't Know&rdquo; or
&ldquo;Refused to Answer.&rdquo; The value should not be <code>NA</code> unless
<code>treat</code> is provided, because <code>NA</code>'s are interpreted as the
response to the question with another endorsement. Default is
<code>99</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_identical.lambda">identical.lambda</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the model with a common
lambda across questions will be fitted.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_covariates">covariates</code></td>
<td>
<p>logical. If <code>TRUE</code>, the model includes
individual-level covariates. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_formula.indiv">formula.indiv</code></td>
<td>
<p>a symbolic description specifying the individual level 
covariates for the support parameter and the ideal points. The formula
should be one-sided, e.g. <code> ~ Z1 + Z2</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_hierarchical">hierarchical</code></td>
<td>
<p>logical.  IF <code>TRUE</code>, the hierarchical model with
village level predictors will be fitted.  The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_formula.village">formula.village</code></td>
<td>
<p>a symbolic description specifying the village level 
covariates for the support parameter and the ideal points. The formula
should be one-sided.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_h">h</code></td>
<td>
<p>Auxiliary data functionality. Optional named numeric vector with 
length equal to number of groups. Names correspond to group labels and 
values correspond to auxiliary moments (i.e. to the known share
of the sensitive trait at the group level).
</p>
</td></tr>
<tr><td><code id="endorse_+3A_group">group</code></td>
<td>
<p>Auxiliary data functionality. Optional character string.  
The variable name of the group indicator in the individual-level data 
(e.g. <code>group = "county"</code>).
</p>
</td></tr>
<tr><td><code id="endorse_+3A_x.start">x.start</code></td>
<td>
<p>starting values for the ideal points vector <code class="reqn">x</code>. If
<code>x.start</code> is set to a scalar, the starting values for the ideal
points of all respondents will be set to the scalar. If
<code>x.start</code> is a vector of the same length as the number of
observations, then this vector will be used as the starting
values. The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s.start">s.start</code></td>
<td>
<p>starting values for the support parameter, <code class="reqn">s_ijk</code>.
If <code>s.start</code> is set to a scalar, the starting values for the
support parameter of all respondents and all questions will be the
scalar.
If <code>s.start</code> is set to a matrix, it should have the same number
of rows as the number of observations and the same number of columns
as the number of questions. Also, the value should be zero for the
control condition.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_beta.start">beta.start</code></td>
<td>
<p>starting values for the question related parameters,
<code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.
If <code>beta.start</code> is set to a scalar, the starting values for the
support parameter of all respondents and all questions will be the
scalar.
If <code>beta.start</code> is set to a matrix, the number
of rows should be the number of questions and the number of columns
should be 2.
The first column
will be the starting values for <code class="reqn">\alpha_j</code> and the second column
will be the starting values for <code class="reqn">\beta_j</code>.
Since the parameter values are constrained to be positive, the starting
values should be also positive.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_tau.start">tau.start</code></td>
<td>
<p>starting values for the cut points in the response
model. If <code>NA</code>, the function generates the starting values
so that each interval between the cut points is 0.5.
If <code>tau.start</code> is set to a matrix, the number of rows should be
the same as the number of questions and the number of columns should
be the maximum value of the number of categories in the responses.
The first cut point for each question should be set to 0 while the
last one set to the previous cut point plus 1000.
The default is <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_lambda.start">lambda.start</code></td>
<td>
<p>starting values for the coefficients in the
support parameter model, <code class="reqn">\lambda_jk</code>.
If <code>lambda.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>lambda.start</code> is set to a matrix, the number of rows should
be the number of the individual level covariates (plus the number of villages, if the model
is hierarchical),
and the number of columns should be the number of
endorsers (times the number of questions, if the model is with varying lambdas).
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_omega2.start">omega2.start</code></td>
<td>
<p>starting values for the variance of the support
parameters, <code class="reqn">\omega_{jk}^{2}</code>.
If set to a scalar, the starting values for
<code class="reqn">omega_{jk}^{2}</code> will be the diagonal matrix with
the diagonal elements set to the scalar.
If <code>omega2.start</code> is set to a matrix, the number of rows should
be the number of questions, 
while the number of columns should be the same as the number of
endorsers.
The default is <code>.1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_theta.start">theta.start</code></td>
<td>
<p>starting values for the means of the
<code class="reqn">\lambda_{jk}</code> for each endorser.
If <code>theta.start</code> is set to a scalar, the starting values for
all parameters will be the scalar.
If <code>theta.start</code> is set to a matrix, the number of rows should
be the number of endorsers and the number of columns should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_phi2.start">phi2.start</code></td>
<td>
<p>starting values for the covariance matrices of the
coefficients
of the support parameters, <code class="reqn">\Phi_{k}</code>.
<code class="reqn">\Phi_{k}</code> is assumed to be a diagonal matrix.
If <code>phi2.start</code> is set to a scalar, the starting values for
all covariance matrices will be the same diagonal matrix with the
diagonal elements set to the scalar.
If <code>phi2.start</code> is set to a vector, the length should be the
number of endorsers times the dimension of covariates.
The default is <code>.1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_kappa.start">kappa.start</code></td>
<td>
<p>starting values for the coefficients on village level covariates in the
support parameter model, <code class="reqn">\kappa_k</code>.
If <code>kappa.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>kappa.start</code> is set to a matrix, the number of rows should
be the number of the village level covariates,
and the number of columns should be the number of
endorsers (times the number of questions, if the varying-lambda
model is fitted).
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_psi2.start">psi2.start</code></td>
<td>
<p>starting values for the variance of the village random intercepts in the support
parameter model, <code class="reqn">\psi_{k}^{2}</code>.
If <code>psi2.start</code> is set to a scalar, the starting values for
<code class="reqn">\psi_{k}^{2}</code> will be the diagonal matrix with
the diagonal elements set to the scalar.
If <code>psi2.start</code> is set to a vector, its length should
be the number of endorsers (times the number of questions, if the
varying-lambda model is fitted).
The default is <code>.1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_delta.start">delta.start</code></td>
<td>
<p>starting values for the coefficients on individual level covariates in the ideal
point model. Will be used only if <code>covariates = TRUE</code>.
If <code>delta.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>delta.start</code> is set to a vector, the length should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_zeta.start">zeta.start</code></td>
<td>
<p>starting values for the coefficients on village level covariates in the ideal
point model. Will be used only if <code>covariates = TRUE</code>.
If <code>zeta.start</code> is set to a scalar, the starting values for
all coefficients will be the scalar.
If <code>zeta.start</code> is set to a vector, the length should be the
dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_rho2.start">rho2.start</code></td>
<td>
<p>numeric. starting values for the variance of the village random intercepts in the ideal point
model, <code class="reqn">\rho^{2}</code>. The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.beta">mu.beta</code></td>
<td>
<p>the mean of the independent Normal prior on the
question related parameters. Can be either a scalar or a matrix of
dimension the number of questions times 2.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.x">mu.x</code></td>
<td>
<p>the mean of the independent Normal prior on the
question related parameters. Can be either a scalar or a vector of
the same length as the number of observations.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.theta">mu.theta</code></td>
<td>
<p>the mean of the independent Normal prior on the
mean of the coefficients in the support parameter model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.kappa">mu.kappa</code></td>
<td>
<p>the mean of the independent Normal prior on the
coefficients of village level covariates. Can be either a scalar or a matrix of
dimension the number of covariates times the number of endorsers.
If auxiliary information is included, the value of <code>mu.kappa</code> 
will be computed for each group such that the prior probability of
the support parameter taking a positive value is equal to the known
value of <code>h</code>.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.delta">mu.delta</code></td>
<td>
<p>the mean of the independent Normal prior on the
the coefficients in the ideal point model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mu.zeta">mu.zeta</code></td>
<td>
<p>the mean of the independent Normal prior on the
the coefficients of village level covariates in the ideal point model.
Can be either a scalar or a vector of
the same length as the dimension of covariates.
The default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.beta">precision.beta</code></td>
<td>
<p>the precisions (inverse variances) of the
independent Normal prior on the
question related parameters. Can be either a scalar or
a 2 <code class="reqn">\times</code> 2 diagonal matrix.
The default is <code>0.04</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.x">precision.x</code></td>
<td>
<p>scalar. The known precision of the
independent Normal distribution on the
ideal points.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.theta">precision.theta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the means of the coefficients
in the support parameter model. Can be either a scalar or
a vector of the same length as the dimension of covariates.
The default is <code>0.04</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.kappa">precision.kappa</code></td>
<td>
<p>the precisions of the
independent Normal prior on the coefficients of village level covariates
in the support parameter model. Can be either a scalar or
a vector of the same length as the dimension of covariates.
If auxiliary information is included, the value of <code>precision.kappa</code> 
will be fixed to <code>100000</code>.
The default is <code>0.04</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.delta">precision.delta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the the coefficients
in the ideal point model. Can be either a scalar or
a square matrix of the same dimension as the dimension of
covariates.
The default is <code>0.04</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_precision.zeta">precision.zeta</code></td>
<td>
<p>the precisions of the
independent Normal prior on the the coefficients of village level covariates
in the ideal point model. Can be either a scalar or
a square matrix of the same dimension as the dimension of
covariates.
The default is <code>0.04</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s0.omega2">s0.omega2</code></td>
<td>
<p>scalar. The scale of the independent scaled
inverse- chi-squared    
prior for the variance parameter in the support parameter model.
If auxiliary information is included, the value of <code>s0.omega2</code> 
will be fixed to the default.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_nu0.omega2">nu0.omega2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled inverse-chi-squared    
prior for the variance parameter in the support parameter model.
If auxiliary information is included, the value of <code>nu0.omega2</code> 
will be fixed to the default.
The default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s0.phi2">s0.phi2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the coefficients in
the support parameter model.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_nu0.phi2">nu0.phi2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the coefficients in
the support parameter model.
The default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s0.psi2">s0.psi2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the village random intercepts in
the support parameter model.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_nu0.psi2">nu0.psi2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the village random intercepts in
the support parameter model.
The default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s0.sig2">s0.sig2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variance parameter in
the ideal point model.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_nu0.sig2">nu0.sig2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variance parameter in the ideal point model.
The default is <code>400</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s0.rho2">s0.rho2</code></td>
<td>
<p>scalar. The scale of the independent
scaled inverse-chi-squared
prior for the variances of the village random intercepts in
the ideal point model.
The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_nu0.rho2">nu0.rho2</code></td>
<td>
<p>scalar. The degrees of freedom of the independent
scaled
inverse-chi-squared
prior for the variances of the village random intercepts in
the ideal point model.
The default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mcmc">MCMC</code></td>
<td>
<p>the number of iterations for the sampler. The default is
<code>20000</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_burn">burn</code></td>
<td>
<p>the number of burn-in iterations for the sampler. The
default is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_thin">thin</code></td>
<td>
<p>the thinning interval used in the simulation. The default
is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_mh">mh</code></td>
<td>
<p>logical. If <code>TRUE</code>, the Metropolis-Hastings algorithm
is used to sample the cut points in the response model. The default is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_prop">prop</code></td>
<td>
<p>a positive number or a vector consisting of positive
numbers. The length of the vector should be the same as the number of
questions. This argument sets proposal variance for the
Metropolis-Hastings algorithm in sampling the cut points of the
response model. The default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="endorse_+3A_x.sd">x.sd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the standard deviation of the
ideal points in each draw will be stored. If <code>FALSE</code>, a sample of
the ideal points will be stored. <em>NOTE: Because storing a sample
takes an enormous amount of memory, this option should be
selected only if the chain is thinned heavily or the data have a small
number of observations.</em>
</p>
</td></tr>
<tr><td><code id="endorse_+3A_tau.out">tau.out</code></td>
<td>
<p>logical. A switch that determines whether or not to
store the cut points in the response model. The default is
<code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_s.out">s.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the support parameter for each
respondent and each question will be stored.
The default is <code>FALSE</code>. <em>NOTE: Because storing a sample
takes an enormous amount of memory, this option should be
selected only if the chain is thinned heavily or the data have a small
number of observations.</em>
</p>
</td></tr>
<tr><td><code id="endorse_+3A_omega2.out">omega2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variannce parameter of the support
parameter model will be stored.
The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_phi2.out">phi2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variannce parameter of the model
for the coefficients in the support parameter model will be stored.
The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_psi2.out">psi2.out</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variance of the village random intercepts 
in the support parameter model  will be stored.
The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_verbose">verbose</code></td>
<td>
<p>logical. A switch that determines whether or not to
print the progress of the chain and Metropolis acceptance ratios for
the cut points of the response model. The default is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_seed.store">seed.store</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the seed will be stored in order
to update the chain later.  The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_update">update</code></td>
<td>
<p>logical.  If <code>TURE</code>, the function is run to update a chain.
The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="endorse_+3A_update.start">update.start</code></td>
<td>
<p>list.  If the function is run to update a chain, the output
object of the previous run should be supplied.  The default is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model takes the following form:
</p>
<p>Consider an endorsement experiment where we wish to measure the level
of support for <code class="reqn">K</code> political
actors.  In the survey, respondents are asked whether or
not they support each of <code class="reqn">J</code> policies chosen by researchers.
Let <code class="reqn">Y_{ij}</code> represent respondent
<code class="reqn">i</code>'s answer to the survey question regarding policy <code class="reqn">j</code>.
Suppose that the response variable <code class="reqn">Y_{ij}</code> is the ordered factor
variable taking one of <code class="reqn">L_{j}</code> levels, i.e., <code class="reqn">Y_{ij} \in \{0,
    1, \dots,
  L_{j} - 1\}</code> where <code class="reqn">L_{j} &gt; 1</code>.  We assume that a greater value of
<code class="reqn">Y_{ij}</code>
indicates a greater level of support for policy <code class="reqn">j</code>.
We denote an <code class="reqn">M</code> dimensional vector of the observed
characteristics of respondent <code class="reqn">i</code> by <code class="reqn">Z_i</code>.
</p>
<p>In the experiment, we
randomly assign one of <code class="reqn">K</code> political actors as an endorser to
respondent <code class="reqn">i</code>'s question regarding policy <code class="reqn">j</code> and denote this
treatment variable by <code class="reqn">T_{ij} \in \{0,1,\dots,K\}</code>.  We use
<code class="reqn">T_{ij}=0</code> to represent the control observations where no
political endorsement is attached to the question. Alternatively, one
may use the endorsement by a neutral actor as the control group.
</p>
<p>The model for the response variable, <code class="reqn">Y_{ij}</code>, is given by,
</p>
<p style="text-align: center;"><code class="reqn">Y_{ij} = l \; {\rm if} \; \tau_{l} &lt; Y^{*}_{ij} \le
    \tau_{l + 1},
  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y^{*}_{ij} \; | \; T_{ij} = k \sim \mathcal{N}(- \alpha_{j} +
    \beta_{j} (x_{i} + s_{ijk}), \; I)
  </code>
</p>

<p>where <code class="reqn">l \in \{0, 1, \dots, L_{j} \}, \tau_{0} = -\infty &lt;
    \tau_{1} = 0 &lt; \tau_{2} &lt; \dots &lt; \tau_{L_{j}} = \infty</code>.
<code class="reqn">\beta_j</code>'s are assumed to be positive.
</p>
<p>The model for the support parameter, <code class="reqn">s_{ijk}</code>, is given by
if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(Z_i^{T} \lambda_{jk}, \; \omega_{jk}^2)
  </code>
</p>

<p>with covariates, and
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda_{jk}, \; \omega_{jk}^2),
  </code>
</p>

<p>without covariates, for <code class="reqn">j = 1, \dots, J, \; k = 1, \dots, K</code>,
and if <code class="reqn">T_{ij} = 0, \; s_{ijk} = 0</code>.
</p>
<p>The <code class="reqn">\lambda</code>'s in the support parameter model are modeled in the
following hierarchical manner,
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda_{jk} \sim \mathcal{N}(\theta_k, \; \Phi_k)
  </code>
</p>
  
<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>If you set <code>identical.lambda = FALSE</code> and <code>hierarchical = TRUE</code>,
the model for <code class="reqn">s_{ijk}</code> is if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda^{0}_{jk, village[i]} + Z_i^{T} \lambda_{jk}, \; \omega_{jk}^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{0}_{jk, village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \kappa_{jk}, \; \psi_{jk}^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code> and <code class="reqn">j = 1, \dots, J</code>.  In addition,
<code class="reqn">\lambda</code> and <code class="reqn">\kappa</code> are modeled in the following
hierarchical manner,
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{*}_{jk} \sim \mathcal{N}(\theta_k, \; \Phi_k)
  </code>
</p>
  
<p>for <code class="reqn">k = 1, \dots, K</code>, where <code class="reqn">\lambda^{*}_{jk} =
  (\lambda^{T}_{jk}, \kappa^{T}_{jk})^{T}</code>.
</p>
<p>If you set <code>identical.lambda = TRUE</code> and <code>hierarchical = TRUE</code>,
the model for <code class="reqn">s_{ijk}</code> is if <code class="reqn">T_{ij} \neq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    s_{ijk} \sim \mathcal{N}(\lambda^{0}_{k, village[i]} + Z_i^{T} \lambda_{k}, \; \omega_{k}^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda^{0}_{k, village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \kappa_{k}, \; \psi_{k}^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>If the covariates are included in the model, the model for the
ideal points is given by
</p>
<p style="text-align: center;"><code class="reqn">
    x_{i} \sim \mathcal{N}(Z_{i}^{T} \delta, \; \sigma_{x}^{2})
  </code>
</p>

<p>for <code class="reqn">i = 1, \dots, N</code> where <code class="reqn">\sigma_x^2</code> is a known prior
variance.
</p>
<p>If you set <code>hierarchical = TRUE</code>,
the model is
</p>
<p style="text-align: center;"><code class="reqn">
    x_{i} \sim \mathcal{N}(\delta^{0}_{village[i]} + Z_i^{T} \delta, \; \sigma^2)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \delta^{0}_{village[i]} \sim \mathcal{N}(V_{village[i]}^{T} \zeta, \; \rho^2)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>Finally, the following independent prior distributions are placed on
unknown parameters,
</p>
<p style="text-align: center;"><code class="reqn">
    \alpha_j \sim \mathcal{N}(\mu_\alpha, \; \sigma_\alpha^2)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \beta_j \sim \mathcal{TN}_{\beta_j &gt; 0}(\mu_\beta, \; \sigma_\beta^2)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \delta \sim \mathcal{N}(\mu_\delta, \; \Sigma_\delta),
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    \theta_k \sim \mathcal{N}(\mu_\theta, \; \Sigma_\theta)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    \omega_{jk}^2 \sim  {\rm Inv-}\chi^{2}(\nu_{\omega}^0, \;
    s_{\omega}^0)
  </code>
</p>

<p>for <code class="reqn">j = 1, \dots, J</code> and <code class="reqn">k = 1, \dots, K</code>, and
</p>
<p style="text-align: center;"><code class="reqn">  
    {\rm diag}(\Phi_k) \sim  {\rm Inv-}\chi^{2}(\nu_{\Phi}^0, \;
    s_{\Phi}^0)
  </code>
</p>

<p>for <code class="reqn">k = 1, \dots, K</code>, where <code class="reqn">\Phi_k</code> is assumed to be a
diagonal matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>"endorse"</code>, which is a list containing the following
elements:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>an <code>"mcmc"</code> object. A sample from the posterior distribution
of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>x.sd = TRUE</code>, a vector of the standard deviation of
the ideal points in each draw. If <code>x.sd = FALSE</code>, an mcmc
object that contains a sample from the posterior distribution of the
ideal points.
</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>If <code>s.out = TRUE</code>, an mcmc object that contains a sample
from the posterior distribution of <code class="reqn">s_{ijk}</code>.  Variable
names are:
</p>
<p><code>s(observation id)(question id)</code>.
</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>If <code>covariates = TRUE</code>, an mcmc object that contains
a sample from the posterior distribution of <code class="reqn">\delta</code>.
</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>If <code>tau.out = TRUE</code>, an mcmc object that contains a
sample from the posterior distribution of <code class="reqn">\tau</code>.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>an mcmc object. A sample from the posterior distribution
of <code class="reqn">\lambda</code>.  Variable names are:
</p>
<p><code>lambda(question id)(group id).(covariate id)</code>.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>an mcmc object. A sample from the posterior distribution
of <code class="reqn">\theta</code>.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>an mcmc object.
</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>an mcmc object.
</p>
</td></tr>
</table>
<p>Note that the posterior sample of all parameters are NOT
standardized. In making posterior inference, each parameter should be
divided by the standard deviation of x (in the default setting, it is
given as &quot;x&quot;) or by <code class="reqn">\sigma^2</code> (in the default setting, it
is given as &quot;sigma2&quot;).
</p>
<p>Also note that <code class="reqn">\alpha</code> and the intercept in
<code class="reqn">\delta</code> (or, if the model is hierarchical, the intercept
in <code class="reqn">\zeta</code>) are not identified.  Instead,
</p>
<p style="text-align: center;"><code class="reqn">  
    - \alpha + \beta * \delta_0
  </code>
</p>

<p>or, if the model is hierarchical,
</p>
<p style="text-align: center;"><code class="reqn">  
    - \alpha + \beta * \zeta_0
  </code>
</p>

<p>is identified after either of the above standardization, where
<code class="reqn">\delta_0</code> and <code class="reqn">\zeta_0</code> denote the
intercepts.
</p>
<p>When using the auxiliary data functionality, the following objects are included:
</p>
<table>
<tr><td><code>aux</code></td>
<td>
<p>logical value indicating whether estimation incorporates auxiliary moments
</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>integer count of the number of auxiliary moments
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan <a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>
</p>
<p>Kosuke Imai, Department of Government and Statistics, Harvard University
<a href="mailto:Imai@Harvard.Edu">Imai@Harvard.Edu</a>, <a href="https://imai.fas.harvard.edu">https://imai.fas.harvard.edu</a>
</p>


<h3>References</h3>

<p>Bullock, Will, Kosuke Imai, and Jacob N. Shapiro. (2011)
&ldquo;Statistical Analysis of Endorsement Experiments: Measuring
Support for Militant Groups in Pakistan,&rdquo; <em>Political Analysis</em>,
Vol. 19, No. 4 (Autumn), pp.363-384.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(pakistan)

Y &lt;- list(Q1 = c("Polio.a", "Polio.b", "Polio.c", "Polio.d", "Polio.e"),
          Q2 = c("FCR.a", "FCR.b", "FCR.c", "FCR.d", "FCR.e"),
          Q3 = c("Durand.a", "Durand.b", "Durand.c", "Durand.d",
                 "Durand.e"),
          Q4 = c("Curriculum.a", "Curriculum.b", "Curriculum.c",
                 "Curriculum.d", "Curriculum.e"))



## Varying-lambda non-hierarchical model without covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = FALSE,
                       covariates = FALSE, hierarchical = FALSE)

## Varying-lambda non-hierarchical model with covariates
indiv.covariates &lt;- formula( ~ female + rural)
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = FALSE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = FALSE)

## Common-lambda non-hierarchical model with covariates
indiv.covariates &lt;- formula( ~ female + rural)
endorse.out &lt;- endorse(Y = Y, data = pakistan, identical.lambda = TRUE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = FALSE)

## Varying-lambda hierarchical model without covariates
div.data &lt;- data.frame(division = sort(unique(pakistan$division)))
div.formula &lt;- formula(~ 1)
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = FALSE,
                       covariates = FALSE, hierarchical = TRUE,
                       formula.village = div.formula)

## Varying-lambda hierarchical model with covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = FALSE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = TRUE,
                       formula.village = div.formula)

## Common-lambda hierarchical model without covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = TRUE,
                       covariates = FALSE, hierarchical = TRUE,
                       formula.village = div.formula)

## Common-lambda hierarchical model with covariates
endorse.out &lt;- endorse(Y = Y, data = pakistan, data.village = div.data,
                       village = "division", identical.lambda = TRUE,
                       covariates = TRUE,
                       formula.indiv = indiv.covariates,
                       hierarchical = TRUE,
                       formula.village = div.formula)

## End(Not run)
</code></pre>

<hr>
<h2 id='endorse.plot'>
Descriptive Plot of Endorsement Experiment Data
</h2><span id='topic+endorse.plot'></span>

<h3>Description</h3>

<p>This function creates a descriptive plot for a question in an
endorsement experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endorse.plot(Y, data, scale, dk = 98, ra = 99, yaxis = NULL,
             col.seq = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endorse.plot_+3A_y">Y</code></td>
<td>
<p>a character vector. List of the variable names for the
responses to a question. Each variable name corresponds to each
treatment status.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_data">data</code></td>
<td>
<p>data frame containing the variables.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_scale">scale</code></td>
<td>
<p>an integer. The scale of the responses. The function
assumes that the responses are coded so that <code>1</code> indicates the
lowest support while the integer specified in this argument
represents the highest support.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_dk">dk</code></td>
<td>
<p>an integer indicating the value of the response variable
that is to be interpreted as &ldquo;Don't Know.&rdquo; Default is <code>98</code>.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_ra">ra</code></td>
<td>
<p>an integer indicating the value of the response variable
that is to be interpreted as &ldquo;Refused.&rdquo; Default is <code>99</code>.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_yaxis">yaxis</code></td>
<td>
<p>a character vector of the same length as <code>Y</code>. The
argument will be used for the label of the horizontal axis. The
order should be the same as <code>Y</code>.
</p>
</td></tr>
<tr><td><code id="endorse.plot_+3A_col.seq">col.seq</code></td>
<td>
<p>a vector of colors for the bars or bar components. By
default, a gradation of gray where the darkest indicates the highest
support level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A descriptive plot for the responses to a question.
</p>


<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan
<a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>.
</p>
<p>Kosuke Imai, Department of Government and Statistics, Harvard University
<a href="mailto:Imai@Harvard.Edu">Imai@Harvard.Edu</a>, <a href="https://imai.fas.harvard.edu/">https://imai.fas.harvard.edu/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pakistan)

Y &lt;- c("Polio.a", "Polio.b", "Polio.c", "Polio.d", "Polio.e")
yaxis &lt;- c("Control", "Kashmir", "Afghan", "Al-Qaida", "Tanzeems")

endorse.plot(Y = Y, data = pakistan, scale = 5)

</code></pre>

<hr>
<h2 id='GeoCount'>
Counting Incidents around Points
</h2><span id='topic+GeoCount'></span>

<h3>Description</h3>

<p>This function calculates the number of incidents (e.g., violent
events) within a specified distance around specified points (e.g.,
villages).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCount(x, y, distance, x.latitude = "latitude",
         x.longitude = "longitude", y.latitude = "latitude",
         y.longitude = "longitude")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCount_+3A_x">x</code></td>
<td>
<p>data frame containing the longitude and the latitude of points.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_y">y</code></td>
<td>
<p>data frame containing the longitude and the latitude of incidents.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_distance">distance</code></td>
<td>
<p>numeric. The distance from points in kilometers.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_x.latitude">x.latitude</code></td>
<td>
<p>character.  The variable name for the latitude in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_x.longitude">x.longitude</code></td>
<td>
<p>character.  The variable name for the longitude in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_y.latitude">y.latitude</code></td>
<td>
<p>character.  The variable name for the latitude in <code>y</code>.
</p>
</td></tr>
<tr><td><code id="GeoCount_+3A_y.longitude">y.longitude</code></td>
<td>
<p>character.  The variable name for the longitude in <code>y</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan
<a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>.
</p>

<hr>
<h2 id='GeoId'>
Getting Indices of Incidents around a specified point
</h2><span id='topic+GeoId'></span>

<h3>Description</h3>

<p>This function obtains the indices of incidents within a specified
distance around a specified point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoId(x, y, distance, x.latitude = "latitude",
      x.longitude = "longitude", y.latitude = "latitude",
      y.longitude = "longitude")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoId_+3A_x">x</code></td>
<td>
<p>data frame containing the longitude and the latitude of a
point.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_y">y</code></td>
<td>
<p>data frame containing the longitude and the latitude of
incidents.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_distance">distance</code></td>
<td>
<p>numeric. The distance from villages in kilometers.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_x.latitude">x.latitude</code></td>
<td>
<p>character.  The variable name for the latitude in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_x.longitude">x.longitude</code></td>
<td>
<p>character.  The variable name for the longitude in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_y.latitude">y.latitude</code></td>
<td>
<p>character.  The variable name for the latitude in <code>y</code>.
</p>
</td></tr>
<tr><td><code id="GeoId_+3A_y.longitude">y.longitude</code></td>
<td>
<p>character.  The variable name for the longitude in <code>y</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the indices of <code>y</code> that are within
<code>distance</code> kilometers around the point specified by <code>x</code>.  If
there are multiple observations in <code>x</code>, the first row is used as
the point.
</p>


<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan
<a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>.
</p>

<hr>
<h2 id='pakistan'>Pakistan Survey Experiment on Support for Militant Groups</h2><span id='topic+pakistan'></span>

<h3>Description</h3>

<p>This data set is a subset of the data from the endorsement experiment
conducted in Pakistan to study support for militant groups. The survey
was implemented by Fair et al. (2009). It is also used by Bullock et
al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pakistan)</code></pre>


<h3>Format</h3>

<p>A data frame containing 5212 observations.
The variables are:
</p>

<ul>
<li> <p><code>division</code>: division number.
</p>
</li>
<li> <p><code>edu</code>: education. 1 if &ldquo;illiterate&rdquo;; 2 if
&ldquo;primary&rdquo;; 3 if &ldquo;middle&rdquo;; 4 if &ldquo;matric&rdquo;; 5 if &ldquo;intermediate
(f.a/f.sc),&rdquo; &ldquo;graduate (b.a/b.sc.),&rdquo; or &ldquo;professionals (m.a /or
other professional degree).&rdquo;
</p>
</li>
<li> <p><code>inc</code>: approximate monthly income. 1 if less than 3000
rupees; 2 if 3000 to 10,000 rupees; 3 if 10,001 to 15,000 rupees; 4
if more than 15,000 rupees.
</p>
</li>
<li> <p><code>female</code>: 0 if male; 1 if female
</p>
</li>
<li> <p><code>rural</code>: 0 if rural; 1 if urban
</p>
</li>
<li> <p><code>Polio.a-e</code>: support for World Health Organization's plan of
universal polio vaccinations in Pakistan. 5 indicates the highest
support while 1 indicates the lowest support.
</p>
</li>
<li> <p><code>FCR.a-e</code>: support for the reform of the Frontier Crimes
Regulation (FCR) governing the tribal areas. 5 indicates the highest
support while 1 indicates the lowest support.
</p>
</li>
<li> <p><code>Durand.a-e</code>: support for using peace jirgas to resolve disputes
over the Afghan border, the Durand Line. 5 indicates the highest
support while 1 indicates the lowest support.
</p>
</li>
<li> <p><code>Curriculum.a-e</code>: support for the Government of Pakistan's plan
of curriculum reforms in religious schools or <em>madaris</em>. 5
indicates the highest
support while 1 indicates the lowest support.
</p>
</li></ul>

<p>For the response variables, endorsers are:
</p>

<ul>
<li> <p><code>varname.a</code>: control (no endorsement).
</p>
</li>
<li> <p><code>varname.b</code>: Pakistani militant groups in Kashmir.
</p>
</li>
<li> <p><code>varname.c</code>: Militants fighting in Afghanistan.
</p>
</li>
<li> <p><code>varname.d</code>: Al-Qaida.
</p>
</li>
<li> <p><code>varname.e</code>: Firqavarana Tanzeems.
</p>
</li></ul>



<h3>Source</h3>

<p>Bullock, Will, Kosuke Imai, and Jacob
N. Shapiro. 2011. Replication data
for: Statistical analysis of endorsement experiments: Measuring
support for militant groups in Pakistan. hdl:1902.1/14840. The
Dataverse Network.
</p>


<h3>References</h3>

<p>Bullock, Will, Kosuke Imai, and Jacob N. Shapiro. (2011)
&ldquo;Statistical Analysis of Endorsement Experiments: Measuring
Support for Militant Groups in Pakistan,&rdquo; <em>Political Analysis</em>,
Vol. 19, No. 4 (Autumn), pp.363-384.
</p>
<p>Fair, Christin C., Neil Malhotra, and Jacob N. Shapiro. (2009)
&ldquo;The Roots of Militancy: Explaining Support for Political
Violence in Pakistan,&rdquo; Working Paper, Princeton University.
</p>

<hr>
<h2 id='predict.endorse'>Predict Method for the Measurement Model of Political Support</h2><span id='topic+predict.endorse'></span>

<h3>Description</h3>

 
<p>Function to calculate predictions from a measurement model fitted to an
endorsement experiment data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'endorse'
predict(object, newdata, type = c("prob.support",
"linear.s"), standardize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="predict.endorse_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>"endorse"</code></p>
</td></tr>
<tr><td><code id="predict.endorse_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame containing data that will be used
to make predictions from. If omitted, the data used to fit the
regression are used.</p>
</td></tr>
<tr><td><code id="predict.endorse_+3A_type">type</code></td>
<td>
<p>the type of prediction required.  The default is on the
scale of the predicted probability of positive support; the
alternative <code>"linear.s"</code> is on the scale of <code class="reqn">s_{ijk}</code>.</p>
</td></tr>
<tr><td><code id="predict.endorse_+3A_standardize">standardize</code></td>
<td>
<p>logical switch indicating if the predicted values on
the scale of <code class="reqn">s_{ijk}</code> are standardized so that its variance is
one.</p>
</td></tr>
<tr><td><code id="predict.endorse_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.endorse</code> produces predicted support for political actors
from a fitted <code>"endorse"</code> object.  If <code>newdata</code> is omitted
the predictions are based on the date used for the fit.  Setting
<code>type</code> specifies the type of predictions.  The default is
<code>"prob.support"</code>, in which case the function computes the average
predicted probability of positive support:
</p>
<p style="text-align: center;"><code class="reqn">
    P(s_{ijk} &gt; 0 \mid Z_i, \; \lambda_{j}, \; \omega_{j}) =
    \Phi \left( \frac{ Z_i^{T} \lambda_{j} }{ \omega_{j} } \right)
  </code>
</p>

<p>for each political group <code class="reqn">k</code>. If <code>type</code> is set to be
<code>"linear.s"</code>, the output is the predicted mean of support
parameters:
</p>
<p style="text-align: center;"><code class="reqn">
    E(s_{ijk} \mid Z_i, \; \lambda_{j}) = Z_i^{T} \lambda_{j}.
  </code>
</p>

<p>If the logical <code>standardize</code> is <code>TRUE</code>, the predicted mean
of support is standardized by dividing by <code class="reqn">\omega_j</code>.
</p>


<h3>Value</h3>

<p>A <code>"mcmc"</code> object for predicted values.
</p>


<h3>Author(s)</h3>

<p>Yuki Shiraito, Department of Political Science, University of Michigan
<a href="mailto:shiraito@umich.edu">shiraito@umich.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endorse">endorse</a></code> for model fitting</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
