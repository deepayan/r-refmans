<!DOCTYPE html><html><head><title>Help for package eventstream</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eventstream}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#extract_event_ftrs'><p>Extracts events from a data stream and computes event features.</p></a></li>
<li><a href='#gen_stream'><p>Generates a two dimensional data stream containing events of two classes.</p></a></li>
<li><a href='#get_clusters'><p>Extracts events from a two-dimensional data stream</p></a></li>
<li><a href='#get_clusters_3d'><p>Extracts events from a three-dimensional data stream</p></a></li>
<li><a href='#get_features'><p>Computes event-features</p></a></li>
<li><a href='#get_features_3d'><p>Computes event-features</p></a></li>
<li><a href='#NO2_2010'><p>A dataset containing NO2 data for 2010</p></a></li>
<li><a href='#NO2_2011'><p>A dataset containing NO2 data for 2011</p></a></li>
<li><a href='#NO2_2012'><p>A dataset containing NO2 data for 2012</p></a></li>
<li><a href='#NO2_2013'><p>A dataset containing NO2 data for 2013</p></a></li>
<li><a href='#NO2_2014'><p>A dataset containing NO2 data for 2014</p></a></li>
<li><a href='#NO2_2015'><p>A dataset containing NO2 data for 2015</p></a></li>
<li><a href='#NO2_2016'><p>A dataset containing NO2 data for 2016</p></a></li>
<li><a href='#NO2_2017'><p>A dataset containing NO2 data for 2017</p></a></li>
<li><a href='#NO2_2018'><p>A dataset containing NO2 data for 2018</p></a></li>
<li><a href='#NO2_2019'><p>A dataset containing NO2 data for 2019</p></a></li>
<li><a href='#predict_tdl'><p>Prediction with incomplete-event-classifier</p></a></li>
<li><a href='#real_details'><p>A dataset containing the details of class A events in the dataset real_stream.</p></a></li>
<li><a href='#real_stream'><p>A data stream from a real world application</p></a></li>
<li><a href='#spline_stats'><p>Computes background quantities using splines</p></a></li>
<li><a href='#stats_3d'><p>Computes mean and standard deviation</p></a></li>
<li><a href='#stream_from_files'><p>Generates a two dimensional data stream from data files in a given folder.</p></a></li>
<li><a href='#td_logistic'><p>Classification with incomplete-event-classifier</p></a></li>
<li><a href='#tune_cpdbee_2D'><p>Tunes 2D event detection using labeled data</p></a></li>
<li><a href='#tune_cpdbee_3D'><p>Tunes 3D event detection using labeled data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Streaming Events and their Early Classification</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sevvandi Kandanaarachchi &lt;sevvandik@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements event extraction and early classification of events in data streams in R. 
    It has the functionality to generate 2-dimensional data streams with events belonging to 
    2 classes. These events can be extracted and features computed. The event features extracted
    from incomplete-events can be classified using a partial-observations-classifier 
    (Kandanaarachchi et al. 2018) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0236331">doi:10.1371/journal.pone.0236331</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, tensorA, glmnet, dbscan, MASS, changepoint, dplyr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sevvandi.github.io/eventstream/index.html">https://sevvandi.github.io/eventstream/index.html</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-16 07:18:24 UTC; sevva</td>
</tr>
<tr>
<td>Author:</td>
<td>Sevvandi Kandanaarachchi
    <a href="https://orcid.org/0000-0002-0337-0395"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-16 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='extract_event_ftrs'>Extracts events from a data stream and computes event features.</h2><span id='topic+extract_event_ftrs'></span>

<h3>Description</h3>

<p>This function extracts events from a 2D or 3D data stream and computes a set of 30 features for 2D streams and 13 features for 3D streams, by using a moving window. 2D data streams with class labels can be generated by using the function <code>gen_stream</code>. To get the class labels of the extracted events for the supervised setting, the event position is matched with the <code>details</code> of the events, which is part of the output of the <code>gen_stream</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_event_ftrs(
  stream,
  supervised = FALSE,
  details = NULL,
  win_size = 200,
  step_size = 20,
  thres = 0.95,
  folder = NULL,
  vis = FALSE,
  tt = 10,
  epsilon = 5,
  miniPts = 10,
  rolling = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_event_ftrs_+3A_stream">stream</code></td>
<td>
<p>A data stream. This can be the output of either the <code>gen_stream</code> function or the <code>stream_from_files</code> function.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_supervised">supervised</code></td>
<td>
<p>If <code>TRUE</code>, event class labels need to be given in <code>details</code>.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_details">details</code></td>
<td>
<p>Event details. This is also an output of the <code>gen_stream</code> function. Event details are used to get the class labels of the extracted events, by matching the position.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_win_size">win_size</code></td>
<td>
<p>The window length of the moving window model, default is set to <code>200</code>.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_step_size">step_size</code></td>
<td>
<p>The window is moved by the <code>step_size</code>, default is <code>20</code>.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_thres">thres</code></td>
<td>
<p>The cut-off quantile. Default is set to <code>0.95</code>. Values greater than the quantile will be clustered. The rest is not clustered.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_folder">folder</code></td>
<td>
<p>If set to a local folder, this is where the jpegs of window data and extracted events are saved for a 2D data stream.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_vis">vis</code></td>
<td>
<p>If <code>TRUE</code>, the window data and the extracted events are plotted for a 2D data stream.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_tt">tt</code></td>
<td>
<p>Related to event ages. For example if <code>tt=10</code> then the event ages are <code>10, 20, 30</code> and <code>40</code>.</p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_epsilon">epsilon</code></td>
<td>
<p>The <code>eps</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_minipts">miniPts</code></td>
<td>
<p>The <code>minPts</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
<tr><td><code id="extract_event_ftrs_+3A_rolling">rolling</code></td>
<td>
<p>This parameter is set to <code>TRUE</code> if rolling windows are considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Nx22x4</code> array  is returned for 2D data streams and an <code>Nx13x4</code> array for 3D data streams. Here <code>N</code> is the total number of  events extracted from all windows. The second dimension has <code>m</code> features and the class label for the <code>supervised</code> setting.  The third dimension has <code>4</code> different event ages : <code>tt, 2tt, 3tt, 4tt</code>.
For example, the element at <code>[10,6,3]</code> has the 6th feature, of the 10th extracted event when the age of the event is <code>3tt</code>. The features for 2D streams are listed below. For 3D streams the features <code>cluster_id, pixels, length, width, height, total_value, l2w_ratio, centroid_x, centroid_y, centroid_z, mean, std_dev</code> and <code>sd_from_global_mean</code> are computed.
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>
<p>An identification number for each event.</p>
</td></tr>
<tr><td><code>pixels</code></td>
<td>
<p>The number of pixels of each event.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>The length of the event.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>The width of the event.</p>
</td></tr>
<tr><td><code>total_value</code></td>
<td>
<p>The total value of the pixels.</p>
</td></tr>
<tr><td><code>l2w_ratio</code></td>
<td>
<p>Length to width ratio of event.</p>
</td></tr>
<tr><td><code>centroid_x</code></td>
<td>
<p>x coordinate of event centroid.</p>
</td></tr>
<tr><td><code>centroid_y</code></td>
<td>
<p>y coordinate of event centroid.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean value of event pixels.</p>
</td></tr>
<tr><td><code>std_dev</code></td>
<td>
<p>Standard deviation of event pixels.</p>
</td></tr>
<tr><td><code>avg_slope</code></td>
<td>
<p>The slope of an <code>lm</code> object fitted to the event pixels.</p>
</td></tr>
<tr><td><code>quad_1</code></td>
<td>
<p>The linear coefficient of  a second order polynomial fitted to event pixels using <code>lm</code>. </p>
</td></tr>
<tr><td><code>quad_2</code></td>
<td>
<p>The quadratic coefficient of a second order polynomial fitted to event pixels using <code>lm</code>.</p>
</td></tr>
<tr><td><code>2sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 2 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>3sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 3 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>4sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 4 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>5iqr_from_median</code></td>
<td>
<p>A small portion of each window and its column medians and column IQRs are used to construct two smoothing splines: a median spline and an IQR spline. The value of the median smoothing spline at each event centroid is used as the local median for that event. Similarly, the value of the IQR smoothing spline at each event centroid is used as the local IQR for that event. This feature gives the proportion of event pixels/cells  that has values greater than 5 local IQRs from the local median.</p>
</td></tr>
<tr><td><code>6iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 6 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>7iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 7 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>8iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 8 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>iqr_from_median</code></td>
<td>
<p>Let us denote the 75th percentile of the event pixels value by <code>x</code>. How many local IQRs is <code>x</code> is away from the local median? Both local IQR and local median are computed using splines. That value is given by this feature. </p>
</td></tr>
<tr><td><code>sd_from_mean</code></td>
<td>
<p>Let us denote the 80th percentile of the event pixels value by <code>x</code>. How many global standard deviations is <code>x</code> is away from the global mean? Here both global values are computed from window data. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 2D data stream example
out &lt;- gen_stream(1, sd=15)
zz &lt;- as.matrix(out$data)
features &lt;- extract_event_ftrs(zz, supervised=TRUE, details = out$details)
features

# 3D data stream example
set.seed(1)
arr &lt;- array(rnorm(12000),dim=c(40,25,30))
arr[25:33,12:20, 20:23] &lt;- 10
# getting events
ftrs &lt;- extract_event_ftrs(arr, supervised=FALSE, win_size=10, step_size = 2, tt=2, thres=0.985)
ftrs

</code></pre>

<hr>
<h2 id='gen_stream'>Generates a two dimensional data stream containing events of two classes.</h2><span id='topic+gen_stream'></span>

<h3>Description</h3>

<p>This function generates a two-dimensional data stream containing events of two classes. The data stream can be saved as separate files with images by specifying the argument <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_stream(
  n,
  folder = NULL,
  sd = 1,
  vis = FALSE,
  muAB = c(4, 3),
  sdAB = c(2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_stream_+3A_n">n</code></td>
<td>
<p>The number of files to generate. Each file consists of a 350x250 data matrix.</p>
</td></tr>
<tr><td><code id="gen_stream_+3A_folder">folder</code></td>
<td>
<p>If this is set to a local folder, the data matrices are saved in <code>folder/data</code>, the images are saved in <code>folder/pics</code> and the event details are saved in <code>folder/summary</code>.  The event details are needed to obtain the class labels of events, when event extraction is done.</p>
</td></tr>
<tr><td><code id="gen_stream_+3A_sd">sd</code></td>
<td>
<p>This specifies the seed.</p>
</td></tr>
<tr><td><code id="gen_stream_+3A_vis">vis</code></td>
<td>
<p>If <code>TRUE</code>, the images are plotted.</p>
</td></tr>
<tr><td><code id="gen_stream_+3A_muab">muAB</code></td>
<td>
<p>The starting event pixels of class A and B events are normally distributed with mean values specified by <code>muAB</code>. The default is <code>c(4,3)</code>.</p>
</td></tr>
<tr><td><code id="gen_stream_+3A_sdab">sdAB</code></td>
<td>
<p>The starting standard deviations of class A and B events. Default set to <code>c(2,3)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are events of two classes in the data matrices : A and B.  Events of class A have only one shape while events of class B have three different shapes, including class A's shape. This was motivated from a real world example. The details of events of each class are given below.
</p>

<table>
<tr>
 <td style="text-align: left;">
Feature </td><td style="text-align: right;"> class A   </td><td style="text-align: right;"> class B </td>
</tr>
<tr>
 <td style="text-align: left;">
Starting cell/pixel values </td><td style="text-align: right;"> <code>N(4,2)</code> </td><td style="text-align: right;"> <code>N(3,3)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Ending cell/pixel values  </td><td style="text-align: right;"> <code>N(8,2)</code>  </td><td style="text-align: right;"> <code>N(5,3)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum age of event - shape 1 </td><td style="text-align: right;"> <code>U(20,30)</code> </td><td style="text-align: right;"> <code>U(20,30)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum age of event - shape 2  </td><td style="text-align: right;"> <code>NA</code>  </td><td style="text-align: right;"> <code>U(100,150)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum age of event - shape 3  </td><td style="text-align: right;"> <code>NA</code> </td><td style="text-align: right;"> <code>U(100,150)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum width of event - shape 1 </td><td style="text-align: right;"> <code>U(20,26)</code> </td><td style="text-align: right;"> <code>U(20,26)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum width of event - shape 2  </td><td style="text-align: right;"> <code>NA</code>  </td><td style="text-align: right;"> <code>U(30,38)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Maximum width of event - shape 3  </td><td style="text-align: right;"> <code>NA</code> </td><td style="text-align: right;"> <code>U(50,58)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A list with following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The data stream returned as a data frame.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>A data frame containing the details of the events: their positions, class labels, etc.. .  This is needed for identifying class labels of events during event extraction.</p>
</td></tr>
<tr><td><code>eventlabs</code></td>
<td>
<p>A matrix with 1 at event locations and 0 elsewhere. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stream_from_files">stream_from_files</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gen_stream(1, sd=15)
zz &lt;- as.matrix(out$data)
image(1:nrow(zz), 1:ncol(zz),zz, xlab="Time", ylab="Location")

</code></pre>

<hr>
<h2 id='get_clusters'>Extracts events from a two-dimensional data stream</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p>This function extracts events from a two-dimensional (1 spatial x 1 time) data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(
  dat,
  filename = NULL,
  thres = 0.95,
  vis = FALSE,
  epsilon = 5,
  miniPts = 10,
  rolling = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clusters_+3A_dat">dat</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_filename">filename</code></td>
<td>
<p>If set, the figure of extracted events are saved in this name. The <code>filename</code> needs to include the correct folder and file name.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_thres">thres</code></td>
<td>
<p>The cut-off quantile. Default is set to <code>0.95</code>. Values greater than the quantile will be clustered. The rest is not clustered.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_vis">vis</code></td>
<td>
<p>If <code>TRUE</code>, the window data and the extracted events are plotted for a 2D data stream.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_epsilon">epsilon</code></td>
<td>
<p>The <code>eps</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
<tr><td><code id="get_clusters_+3A_minipts">miniPts</code></td>
<td>
<p>The <code>minPts</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
<tr><td><code id="get_clusters_+3A_rolling">rolling</code></td>
<td>
<p>This parameter is set to <code>TRUE</code> if rolling windows are considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>The cluster assignment according to DBSCAN output.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data of this cluster assignment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gen_stream(2, sd=15)
zz &lt;- as.matrix(out$data)
clst &lt;- get_clusters(zz, vis=TRUE)

</code></pre>

<hr>
<h2 id='get_clusters_3d'>Extracts events from a three-dimensional data stream</h2><span id='topic+get_clusters_3d'></span>

<h3>Description</h3>

<p>This function extracts events from a three-dimensional (2D spatial x 1D time) data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters_3d(dat, thres = 0.95, epsilon = 3, miniPts = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clusters_3d_+3A_dat">dat</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="get_clusters_3d_+3A_thres">thres</code></td>
<td>
<p>The cut-off quantile. Default is set to <code>0.95</code>. Values greater than the quantile will be clustered. The rest is not clustered.</p>
</td></tr>
<tr><td><code id="get_clusters_3d_+3A_epsilon">epsilon</code></td>
<td>
<p>The <code>eps</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
<tr><td><code id="get_clusters_3d_+3A_minipts">miniPts</code></td>
<td>
<p>The <code>minPts</code> parameter in <code>dbscan</code> function in the package <code>dbscan</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>The cluster assignment according to DBSCAN output.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data of this cluster assignment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
arr &lt;- array(rnorm(12000),dim=c(40,25,30))
arr[25:33,12:20, 20:23] &lt;- 10
# getting events
out &lt;- get_clusters_3d(arr, thres=0.985)
# plots
oldpar &lt;- par(mfrow=c(1,3))
plot(out$data[,c(1,2)], xlab="x", ylab="y", col=as.factor(out$clusters$cluster))
plot(out$data[,c(1,3)], xlab="x", ylab="z",col=as.factor(out$clusters$cluster))
plot(out$data[,c(2,3)], xlab="y", ylab="z",col=as.factor(out$clusters$cluster))
par(oldpar)
</code></pre>

<hr>
<h2 id='get_features'>Computes event-features</h2><span id='topic+get_features'></span>

<h3>Description</h3>

<p>This function computes event features of 2D events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_features(
  dat.xyz,
  res.cluster,
  normal.stats.splines,
  win_size = 200,
  tt = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_features_+3A_dat.xyz">dat.xyz</code></td>
<td>
<p>The data in a cluster friendly format. The first two columns have <code>y</code> and <code>x</code> positions with the third column having the pixel value of that position.</p>
</td></tr>
<tr><td><code id="get_features_+3A_res.cluster">res.cluster</code></td>
<td>
<p>Cluster details from <code>dbscan</code>.</p>
</td></tr>
<tr><td><code id="get_features_+3A_normal.stats.splines">normal.stats.splines</code></td>
<td>
<p>The background statistics, output from <code><a href="#topic+spline_stats">spline_stats</a></code>.</p>
</td></tr>
<tr><td><code id="get_features_+3A_win_size">win_size</code></td>
<td>
<p>The window length of the moving window model, default is set to <code>200</code>.</p>
</td></tr>
<tr><td><code id="get_features_+3A_tt">tt</code></td>
<td>
<p>Related to event ages. For example if <code>tt=10</code> then the event ages are <code>10, 20, 30</code> and <code>40</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Nx22x4</code> array  is returned for 2D data streams and an <code>Nx13x4</code> array for 3D data streams. Here <code>N</code> is the total number of  events extracted from all windows. The second dimension has <code>m</code> features and the class label for the <code>supervised</code> setting.  The third dimension has <code>4</code> different event ages : <code>tt, 2tt, 3tt, 4tt</code>.
For example, the element at <code>[10,6,3]</code> has the 6th feature, of the 10th extracted event when the age of the event is <code>3tt</code>. The features for 2D streams are listed below. For 3D streams the features <code>cluster_id, pixels, length, width, height, total_value, l2w_ratio, centroid_x, centroid_y, centroid_z, mean, std_dev</code> and <code>sd_from_global_mean</code> are computed.
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>
<p>An identification number for each event.</p>
</td></tr>
<tr><td><code>pixels</code></td>
<td>
<p>The number of pixels of each event.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>The length of the event.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>The width of the event.</p>
</td></tr>
<tr><td><code>total_value</code></td>
<td>
<p>The total value of the pixels.</p>
</td></tr>
<tr><td><code>l2w_ratio</code></td>
<td>
<p>Length to width ratio of event.</p>
</td></tr>
<tr><td><code>centroid_x</code></td>
<td>
<p>x coordinate of event centroid.</p>
</td></tr>
<tr><td><code>centroid_y</code></td>
<td>
<p>y coordinate of event centroid.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean value of event pixels.</p>
</td></tr>
<tr><td><code>std_dev</code></td>
<td>
<p>Standard deviation of event pixels.</p>
</td></tr>
<tr><td><code>avg_slope</code></td>
<td>
<p>The slope of an <code>lm</code> object fitted to the event pixels.</p>
</td></tr>
<tr><td><code>quad_1</code></td>
<td>
<p>The linear coefficient of  a second order polynomial fitted to event pixels using <code>lm</code>. </p>
</td></tr>
<tr><td><code>quad_2</code></td>
<td>
<p>The quadratic coefficient of a second order polynomial fitted to event pixels using <code>lm</code>.</p>
</td></tr>
<tr><td><code>2sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 2 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>3sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 3 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>4sd_from_mean</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 4 global standard deviations from the global mean of the window.</p>
</td></tr>
<tr><td><code>5iqr_from_median</code></td>
<td>
<p>A small portion of each window and its column medians and column IQRs are used to construct two smoothing splines: a median spline and an IQR spline. The value of the median smoothing spline at each event centroid is used as the local median for that event. Similarly, the value of the IQR smoothing spline at each event centroid is used as the local IQR for that event. This feature gives the proportion of event pixels/cells  that has values greater than 5 local IQRs from the local median.</p>
</td></tr>
<tr><td><code>6iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 6 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>7iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 7 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>8iqr_from_median</code></td>
<td>
<p>The proportion of event pixels/cells that has values greater than 8 local IQRs from the local median computed using splines.</p>
</td></tr>
<tr><td><code>iqr_from_median</code></td>
<td>
<p>Let us denote the 75th percentile of the event pixels value by <code>x</code>. How many local IQRs is <code>x</code> is away from the local median? Both local IQR and local median are computed using splines. That value is given by this feature. </p>
</td></tr>
<tr><td><code>sd_from_mean</code></td>
<td>
<p>Let us denote the 80th percentile of the event pixels value by <code>x</code>. How many global standard deviations is <code>x</code> is away from the global mean? Here both global values are computed from window data. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gen_stream(1, sd=15)
zz &lt;- as.matrix(out$data)
clst &lt;- get_clusters(zz, vis=TRUE)
sstats &lt;- spline_stats(zz[1:100,])
ftrs &lt;- get_features(clst$data, clst$clusters$cluster, sstats)
</code></pre>

<hr>
<h2 id='get_features_3d'>Computes event-features</h2><span id='topic+get_features_3d'></span>

<h3>Description</h3>

<p>This function computes event features of 3D events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_features_3d(dat.xyz, res.cluster, normal.stats, win_size, tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_features_3d_+3A_dat.xyz">dat.xyz</code></td>
<td>
<p>The data in a cluster friendly format. The first three columns have <code>t</code>,<code>x</code> and <code>y</code> positions with the fourth column having the pixel value of that position.</p>
</td></tr>
<tr><td><code id="get_features_3d_+3A_res.cluster">res.cluster</code></td>
<td>
<p>Cluster details from <code>dbscan</code>.</p>
</td></tr>
<tr><td><code id="get_features_3d_+3A_normal.stats">normal.stats</code></td>
<td>
<p>The background statistics, output from <code><a href="#topic+stats_3d">stats_3d</a></code>.</p>
</td></tr>
<tr><td><code id="get_features_3d_+3A_win_size">win_size</code></td>
<td>
<p>The window length of the moving window model.</p>
</td></tr>
<tr><td><code id="get_features_3d_+3A_tt">tt</code></td>
<td>
<p>Related to event ages. For example if <code>tt=10</code> then the event ages are <code>10, 20, 30</code> and <code>40</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Nx22x4</code> array  is returned. Here <code>N</code> is the total number of  events extracted in all windows. The second dimension has <code>30</code> features and the class label for the <code>supervised</code> setting.  The third dimension has <code>4</code> different event ages : <code>tt, 2tt, 3tt, 4tt</code>.
For example, the element at <code>[10,6,3]</code> has the 6th feature,   of the 10th extracted event when the age of the event is <code>3tt</code>. The features are listed below:
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>
<p>An identification number for each event.</p>
</td></tr>
<tr><td><code>pixels</code></td>
<td>
<p>The number of pixels of each event.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>The length of the event.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>The width of the event.</p>
</td></tr>
<tr><td><code>total_value</code></td>
<td>
<p>The total value of the pixels.</p>
</td></tr>
<tr><td><code>l2w_ratio</code></td>
<td>
<p>Length to width ratio of event.</p>
</td></tr>
<tr><td><code>centroid_x</code></td>
<td>
<p>x coordinate of event centroid.</p>
</td></tr>
<tr><td><code>centroid_y</code></td>
<td>
<p>y coordinate of event centroid.</p>
</td></tr>
<tr><td><code>centroid_z</code></td>
<td>
<p>z coordinate of event centroid.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean value of event pixels.</p>
</td></tr>
<tr><td><code>std_dev</code></td>
<td>
<p>Standard deviation of event pixels.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of a linear model fitted to the event.</p>
</td></tr>
<tr><td><code>quad1</code></td>
<td>
<p>First coefficient of a quadratic model fitted to the event.</p>
</td></tr>
<tr><td><code>quad2</code></td>
<td>
<p>Second coefficient of a quadratic model fitted to the event.</p>
</td></tr>
<tr><td><code>sd_from_mean</code></td>
<td>
<p>Let us denote the 80th percentile of the event pixels value by <code>x</code>. How many  standard deviations is <code>x</code> is away from the mean? </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
arr &lt;- array(rnorm(12000),dim=c(40,25,30))
arr[25:33,12:20, 20:23] &lt;- 10
# getting events
out &lt;- get_clusters_3d(arr, thres=0.985)
mean_sd &lt;- stats_3d(arr[1:20,1:6,1:8])
ftrs &lt;- get_features_3d(out$data, out$cluster$cluster, mean_sd, win_size=40, tt=2 )
</code></pre>

<hr>
<h2 id='NO2_2010'>A dataset containing NO2 data for 2010</h2><span id='topic+NO2_2010'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2010
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2010
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2010[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2010[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2011'>A dataset containing NO2 data for 2011</h2><span id='topic+NO2_2011'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2011
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2011
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2011[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2011[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2012'>A dataset containing NO2 data for 2012</h2><span id='topic+NO2_2012'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2012
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2012
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2012[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2012[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2013'>A dataset containing NO2 data for 2013</h2><span id='topic+NO2_2013'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2013
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2013
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2013[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2013[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2014'>A dataset containing NO2 data for 2014</h2><span id='topic+NO2_2014'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2014
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2014
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2014[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2014[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2015'>A dataset containing NO2 data for 2015</h2><span id='topic+NO2_2015'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2015
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2015
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2015[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2015[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2016'>A dataset containing NO2 data for 2016</h2><span id='topic+NO2_2016'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2016
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2016
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2016[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2016[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2017'>A dataset containing NO2 data for 2017</h2><span id='topic+NO2_2017'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2017
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2017
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2017[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2017[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2018'>A dataset containing NO2 data for 2018</h2><span id='topic+NO2_2018'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2018
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2018
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2018[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2018[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='NO2_2019'>A dataset containing NO2 data for 2019</h2><span id='topic+NO2_2019'></span>

<h3>Description</h3>

<p>This dataset contains smoothed NO2 data from March to September 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NO2_2019
</code></pre>


<h3>Format</h3>

<p>An array of 4 x 179 x 360 dimensions.
</p>

<dl>
<dt>Dimension 1</dt><dd><p>Each <code>NO2_2019[t, , ]</code> contains NO2 data for a given month with <code>t=1</code> corresponding to March and <code>t=7</code> corresponding to September</p>
</dd>
<dt>Dimensions 2,3</dt><dd><p>Each <code>NO2_2019[ ,x, y]</code> contains NO2 concentration for a given position in the world map.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://neo.gsfc.nasa.gov/">https://neo.gsfc.nasa.gov/</a>
</p>

<hr>
<h2 id='predict_tdl'>Prediction with incomplete-event-classifier</h2><span id='topic+predict_tdl'></span>

<h3>Description</h3>

<p>Predicts using the incomplete-event-classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_tdl(model, t, X, probs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_tdl_+3A_model">model</code></td>
<td>
<p>The fitted incomplete-event-classifier.</p>
</td></tr>
<tr><td><code id="predict_tdl_+3A_t">t</code></td>
<td>
<p>The age of events.</p>
</td></tr>
<tr><td><code id="predict_tdl_+3A_x">X</code></td>
<td>
<p>The event features.</p>
</td></tr>
<tr><td><code id="predict_tdl_+3A_probs">probs</code></td>
<td>
<p>If <code>TRUE</code>, probabilities are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted values using the model object. If <code>prob = TRUE</code>, then the probabilities are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
N &lt;- 1000
t &lt;- sort(rep(1:10, N))
set.seed(821)
for(kk in 1:10){
  if(kk==1){
     X &lt;- seq(-11,9,length=N)
  }else{
     temp &lt;- seq((-11-kk+1),(9-kk+1),length=N)
     X &lt;- c(X,temp)
  }
}
real.a.0 &lt;- seq(2,20, by=2)
real.a.1 &lt;- rep(2,10)
Zstar &lt;-real.a.0[t] + real.a.1[t]*X + rlogis(N, scale=0.5)
Z &lt;- 1*(Zstar &gt; 0)

# Plot data for t=1 and t=8
oldpar &lt;- par(mfrow=c(1,2))
plot(X[t==1],Z[t==1], main="t=1 data")
abline(v=-1, lty=2)
plot(X[t==8],Z[t==8],main="t=8 data")
abline(v=-8, lty=2)
par(oldpar)

# Fit model
train_inds &lt;-  c()
for(i in 0:9){train_inds &lt;- c(train_inds , i*N + 2*(1:499))}
model_td &lt;- td_logistic(t[train_inds],X[train_inds],Z[train_inds])

# Prediction
preds &lt;- predict_tdl(model_td,t[-train_inds],X[-train_inds] )
sum(preds==Z[-train_inds])/length(preds)

</code></pre>

<hr>
<h2 id='real_details'>A dataset containing the details of class A events in the dataset real_stream.</h2><span id='topic+real_details'></span>

<h3>Description</h3>

<p>This dataset contains the location of class A events in the real_stream dataset. This can be used for classifying the events in real_stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real_details
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 3 variables:
</p>

<dl>
<dt>filename</dt><dd><p>Orignal file name</p>
</dd>
<dt>class</dt><dd><p>class of event, A or B</p>
</dd>
<dt>file_x</dt><dd><p><code>y</code> coordinate of file, relating to the location of event</p>
</dd>
<dt>file_y</dt><dd><p><code>x</code> coordinate of file, relating to the start time of event </p>
</dd>
<dt>stream_x</dt><dd><p><code>x</code> coordinate of <code>real_stream</code>, relating to the start time of event </p>
</dd>
<dt>stream_y</dt><dd><p><code>y</code> coordinate of <code>real_stream</code>, relating to the location of event</p>
</dd>
</dl>


<hr>
<h2 id='real_stream'>A data stream from a real world application</h2><span id='topic+real_stream'></span>

<h3>Description</h3>

<p>A dataset containing fibre optic cable signals.  A pulse is periodically sent through the cable and this results in a data matrix where each horizontal row (<code>real_stream[x, ]</code>) gives the strength of the signal at a fixed location <code>x</code>, and each vertical column (<code>real_stream[ ,t]</code>) gives the strength of the signal along the cable at a fixed time <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real_stream
</code></pre>


<h3>Format</h3>

<p>A matrix with 587 rows and 379 columns.
</p>

<hr>
<h2 id='spline_stats'>Computes background quantities using splines</h2><span id='topic+spline_stats'></span>

<h3>Description</h3>

<p>This function computes 4 splines, from median, iqr, mean and standard deviation values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_stats(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_stats_+3A_dat">dat</code></td>
<td>
<p>The data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>med.spline</code></td>
<td>
<p>The spline computed from the median values.</p>
</td></tr>
<tr><td><code>iqr.spline</code></td>
<td>
<p>The spline computed from IQR values.</p>
</td></tr>
<tr><td><code>mean.spline</code></td>
<td>
<p>The spline computed from mean values.</p>
</td></tr>
<tr><td><code>sd.spline</code></td>
<td>
<p>The spline computed from standard deviation values.</p>
</td></tr>
<tr><td><code>mean.dat</code></td>
<td>
<p>The mean of the data matrix.</p>
</td></tr>
<tr><td><code>sd.dat</code></td>
<td>
<p>The standard deviation of the data matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gen_stream(1, sd=15)
zz &lt;- as.matrix(out$data)
sstats &lt;- spline_stats(zz[1:100,])
oldpar &lt;- par(mfrow=c(2,1))
image(1:ncol(zz), 1:nrow(zz),t(zz), xlab="Location", ylab="Time" )
plot(sstats[[1]], type="l")
par(oldpar)       
</code></pre>

<hr>
<h2 id='stats_3d'>Computes mean and standard deviation</h2><span id='topic+stats_3d'></span>

<h3>Description</h3>

<p>This function is used for 3D event extraction and feature computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats_3d(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats_3d_+3A_dat">dat</code></td>
<td>
<p>The data array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>mean.dat</code></td>
<td>
<p>The mean of the data array</p>
</td></tr>
<tr><td><code>sd.dat</code></td>
<td>
<p>The standard deviation of the data array</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
arr &lt;- array(rnorm(12000),dim=c(40,25,30))
arr[25:33,12:20, 20:23] &lt;- 10
mean_sd &lt;- stats_3d(arr[1:20,1:6,1:8])
mean_sd
</code></pre>

<hr>
<h2 id='stream_from_files'>Generates a two dimensional data stream from data files in a given folder.</h2><span id='topic+stream_from_files'></span>

<h3>Description</h3>

<p>Generates a two dimensional data stream from data files in a given folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream_from_files(folder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_from_files_+3A_folder">folder</code></td>
<td>
<p>The folder with the data files.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gen_stream">gen_stream</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
folder &lt;- tempdir()
out &lt;- gen_stream(2, folder = folder)
stream &lt;- stream_from_files(paste(folder, "/data", sep=""))
dim(stream)
unlink(folder, recursive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='td_logistic'>Classification with incomplete-event-classifier</h2><span id='topic+td_logistic'></span>

<h3>Description</h3>

<p>This function does classification of incomplete events. The events grow with time. The input vector <code>t</code> denotes the age of the event. The classifier takes the growing event features, <code>X</code> and combines with a <code>L2</code> penalty for smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>td_logistic(
  t,
  X,
  Y,
  lambda = 1,
  scale = TRUE,
  num_bins = 4,
  quad = TRUE,
  interact = FALSE,
  logg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="td_logistic_+3A_t">t</code></td>
<td>
<p>The age of events.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_x">X</code></td>
<td>
<p>The event features.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_y">Y</code></td>
<td>
<p>The class labels. <code>Y</code> needs to be binary output.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_lambda">lambda</code></td>
<td>
<p>The penalty coefficient. Default is 1.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, each column of <code>X</code> is scaled to zero mean and standard deviation 1.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_num_bins">num_bins</code></td>
<td>
<p>The number of time slots to use.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_quad">quad</code></td>
<td>
<p>If <code>TRUE</code>, the squared attributes <code>X^2</code> are included.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_interact">interact</code></td>
<td>
<p>if <code>TRUE</code>, the most relevant interactions are included.</p>
</td></tr>
<tr><td><code id="td_logistic_+3A_logg">logg</code></td>
<td>
<p>If <code>TRUE</code> logarithms  of positive attributes will be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The parameters of the incomplete-event-classifier, after its fitted.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>The difference between the final two output values.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>If <code>scale=TRUE</code>, contains the mean and the standard deviation of each column of <code>X</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The age of events <code>t</code> is split into bins. This list element contains the   boundary values of the bins.</p>
</td></tr>
<tr><td><code>quad</code></td>
<td>
<p>The value of <code>quad</code> in arguments.</p>
</td></tr>
<tr><td><code>interact</code></td>
<td>
<p>The value of <code>interact</code> in arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict_tdl">predict_tdl</a></code> for prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
N &lt;- 1000
t &lt;- sort(rep(1:10, N))
set.seed(821)
for(kk in 1:10){
  if(kk==1){
     X &lt;- seq(-11,9,length=N)
  }else{
     temp &lt;- seq((-11-kk+1),(9-kk+1),length=N)
     X &lt;- c(X,temp)
  }
}
real.a.0 &lt;- seq(2,20, by=2)
real.a.1 &lt;- rep(2,10)
Zstar &lt;-real.a.0[t] + real.a.1[t]*X + rlogis(N, scale=0.5)
Z &lt;- 1*(Zstar &gt; 0)

# Plot data for t=1 and t=8
oldpar &lt;- par(mfrow=c(1,2))
plot(X[t==1],Z[t==1], main="t=1 data")
abline(v=-1, lty=2)
plot(X[t==8],Z[t==8],main="t=8 data")
abline(v=-8, lty=2)
par(oldpar) 

# Fit model
model_td &lt;- td_logistic(t,X,Z)

</code></pre>

<hr>
<h2 id='tune_cpdbee_2D'>Tunes 2D event detection using labeled data</h2><span id='topic+tune_cpdbee_2D'></span>

<h3>Description</h3>

<p>This function finds best parameters for 2D event detection using labeled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_cpdbee_2D(
  x,
  cl,
  alpha_min = 0.95,
  alpha_max = 0.98,
  alpha_step = 0.01,
  epsilon_min = 2,
  epsilon_max = 12,
  epsilon_step = 2,
  minPts_min = 4,
  minPts_max = 12,
  minPts_step = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_cpdbee_2D_+3A_x">x</code></td>
<td>
<p>The data in an mxn matrix or dataframe.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_cl">cl</code></td>
<td>
<p>The actual locations of the events.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_alpha_min">alpha_min</code></td>
<td>
<p>The minimum threshold value.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_alpha_max">alpha_max</code></td>
<td>
<p>The maximum threshold value.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_alpha_step">alpha_step</code></td>
<td>
<p>The incremental step size for alpha.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_epsilon_min">epsilon_min</code></td>
<td>
<p>The minimum epsilon value for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_epsilon_max">epsilon_max</code></td>
<td>
<p>The maximum epsilon value for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_epsilon_step">epsilon_step</code></td>
<td>
<p>The incremental step size for epsilon for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_minpts_min">minPts_min</code></td>
<td>
<p>The minimum minPts value for for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_minpts_max">minPts_max</code></td>
<td>
<p>The maximum minPts value for for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_2D_+3A_minpts_step">minPts_step</code></td>
<td>
<p>The incremental step size for minPts for DBSCAN clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>best</code></td>
<td>
<p>The best threshold, epsilon and MinPts for 2D event detection and the associated Jaccard Index.</p>
</td></tr>
<tr><td><code>all</code></td>
<td>
<p>All parameter values used and the associated Jaccard Index values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- gen_stream(1, sd=15)
zz &lt;- as.matrix(out$data)
clst &lt;- get_clusters(zz, filename = NULL, thres = 0.95, 
                    vis = TRUE, epsilon = 5, miniPts = 10, 
                    rolling = FALSE)
clst_loc &lt;- clst$data[ ,1:2]
out &lt;- tune_cpdbee_2D(zz, clst_loc)
out$best

## End(Not run)
</code></pre>

<hr>
<h2 id='tune_cpdbee_3D'>Tunes 3D event detection using labeled data</h2><span id='topic+tune_cpdbee_3D'></span>

<h3>Description</h3>

<p>This function finds best parameters for 3D event detection using labeled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_cpdbee_3D(
  x,
  cl,
  alpha_min = 0.95,
  alpha_max = 0.98,
  alpha_step = 0.01,
  epsilon_min = 2,
  epsilon_max = 12,
  epsilon_step = 2,
  minPts_min = 8,
  minPts_max = 16,
  minPts_step = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_cpdbee_3D_+3A_x">x</code></td>
<td>
<p>The data in an mxn matrix or dataframe.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_cl">cl</code></td>
<td>
<p>The actual locations of the events.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_alpha_min">alpha_min</code></td>
<td>
<p>The minimum threshold value.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_alpha_max">alpha_max</code></td>
<td>
<p>The maximum threshold value.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_alpha_step">alpha_step</code></td>
<td>
<p>The incremental step size for alpha.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_epsilon_min">epsilon_min</code></td>
<td>
<p>The minimum epsilon value for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_epsilon_max">epsilon_max</code></td>
<td>
<p>The maximum epsilon value for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_epsilon_step">epsilon_step</code></td>
<td>
<p>The incremental step size for epsilon for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_minpts_min">minPts_min</code></td>
<td>
<p>The minimum minPts value for for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_minpts_max">minPts_max</code></td>
<td>
<p>The maximum minPts value for for DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="tune_cpdbee_3D_+3A_minpts_step">minPts_step</code></td>
<td>
<p>The incremental step size for minPts for DBSCAN clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following components
</p>
<table>
<tr><td><code>best</code></td>
<td>
<p>The best threshold, epsilon and MinPts for 2D event detection and the associated Jaccard Index.</p>
</td></tr>
<tr><td><code>all</code></td>
<td>
<p>All parameter values used and the associated Jaccard Index values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
arr &lt;- array(rnorm(12000),dim=c(40,25,30))
arr[25:33,12:20, 20:23] &lt;- 10
# Getting events
out &lt;- get_clusters_3d(arr, thres=0.985) 
out &lt;- tune_cpdbee_3D(arr, out$data[ ,1:3])
out$best

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
