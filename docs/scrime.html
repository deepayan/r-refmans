<!DOCTYPE html><html><head><title>Help for package scrime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scrime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abf'>
<p>Approximate Bayes Factor</p></a></li>
<li><a href='#analyse.models'><p> Summarize MCMC sample of Bayesian logic regression models</p></a></li>
<li><a href='#buildSNPannotation'><p>Construct Annotation for Affymetrix SNP Chips</p></a></li>
<li><a href='#colEpistatic'><p>Cordell's Test for Epistatic Interactions</p></a></li>
<li><a href='#computeContCells'><p>Pairwise Contingency Tables</p></a></li>
<li><a href='#computeContClass'><p>Rowwise Contigency Tables</p></a></li>
<li><a href='#fblr'><p>Full Bayesian Logic Regression for SNP Data</p></a></li>
<li><a href='#gknn'><p>Generalized k Nearest Neighbors</p></a></li>
<li><a href='#identifyMonomorphism'><p>Identification of Constant Variables</p></a></li>
<li><a href='#knncatimpute'><p>Missing Value Imputation with kNN</p></a></li>
<li><a href='#knncatimputeLarge'><p>Missing Value Imputation with kNN for High-Dimensional Data</p></a></li>
<li><a href='#pamCat'><p>Prediction Analysis of Categorical Data</p></a></li>
<li><a href='#pcc'><p>Pearson's Contingency Coefficient</p></a></li>
<li><a href='#predict.pamCat'><p>Predict Method for pamCat Objects</p></a></li>
<li><a href='#predictFBLR'><p> Predict Case Probabilities with Full Bayesian Logic Regression</p></a></li>
<li><a href='#recodeAffySNP'><p>Recoding of Affymetrix SNP Values</p></a></li>
<li><a href='#recodeSNPs'><p>Recoding of SNP Values</p></a></li>
<li><a href='#rowCATTs'><p>Rowwise Cochran-Armitage Trend Test Based on Tables</p></a></li>
<li><a href='#rowChisq2Class'><p>Rowwise Pearson's ChiSquare Test Based on Tables</p></a></li>
<li><a href='#rowChisqStats'><p>Rowwise Pearson's ChiSquare Statistic</p></a></li>
<li><a href='#rowCors'><p>Rowwise Correlation with a Vector</p></a></li>
<li><a href='#rowFreqs'><p>Rowwise Frequencies</p></a></li>
<li><a href='#rowHWEs'><p>Rowwise Test for Hardy-Weinberg Equilibrium</p></a></li>
<li><a href='#rowMAFs'>
<p>Rowwise Minor Allele Frequency</p></a></li>
<li><a href='#rowMsquares'><p>Rowwise Linear Trend Test Based on Tables</p></a></li>
<li><a href='#rowScales'><p>Rowwise Scaling</p></a></li>
<li><a href='#rowTables'><p>Rowwise Tables</p></a></li>
<li><a href='#rowTrendFuzzy'>
<p>Trend Test for Fuzzy Genotype Calls</p></a></li>
<li><a href='#rowTrendStats'><p>Rowwise Linear Trend Tests</p></a></li>
<li><a href='#scrime-internal'><p>Internal scrime functions</p></a></li>
<li><a href='#shortenGeneDescription'><p>Shorten the Gene Description</p></a></li>
<li><a href='#showChanges'><p>Displaying Changes</p></a></li>
<li><a href='#simulateSNPcatResponse'><p>Simulation of SNP Data with Categorical Response</p></a></li>
<li><a href='#simulateSNPglm'><p>Simulation of SNP data</p></a></li>
<li><a href='#simulateSNPs'><p>Simulation of SNP data</p></a></li>
<li><a href='#smc'><p>Simple Matching Coefficient and Cohen's Kappa</p></a></li>
<li><a href='#snp2bin'><p>Transformation of SNPs to Binary Variables</p></a></li>
<li><a href='#summary.simSNPglm'><p>Summarizing a simSNPglm object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of High-Dimensional Categorical Data Such as SNP Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-12-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Holger Schwender, with a contribution of Arno Fritsch</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Holger Schwender &lt;holger.schw@gmx.de&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, RSQLite (&ge; 0.4-15), oligoClasses (&ge; 1.1.9), DBI</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the analysis of high-dimensional data developed/implemented
  at the group "Statistical Complexity Reduction In Molecular Epidemiology" (SCRIME).
  Main focus is on SNP data. But most of the functions can also be applied to other
  types of categorical data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-01 10:36:18 UTC; schwender</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-01 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='abf'>
Approximate Bayes Factor
</h2><span id='topic+abf'></span>

<h3>Description</h3>

<p>Computes the Approximate Bayes Factor proposed by Wakefield (2009) for test statistics <code>theta / sqrt(V)</code>
that under the null hypothesis are assumed to follow an asymptotic standard normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abf(theta, V, W, numerator = 0, pi1 = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abf_+3A_theta">theta</code></td>
<td>
<p>a vector of numeric values, e.g., the maximum likelihood estimates for the parameter of
a logistic regression model computed by separately applying this simple logistic regression to several SNPs.
It is thus assumed that under the null hypothesis <code>theta / sqrt(V)</code> is asymptotically standard normal distributed. 
</p>
</td></tr>
<tr><td><code id="abf_+3A_v">V</code></td>
<td>
<p>a vector of the same length as <code>theta</code> containing the variances of the estimates comprised by <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="abf_+3A_w">W</code></td>
<td>
<p>the prior variance. Must be either a positive value or a vector of the same length as <code>theta</code> consisting of
positive values.
</p>
</td></tr>
<tr><td><code id="abf_+3A_numerator">numerator</code></td>
<td>
<p>either 0 or 1, specifying whether the numerator of the approximate Bayes factor comprises the 
probability for the null hypothesis or the probability for the alternative hypothesis. 
</p>
</td></tr>
<tr><td><code id="abf_+3A_pi1">pi1</code></td>
<td>
<p>either a numeric value between 0 and 1 specifying the prior probability of association or a vector of the 
same length as <code>theta</code> specifying for each of the SNPs a prior probability that this SNP is associated with the response. 
If specified, prior odds, posterior odds,
and depending on <code>numerator</code> the Bayesian False Discovery Probability (<code>numerator = 0</code>) or the posterior
probability of association (<code>numerator = 1</code>) are computed. If <code>NA</code>, only the approximate Bayes factors are
returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>pi1 = NA</code>, a vector of the same length as <code>theta</code> containing the values of the approximate Bayes factor.
If <code>pi1</code> is specified, a list consisting of
</p>
<table>
<tr><td><code>ABF</code></td>
<td>
<p>a numeric vector containing the values of the approximate Bayes factors,</p>
</td></tr>
<tr><td><code>priorOdds</code></td>
<td>
<p>either a numeric value or a numeric vector comprising the prior odds of association (if <code>numerator = 1</code>)
or no association (if <code>numerator = 0</code>),</p>
</td></tr>
<tr><td><code>postOdds</code></td>
<td>
<p>a numeric vector containing the posterior odds of association (if <code>numerator = 1</code>) or no association
(if <code>numerator = 0</code>),</p>
</td></tr>
</table>
<p>and either
</p>
<table>
<tr><td><code>BFDP</code></td>
<td>
<p>a numeric vector containing the Bayesian False Discovery Probabilities for the SNPs (if <code>numerator = 0</code>),</p>
</td></tr>
</table>
<p>or
</p>
<table>
<tr><td><code>PPA</code></td>
<td>
<p>a numeric vector comprising the posterior probabilities of association (if <code>numerator = 1</code>)l</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schw@gmx.de">holger.schw@gmx.de</a>
</p>


<h3>References</h3>

<p>Wakefield, J. (2007). A Bayesian Measure of Probability of False Discovery in Genetic Epidemiology Studies. <em>American Journal
of Human Genetics</em>, 81, 208-227.
</p>

<hr>
<h2 id='analyse.models'> Summarize MCMC sample of Bayesian logic regression models</h2><span id='topic+analyse.models'></span>

<h3>Description</h3>

<p>For an MCMC sample of Bayesian logic regression models obtained with <code>fblr</code>
the distribution of the model size and the most common logic predictors with up
to three binaries are reported.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse.models(file, size.freq = TRUE, moco = c(20, 10), int.freq = TRUE, 
                kmax = 10, int.level = 2, bin.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse.models_+3A_file">file</code></td>
<td>
<p>character string naming file where MCMC output of <code>fblr</code> is 
stored.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_size.freq">size.freq</code></td>
<td>
<p>determines whether distribution of model size is reported as
frequencies (default) or proportions.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_moco">moco</code></td>
<td>
<p>a vector of length 2 or 3 that determines how many of the most 
common main effects, two-factor interactions and (possibly) three-factor 
interactions are reported.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_int.freq">int.freq</code></td>
<td>
<p>determines whether the number (default) or the proportion of 
models containing a specific interaction is reported.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_kmax">kmax</code></td>
<td>
<p>the maximum number of allowed logic predictors used in <code>fblr</code>.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_int.level">int.level</code></td>
<td>
<p>the maximum number of allowed binaries in a logic predictor 
used in <code>fblr</code>.</p>
</td></tr>
<tr><td><code id="analyse.models_+3A_bin.names">bin.names</code></td>
<td>
<p>character vector of names for the binary variables. If no 
names are supplied, binaries are referred to with their indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logic regression models visited during the MCMC run are stored by 
<code>fblr</code> in the rows of a matrix in the following fashion: 
Position 1 contains the number of logic predictors in the model. The next 
<code>kmax * (int.level + 1)</code> positions contain the predictors, each predictor being 
coded as c(number of binaries in predictor, indices of binaries), where negative
indices denote the complement of a variable. It follow the log-likelihood of 
the model, the value of the precision of the regression parameters and the 
<code>kmax+1</code> regression parameters. Zeros indicate empty entries. 
<code>analyse.models</code> extracts some of the most interesting information, namely
which logic predictors occur most often in the visited models, from the sample. 
The complement of a binary is indicated with a minus sign preceding its name.       
</p>


<h3>Value</h3>

<table>
<tr><td><code>size</code></td>
<td>
<p>table of model sizes.</p>
</td></tr>
<tr><td><code>ones</code></td>
<td>
<p>table of the <code>moco[1]</code> most common single-binary predictors.</p>
</td></tr>
<tr><td><code>twos</code></td>
<td>
<p>table of the <code>moco[2]</code> most common two-binaries predictors.</p>
</td></tr>
<tr><td><code>threes</code></td>
<td>
<p>table of the <code>moco[3]</code> most common three-binaries predictors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Arno Fritsch, <a href="mailto:arno.fritsch@uni-dortmund.de">arno.fritsch@uni-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fblr">fblr</a></code>, <code><a href="#topic+predictFBLR">predictFBLR</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use fblr on some simulated SNP data
snp &lt;- matrix(rbinom(500*20,2,0.3),ncol=20)
bin &lt;- snp2bin(snp)
int &lt;- apply(bin,1,function(x) (x[1] == 1 &amp; x[3] == 0)*1)
case.prob &lt;- exp(-0.5+log(5)*int)/(1+exp(-0.5+log(5)*int))
y &lt;- rbinom(nrow(snp),1,prob=case.prob)
fblr(y, bin, niter=1000, nburn=0)

analyse.models("fblr_mcmc.txt")

# with SNP names
name.snp &lt;- LETTERS[1:20]
name.bin &lt;- paste(rep(name.snp,each=2), c("_d","_r"),sep="")

analyse.models("fblr_mcmc.txt", bin.names=name.bin)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='buildSNPannotation'>Construct Annotation for Affymetrix SNP Chips</h2><span id='topic+buildSNPannotation'></span>

<h3>Description</h3>

<p>Constructs a data frame from a metadata package containing annotations for the SNPs
from the corresponding Affymetrix SNP Chip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  buildSNPannotation(pkg, rs = TRUE, allele = TRUE, gene = TRUE,
    chromosome = FALSE, position = FALSE, strand = FALSE, cytoband = FALSE, 
    max.genes = 0, lib.loc = NULL, others = NULL, subset = NULL, 
    pattern = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildSNPannotation_+3A_pkg">pkg</code></td>
<td>
<p>the name of the metadata package from which the data frame containing the
annotations of the SNPs should be generated.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_rs">rs</code></td>
<td>
<p>should the RefSNP-ID of the SNPs be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_allele">allele</code></td>
<td>
<p>should the two alleles of each SNP be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_gene">gene</code></td>
<td>
<p>should the genes associated with the SNPs be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_chromosome">chromosome</code></td>
<td>
<p>should the chromosome to which the respective SNP belongs be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_position">position</code></td>
<td>
<p>should the physical positions of the SNPs be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_strand">strand</code></td>
<td>
<p>should the strands be added to the data frame?</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_cytoband">cytoband</code></td>
<td>
<p>logical indicating whether the cytoband of each SNP is added to the data frame.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_max.genes">max.genes</code></td>
<td>
<p>integer specifying the maximum number of genes associated with the respective
SNP that should be stored in the data frame. By default, all entries are considered. The corresponding column
of the data frame can also be shortened afterwards using <code><a href="#topic+shortenGeneDescription">shortenGeneDescription</a></code>.
Shortened entries are marked by <code>...</code> at the end of the entries.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_lib.loc">lib.loc</code></td>
<td>
<p>the directory in which the metadata package is stored. Needs only to be specified
if it is not stored in the usual directory of the packages.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_others">others</code></td>
<td>
<p>character string or vector naming other entries of the object <code>featureSet</code>
saved in <code>pkg</code> that should be added to the data frame.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_subset">subset</code></td>
<td>
<p>character string consisting of the probe set IDs of the SNPs for which the data
frame should be generated. The data frame will contain all SNPs if <code>subset = NULL</code></p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_pattern">pattern</code></td>
<td>
<p>character string specifying the pattern of the probe set IDs of the SNPs for which
the data frame should be generated. For example, <code>pattern = "SNP%"</code> will lead to a
data frame containing all SNPs whose probe set ID start with &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="buildSNPannotation_+3A_na.rm">na.rm</code></td>
<td>
<p>should the rows of the data frame corresponding to SNPs specified by <code>subset</code>
for which no information is available in the metadata package be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame composed of annotations for the SNPs for which information is available in
the specified metadata package.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schw@gmx.de">holger.schw@gmx.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+shortenGeneDescription">shortenGeneDescription</a></code></p>

<hr>
<h2 id='colEpistatic'>Cordell's Test for Epistatic Interactions
</h2><span id='topic+colEpistatic'></span><span id='topic+rowEpistatic'></span><span id='topic+print.colEpi'></span>

<h3>Description</h3>

<p>Performs the likelihood ratio test for epistatic interactions proposed by Cordell (2002) for case-control data, where
<code>colEpistatic</code> assumes that each column represents a SNP, and <code>rowEpistatic</code> assumes that each row represents a SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colEpistatic(mat.snp, cl, genes = NULL, warnError = TRUE)
rowEpistatic(mat.snp, cl, genes = NULL, warnError = TRUE)

## S3 method for class 'colEpi'
print(x, top = 5, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colEpistatic_+3A_mat.snp">mat.snp</code></td>
<td>
<p>a matrix containing genotype data, where the genotypes of each SNPs need to be coded by the number of minor alleles,
i.e. 0, 1, and 2. Missing values are allowed. For <code>colEpistatic</code>, each column of <code>mat.snp</code> is assumed to represent a SNP, and
each row a subject. For <code>rowEpistatic</code>, each row of <code>mat.snp</code> is assumed to represent a subject, and each column a SNP. 
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_cl">cl</code></td>
<td>
<p>a numeric vector of ones and zeros specifying which of the subjects in <code>mat.snp</code> are cases (coded by 1) and which are
controls (coded by 0).
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_genes">genes</code></td>
<td>
<p>a character vector containing the names of the genes (or, e.g., LD-blocks or pathways) to which the SNPs belong. If specified, 
only the two-way interactions between SNPs from different genetic sets (e.g., genes, LD-blocks, or pathways) are tested. 
If <code>NULL</code>, all two-way interactions between all possible pairs of SNPs are tested.
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_warnerror">warnError</code></td>
<td>
<p>logical indicating whether the statistics for the gTDT for pairs of SNPs should be returned as <code>NA</code> if the fitting 
of one of the logistic regression models with <code><a href="stats.html#topic+glm">glm</a></code> returns warning. If <code>warnError = FALSE</code>, 
these warnings will be ignored, and the gTDT will be performed also for these SNP pairs.
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_x">x</code></td>
<td>
<p>an object of class <code>colEpi</code>, i.e. the output of either <code>colEpistatic</code> or <code>rowEpistatic</code>.
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_top">top</code></td>
<td>
<p>number of interactions that should be printed. If <code>top</code> is set to <code>0</code> or the number of interactions is smaller than 
or equal to <code>top</code>, then the statistics for all interactions are printed in the order of their computation. Otherwise, 
the <code>top</code> interactions with the smallest p-values are printed (sorted by their p-values).
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_digits">digits</code></td>
<td>
<p>number of digits that should be printed.
</p>
</td></tr>
<tr><td><code id="colEpistatic_+3A_...">...</code></td>
<td>
<p>ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>colEpi</code> consisting of
</p>
<table>
<tr><td><code>ll.main</code></td>
<td>
<p>a numeric vector containing the values of the maximized loglikelihoods of the logistic regression models 
considering only main effects,</p>
</td></tr>
<tr><td><code>ll.full</code></td>
<td>
<p>a numeric vector containing the values the maximized loglikelihoods of the logistic regression models additionally 
containing interaction terms,</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector comprising the values of the test statistic,</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector comprising the corresponding p-values,</p>
</td></tr>
<tr><td><code>genes</code></td>
<td>
<p>if <code>genes</code> has been specified, a vector composed of the gene pairs to which the SNP pairs belong,</p>
</td></tr>
<tr><td><code>vec.error</code></td>
<td>
<p>if <code>warnError = TRUE</code>, a list in which an entry corresponding to a SNP pair for which the fitting of (at least)
one of the logistic regression models led to a warning shows this warning message of <code><a href="stats.html#topic+glm">glm</a></code>, and all other entries
are <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a>
</p>


<h3>References</h3>

<p>Cordell, H. J. (2002). Epistasis: What it Means, what it Doesn't mean, and Statistical Methods to Detect it in Humans.
Human Molecular Genetics, 11, 2463-2468.
</p>

<hr>
<h2 id='computeContCells'>Pairwise Contingency Tables</h2><span id='topic+computeContCells'></span>

<h3>Description</h3>

<p>Computes a contingency table for each pair of rows of a matrix, and stores
all contigency table in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeContCells(data, computeExp = TRUE, justDiag = FALSE, 
   check = TRUE, n.cat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeContCells_+3A_data">data</code></td>
<td>
<p>a numeric matrix consisting of integers between 1 and <code>n.cat</code>. 
It is assumed that each row of these matrix represents
a variable. Missing values and different numbers of categories a variable can take are
allowed.</p>
</td></tr>
<tr><td><code id="computeContCells_+3A_computeexp">computeExp</code></td>
<td>
<p>should the numbers of observations expected under the null hypothesis that
the respective two variables are independent also be computed? Required
when <code>computeContCells</code> is used to compute Pearson's <code class="reqn">\chi^2</code>-statistic.</p>
</td></tr>
<tr><td><code id="computeContCells_+3A_justdiag">justDiag</code></td>
<td>
<p>should only the diagonal elements of the contingency tables,
i.e.\ <code class="reqn">n_{ii}</code>, <code class="reqn">i = 1, \dots</code>, <code>n.cat</code>, be computed?</p>
</td></tr>
<tr><td><code id="computeContCells_+3A_check">check</code></td>
<td>
<p>should <code>data</code> be checked more thoroughly? It is highly recommended to use
<code>check = TRUE</code>.</p>
</td></tr>
<tr><td><code id="computeContCells_+3A_n.cat">n.cat</code></td>
<td>
<p>integer specifying the maximum number of levels a variable can take. If <code>NULL</code>,
this number will be computed. It is highly recommended not to change the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of two matrices each consisting of <code class="reqn">m * (m - 1) / 2</code> rows and 
<code>n.cat</code><code class="reqn">^2</code> columns, where <code class="reqn">m</code> is the number of rows of <code>data</code>. 
One of these matrices
called <code>mat.obs</code> contains in each row the values of the contingency table for
a particular pair of rows of <code>data</code>, where the contigency table of the variables represented
by the <em>i</em>th and <em>j</em>th row of <code>data</code> is shown in the
<code class="reqn">j + m * (i - 1) - i * (i - 1) / 2</code> row of <code>mat.obs</code>.
The other matrix called <code>mat.exp</code> consists of
the corresponding numbers of observations expected under the null hypothesis that
the respective two variables are independent.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). A Note on the Simultaneous Computation of Thousands of 
Pearson's <code class="reqn">\chi^2</code>-Statistics. <em>Technical Report</em>, SFB 475,
Deparment of Statistics, University of Dortmund. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeContClass">computeContClass</a></code>, <code><a href="#topic+rowChisqStats">rowChisqStats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate an example data set consisting of 5 rows (variables)
# and 200 columns (observations) by randomly drawing integers 
# between 1 and 3.

mat &lt;- matrix(sample(3, 1000, TRUE), 5)

# Generate the matrix containing the contingency tables for each
# pair of rows of mat.

out &lt;- computeContCells(mat)

# out contains both the observed numbers of observations 
# summarized by contingency tables

out$mat.obs

# and the number of observations expected under the null hypothesis
# of independence.

out$mat.exp

# If, e.g., only the observed number of observations having the same 
# value is of interest, call

computeContCells(mat, computeExp = FALSE, justDiag = TRUE)


## End(Not run)</code></pre>

<hr>
<h2 id='computeContClass'>Rowwise Contigency Tables</h2><span id='topic+computeContClass'></span>

<h3>Description</h3>

<p>Generates a matrix containing a contingency table for each row of a matrix
and a vector of class labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeContClass(data, cl, n.cat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeContClass_+3A_data">data</code></td>
<td>
<p>a numeric matrix consisting of integers between 1 and <code>n.cat</code>. Each
row of data is assumed to represent a variable, and each column to represent an
observation. Missing values are not allowed. All variables must
comprise the same number of levels.</p>
</td></tr>
<tr><td><code id="computeContClass_+3A_cl">cl</code></td>
<td>
<p>a numeric vector of length <code>ncol(data)</code> specifying the
class labels of the observations represented by the columns of data. <code>cl</code> must
consist of integers between 1 and <code class="reqn">n_{cl}</code>, where <code class="reqn">n_{cl}</code> is
the number of classes.</p>
</td></tr>
<tr><td><code id="computeContClass_+3A_n.cat">n.cat</code></td>
<td>
<p>an integer giving the number of levels the variables can take. If not
specified, <code>n.cat</code> will be determined automatically. It is highly
recommended not to specify <code>n.cat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of the following two matrices:
</p>
<table>
<tr><td><code>mat.obs</code></td>
<td>
<p>a matrix consisting of <code class="reqn">m</code> rows and <code>n.cat</code> <code class="reqn">* n_{cl}</code> columns,
where <code class="reqn">m</code> is the number of variables, i.e.\ the number of rows of <code>data</code>. 
Each row of data shows the contingency table of <code>cl</code> and the corresponding row of <code>data</code>.</p>
</td></tr>
<tr><td><code>mat.exp</code></td>
<td>
<p>a matrix of the same size as <code>mat.obs</code> containing the numbers of observations
expected under the null hypothesis of equal distribution in all classes that correspond to the
respective entries in <code>mat.obs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). A Note on the Simultaneous Computation of Thousands of 
Pearson's <code class="reqn">\chi^2</code>-Statistics. <em>Technical Report</em>, SFB 475,
Deparment of Statistics, University of Dortmund. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeContCells">computeContCells</a></code>, <code><a href="#topic+rowChisqStats">rowChisqStats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate an example data set consisting of 10 rows (variables)
# and 200 columns (observations) by randomly drawing integers 
# between 1 and 3, and a vector of class labels of length 200
# indicating that the first 100 observation belong to class 1
# and the other 100 to class 2. 

mat &lt;- matrix(sample(3, 2000, TRUE), 10)
cl &lt;- rep(1:2, e = 100)

# Applying computeContClass to this data set

out &lt;- computeContClass(mat, cl)

# generates the observed numbers of observations

out$mat.obs

# and the corresponding expected numbers of observations.

out$mat.exp


## End(Not run)</code></pre>

<hr>
<h2 id='fblr'>Full Bayesian Logic Regression for SNP Data</h2><span id='topic+fblr'></span><span id='topic+fblr.weight'></span>

<h3>Description</h3>

<p>Performs full Bayesian logic regression for Single Nucleotide Polymorphism (SNP)
data as described in Fritsch and Ickstadt (2007). 
</p>
<p><code>fblr.weight</code> allows to incorporate prior pathway information by restricting 
search for interactions to specific groups of SNPs and/or giving them different 
weights. <code>fblr.weight</code> is only implemented for an interaction level of 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fblr(y, bin, niter, thin = 5, nburn = 10000, int.level = 2, kmax = 10, 
  geo = 1, delta1 = 0.001, delta2 = 0.1, predict = FALSE, 
  file = "fblr_mcmc.txt")

fblr.weight(y, bin, niter, thin = 5, nburn = 10000, kmax = 10, geo = 1, 
  delta1 = 0.001, delta2 = 0.1, predict = FALSE, group = NULL, 
  weight = NULL, file = "fblr_mcmc.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fblr_+3A_y">y</code></td>
<td>
<p>binary vector indicating case-control status.</p>
</td></tr>
<tr><td><code id="fblr_+3A_bin">bin</code></td>
<td>
<p>binary matrix with number of rows equal to <code>length(y)</code>. 
Usually the result of applying <code>snp2bin</code> to a matrix of SNP data.</p>
</td></tr>
<tr><td><code id="fblr_+3A_niter">niter</code></td>
<td>
<p>number of MCMC iterations after burn-in.</p>
</td></tr>
<tr><td><code id="fblr_+3A_thin">thin</code></td>
<td>
<p>after burn-in only every <code>thin</code>th iteration is kept.</p>
</td></tr>
<tr><td><code id="fblr_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="fblr_+3A_int.level">int.level</code></td>
<td>
<p>maximum number of binaries allowed in a logic predictor.
Is fixed to 2 for <code>fblr.weight</code>.</p>
</td></tr>
<tr><td><code id="fblr_+3A_kmax">kmax</code></td>
<td>
<p>maximum number of logic predictors allowed in the model.</p>
</td></tr>
<tr><td><code id="fblr_+3A_geo">geo</code></td>
<td>
<p>geometric penalty parameter for the number of binaries in a predictor.
Value between 0 and 1. Default is <code>1</code>, meaning no penalty.</p>
</td></tr>
<tr><td><code id="fblr_+3A_delta1">delta1</code></td>
<td>
<p>shape parameter for hierarchical gamma prior on precision of 
regression parameters.</p>
</td></tr>
<tr><td><code id="fblr_+3A_delta2">delta2</code></td>
<td>
<p>rate parameter for hierarchical gamma prior on precision of 
regression parameters.</p>
</td></tr>
<tr><td><code id="fblr_+3A_predict">predict</code></td>
<td>
<p>should predicted case probabilities be returned?</p>
</td></tr>
<tr><td><code id="fblr_+3A_file">file</code></td>
<td>
<p>character string naming a file to write the MCMC output to. If 
<code>fblr</code> is called again, the file is overwritten.</p>
</td></tr>
<tr><td><code id="fblr_+3A_group">group</code></td>
<td>
<p>list containing vectors of indices of binaries that are allowed 
to interact. Groups may be overlapping, but every binary has to be in at least
one group. Groups have to contain at least two binaries. Defaults to NULL,
meaning that all interactions are allowed.</p>
</td></tr>
<tr><td><code id="fblr_+3A_weight">weight</code></td>
<td>
<p>vector of length <code>ncol(bin)</code> containing different relative 
prior weights for binaries. Defaults to <code>NULL</code>, meaning equal weight for all binaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MCMC output in <code>file</code> can be analysed using the function 
<code>analyse.models</code>. In the help of this function it is also described how
the models are stored in <code>file</code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>accept</code></td>
<td>
<p>acceptance rate of MCMC algorithm.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>vector of predicted case probabilities. Only given if 
<code>predict = TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arno Fritsch, <a href="mailto:arno.fritsch@uni-dortmund.de">arno.fritsch@uni-dortmund.de</a></p>


<h3>References</h3>

<p> Fritsch, A. and Ickstadt, K.\ (2007). Comparing logic regression 
based methods for identifying SNP interactions. 
In <em>Bioinformatics in Research and Development</em>, Hochreiter, S.\ and 
Wagner, R.\ (Eds.), Springer, Berlin.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+analyse.models">analyse.models</a></code>,<code><a href="#topic+predictFBLR">predictFBLR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# SNP dataset with 500 persons and 20 SNPs each,
# a two-SNP interaction influences the case probability
snp &lt;- matrix(rbinom(500*20,2,0.3),ncol=20)
bin &lt;- snp2bin(snp)
int &lt;- apply(bin,1,function(x) (x[1] == 1 &amp; x[3] == 0)*1)
case.prob &lt;- exp(-0.5+log(5)*int)/(1+exp(-0.5+log(5)*int))
y &lt;- rbinom(nrow(snp),1,prob=case.prob)

# normally more iterations should be used
fblr(y, bin, niter=1000, nburn=0)
analyse.models("fblr_mcmc.txt")

# Prior information: SNPs 1-10 belong to genes in one pathway, 
# SNPs 8-20 to another. Only interactions within a pathway are 
# considered and the first pathway is deemed to be twice as 
# important than the second.
fblr.weight(y,bin,niter=1000, nburn=0, group=list(1:20, 15:40), 
  weight=c(rep(2,20),rep(1,20)))
analyse.models("fblr_mcmc.txt")


## End(Not run)
</code></pre>

<hr>
<h2 id='gknn'>Generalized k Nearest Neighbors</h2><span id='topic+gknn'></span>

<h3>Description</h3>

<p>Predicts the classes of new observations with <code class="reqn">k</code> Nearest Neighbors
based on an user-specified distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gknn(data, cl, newdata, nn = 5, distance = NULL, use.weights = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gknn_+3A_data">data</code></td>
<td>
<p>a numeric matrix in which each row represents an observation and each column
a variable. If <code>distance</code> is <code>"smc"</code>, <code>"cohen"</code> or <code>"pcc"</code>,
the values in <code>data</code> must be integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the maximum number of levels one of the variables can
take. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="gknn_+3A_cl">cl</code></td>
<td>
<p>a numeric vector of length <code>nrow(data)</code> giving the class labels of
the observations represented by the rows of <code>data</code>. <code>cl</code> must consist
of integers between 1 and <code class="reqn">n_{cl}</code>, where <code class="reqn">n_{cl}</code> is the
number of groups.</p>
</td></tr>
<tr><td><code id="gknn_+3A_newdata">newdata</code></td>
<td>
<p>a numeric matrix in which each row represents a new observation for
which the class label should be predicted and each column consists of the same
variable as the corresponding column of <code>data</code>.</p>
</td></tr>
<tr><td><code id="gknn_+3A_nn">nn</code></td>
<td>
<p>an integer specifying the number of nearest neighbors used to classify
the new observations.</p>
</td></tr>
<tr><td><code id="gknn_+3A_distance">distance</code></td>
<td>
<p>character vector naming the distance measure used to identify the
<code>nn</code> nearest neighbors. Must be one of <code>"smc"</code>, <code>"cohen"</code>,
<code>"pcc"</code>, <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, and <code>"minkowski"</code>. If <code>NULL</code>, it is determined in
an ad hoc way if the data seems to be categorical. If this is the case <code>distance</code>
is set to <code>"smc"</code>. Otherwise, it is set to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="gknn_+3A_use.weights">use.weights</code></td>
<td>
<p>should the votes of the nearest neighbors be weighted by the reciprocal
of the distances to the new observation when the class of a new observation should be
predicted?</p>
</td></tr>
<tr><td><code id="gknn_+3A_...">...</code></td>
<td>
<p>further arguments for the distance measure. If, e.g., 
<code>distance = "minkowski"</code>, then <code>p</code> can also be specified, see <code><a href="stats.html#topic+dist">dist</a></code>.
If <code>distance = "pcc"</code>, then <code>version</code> can also be specified,
see <code><a href="#topic+pcc">pcc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted classes of the new observations.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). Statistical Analysis of Genotype and Gene Expression Data.
<em>Dissertation</em>, Department of Statistics, University of Dortmund.</p>


<h3>See Also</h3>

<p><code><a href="#topic+knncatimpute">knncatimpute</a></code>, <code><a href="#topic+smc">smc</a></code>, <code><a href="#topic+pcc">pcc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using the example from the function knn.

library(class)
data(iris3)
train &lt;- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
test &lt;- rbind(iris3[26:50,,1], iris3[26:50,,2], iris3[26:50,,3])
cl &lt;- c(rep(2, 25), rep(1, 25), rep(1, 25))

knn.out &lt;- knn(train, test, as.factor(cl), k = 3, use.all = FALSE)
gknn.out &lt;- gknn(train, cl, test, nn = 3)

# Both applications lead to the same predictions.

knn.out == gknn.out

# But gknn allows to use other distance measures than the Euclidean 
# distance. E.g., the Manhattan distance.

gknn(train, cl, test, nn = 3, distance = "manhattan")


## End(Not run)</code></pre>

<hr>
<h2 id='identifyMonomorphism'>Identification of Constant Variables</h2><span id='topic+identifyMonomorphism'></span>

<h3>Description</h3>

<p>Identifies the rows of a matrix that only show one level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyMonomorphism(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyMonomorphism_+3A_x">x</code></td>
<td>
<p>a matrix consisting of integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the number of levels the variables in <code>x</code>
can take. Each row of <code>x</code> is assumed to represent one variable. Missing values are allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector containing the rows of <code>x</code> showing only one level.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 10 rows and 15 columns,
# where the values are randomly drawn from the integers 1, 2, and 3,
# and row 3 and 7 consist only of one level.

mat &lt;- matrix(sample(3, 2000, TRUE), 10)
mat[3, ] &lt;- 1
mat[7, ] &lt;- 2

identifyMonomorphism(mat)


## End(Not run)</code></pre>

<hr>
<h2 id='knncatimpute'>Missing Value Imputation with kNN</h2><span id='topic+knncatimpute'></span>

<h3>Description</h3>

<p>Imputes missing values in a matrix composed of categorical variables
using <code class="reqn">k</code> Nearest Neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knncatimpute(x, dist = NULL, nn = 3, weights = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knncatimpute_+3A_x">x</code></td>
<td>
<p>a numeric matrix containing missing values. All non-missing values
must be integers between 1 and <code class="reqn">n_{cat}</code>, where <code class="reqn">n_{cat}</code>
is the maximum number of levels the categorical variables in <code>x</code> can take.
If the <code class="reqn">k</code> nearest observations should be used to replace the missing values
of an observation, then each row must represent one of the observations and each
column one of the variables. If the <code class="reqn">k</code> nearest variables should be used
to impute the missing values of a variable, then each row must correspond to a variable
and each column to an observation.</p>
</td></tr>
<tr><td><code id="knncatimpute_+3A_dist">dist</code></td>
<td>
<p>either a character string naming the distance measure or a distance matrix.
If the former, <code>dist</code> must be either <code>"smc"</code>, <code>"cohen"</code>, or <code>"pcc"</code>.
If the latter, <code>dist</code> must be a symmetric matrix having the same number of rows
as <code>x</code>. In this case, both the upper and the lower triangle of <code>dist</code> must
contain the distances, and the row and column names of <code>dist</code> must be equal to
the row names of <code>x</code>. If <code>NULL</code>, <code>dist = "smc"</code> is used.</p>
</td></tr>
<tr><td><code id="knncatimpute_+3A_nn">nn</code></td>
<td>
<p>an integer specifying <code class="reqn">k</code>, i.e.\ the number of nearest neighbors, used in
the imputation of the missing values.</p>
</td></tr>
<tr><td><code id="knncatimpute_+3A_weights">weights</code></td>
<td>
<p>should weighted <code class="reqn">k</code>NN be used to impute the missing values? If <code>TRUE</code>,
the vote of each nearest neighbor is weighted by the reciprocal of its distance to the observation or variable
when the missing values of this observation or variable, respectively, are replaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> in which all the missing values have been imputed.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). Statistical Analysis of Genotype and Gene Expression Data.
<em>Dissertation</em>, Department of Statistics, University of Dortmund.</p>


<h3>See Also</h3>

<p><code><a href="#topic+knncatimputeLarge">knncatimputeLarge</a></code>, <code><a href="#topic+gknn">gknn</a></code>, <code><a href="#topic+smc">smc</a></code>, <code><a href="#topic+pcc">pcc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 200 rows and 50 columns
# in which the values are integers between 1 and 3.
# Afterwards, remove 20 of the values randomly.

mat &lt;- matrix(sample(3, 10000, TRUE), 200)
mat[sample(10000, 20)] &lt;- NA

# Replace the missing values.

mat2 &lt;- knncatimpute(mat)

# Replace the missing values using the 5 nearest neighbors
# and Cohen's Kappa.

mat3 &lt;- knncatimpute(mat, nn = 5, dist = "cohen")


## End(Not run)</code></pre>

<hr>
<h2 id='knncatimputeLarge'>Missing Value Imputation with kNN for High-Dimensional Data</h2><span id='topic+knncatimputeLarge'></span>

<h3>Description</h3>

<p>Imputes missing values in a high-dimensional matrix composed of categorical variables
using <code class="reqn">k</code> Nearest Neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knncatimputeLarge(data, mat.na = NULL, fac = NULL, fac.na = NULL,
   nn = 3, distance = c("smc", "cohen", "snp1norm", "pcc"), 
   n.num = 100, use.weights = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knncatimputeLarge_+3A_data">data</code></td>
<td>
<p>a numeric matrix consisting of integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is maximum number of levels the categorical variables
can take. If <code>mat.na</code> is specified, <code>data</code> is assumed to contain only
non-missing data, and the rows of <code>data</code> are used to impute the missing values
in <code>mat.na</code>. Otherwise, <code>data</code> is also allowed to contain missing values,
and the missing values in the rows of <code>data</code> are imputed by employing the rows of
<code>data</code> showing no missing values.
</p>
<p>Each row of <code>data</code> represents one of the objects that should be used to identify the
<code class="reqn">k</code> nearest neighbors, i.e.\ if the <code class="reqn">k</code> nearest variables should be used to
replace the missing values, then each row must represent one of the variables. If the
<code class="reqn">k</code> nearest observations should be used to impute the missing values, then each
row must correspond to one of the observations.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_mat.na">mat.na</code></td>
<td>
<p>a numeric matrix containing missing values. Must have the same number of
columns as <code>data</code>. All non-missing values must be integers between 1 and
<code class="reqn">n_{cat}</code>. If <code>NULL</code>, <code>data</code> is assumed to also contain the
rows with missing values.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_fac">fac</code></td>
<td>
<p>a numeric or character vector of length <code>nrow{data}</code> specifying the values of
a factor used to split <code>data</code> into subsets. If, e.g., the values of <code>fac</code>
are given by the chromosomes to which the SNPs represented by the rows of <code>data</code>
belong, then <code class="reqn">k</code> nearest neighbors is applied chromosomewise to the missing values
in <code>mat.na</code> (or <code>data</code>). If <code>NULL</code>, no such splitting is done. Must be
specified, if <code>fac.na</code> is specified.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_fac.na">fac.na</code></td>
<td>
<p>a numeric or character vector of length <code>nrow{mat.na}</code> specifying the values
of a factor by which <code>mat.na</code> is split into subsets. Each possible value of <code>fac.na</code>
must be at least <code>nn</code> times in <code>fac</code>. Must be specified, if <code>fac</code> and <code>mat.na</code>
is specified. If both <code>fac</code> and <code>fac.na</code> are <code>NULL</code>, then no splitting is done.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_nn">nn</code></td>
<td>
<p>an integer specifying <code class="reqn">k</code>, i.e.\ the number of nearest neighbors, used to impute
the missing values.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_distance">distance</code></td>
<td>
<p>character string naming the distance measure used in <code class="reqn">k</code> Nearest Neighbors.
Must be either <code>"smc"</code> (default), <code>"cohen"</code>, <code>"snp1norm"</code> (which denotes the
Manhattan distance for SNPs), or <code>"pcc"</code>.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_n.num">n.num</code></td>
<td>
<p>an integer giving the number of rows of <code>mat.na</code> considered simultaneously
when replacing the missing values in <code>mat.na</code>.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_use.weights">use.weights</code></td>
<td>
<p>should weighted <code class="reqn">k</code> nearest neighbors be used to impute the missing values?
If <code>TRUE</code>, the votes of the nearest neighbors are weighted by the reciprocal of their
distances to the variable (or observation) whose missing values are imputed.</p>
</td></tr>
<tr><td><code id="knncatimputeLarge_+3A_verbose">verbose</code></td>
<td>
<p>should more information about the progress of the imputation be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>mat.na = NULL</code>, then a matrix of the same size as <code>data</code> in which the missing
values have been replaced. If <code>mat.na</code> has been specified, then a matrix of the same size as
<code>mat.na</code> in which the missing values have been replaced.
</p>


<h3>Note</h3>

<p>While in <code><a href="#topic+knncatimpute">knncatimpute</a></code> all variable/rows are considered when replacing
missing values, <code>knncatimputeLarge</code> only considers the rows with no missing values
when searching for the <code class="reqn">k</code> nearest neighbors.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H. and Ickstadt, K.\ (2008). Imputing Missing Genotypes with <code class="reqn">k</code> Nearest Neighbors.
<em>Technical Report</em>, SFB 475, Department of Statistics, University of Dortmund. Appears soon.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knncatimpute">knncatimpute</a></code>, <code><a href="#topic+gknn">gknn</a></code>, <code><a href="#topic+smc">smc</a></code>, <code><a href="#topic+pcc">pcc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 100 columns and 2000 rows (actually,
# knncatimputeLarge is made for much larger data sets), where the values
# are randomly drawn from the integers 1, 2, and 3.
# Afterwards, remove 200 of the observations randomly.

mat &lt;- matrix(sample(3, 200000, TRUE), 2000)
mat[sample(200000, 20)] &lt;- NA

# Apply knncatimputeLarge to mat to remove the missing values.

mat2 &lt;- knncatimputeLarge(mat)
sum(is.na(mat))
sum(is.na(mat2))

# Now assume that the first 100 rows belong to SNPs from chromosome 1,
# the second 100 rows to SNPs from chromosome 2, and so on.

chromosome &lt;- rep(1:20, e = 100)

# Apply knncatimputeLarge to mat chromosomewise, i.e. only consider
# the SNPs that belong to the same chromosome when replacing missing
# genotypes.

mat4 &lt;- knncatimputeLarge(mat, fac = chromosome)


## End(Not run)</code></pre>

<hr>
<h2 id='pamCat'>Prediction Analysis of Categorical Data</h2><span id='topic+pamCat'></span><span id='topic+print.pamCat'></span>

<h3>Description</h3>

<p>Performs a Prediction Analysis of Categorical Data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamCat(data, cl, theta = NULL, n.theta = 10, newdata = NULL, newcl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pamCat_+3A_data">data</code></td>
<td>
<p>a numeric matrix composed of the integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the number of levels each of the variables represented
by the rows of <code>data</code> must take. No missing values allowed.</p>
</td></tr>
<tr><td><code id="pamCat_+3A_cl">cl</code></td>
<td>
<p>a numeric vector of length <code>ncol(data)</code> comprising the class labels of
the observations represented by the columns of <code>data</code>. <code>cl</code> must consist
of the integers between 1 and <code class="reqn">n_{cl}</code>, where <code class="reqn">n_{cl}</code> is the number
of classes.</p>
</td></tr>
<tr><td><code id="pamCat_+3A_theta">theta</code></td>
<td>
<p>a numeric vector consisting of the strictly positive values of the shrinkage parameter used
in the Prediction Analysis. If <code>NULL</code>, a vector consisting of <code>n.theta</code> values for
the shrinkage parameter are determined automatically.</p>
</td></tr>
<tr><td><code id="pamCat_+3A_n.theta">n.theta</code></td>
<td>
<p>an integer specifying the number of values for the shrinkage parameter of the
Prediction Analysis. Ignored if <code>theta</code> is specified.</p>
</td></tr>
<tr><td><code id="pamCat_+3A_newdata">newdata</code></td>
<td>
<p>a numeric matrix composed of the integers between 1 and <code class="reqn">n_{cat}</code>.
Must have the same number of rows as <code>data</code>, and each row of <code>newdata</code> must contain
the same variable as the corresponding row of <code>data</code>. <code>newdata</code> is employed to
compute the misclassification rates of the Prediction Analysis for the given values of the
shrinkage parameter. If <code>NULL</code>, <code>data</code> is used to determine the misclassification rates.</p>
</td></tr>
<tr><td><code id="pamCat_+3A_newcl">newcl</code></td>
<td>
<p>a numeric vector of length <code>ncol(newdata)</code> that consists of integers between
1 and <code class="reqn">n_{cl}</code>, and specifies the class labels of the observations in <code>newdata</code>.
Must be specified, if <code>newdata</code> is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>pamCat</code> composed of
</p>
<table>
<tr><td><code>mat.chisq</code></td>
<td>
<p>a matrix with <code class="reqn">m</code> rows and <code class="reqn">n_{cl}</code> columns consisting of the
classwise values of Pearson's <code class="reqn">\chi^2</code> statistic for each of the <code class="reqn">m</code> variables.</p>
</td></tr>
<tr><td><code>mat.obs</code></td>
<td>
<p>a matrix with <code class="reqn">m</code> rows and <code class="reqn">n_{cat} * n_{cl}</code> columns
in which each row shows a contingency table between the corresponding variable and <code>cl</code>.</p>
</td></tr>
<tr><td><code>mat.exp</code></td>
<td>
<p>a matrix of the same size as <code>mat.obs</code> containing the numbers of observations
expected under the null hypothesis of an association between the respective variable and <code>cl</code>.</p>
</td></tr>
<tr><td><code>mat.theta</code></td>
<td>
<p>a data frame consisting of the numbers of variables used in the classification
of the observations in <code>newdata</code> and the corresponding misclassification rates for a set of values of
the shrinkage parameter <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>tab.cl</code></td>
<td>
<p>a table summarizing the values of the response, i.e.\ the class labels.</p>
</td></tr>
<tr><td><code>n.cat</code></td>
<td>
<p><code class="reqn">n_{cat}</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). Statistical Analysis of Genotype and Gene Expression Data.
<em>Dissertation</em>, Department of Statistics, University of Dortmund.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.pamCat">predict.pamCat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 2000 rows (variables) and 50 columns.
# Assume that the first 25 observations belong to class 1, and the other
# 50 observations to class 2.

mat &lt;- matrix(sample(3, 100000, TRUE), 2000)
rownames(mat) &lt;- paste("SNP", 1:2000, sep = "")
cl &lt;- rep(1:2, e = 25)

# Apply PAM for categorical data to this matrix, and compute the
# misclassification rate on the training set, i.e. on mat.

pam.out &lt;- pamCat(mat, cl)
pam.out

# Now generate a new data set consisting of 20 observations, 
# and predict the classes of these observations using the
# value of theta that has led to the smallest misclassification
# rate in pam.out.

mat2 &lt;- matrix(sample(3, 40000, TRUE), 2000)
rownames(mat2) &lt;- paste("SNP", 1:2000, sep = "")
predict(pam.out, mat2)

# Let's assume that the predicted classes are the real classes
# of the observations. Then, mat2 can also be used in pamCat
# to compute the misclassification rate. 

cl2 &lt;- predict(pam.out, mat2)
pamCat(mat, cl, newdata = mat2, newcl = cl2)


## End(Not run)</code></pre>

<hr>
<h2 id='pcc'>Pearson's Contingency Coefficient</h2><span id='topic+pcc'></span>

<h3>Description</h3>

<p>Computes the values of (the corrected) Pearson's contingency coefficient for
all pairs of rows of a matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcc(x, dist = FALSE, corrected = TRUE, version = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcc_+3A_x">x</code></td>
<td>
<p>a numeric matrix consisting of integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the maximum number of levels a variable in <code>x</code> can take.</p>
</td></tr>
<tr><td><code id="pcc_+3A_dist">dist</code></td>
<td>
<p>should the distance based on Pearson's contingency coefficient be computed?
For how this distance is computed, see <code>version</code>.</p>
</td></tr>
<tr><td><code id="pcc_+3A_corrected">corrected</code></td>
<td>
<p>should Pearson's contingency coefficient be corrected such that it can
take values between 0 and 1? If not corrected, it takes values between and 0
and <code class="reqn">\sqrt{(a - 1) / a}</code>, 
where <code class="reqn">a</code> is the minimum of the numbers of levels that the respective
two variables can take. Must be set to <code>TRUE</code>, if <code>dist = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pcc_+3A_version">version</code></td>
<td>
<p>a numeric value &ndash; either 1, 2, or 3 &ndash; specifying how the distance is computed.
Ignored if <code>dist = FALSE</code>. If <code>1</code>, <code class="reqn">\sqrt{1 - Cont^2}</code> is computed,
where <code class="reqn">Cont</code> denotes Pearson's contigency coefficient. If 2, <code class="reqn">1 - Cont</code> is determined, and if 3,
<code class="reqn">1 - Cont^2</code> is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>nrow(x)</code> columns and rows containing the values of (or distances based on)
the (corrected) Pearson's contigency coefficient for all pairs of rows of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+smc">smc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 10 rows and 200 columns,
# where the values are randomly drawn from the integers 1, 2, and 3.

mat &lt;- matrix(sample(3, 2000, TRUE), 10)

# For each pair of rows of mat, the value of the corrected Pearson's 
# contingency coefficient is then obtained by

out1 &lt;- pcc(mat)
out1

# and the distances based on this coefficient by

out2 &lt;- pcc(mat, dist = TRUE)
out2

# Note that if version is set to 1 (default) in pcc, then

all.equal(sqrt(1 - out1^2), out2)


## End(Not run)</code></pre>

<hr>
<h2 id='predict.pamCat'>Predict Method for pamCat Objects</h2><span id='topic+predict.pamCat'></span>

<h3>Description</h3>

<p>Predicts the classes of new observations based on a Prediction Analysis of Categorical Data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pamCat'
predict(object, newdata, theta = NULL, add.nvar = FALSE,
   type = c("class", "prob"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pamCat_+3A_object">object</code></td>
<td>
<p>an object of class <code>pamCat</code>.</p>
</td></tr>
<tr><td><code id="predict.pamCat_+3A_newdata">newdata</code></td>
<td>
<p>a numeric matrix consisting of the integers between 1 and <code class="reqn">n_{cat}</code>, where
<code class="reqn">n_{cat}</code> is the number of levels each of the variables in <code>newdata</code> must take. 
Each row of <code>newdata</code> must represent the same variable as the corresponding row in
the matrix <code>data</code> used to produce <code>object</code>.
Each column corresponds to an observation for which the class should be predicted.</p>
</td></tr>
<tr><td><code id="predict.pamCat_+3A_theta">theta</code></td>
<td>
<p>a strictly positive numeric value specifying the value of the shrinkage parameter
of the Prediction Analysis that should be used in the class prediction.
If <code>NULL</code>, then the value of <code>theta</code> will be used that
has led to the smallest misclassification rate in the initial Prediction Analysis generating <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.pamCat_+3A_add.nvar">add.nvar</code></td>
<td>
<p>should the number of variables used in the class prediction be added to the output?</p>
</td></tr>
<tr><td><code id="predict.pamCat_+3A_type">type</code></td>
<td>
<p>either <code>"class"</code> or <code>"prob"</code>. If <code>"class"</code>, then the predicted classes will be returned.
Otherwise, the probabilities for the classes are returned.</p>
</td></tr>
<tr><td><code id="predict.pamCat_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>add.nvar = FALSE</code>, the predicted classes or the class probabilities (depending on <code>type</code>). 
Otherwise, a list consisting of
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>a vector or matrix containing the predicted classes or the class probabilities, respectively.</p>
</td></tr>
<tr><td><code>n.var</code></td>
<td>
<p>the number of variables used in the prediction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). Statistical Analysis of Genotype and Gene Expression Data.
<em>Dissertation</em>, Department of Statistics, University of Dortmund.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pamCat">pamCat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 2000 rows (variables) and 50 columns.
# Assume that the first 25 observations belong to class 1, and the other
# 50 observations to class 2.

mat &lt;- matrix(sample(3, 100000, TRUE), 2000)
rownames(mat) &lt;- paste("SNP", 1:2000, sep = "")
cl &lt;- rep(1:2, e = 25)

# Apply PAM for categorical data to this matrix, and compute the
# misclassification rate on the training set, i.e. on mat.

pam.out &lt;- pamCat(mat, cl)
pam.out

# Now generate a new data set consisting of 20 observations, 
# and predict the classes of these observations using the
# value of theta that has led to the smallest misclassification
# rate in pam.out.

mat2 &lt;- matrix(sample(3, 40000, TRUE), 2000)
rownames(mat2) &lt;- paste("SNP", 1:2000, sep = "")
predict(pam.out, mat2)

# Another theta, say theta = 4, can also be specified.

predict(pam.out, mat2, theta = 4)

# The class probabilities for each observation can be obtained by

predict(pam.out, mat2, theta = 4, type = "prob") 


## End(Not run)</code></pre>

<hr>
<h2 id='predictFBLR'> Predict Case Probabilities with Full Bayesian Logic Regression </h2><span id='topic+predictFBLR'></span>

<h3>Description</h3>

<p>Predicts case probabilities for binary data (usually SNP data dichotomized with
<code>snp2bin</code>) based on an MCMC sample of Bayesian logic regression models
obtained with <code>fblr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictFBLR(file, bin, kmax = 10, int.level = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictFBLR_+3A_file">file</code></td>
<td>
<p>character string naming file where MCMC sample is stored.</p>
</td></tr>
<tr><td><code id="predictFBLR_+3A_bin">bin</code></td>
<td>
<p>matrix of binary variables to make predictions for. One row is one
observation. The number of binary variables has to be the same as used in <code>fblr</code>.</p>
</td></tr>
<tr><td><code id="predictFBLR_+3A_kmax">kmax</code></td>
<td>
<p>the maximum number of allowed logic predictors used in <code>fblr</code>.</p>
</td></tr>
<tr><td><code id="predictFBLR_+3A_int.level">int.level</code></td>
<td>
<p>the maximum number of allowed binaries in a logic predictor 
used in <code>fblr</code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>Vector of length <code>nrow(bin)</code> with predicted case probabilities.
</p>


<h3>Author(s)</h3>

<p> Arno Fritsch, <a href="mailto:arno.fritsch@uni-dortmund.de">arno.fritsch@uni-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fblr">fblr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use fblr on some simulated SNP data
snp &lt;- matrix(rbinom(500 * 20, 2, 0.3), ncol = 20)
bin &lt;- snp2bin(snp)
int &lt;- apply(bin,1,function(x) (x[1] == 1 &amp; x[3] == 0)*1)
case.prob &lt;- exp(-0.5+log(5)*int)/(1+exp(-0.5+log(5)*int))
y &lt;- rbinom(nrow(snp),1,prob=case.prob)
fblr(y, bin, niter=1000, nburn=0)

# Prediction for some new observations 
newbin &lt;- snp2bin(matrix(rbinom(100 * 20, 2, 0.3), ncol = 20))
predictFBLR("fblr_mcmc.txt",newbin)


## End(Not run)
</code></pre>

<hr>
<h2 id='recodeAffySNP'>Recoding of Affymetrix SNP Values</h2><span id='topic+recodeAffySNP'></span>

<h3>Description</h3>

<p>Recodes the values used on Affymetrix SNP chips to code the genotypes to
other values &ndash; required, e.g., by other functions of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeAffySNP(mat, refAA = FALSE, geno = 1:3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recodeAffySNP_+3A_mat">mat</code></td>
<td>
<p>a matrix or data frame consisting of the character strings <code>"AA"</code>, <code>"AB"</code>,
<code>"BB"</code>. Missing values can be coded by either <code>"NN"</code> or <code>NA</code>. Each
row is assumed to correspond to a variable, and each column to a microarray.</p>
</td></tr>
<tr><td><code id="recodeAffySNP_+3A_refaa">refAA</code></td>
<td>
<p>codes <code>"AA"</code> always for the homozygous reference genotype? If
<code>TRUE</code>, <code>"AA"</code> is always replaced by <code>geno[1]</code>, and <code>"BB"</code> by
<code>geno[3]</code>. If <code>FALSE</code>, it is evaluated rowwise whether <code>"AA"</code> or
<code>"BB"</code> occurs more often, and the more frequently occuring value is set to <code>geno[1]</code>.</p>
</td></tr>
<tr><td><code id="recodeAffySNP_+3A_geno">geno</code></td>
<td>
<p>a numeric or character vector of length 3 giving the three values that
should be used to recode the genotypes. By default, <code>geno = 1:3</code> which is the
coding, e.g., required by <code><a href="#topic+rowChisqStats">rowChisqStats</a></code> or <code><a href="#topic+pamCat">pamCat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as <code>mat</code> containing the recoded genotypes. (Missing values are
coded by <code>NA</code>.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recodeSNPs">recodeSNPs</a></code>, <code><a href="#topic+snp2bin">snp2bin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a sample data set consisting of 10 rows and 12 columns,
# and randomly replace 5 of the values by "NN".

mat &lt;- matrix("", 10, 12)
mat[1:5,] &lt;- sample(c("AA", "AB", "BB"), 60, TRUE,
   prob = c(0.49, 0.42, 0.09))
mat[6:10,] &lt;- sample(c("AA", "AB", "BB"), 60, TRUE,
   prob = c(0.09, 0.42, 0.49))
mat[sample(120, 5)] &lt;- "NN"
mat

# Recode the SNPs.

recodeAffySNP(mat)

# Recode the SNPs assuming that "A" is always the major allele.

recodeAffySNP(mat, refAA = TRUE)


## End(Not run)</code></pre>

<hr>
<h2 id='recodeSNPs'>Recoding of SNP Values</h2><span id='topic+recodeSNPs'></span>

<h3>Description</h3>

<p>Recodes the values used to specify the genotypes of the SNPs to
other values. Such a recoding might be required to use other
functions contained in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeSNPs(mat, first.ref = FALSE, geno = 1:3, snp.in.col = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recodeSNPs_+3A_mat">mat</code></td>
<td>
<p>a matrix or data frame consisting of character strings of length 2 that
specify the genotypes of the SNPs. Each of these character strings
must be a combination of the letters A, T, C, and G. Missing values can
be specified by <code>"NN"</code> or <code>NA</code>. Depending on
<code>snp.in.col</code> it is assumed that each row of <code>mat</code> represents
a SNP and each column a variable (<code>snp.in.col = FALSE</code>), or vice versa.</p>
</td></tr>
<tr><td><code id="recodeSNPs_+3A_first.ref">first.ref</code></td>
<td>
<p>does the first letter in the string coding the heterozygous
genotype always stands for the more frequent allele? E.g., codes <code>"CC"</code>
for the homozygous reference genotype if the genotypes
of a SNP are coded by <code>"CC"</code>, <code>"CG"</code> and <code>"GG"</code>? If <code>TRUE</code>,
the value made up only of this first letter is set to <code>geno[1]</code>, and the
value made up only of the second letter is set to <code>geno[3]</code>. If <code>FALSE</code>,
it is evaluated rowwise which of the homozygous genotypes has the higher frequency
and the more often occuring value is set to <code>geno[1]</code>, and the other to <code>geno[3]</code>.</p>
</td></tr>
<tr><td><code id="recodeSNPs_+3A_geno">geno</code></td>
<td>
<p>a numeric or character vector of length 3 giving the three values that
should be used to recode the genotypes. By default, <code>geno = 1:3</code> which is the
coding, e.g., required by <code><a href="#topic+rowChisqStats">rowChisqStats</a></code> or <code><a href="#topic+pamCat">pamCat</a></code>.</p>
</td></tr>
<tr><td><code id="recodeSNPs_+3A_snp.in.col">snp.in.col</code></td>
<td>
<p>does each column of <code>mat</code> correspond to a SNP (and each row to an array)?
If <code>FALSE</code>, it is assumed that each row represents a SNP, and each column an array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as <code>mat</code> containing the recoded genotypes. (Missing values are
coded by <code>NA</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recodeAffySNP">recodeAffySNP</a></code>, <code><a href="#topic+snp2bin">snp2bin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate an example data set consisting of 5 rows and 12 columns,
# where it is assumed that each row corresponds to a SNP.

mat &lt;- matrix("", 10, 12)
mat[c(1, 4, 6),] &lt;- sample(c("AA", "AT", "TT"), 18, TRUE)
mat[c(2, 3, 10),] &lt;- sample(c("CC", "CG", "GG"), 18, TRUE)
mat[c(5, 8),] &lt;- sample(c("GG", "GT", "TT"), 12, TRUE)
mat[c(7, 9),] &lt;- sample(c("AA", "AC", "CC"), 12, TRUE)
mat

# Recode the SNPs

recodeSNPs(mat)

# Recode the SNPs by assuming that the first letter in
# the heterogyzous genotype refers to the major allele.

recodeSNPs(mat, first.ref = TRUE)


## End(Not run)</code></pre>

<hr>
<h2 id='rowCATTs'>Rowwise Cochran-Armitage Trend Test Based on Tables</h2><span id='topic+rowCATTs'></span>

<h3>Description</h3>

<p>Given two matrices, each representing one group of subjects (e.g.,
cases and controls in a case-control study), that summarize the numbers 
of subjects showing the different (ordered) levels of the ordinal variables 
represented by the rows of the matrices, the value of the Cochran-Armitage
Trend Test statistic is computed for each variable.
</p>
<p>Using this function instead of <code>rowTrendStats</code> is in particular recommended
when the total number of observations is very large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCATTs(cases, controls, scores = NULL, add.pval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCATTs_+3A_cases">cases</code></td>
<td>
<p>a numeric matrix in which each row represents one ordinal
variable and each column one of the ordered levels that the variables exhibit. The
entries of this matrix are the numbers of observations from one group (e.g.,
the cases in a case-control study) showing a particular
level at the different variables. Such a matrix can, e.g., be generated
by <code><a href="#topic+rowTables">rowTables</a></code>. The rowwise sums of <code>cases</code> are allowed to
differ between variables (which might happen when some of the observations
are missing for some of the variables).</p>
</td></tr>
<tr><td><code id="rowCATTs_+3A_controls">controls</code></td>
<td>
<p>a numeric matrix of the same dimensions as <code>cases</code> comprising
the numbers of observations from the second group (e.g., the controls in a
case-control study) that show the respective level at the different ordinal variables.
The rows of <code>controls</code> must represent the same variables in the same
order as <code>cases</code>, and the columns must represent the same levels in the
same order. This matrix can also be generated by employing <code><a href="#topic+rowTables">rowTables</a></code>.
The rowwise sums of <code>controls</code> are allowed to
differ between variables (which might happen when some of the observations
are missing for some of the variables).</p>
</td></tr>
<tr><td><code id="rowCATTs_+3A_scores">scores</code></td>
<td>
<p>a numeric vector of length <code>ncol(cases)</code> containing the scores
for the different levels. If not specified, i.e.\ <code>NULL</code>, the column names
of <code>cases</code> are interpreted as scores.</p>
</td></tr>
<tr><td><code id="rowCATTs_+3A_add.pval">add.pval</code></td>
<td>
<p>should p-values be added to the output? If <code>FALSE</code>, only the
rowwise values of the Cochran-Armitage trend test statistic will be returned. If <code>TRUE</code>,
additionally the (raw) p-values based on an approximation to the ChiSquare-distribution
with 1 degree of freedom are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector containing the rowwise values of the Cochran-Armitage trend test statistic
(if <code>add.pval = FALSE</code>), or a list containing these values (<code>stats</code>),
and the (raw) p-values (<code>rawp</code>) not adjusted for multiple comparisons (if <code>add.pval = TRUE</code>).
</p>


<h3>Note</h3>

<p>The usual contingency table for a variable can be obtained from the matrices
by forming a variable-specific matrix in which each row consists of the
row of one of these matrices.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

 
<p>Agresti, A.\ (2002). <em>Categorical Data Analysis</em>. Wiley, Hoboken, NJ. 2nd Edition.
</p>
<p>Armitage, P.\ (1955). Tests for Linear Trends in Proportions and Frequencies. 
<em>Biometrics</em>, 11, 375-386.
</p>
<p>Cochran, W.~G.\ (1954). Some Methods for Strengthening the Common ChiSquare Tests.
<em>Biometrics</em>, 10, 417-451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowTrendStats">rowTrendStats</a></code>, <code><a href="#topic+rowMsquares">rowMsquares</a></code>, <code><a href="#topic+rowChisq2Class">rowChisq2Class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

# Now assume that the first 25 columns correspond to
# cases and the remaining 25 columns to cases. Then
# a vector containing the class labels is given by

cl &lt;- rep(1:2, e=25)

# and the matrices summarizing the numbers of subjects
# showing the respective levels at the different variables
# are computed by

cases &lt;- rowTables(mat[, cl==1])
controls &lt;- rowTables(mat[,cl==2])

# The values of the rowwise Cochran-Armitage trend test 
# are computed by

rowCATTs(cases, controls)

# which leads to the same results as

rowTrendStats(mat, cl)

# or as 

out &lt;- rowMsquares(cases, controls)
n &lt;- ncol(mat)
out$stats * n / (n-1)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='rowChisq2Class'>Rowwise Pearson's ChiSquare Test Based on Tables</h2><span id='topic+rowChisq2Class'></span><span id='topic+rowChisqMultiClass'></span>

<h3>Description</h3>

<p>Given a set of matrices, each of which represents one group of subjects, and
summarizes rowwise the numbers of these observations
showing the levels of the categorical variables represented by the rows of
the matrices, the value of Pearson's ChiSquare statistic for testing
whether the distribution of the variable differs between the different
groups is computed for each variable.
</p>
<p>Using this function instead of <code>rowChisqStats</code> is recommended
when the total number of observations is very large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowChisq2Class(cases, controls, add.pval = TRUE, sameNull = FALSE)

rowChisqMultiClass(..., listTables = NULL, add.pval = TRUE,
   sameNull = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowChisq2Class_+3A_cases">cases</code></td>
<td>
<p>a numeric matrix in which each row represents one categorical
variable and each column one of the levels that the variables exhibit. The
entries of this matrix are the numbers of observations from one group (e.g.,
the cases in a case-control study) showing a particular
level at the different variables. Such a matrix can, e.g., be generated
by <code><a href="#topic+rowTables">rowTables</a></code>.The rowwise sums of <code>cases</code> are allowed to
differ between variables (which might happen when some of the observations
are missing for some of the variables).</p>
</td></tr>
<tr><td><code id="rowChisq2Class_+3A_controls">controls</code></td>
<td>
<p>a numeric matrix of the same dimensions as <code>cases</code> comprising
the numbers of observations from the second group (e.g., the controls in a
case-control study) that show the respective level at the different variables.
The rows of <code>controls</code> must represent the same variables in the same
order as <code>cases</code>, and the columns must represent the same levels in the
same order. This matrix can also be generated by employing <code><a href="#topic+rowTables">rowTables</a></code>.
The rowwise sums of <code>controls</code> are allowed to
differ between variables (which might happen when some of the observations
are missing for some of the variables).</p>
</td></tr>
<tr><td><code id="rowChisq2Class_+3A_...">...</code></td>
<td>
<p>numeric matrices (such as <code>cases</code> and <code>controls</code>) each of which
comprises the numbers of observations showing the respective levels at the different
variables. The dimensions of all matrices must be the same, and the rows and columns
must represent the same variables and levels, respectively, in the same order in
all matrices.</p>
</td></tr>
<tr><td><code id="rowChisq2Class_+3A_listtables">listTables</code></td>
<td>
<p>instead of inputting the matrices directly into <code>rowChisqMultiClass</code>
a list can generated, where each entry of this list is one of matrices, and this
list can be used in <code>rowChisqMultiClass</code> by specifying <code>listTables</code>.</p>
</td></tr>
<tr><td><code id="rowChisq2Class_+3A_add.pval">add.pval</code></td>
<td>
<p>should p-values be added to the output? If <code>FALSE</code>, only the
rowwise values of Pearson's ChiSquare statistic will be returned. If <code>TRUE</code>,
additionally the degrees of freedom and the (raw) p-values are computed by assuming
approximation to the ChiSquare-distribution, and added to the output.</p>
</td></tr>
<tr><td><code id="rowChisq2Class_+3A_samenull">sameNull</code></td>
<td>
<p>should all variables follow the same null distribution? If <code>TRUE</code>,
then all variables must show the same number of levels such that their null distribution
is approximated by the same ChiSquare-distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector containing the rowwise values of Pearson's ChiSquare statistic
(if <code>add.pval = FALSE</code>) or a list containing these values (<code>stats</code>),
the degrees of freedom (<code>df</code>), and the p-values (<code>rawp</code>) not adjusted
for multiple comparisons (if <code>add.pval = TRUE</code>).
</p>


<h3>Note</h3>

<p>In the case of a 2 x 2 table, no continuity correction is applied. In this
case, the results of <code>rowChisq2Class</code> and <code>rowChisMultiClass</code> are
only equal to the results of <code>chisq.test</code> if in the latter <code>correct = FALSE</code>
is used.
</p>
<p>The usual contingency table for a variable can be obtained from the matrices
by forming a variable-specific matrix in which each row consists of the
row of one of these matrices.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rowChisqStats">rowChisqStats</a></code>, <code><a href="#topic+rowTables">rowTables</a></code>, <code><a href="#topic+rowCATTs">rowCATTs</a></code>,
<code><a href="#topic+rowMsquares">rowMsquares</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

# Now assume that the first 25 columns correspond to
# cases and the remaining 25 columns to cases. Then
# a vector containing the class labels is given by

cl &lt;- rep(1:2, e=25)

# and the matrices summarizing the numbers of subjects
# showing the respective levels at the different variables
# are computed by

cases &lt;- rowTables(mat[, cl==1])
controls &lt;- rowTables(mat[,cl==2])

# To obtain the ChiSquare values call

rowChisq2Class(cases, controls)

# This leads to the same results as

rowChisqStats(mat, cl)

# or

rowChisqMultiClass(cases, controls)

# or

listTab &lt;- list(cases, controls)
rowChisqMultiClass(listTables = listTab)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='rowChisqStats'>Rowwise Pearson's ChiSquare Statistic</h2><span id='topic+rowChisqStats'></span>

<h3>Description</h3>

<p>Computes for each row of a matrix the value of Pearson's ChiSquare statistic
for testing if the corresponding categorical variable is associated with a (categorical)
response, or determines for each pair of rows of a matrix the value of
Pearson's ChiSquare statistic for testing if the two corresponding variables
are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowChisqStats(data, cl, compPval = TRUE, asMatrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowChisqStats_+3A_data">data</code></td>
<td>
<p>a numeric matrix consisting of the integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the maximum number of levels the categorical variables can
take. Each row of <code>data</code> must correspond to a variable, each row to an observation.
Missing values and different numbers of levels a variable might take are allowed.</p>
</td></tr>
<tr><td><code id="rowChisqStats_+3A_cl">cl</code></td>
<td>
<p>a numeric vector of length <code>ncol(data)</code> containing the class labels for
the observations represented by the columns of <code>data</code>. The class labels must be
coded by the integers between 1 and <code class="reqn">n_{cl}</code>, where <code class="reqn">n_{cl}</code>
is the number of classes. If missing, the value of the statistic for Pearson's
<code class="reqn">\chi^2</code>-test of independence will be computed for each pair of rows
of <code>data</code>. Otherwise, the value of Pearson's <code class="reqn">\chi^2</code>-statistic
for testing if the distribution of the variable differs between the groups specified
by <code>cl</code> will be determined for each row of <code>data</code>.</p>
</td></tr>
<tr><td><code id="rowChisqStats_+3A_comppval">compPval</code></td>
<td>
<p>should also the p-value (based on the approximation to a 
<code class="reqn">\chi^2</code>-distribution) be computed?</p>
</td></tr>
<tr><td><code id="rowChisqStats_+3A_asmatrix">asMatrix</code></td>
<td>
<p>should the pairwise test scores be returned as matrix? Ignored
if <code>cl</code> is specified. If <code>TRUE</code>,
a matrix with <code class="reqn">m</code> rows and columns is returned that contains the values
of Pearson's <code class="reqn">\chi^2</code>-statistic in its lower triangle, where <code class="reqn">m</code>
is the number of variables. If <code>FALSE</code>,
a vector of length <code class="reqn">m * (m - 1) / 2</code> is returned, where the value for
testing the <code class="reqn">i</code>th and <code class="reqn">j</code>th variable is given by the
<code class="reqn">j + m * (i - 1) - i * (i - 1) / 2</code> element of this vector.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>If <code>compPval = FALSE</code>, a vector (or matrix if <code>cl</code> is not specified and
<code>as.matrix = TRUE</code>) composed of the values of Pearson's <code class="reqn">\chi^2</code>-statistic.
Otherwise, a list consisting of
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>a vector (or matrix) containing the values of Pearson's <code class="reqn">\chi^2</code>-statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a vector (or matrix) comprising the degrees of freedom of the asymptotic
<code class="reqn">\chi^2</code>-distribution.</p>
</td></tr>
<tr><td><code>rawp</code></td>
<td>
<p>a vector (or matrix) containing the (unadjusted) p-values.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>Contrary to <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, currently no continuity correction is done 
for 2 x 2 tables.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H.\ (2007). A Note on the Simultaneous Computation of Thousands of 
Pearson's <code class="reqn">\chi^2</code>-Statistics. <em>Technical Report</em>, SFB 475,
Deparment of Statistics, University of Dortmund. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeContCells">computeContCells</a></code>, <code><a href="#topic+computeContClass">computeContClass</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate an example data set consisting of 5 rows (variables)
# and 200 columns (observations) by randomly drawing integers 
# between 1 and 3.

mat &lt;- matrix(sample(3, 1000, TRUE), 5)
rownames(mat) &lt;- paste("SNP", 1:5, sep = "")

# For each pair of rows of mat, test if they are independent.

r1 &lt;- rowChisqStats(mat)

# The values of Pearson's ChiSquare statistic as matrix.

r1$stats

# And the corresponding (unadjusted) p-values.

r1$rawp

# Obtain only the values of the test statistic as vector

rowChisqStats(mat, compPval = FALSE, asMatrix =FALSE)


# Generate an example data set consisting of 10 rows (variables)
# and 200 columns (observations) by randomly drawing integers 
# between 1 and 3, and a vector of class labels of length 200
# indicating that the first 100 observation belong to class 1
# and the other 100 to class 2. 

mat2 &lt;- matrix(sample(3, 2000, TRUE), 10)
cl &lt;- rep(1:2, e = 100)

# For each row of mat2, test if they are associated with cl.

r2 &lt;- rowChisqStats(mat2, cl)
r2$stats

# And the results are identical to the one of chisq.test
pv &lt;- stat &lt;- numeric(10)
for(i in 1:10){
    tmp &lt;- chisq.test(mat2[i,], cl)
    pv[i] &lt;- tmp$p.value
    stat[i] &lt;- tmp$stat
}

all.equal(r2$stats, stat)
all.equal(r2$rawp, pv)


## End(Not run)</code></pre>

<hr>
<h2 id='rowCors'>Rowwise Correlation with a Vector</h2><span id='topic+rowCors'></span>

<h3>Description</h3>

<p>Computes Pearson's correlation coefficient of a vector with each row of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCors(X, y, trendStat = FALSE, use.n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCors_+3A_x">X</code></td>
<td>
<p>a numeric matrix in which each row represents a variable and each
column an observation.</p>
</td></tr>
<tr><td><code id="rowCors_+3A_y">y</code></td>
<td>
<p>a numeric vector of length <code>ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="rowCors_+3A_trendstat">trendStat</code></td>
<td>
<p>instead of the correlation coefficients should the values of
the statistic for a test of linear trend based on this coefficient be returned?
If <code>TRUE</code>, then it is assumed that all variables in <code>X</code> and the 
variable represented by <code>y</code> are ordinal, and the values in <code>X</code> and <code>y</code>
represent scores for the different levels.</p>
</td></tr>
<tr><td><code id="rowCors_+3A_use.n">use.n</code></td>
<td>
<p>should the squared values of the correlation coefficient be multiplied
by <code>ncol(X)</code>? Ignored if <code>trendStat = FALSE</code>. If <code>FALSE</code>, the
squared values are multiplied by <code>ncol(X) - 1</code>. By default, the squared values
are multiplied by <code>ncol(X)</code> if <code>y</code> shows two levels, leading to
the Cochran-Armitage test of trend. Otherwise, they are multiplied by <code>ncol(X) - 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the rowwise values of Pearson's correlation coefficient (if
<code>trendStat = FALSE</code> or the rowwise values of the trend statistics (if
<code>trendStat = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

 
<p>Agresti, A.\ (2002). <em>Categorical Data Analysis</em>. Wiley, Hoboken, NJ. 2nd Edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowTrendStats">rowTrendStats</a></code>, <code><a href="#topic+rowCATTs">rowCATTs</a></code>, <code><a href="#topic+rowMsquares">rowMsquares</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random matrix containing 10 continuous variables
# and a vector representing a continuous variable.

mat &lt;- matrix(runif(200, 0, 20), 10)
y &lt;- sample(runif(20, 0, 20))

# The correlations between y and each of row of mat are
# computed by

rowCors(mat, y)

# Generate a random binary vector and a matrix consisting
# of 10 ordinal variables with levels 0, 1, 2, where these 
# values can be interpreted as scores for the differ 
# categories.

mat &lt;- matrix(sample(0:2, 500, TRUE), 10)
y &lt;- sample(0:1, 50, TRUE)

# The values of the Cochran-Armitage trend statistic are
# computed by

rowCors(mat, y, trendStat = TRUE)

# If the values of the general test of linear trend described
# on page 87 of Agresti (2002) should be computed, then call

rowCors(mat, y, trendStat = TRUE, use.n = FALSE) 


## End(Not run)</code></pre>

<hr>
<h2 id='rowFreqs'>Rowwise Frequencies</h2><span id='topic+rowFreqs'></span>

<h3>Description</h3>

<p>Computes the frequencies of the levels that the categorical variables
in a matrix show.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowFreqs(x, levels = 1:3, divide.by.n = FALSE, affy = FALSE,
   includeNA = FALSE, useNN = c("not", "only", "also"), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowFreqs_+3A_x">x</code></td>
<td>
<p>a matrix in which each row represents a categorical variable (e.g., a SNP)
and each column an observation, where the variables are assumed to show the
levels specified by <code>levels</code>. Missing values are allowed in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_levels">levels</code></td>
<td>
<p>vector specifying the levels that the categorical variables in <code>x</code>
show. Ignored if <code>affy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_divide.by.n">divide.by.n</code></td>
<td>
<p>should the numbers of observations showing the respective levels
be divided by the total number of observations, i.e.\ by <code>ncol(x)</code>? If <code>FALSE</code>,
these numbers are divided by the number of non-missing values of the respective variable.
Ignored if <code>includeNA = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_affy">affy</code></td>
<td>
<p>logical specifying whether the SNPs in <code>x</code> are coded in the Affymetrix
standard way. If <code>TRUE</code>, <code>levels = c("AA", "AB", "BB")</code> and <code>useNN = "also"</code>
will be used (the latter only when <code>includeNA = TRUE</code>).</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_includena">includeNA</code></td>
<td>
<p>should a column be added to the output matrix containing the number of
missing values for each variable?</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_usenn">useNN</code></td>
<td>
<p>character specifying whether missing values can also be coded by <code>"NN"</code>.
If <code>useNN = "not"</code> (default), missing values are assumed to be coded only by <code>NA</code>.
If <code>"only"</code>, then missing values are assumed to be coded only by <code>"NN"</code> (and not
by <code>NA</code>. If <code>"both"</code>, both <code>"NN"</code> and <code>NA</code> are considered. Ignored
if <code>affy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowFreqs_+3A_check">check</code></td>
<td>
<p>should it be checked whether some of the variables show other levels than the one
specified by <code>levels</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same number of rows as <code>x</code> containing for each variable the numbers
of observations showing the levels specified by <code>levels</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rowTables">rowTables</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

rowFreqs(mat)

# leads to the same results as 

rowTables(mat) / ncol(mat)

# If mat contains missing values

mat[sample(500, 20)] &lt;- NA

# then

rowFreqs(mat)

# leads to the same result as

rowTables(mat) / rowSums(!is.na(mat))


## End(Not run)</code></pre>

<hr>
<h2 id='rowHWEs'>Rowwise Test for Hardy-Weinberg Equilibrium</h2><span id='topic+rowHWEs'></span>

<h3>Description</h3>

<p>Tests for each row of a matrix whether the Hardy-Weinberg Equilibrium holds for the SNP
represented by the row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowHWEs(x, levels = 1:3, affy = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowHWEs_+3A_x">x</code></td>
<td>
<p>a matrix in which each row represents a SNP and each column a subject,
where the SNPs can take the values specified by <code>levels</code>. NAs are allowed.</p>
</td></tr>
<tr><td><code id="rowHWEs_+3A_levels">levels</code></td>
<td>
<p>a vector of length three specifying the values with which the three
genotypes of each SNP are represented. It is assumed that the second element of
<code>levels</code> represents the heterozygous genotype, whereas the first and the
third element represent the homozygous genotypes. Ignored if <code>affy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowHWEs_+3A_affy">affy</code></td>
<td>
<p>logical specifying whether the SNPs in <code>x</code> are coded as in the Affymetrix
standard output. If <code>TRUE</code>, <code>levels = c("AA", "AB", "BB")</code> will be used.</p>
</td></tr>
<tr><td><code id="rowHWEs_+3A_check">check</code></td>
<td>
<p>should some checks be done if, e.g., other than the specified <code>levels</code>
are used in <code>x</code>? It is highly recommended to leave <code>check = TRUE</code>. Setting
<code>check = FALSE</code> will reduce the computation time slightly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of the ChiSquare statistic for testing for deviation from HWE
(<code>stats</code>) and the raw p-values (<code>rawp</code>) computed by employing the ChiSquare distribution
with 1 degree of freedom.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a>
</p>

<hr>
<h2 id='rowMAFs'>
Rowwise Minor Allele Frequency
</h2><span id='topic+rowMAFs'></span>

<h3>Description</h3>

<p>Computes for each SNP represented by a row of a matrix the frequency of the minor allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMAFs(x, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMAFs_+3A_x">x</code></td>
<td>
<p>a matrix in which each row represents a SNP and each column a subject,
where the genotypes of each SNP are coded by 1 (for the homozygous reference genotype),
2 (heterozygous), and 3 (homozygous variant). NAs are also allowed.</p>
</td></tr>
<tr><td><code id="rowMAFs_+3A_check">check</code></td>
<td>
<p>should it be checked if the matrix contains values differing from 1, 2, and 3?
It is highly recommended to leave <code>check = TRUE</code>. Setting <code>check = FALSE</code>
reduces the computation time only slightly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the minor allele frequency of the SNPs represented by <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a>
</p>

<hr>
<h2 id='rowMsquares'>Rowwise Linear Trend Test Based on Tables</h2><span id='topic+rowMsquares'></span>

<h3>Description</h3>

<p>Given a set of matrices, each representing one group of subjects (e.g.,
cases and controls in a case-control study), that summarize the numbers 
of subjects showing the different levels of the categorical variables 
represented by the rows of the matrices, the value of the linear trend statistic
based on Pearson's correlation coefficient and described on page 87 of Agresti (2002)
is computed for each variable.
</p>
<p>Using this function instead of <code>rowTrendStats</code> is in particular recommended
when the total number of observations is very large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMsquares(..., listTables = NULL, clScores = NULL, levScores = NULL,
   add.pval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMsquares_+3A_...">...</code></td>
<td>
<p>numeric matrices in each of which each row corresponds to a ordinal variable
and each column to one of the ordered levels of these variables. Each of these matrices
represents one of the groups of interest and comprises the numbers of observations showing 
the respective levels at the different variables. These matrices can, e.g., generated by
employing <code><a href="#topic+rowTables">rowTables</a></code>. The dimensions of all matrices must be the same, and 
the rows and columns must represent the same variables and levels, respectively, in the 
same order in all matrices. The rowwise sums in a matrix are allowed to differ (which might
happen if some of the observations are missing for some of the variables.)</p>
</td></tr>
<tr><td><code id="rowMsquares_+3A_listtables">listTables</code></td>
<td>
<p>instead of inputting the matrices directly,
a list consisting of these matrices can be generated and then be used in <code>rowMsquares</code> 
by specifying <code>listTables</code>.</p>
</td></tr>
<tr><td><code id="rowMsquares_+3A_clscores">clScores</code></td>
<td>
<p>a numeric vector with one entry for each matrix specifying the score that should
be assigned to the corresponding group. If <code>NULL</code>, <code>clScores</code> is set to <code>1:m</code>,
where <code class="reqn">m</code> is the number of groups/matrices, such that the first input matrix (or the first
entry in <code>listTables</code>) gets a score of 1, the second a score of 2, and so on.</p>
</td></tr>
<tr><td><code id="rowMsquares_+3A_levscores">levScores</code></td>
<td>
<p>a numeric vector with one score for each level of the variables.If not specified, 
i.e.\ <code>NULL</code>, the column names of the matrices are interpreted as scores.</p>
</td></tr>
<tr><td><code id="rowMsquares_+3A_add.pval">add.pval</code></td>
<td>
<p>should p-values be added to the output? If <code>FALSE</code>, only the
rowwise values of the linear trend test statistic will be returned. If <code>TRUE</code>,
additionally the (raw) p-values based on an approximation to the ChiSquare-distribution
with 1 degree of freedom are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an extension of the Cochran-Armitage trend test from two to several classes. The
statistic of the Cochran-Armitage trend test can be obtained by multiplying the statistic
of this general linear trend test with <code class="reqn">n / (n - 1)</code>, where <code class="reqn">n</code> is the number
of observations.
</p>


<h3>Value</h3>

<p>Either a vector containing the rowwise values of the linear trend test statistic
(if <code>add.pval = FALSE</code>), or a list containing these values (<code>stats</code>),
and the (raw) p-values (<code>rawp</code>) not adjusted for multiple comparisons (if <code>add.pval = TRUE</code>).
</p>


<h3>Note</h3>

<p>The usual contingency table for a variable can be obtained from the matrices
by forming a variable-specific matrix in which each row consists of the
row of one of these matrices.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

 
<p>Agresti, A.\ (2002). <em>Categorical Data Analysis</em>. Wiley, Hoboken, NJ. 2nd Edition.
</p>
<p>Mantel, N.\ (1963). Chi-Square Test with one Degree of Freedom: Extensions of the Mantel-Haenszel
Procedure. <em>Journal of the American Statistical Association</em>, 58, 690-700.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowTrendStats">rowTrendStats</a></code>, <code><a href="#topic+rowCATTs">rowCATTs</a></code>, <code><a href="#topic+rowChisqMultiClass">rowChisqMultiClass</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

# Now assume that we consider a case-control study,
# i.e. two groups, and that the first 25 columns 
# of mat correspond to cases and the remaining 25 
# columns to cases. Then a vector containing the 
# class labels is given by

cl &lt;- rep(1:2, e=25)

# and the matrices summarizing the numbers of subjects
# showing the respective levels at the different variables
# are computed by

cases &lt;- rowTables(mat[, cl==1])
controls &lt;- rowTables(mat[,cl==2])

# The values of the rowwise liner trend test are
# computed by

rowMsquares(cases, controls)

# which leads to the same results as

listTab &lt;- list(cases, controls)
rowMsquares(listTables = listTab)

# or as

rowTrendStats(mat, cl, use.n = FALSE)

# or as

out &lt;- rowCATTs(cases, controls)
n &lt;- ncol(mat)
out$stats * (n - 1) / n

 
## End(Not run)
</code></pre>

<hr>
<h2 id='rowScales'>Rowwise Scaling</h2><span id='topic+rowScales'></span>

<h3>Description</h3>

<p>Scales each row of a matrix such that the values in this row have
zero mean and a standard deviation of 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowScales(X, add.stats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowScales_+3A_x">X</code></td>
<td>
<p>a numeric matrix whose rows should be scaled. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="rowScales_+3A_add.stats">add.stats</code></td>
<td>
<p>should the rowwise means and standard deviations of <code>X</code>
be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>add.stats = FALSE</code>, a matrix of the same dimensions as <code>X</code>
with a rowwise mean of zero and a rowwise standard deviation of 1.
If <code>add.stats = TRUE</code>, a list containing this matrix and the
rowwise means and standard deviations of the input matrix.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rowCors">rowCors</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

rowScales(mat)


## End(Not run)</code></pre>

<hr>
<h2 id='rowTables'>Rowwise Tables</h2><span id='topic+rowTables'></span>

<h3>Description</h3>

<p>Computes a one-dimensional table for each row of a matrix that summarizes
the values of the categorical variables represented by the rows of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowTables(x, levels = 1:3, affy = FALSE, includeNA = FALSE,
   useNN = c("not", "only", "also"), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowTables_+3A_x">x</code></td>
<td>
<p>a matrix in which each row represents a categorical variable (e.g., a SNP)
and each column an observation, where the variables are assumed to show the
levels specified by <code>levels</code>. Missing values are allowed in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rowTables_+3A_levels">levels</code></td>
<td>
<p>vector specifying the levels that the categorical variables in <code>x</code>
show. Ignored if <code>affy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowTables_+3A_affy">affy</code></td>
<td>
<p>logical specifying whether the SNPs in <code>x</code> are coded in the Affymetrix
standard way. If <code>TRUE</code>, <code>levels = c("AA", "AB", "BB")</code> and <code>useNN = "also"</code>
will be used (the latter only when <code>includeNA = TRUE</code>).</p>
</td></tr>
<tr><td><code id="rowTables_+3A_includena">includeNA</code></td>
<td>
<p>should a column be added to the output matrix containing the number of
missing values for each variable?</p>
</td></tr>
<tr><td><code id="rowTables_+3A_usenn">useNN</code></td>
<td>
<p>character specifying whether missing values can also be coded by <code>"NN"</code>.
If <code>useNN = "not"</code> (default), missing values are assumed to be coded only by <code>NA</code>.
If <code>"only"</code>, then missing values are assumed to be coded only by <code>"NN"</code> (and not
by <code>NA</code>. If <code>"both"</code>, both <code>"NN"</code> and <code>NA</code> are considered. Ignored
if <code>affy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowTables_+3A_check">check</code></td>
<td>
<p>should it be checked whether some of the variables show other levels than the one
specified by <code>levels</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same number of rows as <code>x</code> containing for each variable the numbers
of observations showing the levels specified by <code>levels</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rowFreqs">rowFreqs</a></code>, <code><a href="#topic+rowScales">rowScales</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

rowTables(mat)


## End(Not run)</code></pre>

<hr>
<h2 id='rowTrendFuzzy'>
Trend Test for Fuzzy Genotype Calls
</h2><span id='topic+rowTrendFuzzy'></span><span id='topic+getMatFuzzy'></span>

<h3>Description</h3>

<p><code>rowTrendFuzzy</code> performs the trend test proposed by Louis et al. (2010) based on fuzzy genotype calls, i.e. the weighted sums
over the confidences for the three genotypes as they are determined by preprocessing algorithms (e.g., CRLMM)
or imputation procedures.
</p>
<p>Given the confidences and scores for all three genotypes, <code>getMatFuzzy</code> constructs a matrix containing the fuzzy genotype calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowTrendFuzzy(score, probs, y, mat.fuzzy = NULL, 
    alternative = c("two.sided", "less", "greater"), 
    check = TRUE)
    
getMatFuzzy(score, probs, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowTrendFuzzy_+3A_score">score</code></td>
<td>
<p>either a numeric vector of length 2 or 3, or a character string. 
</p>
<p>If the latter, <code>score</code> must
be either <code>"additive"</code>, <code>"dominant"</code>, <code>"recessive"</code>, or an abbreviation of these terms. If 
<code>score = "additive"</code>, then <code>score</code> is set to <code>c(0, 1, 2)</code>. If <code>score = "dominant"</code>,
then <code>score</code> is set to <code>c(0, 1, 1)</code>. And if <code>score = "recessive"</code>, <code>score</code> is set to <code>c(0, 0, 1)</code>.
</p>
<p>If <code>score</code> is a numeric vector of length 2, then the first value must be the score for the heterozygous genotype,
and the second value the score for the homozygous variant genotype. If <code>score</code> is of length, the first entry of
this vector must be a zero (the score for the homozygous reference genotype), followed by the scores for the heterozygous
and homozygous variant genotype.
</p>
</td></tr>
<tr><td><code id="rowTrendFuzzy_+3A_probs">probs</code></td>
<td>
<p>a list of length 2 or 3 consisting of matrices of the same size. Each matrix must contain the confidences
for one of the three genotypes, where each row in the matrix represents a SNP and each column a sample (which must be in the same
order in all matrices). The matrices in <code>probs</code> correspond to the scores in <code>score</code>. Thus, if <code>probs</code> has
length 2, then the first matrix must contain the confidences for the heterozygous genotype, and the second matrix the confidences
for the homozygous variant genotype. All elementwise sums of these two matrices must be smaller than or equal to 1. 
If <code>probs</code> has length 3, the first object must be a matrix containing the confidences
for the homozygous reference genotype, followed by the two other matrices comprising the confidences for the heterozygous and
homozygous variant genotype. All elementwise sums of the three matrices must be equal to 1. 
</p>
</td></tr>
<tr><td><code id="rowTrendFuzzy_+3A_y">y</code></td>
<td>
<p>a vector of zeros and ones specifying which of the samples in the matrices in <code>probs</code> are cases (<code>1</code>) and which
are controls (<code>0</code>).
</p>
</td></tr>
<tr><td><code id="rowTrendFuzzy_+3A_mat.fuzzy">mat.fuzzy</code></td>
<td>
<p>a matrix containing the fuzzy genotype calls. If specified, <code>score</code> and <code>probs</code> are not allowed to be
specified in <code>rowTrendFuzzy</code>. 
If <code>NULL</code>, <code>mat.fuzzy</code> is determined by employing <code>getMatFuzzy</code>, i.e.\ by multiplying the confidences 
in <code>probs</code> with the corresponding
scores in <code>score</code> and computing the elementwise sums over the resulting matrices with the weighted confidences.
</p>
</td></tr>
<tr><td><code id="rowTrendFuzzy_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis. Must be one of <code>"two.sided"</code> (default), 
<code>"greater"</code>, or <code>"less"</code>. Abbreviations (e.g.\ the initial letter) for these choices are also allowed.
</p>
</td></tr>
<tr><td><code id="rowTrendFuzzy_+3A_check">check</code></td>
<td>
<p>logical specifying whether the specified objects should be extensively checked. If <code>FALSE</code>, only some basic
checks are done. It is highly recommended to use <code>check = TRUE</code>, although the checking takes much more computing time
than the determination of the values of the trend test statistic.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>getMatFuzzy</code>, a matrix containing the fuzzy genotype calls. For <code>rowTrendFuzzy</code>, a list consisting of 
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing the values of the trend test statistic for all SNPs comprised by <code>probs</code>,</p>
</td></tr>
<tr><td><code>rawp</code></td>
<td>
<p>a vector containing the unadjusted p-values computed for the values in <code>stat</code> based on a standard normal distribution
and the specification of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a vector containing estimates for the log odds ratios for risk corresponding to <code>stat</code>,</p>
</td></tr>
<tr><td><code>varTheta</code></td>
<td>
<p>a vector containing the variance estimates for <code>theta</code>.</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Louis, T.A., Carvalho, B.S., Fallin, M.D., Irizarry, R.A., Li, Q., and Ruczinski, I. (2010). Association Tests that Accommodate 
Genotyping Errors. In Bernardo, J.M., Bayarri, M.J., Berger, J.O., Dawid, A.P., Heckerman, D., Smith, A.F.M., and West, M. (eds.),
<em>Bayesian Statistics 9</em>, 393-420. Oxford University Press, Oxford, UK. With Discussion. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowTrendStats">rowTrendStats</a></code>, <code><a href="#topic+rowCATTs">rowCATTs</a></code>
</p>

<hr>
<h2 id='rowTrendStats'>Rowwise Linear Trend Tests</h2><span id='topic+rowTrendStats'></span>

<h3>Description</h3>

<p>Computes for each row of a matrix the value of the statistic of a linear trend test
for testing whether the ordinal variable corresponding to the row of the matrix
is associated with an ordinal response. 
</p>
<p>In the two-class case, the statistic of the Cochran-Armitage trend test is computed
by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowTrendStats(X, y, use.n = NULL, add.pval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowTrendStats_+3A_x">X</code></td>
<td>
<p>a numeric matrix in which each row represents an ordinal variable and
each column corresponds to an observation. The entries of this matrix are
interpreted as scores for the different (ordered) levels of the respective variables.</p>
</td></tr>
<tr><td><code id="rowTrendStats_+3A_y">y</code></td>
<td>
<p>a numeric vector of length <code>ncol(X)</code> containing the class labels
of the observations represented by the columns of <code>X</code>, where these labels
are interpreted as scores for the different classes.</p>
</td></tr>
<tr><td><code id="rowTrendStats_+3A_use.n">use.n</code></td>
<td>
<p>should the squared values of Pearson's correlation coefficient be multiplied
by <code>ncol(X)</code> to generate the values of the test statistic? If <code>FALSE</code>, the
squared values are multiplied by <code>ncol(X) - 1</code>. By default, the squared values
are multiplied by <code>ncol(X)</code> if <code>y</code> shows two levels, leading to
the Cochran-Armitage test of trend. Otherwise, they are multiplied by <code>ncol(X) - 1</code>
leading to the linear trend test statistic of Mantel (1963) described, e.g., on page
87 of Agresti (2002).</p>
</td></tr>
<tr><td><code id="rowTrendStats_+3A_add.pval">add.pval</code></td>
<td>
<p>should p-values be added to the output? If <code>FALSE</code>, only the
rowwise values of the linear trend test statistic will be returned. If <code>TRUE</code>,
additionally the (raw) p-values based on an approximation to the ChiSquare-distribution
with 1 degree of freedom are returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

 
<p>Agresti, A.\ (2002). <em>Categorical Data Analysis</em>. Wiley, Hoboken, NJ. 2nd Edition.
</p>
<p>Armitage, P.\ (1955). Tests for Linear Trends in Proportions and Frequencies. 
<em>Biometrics</em>, 11, 375-386.
</p>
<p>Cochran, W.~G.\ (1954). Some Methods for Strengthening the Common ChiSquare Tests.
<em>Biometrics</em>, 10, 417-451.
</p>
<p>Mantel, N.\ (1963). Chi-Square Test with one Degree of Freedom: Extensions of the Mantel-Haenszel
Procedure. <em>Journal of the American Statistical Association</em>, 58, 690-700.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowMsquares">rowMsquares</a></code>, <code><a href="#topic+rowCATTs">rowCATTs</a></code>, <code><a href="#topic+rowChisqMultiClass">rowChisqMultiClass</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a matrix containing data for 10 categorical 
# variables with levels 1, 2, 3.

mat &lt;- matrix(sample(3, 500, TRUE), 10)

# Now assume that the first 25 columns correspond to
# cases and the remaining 25 columns to cases. Then
# a vector containing the class labels is given by

cl &lt;- rep(0:1, e=25)

# The values of the Cochran-Armitage trend test can
# then be computed by

rowTrendStats(mat, cl)

# This leads to the same results as

cases &lt;- rowTables(mat[, cl==1])
controls &lt;- rowTables(mat[,cl==0])

rowCATTs(cases, controls)

# or as

out &lt;- rowMsquares(cases, controls)
n &lt;- ncol(mat)
out$stats * n / (n - 1)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='scrime-internal'>Internal scrime functions</h2><span id='topic+buildSNPmat'></span><span id='topic+canberra2Mats'></span><span id='topic+check4Monomorphism'></span><span id='topic+checkATCG'></span><span id='topic+checkCatMat'></span><span id='topic+checkDist'></span><span id='topic+checkDistMat'></span><span id='topic+checkMatSNP'></span><span id='topic+checkX1X2'></span><span id='topic+chisqClass2'></span><span id='topic+chisqInd'></span><span id='topic+cohen2Mats'></span><span id='topic+compChisqPval'></span><span id='topic+compVarLevs'></span><span id='topic+constructMatCheck'></span><span id='topic+constructMatIA'></span><span id='topic+dist2Mats'></span><span id='topic+euclidean2Mats'></span><span id='topic+evalRedundancy'></span><span id='topic+getBinDomRec'></span><span id='topic+getBinGenotype'></span><span id='topic+getCall'></span><span id='topic+getDistance'></span><span id='topic+getListIdentity'></span><span id='topic+ia.samp'></span><span id='topic+manhattan2Mats'></span><span id='topic+mc2Mats'></span><span id='topic+maximum2Mats'></span><span id='topic+minkowski2Mats'></span><span id='topic+minrc'></span><span id='topic+minrc2Mats'></span><span id='topic+modeDist'></span><span id='topic+pcc2Mats'></span><span id='topic+print.simulatedSNPs'></span><span id='topic+print.simSNPglm'></span><span id='topic+recodeCount'></span><span id='topic+recodeFirst'></span><span id='topic+recodeNoHete'></span><span id='topic+removeRedundancy'></span><span id='topic+replaceNAs'></span><span id='topic+row2col'></span><span id='topic+sample.snpmat'></span><span id='topic+smc2Mats'></span><span id='topic+snp1norm2Mats'></span><span id='topic+weightMode'></span>

<h3>Description</h3>

<p>Internal scrime functions.</p>


<h3>Details</h3>

<p>These functions are not meant to be directly called by the user.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schw@gmx.de">holger.schw@gmx.de</a></p>

<hr>
<h2 id='shortenGeneDescription'>Shorten the Gene Description</h2><span id='topic+shortenGeneDescription'></span>

<h3>Description</h3>

<p>Shortens the entries of the column of a data frame containing the genes
associated with the SNPs for which the data frame comprises annotations.
Typically used in combination with, i.e.\ either within or after an application of,
<code><a href="#topic+buildSNPannotation">buildSNPannotation</a>.</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shortenGeneDescription(dat, colname = "Gene", max.length = 2, 
     sep = "///", add.ldots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortenGeneDescription_+3A_dat">dat</code></td>
<td>
<p>a data frame. Typically, the output of <code><a href="#topic+buildSNPannotation">buildSNPannotation</a></code>.</p>
</td></tr>
<tr><td><code id="shortenGeneDescription_+3A_colname">colname</code></td>
<td>
<p>character string comprising the name of the column of <code>dat</code>
containing the gene description.</p>
</td></tr>
<tr><td><code id="shortenGeneDescription_+3A_max.length">max.length</code></td>
<td>
<p>integer specifying the maximum number of genes associated with the respective
SNP that should be stored in the data frame. By default, the first two genes are retained. 
Shortened entries are marked by <code>...</code> at the end of the entries, when <code>add.ldots = TRUE</code>.</p>
</td></tr>
<tr><td><code id="shortenGeneDescription_+3A_sep">sep</code></td>
<td>
<p>character string specifying the separation symbol between the different genes.</p>
</td></tr>
<tr><td><code id="shortenGeneDescription_+3A_add.ldots">add.ldots</code></td>
<td>
<p>should <code>...</code> be added at the entries which are shortened?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same data frame as <code>dat</code> with shortened entries in the column of <code>dat</code> named <code>colname</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schw@gmx.de">holger.schw@gmx.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+buildSNPannotation">buildSNPannotation</a></code></p>

<hr>
<h2 id='showChanges'>Displaying Changes</h2><span id='topic+showChanges'></span>

<h3>Description</h3>

<p>Shows the content of the file CHANGES stored in a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showChanges(pkg = "scrime")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showChanges_+3A_pkg">pkg</code></td>
<td>
<p>character string naming the package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>

<hr>
<h2 id='simulateSNPcatResponse'>Simulation of SNP Data with Categorical Response</h2><span id='topic+simulateSNPcatResponse'></span><span id='topic+print.simSNPcatResponse'></span>

<h3>Description</h3>

<p>Simulates SNP data. Interactions of some of the simulated SNPs
are then used to specify a categorical response
by level-wise or multinomial logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSNPcatResponse(n.obs = 1000, n.snp = 50, list.ia = NULL,
   list.snp = NULL, withRef = FALSE, beta0 = -0.5, beta = 1.5, 
   maf = 0.25, sample.y = TRUE, rand = NA)
  
## S3 method for class 'simSNPcatResponse'
print(x, justify = c("left", "right"), spaces = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSNPcatResponse_+3A_n.obs">n.obs</code></td>
<td>
<p>number of observations that should be generated.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_n.snp">n.snp</code></td>
<td>
<p>number of SNPs that should be generated.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_list.ia">list.ia</code></td>
<td>
<p>a list consisting of <code class="reqn">n_{cat}</code> objects, where
<code class="reqn">n_{cat}</code> is the number of levels the response should have. If one
interaction of SNPs should be explanatory for a specific level of the response,
then the corresponding object in <code>list.ia</code> must be a numeric vector specifying
the genotypes of the interacting SNPs by the integers -3, -2, -1, 1, 2, or 3, where
1 codes for the homozygous reference genotype, 2 for the heterozygous genotype, and
3 for the homozygous variant genotype, and a minus before these numbers means that
the corresponding SNP should be not of this genotype. If more than one interaction
should be explanatory for a specific category, then the corresponding object of
<code>list.ia</code> must be a list containing one numeric vector composed of the integers
-3, -2, -1, 1, 2, and 3 for each of the interactions.
</p>
<p>If, e.g., one of the
vectors is given by <code>c(1, -1, -3)</code> and the corresponding vector in
<code>list.snp</code> is <code>c(5, 7, 8)</code>, then the corresponding interaction
explanatory for a level of the response is given by
</p>
<p><code>(SNP5 == 1) &amp; (SNP7 != 1) &amp; (SNP8 != 3)</code>.
</p>
<p>For more details, see Details. Must be specified if <code>list.snp</code> is specified.
If both <code>list.ia</code> and <code>list.snp</code> are <code>NULL</code>, then the interactions
shown in the Details section are used. </p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_list.snp">list.snp</code></td>
<td>
<p>a list consisting of numeric vectors (if one interaction should be explanatory
for a level of the response) or lists of numeric vectors (if there should be more than one
explanatory interaction) specifying the SNPs that compose
the interactions. <code>list.snp</code> must have the same structure as <code>list.ia</code>, and each
entry of <code>list.snp</code> must be an integer between 1 and <code>n.snp</code>.
If <code>list.ia</code> is specified but
not <code>list.snp</code>, then the first <code class="reqn">n</code> SNPs are used to generate the interactions,
where <code class="reqn">n</code> is the total number of values in <code>list.ia</code>. For the case that both
<code>list.ia</code> and <code>list.snp</code> are not specified, see Details.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_withref">withRef</code></td>
<td>
<p>should there be an additional reference group (i.e.\ a control group) denoted by a 
zero? If <code>TRUE</code>, a multinomial logistic regression is used to specify the class labels.
If <code>FALSE</code>, level-wise logistic regressions are employed to generate the class labels.
For details, see Details.</p>
</td></tr> 
<tr><td><code id="simulateSNPcatResponse_+3A_beta0">beta0</code></td>
<td>
<p>a numeric value or vector of <code>length(list.ia)</code> specifying the intercept of
the logistic regression models.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_beta">beta</code></td>
<td>
<p>either a non-negative numeric value or a list of non-negative numeric values specifying
the parameters in the logistic regression models. If a numeric value, all parameters (except for
the intercept) in all logistic regression models will be equal to this value. If a list, then
this list must have the same length as <code>list.ia</code>, and each object must consist of as many
numeric values as interactions are specified by the corresponding object in <code>list.ia</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_maf">maf</code></td>
<td>
<p>either an integer, or a vector of length 2 or <code>n.snp</code> specifying the
minor allele frequency. If an integer, all the SNPs will have the same
minor allele frequency. If a vector of length <code>n.snp</code>, each SNP will have the minor
allele frequency specified in the corresponding entry of <code>maf</code>. If length 2, then
<code>maf</code> is interpreted as the range of the minor allele frequencies, and for each SNP,
a minor allele frequency will be randomly drawn from a uniform distribution with
the range given by <code>maf</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_sample.y">sample.y</code></td>
<td>
<p>should the values of the response be randomly drawn using the probabilities
determined by the logistic regression models? If <code>FALSE</code>, then for each of the <code>n.obs</code>
observations, the value of the response is given by the level exhibiting the largest probability
at this observation.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_rand">rand</code></td>
<td>
<p>a numeric value for setting the random number generator in a reproducible state.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_x">x</code></td>
<td>
<p>the output of <code>simulateSNPcatResponse</code></p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_justify">justify</code></td>
<td>
<p>a character string specifying whether the column of the summarizing table that
names the explanatory interactions should be <code>"left"</code>- or <code>"right"</code>-adjusted.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_spaces">spaces</code></td>
<td>
<p>integer specifying the distance from the left end of the column mentioned in <code>justify</code>
to the position at which the column name is presented.</p>
</td></tr>
<tr><td><code id="simulateSNPcatResponse_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simulateSNPcatResponse</code> first simulates a matrix consisting of <code>n.obs</code> observations and <code>n.snp</code>
SNPs, where the minor allele frequencies of these SNPs are given by <code>maf</code>.
</p>
<p>Note that all SNPs are currently simulated independently of each other such that they are unlinked.
Moreover, an observation is currently not allowed to have genotypes/interactions that are explanatory
for more than one of the levels of the response. If, e.g., the response has three categories, then
an observation can either exhibit one (or more) of the genotypes explaining the first level, or
one (or more) of the genotypes explanatory for the second level, or one (or more) of the genotypes
explaining the third level, or none of these genotypes.
</p>
<p>Afterwards, the response is generated by employing the specifications of <code>list.ia</code>,
<code>list.snp</code>, <code>beta0</code> and <code>beta</code>.
</p>
<p>By default, i.e.\ if both <code>list.ia</code> and <code>list.snp</code> are <code>NULL</code>, <code>list.ia</code> is set
to
</p>
<p><code>list(c(-1, 1), c(1, 1, 1), list(c(-1, 1), c(1, 1, 1)))</code>,
</p>
<p>and <code>list.snp</code> is set to
</p>
<p><code>list(c(6, 7), c(3, 9, 10), list(c(2, 5), c(1, 4, 8)))</code>
</p>
<p>such that the interaction
</p>
<p><code>(SNP6 != 1) &amp; (SNP7 == 1)</code>
</p>
<p>is assumed to be explanatory for the first level of the three-categorical response, the interaction
</p>
<p><code>(SNP3 == 1) &amp; (SNP9 == 1) &amp; (SNP10 == 1)</code>
</p>
<p>is assumed to be explanatory for the second level, and the interactions
</p>
<p><code>(SNP2 != 1) &amp; (SNP5 == 1)</code>\ \ \ and
</p>
<p><code>(SNP1 == 1) &amp; (SNP4 == 1) &amp; (SNP8 == 1)</code>,
</p>
<p>are assumed to be explanatory for the third level.
</p>
<p>If <code>withRef = FALSE</code>, then for each of the levels, 
the probability of having this level given that an observation exhibits one, two, ...
of the interactions intended to be explanatory for that level is determined using the corresponding
logistic regression model. Afterwards, the value of the response for an observation showing one, two, ...
of the interactions explanatory for a particular level is randomly drawn using the above probability <code class="reqn">p</code>
for the particular level and <code class="reqn">(1-p)/(n_{cat}-1)</code> as probabilities for the other
<code class="reqn">(n_{cat}-1)</code> levels. If an observation exhibits none of the explanatory interactions,
its response value is randomly drawn using the probabilities <code class="reqn">\exp{beta0}/(1+\exp{beta0})</code>.
</p>
<p>If <code>withRef = TRUE</code>, a multinomial logistic regression is used to specify the class labels. In this
case the probabilities <code class="reqn">p_j</code>, <code class="reqn">j = 1, ..., n.cat</code>, are given by 
<code class="reqn">p_j = \exp(q_j) * p_0</code>, where <code class="reqn">q_j</code> are the probabilities on the
logit-scale (i.e.\ the probabilities on the scale of the linear predictors) and 
<code class="reqn">p_0^{-1} = 1 + p_1 + ... + p_{n.cat}</code> is the reciprocal
of the probability for the control/reference group.  
</p>


<h3>Value</h3>

<p>An object of class <code>simSNPcatResponse</code> consisting of
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a matrix with <code>n.obs</code> rows and <code>n.snp</code> columns containing the simulated SNP values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of length <code>n.obs</code> composed of the values of the response.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>a character vector naming the level-wise logistic regression models.</p>
</td></tr>
<tr><td><code>maf</code></td>
<td>
<p>a vector of length <code>n.snp</code> composed of the minor allele frequencies.</p>
</td></tr>
<tr><td><code>tab.explain</code></td>
<td>
<p>a data frame summarizing the results of the simulation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateSNPs">simulateSNPs</a></code>, <code><a href="#topic+simulateSNPglm">simulateSNPglm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The simulated data set described in Details.

sim1 &lt;- simulateSNPcatResponse()
sim1

# Specifying the values of the response by the levels with
# the largest probability.

sim2 &lt;- simulateSNPcatResponse(sample.y = FALSE)
sim2

# If ((SNP4 != 2) &amp; (SNP3 == 1)), (SNP5 ==3), and
# ((SNP12 !=1) &amp; (SNP9 == 3)) should be the three interactions
# (or variables) that are explanatory for the three levels
# of the response, list.ia and list.snp are specified as follows.

list.ia &lt;- list(c(-2, 1), 3, c(-1,3))
list.snp &lt;- list(c(4, 3), 5, c(12,9))

# The categorical response and a data set consisting of 
# 800 observations and 25 SNPs, where the minor allele
# frequency of each SNP is randomly drawn from a
# uniform distribution with minimum 0.1 and maximum 0.4,
# is then generated by

sim3 &lt;- simulateSNPcatResponse(n.obs = 800, n.snp = 25,
  list.ia = list.ia, list.snp = list.snp, maf = c(0.1, 0.4))
sim3


## End(Not run)</code></pre>

<hr>
<h2 id='simulateSNPglm'>Simulation of SNP data</h2><span id='topic+simulateSNPglm'></span>

<h3>Description</h3>

<p>Simulates SNP data. Interactions of some of the simulated SNPs
are then used to specify either a binary or a
quantitative response by a logistic or linear regression model, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSNPglm(n.obs = 1000, n.snp = 50, list.ia = NULL, list.snp = NULL, 
   beta0 = -0.5, beta = 1.5, maf = 0.25, sample.y = TRUE, p.cutoff = 0.5, 
   err.fun = NULL, rand = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSNPglm_+3A_n.obs">n.obs</code></td>
<td>
<p>number of observations that should be generated.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_n.snp">n.snp</code></td>
<td>
<p>number of SNPs that should be generated.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_list.ia">list.ia</code></td>
<td>
<p>a list consisting of numeric vectors (or values) specifying the genotypes
of the SNPs that should be explanatory for the response. Each of these vectors
must be composed of some of the numbers -3, -2, -1, 1, 2, 3, where 1 denotes
the homozygous reference genotype, 2 the heterozygous genotype, and 3 the
homozygous variant genotype, and a minus before these numbers means that
the corresponding SNP should be not of this genotype. If, e.g., one of the
vectors is given by <code>c(1, -1, -3)</code> and the corresponding vector in
<code>list.snp</code> is <code>c(5, 7, 8)</code>, then the corresponding interaction
used in the regression model to specify the response is
</p>
<p><code>(SNP5 == 1) &amp; (SNP7 != 1) &amp; (SNP8 != 3)</code>. 
</p>
<p>For more details, see Details. Must be specified if <code>list.snp</code> is specified. 
If both <code>list.ia</code> and <code>list.snp</code> are <code>NULL</code>, then the interactions
shown in the Details section are used.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_list.snp">list.snp</code></td>
<td>
<p>a list consisting of numeric vectors specifying the SNPs that compose
the interactions used in the regression model. Each of these vectors must have the
same length as the corresponding vector in <code>list.ia</code>, and  must consist
of integers between 1 and <code>n.snp</code>, where the integer <code class="reqn">i</code> corresponds to
the <code class="reqn">i</code>th column of the simulated SNP matrix. If <code>list.ia</code> is specified but
not <code>list.snp</code>, then the first <code class="reqn">n</code> SNPs are used to generate the interactions,
where <code class="reqn">n</code> is the total number of values in <code>list.ia</code>. For the case that both
<code>list.ia</code> and <code>list.snp</code> are not specified, see Details.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_beta0">beta0</code></td>
<td>
<p>a numeric value specifying the intercept of the regression model.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_beta">beta</code></td>
<td>
<p>a non-negative numeric value or vector of the same length as <code>list.ia</code>
(i.e.\ one numeric value for each interaction) specifying the parameters in the
regression model.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_maf">maf</code></td>
<td>
<p>either an integer, or a vector of length 2 or <code>n.snp</code> specifying the
minor allele frequency. If an integer, all the SNPs will have the same
minor allele frequency. If a vector of length <code>n.snp</code>, each SNP will have the minor
allele frequency specified in the corresponding entry of <code>maf</code>. If length 2, then
<code>maf</code> is interpreted as the range of the minor allele frequencies, and for each SNP,
a minor allele frequency will be randomly drawn from a uniform distribution with
the range given by <code>maf</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_sample.y">sample.y</code></td>
<td>
<p>should the values of the response in the logistic regression model be randomly drawn
using the probabilities of the respective observations for being a case? If <code>FALSE</code>,
then the response value of an observation is 1 if its probability for being a case is larger
than <code>p.cutoff</code>, and otherwise the observation is classified as a control (i.e.\ the value
of the response is 0). Ignored if <code>err.fun</code> is specified.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_p.cutoff">p.cutoff</code></td>
<td>
<p>a probability, i.e.\ a numeric value between 0 and 1, naming the cutoff for an
observation to be called a case if <code>sample.y = FALSE</code>. For details, see <code>sample.y</code>.
Ignored if <code>sample.y = TRUE</code> or <code>err.fun</code> is specified.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_err.fun">err.fun</code></td>
<td>
<p>a function for generating the error that is added to the linear model to determine
the value of the (quantitative) response. If <code>NULL</code>, a logistic regression model is fitted.
If specified, a linear model is fitted. Therefore, this argument is used to differ between the
two types of models. The specified function must have as first argument the number of values
that should be generated and as output a vector consisting of these values. Further arguments
can also be specified because of <code>...</code> in <code>simulateSNPglm</code>.
If, e.g., <code>err.fun = rnorm</code>, then <code>rnorm(n.obs)</code> will be called to generate
<code>n.obs</code> observations from a standard normal function.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_rand">rand</code></td>
<td>
<p>a numeric value for setting the random number generator in a reproducible state.</p>
</td></tr>
<tr><td><code id="simulateSNPglm_+3A_...">...</code></td>
<td>
<p>further arguments of the function specified by <code>err.fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simulateSNPglm</code> first simulates a matrix consisting of <code>n.obs</code> observations and <code>n.snp</code>
SNPs, where the minor allele frequencies of these SNPs are given by <code>maf</code>.
</p>
<p>Note that all SNPs are currently simulated independently of each other such that they are unlinked.
</p>
<p>Afterwards, the response is determined by a regression model using the specifications of <code>list.ia</code>,
<code>list.snp</code>, <code>beta0</code> and <code>beta</code>. Depending on whether <code>err.fun</code> is specified or not,
a linear or a logistic regression model is used, respectively, i.e.\ the response <code class="reqn">Y</code> is continuous or binary.
</p>
<p>By default, a logistic regression model
</p>
<p>logit(Prob(<code class="reqn">Y = 1</code>)) = <code>beta0</code> + <code>beta[1]</code> * <code class="reqn">L_1</code> + <code>beta[2]</code> * <code class="reqn">L_2</code> + ...
</p>
<p>is fitted, since <code>err.fun = NULL</code>. 
</p>
<p>If both <code>list.ia</code> and <code>list.snp</code> are <code>NULL</code>, then interactions similar to the one
considered, e.g., in Nunkesser et al.\ (2007) or Schwender et al.\ (2007) are used, i.e.\
</p>
<p><code class="reqn">L_1</code> = <code>(SNP6 != 1) &amp; (SNP7 == 1)</code>\ \ \ and 
</p>
<p><code class="reqn">L_2</code> = <code>(SNP3 == 1) &amp; (SNP9 == 1) &amp; (SNP10 == 1)</code>,
</p>
<p>by setting <code>list.ia = list(c(-1, 1), c(1, 1, 1))</code> and
<code>list.snp = list(c(6, 7), c(3, 9, 10))</code>. 
</p>
<p>Using the above model Prob(<code class="reqn">Y = 1</code>) is computed for each observation, and its value of the response is
determined either by a random draw from a Bernoulli distribution using this probability (if <code>sample.y = TRUE</code>),
or by evaluating if Prob(<code class="reqn">Y = 1</code>) <code class="reqn">&gt;</code> <code>p.cutoff</code> (if <code>sample.y = FALSE</code>).
</p>
<p>If <code>err.fun</code> is specified, then the linear model
</p>
<p><code class="reqn">Y</code> = <code>beta0</code> + <code>beta[1]</code> * <code class="reqn">L_1</code> + <code>beta[2]</code> * <code class="reqn">L_2</code> + ... + error
</p>
<p>is used to determine the values of the response <code class="reqn">Y</code>, where the values for error are given
by the output of a call of <code>err.fun</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>simSNPglm</code> consisting of
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a matrix with <code>n.obs</code> rows and <code>n.snp</code> columns containing the simulated SNP values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of length <code>n.obs</code> composed of the values of the response.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>the value of the intercept.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the vector of parameters.</p>
</td></tr>
<tr><td><code>ia</code></td>
<td>
<p>a character vector naming the explanatory interactions.</p>
</td></tr>
<tr><td><code>maf</code></td>
<td>
<p>a vector of length <code>n.snp</code> composed of the minor allele frequencies.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>a vector of length <code>n.obs</code> consisting of the values of Prob(<code class="reqn">Y = 1</code>) (if <code>err.fun = NULL</code>).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>a vector of length <code>n.obs</code> composed of the values of the error (if <code>err.fun</code> is specified).</p>
</td></tr>
<tr><td><code>p.cutoff</code></td>
<td>
<p>the value of <code>p.cutoff</code> (if <code>err.fun = NULL</code> and <code>sample.y = FALSE</code>).</p>
</td></tr>
<tr><td><code>err.call</code></td>
<td>
<p>a character string naming the call of the error function (if <code>err.fun</code> is specified).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Nunkesser, R., Bernholt, T., Schwender, H., Ickstadt, K. and Wegener, I.\ (2007).
Detecting High-Order Interactions of Single Nucleotide Polymorphisms Using Genetic Programming.
<em>Bioinformatics</em>, 23, 3280-3288.
</p>
<p>Schwender, H.\ (2007). Statistical Analysis of Genotype and Gene Expression Data. <em>Dissertation</em>,
Department of Statistics, University of Dortmund. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateSNPs">simulateSNPs</a></code>, <code><a href="#topic+summary.simSNPglm">summary.simSNPglm</a></code>, <code><a href="#topic+simulateSNPcatResponse">simulateSNPcatResponse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The simulated data set described in Details.

sim1 &lt;- simulateSNPglm()
sim1

# A bit more information: Table of probabilities of being a case
# vs. numbers of cases and controls.

summary(sim1)

# Calling an observation a case if its probability of being
# a case is larger than 0.5 (the default for p.cutoff).

sim2 &lt;- simulateSNPglm(sample.y = FALSE)
summary(sim2)

# If ((SNP4 != 2) &amp; (SNP3 == 1)), (SNP5 ==3) and
# ((SNP12 !=1) &amp; (SNP9 == 3)) should be the three interactions
# (or variables) that are explanatory for the response,
# list.ia and list.snp are specified as follows.

list.ia &lt;- list(c(-2, 1), 3, c(-1,3))
list.snp &lt;- list(c(4, 3), 5, c(12,9))

# The binary response and the data set consisting of 
# 600 observations and 25 SNPs, where the minor allele
# frequency of each SNP is randomly drawn from a
# uniform distribution with minimum 0.1 and maximum 0.4,
# is then generated by

sim3 &lt;- simulateSNPglm(n.obs = 600, n.snp = 25,
  list.ia = list.ia, list.snp = list.snp, maf = c(0.1, 0.4))
sim3

summary(sim3)
  
# If the response should be quantitative, err.fun has
# to be specified. To use a normal distribution with mean 0
# (default in rnorm) and a standard deviation of 2 
# as the distribution of the error, call

simulateSNPglm(err.fun = rnorm, sd = 2)
 


## End(Not run)</code></pre>

<hr>
<h2 id='simulateSNPs'>Simulation of SNP data</h2><span id='topic+simulateSNPs'></span>

<h3>Description</h3>

<p>Simulates SNP data, where a specified proportion of cases and controls
is explained by specified set of SNP interactions. Can also be used
to simulate a data set with a multi-categorical response, i.e.\
a data set in which the cases are divided into several classes (e.g.,
different diseases or subtypes of a disease).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSNPs(n.obs, n.snp, vec.ia, prop.explain = 1, 
  list.ia.val = NULL, vec.ia.num = NULL, vec.cat = NULL,
  maf = c(0.1, 0.4), prob.val = rep(1/3, 3), list.equal = NULL, 
  prob.equal = 0.8, rm.redundancy = TRUE, shuffle = FALSE, 
  shuffle.obs = FALSE, rand = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSNPs_+3A_n.obs">n.obs</code></td>
<td>
<p>either an integer specifying the total number of 
observations, or a vector of length 2 specifying the number 
of cases and the number of controls. If <code>vec.cat</code> is specified,
then the partitioning of the number of cases to the different
classes can be governed by <code>vec.ia.num</code>. If <code>n.obs</code> is
an integer, then <code class="reqn">1 / c</code> of the observations will be controls and
the remaining observations will be cases, where <code class="reqn">c</code> is the total number
of groups (including the controls).</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_n.snp">n.snp</code></td>
<td>
<p>integer specifying the number of SNPs.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_vec.ia">vec.ia</code></td>
<td>
<p>a vector of integers specifying the orders of the interactions
that explain the cases. <code>c(3,1,2,3)</code>, e.g., means that a three-way,
a one-way (i.e. just a SNP), a two-way, and a three-way interaction explain the cases.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_prop.explain">prop.explain</code></td>
<td>
<p>either an integer or a vector of <code>length(vec.ia)</code> 
specifying the proportions of cases explained by the interactions of interest
among all observation having the interaction of interest. Must be larger than 0.5.
E.g., <code>prop.explain = 1</code> means that only cases have the interactions of interest
specified by <code>vec.ia</code> (and <code>list.ia.val</code>). E.g., <code>vec.ia = c(3, 2)</code>
and <code>prop.explain = c(1, 0.8)</code> means that only cases have the three-way interaction of
interest, while 80% of the observations having the two-way interaction of interest
are cases, and 20% are controls.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_list.ia.val">list.ia.val</code></td>
<td>
<p>a list of <code>length(vec.ia)</code> specifying the exact interactions.
The objects in this list must be vectors of length <code>vec.ia[i]</code>, and consist
of the values 0 (for homozygous reference), 1 (heterozygous variant), or 2 (homozygous variant).
E.g., <code>vec.ia = c(3, 2)</code> and <code>list.ia.val = list(c(2, 0, 1), c(0, 2))</code> 
and <code>prob.equal = 1</code> (see also <code>list.equal</code>) means that
((SNP1 == 2) \&amp; (SNP2 == 0) \&amp; (SNP3 == 1)) and ((SNP4 == 0) \&amp; (SNP5 == 2))
are the explanatory interactions (if additionally <code>prob.equal = 1</code>; see also
<code>list.equal</code>). If <code>NULL</code>, the genotypes are randomly drawn
using the probabilities given by <code>prob.val</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_vec.ia.num">vec.ia.num</code></td>
<td>
<p>a vector of <code>length(vec.ia)</code> specifying the number of
<em>cases</em> (not observations) explained by the interactions in <code>vec.ia</code>.
If <code>NULL</code>, all the cases are divided into <code>length(vec.ia)</code> groups of
about the same size. <code>sum(vec.ia.num)</code> must be smaller than
or equal to the total number of cases. Each entry of <code>vec.ia.num</code> must currently be &gt;= 10.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_vec.cat">vec.cat</code></td>
<td>
<p>a vector of the same length of <code>vec.ia</code> specifying the subclasses
of the cases that are explained by the corresponding interaction in <code>vec.ia</code>. If <code>NULL</code>,
no subclasses will be considered. This feature is currently not fully tested. So be careful
if specifying <code>vec.cat</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_maf">maf</code></td>
<td>
<p>either an integer, or a vector of length 2 or <code>n.snp</code> specifying
the minor allele frequencies. If an integer, all SNPs will have the same
minor allele frequency. If a vector of length <code>n.snp</code>, each SNP will have the minor
allele frequency specified in the corresponding entry of <code>maf</code>. If length 2, then
<code>maf</code> is interpreted as the range of the minor allele frequencies, and for each SNP,
a minor allele frequency will be randomly drawn from a uniform distribution with 
the range given by <code>maf</code>. Note: If a SNP belongs to an explanatory interaction,
then only the set of observations not explained by this interaction will have
the minor allele frequency specified by <code>maf</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_prob.val">prob.val</code></td>
<td>
<p>a vector consisting of the probabilities for drawing a 0, 1, or 2,
if <code>list.ia.val = NULL</code>, i.e.\ if the genotypes of the SNPs explaining the case-control
status should be randomly drawn. Ignored if <code>list.ia.val</code> is specified. By default,
each genotype has the same probability of being drawn.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_list.equal">list.equal</code></td>
<td>
<p>list of same structure as <code>list.ia.val</code> containing only ones and
zeros, where a 1 specifies the equality to the corresponding value in
<code>list.ia.val</code>, and a 0 specifies the non-equality. Thus, the entries of <code>list.equal</code>
specify if the corresponding SNP should be of a particular genotype (when the entry is 1)
or should be not of this genotype (when entry is 0). If <code>NULL</code>, this list
will be generated automatically using <code>prob.equal</code>. If, e.g., <code>vec.ia = c(3, 2)</code>,
<code>list.ia.val = list(c(2, 0, 1), c(0, 2))</code>,
and <code>list.equal = list(c(1, -1, 1), c(1, -1))</code>, then the explanatory interactions are
given by ((SNP1 == 2) \&amp; (SNP2 != 0) \&amp; (SNP3 == 1)) and ((SNP4 == 0) \&amp; (SNP5 != 2))</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_prob.equal">prob.equal</code></td>
<td>
<p>a numeric value specifying the probability that a 1 is drawn when generating
<code>list.equal</code>. <code>prob.equal</code> is thus the probability for an equal sign.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_rm.redundancy">rm.redundancy</code></td>
<td>
<p>should redundant SNPs be removed from the explaining interactions?
It is possible that one specify an explaining <code class="reqn">i</code>-way interaction, but an interaction
between <code class="reqn">(i-1)</code> of the variables contained in the <code class="reqn">i</code>-way
interaction already explains all the cases (and controls) that the <code class="reqn">i</code>-way interaction
should explain. In this case, the redundant SNP is removed if <code>rm.redundancy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_shuffle">shuffle</code></td>
<td>
<p>logical. By default, the first <code>sum(vec.ia)</code> columns of the generated
data set contain the explanatory SNPs in the same order as they appear in this data set.
If <code>TRUE</code>, this order will be shuffled.</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_shuffle.obs">shuffle.obs</code></td>
<td>
<p>should the observations be shuffled?</p>
</td></tr>
<tr><td><code id="simulateSNPs_+3A_rand">rand</code></td>
<td>
<p>integer. Sets the random number generator in a reproducible state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>simulatedSNPs</code> composed of
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a matrix with <code>n.obs</code> rows and <code>n.snp</code> columns containing
the SNP data.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>a vector of length <code>n.obs</code> comprising the case-control status of the
observations.</p>
</td></tr>
<tr><td><code>tab.explain</code></td>
<td>
<p>a table naming the explanatory interactions and the numbers
of cases and controls explained by them.</p>
</td></tr>
<tr><td><code>ia</code></td>
<td>
<p>character vector naming the interactions.</p>
</td></tr>
<tr><td><code>maf</code></td>
<td>
<p>vector of length <code>n.snp</code> containing the minor allele frequencies.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, the genotypes of all SNPs are simulated independently from each other
(except for the SNPs that belong to the same explanatory interaction).</p>


<h3>Author(s)</h3>

<p>Holger Schwender <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateSNPglm">simulateSNPglm</a></code>, <code><a href="#topic+simulateSNPcatResponse">simulateSNPcatResponse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate a data set containing 2000 observations (1000 cases
# and 1000 controls) and 50 SNPs, where one three-way and two 
# two-way interactions are chosen randomly to be explanatory 
# for the case-control status.

sim1 &lt;- simulateSNPs(2000, 50, c(3, 2, 2))
sim1

# Simulate data of 1200 cases and 800 controls for 50 SNPs, 
# where 90% of the observations showing a randomly chosen 
# three-way interaction are cases, and 95% of the observations 
# showing a randomly chosen two-way interactions are cases.

sim2 &lt;- simulateSNPs(c(1200, 800), 50, c(3, 2), 
   prop.explain = c(0.9, 0.95))
sim2

# Simulate a data set consisting of 1000 observations and 50 SNPs,
# where the minor allele frequency of each SNP is 0.25, and
# the interactions 
# ((SNP1 == 2) &amp; (SNP2 != 0) &amp; (SNP3 == 1))   and 
# ((SNP4 == 0) &amp; (SNP5 != 2))
# are explanatory for 200 and 250 of the 500 cases, respectively,
# and for none of the 500 controls.

list1 &lt;- list(c(2, 0, 1), c(0, 2))
list2 &lt;- list(c(1, 0, 1), c(1, 0))
sim3 &lt;- simulateSNPs(1000, 50, c(3, 2), list.ia.val = list1,
    list.equal = list2, vec.ia.num = c(200, 250), maf = 0.25)


## End(Not run)</code></pre>

<hr>
<h2 id='smc'>Simple Matching Coefficient and Cohen's Kappa</h2><span id='topic+smc'></span><span id='topic+cohen'></span>

<h3>Description</h3>

<p>Computes the values of (or the distance based on) the simple matching coefficient
or Cohen's Kappa, respectively, for each pair of rows of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smc(x, dist = FALSE)
cohen(x, dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smc_+3A_x">x</code></td>
<td>
<p>a matrix consisting of integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is the number of levels the variables in <code>x</code>
can take. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="smc_+3A_dist">dist</code></td>
<td>
<p>should the distance based on the simple matching coefficient or Cohen's Kappa, respectively,
be computed? Note that, e.g., <code>smc(x, dist = TRUE)</code> is equal to <code>1 - smc(x, dist = FALSE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>nrow(x)</code> columns and rows containing the distances or similarities.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pcc">pcc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a data set consisting of 10 rows and 200 columns,
# where the values are randomly drawn from the integers 1, 2, and 3.

mat &lt;- matrix(sample(3, 2000, TRUE), 10)

# For each pair of row, the value of the simple matching coefficient
# can be obtained by

smc(mat)

# and the distance based on the SMC by

smc(mat, dist = TRUE)


## End(Not run)</code></pre>

<hr>
<h2 id='snp2bin'>Transformation of SNPs to Binary Variables</h2><span id='topic+snp2bin'></span>

<h3>Description</h3>

<p>Transforms SNPs to binary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snp2bin(mat, domrec = TRUE, refAA = FALSE, snp.in.col = TRUE, 
   monomorph = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snp2bin_+3A_mat">mat</code></td>
<td>
<p>a matrix or data frame in which the genotypes of all SNPs are coded
either by <code>0</code>, <code>1</code> and <code>2</code>,
or by <code>1</code>, <code>2</code> and <code>3</code>, or by <code>"AA"</code>, <code>"AB"</code> and <code>"BB"</code>.
Missing values are allowed. In the latter coding not only <code>NA</code>, but also <code>"NN"</code>
is allowed for specifying missing values. Using the former two codings it is assumed
that the smallest value codes the homozygous reference genotype, the second value the
heterozygous genotype, and the largest value the homozygous variant genotype. For the third
coding, see <code>refAA</code>.</p>
</td></tr>
<tr><td><code id="snp2bin_+3A_domrec">domrec</code></td>
<td>
<p>should each SNP be coded by two dummy variables from which one codes for
a recessive, and the other for a dominant effect? If <code>TRUE</code>, then the first
binary variable is set to 1 if the SNP is of the heterozygous or the homozygous variant
genotype, and the second dummy variable is set to 1 if the SNP is of the homozygous
variant genotype. If <code>FALSE</code>, three dummy variables are used and each of the three
genotypes of a SNP is coded by one of these binary variables.</p>
</td></tr>
<tr><td><code id="snp2bin_+3A_refaa">refAA</code></td>
<td>
<p>codes <code>"AA"</code> always for the homozygous reference gentoype? Only considered
if the SNPs are coded by <code>"AA"</code>, <code>"AB"</code> and <code>"BB"</code>.
If <code>FALSE</code>, it is evaluated SNPwise whether <code>"AA"</code> or
<code>"BB"</code> occurs more often, and the more frequently occuring value is assumed to be
the homozygous reference genotype.</p>
</td></tr>
<tr><td><code id="snp2bin_+3A_snp.in.col">snp.in.col</code></td>
<td>
<p>does each column of <code>mat</code> correspond to a SNP (and each row to an observation)?
If <code>FALSE</code>, it is assumed that each row represents a SNP, and each column an observation.</p>
</td></tr>
<tr><td><code id="snp2bin_+3A_monomorph">monomorph</code></td>
<td>
<p>a non-negative number. If a dummy variable contains <code>monomorph</code> or less
values that differ from the more frequent value of this variable, then the variable is
removed from the data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the binary dummy variables.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+recodeSNPs">recodeSNPs</a></code>, <code><a href="#topic+recodeAffySNP">recodeAffySNP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate an example data set consisting of 10 rows (observations)
# and 5 columns (SNPs).

mat &lt;- matrix(sample(3, 50, TRUE), 10)
colnames(mat) &lt;- paste("SNP", 1:5, sep = "")

# Transform each SNP into two dummy variables, one that codes for
# a recessive effect and one that codes for a dominant effect.

snp2bin(mat)

# Transform each SNP into three dummy variables, where each of
# these variables codes for one of the three genotypes.

snp2bin(mat, domrec = FALSE)

## End(Not run)</code></pre>

<hr>
<h2 id='summary.simSNPglm'>Summarizing a simSNPglm object</h2><span id='topic+summary.simSNPglm'></span>

<h3>Description</h3>

<p>Summarizes an object of class <code>simSNPglm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simSNPglm'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.simSNPglm_+3A_object">object</code></td>
<td>
<p>an object of class <code>simSNPglm</code>, i.e.\ the output of <code><a href="#topic+simulateSNPglm">simulateSNPglm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.simSNPglm_+3A_digits">digits</code></td>
<td>
<p>number of digits used in the output.</p>
</td></tr>
<tr><td><code id="summary.simSNPglm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shows the model used in <code><a href="#topic+simulateSNPglm">simulateSNPglm</a></code> to generate the values of the response.
If the response is binary, then it additionally shows and returns a contingency table of the
numbers of cases and controls and the probabilities for being a case.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateSNPglm">simulateSNPglm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The default simulated data set.

sim1 &lt;- simulateSNPglm()
sim1

# A bit more information: Table of probability of being a case
# vs. number of cases and controls.

summary(sim1)


## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
