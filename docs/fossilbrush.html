<!DOCTYPE html><html><head><title>Help for package fossilbrush</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fossilbrush}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_itp'><p>add_itp</p></a></li>
<li><a href='#add_kingdoms'><p>add_kingdoms</p></a></li>
<li><a href='#age_ranges'><p>roxygen documentation</p></a></li>
<li><a href='#assess_duplicates'><p>assess_duplicates</p></a></li>
<li><a href='#brachios'><p>brachios</p></a></li>
<li><a href='#check_taxonomy'><p>check_taxonomy</p></a></li>
<li><a href='#chrono_scale'><p>chrono_scale</p></a></li>
<li><a href='#clean_name'><p>roxygen documentation</p></a></li>
<li><a href='#densify'><p>densify</p></a></li>
<li><a href='#discrete_ranks'><p>roxygen documentation</p></a></li>
<li><a href='#find_duplicates'><p>find_duplicates</p></a></li>
<li><a href='#find_peaks'><p>find_peaks</p></a></li>
<li><a href='#flag_ranges'><p>flag_ranges</p></a></li>
<li><a href='#format_check'><p>format_check</p></a></li>
<li><a href='#geog_lookup'><p>geog_lookup</p></a></li>
<li><a href='#get_pbdb'><p>get_pbdb</p></a></li>
<li><a href='#GTS2020'><p>GTS2020</p></a></li>
<li><a href='#GTS2020_changelog'><p>GTS2020_changelog</p></a></li>
<li><a href='#intersect_ranges'><p>intersect_ranges</p></a></li>
<li><a href='#pacmacro_ranges'><p>pacmacro_ranges</p></a></li>
<li><a href='#pbdb_fields'><p>geog_lookup</p></a></li>
<li><a href='#pbdb_kingdoms'><p>pbdb_kingdoms</p></a></li>
<li><a href='#plot_dprofile'><p>plot_dprofile</p></a></li>
<li><a href='#plot_taxa'><p>plot_taxa</p></a></li>
<li><a href='#quantile_coef_density_BMS'><p>quantile_coef_density_BMS</p></a></li>
<li><a href='#resolve_duplicates'><p>resolve_duplicates</p></a></li>
<li><a href='#revise_ranges'><p>revise_ranges</p></a></li>
<li><a href='#sep_code'><p>sep_code</p></a></li>
<li><a href='#sepkoski'><p>sepkoski</p></a></li>
<li><a href='#spell_check'><p>spell_check</p></a></li>
<li><a href='#tgraph'><p>tgraph</p></a></li>
<li><a href='#threshold_peaks'><p>threshold_peaks</p></a></li>
<li><a href='#threshold_ranges'><p>threshold_ranges</p></a></li>
<li><a href='#update_graph'><p>update_graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Automated Cleaning of Fossil Occurrence Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to automate the detection and resolution of taxonomic and stratigraphic errors in fossil occurrence datasets. Functions were developed using data from the Paleobiology Database.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, curl, data.table, pbapply, stringdist, stringr,
Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=fossilbrush">https://cran.r-project.org/package=fossilbrush</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://cran.r-project.org/package=fossilbrush">https://cran.r-project.org/package=fossilbrush</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-21 14:50:11 UTC; Joe</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Flannery-Sutherland
    <a href="https://orcid.org/0000-0001-8232-6773"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Nussaïbah Raja-Schoob [aut, ctb],
  Ádam Kocsis [aut, ctb],
  Wolfgang Kiessling [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Flannery-Sutherland &lt;jf15558@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-21 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_itp'>add_itp</h2><span id='topic+add_itp'></span>

<h3>Description</h3>

<p>Function to add detected peaks using the output of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_itp(x, taxon, legend.pos = "topright", exit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_itp_+3A_x">x</code></td>
<td>
<p>The list output of @seealso threshold_ranges</p>
</td></tr>
<tr><td><code id="add_itp_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of length one, specifying
one of the taxon names in x to be plotted</p>
</td></tr>
<tr><td><code id="add_itp_+3A_legend.pos">legend.pos</code></td>
<td>
<p>One of topleft, bottomleft, topright or
bottomright, or a vector of length two, giving the xy
coordinates of the legend. A convenience parameter so that
the plot detail can remain unobscured.</p>
</td></tr>
<tr><td><code id="add_itp_+3A_exit">exit</code></td>
<td>
<p>Restore base plotting parameters on function exit
(default as a requirement for CRAN). Can be set to false to allow
other elements to be aded to a plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, the detected peaks are added to an existing density plot
</p>


<h3>See Also</h3>

<p>threshold_ranges. This function should be used
to add information to an existing plot from @seealso densify,
ensuring that the same taxon name is being used
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# densify ranges
dens &lt;- densify(brachios)
# interpeak thresholding
itp &lt;- threshold_ranges(brachios, win = 8, thresh = 10,
                        rank = "genus", srt = "max_ma", end = "min_ma")
# append the stratigraphically thresholded taxon names to the dataset
# plot the taxon, now identifying the peaks
plot_dprofile(dens, "Atrypa", exit = FALSE)
add_itp(itp, "Atrypa")
</code></pre>

<hr>
<h2 id='add_kingdoms'>add_kingdoms</h2><span id='topic+add_kingdoms'></span>

<h3>Description</h3>

<p>Convenience function to add in a kingdom column to a PBDB
dataset. This relies on the dataset having a column of
phylum-level assignments for occurrences. The kingdom
column is a useful addition for filtering very large
taxonomically diverse datasets, and adds in an additional
level of data which can inform taxonomic cleaning routines
like those called by @seealso check_taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_kingdoms(x, phylum = "phylum", insert.left = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_kingdoms_+3A_x">x</code></td>
<td>
<p>A dataframe containing, minimally, phylum-level
assignments of the data</p>
</td></tr>
<tr><td><code id="add_kingdoms_+3A_phylum">phylum</code></td>
<td>
<p>A character of length 1 specifing the column
in x with the phylum level assignments</p>
</td></tr>
<tr><td><code id="add_kingdoms_+3A_insert.left">insert.left</code></td>
<td>
<p>A convenience argument which will
make sure that the kingdom column will be inserted in
dataframe left immediately to the left of the phylum column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataframe x, with the kingdom column inserted
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# add kingdoms to dataset
brachios &lt;- add_kingdoms(brachios)
</code></pre>

<hr>
<h2 id='age_ranges'>roxygen documentation</h2><span id='topic+age_ranges'></span>

<h3>Description</h3>

<p>age_ranges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_ranges(
  data,
  taxonomy = "genus",
  srt = "max_ma",
  end = "min_ma",
  mode = "max"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_ranges_+3A_data">data</code></td>
<td>
<p>A three column dataframe comprising one or
more character columns of taxonomic names, a numeric
column of FADs and a numeric column of LADs</p>
</td></tr>
<tr><td><code id="age_ranges_+3A_taxonomy">taxonomy</code></td>
<td>
<p>A character vector corresponding to one or
more of the taxonomic name columns in data</p>
</td></tr>
<tr><td><code id="age_ranges_+3A_srt">srt</code></td>
<td>
<p>A character vector of length one specifying the
FAD column in data</p>
</td></tr>
<tr><td><code id="age_ranges_+3A_end">end</code></td>
<td>
<p>A character vector of length one specifying the
LAD column in data</p>
</td></tr>
<tr><td><code id="age_ranges_+3A_mode">mode</code></td>
<td>
<p>A character vector of length one specifying
the type of range table to return: one of max, min or
bounds. If not specified by the user, the function
behaviour will default to max</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to derive a range table of taxon names from a
stratigraphic occurrence dataset. The default behaviour
is to return a total range table - the oldest FAD and
youngest LAD for each taxon (max), but the function can
also return the minimum range - youngest FAD and oldest
LAD (min), or the uncertainty bounds on each FAD and
LAD - the two oldest FADs and two youngest LADs (bounds).
The names for which ranges are derived are specified by
the taxononmy argument, but multiple elements can be
given here, allowing taxonomic range for higher clades
to also be returned.
</p>


<h3>Value</h3>

<p>A dataframe containing at least four columns:
taxon name, FAD, LAD and the taxonomic rank. If taxonomy
is of length one, taxonomic rank will be a vector of
identical names. If mode = &quot;bounds&quot;, there will be two
pairs of age columns, denoting the upper and lower bounds
on the FAD and LAD for each taxon name
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# derive age ranges
rng &lt;- age_ranges(brachios)
</code></pre>

<hr>
<h2 id='assess_duplicates'>assess_duplicates</h2><span id='topic+assess_duplicates'></span>

<h3>Description</h3>

<p>Function to assess and resolve elements with multiple higher
classifications in a tgraph object. Assessment is performed
based on the topology of the graph they form. Linear paths
(i.e. two totally separate paths diverging from the a shared
node), rings (divergent paths which only reunite at the
highest rank in the tgraph) or more than two divergent paths
are treated as distinct. If not any of these cases, the
distance between the focal element and the reunion of the
divergent paths, along with their subtopologies are assessed
and a consensus or preferred path based on the frequency of
each path in the tgraph or their completeness returned, or
the element judged as having multiple distinct
classifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_duplicates(
  x,
  node,
  mode = c("frequency", "completeness"),
  jump = 3,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_duplicates_+3A_x">x</code></td>
<td>
<p>A tgraph object</p>
</td></tr>
<tr><td><code id="assess_duplicates_+3A_node">node</code></td>
<td>
<p>character vector of elements with multiple higher
classifications in x, or a tvertseq object with those same
elements as focal</p>
</td></tr>
<tr><td><code id="assess_duplicates_+3A_mode">mode</code></td>
<td>
<p>The rule to be used in selecting between multiple
higher classifications. It is possible for the most complete
pathway to also be the most frequent</p>
</td></tr>
<tr><td><code id="assess_duplicates_+3A_jump">jump</code></td>
<td>
<p>The maximum number of levels between the point of
divergence and the point of reunion (if present) for a given
path, below which the divergence will be taken as conflicting</p>
</td></tr>
<tr><td><code id="assess_duplicates_+3A_plot">plot</code></td>
<td>
<p>A logical speciying if the divergent paths should
be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with as many items as elements with multiple
classifications, each recording the assessment for a given
element
</p>

<hr>
<h2 id='brachios'>brachios</h2><span id='topic+brachios'></span>

<h3>Description</h3>

<p>An example dataset of Palaeozoic brachiopods
downloaded from the Paleobiology Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brachios
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 151473 rows and 10 columns.
</p>

<hr>
<h2 id='check_taxonomy'>check_taxonomy</h2><span id='topic+check_taxonomy'></span>

<h3>Description</h3>

<p>Wrapper functions to implement a multi-step cleaning routine
for hierarchically structured taxonomic data. The first part
of the routine calls @seealso format_check to perform a few
presumptive checks on all columns, scanning for non-letter
characters and checking the number of words in each string.
By default, @seealso clean_name is called to ensure correct
formatting as this improves downstream checking. The second
part of the routine calls @seealso spell_check to flag spelling
discrepancies between names within a given taxonomic group. If
chosen, the function can automatically impose the more frequent
spelling. The third part of the routine calls @seealso discrete_ranks
to flag name re-use at different taxonomic levels. Some of these
cases may arise when a name has been unfortunately, (although
permissibly) used to refer to groups at different taxonomic levels,
or where a higher classification may have been inserted as a
placeholder for a missing lower classification. The fourth part of
the routine calls @seealso find_duplicates to flag variable higher
classifications for a given taxon, including cases where a higher
classification is missing for one instance of a taxon, but present
for the others. If chosen, @seealso resolve_duplicates is called
to ensure a consistent classification is imposed. For cases where
a name has been re-used at the same rank for genuinely different
taxa (not permissible, unlike name re-use at different ranks)
suffixes are added as capital letters, e.g. TaxonA, TaxonB. If
any of the automatic cleaning routines are employed (again the
default behaviour as clean_name is TRUE by default), the function
will return are a cleaned version of the dataset. If the use of
suffixes from @seealso resolve_duplicates is not desirable,
the function behaviour can be altered so that any suffixes are
dropped before returning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_taxonomy(
  x,
  ranks = c("phylum", "class", "order", "family", "genus"),
  species = FALSE,
  species_sep = NULL,
  routine = c("format_check", "spell_check", "discrete_ranks", "find_duplicates"),
  report = TRUE,
  verbose = TRUE,
  clean_name = FALSE,
  clean_spell = FALSE,
  thresh = NULL,
  resolve_duplicates = FALSE,
  append = TRUE,
  term_set = NULL,
  collapse_set = NULL,
  jw = 0.1,
  str = 1,
  str2 = NULL,
  alternative = "jaccard",
  q = 1,
  pref_set = NULL,
  suff_set = NULL,
  exclude_set = NULL,
  jump = 3,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_taxonomy_+3A_x">x</code></td>
<td>
<p>A dataframe with hierarchically organised
taxonomic information. If x only comprises the taxonomic
information, @param ranks does not need to be specified, but the
columns must be in order of decreasing taxonomic rank</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_ranks">ranks</code></td>
<td>
<p>The column names of the taxonomic data fields
in x. These must be provided in order of decreasing taxonomic
rank</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_species">species</code></td>
<td>
<p>A logical indicating if x contains a species
column. As the data must be supplied in hierarchical order,
this column will naturally be the last column in x and
species-specific spell checks will be performed on this column.</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_species_sep">species_sep</code></td>
<td>
<p>A character vector of length one specifying
the genus name and specific epithet in the species column, if
present
</p>

<ul>
<li><p> Flagging routine arguments *
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_routine">routine</code></td>
<td>
<p>A character vector determining the flagging
and cleaning routines to employ. Valid values are format_check (check for
non letter characters and the number of words in names), spell_check
(flag potential spelling errors), discrete_rank (check that
taxonomic names are unique to their rank), duplicate_tax (flag
conflicting higher classifications of a given taxon)</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_report">report</code></td>
<td>
<p>A logical of length one determining if the flagging outputs
of each cleaning routine should be returned to the user for inspection.
This is different to @param verbose, which controls whether flagging
should additionally be reported to the user on the console</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress and flagged
errors should be reported to the console
</p>

<ul>
<li><p> Cleaning routine arguments *
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_clean_name">clean_name</code></td>
<td>
<p>If TRUE, the function will return cleaned versions of
the columns in x using the routines in @seealso clean_name. These routines
can be altered using the 'term_set' and 'collapse_set' arguments.</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_clean_spell">clean_spell</code></td>
<td>
<p>If TRUE, the function will return a cleaned version
of the supplied taxonomic dataframe, using the supplied threshold
for the similarity method given by method2, to automatically update
any names in pairs of flagged synonyms to the more frequent spelling.
This is not recommended, however, so the argument is FALSE by default
and the threshold left as NULL</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_thresh">thresh</code></td>
<td>
<p>The threshold for the similarity method given by method2,
below which flagged pairs of names will be considered synonyms and
resolved automatically. See @seealso spell_check for details on method2</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_resolve_duplicates">resolve_duplicates</code></td>
<td>
<p>If TRUE, the function will return a cleaned version
of the supplied taxonomic dataframe, using @seealso resolve_duplicates
to resolve conflicts in the way documented by the function. Both
spell_clean and tax_clean can both be TRUE to return a dataset cleaned
by both methods</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_append">append</code></td>
<td>
<p>If TRUE, any suffixes used during cleaning will
be retained in the cleaned version of the data. This is preferable
as it ensures that all taxonomic names are rank-discrete and
uniquely classified
</p>

<ul>
<li><p> Routine specific arguments *
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_term_set">term_set</code></td>
<td>
<p>A character vector of terms (to be
used at all ranks) or a list of rank-specific terms
which will be supplied, element-wise as the @param collapse argument
called by @seealso clean_name. If a list, this</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_collapse_set">collapse_set</code></td>
<td>
<p>A character vector of character strings (to be
used at all ranks) or a list of rank-specific strings
which will be supplied, element-wise as the @param collapse argument
called by @seealso clean_name. If a list, this
should be given in descending rank order</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_jw">jw</code></td>
<td>
<p>Called by @seealso spell_check</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_str">str</code></td>
<td>
<p>Called by @seealso spell_check</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_str2">str2</code></td>
<td>
<p>Called by @seealso spell_check</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_alternative">alternative</code></td>
<td>
<p>Called by @seealso spell_check</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_q">q</code></td>
<td>
<p>Called by @seealso spell_check</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_pref_set">pref_set</code></td>
<td>
<p>A character vector of prefixes (which
will be used at all ranks) or a list of rank-specific prefixes,
which will be supplied, element-wise as the @param pref argument
called by @seealso spell_check. If a list, this
should be given in descending rank order.</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_suff_set">suff_set</code></td>
<td>
<p>A character vector of suffixes (which
will be used at all ranks) or a list of rank-specific suffixes,
which will be supplied, element-wise as the @param suff argument
called by @seealso spell_check. If a list, this
should be given in descending rank order.</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_exclude_set">exclude_set</code></td>
<td>
<p>A character vector of terms to exclude (which
will be used at all ranks) or a list of rank-specific exclusion terms,
which will be supplied, element-wise as the @param exclude argument
called by @seealso spell_check. If a list, this
should be given in descending rank order.</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_jump">jump</code></td>
<td>
<p>Called by @seealso resolve_duplicates</p>
</td></tr>
<tr><td><code id="check_taxonomy_+3A_plot">plot</code></td>
<td>
<p>Called by @seealso resolve_duplicates</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Data supply arguments *
</p>
</li></ul>



<h3>Value</h3>

<p>A list with elements corresponding to the outputs of the chosen
flagging routines (four by default: $formatting, $synonyms, $ranks, $duplicates),
plus a cleaned verison of the data ($data) if any of clean_name, clean_spell
or resolve_duplicates are TRUE. See @seealso format_check, @seealso spell_clean,
</p>


<h3>See Also</h3>

<p>discrete_ranks and @seealso find_duplicates for details of the structure
of the flagging outputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# define the taxonomic ranks used in the dataset (re-used elsewhere)
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# define a list of suffixes to be used at each taxonomic level when scanning for synonyms
b_suff = list(NULL, NULL, NULL, NULL, c("ina", "ella", "etta"))
# scan for errors
brachios &lt;- check_taxonomy(brachios, suff_set = b_suff, ranks = b_ranks)
</code></pre>

<hr>
<h2 id='chrono_scale'>chrono_scale</h2><span id='topic+chrono_scale'></span>

<h3>Description</h3>

<p>Convenience function to apply user-specified chronostratigraphy
to fossil datasets. The function relies on a lookup table
generated based on the named intervals in the PBDB in early
2021. First and last interval names in the supplied dataset
are matched against this lookup table, by default using
'get(&quot;GTS2020)&quot;, to get GTS2020 numeric ages. If the
dataset contains intervals which are not present in the
lookup table, they will not be matched and the user will
be warned. To get around this possibility, the user can
also supply the original numeric ages which will be used
as default ages if an interval cannot be matched, to ensure
that the returned vectors of numeric ages do not contain NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrono_scale(
  x,
  tscale = "GTS2020",
  srt = "early_interval",
  end = "late_interval",
  max_ma = NULL,
  min_ma = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chrono_scale_+3A_x">x</code></td>
<td>
<p>A data.frame containing, minimally two columns
corresponding respectively to the first and last intervals
of the data. Values should only be present in the second column
where the minimum age interval for a row is different to the
maximum age interval. Otherwise the values should be NA and the
ages returned will be based on the interval specified in the
first column, in line with PBDB formatting.</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_tscale">tscale</code></td>
<td>
<p>A character string specifying one of the inbuilt
chronostratigraphic timescales (currently GTS 2020 only) or a
data.frame supplied by the user. If the latter, this must
contain columns named 'Interval', 'FAD', 'LAD', specifying the
interval names to be matched and their lower and upper age in Ma</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_srt">srt</code></td>
<td>
<p>A character of length 1 specifing the column name
of the first interval field in x</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_end">end</code></td>
<td>
<p>A character of length 1 specifing the column name
of the last interval field in x</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_max_ma">max_ma</code></td>
<td>
<p>If not NULL, a character of length 1 specifing
the column name of the original numeric maximum age field in
x, to be used as fall back values if interval names cannot
all be matched</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_min_ma">min_ma</code></td>
<td>
<p>If not NULL, a character of length 1 specifing
the column name of the original numeric minimum age field in
x, to be used as fall back values if interval names cannot
all be matched</p>
</td></tr>
<tr><td><code id="chrono_scale_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if warning messages should be
displayed or otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataframe, x, with two additional columns containing
the revised first and last numeric ages of the data, with column
names GTS_FAD and GTS_LAD respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example dataset
data("brachios")
# add GTS 2020 dates
brachios &lt;- chrono_scale(brachios, srt = "early_interval", end = "late_interval",
                          max_ma = "max_ma", min_ma = "min_ma")
</code></pre>

<hr>
<h2 id='clean_name'>roxygen documentation</h2><span id='topic+clean_name'></span>

<h3>Description</h3>

<p>clean_name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_name(x, terms = NULL, collapse = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_name_+3A_x">x</code></td>
<td>
<p>a vector of names to clean. This will be coerced to
class character internally</p>
</td></tr>
<tr><td><code id="clean_name_+3A_terms">terms</code></td>
<td>
<p>a character vector of terms to remove from
elements of x. Terms are only removed as whole words, rather
than if they also happen to occur as strings within elements
of x</p>
</td></tr>
<tr><td><code id="clean_name_+3A_collapse">collapse</code></td>
<td>
<p>a character vector of strings which should
collapsed (i.e. replaced by &quot;&quot;, rather than the default &quot; &quot;).
If one of the collapse terms is a special regex character, it
will need to be escaped, e.g. &quot;\-&quot;</p>
</td></tr>
<tr><td><code id="clean_name_+3A_verbose">verbose</code></td>
<td>
<p>A logical of length 1 determining if function
progress should be reported to the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function which bundles a series of cleaning routines into a
single process. First any words in brackets are removed,
followed by a series of user-defined terms if given. Next
Roman and Arabic numerical are removed, then abbreviations
up to five letters (abbreviations are matched by the
following dot e.g ABFS.). By default, characters for removal
are replaced by a white space to prevent accidental collapse
of strings. However, there may be specific cases where a
collapse is required and so terms given in collapse are
dealt with next. After collapsing, rogue all rogue punctation
is removed, then isolated lowercase letters, then isolated
groups of capitals up to 5 characters long. Finally, white
spaces greater than 1 are removed, along with trailing white
space, any remaining strings longer than 2 words subsetted
to the first word, the first letter of each string capitalised
and zero length strings converted to NA
</p>


<h3>Value</h3>

<p>a character vector the same length as x. Elements
which were reduced to zero characters during cleaning are
returned as NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# clean genus names
gen_clean &lt;- clean_name(brachios$genus)
</code></pre>

<hr>
<h2 id='densify'>densify</h2><span id='topic+densify'></span>

<h3>Description</h3>

<p>Function to create a matrix of occurrence record densities
through geological time from an occurrence dataset. Each column
represents a taxon. Each row represents a user defined window of
time, with the first row starting at the oldest FAD in the
dataset and spanning to the youngest LAD stepwise by the user
defined window (default of 1 Ma). Occurrence records are
densified by generating a vector of time points from occurrence
FAD to occurrence LAD (default step of 0.1 Ma), then tallied in
two ways. The first way is a simple histogram count of
points-per-window, with the same number of histogram bins as time
steps between the overall taxon FAD and LAD. The second way is a
kernel density estimate, using a Gaussian kernel with a equally
spaced estimatopms equal to the number of timesteps between the
overall taxon FAD and LAD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densify(
  x,
  rank = "genus",
  srt = "max_ma",
  end = "min_ma",
  step = 1,
  density = 0.1,
  method = c("histogram", "kernel"),
  ...,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densify_+3A_x">x</code></td>
<td>
<p>An occurrence dataset</p>
</td></tr>
<tr><td><code id="densify_+3A_rank">rank</code></td>
<td>
<p>The column name in x containing the taxon names
for which densified columns will be generated</p>
</td></tr>
<tr><td><code id="densify_+3A_srt">srt</code></td>
<td>
<p>A column name in x denoting the occurrence FADs</p>
</td></tr>
<tr><td><code id="densify_+3A_end">end</code></td>
<td>
<p>A column name in x denoting the occurrence LADs</p>
</td></tr>
<tr><td><code id="densify_+3A_step">step</code></td>
<td>
<p>A positive integer specifying the time window size
(i.e. the duration represented by each row in the output matrix)</p>
</td></tr>
<tr><td><code id="densify_+3A_density">density</code></td>
<td>
<p>A positive numeric specifying the step size for
densifying records. This should ideally be smaller than step</p>
</td></tr>
<tr><td><code id="densify_+3A_method">method</code></td>
<td>
<p>The method for quantifying occurrence density. By
default both histogram and kernel density will be used</p>
</td></tr>
<tr><td><code id="densify_+3A_...">...</code></td>
<td>
<p>additional arguments passed to @seealso density</p>
</td></tr>
<tr><td><code id="densify_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress
should be reported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two sparse matrices, the first containing
the histogram counts, the second the kernel density estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# densify ranges
dens &lt;- densify(brachios)
</code></pre>

<hr>
<h2 id='discrete_ranks'>roxygen documentation</h2><span id='topic+discrete_ranks'></span>

<h3>Description</h3>

<p>discrete_ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_ranks(x, ranks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_ranks_+3A_x">x</code></td>
<td>
<p>A dataframe containing hierarchically structured
information, for example a table of genus names and their
higher taxonomic classifications</p>
</td></tr>
<tr><td><code id="discrete_ranks_+3A_ranks">ranks</code></td>
<td>
<p>If not NULL, a vector of column names of x,
given in rank order. This is useful if x contains columns
which are not rank relevant or if columns are not in
hierarchical order. If not supplied, the column order in x
is used directly and is assumed to be in rank order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for checking whether names in one column of a
hierarchically organised dataframe re-occur at other levels.
Two checks are performed. The first checks for names in
adjacent column, assuming that accidental reuse of names at
other levels are most likely to occur at an adjacent rank.
The second compares across all columns.
</p>


<h3>Value</h3>

<p>A list of two lists. The first list contains names
which reoccur at adjacent ranks. The second list contains
names that reoccur at any rank
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# define ranks
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# run function
flag &lt;- discrete_ranks(brachios, ranks = b_ranks)
</code></pre>

<hr>
<h2 id='find_duplicates'>find_duplicates</h2><span id='topic+find_duplicates'></span>

<h3>Description</h3>

<p>Function to detect and report elements with multiple
higher assigments in a hierarchically structured
dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_duplicates(x, ranks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_duplicates_+3A_x">x</code></td>
<td>
<p>A hierarchically organised dataframe</p>
</td></tr>
<tr><td><code id="find_duplicates_+3A_ranks">ranks</code></td>
<td>
<p>The ranks in the dataframe in which
to check for elements with multiple higher
classifications. The top rank is ignored by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of elements with multiple
higher classifications and their ranks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# run function
flag &lt;- find_duplicates(brachios, ranks = b_ranks)
</code></pre>

<hr>
<h2 id='find_peaks'>find_peaks</h2><span id='topic+find_peaks'></span>

<h3>Description</h3>

<p>Function to scan, column-wise, a matrix of per-taxon observation
density time series. This can be applied to either the histogram
or the kernel density output of <code>densify</code>, but the latter is
recommended. Peaks are detected as local maxima, then smoothed
within a local window and tested to distinguish if they are
noise or significant. Strict threshold is that the peak is
greater than the mean + sd of the window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peaks(x, win = 5, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_peaks_+3A_x">x</code></td>
<td>
<p>A matrix as outputed by <code>densify</code></p>
</td></tr>
<tr><td><code id="find_peaks_+3A_win">win</code></td>
<td>
<p>A positive integer specifying the window length on
either side of a peak (i.e. win 5 will give a total window of 11 -
-5 indices + peak index + 5 indices)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress
should be reported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four, the first three positions containing lists
of the peak indices for each taxon, under raw, mean + sd and mean
detection regimes. The fourth item is a dataframe of counts of peaks
per taxon, 1 row per taxon, 1 column per detection regime
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# get density matrix
dens &lt;- densify(brachios)
# run function, using kernel density matrix
pk &lt;- find_peaks(dens$kdensity)
</code></pre>

<hr>
<h2 id='flag_ranges'>flag_ranges</h2><span id='topic+flag_ranges'></span>

<h3>Description</h3>

<p>Function to compare stratigraphic ranges in x to a
set of reference ranges from y. A list of two elements
is returned. The first is a dataframe summarising
the overall error status, specific error counts
FAD and LAD differences, and the 95% density
distributions of the FAD and LAD errors for each
unique taxon in the column of x denoted by the first
element of xcols. If a taxon in x is not present in
y, it is assigned the status 000 and its other
entries in the returned dataframe will be NA.
The second element of the returned list is the error
code for every individual element of the column of
x denoted by the first element of xcols - this will
have the same number of rows as x. If x is a range
table rather than an occurrence dataset, then the two
list elements will have the same number of rows.
Ranges for comparison may be supplied directly in y,
or y may be another occurrence dataset, in which case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_ranges(
  x = NULL,
  y = NULL,
  xcols = c("genus", "max_ma", "min_ma"),
  ycols = NULL,
  flag.diff = 5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_ranges_+3A_x">x</code></td>
<td>
<p>Stratigraphic range data for taxa as a whole
or for individual fossil occurrences</p>
</td></tr>
<tr><td><code id="flag_ranges_+3A_y">y</code></td>
<td>
<p>The same as in x. This is the dataset to
which ranges will be compared</p>
</td></tr>
<tr><td><code id="flag_ranges_+3A_xcols">xcols</code></td>
<td>
<p>A character vector of length three
specifying, in the following order, the taxonomic name,
stratigraphic base (FAD) and stratigraphic top (LAD)
columns in x.</p>
</td></tr>
<tr><td><code id="flag_ranges_+3A_ycols">ycols</code></td>
<td>
<p>An optional character vector of length
three for the same column types as in xcols, but for
dataset y. This is useful if the column names differ
between the datasets</p>
</td></tr>
<tr><td><code id="flag_ranges_+3A_flag.diff">flag.diff</code></td>
<td>
<p>A vector of thresholds, given in millions
of years which will be used to flag discrepancies
between occurrence FADs and LADs with respect to the
reference range. This is a convenience parameter so that
occurrences with large discrepancies can be quickly
identified. Multiple thresholds can be supplied</p>
</td></tr>
<tr><td><code id="flag_ranges_+3A_verbose">verbose</code></td>
<td>
<p>A logical of length one determining if
the flagging progress should be reported to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data.frames, the first recording
overall error statistics, the second recording error
types for each element of x. In the second data.frame,
FAD or LAD differences in excess of the supplied threshold(s)
are marked with 1, otherwise 0
</p>


<h3>See Also</h3>

<p>age_ranges is called internally to generate
the range table for comparison.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example datasets
data(brachios)
data(sepkoski)
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# update brachios to GTS2020 to match Sepkoski
brachios &lt;- chrono_scale(brachios, srt = "early_interval", end = "late_interval",
                          max_ma = "max_ma", min_ma = "min_ma", verbose = FALSE)
brachios$max_ma &lt;- brachios$newFAD
brachios$min_ma &lt;- brachios$newLAD
# drop occurrences with older LADs than FADs
brachios &lt;- brachios[brachios$max_ma &gt; brachios$min_ma,]
# trim the Sepkoski Compendium to the relevant entries
sepkoski &lt;- sepkoski[which(sepkoski$PHYLUM == "Brachiopoda"),]
# run flag ranges
flg &lt;- flag_ranges(x = brachios, y = sepkoski, ycols = c("GENUS", "RANGE_BASE", "RANGE_TOP"))
</code></pre>

<hr>
<h2 id='format_check'>format_check</h2><span id='topic+format_check'></span>

<h3>Description</h3>

<p>Function to perform a series of basic formatting checks
geared towards taxonomic name data. The function very
simply checks for non letter characters in the taxonomic
names, that species-level names contain two words, and
genus-level and above names contain one word.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_check(x, ranks, species = FALSE, species_sep = " ", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_check_+3A_x">x</code></td>
<td>
<p>A dataframe with hierarchically organised, taxonomic
information. If x only comprises the taxonomic information,</p>
</td></tr>
<tr><td><code id="format_check_+3A_ranks">ranks</code></td>
<td>
<p>does not need to be specified, but the columns
must be in order of decreasing taxonomic rank @param ranks
The column names of the taxonomic data fields in x. These
must be provided in order of decreasing taxonomic rank</p>
</td></tr>
<tr><td><code id="format_check_+3A_species">species</code></td>
<td>
<p>A logical indicating if x contains a species
column. As the data must be supplied in hierarchical order,
this column will naturally be the last column in x and
species-specific spell checks will be performed on this column.</p>
</td></tr>
<tr><td><code id="format_check_+3A_species_sep">species_sep</code></td>
<td>
<p>A character vector of length one specifying
the genus name and specific epithet in the species column, if
present</p>
</td></tr>
<tr><td><code id="format_check_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if any flagged
errors should be reported to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two lists. The first list flags the row
indexes of columns whose elements contains non-letter characters.
The second list flags the row indexes  of columns whose elements
do not contain the correct numbers of words
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# define ranks
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# run function
flag &lt;- format_check(brachios, ranks = b_ranks)
</code></pre>

<hr>
<h2 id='geog_lookup'>geog_lookup</h2><span id='topic+geog_lookup'></span>

<h3>Description</h3>

<p>lookup table called by 'get_pbdb'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geog_lookup
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 511 rows and 2 columns.
</p>

<hr>
<h2 id='get_pbdb'>get_pbdb</h2><span id='topic+get_pbdb'></span>

<h3>Description</h3>

<p>Function for downloading Paleobiology Database (PBDB) data
(saved to disk and/or imported into R) or generating PBDB
API-compatible URLs. If downloading data over timespans
greater than 100 Ma, the download is performed in 100 Ma
chunks to better track the download progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pbdb(
  taxon = NULL,
  interval = NULL,
  mode = "occurrence",
  res = "all",
  fields = c("ident", "coords", "class"),
  ex_taxon = NULL,
  area = NULL,
  ex_area = NULL,
  invert_area = FALSE,
  litho = NULL,
  invert_litho = FALSE,
  env = NULL,
  ex_env = NULL,
  invert_env = NULL,
  pres = NULL,
  idqual = NULL,
  return_url = FALSE,
  return_data = TRUE,
  save_as = NULL,
  tscale = "ICS2013",
  wait = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pbdb_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of taxon names. Prepending
a taxon name with ^ will exclude it from the PBDB search.
Alternatively @param ex_taxon can be used to do this</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_interval">interval</code></td>
<td>
<p>A numeric vector of length two with positive
ages in Ma, or a character vector containing one or two ICS
chronostratigraphic interval names</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_mode">mode</code></td>
<td>
<p>A character vector of length one specifying the
type of data to return: one of occurrence, collection, taxa,
specimen, measurement, strata, diversity, opinion or reference</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_res">res</code></td>
<td>
<p>A character vector of length one specifying the
taxonomic resolution of the dataset: one of all, family, genus
species, lump_genus or lump_subgen. The latter two lump
multiple occurrences of genera or subgenera within collections
into a single representative occurrence</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_fields">fields</code></td>
<td>
<p>A character vector of PBDB vocabulary for
additional data fields to download:
see https://paleobiodb.org/data1.2/occs/list_doc.html</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_ex_taxon">ex_taxon</code></td>
<td>
<p>A character vector of taxon names to exclude
from the PBDB search</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_area">area</code></td>
<td>
<p>If not NULL, then a numeric vector of length four
specifying, in order, the min lng, max lng, min lat and max
lat of the area from which occurrences will be returned, in
decimal degrees (equator = 0 lat, prime meridian = 0 lng).
Alternatively, a character vector of regions from which
occurrences will be returned: any valid country name or ISO2
code. Continent names and codes are also supported as follows:
ATA Antarctica, AFR Africa, ASI Asia, AUS Australia, EUR
Europe, IOC Indian Ocean, NOA North America, OCE Oceania,SOA
South America</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_ex_area">ex_area</code></td>
<td>
<p>If not NULL, then a character vector of
valid country names or ISO2 codes, as in @param area (), from
which occurrences will be excluded from a PBDB search</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_invert_area">invert_area</code></td>
<td>
<p>If TRUE, then regions specified in area
will be excluded from a PBDB search, except for the regions
specified in ex_area</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_litho">litho</code></td>
<td>
<p>If not NULL, a character vector of PBDB vocabulary
corresponding to which lithologies a PBDB search should return</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_invert_litho">invert_litho</code></td>
<td>
<p>If TRUE, a character vector of PBDB
vocabulary corresponding to which lithologies a PBDB search
should exclude</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_env">env</code></td>
<td>
<p>If not NULL, a character vector of PBDB vocabulary
corresponding to which environments a PBDB search should return</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_ex_env">ex_env</code></td>
<td>
<p>If not NULL, a character vector of PBDB vocabulary
corresponding to which environments a PBDB search should exclude</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_invert_env">invert_env</code></td>
<td>
<p>If TRUE, then environments specified in env
will be excluded from a PBDB search, except for the environments
specified in ex_env</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_pres">pres</code></td>
<td>
<p>A character vector of length one specifying the
preservation mode of the occurrences to return: one of regular,
form, ichno, or 'form,ichno'</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_idqual">idqual</code></td>
<td>
<p>A character vector of length one specifying the
taxonomic certainty of the occurrences to return: one of certain,
genus_certain, uncertain, new&quot;</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_return_url">return_url</code></td>
<td>
<p>If TRUE, the function will return a correctly
formatted url suitable for use with curl or similar API functions,
comprising the search parameters set by the user</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_return_data">return_data</code></td>
<td>
<p>If TRUE (default), the downloaded csv will
automatically be read into R (this must be assigned to an object)</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_save_as">save_as</code></td>
<td>
<p>If not NULL, the file name to which the downloaded
data will be saved on the disk as a .csv</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_tscale">tscale</code></td>
<td>
<p>A character vector of length one determining what
chronostratigraphic timescale will be applied to the data. &quot;ICS2013&quot;
will retain the PBDB ICS 2013 standard. &quot;GTS2020&quot; will update all
early and late interval ages to the GTS2020 standard, using a
lookup table supplied with the function. Alternatively, the
pathway to a custom .csv file  with columns Interval, FAD and
LAD where Interval are the names of the early and late intervals
in the PBDB, and FAD and LAD are the numeric lower and upper
boundaries of those intervals</p>
</td></tr>
<tr><td><code id="get_pbdb_+3A_wait">wait</code></td>
<td>
<p>The maximum wait time for the download in milliseconds,
as used by curl. This is set to no wait time by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a PBDB API compatible URL or a PBDB dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'># download Triassic dinosaurs (wait time set to meet CRAN example requirement)
tdinos &lt;- fossilbrush:::get_pbdb(taxon = "Dinosauria", interval = "Triassic", wait = 499)
</code></pre>

<hr>
<h2 id='GTS2020'>GTS2020</h2><span id='topic+GTS2020'></span>

<h3>Description</h3>

<p>lookup table called by 'get_pbdb'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GTS2020
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1535 rows and 9 columns.
</p>

<hr>
<h2 id='GTS2020_changelog'>GTS2020_changelog</h2><span id='topic+GTS2020_changelog'></span>

<h3>Description</h3>

<p>changelog of periodic updates made to the GTS2020 table originally
published in this package. The purpose of this changelog is to allow
the user to assess how up-to-date the resource is and made any changes
themselves if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GTS2020_changelog
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

<hr>
<h2 id='intersect_ranges'>intersect_ranges</h2><span id='topic+intersect_ranges'></span>

<h3>Description</h3>

<p>Function to find the maximum intersection between a set
of numeric ranges, in this case first and last appearence
datums on taxonomic ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_ranges(x, srt = NULL, end = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_ranges_+3A_x">x</code></td>
<td>
<p>A numeric data.frame or matrix of ranges. If
just two columns are supplied, the first column is assumed
to be the srt column</p>
</td></tr>
<tr><td><code id="intersect_ranges_+3A_srt">srt</code></td>
<td>
<p>If x contains more than two columns, srt is the
name of the range base column - the FAD</p>
</td></tr>
<tr><td><code id="intersect_ranges_+3A_end">end</code></td>
<td>
<p>If x contains more than two columns, end is the
name of the range top column - the LAD</p>
</td></tr>
<tr><td><code id="intersect_ranges_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether the function
should report progress to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with three columns, indicating the intersection
(FAD and LAD) and the number of ranges that intersection
encompasses
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot an example
df &lt;- cbind(c(1.5, 3, 2.1, 1), c(6, 5, 3.7, 10.1))
plot(1:11, ylim = c(0, 5), col = NA)
segments(x0 = c(1.5, 3, 2.1, 1), y0 = 1:4, x1 = c(6, 5, 3.7, 10.1), y1 = 1:4)
abline(v = 3, col  = "red", lty = 2)
abline(v = 3.7, col  = "red", lty = 2)
# intersect function
intersect_ranges(df)
</code></pre>

<hr>
<h2 id='pacmacro_ranges'>pacmacro_ranges</h2><span id='topic+pacmacro_ranges'></span>

<h3>Description</h3>

<p>Function to apply a modification of Pacman trimming to
macrofossil data. The function generates a densified
occurrence record using the same methods as <code>densify</code>
then trim the upper and lower ranges by a user-defined
percentage. The full and trimmed ranges are then
compared against each other to test if the FAD and the
LAD for a taxon form a long tail in its distribution.
Multiple tail thresholds can be supplied, but all test
to see if the sum of the FAD and LAD which exceeds the
trimmed range constitute the threshold proportion of the
total range for than taxon, e.g. does the FAD and the
LAD outside of the trimmed range comprise a quarter
(<code>tail.flag = 0.25</code>) of the taxon range?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pacmacro_ranges(
  x,
  rank = "genus",
  srt = "max_ma",
  end = "min_ma",
  step = 1,
  density = 0.1,
  top = 5,
  bottom = 5,
  tail.flag = 0.35,
  method = c("histogram", "kernel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pacmacro_ranges_+3A_x">x</code></td>
<td>
<p>A stratigraphic occurrence dataset</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_rank">rank</code></td>
<td>
<p>The column name in x containing the taxon
names for which trimmed ranges will be calculated</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_srt">srt</code></td>
<td>
<p>A column name in x denoting the occurrence FADs</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_end">end</code></td>
<td>
<p>A column name in x denoting the occurrence LADs</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_step">step</code></td>
<td>
<p>A positive integer specifying the time window size
(i.e. the duration represented by each row in the output matrix)</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_density">density</code></td>
<td>
<p>A positive numeric specifying the step size for
densifying records. This should ideally be smaller than step</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_top">top</code></td>
<td>
<p>The percentage by which the top of the range will
be trimmed</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_bottom">bottom</code></td>
<td>
<p>The percentage by which the bottom of the range
will be trimmed</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_tail.flag">tail.flag</code></td>
<td>
<p>a numeric vector of proportions in the range
0 &gt; x &gt; 1 which will be used to test for long tails</p>
</td></tr>
<tr><td><code id="pacmacro_ranges_+3A_method">method</code></td>
<td>
<p>The method for quantifying occurrence density. By
default both histogram and kernel density will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the user specifies a specific method (e.g. method = &quot;kernel&quot;),
the returned value will be a data.frame containing the taxa as row names,
the original taxon ranges (FAD, LAD), their ranges as trimmed by the
specified value (default FAD95, LAD95), and the tail status (0 = none, 1 = tail)
at the user-specified tail proportions. If method is not specified, the result
will be a list of 2 data.frames, one for each method
</p>


<h3>Source</h3>

<p>Pacman procedure modified from https://rdrr.io/github/plannapus/CONOP9companion/src/R/pacman.R.
</p>


<h3>References</h3>

<p>Lazarus et al (2012) Paleobiology
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# run pacmacro
pacm &lt;- pacmacro_ranges(brachios, tail.flag = c(0.3, 0.35, 0.4),
                        rank = "genus", srt = "max_ma", end = "min_ma")
</code></pre>

<hr>
<h2 id='pbdb_fields'>geog_lookup</h2><span id='topic+pbdb_fields'></span>

<h3>Description</h3>

<p>lookup table called by 'get_pbdb'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbdb_fields
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 31.
</p>

<hr>
<h2 id='pbdb_kingdoms'>pbdb_kingdoms</h2><span id='topic+pbdb_kingdoms'></span>

<h3>Description</h3>

<p>lookup table called by 'get_pbdb'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbdb_kingdoms
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='plot_dprofile'>plot_dprofile</h2><span id='topic+plot_dprofile'></span>

<h3>Description</h3>

<p>Function to plot density profiles of occurrences through
time using the output of @seealso densify.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dprofile(x, taxon, exit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dprofile_+3A_x">x</code></td>
<td>
<p>The list output of @seealso densify</p>
</td></tr>
<tr><td><code id="plot_dprofile_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of length one, specifying
one of the taxon names in x to be plotted</p>
</td></tr>
<tr><td><code id="plot_dprofile_+3A_exit">exit</code></td>
<td>
<p>Restore base plotting parameters on function exit
(default as a requirement for CRAN). Can be set to false to allow
other elements to be aded to a plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, the plotted density profile
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# densify ranges
dens &lt;- densify(brachios)
plot_dprofile(dens, "Atrypa")
</code></pre>

<hr>
<h2 id='plot_taxa'>plot_taxa</h2><span id='topic+plot_taxa'></span>

<h3>Description</h3>

<p>Function to plot the parent or child relationships of an
element in a hierarchically organised dataframe. Multiple
taxa can be plotted simultaneously
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_taxa(
  x,
  taxon,
  trank,
  ranks,
  mode = c("parent", "child", "all"),
  step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_taxa_+3A_x">x</code></td>
<td>
<p>a dataframe containing hierarchically organised
data in columns</p>
</td></tr>
<tr><td><code id="plot_taxa_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of element names whose
relationships will be plotted (these must be of the same
rank)</p>
</td></tr>
<tr><td><code id="plot_taxa_+3A_trank">trank</code></td>
<td>
<p>A character vector of length one corresponding
to the column name in x in which taxa is located</p>
</td></tr>
<tr><td><code id="plot_taxa_+3A_ranks">ranks</code></td>
<td>
<p>A character vector corresponding to the column
names in x, given in hierarchical order</p>
</td></tr>
<tr><td><code id="plot_taxa_+3A_mode">mode</code></td>
<td>
<p>The direction of the relationships to be
plotted</p>
</td></tr>
<tr><td><code id="plot_taxa_+3A_step">step</code></td>
<td>
<p>A positive integer specifinyg the
neighbourhood of the relationships to plot. Specifying
a number greater than the number of ranks will not cause a
failure, and will instead plot all relationships in the
direction specified in mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the relationships of the specified
elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# define ranks in dataset
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# plot taxon
plot_taxa(brachios, "Atrypa", trank = "genus", ranks = b_ranks, mode = "parent")
</code></pre>

<hr>
<h2 id='quantile_coef_density_BMS'>quantile_coef_density_BMS</h2><span id='topic+quantile_coef_density_BMS'></span>

<h3>Description</h3>

<p>Static rip of the quantile.coef.density
function and relevant internals from the
BMS package as the package is archived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_coef_density_BMS(
  x,
  probs = seq(0.25, 0.75, 0.25),
  names = TRUE,
  normalize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_coef_density_BMS_+3A_x">x</code></td>
<td>
<p>a object of class pred.density, coef.density, density, or a list of densities</p>
</td></tr>
<tr><td><code id="quantile_coef_density_BMS_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in range 0 - 1. Elements very close to the boundaries return Inf or -Inf</p>
</td></tr>
<tr><td><code id="quantile_coef_density_BMS_+3A_names">names</code></td>
<td>
<p>logical; if TRUE, the result has a names attribute, resp. a rownames and colnames attributes. Set to FALSE for speedup with many probs</p>
</td></tr>
<tr><td><code id="quantile_coef_density_BMS_+3A_normalize">normalize</code></td>
<td>
<p>logical if TRUE then the values in x$y are multiplied with a factor such that their integral is equal to one</p>
</td></tr>
<tr><td><code id="quantile_coef_density_BMS_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is of class density (or a list with exactly one element), a vector with quantiles.
If x is a list of densities with more than one element (e.g. as resulting from pred.density or coef.density),
then the output is a matrix of quantiles, with each matrix row corresponding to the respective density.
</p>


<h3>Source</h3>

<p>static rip from BMS package
</p>

<hr>
<h2 id='resolve_duplicates'>resolve_duplicates</h2><span id='topic+resolve_duplicates'></span>

<h3>Description</h3>

<p>Function for identifying and resolving alternative higher
assignments in a hierarchically structured dataframe.
Columns are checked from the lowest to the highest rank for
elements with multiple higher assignments. These assignments
are then assessed topologically to determine if they
represent inadvertent use of the same name at a given rank
for genuinely different entities, or whether the higher
classifications are conflicting. In the case of the former,
unique character suffixes are applied to each differently
classified case (up to 26 currently supported), effectively
splitting up the alternatively classified element. In the
case of the latter, the alternative classifications are
assessed and are either combined, or the more frequently
used or the more complete classification scheme is taken
(the more frequent pathway can also be the most complete).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_duplicates(x, ranks = NULL, jump = 4, plot = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_duplicates_+3A_x">x</code></td>
<td>
<p>A dataframe containing hierarchically structured
information, for example a table of genus names and their
higher taxonomic classifications</p>
</td></tr>
<tr><td><code id="resolve_duplicates_+3A_ranks">ranks</code></td>
<td>
<p>If not NULL, a vector of column names of x,
given in rank order. This is useful if x contains columns
which are not rank relevant or if columns are not in
hierarchical order. If not supplied, the column order in x
is used directly and is assumed to be in rank order</p>
</td></tr>
<tr><td><code id="resolve_duplicates_+3A_jump">jump</code></td>
<td>
<p>The maximum number of levels between the point of
divergence and the point of reunion (if present) for a given
path, below which the divergence will be taken as conflicting</p>
</td></tr>
<tr><td><code id="resolve_duplicates_+3A_plot">plot</code></td>
<td>
<p>A logical speciying if the divergent paths should
be plotted</p>
</td></tr>
<tr><td><code id="resolve_duplicates_+3A_verbose">verbose</code></td>
<td>
<p>A logical of length one which determines if
the function should report the detection and resolution of
elements with multiple higher classifications (if any)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataframe x, with any alternative higher
classifications resolved, giving the classification a strict
tree structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# define ranks
b_ranks &lt;- c("phylum", "class", "order", "family", "genus")
# run function
res &lt;- resolve_duplicates(brachios, ranks = b_ranks)
</code></pre>

<hr>
<h2 id='revise_ranges'>revise_ranges</h2><span id='topic+revise_ranges'></span>

<h3>Description</h3>

<p>Function to generate a consensus age for assemblages
of fossil data in x, given a table of taxonomic
ranges. The need for error-checking is informed by
the error codes for the individual fossil
occurrences within each collection - if there is no
error, then the consensus age is unchanged. If
errors are present, then a consensus age for a
threshold proportion of taxa is searched for using
the overlap of the ranges for those taxa, as given
in range table y. Taxa whose occurrences lie outside
this consensus age are flagged as potential taxonomic
errors. If the threshold consensus partially overlaps
with the assemblage age, this overlap is returned to
present overzealous alteration of the age - otherwise
the complete consensus age is returned. If a
consensus age cannot be found, the original assemblage
age is returned, and each occurrence in the collection
flagged as potential taxonomic errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revise_ranges(
  x,
  y,
  assemblage = "collection_no",
  srt = "max_ma",
  end = "min_ma",
  taxon = "genus",
  err = NULL,
  do.flag = FALSE,
  prop = 0.75,
  allow.zero = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revise_ranges_+3A_x">x</code></td>
<td>
<p>Fossil occurrence data grouped into
spatiotemporally distinct assemblages</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_y">y</code></td>
<td>
<p>A stratigraphic range dataset from which
consensus assemblage ages will be derived</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_assemblage">assemblage</code></td>
<td>
<p>The column name of the assemblage
groups in x</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_srt">srt</code></td>
<td>
<p>The column name of stratigraphic bases for
each element in both x and y - i.e. x and y must have
this same name for that column</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_end">end</code></td>
<td>
<p>The column name of stratigraphic tops for
each element in both x and y - i.e. x and y must have
this same name for that column</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_taxon">taxon</code></td>
<td>
<p>The column name denoting the taxon names
in both x and y - i.e. x and y must have
this same name for that column</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_err">err</code></td>
<td>
<p>The column name flagging age errors for
occurrences in x. This allows 100$ valid assemblages to
be skipped. Age errors can be derived using @seealso
flag_ranges. All error codes must be one of: &quot;000&quot; -
unchecked, &quot;R1R&quot; - valid, &quot;0R0&quot; - both FAD and LAD exceeded,
&quot;00R&quot; - totally older than range, &quot;R00&quot; - totally younger
than range, &quot;01R&quot; - FAD exceeded, &quot;1R0&quot; - LAD exceeded.
If not supplied, all assemblages will be checked, even if
they are already valid a priori.</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_do.flag">do.flag</code></td>
<td>
<p>Rather than supplying error codes, should
flag_ranges be called internally to generate error codes
for supply to the rest of revise_ranges? As with err, this
is useful to prefilter individual occurrences, allowing
assemblages contain all valid, all unchecked or a mixture
of such error codes to be skipped. This can massively speed
up processing time for large datasets.</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_prop">prop</code></td>
<td>
<p>A numeric, between 0 and 1, denoting the
threshold percentage of taxa in the assemblage for
which a consensus age must be found</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_allow.zero">allow.zero</code></td>
<td>
<p>A logical determining if, in the
case of a collection LAD being equal to the consensus
age FAD (i.e. a pointwise overlap), that pointwise
age will be taken as the revised age. The resultant
collection age will have no uncertainty as a result,
which may be unrealistic. The default behaviour is
FALSE, in which case pointwise overlaps will be
ignored and the revised age taken instead</p>
</td></tr>
<tr><td><code id="revise_ranges_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if the progress
of the redating procedure should be reported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes, the first recording
the results of the consensus redating procedure for
each assemblage in x, the second recording any flags
(if any) for each occurrence in x
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load datasets
data("brachios")
data("sepkoski")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# rename columns in Sepkoski to match brachios
colnames(sepkoski)[4:6] &lt;- c("genus", "max_ma", "min_ma")
# flag and resolve against the Sepkoski Compendium, collection-wise
revrng &lt;- revise_ranges(x = brachios, y = sepkoski, do.flag = TRUE, verbose = TRUE,
                        taxon = "genus", assemblage = "collection_no",
                        srt = "max_ma", end = "min_ma")
# append the revised occurrence ages and error codes to the dataset
brachios$newfad &lt;- revrng$occurrence$FAD
brachios$newlad &lt;- revrng$occurrence$LAD
brachios$errcode &lt;- revrng$occurence$status
</code></pre>

<hr>
<h2 id='sep_code'>sep_code</h2><span id='topic+sep_code'></span>

<h3>Description</h3>

<p>Lookup table of chronostratigraphic stage abbreviations
used in the Sepkoski Compendium, with interval boundaries
updated to the GTS2020 standard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sep_code)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 306 rows and 8 columns.
</p>


<h3>Source</h3>

<p>chronosphere (fetch), Sepkoski 2002
</p>

<hr>
<h2 id='sepkoski'>sepkoski</h2><span id='topic+sepkoski'></span>

<h3>Description</h3>

<p>An example dataset. A port of the Sepkoski Compendium
from the chronosphere package, with a few corrections
and GTS2020 dating applied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepkoski
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 35700 rows and 6 columns.
</p>

<hr>
<h2 id='spell_check'>spell_check</h2><span id='topic+spell_check'></span>

<h3>Description</h3>

<p>Function for checking for potential synonyms with alternate
spellings. Synonyms are checked for within group using using
a Jaro Winkler string distance matrix. Potential synonyms are
selected using the jw threshold. These can then be further
filtered by the number of shared letters at the beginning and
end of the a synonym pair, and by prefixes or suffixes which
may give erroneously high similarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spell_check(
  x,
  terms = NULL,
  groups = NULL,
  jw = 0.1,
  str = 1,
  str2 = NULL,
  alternative = "jaccard",
  q = 1,
  pref = NULL,
  suff = NULL,
  exclude = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spell_check_+3A_x">x</code></td>
<td>
<p>a dataframe containing a column with terms, and a
further column denoting the groups within which terms will
be checked against one another. If supplying a dataframe with
just these columns, terms should be column 1</p>
</td></tr>
<tr><td><code id="spell_check_+3A_terms">terms</code></td>
<td>
<p>a character vector of length 1, specifying the
terms column in x. This is required if x contains more than
two columns. Alternatively, if x is not provided, terms can
be a character vector. If groups are not specified, all
elements of terms will be treated as part of the same group</p>
</td></tr>
<tr><td><code id="spell_check_+3A_groups">groups</code></td>
<td>
<p>a character vector of length 1, specifying the
groups column in x. This is required if x contains more than
two columns. Alternatively, if terms is supplied as a
character vector, groups can also be supplied in the same way
to denote their groups</p>
</td></tr>
<tr><td><code id="spell_check_+3A_jw">jw</code></td>
<td>
<p>a numeric greater than 0 and less than 1. This is
the distance threshold below which potential synonyms will be
considered</p>
</td></tr>
<tr><td><code id="spell_check_+3A_str">str</code></td>
<td>
<p>A positive integer specifying the
number of matching characters at the beginning of synonym
pairs. By default 1, i.e. the first letters must match</p>
</td></tr>
<tr><td><code id="spell_check_+3A_str2">str2</code></td>
<td>
<p>If not NULL, a positive integer specifying the
number of matching characters at the end of synonym pairs</p>
</td></tr>
<tr><td><code id="spell_check_+3A_alternative">alternative</code></td>
<td>
<p>A character string of length one corresponding
to one of the methods used by @seealso afind. One of &quot;osa&quot;,
&quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;,
&quot;running_cosine&quot;, &quot;jaccard&quot;, or &quot;soundex&quot;.</p>
</td></tr>
<tr><td><code id="spell_check_+3A_q">q</code></td>
<td>
<p>q-gram size. Only used when alternative is &quot;qgram&quot;,
&quot;cosine&quot; or &quot;Jaccard&quot;.</p>
</td></tr>
<tr><td><code id="spell_check_+3A_pref">pref</code></td>
<td>
<p>If not NULL, a character vector of prefixes which
may result in erroneously low JW distances. Synonyms will only
be considered if both terms share the same prefix</p>
</td></tr>
<tr><td><code id="spell_check_+3A_suff">suff</code></td>
<td>
<p>If not NULL, a character vector of suffices which
may result in erroneously low JW distances. Synonyms will only
be considered if both terms share the same suffix</p>
</td></tr>
<tr><td><code id="spell_check_+3A_exclude">exclude</code></td>
<td>
<p>If not NULL, a character vector of group names
which should be skipped - useful for groups which are known
to contain potentially similar terms</p>
</td></tr>
<tr><td><code id="spell_check_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress be reported using the
pbapply progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of synonyms (cols 1 and 2), the group in
which they occur, the frequencies of each synonym in the dataset
and finally the q-gram difference between the synonyms
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# define suffixes
b_suff &lt;- c("ina", "ella", "etta")
# run function
spl &lt;- spell_check(brachios, terms = "genus", groups = "family", suff = b_suff)
</code></pre>

<hr>
<h2 id='tgraph'>tgraph</h2><span id='topic+tgraph'></span>

<h3>Description</h3>

<p>Function to create a tgraph representation of a
hierarchically organised dataframe. This is the focal
object of the t* functions - the complete set of
hierarchical relationships between a set of elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgraph(x, ranks = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tgraph_+3A_x">x</code></td>
<td>
<p>A dataframe containing a set of hierarchical
relationships. The leftmost column contains the
elements which will form the highest rank, followed
rightwards by successive ranks</p>
</td></tr>
<tr><td><code id="tgraph_+3A_ranks">ranks</code></td>
<td>
<p>If not NULL, a vector of column names of x,
given in rank order. This is useful if x contains
columns which are not rank relevant or if columns are
not in hierarchical order. If not supplied, the
column order in x is used directly and is assumed to
be in rank order</p>
</td></tr>
<tr><td><code id="tgraph_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether the
progress of tgraph construction should be reported
to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tgraph object
</p>

<hr>
<h2 id='threshold_peaks'>threshold_peaks</h2><span id='topic+threshold_peaks'></span>

<h3>Description</h3>

<p>Function to detect if two peaks in a density spectrum can
be considered separate based on a user supplied threshold.
Creates a sequence of divisions from the troughs immediately
preceding any significant peaks, then bins occurrences for
a given taxon name by those divisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold_peaks(
  x,
  y,
  ycols = c("genus", "max_ma", "min_ma"),
  thresh = 15,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_peaks_+3A_x">x</code></td>
<td>
<p>A list of significant peaks as returned by <code>find_peaks</code></p>
</td></tr>
<tr><td><code id="threshold_peaks_+3A_y">y</code></td>
<td>
<p>An occurrence dataset with taxon names corresponding
to the list names of x</p>
</td></tr>
<tr><td><code id="threshold_peaks_+3A_ycols">ycols</code></td>
<td>
<p>A character vector denoting, in order, the taxon, FAD
and LAD columns in y</p>
</td></tr>
<tr><td><code id="threshold_peaks_+3A_thresh">thresh</code></td>
<td>
<p>The threshold distance between peaks above which
they will be considered distinct - given in Ma</p>
</td></tr>
<tr><td><code id="threshold_peaks_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress
should be reported</p>
</td></tr>
</table>

<hr>
<h2 id='threshold_ranges'>threshold_ranges</h2><span id='topic+threshold_ranges'></span>

<h3>Description</h3>

<p>Function to detect if two peaks in a density spectrum can
be considered separate based on a user supplied threshold.
Creates a sequence of divisions from the troughs immediately
preceding any significant peaks, then bins occurrences for
a given taxon name by those divisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold_ranges(
  x,
  rank = "genus",
  srt = "max_ma",
  end = "min_ma",
  method = "kernel",
  step = 1,
  density = 0.1,
  use_sd = TRUE,
  win = 5,
  thresh = 5,
  ...,
  report = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_ranges_+3A_x">x</code></td>
<td>
<p>An occurrence dataset containing taxon names,
maximum ages and minimum ages</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_rank">rank</code></td>
<td>
<p>The column name in x containing the taxon names</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_srt">srt</code></td>
<td>
<p>A column name in x denoting the occurrence maximum ages</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_end">end</code></td>
<td>
<p>A column name in x denoting the occurrence minumum ages</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_method">method</code></td>
<td>
<p>The method for quantifying occurrence density: one
histogram or kernel. Kernel is the recommended default. As called
be @seealso densify</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_step">step</code></td>
<td>
<p>A positive integer specifying the time window size
for density calculation. As called by @seealso densify</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_density">density</code></td>
<td>
<p>A positive numeric specifying the step size for
densifying records. This should ideally be smaller than step.
As called by @seealso densify</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_use_sd">use_sd</code></td>
<td>
<p>A logical determining whether to use peaks detected
as significant using the mean + standard deviation of its neighbourhood.
If FALSE, then the peaks need only be greater than the neighbourhood
mean to be significant. Thus, use_sd is more conservative, but less
prone to noise. As called by @seealso find_peaks</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_win">win</code></td>
<td>
<p>A positive integer specifying the neighborhood window length
on either side of a peak durign significance testing (i.e. win 5 will
give a total window of 11: -5 indices + peak index + 5 indices). As
called by @seealso find_peaks</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_thresh">thresh</code></td>
<td>
<p>The threshold distance between peaks above which
they will be considered distinct - given in Ma</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_...">...</code></td>
<td>
<p>additional arguments passed to @seealso density</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_report">report</code></td>
<td>
<p>A logical determining if the analytical outputs of the
function be returned to the user, as well as the revised taxon names, TRUE
by default</p>
</td></tr>
<tr><td><code id="threshold_ranges_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining if function progress
should be reported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If report = TRUE (the default), a list of five elements. $data
gives the thresholded (and potentially subdivided) taxon names. $matrix
is the taxon-wise matrix of occurrence densities. $peaks is a list
containing three lists of peaks (all peaks, significant by mean + sd,
significant by sd only) for each taxon and a dataframe of peak counts
between the three treatments. $comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data("brachios")
# subsample brachios to make for a short example runtime
set.seed(1)
brachios &lt;- brachios[sample(1:nrow(brachios), 1000),]
# interpeak thresholding
itp &lt;- threshold_ranges(brachios, win = 8, thresh = 10,
                        rank = "genus", srt = "max_ma", end = "min_ma")
</code></pre>

<hr>
<h2 id='update_graph'>update_graph</h2><span id='topic+update_graph'></span>

<h3>Description</h3>

<p>Function to update the structure of a graph, given
a set of modification as returned by assess_duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_graph(x, del = NULL, add = NULL, changes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_graph_+3A_x">x</code></td>
<td>
<p>a tgraph object to modify</p>
</td></tr>
<tr><td><code id="update_graph_+3A_del">del</code></td>
<td>
<p>A vector of element names or numbers to delete</p>
</td></tr>
<tr><td><code id="update_graph_+3A_add">add</code></td>
<td>
<p>An edge sequence of edges to add to the graph</p>
</td></tr>
<tr><td><code id="update_graph_+3A_changes">changes</code></td>
<td>
<p>Alternatively, the output of
assess_duplicates, containing proposed deletions and
additions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated tgraph object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
