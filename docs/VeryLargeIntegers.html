<!DOCTYPE html><html lang="en"><head><title>Help for package VeryLargeIntegers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VeryLargeIntegers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#01.+20Basics'><p>Very Large Integers Basics</p></a></li>
<li><a href='#02.+20Arithmetic+20and+20logic'><p>Basic Arithmetic and Logical Operators for vli Objects</p></a></li>
<li><a href='#03.+20Roots'><p>Integer roots for vli Objects</p></a></li>
<li><a href='#04.+20Logarithms'><p>Integer Logarithms for vli Objects</p></a></li>
<li><a href='#05.+20Efficent+20division+20by+20a+20power+20of+202'><p>Efficient Division by a Power of 2</p></a></li>
<li><a href='#06.+20Binomial+20coefficients'><p>Binomial Coefficients for vli Objects</p></a></li>
<li><a href='#07.+20Factorial'><p>Factorial of a vli Object</p></a></li>
<li><a href='#08.+20Modular-arithmetic'><p>Basic Modular-Arithmetic Operators for vli Objects</p></a></li>
<li><a href='#09.+20Greatest+20common+20divisor'><p>Greatest Common Divisor for vli Objects</p></a></li>
<li><a href='#10.+20Least+20common+20multiple'><p>Least Common Multiple for vli Objects</p></a></li>
<li><a href='#11.+20Extended+20Euclidean+20algorithm'><p>Extended Euclidean Algorithm for vli Objects</p></a></li>
<li><a href='#12.+20Perfect+20power'><p>Perfect Power Tools for vli Objects</p></a></li>
<li><a href='#13.+20Legrendre+27s+20Formula'><p>Legrendre's Formula for vli Objects</p></a></li>
<li><a href='#14.+20Finding+20a+20random+20divisor'><p>Finding a Random Divisor of a vli Object</p></a></li>
<li><a href='#15.+20Factorization'><p>Factorization of vli Objects</p></a></li>
<li><a href='#16.+20Jacobi+20Symbol'><p>Computation of the Jacobi Symbol for vli Objects</p></a></li>
<li><a href='#17.+20Euler+27s+20phi+20function'><p>Euler's Phi Function for vli Objects</p></a></li>
<li><a href='#18.+20Probabilistic+20primality+20tests'><p>Probabilistic Primality Tests for vli Objects</p></a></li>
<li><a href='#19.+20Finding+20all+20primes'><p>Finding All Primes Up to a Given Bound</p></a></li>
<li><a href='#20.+20Next+20prime+20number'><p>Next Prime Number</p></a></li>
<li><a href='#21.+20Pi+20function'><p>Pi Function Approximation for vli Objects</p></a></li>
<li><a href='#22.+20Counting+20the+20number+20of+20primes'><p>Counting the Number of Primes Up to a Given Bound</p></a></li>
<li><a href='#23.+20Fibonacci+20numbers'><p>Fibonacci Numbers Tools for vli Objects</p></a></li>
<li><a href='#24.+20Random+20generators'><p>Random Generators of vli Objects</p></a></li>
<li><a href='#25.+20Counting+201+20bits'><p>Counting the Number of 1-Bits in vli Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Store and Operate with Arbitrarily Large Integers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier Leiva Cuadrado</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier Leiva Cuadrado &lt;jleivacuadrado@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multi-precision library that allows to store and operate with arbitrarily big integers without
    loss of precision. It includes a large list of tools to work with them, like:
      - Arithmetic and logic operators
      - Modular-arithmetic operators
      - Computer Number Theory utilities
      - Probabilistic primality tests
      - Factorization algorithms
      - Random generators of diferent types of integers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.9)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-12 18:24:06 UTC; Javier</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-13 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='01.+20Basics'>Very Large Integers Basics</h2><span id='topic+01.+20Basics'></span><span id='topic+as.vli'></span><span id='topic+as.vli.default'></span><span id='topic+as.vli.vli'></span><span id='topic+as.vli.character'></span><span id='topic+as.vli.numeric'></span><span id='topic+asnumeric'></span><span id='topic+asnumeric.default'></span><span id='topic+asnumeric.vli'></span><span id='topic+as.integer.vli'></span><span id='topic+as.character.vli'></span><span id='topic+vli'></span><span id='topic+print.vli'></span><span id='topic+is.vli'></span>

<h3>Description</h3>

<p>vli is a S3 class that allows to store and operate with arbitrarily large integers. Each object of class vli has 3 attributes (<code>sign</code>, <code>length</code> and <code>value</code>) that can be accessed as shown in the examples. The (absolute) value of the number is stored in a numeric vector to avoid truncation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vli(n)

## Default S3 method:
as.vli(n)

## S3 method for class 'vli'
as.vli(n)

## S3 method for class 'character'
as.vli(n)

## S3 method for class 'numeric'
as.vli(n)

asnumeric(x)

## Default S3 method:
asnumeric(x)

## S3 method for class 'vli'
asnumeric(x)

## S3 method for class 'vli'
as.integer(x, ...)

## S3 method for class 'vli'
as.integer(x, ...)

vli(m)

## S3 method for class 'vli'
print(x, ...)

is.vli(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="01.+2B20Basics_+3A_n">n</code></td>
<td>
<p>value for the vli object being created; character or numeric</p>
</td></tr>
<tr><td><code id="01.+2B20Basics_+3A_x">x</code></td>
<td>
<p>object of class vli</p>
</td></tr>
<tr><td><code id="01.+2B20Basics_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="01.+2B20Basics_+3A_m">m</code></td>
<td>
<p>number of vli objects being initialized; numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>as.vli(n)</code>, if <code>n</code> is numeric, it must be a 32 bits integer to avoid the loss of precision. The idea is to use numeric objects only for small numbers. In other case, character objects are prefered.
The function <code>as.integer(x)</code>, where <code>x</code> a vli object, only works when the absolute value of <code>x</code> is up to 2.147.483.648 (32 bits). In other case it returns an error.
The function <code>asnumeric(x)</code> could cause loss of precision if the value of <code>x</code> is big.
The function <code>vli(m)</code> initialize a list of <code>m</code> objects of class vli.
Punctuation signs are ignored in the creation of vli objects (see the last example).
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a new vli object
x &lt;- as.vli("-89027148538375418689123052")

## Printing a vli object
print(x)

## Testing the class
is.vli(x)

## Coercing into a character object
as.character(x)

## Accessing to the attributes of the vli object
x$sign
x$value
x$length

## Punctuation signs are ignored
as.vli("2345.25")
</code></pre>

<hr>
<h2 id='02.+20Arithmetic+20and+20logic'>Basic Arithmetic and Logical Operators for vli Objects</h2><span id='topic+02.+20Arithmetic+20and+20logic'></span><span id='topic++2B.vli'></span><span id='topic+-.vli'></span><span id='topic++2A.vli'></span><span id='topic++2F.vli'></span><span id='topic++25+25.vli'></span><span id='topic+abs.vli'></span><span id='topic++5E.vli'></span><span id='topic++3E.vli'></span><span id='topic++3C.vli'></span><span id='topic++3E+3D.vli'></span><span id='topic++3C+3D.vli'></span><span id='topic++3D+3D.vli'></span><span id='topic++21+3D.vli'></span>

<h3>Description</h3>

<p>Basic arithmetic and logical operators for vli (Very Large Integers) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vli'
x + y

## S3 method for class 'vli'
x - y

## S3 method for class 'vli'
x * y

## S3 method for class 'vli'
x / y

## S3 method for class 'vli'
x %% y

## S3 method for class 'vli'
abs(x)

## S3 method for class 'vli'
x ^ y

## S3 method for class 'vli'
x &gt; y

## S3 method for class 'vli'
x &lt; y

## S3 method for class 'vli'
x &gt;= y

## S3 method for class 'vli'
x &lt;= y

## S3 method for class 'vli'
x == y

## S3 method for class 'vli'
x != y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="02.+2B20Arithmetic+2B20and+2B20logic_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="02.+2B20Arithmetic+2B20and+2B20logic_+3A_y">y</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in the creation of vli objects (through the function <code>as.vli</code>), punctuation signs will be ignored (see the last example).
</p>
<p>The algorithm implemented for the operator &quot;<code>*</code>&quot; computes the product with a trivial method when imput numbers have less than 40 digits and with the Karatsuba algorithm for fast multiplications when they are larger.
</p>


<h3>Value</h3>

<p>objects of class vli with the arithmetic operators; booleans with the logical operators
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("712376544526091241")
x ^ 61
x / as.vli("4225234")
x &gt; -x
x &lt;= 10000000
13.2415 - as.vli(132415)
</code></pre>

<hr>
<h2 id='03.+20Roots'>Integer roots for vli Objects</h2><span id='topic+03.+20Roots'></span><span id='topic+sqrt.vli'></span><span id='topic+sqrtrem'></span><span id='topic+sqrtrem.default'></span><span id='topic+sqrtrem.numeric'></span><span id='topic+sqrtrem.vli'></span><span id='topic+rootk'></span><span id='topic+rootk.default'></span><span id='topic+rootk.numeric'></span><span id='topic+rootk.vli'></span><span id='topic+rootkrem'></span><span id='topic+rootkrem.default'></span><span id='topic+rootkrem.numeric'></span><span id='topic+rootkrem.vli'></span>

<h3>Description</h3>

<p>Computation of integer roots and their remainders of vli (Very Large Integers) objects. Functions <code>sqrt</code> and <code>rootk</code> returns respectively the integer square root and the integer k-th root of the given value. Functions <code>sqrtrem</code> and <code>rootkrem</code> returns the corresponding remainder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vli'
sqrt(x)

sqrtrem(x)

## Default S3 method:
sqrtrem(x)

## S3 method for class 'numeric'
sqrtrem(x)

## S3 method for class 'vli'
sqrtrem(x)

rootk(x, k)

## Default S3 method:
rootk(x, k)

## S3 method for class 'numeric'
rootk(x, k)

## S3 method for class 'vli'
rootk(x, k)

rootkrem(x, k)

## Default S3 method:
rootkrem(x, k)

## S3 method for class 'numeric'
rootkrem(x, k)

## S3 method for class 'vli'
rootkrem(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="03.+2B20Roots_+3A_x">x</code></td>
<td>
<p>base of the root; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="03.+2B20Roots_+3A_k">k</code></td>
<td>
<p>index of the root; object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("4124135")
sqrt(x)
sqrtrem(x)
sqrt(x)^2 + sqrtrem(x) == x
## Not run: 
rootk(as.vli("1492346293864978561249785"), 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='04.+20Logarithms'>Integer Logarithms for vli Objects</h2><span id='topic+04.+20Logarithms'></span><span id='topic+log10.vli'></span><span id='topic+log10rem'></span><span id='topic+log10rem.default'></span><span id='topic+log10rem.numeric'></span><span id='topic+log10rem.vli'></span><span id='topic+log.vli'></span><span id='topic+logrem'></span><span id='topic+logrem.default'></span><span id='topic+logrem.numeric'></span><span id='topic+logrem.vli'></span><span id='topic+loge'></span><span id='topic+loge.default'></span><span id='topic+loge.numeric'></span><span id='topic+loge.vli'></span>

<h3>Description</h3>

<p>Computation of integer logarithms and their remainders for objects of class vli.
</p>
<p>Functions <code>log</code>, <code>log10</code> and <code>loge</code> return respectively the integer generalized logarithm, the integer base-10 logarithm and the integer natural logarithm of the given values. Functions <code>logrem</code> and <code>log10rem</code> returns the corresponding remainder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vli'
log10(x)

log10rem(x)

## Default S3 method:
log10rem(x)

## S3 method for class 'numeric'
log10rem(x)

## S3 method for class 'vli'
log10rem(x)

## S3 method for class 'vli'
log(x, base)

logrem(x, base)

## Default S3 method:
logrem(x, base)

## S3 method for class 'numeric'
logrem(x, base)

## S3 method for class 'vli'
logrem(x, base)

loge(x)

## Default S3 method:
loge(x)

## S3 method for class 'numeric'
loge(x)

## S3 method for class 'vli'
loge(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="04.+2B20Logarithms_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="04.+2B20Logarithms_+3A_base">base</code></td>
<td>
<p>base of the logarithm; object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("3873899469432")
log(x, base = 5)
logrem(x, base = 5)
( 5^log(x, base = 5) ) + logrem(x, base = 5) == x
x &lt;- as.vli("149234629386497858748773210293261249785")
log10(x)
</code></pre>

<hr>
<h2 id='05.+20Efficent+20division+20by+20a+20power+20of+202'>Efficient Division by a Power of 2</h2><span id='topic+05.+20Efficent+20division+20by+20a+20power+20of+202'></span><span id='topic+divp2'></span><span id='topic+divp2.default'></span><span id='topic+divp2.numeric'></span><span id='topic+divp2.vli'></span>

<h3>Description</h3>

<p><code>divp2</code> efficiently divides an object of class vli by a power of 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vli'
divp2(x, k)

## Default S3 method:
divp2(x, k)

## S3 method for class 'numeric'
divp2(x, k)

## S3 method for class 'vli'
divp2(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="05.+2B20Efficent+2B20division+2B20by+2B20a+2B20power+2B20of+2B202_+3A_x">x</code></td>
<td>
<p>dividend; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="05.+2B20Efficent+2B20division+2B20by+2B20a+2B20power+2B20of+2B202_+3A_k">k</code></td>
<td>
<p>exponent of the divisor (the divisor will be <code>2^k</code>); 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two integers <code>x</code> (vli or 32 bits integer) and <code>k</code> (32 bits integer), the function <code>divp2(x, k)</code> computes and returns <code>x/(2^k)</code> as an object of class vli.
</p>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dividing a random 500 digits integer by 2^10 = 1024
x &lt;- rvlidigits(500)
x
divp2(x, 10)
</code></pre>

<hr>
<h2 id='06.+20Binomial+20coefficients'>Binomial Coefficients for vli Objects</h2><span id='topic+06.+20Binomial+20coefficients'></span><span id='topic+binom'></span><span id='topic+binom.default'></span><span id='topic+binom.numeric'></span><span id='topic+binom.vli'></span>

<h3>Description</h3>

<p><code>binom</code> computes binomial coefficients of vli (Very Large Integer) objects. That is, given two positive integers <code>n</code> and <code>k</code> with <code>n &gt;= k</code>, the function <code>binom(n, k)</code> returns the number of ways to choose a subset of <code>k</code> elements, disregarding their order, from a set of <code>n</code> elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom(n, k)

## Default S3 method:
binom(n, k)

## S3 method for class 'numeric'
binom(n, k)

## S3 method for class 'vli'
binom(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="06.+2B20Binomial+2B20coefficients_+3A_n">n</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="06.+2B20Binomial+2B20coefficients_+3A_k">k</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("100")
binom(x, 20)
</code></pre>

<hr>
<h2 id='07.+20Factorial'>Factorial of a vli Object</h2><span id='topic+07.+20Factorial'></span><span id='topic+factvli'></span><span id='topic+factvli.default'></span><span id='topic+factvli.numeric'></span><span id='topic+factvli.vli'></span>

<h3>Description</h3>

<p><code>factvli</code> computes and returns the factorial of a vli (Very Large Integers) object. Given a positive integer <code>n</code>, the factorial of <code>n</code>, <code>n!</code>, is defined as the product of all the positive integers from <code>1</code> to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factvli(n)

## Default S3 method:
factvli(n)

## S3 method for class 'numeric'
factvli(n)

## S3 method for class 'vli'
factvli(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="07.+2B20Factorial_+3A_n">n</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- as.vli("420")
factvli(n)

## End(Not run)
</code></pre>

<hr>
<h2 id='08.+20Modular-arithmetic'>Basic Modular-Arithmetic Operators for vli Objects</h2><span id='topic+08.+20Modular-arithmetic'></span><span id='topic+summod'></span><span id='topic+summod.default'></span><span id='topic+summod.numeric'></span><span id='topic+summod.vli'></span><span id='topic+submod'></span><span id='topic+submod.default'></span><span id='topic+submod.numeric'></span><span id='topic+submod.vli'></span><span id='topic+mulmod'></span><span id='topic+mulmod.default'></span><span id='topic+mulmod.numeric'></span><span id='topic+mulmod.vli'></span><span id='topic+powmod'></span><span id='topic+powmod.default'></span><span id='topic+powmod.numeric'></span><span id='topic+powmod.vli'></span><span id='topic+invmod'></span><span id='topic+invmod.default'></span><span id='topic+invmod.numeric'></span><span id='topic+invmod.vli'></span><span id='topic+divmod'></span><span id='topic+divmod.default'></span><span id='topic+divmod.numeric'></span><span id='topic+divmod.vli'></span>

<h3>Description</h3>

<p>Basic modular-arithmetic operators for vli (Very Large Integers) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summod(x, y, mod)

## Default S3 method:
summod(x, y, mod)

## S3 method for class 'numeric'
summod(x, y, mod)

## S3 method for class 'vli'
summod(x, y, mod)

submod(x, y, mod)

## Default S3 method:
submod(x, y, mod)

## S3 method for class 'numeric'
submod(x, y, mod)

## S3 method for class 'vli'
submod(x, y, mod)

mulmod(x, y, mod)

## Default S3 method:
mulmod(x, y, mod)

## S3 method for class 'numeric'
mulmod(x, y, mod)

## S3 method for class 'vli'
mulmod(x, y, mod)

powmod(x, n, mod)

## Default S3 method:
powmod(x, n, mod)

## S3 method for class 'numeric'
powmod(x, n, mod)

## S3 method for class 'vli'
powmod(x, n, mod)

invmod(x, n)

## Default S3 method:
invmod(x, n)

## S3 method for class 'numeric'
invmod(x, n)

## S3 method for class 'vli'
invmod(x, n)

divmod(x, y, mod)

## Default S3 method:
divmod(x, y, mod)

## S3 method for class 'numeric'
divmod(x, y, mod)

## S3 method for class 'vli'
divmod(x, y, mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="08.+2B20Modular-arithmetic_+3A_x">x</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="08.+2B20Modular-arithmetic_+3A_y">y</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="08.+2B20Modular-arithmetic_+3A_mod">mod</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="08.+2B20Modular-arithmetic_+3A_n">n</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>summod</code>, <code>submod</code> and <code>mulmod</code> compute respectively the sum, the substraction and the multiplication of <code>x</code> and <code>y</code> under modulo <code>mod</code>.
</p>
<p>The function <code>powmod</code> computes the <code>n</code>-th power of <code>x</code> under modulo <code>mod</code>.
</p>
<p>The function <code>invmod</code> returns the modular multiplicative inverse of <code>x</code> in Z<code>n</code>; that is,  <code>y = x^(-1)</code> such that <code> x * y = 1 (</code>mod<code> n)</code>.
</p>
<p>The function <code>divmod</code> returns the modular division of <code>x</code> over <code>y</code>; that is, <code>z</code> such that <code>y * z (</code>mod <code>mod) = x (</code>mod <code>mod)</code>.
</p>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("8925378246957826904701")
y &lt;- as.vli("347892325634785693")
mod &lt;- as.vli(21341)

summod(x, y, mod)

mulmod(x, invmod(x, n = 123), mod = 123) == 1

z &lt;- divmod(x, y, mod)
mulmod(z, y, mod) == x %% mod
</code></pre>

<hr>
<h2 id='09.+20Greatest+20common+20divisor'>Greatest Common Divisor for vli Objects</h2><span id='topic+09.+20Greatest+20common+20divisor'></span><span id='topic+gcd'></span><span id='topic+gcd.default'></span><span id='topic+gcd.numeric'></span><span id='topic+gcd.vli'></span>

<h3>Description</h3>

<p><code>gcd</code> computes and returns the greatest common divisor of two vli (Very Large Integers) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(x, y)

## Default S3 method:
gcd(x, y)

## S3 method for class 'numeric'
gcd(x, y)

## S3 method for class 'vli'
gcd(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="09.+2B20Greatest+2B20common+2B20divisor_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="09.+2B20Greatest+2B20common+2B20divisor_+3A_y">y</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("1225312091263347514461245")
y &lt;- as.vli("357590484262521")
gcd(x, y)
</code></pre>

<hr>
<h2 id='10.+20Least+20common+20multiple'>Least Common Multiple for vli Objects</h2><span id='topic+10.+20Least+20common+20multiple'></span><span id='topic+lcmul'></span><span id='topic+lcmul.default'></span><span id='topic+lcmul.numeric'></span><span id='topic+lcmul.vli'></span>

<h3>Description</h3>

<p>Computation of the least common multiple of two vli (Very Large Integers) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcmul(x, y)

## Default S3 method:
lcmul(x, y)

## S3 method for class 'numeric'
lcmul(x, y)

## S3 method for class 'vli'
lcmul(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="10.+2B20Least+2B20common+2B20multiple_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="10.+2B20Least+2B20common+2B20multiple_+3A_y">y</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("125634750214756")
y &lt;- as.vli("761048412524216246")
lcmul(x, y)
</code></pre>

<hr>
<h2 id='11.+20Extended+20Euclidean+20algorithm'>Extended Euclidean Algorithm for vli Objects</h2><span id='topic+11.+20Extended+20Euclidean+20algorithm'></span><span id='topic+exteuclid'></span><span id='topic+exteuclid.default'></span><span id='topic+exteuclid.numeric'></span><span id='topic+exteuclid.vli'></span>

<h3>Description</h3>

<p>Computation of the Extended Euclidean algorithm for vli (Very Large Integers) objects. Given two positive integers, <code>x</code> and <code>y</code>, the Extended Euclidean algorithm looks for two integers <code>a</code> and <code>b</code> (called Bezout's coefficients) such that <code>(a * x) + (b * y) = 1</code>. To do this, the algorithm needs to compute the greatest common divisor of <code>x</code> and <code>y</code>, so it is also returned by the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exteuclid(x, y)

## Default S3 method:
exteuclid(x, y)

## S3 method for class 'numeric'
exteuclid(x, y)

## S3 method for class 'vli'
exteuclid(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="11.+2B20Extended+2B20Euclidean+2B20algorithm_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="11.+2B20Extended+2B20Euclidean+2B20algorithm_+3A_y">y</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object is a list of 3 elements. To access the numbers, it is necessary to use the list operator <code>[[i]]</code>, where &quot;<code>i</code>&quot; has to be 1 for the greatest common divisor, 2 for the first Bezout coefficient and 3 for the second Bezout coefficient (see the example).
</p>


<h3>Value</h3>

<p>list of 3 objects of class vli: the first is the greatest common divisor of <code>x</code> and <code>y</code>, and the other two are the Bezout's coefficients
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("232636113097")
y &lt;- as.vli("52442092785616")
result &lt;- exteuclid(x, y)
( result[[2]] * x ) + ( result[[3]] * y )
</code></pre>

<hr>
<h2 id='12.+20Perfect+20power'>Perfect Power Tools for vli Objects</h2><span id='topic+12.+20Perfect+20power'></span><span id='topic+perfectpow'></span><span id='topic+perfectpow.default'></span><span id='topic+perfectpow.numeric'></span><span id='topic+perfectpow.vli'></span><span id='topic+is.perfectpow'></span><span id='topic+is.perfectpow.default'></span><span id='topic+is.perfectpow.numeric'></span><span id='topic+is.perfectpow.vli'></span>

<h3>Description</h3>

<p>A positive integer is a perfect power if it can be expressed as an integer power of another positive integer. That is, a positive integer <code>x</code> is a perfect power if there exist two positive integers <code>a</code> and <code>b</code> such that <code>x = a^b</code> (note that <code>a</code> and <code>b</code> might not be unique).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perfectpow(x)

## Default S3 method:
perfectpow(x)

## S3 method for class 'numeric'
perfectpow(x)

## S3 method for class 'vli'
perfectpow(x)

is.perfectpow(x)

## Default S3 method:
is.perfectpow(x)

## S3 method for class 'numeric'
is.perfectpow(x)

## S3 method for class 'vli'
is.perfectpow(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="12.+2B20Perfect+2B20power_+3A_x">x</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>is.perfectpow(x)</code> returns <code>TRUE</code> if there exist two positive integers <code>a</code> and <code>b</code> such that <code>x = a^b</code>, and returns <code>FALSE</code> if there not exist.
</p>
<p>The function <code>perfectpow(x)</code> returns a list of two vli objects, <code>a</code> and <code>b</code>, such that <code>x = a^b</code>. If there not exist such numbers, the two vli objects will be equal to zero. Although the concept is usually defined only for positive integers, the function has been also programmed to work with negative integers.
</p>


<h3>Value</h3>

<p><code>is.perfectpow(x)</code> returns a Boolean
</p>
<p><code>perfectpow(x)</code> returns a list of two objects of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("234925792")
is.perfectpow(x)

x &lt;- as.vli("77808066022325383192121677734375")
is.perfectpow(x)
res &lt;- perfectpow(x)
res
res[[1]]^res[[2]]
</code></pre>

<hr>
<h2 id='13.+20Legrendre+27s+20Formula'>Legrendre's Formula for vli Objects</h2><span id='topic+13.+20Legrendre+27s+20Formula'></span><span id='topic+Legendre'></span><span id='topic+Legendre.default'></span><span id='topic+Legendre.numeric'></span><span id='topic+Legendre.vli'></span>

<h3>Description</h3>

<p>Given a positive integer <code>n</code> and a prime <code>p</code>, the Legendre's Formula finds the largest integer <code>x</code> such that <code>p^x</code> divides the factorial of <code>n</code>, <code>n!</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Legendre(n, p)

## Default S3 method:
Legendre(n, p)

## S3 method for class 'numeric'
Legendre(n, p)

## S3 method for class 'vli'
Legendre(n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="13.+2B20Legrendre+2B27s+2B20Formula_+3A_n">n</code></td>
<td>
<p>a positive integer; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="13.+2B20Legrendre+2B27s+2B20Formula_+3A_p">p</code></td>
<td>
<p>a prime number; object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as.vli(577)
is.prime(p)
Legendre(12222, p)
</code></pre>

<hr>
<h2 id='14.+20Finding+20a+20random+20divisor'>Finding a Random Divisor of a vli Object</h2><span id='topic+14.+20Finding+20a+20random+20divisor'></span><span id='topic+divisor'></span><span id='topic+divisor.default'></span><span id='topic+divisor.numeric'></span><span id='topic+divisor.vli'></span>

<h3>Description</h3>

<p><code>divisor</code> returns a randomly chosen divisor of a given number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisor(n, iter = 100)

## Default S3 method:
divisor(n, iter = 100)

## S3 method for class 'numeric'
divisor(n, iter = 100)

## S3 method for class 'vli'
divisor(n, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="14.+2B20Finding+2B20a+2B20random+2B20divisor_+3A_n">n</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="14.+2B20Finding+2B20a+2B20random+2B20divisor_+3A_iter">iter</code></td>
<td>
<p>number of iterations for testing if the given number is prime; numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm determines if the given number is prime or composite by usign the Miller-Rabin Probabilistic Primality Test. If it is prime, it returns the number itself. If it is composite, it returns a randomly chosen divisor. The number of iterations is configurable to set the desired accuracy. A too low number of iterations could cause an infinite loop because of being looking for a divisor of a prime number.
</p>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rvliprime(100)
r
x &lt;- r * 51
x
divisor(x, iter = 100)
</code></pre>

<hr>
<h2 id='15.+20Factorization'>Factorization of vli Objects</h2><span id='topic+15.+20Factorization'></span><span id='topic+factors'></span><span id='topic+factors.default'></span><span id='topic+factors.numeric'></span><span id='topic+factors.vli'></span>

<h3>Description</h3>

<p><code>factors</code> returns all the prime factors of a given number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factors(n, iter = 10, output = "print")

## Default S3 method:
factors(n, iter = 10, output = "print")

## S3 method for class 'numeric'
factors(n, iter = 10, output = "print")

## S3 method for class 'vli'
factors(n, iter = 10, output = "print")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="15.+2B20Factorization_+3A_n">n</code></td>
<td>
<p>integer to be factorized; vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="15.+2B20Factorization_+3A_iter">iter</code></td>
<td>
<p>number of iterations for testing if the given number is prime; numeric</p>
</td></tr>
<tr><td><code id="15.+2B20Factorization_+3A_output">output</code></td>
<td>
<p>chosen way for objects being returned: <code>'list'</code> to return the result as a list of vli objects or <code>'print'</code> (by default) to simply display the result on the screen; character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented algorithm is based in a Monte Carlo method for integer factorization called Pollard's Rho Algorithm.
</p>
<p>It determines if the given number is prime or composite by usign the Miller-Rabin Probabilistic Primality Test. If it is prime, it returns the number itself. If it is composite, it calls iteratively the <code>divisor</code> function until all the prime factors of the given number are found.
</p>
<p>It is a Monte Carlo method, therefore it is not deterministic. The number of iterations is configurable, to set the desired accuracy. A too low number of iterations could cause an infinite loop because of being looking for a divisor of a prime number.
</p>


<h3>Value</h3>

<p>list of objects of class vli or the result displayed on the screen, depending on the <code>output</code> argument
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("584843")
factors(x, iter = 100)
</code></pre>

<hr>
<h2 id='16.+20Jacobi+20Symbol'>Computation of the Jacobi Symbol for vli Objects</h2><span id='topic+16.+20Jacobi+20Symbol'></span><span id='topic+Jacobi'></span><span id='topic+Jacobi.default'></span><span id='topic+Jacobi.numeric'></span><span id='topic+Jacobi.vli'></span>

<h3>Description</h3>

<p>Computation of the Jacobi Symbol for vli (Very Large Integers) objects. The Jacobi Symbol is a generalization of the Legendre Symbol, not being necessary that <code>n</code> be a prime number.
</p>
<p>It is needed in many algorithms of modular arithmetic, computational number theory and cryptography. For example, it is used by the present package in the Solovay-Strassen probabilistic primality test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jacobi(a, n)

## Default S3 method:
Jacobi(a, n)

## S3 method for class 'numeric'
Jacobi(a, n)

## S3 method for class 'vli'
Jacobi(a, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="16.+2B20Jacobi+2B20Symbol_+3A_a">a</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="16.+2B20Jacobi+2B20Symbol_+3A_n">n</code></td>
<td>
<p>positive odd integer; object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class vli with value <code>-1</code>, <code>0</code> or <code>1</code>.
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("342635653456")
y &lt;- as.vli("3210591001")
Jacobi(x, y)
</code></pre>

<hr>
<h2 id='17.+20Euler+27s+20phi+20function'>Euler's Phi Function for vli Objects</h2><span id='topic+17.+20Euler+27s+20phi+20function'></span><span id='topic+phi'></span><span id='topic+phi.default'></span><span id='topic+phi.numeric'></span><span id='topic+phi.vli'></span>

<h3>Description</h3>

<p>Euler's Phi Function for vli (Very Large Integers) objects. Given a positive integer <code>x</code>, the Euler's Phi Function returns the number of positive integers up to <code>x</code> that are relatively prime to <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(x)

## Default S3 method:
phi(x)

## S3 method for class 'numeric'
phi(x)

## S3 method for class 'vli'
phi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="17.+2B20Euler+2B27s+2B20phi+2B20function_+3A_x">x</code></td>
<td>
<p>positive integer; object of class vli or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned value by the <code>phi</code> function is equal to the order of the group of units of the ring <code>Z/Zn</code> (the multiplicative group of integers modulo <code>n</code>). It is also called Euler's Totient Function, and plays a major part in Number Theory and in the RSA Cryptosystem.
</p>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- as.vli("24352")
phi(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='18.+20Probabilistic+20primality+20tests'>Probabilistic Primality Tests for vli Objects</h2><span id='topic+18.+20Probabilistic+20primality+20tests'></span><span id='topic+is.primeF'></span><span id='topic+is.primeF.default'></span><span id='topic+is.primeF.numeric'></span><span id='topic+is.primeF.vli'></span><span id='topic+is.primeMR'></span><span id='topic+is.primeMR.default'></span><span id='topic+is.primeMR.numeric'></span><span id='topic+is.primeMR.vli'></span><span id='topic+is.primeSS'></span><span id='topic+is.primeSS.default'></span><span id='topic+is.primeSS.numeric'></span><span id='topic+is.primeSS.vli'></span><span id='topic+is.prime'></span>

<h3>Description</h3>

<p>Functions to compute different probabilistic primality tests for vli (Very Large Integer) objects.
</p>
<p>The function <code>is.primeF</code> computes the Fermat Primality Test.
</p>
<p>The function <code>is.primeMR</code> computes the Miller-Rabin Primality Test.
</p>
<p>The function <code>is.primeSS</code> computes the Solovay-Strassen Primality Test.
</p>
<p>The function <code>is.prime</code> is a general function that computes the test specified in the <code>test</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.primeF(x, iter = 10)

## Default S3 method:
is.primeF(x, iter = 10)

## S3 method for class 'numeric'
is.primeF(x, iter = 10)

## S3 method for class 'vli'
is.primeF(x, iter = 10)

is.primeMR(x, iter = 10)

## Default S3 method:
is.primeMR(x, iter = 10)

## S3 method for class 'numeric'
is.primeMR(x, iter = 10)

## S3 method for class 'vli'
is.primeMR(x, iter = 10)

is.primeSS(x, iter = 10)

## Default S3 method:
is.primeSS(x, iter = 10)

## S3 method for class 'numeric'
is.primeSS(x, iter = 10)

## S3 method for class 'vli'
is.primeSS(x, iter = 10)

is.prime(x, iter = 10, test = "MR")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="18.+2B20Probabilistic+2B20primality+2B20tests_+3A_x">x</code></td>
<td>
<p>number to be tested; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="18.+2B20Probabilistic+2B20primality+2B20tests_+3A_iter">iter</code></td>
<td>
<p>number of iterations; numeric</p>
</td></tr>
<tr><td><code id="18.+2B20Probabilistic+2B20primality+2B20tests_+3A_test">test</code></td>
<td>
<p>chosen test: &quot;F&quot; for the Fermat Test, &quot;SS&quot; for the Solovay-Strassen Test or &quot;MR&quot; (by default) for the Miller-Rabin Test; character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probabilistic primality tests are algorithms that determine if an integer is prime or composite. They are not deterministic tests so there is a probability of error (it is never reported a prime number as composite, but it is possible for a composite number to be reported as prime). This probability of error can be calculated and reduced as much as we want by increasing the number of iterations of the test.
</p>
<p>Each test is different, therefore they have different computational efficiency and one could be better than other for testing some numbers. However, the Miller-Rabin test is the most accurated of all three and, because of that, it is the test chosen by default in every function that needs primality testing in the present package.
</p>
<p>The Fermat Primality Test detects composite numbers by using the Fermat's Little Theorem, which says that, if <code>p</code> is prime, for any integer <code>a</code> satisfaying <code>gcd(a, p) = 1</code> we have that <code>a^(p-1) = 1 </code>(<code>mod p</code>).
Each iteration randomly pick an integer <code>a</code>. The more iterations are computed, the greater probability to find an <code>a</code> that does not verify such conditions and, therefore, it reveals that <code>p</code> is composite. However, there are some composite numbers <code>p</code> that have the property that <code>a^(p-1) = 1 </code>(<code>mod p</code>) for every <code>a</code> coprime to <code>p</code>. These numbers are called Carmichael numbers or Fermat pseudoprimes, and it is not possible for the Fermat Test to detect that they are composite numbers. But there are only 105212 such numbers up to <code>10^15</code> (approximately 1 Carmichael number per each 10.000.000.000 integer numbers). The first five are: 561, 1105, 1729, 2465 and 2821.
</p>
<p>As a conclusion, we can say that if the chosen <code>x</code> number is prime, the Fermat test returns <code>TRUE</code>. If it is an odd composite (but not a Carmichael number), it returns <code>FALSE</code> with probability at least <code>1/2^k</code>, where <code>k</code> is the number of computed iterations.
</p>
<p>The Miller-Rabin Primality Test is a more sophisticated version of the Fermat test. If the chosen <code>x</code> number is prime, the test returns <code>TRUE</code>. If <code>x</code> is an odd composite the algorithm returns <code>TRUE</code> (that is, it fails) with probability less than <code>1/4^k</code>, where <code>k</code> is the number of computed iterations. In cases of very big numbers, the probability is even smaller.
</p>
<p>The Solovay-Strassen test is based in a known algebraic property of the Jacobi symbol. The probabily of failure is also less than <code>1/2^k</code>, where <code>k</code> is the number of computed iterations. However, unlike it happens with the Fermat test, there are not odd composite numbers that can not be detected with enough iterations of the Solovay-Strassen test.
</p>


<h3>Value</h3>

<p>boolean:
if the test determines that the given number is prime it returns <code>TRUE</code>
if the test determines that the given number is composite it returns <code>FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Testing a 32 bits integer using the Miller-Rabin Test
is.primeMR(2845127, iter = 10)

## Testing an object of class vli using the Fermat Test
x &lt;- as.vli("2801401243675128975602569907852141")
is.primeF(x, iter = 100)

## Testing the same object of class vli using the general
##     is.prime function and the Solovay-Strassen Test
is.prime(x, iter = 100, test = "SS")

## End(Not run)
</code></pre>

<hr>
<h2 id='19.+20Finding+20all+20primes'>Finding All Primes Up to a Given Bound</h2><span id='topic+19.+20Finding+20all+20primes'></span><span id='topic+primes'></span><span id='topic+primes.default'></span><span id='topic+primes.numeric'></span><span id='topic+primes.vli'></span>

<h3>Description</h3>

<p>The function <code>primes</code> displays a vector with all prime numbers up to a given bound. Computation can be made by using different probabilistic primality tests at the user's choice (Fermat Test, Miller-Rabin Test or Solovay-Strassen Test). The number of iterations is also configurable, to set the desired accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primes(n, test = "MR", iter = 10, bar = TRUE)

## Default S3 method:
primes(n, test = "MR", iter = 10, bar = TRUE)

## S3 method for class 'numeric'
primes(n, test = "MR", iter = 10, bar = TRUE)

## S3 method for class 'vli'
primes(n, test = "MR", iter = 10, bar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="19.+2B20Finding+2B20all+2B20primes_+3A_n">n</code></td>
<td>
<p>upper bound of the interval in which look for primes; object of class vli or 32 bits</p>
</td></tr>
<tr><td><code id="19.+2B20Finding+2B20all+2B20primes_+3A_test">test</code></td>
<td>
<p>chosen test for each number: &quot;F&quot; for the Fermat Test, &quot;SS&quot; for the Solovay-Strassen Test or &quot;MR&quot; (by default) for the Miller-Rabin Test; character</p>
</td></tr>
<tr><td><code id="19.+2B20Finding+2B20all+2B20primes_+3A_iter">iter</code></td>
<td>
<p>number of iterations for each number being tested; numeric</p>
</td></tr>
<tr><td><code id="19.+2B20Finding+2B20all+2B20primes_+3A_bar">bar</code></td>
<td>
<p>to choose if display or not a progress bar; boolean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of objects of class &quot;noquote&quot;
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>primes(n = 600, iter = 10, test = "MR", bar = TRUE)
</code></pre>

<hr>
<h2 id='20.+20Next+20prime+20number'>Next Prime Number</h2><span id='topic+20.+20Next+20prime+20number'></span><span id='topic+nextprime'></span><span id='topic+nextprime.default'></span><span id='topic+nextprime.numeric'></span><span id='topic+nextprime.vli'></span>

<h3>Description</h3>

<p>The function <code>nextprime</code> computes and returns the smallest prime number that is greater than the given number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextprime(n, iter = 10, test = "MR")

## Default S3 method:
nextprime(n, iter = 10, test = "MR")

## S3 method for class 'numeric'
nextprime(n, iter = 10, test = "MR")

## S3 method for class 'vli'
nextprime(n, iter = 10, test = "MR")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="20.+2B20Next+2B20prime+2B20number_+3A_n">n</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="20.+2B20Next+2B20prime+2B20number_+3A_iter">iter</code></td>
<td>
<p>number of iterations for testing whether or not each number is prime; numeric</p>
</td></tr>
<tr><td><code id="20.+2B20Next+2B20prime+2B20number_+3A_test">test</code></td>
<td>
<p>chosen test: &quot;F&quot; for the Fermat Test, &quot;SS&quot; for the Solovay-Strassen Test or &quot;MR&quot; (by default) for the Miller-Rabin Test; character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of iterations is configurable to set the desired accuracy. A small number of iterations might cause not finding a prime number.
</p>


<h3>Value</h3>

<p>object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- as.vli("982234568923564")
x &lt;- nextprime(n)
x
is.prime(x)
</code></pre>

<hr>
<h2 id='21.+20Pi+20function'>Pi Function Approximation for vli Objects</h2><span id='topic+21.+20Pi+20function'></span><span id='topic+Pi'></span><span id='topic+Pi.default'></span><span id='topic+Pi.numeric'></span><span id='topic+Pi.vli'></span>

<h3>Description</h3>

<p>Pi function approximation for vli (Very Large Integers) objects. It is also called &quot;Prime-counting function&quot;.
Given a positive integer <code>x</code>, the Pi function returns the number of primes up to <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pi(x)

## Default S3 method:
Pi(x)

## S3 method for class 'numeric'
Pi(x)

## S3 method for class 'vli'
Pi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="21.+2B20Pi+2B20function_+3A_x">x</code></td>
<td>
<p>positive integer; vli class object or 32 bits integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented algorithm is based in the fact that <code>x/log(x)</code> is asymptotically equal to <code>Pi(x)</code>, also known as &quot;Prime Number Theorem&quot;.
</p>
<p>Closer approximations could be implemented by using the Logarithmic Integral Function. The function <code>countprimes</code> of the present package is another way to get a better approximation (in return for a less efficient computation) of <code>Pi(x)</code>. Alhought the algorithm is not deterministic, it is based in the Miller-Rabin Probabilistic Primality Test, therefore the error can be arbitrarily reduced.
</p>


<h3>Value</h3>

<p>number of primes up to <code>x</code>; object of class vli
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("89235489145293876129784691")
Pi(x)
</code></pre>

<hr>
<h2 id='22.+20Counting+20the+20number+20of+20primes'>Counting the Number of Primes Up to a Given Bound</h2><span id='topic+22.+20Counting+20the+20number+20of+20primes'></span><span id='topic+primescount'></span><span id='topic+primescount.default'></span><span id='topic+primescount.numeric'></span><span id='topic+primescount.vli'></span>

<h3>Description</h3>

<p>The function <code>primescount</code> returns the number of primes found up to a given bound. The implemented algorithm uses the Miller-Rabin Primality Test to determine whether a number is prime or not. The number of iterations is configurable, to set the desired accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primescount(n, iter = 10, bar = TRUE)

## Default S3 method:
primescount(n, iter = 10, bar = TRUE)

## S3 method for class 'numeric'
primescount(n, iter = 10, bar = TRUE)

## S3 method for class 'vli'
primescount(n, iter = 10, bar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="22.+2B20Counting+2B20the+2B20number+2B20of+2B20primes_+3A_n">n</code></td>
<td>
<p>upper bound of the interval in which we want to count the number of primes; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="22.+2B20Counting+2B20the+2B20number+2B20of+2B20primes_+3A_iter">iter</code></td>
<td>
<p>number of iterations for each number being tested; numeric</p>
</td></tr>
<tr><td><code id="22.+2B20Counting+2B20the+2B20number+2B20of+2B20primes_+3A_bar">bar</code></td>
<td>
<p>to choose if display or not a progress bar; boolean</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Counting primes up to 200
primescount(n = 200, iter = 10, bar = TRUE)

## Computing the approximation of pi(x)
pi(200)

## Showing the numbers by using the Solovay-Strassen test
primes(n = 200, iter = 10, test = "SS", bar = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='23.+20Fibonacci+20numbers'>Fibonacci Numbers Tools for vli Objects</h2><span id='topic+23.+20Fibonacci+20numbers'></span><span id='topic+Fibonacci'></span><span id='topic+Fibonacci.default'></span><span id='topic+Fibonacci.numeric'></span><span id='topic+nthFibonacci'></span><span id='topic+nthFibonacci.default'></span><span id='topic+nthFibonacci.numeric'></span><span id='topic+nthFibonacci.vli'></span><span id='topic+is.Fibonacci'></span><span id='topic+is.Fibonacci.default'></span><span id='topic+is.Fibonacci.numeric'></span><span id='topic+is.Fibonacci.vli'></span>

<h3>Description</h3>

<p>The Fibonacci Sequence is defined as follows:
</p>
<p><code>x[1] = 0</code>,
</p>
<p><code>x[2] = 1</code>,
</p>
<p><code>...</code>
</p>
<p><code>x[n] = x[n-1] + x[n-2]</code>.
</p>
<p>A positive integer is said to be a Fibonacci Number if it is an element of the Fibonacci Sequence.
</p>
<p>The function <code>Fibonacci(m, output)</code> computes and displays the first <code>m</code> elements of the Fibonacci Sequence.
</p>
<p>The function <code>nthFibonacci(n)</code> computes and displays the <code>n</code>-th element of the Fibonacci Sequence.
</p>
<p>The function <code>is.Fibonacci(x)</code> says whether or not <code>x</code> is a Fibonacci Number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fibonacci(m, output = "print")

## Default S3 method:
Fibonacci(m, output = "print")

## S3 method for class 'numeric'
Fibonacci(m, output = "print")

nthFibonacci(n)

## Default S3 method:
nthFibonacci(n)

## S3 method for class 'numeric'
nthFibonacci(n)

## S3 method for class 'vli'
nthFibonacci(n)

is.Fibonacci(x)

## Default S3 method:
is.Fibonacci(x)

## S3 method for class 'numeric'
is.Fibonacci(x)

## S3 method for class 'vli'
is.Fibonacci(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="23.+2B20Fibonacci+2B20numbers_+3A_m">m</code></td>
<td>
<p>object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="23.+2B20Fibonacci+2B20numbers_+3A_output">output</code></td>
<td>
<p>chosen way for objects being returned: <code>'list'</code> to return the result as a list of vli objects or <code>'print'</code> (by default) to simply display the result on the screen; character</p>
</td></tr>
<tr><td><code id="23.+2B20Fibonacci+2B20numbers_+3A_n">n</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="23.+2B20Fibonacci+2B20numbers_+3A_x">x</code></td>
<td>
<p>vli class object or 32 bits integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>Fibonacci(m, output)</code> returns a list of objects of class vli or the result displayed on the screen, depending on the <code>output</code> argument.
</p>
<p>The function <code>nthFibonacci(n)</code> returns a object of class vli.
</p>
<p>The function <code>is.Fibonacci(x)</code> returns a boolean.
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fibonacci(200)

n &lt;- as.vli("50000")
nthFibonacci(n)

x &lt;- as.vli("5358359254990966640871840")
is.Fibonacci(x)

y &lt;- x + 1
is.Fibonacci(y)
</code></pre>

<hr>
<h2 id='24.+20Random+20generators'>Random Generators of vli Objects</h2><span id='topic+24.+20Random+20generators'></span><span id='topic+rvlidigits'></span><span id='topic+rvliunif'></span><span id='topic+rvliunif.default'></span><span id='topic+rvliunif.numeric'></span><span id='topic+rvliunif.vli'></span><span id='topic+rvlibin'></span><span id='topic+rvlibin.default'></span><span id='topic+rvlibin.numeric'></span><span id='topic+rvlibin.vli'></span><span id='topic+rvlinegbin'></span><span id='topic+rvlinegbin.default'></span><span id='topic+rvlinegbin.numeric'></span><span id='topic+rvlinegbin.vli'></span><span id='topic+rvliprime'></span><span id='topic+rvliprime.default'></span><span id='topic+rvliprime.numeric'></span><span id='topic+rvliprime.vli'></span>

<h3>Description</h3>

<p>Random generators of vli (Very Large Integer) objects following different probability distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvlidigits(d)

rvliunif(x, y)

## Default S3 method:
rvliunif(x, y)

## S3 method for class 'numeric'
rvliunif(x, y)

## S3 method for class 'vli'
rvliunif(x, y)

rvlibin(n, p)

## Default S3 method:
rvlibin(n, p)

## S3 method for class 'numeric'
rvlibin(n, p)

## S3 method for class 'vli'
rvlibin(n, p)

rvlinegbin(s, p)

## Default S3 method:
rvlinegbin(s, p)

## S3 method for class 'numeric'
rvlinegbin(s, p)

## S3 method for class 'vli'
rvlinegbin(s, p)

rvliprime(y, iter = 10, test = "MR")

## Default S3 method:
rvliprime(y, iter = 10, test = "MR")

## S3 method for class 'numeric'
rvliprime(y, iter = 10, test = "MR")

## S3 method for class 'vli'
rvliprime(y, iter = 10, test = "MR")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="24.+2B20Random+2B20generators_+3A_d">d</code></td>
<td>
<p>number of digits of the vli class object being generated; numeric</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_x">x</code></td>
<td>
<p>lower bound for the object of class vli being generated; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_y">y</code></td>
<td>
<p>upper bound for the object of class vli being generated; object of class vli or 32 bits integer</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_n">n</code></td>
<td>
<p>number of independent Bernoulli trials; object of class vli 32 bits integer</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_p">p</code></td>
<td>
<p>probability of success; numeric</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_s">s</code></td>
<td>
<p>number of successes; vli class object or 32 bits integer</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_iter">iter</code></td>
<td>
<p>number of iterations for each number to be tested; numeric</p>
</td></tr>
<tr><td><code id="24.+2B20Random+2B20generators_+3A_test">test</code></td>
<td>
<p>chosen primality test: &quot;F&quot; for the Fermat Test, &quot;SS&quot; for the Solovay-Strassen Test or &quot;MR&quot; (by default) for the Miller-Rabin Test; character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rvlidigits(d)</code> returns a vli object of <code>d</code> digits randomly generated following the uniform distribution. It is the most efficient way of generating random vli objects.
</p>
<p>The function <code>rvliunif(x, y)</code> returns a vli object randomly generated following the Uniform distribution with parameters <code>x</code> and <code>y</code>.
</p>
<p>The function <code>rvlibin(n, p)</code> returns a vli object randomly generated following the Binomial distribution with parameters <code>n</code> and <code>p</code>, where <code>n</code> is the number of Bernoulli trials and <code>p</code> the probability of success.
</p>
<p>The function <code>rvlinegbin(x, y)</code> returns a vli object randomly generated following the Negative Binomial distribution with parameters <code>s</code> and <code>p</code>, where <code>s</code> is the number of successes and <code>p</code> the probability of success.
</p>
<p>The function <code>rvliprime(y, iter, test)</code> returns a vli object randomly chosen from the set of primes up to <code>y</code>.
</p>


<h3>Value</h3>

<p>objects of class vli in all cases:
</p>
<p><code>rvlidigits(d)</code> returns a object of class vli belonging to the interval <code>[0, 10^d)</code>
</p>
<p><code>rvliunif(x, y)</code> returns a object of class vli belonging to the interval <code>[x, y)</code>
</p>
<p><code>rvlibin(n, p)</code> returns a object of class vli belonging to the interval <code>[0, n]</code>
</p>
<p><code>rvlinegbin(x, y)</code> returns a object of class vli belonging to the interval <code>[n, Inf)</code>
</p>
<p><code>rvliprime(y, iter, test)</code> returns a object of class vli with the value of a prime number belonging to the interval <code>[2, y)</code>
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvlidigits(2000)
rvliunif(3425, as.vli("2061341345304562604342"))
rvlibin(100, 0.6)
rvlinegbin(as.vli("1000000"), 0.5)
rvliprime(as.vli("100000"), iter = 10, test = "MR")
</code></pre>

<hr>
<h2 id='25.+20Counting+201+20bits'>Counting the Number of 1-Bits in vli Objects</h2><span id='topic+25.+20Counting+201+20bits'></span><span id='topic+count1bits'></span><span id='topic+count1bits.default'></span><span id='topic+count1bits.numeric'></span><span id='topic+count1bits.vli'></span>

<h3>Description</h3>

<p>Counting the number of 1-bits in the base 2 expression of vli (Very Large Integer) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count1bits(x)

## Default S3 method:
count1bits(x)

## S3 method for class 'numeric'
count1bits(x)

## S3 method for class 'vli'
count1bits(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="25.+2B20Counting+2B201+2B20bits_+3A_x">x</code></td>
<td>
<p>object of class vli</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Author(s)</h3>

<p>Javier Leiva Cuadrado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vli("69158247560284795612")
count1bits(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
