<!DOCTYPE html><html><head><title>Help for package cellKey</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cellKey}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ck_class'><p>R6 Class defining statistical tables that can be perturbed</p></a></li>
<li><a href='#ck_cnt_measures'><p>Utility measures for perturbed counts</p></a></li>
<li><a href='#ck_create_testdata'><p>ck_create_testdata</p></a></li>
<li><a href='#ck_dat_hc92'><p>A real-world data set on persons</p></a></li>
<li><a href='#ck_flexparams'><p>Set parameters required to perturb numeric variables using a flex function</p></a></li>
<li><a href='#ck_generate_rkeys'><p>Generate random record keys</p></a></li>
<li><a href='#ck_params_cnts'><p>Create perturbation parameters for count variables</p></a></li>
<li><a href='#ck_params_nums'><p>Set perturbation parameters for continuous variables</p></a></li>
<li><a href='#ck_read_yaml'><p>Read perturbation parameters from yaml-files</p></a></li>
<li><a href='#ck_simpleparams'><p>Set parameters required to perturb numeric variables using a simple approach</p></a></li>
<li><a href='#ck_vignette'><p>ck_vignette</p></a></li>
<li><a href='#testdata'><p>A real-world data set on household income and expenditures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Consistent Perturbation of Statistical Frequency- And Magnitude
Tables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Data from statistical agencies and other institutions often
    need to be protected before they can be published. This package 
    can be used to perturb statistical tables in a consistent way. The
    main idea is to add - at the micro data level - a record key for each
    unit. Based on these keys, for any cell in a statistical table a
    cell key is computed as a function on the record keys contributing to
    a specific cell. Values that are added to the cell in order to perturb
    it are derived from a lookup-table that maps values of cell keys to 
    specific perturbation values. The theoretical basis for the methods 
    implemented can be found in Thompson, Broadfoot and Elazar 
    (2013) <a href="https://unece.org/fileadmin/DAM/stats/documents/ece/ces/ge.46/2013/Topic_1_ABS.pdf">https://unece.org/fileadmin/DAM/stats/documents/ece/ces/ge.46/2013/Topic_1_ABS.pdf</a>
    which was extended and enhanced by Giessing and Tent 
    (2019) <a href="https://unece.org/fileadmin/DAM/stats/documents/ece/ces/ge.46/2019/mtg1/SDC2019_S2_Germany_Giessing_Tent_AD.pdf">https://unece.org/fileadmin/DAM/stats/documents/ece/ces/ge.46/2019/mtg1/SDC2019_S2_Germany_Giessing_Tent_AD.pdf</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.1), sdcHierarchies (&ge; 0.19.3), data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, methods, digest (&ge; 0.6.23), sdcTable (&ge; 0.32.2),
ptable (&ge; 1.0.0), cli, utils, yaml, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernhard Meindl [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernhard Meindl &lt;bernhard.meindl@statistik.gv.at&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sdcTools/userSupport/issues">https://github.com/sdcTools/userSupport/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sdcTools/cellKey">https://github.com/sdcTools/cellKey</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 10:21:17 UTC; meindl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ck_class'>R6 Class defining statistical tables that can be perturbed</h2><span id='topic+ck_class'></span><span id='topic+cellkey_pkg'></span><span id='topic+ck_setup'></span>

<h3>Description</h3>

<p>This class allows to define statistical tables and perturb both
count and numerical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_setup(x, rkey, dims, w = NULL, countvars = NULL, numvars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_class_+3A_x">x</code></td>
<td>
<p>an object coercible to a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="ck_class_+3A_rkey">rkey</code></td>
<td>
<p>either a column name within <code>x</code> referring to a variable containing record keys
or a single integer(ish) number &gt; <code>5</code> that referns to the number of digits for record keys that
will be generated internally.</p>
</td></tr>
<tr><td><code id="ck_class_+3A_dims">dims</code></td>
<td>
<p>a list containing slots for each variable that should be
tabulated. Each slot consists should be created/modified using <code><a href="sdcHierarchies.html#topic+hier_create">sdcHierarchies::hier_create()</a></code>,
<code><a href="sdcHierarchies.html#topic+hier_add">sdcHierarchies::hier_add()</a></code> and other functionality from package <code>sdcHierarchies</code>.</p>
</td></tr>
<tr><td><code id="ck_class_+3A_w">w</code></td>
<td>
<p>(character) a scalar character referring to a variable in <code>x</code> holding sampling
weights. If <code>w</code> is <code>NULL</code> (the default), all weights are assumed to be <code>1</code></p>
</td></tr>
<tr><td><code id="ck_class_+3A_countvars">countvars</code></td>
<td>
<p>(character) an optional vector containing names of binary (0/1 coded)
variables withing <code>x</code> that should be included in the problem instance.
These variables can later be perturbed.</p>
</td></tr>
<tr><td><code id="ck_class_+3A_numvars">numvars</code></td>
<td>
<p>(character) an optional vector of numerical variables that can later be tabulated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Such objects are typically generated using <code><a href="#topic+ck_setup">ck_setup()</a></code>.
</p>


<h3>Value</h3>

<p>A new <code>cellkey_obj</code> object. Such objects (internally) contain the fully computed
statistical tables given input microdata (<code>x</code>), the hierarchical definitionals (<code>dims</code>) as
well as the remaining inputs. Intermediate results are stored internally and can only be
modified / accessed via the exported public methods described below.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-cellkey_obj-new"><code>ck_class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-perturb"><code>ck_class$perturb()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-freqtab"><code>ck_class$freqtab()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-numtab"><code>ck_class$numtab()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-measures_cnts"><code>ck_class$measures_cnts()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-measures_nums"><code>ck_class$measures_nums()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-allvars"><code>ck_class$allvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-cntvars"><code>ck_class$cntvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-numvars"><code>ck_class$numvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-hierarchy_info"><code>ck_class$hierarchy_info()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-mod_cnts"><code>ck_class$mod_cnts()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-mod_nums"><code>ck_class$mod_nums()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_freq"><code>ck_class$supp_freq()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_val"><code>ck_class$supp_val()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_cells"><code>ck_class$supp_cells()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_p"><code>ck_class$supp_p()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_pq"><code>ck_class$supp_pq()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-supp_nk"><code>ck_class$supp_nk()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_cnts_get"><code>ck_class$params_cnts_get()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_cnts_set"><code>ck_class$params_cnts_set()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_cntvars"><code>ck_class$reset_cntvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_numvars"><code>ck_class$reset_numvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-reset_allvars"><code>ck_class$reset_allvars()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_nums_get"><code>ck_class$params_nums_get()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-params_nums_set"><code>ck_class$params_nums_set()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-summary"><code>ck_class$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-cellkey_obj-print"><code>ck_class$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-cellkey_obj-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new table instance
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$new(x, rkey, dims, w = NULL, countvars = NULL, numvars = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an object coercible to a <code>data.frame</code></p>
</dd>
<dt><code>rkey</code></dt><dd><p>either a column name within <code>x</code> referring to a variable containing record keys
or a single integer(ish) number &gt; <code>5</code> that referns to the number of digits for record keys that
will be generated internally.</p>
</dd>
<dt><code>dims</code></dt><dd><p>a list containing slots for each variable that should be
tabulated. Each slot consists should be created/modified using <code><a href="sdcHierarchies.html#topic+hier_create">sdcHierarchies::hier_create()</a></code>,
<code><a href="sdcHierarchies.html#topic+hier_add">sdcHierarchies::hier_add()</a></code> and other functionality from package <code>sdcHierarchies</code>.</p>
</dd>
<dt><code>w</code></dt><dd><p>(character) a scalar character referring to a variable in <code>x</code> holding sampling
weights. If <code>w</code> is <code>NULL</code> (the default), all weights are assumed to be <code>1</code></p>
</dd>
<dt><code>countvars</code></dt><dd><p>(character) an optional vector containing names of binary (0/1 coded)
variables withing <code>x</code> that should be included in the problem instance.
These variables can later be perturbed.</p>
</dd>
<dt><code>numvars</code></dt><dd><p>(character) an optional vector of numerical variables that can later be tabulated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>cellkey_obj</code> object. Such objects (internally) contain the fully computed
statistical tables given input microdata (<code>x</code>), the hierarchical definitionals (<code>dims</code>) as
well as the remaining inputs. Intermediate results are stored internally and can only be
modified / accessed via the exported public methods described below.
</p>


<hr>
<a id="method-cellkey_obj-perturb"></a>



<h4>Method <code>perturb()</code></h4>

<p>Perturb a count- or magnitude variable
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$perturb(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>name(s) of count- or magnitude variables that should be perturbed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. Updated data can be accessed using other exported
methods like <code style="white-space: pre;">&#8288;$freqtab()&#8288;</code> or <code style="white-space: pre;">&#8288;$numtab()&#8288;</code>.
</p>


<hr>
<a id="method-cellkey_obj-freqtab"></a>



<h4>Method <code>freqtab()</code></h4>

<p>Extract results from already perturbed count variables as a
<code>data.table</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$freqtab(v = NULL, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a vector of variable names for count variables. If <code>NULL</code>
(the default), the results are returned for all available count
variables. For variables that have not yet perturbed, columns
<code>puwc</code> and <code>pwc</code> are filled with <code>NA</code>.</p>
</dd>
<dt><code>path</code></dt><dd><p>if not <code>NULL</code>, a scalar character defining a (relative
or absolute) path to which the result table should be written. A <code>csv</code>
file will be generated and, if specified, <code>path</code> must have
&quot;.csv&quot; as file-ending</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns a <code>data.table</code> containing all combinations of the dimensional variables in
the first n columns. Additionally, the following columns are shown:
</p>

<ul>
<li> <p><code>vname</code>: name of the perturbed variable
</p>
</li>
<li> <p><code>uwc</code>: unweighted counts
</p>
</li>
<li> <p><code>wc</code>: weighted counts
</p>
</li>
<li> <p><code>puwc</code>: perturbed unweighted counts or <code>NA</code> if <code>vname</code> was not yet perturbed
</p>
</li>
<li> <p><code>pwc</code>: perturbed weighted counts or <code>NA</code> if <code>vname</code> was not yet perturbed
</p>
</li></ul>



<hr>
<a id="method-cellkey_obj-numtab"></a>



<h4>Method <code>numtab()</code></h4>

<p>Extract results from already perturbed continuous variables
as a <code>data.table</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$numtab(v = NULL, mean_before_sum = FALSE, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a vector of variable names of continuous variables. If <code>NULL</code>
(the default), the results are returned for all available numeric variables.</p>
</dd>
<dt><code>mean_before_sum</code></dt><dd><p>(logical); if <code>TRUE</code>, the perturbed values are adjusted
by a factor <code style="white-space: pre;">&#8288;((n+p))⁄n&#8288;</code> with
</p>

<ul>
<li> <p><code>n</code>: the original weighted cell value
</p>
</li>
<li> <p><code>p</code>: the perturbed cell value
</p>
</li></ul>

<p>This makes sense if the the accuracy of the variable mean is considered to be
more important than accuracy of sums of the variable. The default value is
<code>FALSE</code> (no adjustment is done)</p>
</dd>
<dt><code>path</code></dt><dd><p>if not <code>NULL</code>, a scalar character defining a (relative or absolute)
path to which the result table should be written. A <code>csv</code> file will be generated
and, if specified, <code>path</code> must have &quot;.csv&quot; as file-ending</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns a <code>data.table</code> containing all combinations of the
dimensional variables in the first n columns. Additionally, the following
columns are shown:
</p>

<ul>
<li> <p><code>vname</code>: name of the perturbed variable
</p>
</li>
<li> <p><code>uws</code>: unweighted sum of the given variable
</p>
</li>
<li> <p><code>ws</code>: weighted cellsum
</p>
</li>
<li> <p><code>pws</code>: perturbed weighted sum of the given cell or <code>NA</code> if <code>vname</code>
has not not perturbed
</p>
</li></ul>



<hr>
<a id="method-cellkey_obj-measures_cnts"></a>



<h4>Method <code>measures_cnts()</code></h4>

<p>Utility measures for perturbed count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$measures_cnts(v, exclude_zeros = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>name of a count variable for which utility measures
should be computed.</p>
</dd>
<dt><code>exclude_zeros</code></dt><dd><p>should empty (zero) cells in the original values
be excluded when computing distance measures</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns a <code>list</code> containing a set of utility
measures based on some distance functions. For a detailed description
of the computed measures, see <code><a href="#topic+ck_cnt_measures">ck_cnt_measures()</a></code>
</p>


<hr>
<a id="method-cellkey_obj-measures_nums"></a>



<h4>Method <code>measures_nums()</code></h4>

<p>Utility measures for continuous variables (not yet implemented)
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$measures_nums(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>name of a continuous variable for which utility measures
should be computed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>for (now) an empty list; In future versions of the package, the
Method will return utility measures for perturbed magnitude tables.
</p>


<hr>
<a id="method-cellkey_obj-allvars"></a>



<h4>Method <code>allvars()</code></h4>

<p>Names of variables that can be perturbed / tabulated
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$allvars()</pre></div>



<h5>Returns</h5>

<p>returns a <code>list</code> with the following two elements:
</p>

<ul>
<li> <p><code>cntvars</code>: character vector with names of available count
variables for perturbation
</p>
</li>
<li> <p><code>numvars</code>: character vector with names of available numerical
variables for perturbation
</p>
</li></ul>



<hr>
<a id="method-cellkey_obj-cntvars"></a>



<h4>Method <code>cntvars()</code></h4>

<p>Names of count variables that can be perturbed
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$cntvars()</pre></div>



<h5>Returns</h5>

<p>a character vector containing variable names
</p>


<hr>
<a id="method-cellkey_obj-numvars"></a>



<h4>Method <code>numvars()</code></h4>

<p>Names of continuous variables that can be perturbed
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$numvars()</pre></div>



<h5>Returns</h5>

<p>a character vector containing variable names
</p>


<hr>
<a id="method-cellkey_obj-hierarchy_info"></a>



<h4>Method <code>hierarchy_info()</code></h4>

<p>Information about hierarchies
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$hierarchy_info()</pre></div>



<h5>Returns</h5>

<p>a <code>list</code> (for each dimensional variable) with
information on the hierarchies. This may be used to restrict output tables to
specific levels or codes. Each list element is a <code>data.table</code> containing
the following variables:
</p>

<ul>
<li> <p><code>code</code>: the name of a code within the hierarchy
</p>
</li>
<li> <p><code>level</code>: number defining the level of the code; the higher the number,
the lower the hierarchy with <code>1</code> being the overall total
</p>
</li>
<li> <p><code>is_leaf</code>: if <code>TRUE</code>, this code is a leaf node which means no other codes
contribute to it
</p>
</li>
<li> <p><code>parent</code>: name of the parent code
</p>
</li></ul>



<hr>
<a id="method-cellkey_obj-mod_cnts"></a>



<h4>Method <code>mod_cnts()</code></h4>

<p>Modifications applied to count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$mod_cnts()</pre></div>



<h5>Returns</h5>

<p>a <code>data.table</code> containing modifications applied to count variables
</p>


<hr>
<a id="method-cellkey_obj-mod_nums"></a>



<h4>Method <code>mod_nums()</code></h4>

<p>Modifications applied to numerical variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$mod_nums()</pre></div>



<h5>Returns</h5>

<p>a <code>data.table</code> containing modifications applied to numerical variables
</p>


<hr>
<a id="method-cellkey_obj-supp_freq"></a>



<h4>Method <code>supp_freq()</code></h4>

<p>Identify sensitive cells based on minimum frequency rule
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_freq(v, n, weighted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt><dd><p>a number defining the threshold. All cells <code style="white-space: pre;">&#8288;&lt;= n&#8288;</code> are considered as unsafe.</p>
</dd>
<dt><code>weighted</code></dt><dd><p>if <code>TRUE</code>, the weighted number of contributors to a cell are compared to
the threshold specified in <code>n</code> (default); else the unweighted number of contributors is used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_val"></a>



<h4>Method <code>supp_val()</code></h4>

<p>Identify sensitive cells based on weighted or unweighted cell value
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_val(v, n, weighted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt><dd><p>a number defining the threshold. All cells <code style="white-space: pre;">&#8288;&lt;= n&#8288;</code> are considered as unsafe.</p>
</dd>
<dt><code>weighted</code></dt><dd><p>if <code>TRUE</code>, the weighted cell value of variable <code>v</code> is compared to
the threshold specified in <code>n</code> (default); else the unweighted number is used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_cells"></a>



<h4>Method <code>supp_cells()</code></h4>

<p>Identify sensitive cells based on their <code>names</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_cells(v, inp)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>inp</code></dt><dd><p>a <code>data.frame</code> where each colum represents a dimensional variable. Each row of
this input is then used to compute the relevant cells to be identified as sensitive where
<code>NA</code>-values are possible and used to match any characteristics of the dimensional variable.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_p"></a>



<h4>Method <code>supp_p()</code></h4>

<p>Identify sensitive cells based on the p%-rule rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_p(v, p)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>a number defining a percentage between <code>1</code> and <code>99</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_pq"></a>



<h4>Method <code>supp_pq()</code></h4>

<p>Identify sensitive cells based on the pq-rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_pq(v, p, q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>p</code></dt><dd><p>a number defining a percentage between <code>1</code> and <code>99</code>.</p>
</dd>
<dt><code>q</code></dt><dd><p>a number defining a percentage between <code>1</code> and <code>99</code>. This value must be larger than <code>p</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-supp_nk"></a>



<h4>Method <code>supp_nk()</code></h4>

<p>Identify sensitive cells based on the nk-dominance rule. Please note that this rule
can only be applied to positive-only variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$supp_nk(v, n, k)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a single variable name of a continuous variable (see method <code>numvars()</code>)</p>
</dd>
<dt><code>n</code></dt><dd><p>an integerish number <code style="white-space: pre;">&#8288;&gt;= 2&#8288;</code></p>
</dd>
<dt><code>k</code></dt><dd><p>a number defining a percentage between <code>1</code> and <code>99</code>. All cells to which the top <code>n</code>
contributers contribute more than <code style="white-space: pre;">&#8288;k%&#8288;</code> is considered unsafe</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-params_cnts_get"></a>



<h4>Method <code>params_cnts_get()</code></h4>

<p>Return perturbation parameters of count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_cnts_get()</pre></div>



<h5>Returns</h5>

<p>a named list in which each list-element contains the
active perturbation parameters for the specific count variable
defined by the list-name.
</p>


<hr>
<a id="method-cellkey_obj-params_cnts_set"></a>



<h4>Method <code>params_cnts_set()</code></h4>

<p>Set perturbation parameters for count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_cnts_set(val, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>a perturbation object created with <code><a href="#topic+ck_params_cnts">ck_params_cnts()</a></code></p>
</dd>
<dt><code>v</code></dt><dd><p>a character vector (or <code>NULL</code>). If <code>NULL</code> (the default),
the perturbation parameters provided in <code>val</code> are set for all
count variables; otherwise one may specify the names of
the count variables for which the parameters should be set.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_cntvars"></a>



<h4>Method <code>reset_cntvars()</code></h4>

<p>reset results and parameters for already perturbed
count variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_cntvars(v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>if <code>v</code> equals <code>NULL</code> (the default), the results are reset
for all perturbed count variables; otherwise it is possible to specify
the names of already perturbed count variables.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code> or <code style="white-space: pre;">&#8288;$freqtab()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_numvars"></a>



<h4>Method <code>reset_numvars()</code></h4>

<p>reset results and parameters for already perturbed
numerical variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_numvars(v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>if <code>v</code> equals <code>NULL</code> (the default), the results are reset for all perturbed
numerical variables; otherwise it is possible to specify the names of already
perturbed continuous variables.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code> or <code style="white-space: pre;">&#8288;$numtab()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-reset_allvars"></a>



<h4>Method <code>reset_allvars()</code></h4>

<p>reset results and parameters for all already perturbed variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$reset_allvars()</pre></div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>, <code style="white-space: pre;">&#8288;$freqtab()&#8288;</code> or <code style="white-space: pre;">&#8288;$numtab()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-params_nums_get"></a>



<h4>Method <code>params_nums_get()</code></h4>

<p>Return perturbation parameters of continuous variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_nums_get()</pre></div>



<h5>Returns</h5>

<p>a named list in which each list-element contains the
active perturbation parameters for the specific continuous variable
defined by the list-name.
</p>


<hr>
<a id="method-cellkey_obj-params_nums_set"></a>



<h4>Method <code>params_nums_set()</code></h4>

<p>set perturbation parameters for continuous variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$params_nums_set(val, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>a perturbation object created with <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code></p>
</dd>
<dt><code>v</code></dt><dd><p>a character vector (or <code>NULL</code>); if <code>NULL</code> (the default), the
perturbation parameters provided in <code>val</code> are set for all continuous
variables; otherwise one may specify the names of the numeric variables for
which the parameters should be set.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A modified <code>cellkey_obj</code> object in which private slots were
updated for side-effects. These updated values are used by other
methods (e.g <code style="white-space: pre;">&#8288;$perturb()&#8288;</code>).
</p>


<hr>
<a id="method-cellkey_obj-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>some aggregated summary statistics about perturbed variables
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$summary()</pre></div>



<h5>Returns</h5>

<p>invisible <code>NULL</code>
</p>


<hr>
<a id="method-cellkey_obj-print"></a>



<h4>Method <code>print()</code></h4>

<p>prints information about the current table
</p>


<h5>Usage</h5>

<div class="r"><pre>ck_class$print()</pre></div>



<h5>Returns</h5>

<p>invisible <code>NULL</code>
</p>




<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>

<hr>
<h2 id='ck_cnt_measures'>Utility measures for perturbed counts</h2><span id='topic+ck_cnt_measures'></span>

<h3>Description</h3>

<p>This function computes utility/information loss measures
based on two numeric vectors (original and perturbed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_cnt_measures(orig, pert, exclude_zeros = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_cnt_measures_+3A_orig">orig</code></td>
<td>
<p>a numeric vector holding original values</p>
</td></tr>
<tr><td><code id="ck_cnt_measures_+3A_pert">pert</code></td>
<td>
<p>a numeric vector holding perturbed values</p>
</td></tr>
<tr><td><code id="ck_cnt_measures_+3A_exclude_zeros">exclude_zeros</code></td>
<td>
<p>a scalar logical value; if <code>TRUE</code> (the default), all only cells
with counts <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> are used when computing distances <code>d1</code>, <code>d2</code> and <code>d3</code>. If this
argument is <code>FALSE</code>, the complete vector is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing the following elements:
</p>

<ul>
<li> <p><code>overview</code>: a <code>data.table</code> with the following three columns:
</p>

<ul>
<li> <p><code>noise</code>: amount of noise computed as <code>orig</code> - <code>pert</code>
</p>
</li>
<li> <p><code>cnt</code>: number of cells perturbed with the value given in column <code>noise</code>
</p>
</li>
<li> <p><code>pct</code>: percentage of cells perturbed with the value given in column <code>noise</code>
</p>
</li></ul>

</li>
<li> <p><code>measures</code>: a <code>data.table</code> containing measures of the distribution
of three different distances between original and perturbed values
of the unweighted counts. Column <code>what</code> specifies the computed measure.
The three distances considered are:
</p>

<ul>
<li> <p><code>d1</code>: absolute distance between original and masked values
</p>
</li>
<li> <p><code>d2</code>: relative absolute distance between original and masked values
</p>
</li>
<li> <p><code>d3</code>: absolute distance between square-roots of original and perturbed
values
</p>
</li></ul>

</li>
<li> <p><code>cumdistr_d1</code>, <code>cumdistr_d2</code> and <code>cumdistr_d3</code>: for each distance <code>d1</code>, <code>d2</code>
and <code>d3</code>, a <code>data.table</code> with the following three columns:
</p>

<ul>
<li> <p><code>cat</code>: a specific value (for <code>d1</code>) or interval (for distances <code>d2</code> and <code>d3</code>)
</p>
</li>
<li> <p><code>cnt</code>: number of records smaller or equal the value in column <code>cat</code> for the
given distance
</p>
</li>
<li> <p><code>pct</code>: proportion of records smaller or equal the value
in column <code>cat</code> for the selected distance
</p>
</li></ul>

</li>
<li> <p><code>false_zero</code>: number of cells that were perturbed to zero
</p>
</li>
<li> <p><code>false_nonzero</code>: number of cells that were initially zero but
have been perturbed to a number different from zero
</p>
</li>
<li> <p><code>exclude_zeros</code>: were empty cells exluded from computation or not
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>orig &lt;- c(1:10, 0, 0)
pert &lt;- orig; pert[c(1, 5, 7)] &lt;- c(0, 6, 9)

# ignore empty cells when computing measures `d1`, `d2`, `d3`
ck_cnt_measures(orig = orig, pert = pert, exclude_zeros = TRUE)

# use all cells
ck_cnt_measures(orig = orig, pert = pert, exclude_zeros = FALSE)

# for an application on a perturbed object, see ?cellkey_pkg
</code></pre>

<hr>
<h2 id='ck_create_testdata'>ck_create_testdata</h2><span id='topic+ck_create_testdata'></span>

<h3>Description</h3>

<p>this function generates some test-data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_create_testdata()
</code></pre>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- ck_create_testdata(); print(str(dat))
</code></pre>

<hr>
<h2 id='ck_dat_hc92'>A real-world data set on persons</h2><span id='topic+ck_dat_hc92'></span>

<h3>Description</h3>

<p>820000 obervations in 5 Variables without sampling weights.
</p>


<h3>Format</h3>

<p>ck_dat_hc92: a data frame with 820000 observations on the following 6 variables.
</p>

<ul>
<li> <p><code>id</code>: a numeric identifier
</p>
</li>
<li> <p><code>geo_m</code>: a character vector defining regions
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sex a&#8288;</code>: character vector defining gender
</p>
</li>
<li> <p><code>age_m</code>: a character vector containing age groups
</p>
</li>
<li> <p><code>yae_h</code>: a character vector
</p>
</li>
<li> <p><code>rkey</code>: a numeric vector holding record keys
</p>
</li></ul>



<h3>References</h3>

<p>https://ec.europa.eu/eurostat/cros/content/3-random-noise-cell-key-method_en
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ck_dat_hc92)
head(ck_dat_hc92)
</code></pre>

<hr>
<h2 id='ck_flexparams'>Set parameters required to perturb numeric variables using a flex function</h2><span id='topic+ck_flexparams'></span>

<h3>Description</h3>

<p><code><a href="#topic+ck_flexparams">ck_flexparams()</a></code> allows to define a flex function that is used to lookup perturbation
magnitudes (percentages) used when perturbing continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_flexparams(fp, p = c(0.25, 0.05), epsilon = 1, q = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_flexparams_+3A_fp">fp</code></td>
<td>
<p>(numeric scalar); at which point should the noise coefficient
function reaches its desired maximum (defined by the first element of <code>p</code>)</p>
</td></tr>
<tr><td><code id="ck_flexparams_+3A_p">p</code></td>
<td>
<p>a numeric vector of length <code>2</code> where both elements specify a percentage.
The first value refers to the desired maximum perturbation percentage for small
cells (depending on <code>fp</code>) while the second element refers to the desired maximum
perturbation percentage for large cells. Both values must be between <code>0</code> and <code>1</code> and
need to be in descending order.</p>
</td></tr>
<tr><td><code id="ck_flexparams_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric vector in descending order with all values <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code> with the first
element forced to equal 1. The length of this vector must correspond with the number <code>top_k</code>
specified in <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code> when creating parameters for <code>type == "top_contr"</code> which is
checked at runtime. This setting allows to use different flex-functions for the largest <code>top_k</code> contributors.</p>
</td></tr>
<tr><td><code id="ck_flexparams_+3A_q">q</code></td>
<td>
<p>(numeric scalar); Parameter of the function; <code>q</code> needs to be <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>details about the flex function can be found in Deliverable D4.2, Part I in
SGA <em>&quot;Open Source tools for perturbative confidentiality methods&quot;</em>
</p>


<h3>Value</h3>

<p>an object suitable as input for <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ck_simpleparams">ck_simpleparams()</a></code>, <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>

<hr>
<h2 id='ck_generate_rkeys'>Generate random record keys</h2><span id='topic+ck_generate_rkeys'></span>

<h3>Description</h3>

<p>This function allows to create random record keys from a uniform distribution. If no seed is
specified, a seed value is computed from the input data set to allow for reproducability depending
on the input data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_generate_rkeys(dat, nr_digits = 8, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_generate_rkeys_+3A_dat">dat</code></td>
<td>
<p>microdata used to generated hash for random seed</p>
</td></tr>
<tr><td><code id="ck_generate_rkeys_+3A_nr_digits">nr_digits</code></td>
<td>
<p>maximum number of digits in the record keys. The default setting (<code>8</code>) corresponds
with the default setting of the method in <code>tau-argus</code>.</p>
</td></tr>
<tr><td><code id="ck_generate_rkeys_+3A_seed">seed</code></td>
<td>
<p>if not <code>NULL</code>, a number specifying the initial seed value
for the random number generator. If <code>NULL</code>, a seed is computed from <code>dat</code> itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with <code>nrow(dat)</code> record keys
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- ck_create_testdata()
dat$rkeys &lt;- ck_generate_rkeys(dat = ck_create_testdata(), nr_digits = 8)
</code></pre>

<hr>
<h2 id='ck_params_cnts'>Create perturbation parameters for count variables</h2><span id='topic+ck_params_cnts'></span>

<h3>Description</h3>

<p>This function allows to generate required perturbation parameters that are used
to perturb count variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_params_cnts(ptab, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_params_cnts_+3A_ptab">ptab</code></td>
<td>
<p>an object created with <code><a href="ptable.html#topic+ptable_pkg">ptable::create_ptable()</a></code>,
or <code><a href="ptable.html#topic+ptable_pkg">ptable::create_cnt_ptable()</a></code></p>
</td></tr>
<tr><td><code id="ck_params_cnts_+3A_path">path</code></td>
<td>
<p>a scalar character specifying a path to which the parameters
created with this functions should be written to (in yaml format)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object suitable as input to method <code style="white-space: pre;">&#8288;$params_cnts_set()&#8288;</code> for the perturbation
of counts and frequencies.
</p>


<h3>See Also</h3>

<p>This function uses functionality from package
<code>ptable</code> (https://github.com/sdcTools/ptable), expecially
<code><a href="ptable.html#topic+ptable_pkg">ptable::create_ptable()</a></code> and
<code><a href="ptable.html#topic+ptable_pkg">ptable::create_cnt_ptable()</a></code>. More detailed information on the parameters
is available from the respective help-pages of these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>

<hr>
<h2 id='ck_params_nums'>Set perturbation parameters for continuous variables</h2><span id='topic+ck_params_nums'></span>

<h3>Description</h3>

<p>This function allows to define perturbation parameters used to
perturb cells in magnitude tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_params_nums(
  type = "top_contr",
  top_k = NULL,
  ptab,
  mult_params,
  mu_c = 0,
  same_key = TRUE,
  use_zero_rkeys = FALSE,
  path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_params_nums_+3A_type">type</code></td>
<td>
<p>a character value defining the way to identify the <code>magnifier</code>,
e.g which contributions/values in a cell should be the used in the
perturbation procedure. Possible choices are:
</p>

<ul>
<li> <p><code>top_contr</code>: the <code>k</code> largest contributions are used. In this case,
it is also required to specify argument <code>top_k</code>
</p>
</li>
<li> <p><code>mean</code>: the (weighted) cellmean is used as starting point
</p>
</li>
<li> <p><code>range</code>: the difference between largest and smallest contribution
is used.
</p>
</li>
<li> <p><code>sum</code>: the (weighted) cellvalue itself is used as starting point
</p>
</li></ul>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_top_k">top_k</code></td>
<td>
<p>it is ignored if <code>variant</code> is different from <code>top_contr</code>.
Otherwise, a scalar number <code style="white-space: pre;">&#8288;&gt;0&#8288;</code> is expected.</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_ptab">ptab</code></td>
<td>
<p>in this argument, one ore more perturbation tables are given as
input. the following choices are possible:
</p>

<ul>
<li><p> an object derived from <code><a href="ptable.html#topic+ptable_pkg">ptable::create_ptable()</a></code>
or <code><a href="ptable.html#topic+ptable_pkg">ptable::create_num_ptable()</a></code>: this case is the same as specifying a named
list with only a single element <code>"all"</code> (as described below)
</p>
</li>
<li><p> a named <code>list</code> where the allowed names are shown below and each element
must be the output of [ptable::create_ptable())] or
<code><a href="ptable.html#topic+ptable_pkg">ptable::create_num_ptable()</a></code>
</p>

<ul>
<li> <p><code>"all"</code>: this ptable will be used for all cells; if specified, no
elements named <code>"even"</code> or <code>"odd"</code> must exist.
</p>
</li>
<li> <p><code>"even"</code>: will be used to look up perturbation values for cells with an
even number of contributors. if specified, also list-element <code>"odd"</code> must
exist.
</p>
</li>
<li> <p><code>"odd"</code>: will be used to look up perturbation values for cells with an
odd number of contributors; if specified, also list-element <code>"even"</code> must
exist.
</p>
</li>
<li> <p><code>"small_cells"</code>: if specified, this ptable will be used to extract
perturbation values for very small cells
</p>
</li></ul>

</li></ul>

<p>[ptable::create_ptable())]: R:ptable::create_ptable())
<code><a href="ptable.html#topic+ptable_pkg">ptable::create_num_ptable()</a></code>: R:ptable::create_num_ptable()</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_mult_params">mult_params</code></td>
<td>
<p>an object derived with <code><a href="#topic+ck_flexparams">ck_flexparams()</a></code> or
<code><a href="#topic+ck_simpleparams">ck_simpleparams()</a></code> that contain required parameters for the computation of
the perturbation multiplier</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_mu_c">mu_c</code></td>
<td>
<p>fixed extra protection amount (<code style="white-space: pre;">&#8288;&gt;= 0)&#8288;</code> applied to the absolute of
the perturbation value of the first (largest) noise component if the cell is
sensitive. This value defaults to <code>0</code> (no additional protection). Please note
that sensitive cells can be defined according using the <code>supp_freq()</code>,
<code>supp_val</code>, <code>supp_p()</code>, <code>supp_nk()</code> and <code>supp_pq()</code> methods. An examples is
given in <code>?cellkey_pkg</code>.</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_same_key">same_key</code></td>
<td>
<p>(logical) should original cell key (<code>TRUE</code>) used for
for finding perturbation values of the largest contributor to a
cell or should a perturbation of the cellkey itself (<code>FALSE</code>) take place.</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_use_zero_rkeys">use_zero_rkeys</code></td>
<td>
<p>(logical) scalar defining if record keys of
units not contributing to a specific numeric variables should be
used (<code>TRUE</code>) or ignored (<code>FALSE</code>) when computing cell keys.</p>
</td></tr>
<tr><td><code id="ck_params_nums_+3A_path">path</code></td>
<td>
<p>a scalar character specifying a path to which the parameters
created with this functions should be written to (in yaml format)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object suitable as input to method <code style="white-space: pre;">&#8288;$params_nums_set()&#8288;</code> for the
perturbation of continous variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ck_flexparams">ck_flexparams()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a perturbation table using
# functionality from ptable-pkg; see help(pa = "ptable")
# this returns an extra ptable for very small cells
ptab &lt;- ptable::pt_ex_nums(separation = TRUE)

# create parameters
ck_params_nums(
  type = "top_contr",
  top_k = 3,
  ptab = ptab,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.20, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 2),
  use_zero_rkeys = TRUE,
  mu_c = 3)
</code></pre>

<hr>
<h2 id='ck_read_yaml'>Read perturbation parameters from yaml-files</h2><span id='topic+ck_read_yaml'></span>

<h3>Description</h3>

<p><code><a href="#topic+ck_read_yaml">ck_read_yaml()</a></code> allows to create perturbation parameter inputs from yaml-files
that were previously created using <code><a href="#topic+ck_params_cnts">ck_params_cnts()</a></code> or <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_read_yaml(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_read_yaml_+3A_path">path</code></td>
<td>
<p>a path to a yaml-input file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object object suitable as input to method <code style="white-space: pre;">&#8288;$params_nums_set()&#8288;</code> for the perturbation
of continous variables in case <code>path</code> was created using <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code> or an object
suitable as input for <code style="white-space: pre;">&#8288;$params_cnts_set()&#8288;</code> for the perturbation
of counts and frequencies if the input file was generated using <code><a href="#topic+ck_params_cnts">ck_params_cnts()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>

<hr>
<h2 id='ck_simpleparams'>Set parameters required to perturb numeric variables using a simple approach</h2><span id='topic+ck_simpleparams'></span>

<h3>Description</h3>

<p><code><a href="#topic+ck_simpleparams">ck_simpleparams()</a></code> allows to define parameters for a simple perturbation
approach based on a single magnitude parameter (<code>m</code>). The values of <code>epsilon</code>
are used to  <code>"weight"</code> parameter <code>m</code> in case <code>type == "top_contr"</code> is set in
<code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_simpleparams(p, epsilon = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_simpleparams_+3A_p">p</code></td>
<td>
<p>a percentage value used as magnitude for perturbation</p>
</td></tr>
<tr><td><code id="ck_simpleparams_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric vector in descending order with all values <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code> with the first
element forced to equal 1. The length of this vector must correspond with the number <code>top_k</code>
specified in <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code> when creating parameters for <code>type == "top_contr"</code> which is
checked at runtime. This setting allows to use different flex-functions for the largest <code>top_k</code> contributors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details about the flex function can be found in Deliverable D4.2, Part I in
SGA <em>&quot;Open Source tools for perturbative confidentiality methods&quot;</em>
</p>


<h3>Value</h3>

<p>an object suitable as input for <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ck_flexparams">ck_flexparams()</a></code>, <code><a href="#topic+ck_params_nums">ck_params_nums()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ck_create_testdata()

# create some 0/1 variables that should be perturbed later
x[, cnt_females := ifelse(sex == "male", 0, 1)]
x[, cnt_males := ifelse(sex == "male", 1, 0)]
x[, cnt_highincome := ifelse(income &gt;= 9000, 1, 0)]
# a variable with positive and negative contributions
x[, mixed := sample(-10:10, nrow(x), replace = TRUE)]

# create record keys
x$rkey &lt;- ck_generate_rkeys(dat = x)

# define required inputs

# hierarchy with some bogus codes
d_sex &lt;- hier_create(root = "Total", nodes = c("male", "female"))
d_sex &lt;- hier_add(d_sex, root = "female", "f")
d_sex &lt;- hier_add(d_sex, root = "male", "m")

d_age &lt;- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
d_age &lt;- hier_add(d_age, root = "age_group1", "ag1a")
d_age &lt;- hier_add(d_age, root = "age_group2", "ag2a")

# define the cell key object
countvars &lt;- c("cnt_females", "cnt_males", "cnt_highincome")
numvars &lt;- c("expend", "income", "savings", "mixed")
tab &lt;- ck_setup(
  x = x,
  rkey = "rkey",
  dims = list(sex = d_sex, age = d_age),
  w = "sampling_weight",
  countvars = countvars,
  numvars = numvars)

# show some information about this table instance
tab$print() # identical with print(tab)

# information about the hierarchies
tab$hierarchy_info()

# which variables have been defined?
tab$allvars()

# count variables
tab$cntvars()

# continuous variables
tab$numvars()

# create perturbation parameters for "total" variable and
# write to yaml-file

# create a ptable using functionality from the ptable-pkg
f_yaml &lt;- tempfile(fileext = ".yaml")
p_cnts1 &lt;- ck_params_cnts(
  ptab = ptable::pt_ex_cnts(),
  path = f_yaml)

# read parameters from yaml-file and set them for variable `"total"`
p_cnts1 &lt;- ck_read_yaml(path = f_yaml)

tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters by specifying parameters
para2 &lt;- ptable::create_cnt_ptable(
  D = 8, V = 3, js = 2, create = FALSE)

p_cnts2 &lt;- ck_params_cnts(ptab = para2)

# use these ptable it for the remaining variables
tab$params_cnts_set(val = p_cnts2, v = countvars)

# perturb a variable
tab$perturb(v = "total")

# multiple variables can be perturbed as well
tab$perturb(v = c("cnt_males", "cnt_highincome"))

# return weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# numerical variables (positive variables using flex-function)
# we also write the config to a yaml file
f_yaml &lt;- tempfile(fileext = ".yaml")

# create a ptable using functionality from the ptable-pkg
# a single ptable for all cells
ptab1 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = FALSE)

# a single ptab for all cells except for very small ones
ptab2 &lt;- ptable::pt_ex_nums(parity = TRUE, separation = TRUE)

# different ptables for cells with even/odd number of contributors
# and very small cells
ptab3 &lt;- ptable::pt_ex_nums(parity = FALSE, separation = TRUE)

p_nums1 &lt;- ck_params_nums(
  ptab = ptab1,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.30, 0.03),
    epsilon = c(1, 0.5, 0.2),
    q = 3),
  mu_c = 2,
  same_key = FALSE,
  use_zero_rkeys = FALSE,
  path = f_yaml)

# we read the parameters from the yaml-file
p_nums1 &lt;- ck_read_yaml(path = f_yaml)

# for variables with positive and negative values
p_nums2 &lt;- ck_params_nums(
  ptab = ptab2,
  type = "top_contr",
  top_k = 3,
  mult_params = ck_flexparams(
    fp = 1000,
    p = c(0.15, 0.02),
    epsilon = c(1, 0.4, 0.15),
    q = 3),
  mu_c = 2,
  same_key = FALSE)

# simple perturbation parameters (not using the flex-function approach)
p_nums3 &lt;- ck_params_nums(
  ptab = ptab3,
  type = "mean",
  mult_params = ck_simpleparams(p = 0.25),
  mu_c = 2,
  same_key = FALSE)

# use `p_nums1` for all variables
tab$params_nums_set(p_nums1, c("savings", "income", "expend"))

# use different parameters for variable `mixed`
tab$params_nums_set(p_nums2, v = "mixed")

# identify sensitive cells to which extra protection (`mu_c`) is added.
tab$supp_p(v = "income", p = 85)
tab$supp_pq(v = "income", p = 85, q = 90)
tab$supp_nk(v = "income", n = 2, k = 90)
tab$supp_freq(v = "income", n = 14, weighted = FALSE)
tab$supp_val(v = "income", n = 10000, weighted = TRUE)
tab$supp_cells(
  v = "income",
  inp = data.frame(
    sex = c("female", "female"),
    "age" = c("age_group1", "age_group3")
  )
)

# perturb variables
tab$perturb(v = c("income", "savings"))

# extract results
tab$numtab("income", mean_before_sum = TRUE)
tab$numtab("income", mean_before_sum = FALSE)
tab$numtab("savings")

# results can be resetted, too
tab$reset_cntvars(v = "cnt_males")

# we can then set other parameters and perturb again
tab$params_cnts_set(val = p_cnts1, v = "cnt_males")

tab$perturb(v = "cnt_males")

# write results to a .csv file
tab$freqtab(
  v = c("total", "cnt_males"),
  path = file.path(tempdir(), "outtab.csv")
)

# show results containing weighted and unweighted results
tab$freqtab(v = c("total", "cnt_males"))

# utility measures for a count variable
tab$measures_cnts(v = "total", exclude_zeros = TRUE)

# modifications for perturbed count variables
tab$mod_cnts()

# display a summary about utility measures
tab$summary()

</code></pre>

<hr>
<h2 id='ck_vignette'>ck_vignette</h2><span id='topic+ck_vignette'></span>

<h3>Description</h3>

<p>starts the package vignette that gets you started with the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_vignette()
</code></pre>


<h3>Value</h3>

<p>a browser windows/tab with showing the vignette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ck_vignette()

## End(Not run)
</code></pre>

<hr>
<h2 id='testdata'>A real-world data set on household income and expenditures</h2><span id='topic+testdata'></span>

<h3>Description</h3>

<p>4580 Obervations in 15 Variables; This dataset also contains sampling weights!
</p>


<h3>Format</h3>

<p>testdata: a data frame with 4580 observations on the following 15 variables.
</p>

<ul>
<li> <p><code>urbrur</code>: a numeric vector
</p>
</li>
<li> <p><code>roof</code>: a numeric vector
</p>
</li>
<li> <p><code>walls</code>: a numeric vector
</p>
</li>
<li> <p><code>water</code>: a numeric vector
</p>
</li>
<li> <p><code>electcon</code>: a numeric vector
</p>
</li>
<li> <p><code>relat</code>: a numeric vector
</p>
</li>
<li> <p><code>sex</code>: a numeric vector
</p>
</li>
<li> <p><code>age</code>: a numeric vector
</p>
</li>
<li> <p><code>hhcivil</code>: a numeric vector
</p>
</li>
<li> <p><code>expend</code>: a numeric vector
</p>
</li>
<li> <p><code>income</code>: a numeric vector
</p>
</li>
<li> <p><code>savings</code>: a numeric vector
</p>
</li>
<li> <p><code>ori_hid</code>: a numeric vector
</p>
</li>
<li> <p><code>sampling_weight</code>: a numeric vector
</p>
</li>
<li> <p><code>household_weights</code>: a numeric vector
</p>
</li></ul>



<h3>References</h3>

<p>The International Household Survey Network, www.ihsn.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testdata)
head(testdata)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
