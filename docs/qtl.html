<!DOCTYPE html><html lang="en"><head><title>Help for package qtl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A+20starting+20point'><p>Introductory comments on R/qtl</p></a></li>
<li><a href='#add.cim.covar'><p>Indicate marker covariates from composite interval mapping</p></a></li>
<li><a href='#add.threshold'><p>Add significance threshold to plot</p></a></li>
<li><a href='#addcovarint'><p>Add QTL x covariate interaction to a multiple-QTL model</p></a></li>
<li><a href='#addint'><p>Add pairwise interaction to a multiple-QTL model</p></a></li>
<li><a href='#addloctocross'><p>Add phenotype location into a cross object</p></a></li>
<li><a href='#addmarker'><p>Add a marker to a cross</p></a></li>
<li><a href='#addpair'><p>Scan for an additional pair of QTL in a multiple-QTL model</p></a></li>
<li><a href='#addqtl'><p>Scan for an additional QTL in a multiple-QTL model</p></a></li>
<li><a href='#addtoqtl'><p>Add to a qtl object</p></a></li>
<li><a href='#allchrsplits'><p>Test all possible splits of a chromosome into two pieces</p></a></li>
<li><a href='#argmax.geno'><p>Reconstruct underlying genotypes</p></a></li>
<li><a href='#arithscan'><p>Arithmetic operators for scanone and scantwo results</p></a></li>
<li><a href='#arithscanperm'><p>Arithmetic Operators for permutation results</p></a></li>
<li><a href='#badorder'><p>An intercross with misplaced markers</p></a></li>
<li><a href='#bayesint'><p>Bayesian credible interval</p></a></li>
<li><a href='#bristle3'><p>Data on bristle number in Drosophila</p></a></li>
<li><a href='#bristleX'><p>Data on bristle number in Drosophila</p></a></li>
<li><a href='#c.cross'><p>Combine data for QTL experiments</p></a></li>
<li><a href='#c.scanone'><p>Combine columns from multiple scanone results</p></a></li>
<li><a href='#c.scanoneperm'><p>Combine data from scanone permutations</p></a></li>
<li><a href='#c.scantwo'><p>Combine columns from multiple scantwo results</p></a></li>
<li><a href='#c.scantwoperm'><p>Combine data from scantwo permutations</p></a></li>
<li><a href='#calc.errorlod'><p>Identify likely genotyping errors</p></a></li>
<li><a href='#calc.genoprob'><p>Calculate conditional genotype probabilities</p></a></li>
<li><a href='#calc.penalties'><p>Calculate LOD penalties</p></a></li>
<li><a href='#cbind.scanoneperm'><p>Combine columns from multiple scanone permutation results</p></a></li>
<li><a href='#cbind.scantwoperm'><p>Combine scantwo permutations by column</p></a></li>
<li><a href='#checkAlleles'><p>Identify markers with switched alleles</p></a></li>
<li><a href='#chrlen'><p>Chromosome lengths in QTL experiment</p></a></li>
<li><a href='#chrnames'><p>Pull out the chromosome names from a cross</p></a></li>
<li><a href='#cim'><p>Composite interval mapping</p></a></li>
<li><a href='#clean.cross'><p>Remove derived data</p></a></li>
<li><a href='#clean.scantwo'><p>Clean up scantwo output</p></a></li>
<li><a href='#cleanGeno'><p>Delete genotypes that are possibly in error</p></a></li>
<li><a href='#comparecrosses'><p>Compare two cross objects</p></a></li>
<li><a href='#comparegeno'><p>Compare individuals' genotype data</p></a></li>
<li><a href='#compareorder'><p>Compare two orderings of markers on a chromosome</p></a></li>
<li><a href='#condense.scantwo'><p>Condense the output from a 2-d genome scan</p></a></li>
<li><a href='#convert.map'><p>Change map function for a genetic map</p></a></li>
<li><a href='#convert.scanone'><p>Convert output from scanone for R/qtl version 0.98</p></a></li>
<li><a href='#convert.scantwo'><p>Convert output from scantwo for R/qtl version 1.03 and earlier</p></a></li>
<li><a href='#convert2riself'><p>Convert a cross to RIL by selfing</p></a></li>
<li><a href='#convert2risib'><p>Convert a cross to RIL by sib mating</p></a></li>
<li><a href='#convert2sa'><p>Convert a sex-specific map to a sex-averaged one</p></a></li>
<li><a href='#countXO'><p>Count number of obligate crossovers for each individual</p></a></li>
<li><a href='#drop.dupmarkers'><p>Drop duplicate markers</p></a></li>
<li><a href='#drop.markers'><p>Drop a set of markers</p></a></li>
<li><a href='#drop.nullmarkers'><p>Drop markers without any genotype data</p></a></li>
<li><a href='#dropfromqtl'><p>Drop a QTL from a qtl object</p></a></li>
<li><a href='#droponemarker'><p>Drop one marker at a time and determine effect on genetic map</p></a></li>
<li><a href='#effectplot'><p>Plot phenotype means against genotypes at one or two markers</p></a></li>
<li><a href='#effectscan'><p>Plot estimated QTL effects across the whole genome</p></a></li>
<li><a href='#est.map'><p>Estimate genetic maps</p></a></li>
<li><a href='#est.rf'><p>Estimate pairwise recombination fractions</p></a></li>
<li><a href='#fake.4way'><p>Simulated data for a 4-way cross</p></a></li>
<li><a href='#fake.bc'><p>Simulated data for a backcross</p></a></li>
<li><a href='#fake.f2'><p>Simulated data for an F2 intercross</p></a></li>
<li><a href='#fill.geno'><p>Fill holes in genotype data</p></a></li>
<li><a href='#find_large_intervals'><p>Find large intervals in a map</p></a></li>
<li><a href='#find.flanking'><p>Find flanking markers for a specified position</p></a></li>
<li><a href='#find.marker'><p>Find marker closest to a specified position</p></a></li>
<li><a href='#find.markerindex'><p>Determine the numeric index for a marker</p></a></li>
<li><a href='#find.markerpos'><p>Find position of a marker</p></a></li>
<li><a href='#find.pheno'><p>Find column number for a particular phenotype</p></a></li>
<li><a href='#find.pseudomarker'><p>Find the pseudomarker closest to a specified position</p></a></li>
<li><a href='#findDupMarkers'><p>Find markers with identical genotype data</p></a></li>
<li><a href='#fitqtl'><p>Fit a multiple-QTL model</p></a></li>
<li><a href='#fitstahl'><p>Fit Stahl interference model</p></a></li>
<li><a href='#flip.order'><p>Flip the orders of markers on a set of chromosomes</p></a></li>
<li><a href='#formLinkageGroups'><p>Partition markers into linkage groups</p></a></li>
<li><a href='#formMarkerCovar'><p>Create matrix of marker covariates for QTL analysis</p></a></li>
<li><a href='#geno.crosstab'><p>Create table of two-locus genotypes</p></a></li>
<li><a href='#geno.image'><p>Plot grid of genotype data</p></a></li>
<li><a href='#geno.table'><p>Create table of genotype distributions</p></a></li>
<li><a href='#getid'><p>Pull out the individual identifiers from a cross</p></a></li>
<li><a href='#groupclusteredheatmap'><p>Retrieving groups of traits after clustering</p></a></li>
<li><a href='#hyper'><p>Data on hypertension</p></a></li>
<li><a href='#inferFounderHap'><p>Crude reconstruction of founder haplotypes in multi-parent RIL</p></a></li>
<li><a href='#inferredpartitions'><p>Identify inferred partitions in mapping QTL to a phylogenetic tree</p></a></li>
<li><a href='#interpPositions'><p>Interpolate positions from one map to another</p></a></li>
<li><a href='#jittermap'><p>Jitter marker positions in a genetic map</p></a></li>
<li><a href='#listeria'><p>Data on Listeria monocytogenes susceptibility</p></a></li>
<li><a href='#locateXO'><p>Estimate locations of crossovers</p></a></li>
<li><a href='#locations'>
<p>Genetic locations of traits for the multitrait dataset</p></a></li>
<li><a href='#lodint'><p>LOD support interval</p></a></li>
<li><a href='#makeqtl'><p>Make a qtl object</p></a></li>
<li><a href='#map10'><p>An example genetic map</p></a></li>
<li><a href='#map2table'><p>Convert genetic map from list to table.</p></a></li>
<li><a href='#mapthis'><p>Simulated data for illustrating genetic map construction</p></a></li>
<li><a href='#markerlrt'><p>General likelihood ratio test for association between marker pairs</p></a></li>
<li><a href='#markernames'><p>Pull out the marker names from a cross</p></a></li>
<li><a href='#max.scanone'><p>Maximum peak in genome scan</p></a></li>
<li><a href='#max.scanPhyloQTL'><p>Maximum peak in genome scan to map a QTL to a phylogenetic tree</p></a></li>
<li><a href='#max.scantwo'><p>Maximum peak in two-dimensional genome scan</p></a></li>
<li><a href='#movemarker'><p>Move a marker to a new chromosome</p></a></li>
<li><a href='#MQM'><p>Introduction to Multiple QTL Model (MQM) mapping</p></a></li>
<li><a href='#mqmaugment'><p>MQM augmentation</p></a></li>
<li><a href='#mqmautocofactors'><p>Automatic setting of cofactors, taking marker density into account</p></a></li>
<li><a href='#mqmextractmarkers'><p>MQM marker extraction</p></a></li>
<li><a href='#mqmfind.marker'><p> Fetch significant markers after permutation analysis</p></a></li>
<li><a href='#mqmgetmodel'><p> Retrieve the QTL model used in mapping from the results of an MQM scan</p></a></li>
<li><a href='#mqmpermutation'><p>Estimate QTL LOD score significance using permutations or simulations</p></a></li>
<li><a href='#mqmplot.circle'><p>Circular genome plot for MQM</p></a></li>
<li><a href='#mqmplot.cistrans'><p>cis-trans plot</p></a></li>
<li><a href='#mqmplot.clusteredheatmap'><p>Plot clustered heatmap</p>
of MQM scan on multiple phenotypes</a></li>
<li><a href='#mqmplot.cofactors'><p>Plot cofactors on the genetic map</p></a></li>
<li><a href='#mqmplot.directedqtl'><p>Plot LOD*Effect curves of a multiple-QTL model</p></a></li>
<li><a href='#mqmplot.heatmap'><p>Heatmap of a genome of MQM scan on multiple phenotypes</p></a></li>
<li><a href='#mqmplot.multitrait'><p>Plot the results from a genomescan using a multiple-QTL model on multiple phenotypes</p></a></li>
<li><a href='#mqmplot.permutations'><p>Plot results from mqmpermutation</p></a></li>
<li><a href='#mqmplot.singletrait'><p>Plot LOD curves of a multiple-QTL model</p></a></li>
<li><a href='#mqmprocesspermutation'><p>Convert mqmmulti objects into a scanoneperm object</p></a></li>
<li><a href='#mqmscan'><p>Genome scan with a multiple QTL model (MQM)</p></a></li>
<li><a href='#mqmscanall'><p>Parallelized MQM on multiple phenotypes in a cross object</p></a></li>
<li><a href='#mqmscanfdr'><p> Estimate FDR for multiple trait QTL analysis</p></a></li>
<li><a href='#mqmsetcofactors'><p>Set cofactors at fixed intervals, to be used with MQM</p></a></li>
<li><a href='#mqmtestnormal'><p> Shapiro normality test used for MQM</p></a></li>
<li><a href='#multitrait'>
<p>Example Cross object from R/QTL with multiple traits</p></a></li>
<li><a href='#nchr'><p>Determine the number of chromosomes</p></a></li>
<li><a href='#nind'><p>Determine the number of individuals QTL experiment</p></a></li>
<li><a href='#nmar'><p>Determine the numbers of markers on each chromosome</p></a></li>
<li><a href='#nmissing'><p>Number of missing genotypes</p></a></li>
<li><a href='#nphe'><p>Determine the number of phenotypes QTL experiment</p></a></li>
<li><a href='#nqrank'><p>Transform a vector of quantitative values to the corresponding</p>
normal quantiles</a></li>
<li><a href='#nqtl'><p>Determine the number of QTL in a QTL object</p></a></li>
<li><a href='#ntyped'><p>Number of genotypes</p></a></li>
<li><a href='#nullmarkers'><p>Identify markers without any genotype data</p></a></li>
<li><a href='#orderMarkers'><p>Find an initial order for markers within chromosomes</p></a></li>
<li><a href='#phenames'><p>Pull out the phenotypes names from a cross</p></a></li>
<li><a href='#pickMarkerSubset'><p>Identify the largest subset of markers that are some distance apart</p></a></li>
<li><a href='#plot.comparegeno'><p>Plot genotype comparison</p></a></li>
<li><a href='#plot.cross'><p>Plot various features of a cross object</p></a></li>
<li><a href='#plot.qtl'><p>Plot QTL locations</p></a></li>
<li><a href='#plot.rfmatrix'><p>Plot recombination fractions or LOD scores for a single marker</p></a></li>
<li><a href='#plot.scanone'><p>Plot LOD curves</p></a></li>
<li><a href='#plot.scanoneboot'><p>Plot results of bootstrap for QTL position</p></a></li>
<li><a href='#plot.scanoneperm'><p>Plot permutation results for a single-QTL genome scan</p></a></li>
<li><a href='#plot.scanPhyloQTL'><p>Plot LOD curves from single-QTL scan to map QTL to a phylogenetic tree</p></a></li>
<li><a href='#plot.scantwo'><p>Plot LOD scores for a two-dimensional genome scan</p></a></li>
<li><a href='#plot.scantwoperm'><p>Plot permutation results for a 2d, 2-QTL genome scan</p></a></li>
<li><a href='#plotErrorlod'><p>Plot grid of error LOD values</p></a></li>
<li><a href='#plotGeno'><p>Plot observed genotypes, flagging likely errors</p></a></li>
<li><a href='#plotInfo'><p>Plot the proportion of missing genotype information</p></a></li>
<li><a href='#plotLodProfile'><p>Plot 1-d LOD profiles for a multiple QTL model</p></a></li>
<li><a href='#plotMap'><p>Plot genetic map</p></a></li>
<li><a href='#plotMissing'><p>Plot grid of missing genotypes</p></a></li>
<li><a href='#plotModel'><p>Plot a QTL model</p></a></li>
<li><a href='#plotPheno'><p>Plot a phenotype distribution</p></a></li>
<li><a href='#plotPXG'><p>Plot phenotypes versus marker genotypes</p></a></li>
<li><a href='#plotRF'><p>Plot recombination fractions</p></a></li>
<li><a href='#pull.argmaxgeno'><p>Pull out the results of the Viterbi algorithm from a cross</p></a></li>
<li><a href='#pull.draws'><p>Pull out the genotype imputations from a cross</p></a></li>
<li><a href='#pull.geno'><p>Pull out the genotype data from a cross</p></a></li>
<li><a href='#pull.genoprob'><p>Pull out the genotype probabilities from a cross</p></a></li>
<li><a href='#pull.map'><p>Pull out the genetic map from a cross</p></a></li>
<li><a href='#pull.markers'><p>Drop all but a selected set of markers</p></a></li>
<li><a href='#pull.pheno'><p>Pull out phenotype data from a cross</p></a></li>
<li><a href='#pull.rf'><p>Pull out recombination fractions or LOD scores from a cross object</p></a></li>
<li><a href='#qtl-internal'><p>Internal qtl functions</p></a></li>
<li><a href='#qtlversion'><p>Installed version of R/qtl</p></a></li>
<li><a href='#read.cross'><p>Read data for a QTL experiment</p></a></li>
<li><a href='#readMWril'><p>Read data for 4- or 8-way RIL</p></a></li>
<li><a href='#reduce2grid'><p>Reduce to a grid of pseudomarkers.</p></a></li>
<li><a href='#refineqtl'><p>Refine the positions of QTL</p></a></li>
<li><a href='#reorderqtl'><p>Reorder the QTL in a qtl object</p></a></li>
<li><a href='#replace.map'><p>Replace the genetic map of a cross</p></a></li>
<li><a href='#replacemap.scanone'><p>Replace the genetic map in QTL mapping results with an alternate map</p></a></li>
<li><a href='#replacemap.scantwo'><p>Replace the genetic map in QTL mapping results with an alternate map</p></a></li>
<li><a href='#replaceqtl'><p>Replace a QTL in a qtl object with a different position</p></a></li>
<li><a href='#rescalemap'><p>Rescale genetic maps</p></a></li>
<li><a href='#ripple'><p>Compare marker orders</p></a></li>
<li><a href='#scanone'><p>Genome scan with a single QTL model</p></a></li>
<li><a href='#scanoneboot'><p>Bootstrap to get interval estimate of QTL location</p></a></li>
<li><a href='#scanonevar'><p>Genome scan for QTL affecting mean and/or variance</p></a></li>
<li><a href='#scanonevar.meanperm'><p>Permutation test for mean effect in scanonevar</p></a></li>
<li><a href='#scanonevar.varperm'><p>Permutation test for variance effect in scanonevar</p></a></li>
<li><a href='#scanPhyloQTL'><p>Single-QTL genome scan to map QTL to a phylogenetic tree</p></a></li>
<li><a href='#scanqtl'><p>General QTL scan</p></a></li>
<li><a href='#scantwo'><p>Two-dimensional genome scan with a two-QTL model</p></a></li>
<li><a href='#scantwopermhk'><p>Permutation test for 2d genome scan by Haley-Knott regression</p></a></li>
<li><a href='#shiftmap'><p>Shift starting points in genetic maps</p></a></li>
<li><a href='#sim.cross'><p>Simulate a QTL experiment</p></a></li>
<li><a href='#sim.geno'><p>Simulate genotypes given observed marker data</p></a></li>
<li><a href='#sim.map'><p>Simulate a genetic map</p></a></li>
<li><a href='#simFounderSnps'><p>Simulate founder SNPs for a multiple-strain RIL</p></a></li>
<li><a href='#simPhyloQTL'><p>Simulate a set of intercrosses for a single diallelic QTL</p></a></li>
<li><a href='#simulatemissingdata'><p>Simulates missing genotype data</p></a></li>
<li><a href='#stepwiseqtl'><p>Stepwise selection for multiple QTL</p></a></li>
<li><a href='#strip.partials'><p>Strip partially informative genotypes</p></a></li>
<li><a href='#subset.cross'><p>Subsetting data for QTL experiment</p></a></li>
<li><a href='#subset.map'><p>Subsetting chromosomes for a genetic map</p></a></li>
<li><a href='#subset.scanone'><p>Subsetting the results of a genome scan</p></a></li>
<li><a href='#subset.scanoneperm'><p>Subsetting permutation test results</p></a></li>
<li><a href='#subset.scantwo'><p>Subsetting the results of a 2-d genome scan</p></a></li>
<li><a href='#subset.scantwoperm'><p>Subsetting two-dimensional permutation test results</p></a></li>
<li><a href='#summary.comparegeno'><p>Print pairs of individuals with similar genotype data.</p></a></li>
<li><a href='#summary.cross'><p>Print summary of QTL experiment</p></a></li>
<li><a href='#summary.fitqtl'><p>Summary of fit of qtl model</p></a></li>
<li><a href='#summary.qtl'><p>Print summary of a QTL object</p></a></li>
<li><a href='#summary.ripple'><p>Print summary of ripple results</p></a></li>
<li><a href='#summary.scanone'><p>Summarize the results of a genome scans</p></a></li>
<li><a href='#summary.scanoneboot'><p>Bootstrap confidence interval for QTL location</p></a></li>
<li><a href='#summary.scanoneperm'><p>LOD thresholds from scanone permutation results</p></a></li>
<li><a href='#summary.scanPhyloQTL'><p>Summarize the results a genome scan to map a QTL to a phylogenetic tree</p></a></li>
<li><a href='#summary.scantwo'><p>Summarize the results of a two-dimensional genome scan</p></a></li>
<li><a href='#summary.scantwoperm'><p>LOD thresholds from scantwo permutation results</p></a></li>
<li><a href='#summaryMap'><p>Print summary of a genetic map</p></a></li>
<li><a href='#summaryScantwoOld'><p>Summarize the results of a two-dimensional genome scan</p></a></li>
<li><a href='#switch.order'><p>Switch the order of markers on a chromosome</p></a></li>
<li><a href='#switchAlleles'><p>Switch alleles at selected markers</p></a></li>
<li><a href='#table2map'><p>Convert a table of marker positions to a map object.</p></a></li>
<li><a href='#top.errorlod'><p>List genotypes with large error LOD scores</p></a></li>
<li><a href='#totmar'><p>Determine the total number of markers</p></a></li>
<li><a href='#transformPheno'><p>Transformation of the phenotypes in a cross object</p></a></li>
<li><a href='#tryallpositions'><p>Test all possible positions for a marker</p></a></li>
<li><a href='#typingGap'><p>Maximum distance between genotyped markers</p></a></li>
<li><a href='#write.cross'><p>Write data for a QTL experiment to a file</p></a></li>
<li><a href='#xaxisloc.scanone'><p>Get x-axis locations in scanone plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.70</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Analyzing QTL Experiments</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hao Wu [aut],
  Gary Churchill <a href="https://orcid.org/0000-0001-9190-9284"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Saunak Sen <a href="https://orcid.org/0000-0003-4519-6361"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Danny Arends <a href="https://orcid.org/0000-0001-8738-0162"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Robert Corty [ctb],
  Timothee Flutre [ctb],
  Ritsert Jansen [ctb],
  Pjotr Prins <a href="https://orcid.org/0000-0002-8021-9162"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Lars Ronnegard [ctb],
  Rohan Shah [ctb],
  Laura Shannon [ctb],
  Quoc Tran [ctb],
  Aaron Wolen [ctb],
  Brian Yandell <a href="https://orcid.org/0000-0002-8774-9377"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  R Core Team [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of experimental crosses to identify genes
  (called quantitative trait loci, QTLs) contributing to variation in
  quantitative traits.
  Broman et al. (2003) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtg112">doi:10.1093/bioinformatics/btg112</a>&gt;.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Code for Brent's method for finding the root of a univariate
function was taken from R 2.15.1 (Copyright 1999, 2001 The R
Core Team)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, graphics, stats, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rqtl.org">https://rqtl.org</a>, <a href="https://github.com/kbroman/qtl">https://github.com/kbroman/qtl</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kbroman/qtl/issues">https://github.com/kbroman/qtl/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-21 11:19:33 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 02:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='A+20starting+20point'>Introductory comments on R/qtl</h2><span id='topic+qtl-package'></span>

<h3>Description</h3>

<p>A brief introduction to the R/qtl package, with a walk-through of an
analysis.
</p>


<h3>New to R and/or R/qtl?</h3>


<ul>
<li><p> In order to use the R/qtl package, you must type (within R)
<code>library(qtl)</code>.  You may wish to include this in a
<code><a href="base.html#topic+Startup">.Rprofile</a></code> file.
</p>
</li>
<li><p> Documention and several tutorials are available
at the R archive (<a href="https://cran.r-project.org">https://cran.r-project.org</a>).
</p>
</li>
<li><p> Use the <code><a href="utils.html#topic+help.start">help.start</a></code> function to start the
html version of the R help.
</p>
</li>
<li><p> Type <code>library(help=qtl)</code> to get a list of the functions
in R/qtl.
</p>
</li>
<li><p> Use the <code><a href="utils.html#topic+example">example</a></code> function to run examples
of the various functions in R/qtl.
</p>
</li>
<li><p> A tutorial on the use of R/qtl is distributed with the
package and is also available at <a href="https://rqtl.org/rqtltour.pdf">https://rqtl.org/rqtltour.pdf</a>.
</p>
</li>
<li><p> Download the latest version of R/qtl from the R archive or
from <a href="https://rqtl.org">https://rqtl.org</a>.
</p>
</li></ul>



<h3>Walk-through of an analysis</h3>

<p>Here we briefly describe the use of R/qtl to analyze an experimental
cross.  A more extensive tutorial on its use is distributed with the
package and is also available at <a href="https://rqtl.org/rqtltour.pdf">https://rqtl.org/rqtltour.pdf</a>.
</p>
<p>A difficult first step in the use of most data analysis software is the
import of data.  With R/qtl, one may import data in several different
formats by use of the function <code><a href="#topic+read.cross">read.cross</a></code>.  The
internal data structure used by R/qtl is rather complicated, and is
described in the help file for <code><a href="#topic+read.cross">read.cross</a></code>.  We won't
discuss data import any further here, except to say that the
comma-delimited format (<code>"csv"</code>) is recommended.  If you have
trouble importing data, send an email to Karl Broman,
<a href="mailto:broman@wisc.edu">broman@wisc.edu</a>, perhaps attaching examples of your data
files.  (Such data will be kept confidential.)  Also see the sample data
files and code at <a href="https://rqtl.org/sampledata/">https://rqtl.org/sampledata/</a>.
</p>
<p>We consider the example data <code><a href="#topic+hyper">hyper</a></code>, an experiment on
hypertension in the mouse, kindly provided
by Bev Paigen and Gary Churchill.  Use the <code><a href="utils.html#topic+data">data</a></code>
function to load the data.
</p>
<p><code>data(hyper)</code>
</p>
<p>The <code><a href="#topic+hyper">hyper</a></code> data set has class <code>"cross"</code>.  The
function <code><a href="#topic+summary.cross">summary.cross</a></code> gives summary information
on the data, and checks the data for internal consistency.  A number
of other utility functions are available; hopefully these are
self-explanatory.
</p>
<p><code>summary(hyper)</code> <br />
<code>nind(hyper)</code> <br />
<code>nphe(hyper)</code> <br />
<code>nchr(hyper)</code> <br />
<code>nmar(hyper)</code> <br />
<code>totmar(hyper)</code>
</p>
<p>The function <code><a href="#topic+plot.cross">plot.cross</a></code> gives a graphical summary of
the data; it calls <code><a href="#topic+plotMissing">plotMissing</a></code> (to plot a matrix
displaying missing genotypes) and <code><a href="#topic+plotMap">plotMap</a></code> (to plot
the genetic maps), and also displays histograms or barplots of the
phenotypes.  The <code><a href="#topic+plotMissing">plotMissing</a></code> function can plot
individuals ordered by their phenotypes; you can see that for most
markers, only individuals with extreme phenotypes were genotyped.
</p>
<p><code>plot(hyper)</code> <br />
<code>plotMissing(hyper)</code> <br />
<code>plotMissing(hyper, reorder=TRUE)</code> <br />
<code>plotMap(hyper)</code>
</p>
<p>Note that one marker (on chromosome 14) has no genotype data.  The
function <code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code> removes such markers from
the data.
</p>
<p><code>hyper &lt;- drop.nullmarkers(hyper)</code> <br />
<code>totmar(hyper)</code>
</p>
<p>The function <code><a href="#topic+est.rf">est.rf</a></code> estimates the recombination
fraction between each pair of markers, and calculates a LOD score for
the test of <code class="reqn">r</code> = 1/2.  This is useful for identifying markers that
are placed on the wrong chromosome.  Note that since, for these data,
many markers were typed only on recombinant individuals, the pairwise
recombination fractions show rather odd patterns.
</p>
<p><code>hyper &lt;- est.rf(hyper)</code> <br />
<code>plotRF(hyper)</code> <br />
<code>plotRF(hyper, chr=c(1,4))</code>
</p>
<p>To re-estimate the genetic map for an experimental cross, use the
function <code><a href="#topic+est.map">est.map</a></code>.  The function
<code><a href="#topic+plotMap">plotMap</a></code>, in addition to plotting a single map, can
plot the comparison of two genetic maps (as long as they are composed of
the same numbers of chromosomes and markers per chromosome).  The
function <code><a href="#topic+replace.map">replace.map</a></code> map be used to replace the
genetic map in a cross with a new one.
</p>
<p><code>newmap &lt;- est.map(hyper, error.prob=0.01, verbose=TRUE)</code> <br />
<code>plotMap(hyper, newmap)</code> <br />
<code>hyper &lt;- replace.map(hyper, newmap)</code>
</p>
<p>The function <code><a href="#topic+calc.errorlod">calc.errorlod</a></code> may be used to assist in
identifying possible genotyping errors; it calculates the error LOD
scores described by Lincoln and Lander (1992).  The
<code><a href="#topic+calc.errorlod">calc.errorlod</a></code> function return a modified version of
the input cross, with error LOD scores included.  The function
<code><a href="#topic+top.errorlod">top.errorlod</a></code> prints the genotypes with values above a
cutoff (by default, the cutoff is 4.0).
</p>
<p><code>hyper &lt;- calc.errorlod(hyper, error.prob=0.01)</code> <br />
<code>top.errorlod(hyper)</code>
</p>
<p>The function <code><a href="#topic+plotGeno">plotGeno</a></code> may be used to inspect the
observed genotypes for a chromosome, with likely genotyping errors
flagged.
</p>
<p><code>plotGeno(hyper, chr=16, ind=c(24:34, 71:81))</code>
</p>
<p>Before doing QTL analyses, some intermediate calculations need to be
performed.  The function <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> calculates
conditional genotype probabilities given the multipoint marker data.
<code><a href="#topic+sim.geno">sim.geno</a></code> simulates sequences of genotypes from their
joint distribution, given the observed marker data.
</p>
<p>As with <code><a href="#topic+calc.errorlod">calc.errorlod</a></code>, these functions return a
modified version of the input cross, with the intermediate calculations
included.  The <code>step</code> argument indicates the density of the grid on
which the calculations will be performed, and determines the density at
which LOD scores will be calculated.
</p>
<p><code>hyper &lt;- calc.genoprob(hyper, step=2.5, error.prob=0.01)</code> <br />
<code>hyper &lt;- sim.geno(hyper, step=2.5, n.draws=64, error.prob=0.01)</code>
</p>
<p>The function <code><a href="#topic+scanone">scanone</a></code> performs a genome scan with a
single QTL model.  By default, it performs standard interval mapping
(Lander and Botstein 1989): use of a normal model and the EM algorithm.
If one specifies <code>method="hk"</code>, Haley-Knott regression is performed
(Haley and Knott 1992).  These two methods require the results from
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code>.
</p>
<p><code>out.em &lt;- scanone(hyper)</code> <br />
<code>out.hk &lt;- scanone(hyper, method="hk")</code>
</p>
<p>If one specifies <code>method="imp"</code>, a genome scan is performed by the
multiple imputation method of Sen and Churchill (2001).  This method
requires the results from <code><a href="#topic+sim.geno">sim.geno</a></code>.
</p>
<p><code>out.imp &lt;- scanone(hyper, method="imp")</code>
</p>
<p>The output of <code><a href="#topic+scanone">scanone</a></code> is a data.frame with class
<code>"scanone"</code>.  The function <code><a href="#topic+plot.scanone">plot.scanone</a></code> may be
used to plot the results, and may plot up to three sets of results
against each other, as long as they conform appropriately.
</p>
<p><code>plot(out.em)</code> <br />
<code>plot(out.hk, col="blue", add=TRUE)</code> <br />
<code>plot(out.imp, col="red", add=TRUE)</code> <br />
<code>plot(out.hk, out.imp, out.em, chr=c(1,4), lty=1,</code> <br />
<code>     col=c("blue","red","black"))</code>
</p>
<p>The function <code><a href="#topic+summary.scanone">summary.scanone</a></code> may be used to list
information on the peak LOD for each chromosome for which the LOD
exceeds a specified threshold.
</p>
<p><code>summary(out.em)</code> <br />
<code>summary(out.em, threshold=3)</code> <br />
<code>summary(out.hk, threshold=3)</code> <br />
<code>summary(out.imp, threshold=3)</code>
</p>
<p>The function <code><a href="#topic+max.scanone">max.scanone</a></code> returns the maximum LOD
score, genome-wide.
</p>
<p><code>max(out.em)</code> <br />
<code>max(out.hk)</code> <br />
<code>max(out.imp)</code>
</p>
<p>One may also use <code><a href="#topic+scanone">scanone</a></code> to perform a permutation
test to get a genome-wide LOD significance threshold.
</p>
<p><code>operm.hk &lt;- scanone(hyper, method="hk", n.perm=1000)</code>
</p>
<p>The result has class <code>"scanoneperm"</code>.  The
<code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code> function may be used to calculate
LOD thresholds.
</p>
<p><code>summary(operm.hk, alpha=0.05)</code>
</p>
<p>The permutation results may also be used in the
<code><a href="#topic+summary.scanone">summary.scanone</a></code> function to calculate LOD thresholds
and genome-scan-adjusted p-values.
</p>
<p><code>summary(out.hk, perms=operm.hk, alpha=0.05, pvalues=TRUE)</code>
</p>
<p>We should say at this point that the function
<code><a href="base.html#topic+save">save.image</a></code> will save your workspace to disk.  You'll
wish you had used this if R crashes.
</p>
<p><code>save.image()</code>
</p>
<p>The function <code><a href="#topic+scantwo">scantwo</a></code> performs a two-dimensional
genome scan with a two-QTL model.  Methods <code>"em"</code>, <code>"hk"</code> and
<code>"imp"</code> are all available.  <code><a href="#topic+scantwo">scantwo</a></code> is
considerably slower than <code><a href="#topic+scanone">scanone</a></code>, and can require a
great deal of memory.  Thus, you may wish to re-run
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> and/or <code><a href="#topic+sim.geno">sim.geno</a></code> with
a more coarse grid.
</p>
<p><code>hyper &lt;- calc.genoprob(hyper, step=10, err=0.01)</code> <br />
<code>hyper &lt;- sim.geno(hyper, step=10, n.draws=64, err=0.01)</code> <br />
<br />
<code>out2.hk &lt;- scantwo(hyper, method="hk")</code> <br />
<code>out2.em &lt;- scantwo(hyper)</code> <br />
<code>out2.imp &lt;- scantwo(hyper, method="imp")</code>
</p>
<p>The output is an object with class <code>scantwo</code>.  The function
<code><a href="#topic+plot.scantwo">plot.scantwo</a></code> may be used to plot the results.  The
upper triangle contains LOD scores for tests of epistasis, while the
lower triangle contains LOD scores for the full model.
</p>
<p><code>plot(out2.hk)</code> <br />
<code>plot(out2.em)</code> <br />
<code>plot(out2.imp)</code>
</p>
<p>The function <code><a href="#topic+summary.scantwo">summary.scantwo</a></code> lists the interesting
aspects of the output.  For each pair of chromosomes <code class="reqn">(k,l)</code>, it
calculates the maximum LOD score for the full model, <code class="reqn">M_f(k,l)</code>; a
LOD score indicating evidence for a second QTL, allowing for epistasis),
<code class="reqn">M_{fv1}(k,l)</code>; a LOD score indicating evidence for
epistasis, <code class="reqn">M_i(k,l)</code>; the LOD score for the additive QTL model,
<code class="reqn">M_a(k,l)</code>; and a LOD score indicating evidence for a second QTL,
assuming no epistasis, <code class="reqn">M_{av1}(k,l)</code>.
</p>
<p>You must provide five LOD thresholds, corresponding to the above five
LOD scores, and in that order.  A chromosome pair is printed if either
(a) <code class="reqn">M_f(k,l) \ge T_f</code> and (<code class="reqn">M_{fv1}(k,l) \ge
  T_{fv1}</code> or <code class="reqn">M_i(k,l) \ge
  T_i</code>), or (b)
<code class="reqn">M_a(k,l) \ge T_a</code> and <code class="reqn">M_{av1}(k,l) \ge
  T_{av1}</code>.
</p>
<p><code>summary(out2.em, thresholds=c(6.2, 5.0, 4.6, 4.5, 2.3))</code> <br />
<code>summary(out2.em, thresholds=c(6.2, 5.0, Inf, 4.5, 2.3))</code>
</p>
<p>In the latter case, the interaction LOD score will be ignored.
</p>
<p>The function <code><a href="#topic+max.scantwo">max.scantwo</a></code> returns the maximum joint
and additive LODs for a two-dimensional genome scan.
</p>
<p><code>max(out2.em)</code>
</p>
<p>Permutation tests may also performed with <code><a href="#topic+scantwo">scantwo</a></code>;
it may take a few days of CPU time.  The output is a list containing the
maxima of the above five LOD scores for each of the imputations.
</p>
<p><code>operm2 &lt;- scantwo(hyper, method="hk", n.perm=100)</code> <br />
<code>summary(operm2, alpha=0.05)</code>
</p>


<h3>Citing R/qtl</h3>

<p>To cite R/qtl in publications, use the Broman et al. (2003) reference
listed below.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Broman, K. W. and Sen,
&#346;. (2009) <em>A
guide to QTL mapping with R/qtl.</em>  Springer.  <a href="https://rqtl.org/book/">https://rqtl.org/book/</a>
</p>
<p>Broman, K. W., Wu, H., Sen, &#346;. and Churchill, G. A. (2003) R/qtl: QTL
mapping in experimental crosses.  <em>Bioinformatics</em> <b>19</b>,
889&ndash;890.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Lander, E. S. and Botstein, D. (1989) Mapping Mendelian factors underlying
quantitative traits using RFLP linkage maps.  <em>Genetics</em>
<b>121</b>, 185&ndash;199.
</p>
<p>Lincoln, S. E. and Lander, E. S. (1992) Systematic detection of
errors in genetic linkage data.  <em>Genomics</em> <b>14</b>, 604&ndash;610.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>

<hr>
<h2 id='add.cim.covar'>Indicate marker covariates from composite interval mapping</h2><span id='topic+add.cim.covar'></span>

<h3>Description</h3>

<p>Add dots at the locations of the selected marker covariates, for a
plot of composite interval mapping results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.cim.covar(cimresult, chr, gap=25, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.cim.covar_+3A_cimresult">cimresult</code></td>
<td>
<p>Composite interval mapping results, as output from
<code><a href="#topic+cim">cim</a></code>.</p>
</td></tr>
<tr><td><code id="add.cim.covar_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to plot. (The
chromosomes must be specified by name.)  This should be identical to
that used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="add.cim.covar_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM). This should be identical to
that used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="add.cim.covar_+3A_...">...</code></td>
<td>
<p>Additional plot arguments, passed to the function
<code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One must first have used the function <code><a href="#topic+plot.scanone">plot.scanone</a></code>
to plot the composite interval mapping results.
</p>
<p>The arguments <code>chr</code> and <code>gap</code> must be identical to the
values used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.
</p>
<p>Dots indicating the locations of the selected marker covariates are
displayed on the x-axis.  (By default, solid red circles are plotted;
this may be modified by specifying the graphics parameters <code>pch</code> and
<code>col</code>.)
</p>


<h3>Value</h3>

<p>A data frame indicating the marker covariates that were plotted.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+cim">cim</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(hyper)
hyper &lt;- calc.genoprob(hyper, step=2.5)

out &lt;- scanone(hyper)
out.cim &lt;- cim(hyper, n.marcovar=3)
plot(out, out.cim, chr=c(1,4,6,15), col=c("blue", "red"))

add.cim.covar(out.cim, chr=c(1,4,6,15))
## End(Not run)
</code></pre>

<hr>
<h2 id='add.threshold'>Add significance threshold to plot</h2><span id='topic+add.threshold'></span>

<h3>Description</h3>

<p>Add a significance threshold to a plot created by
<code><a href="#topic+plot.scanone">plot.scanone</a></code>), using the permutation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.threshold(out, chr, perms, alpha=0.05, lodcolumn=1, gap=25, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.threshold_+3A_out">out</code></td>
<td>
<p>An object of class <code>"scanone"</code>, as output by
<code><a href="#topic+scanone">scanone</a></code>.  This must be identical to what was used
in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to plot. If a
selected subset of chromosomes were plotted, they must be specified
here.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_perms">perms</code></td>
<td>
<p>Permutation results from <code><a href="#topic+scanone">scanone</a></code>, used
to calculate the significance threshold.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the threshold.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer indicating which
of column in the permutation results should be used.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).  This must be identical
to what was used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="add.threshold_+3A_...">...</code></td>
<td>
<p>Passed to the function <code><a href="graphics.html#topic+abline">abline</a></code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to add a horizontal line at the significance
threshold to genome scan results plotted by
<code><a href="#topic+plot.scanone">plot.scanone</a></code>.
</p>
<p>The arguments <code>out</code>, <code>chr</code>, and <code>gap</code> must match what
was used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.
</p>
<p>The argument <code>perms</code> must be specified.  If X-chromosome-specific
permutations were performed (via the argument <code>perm.Xsp</code> in the
call to <code><a href="#topic+scanone">scanone</a></code>), separate thresholds will be
plotted for the autosomes and the X chromosome.  These are calculated
via the <code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code> function.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>, <code><a href="#topic+xaxisloc.scanone">xaxisloc.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper &lt;- calc.genoprob(hyper)
out &lt;- scanone(hyper, method="hk")
operm &lt;- scanone(hyper, method="hk", n.perm=100, perm.Xsp=TRUE)

plot(out, chr=c(1,4,6,15,"X"))
add.threshold(out, chr=c(1,4,6,15,"X"), perms=operm, alpha=0.05)
add.threshold(out, chr=c(1,4,6,15,"X"), perms=operm, alpha=0.1,
              col="green", lty=2)
</code></pre>

<hr>
<h2 id='addcovarint'>Add QTL x covariate interaction to a multiple-QTL model</h2><span id='topic+addcovarint'></span>

<h3>Description</h3>

<p>Try adding all QTL x covariate interactions, one at a time, to a
multiple QTL model, for a given set of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addcovarint(cross, pheno.col=1, qtl, covar=NULL, icovar, formula,
            method=c("imp","hk"), model=c("normal", "binary"),
            verbose=TRUE, pvalues=TRUE, simple=FALSE, tol=1e-4,
            maxit=1000, require.fullrank=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addcovarint_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>, as output from
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_icovar">icovar</code></td>
<td>
<p>Vector of character strings indicating the columns in
<code>covar</code> to be considered for QTL x covariate interactions.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are referred to as
<code>Q1</code>, <code>Q2</code>, etc.  Covariates are referred to by their names
in the data frame <code>covar</code>.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, will print a message if there are no
interactions to test.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_pvalues">pvalues</code></td>
<td>
<p>If FALSE, p-values will not be included in the results.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_simple">simple</code></td>
<td>
<p>If TRUE, don't include p-values or sums of squares in the summary.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="addcovarint_+3A_require.fullrank">require.fullrank</code></td>
<td>
<p>If TRUE, give LOD=0 when covariate matrix in
the linear regression is not of full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect must also
be included.
</p>


<h3>Value</h3>

<p>An object of class <code>addcovarint</code>, with results as in the
drop-one-term analysis from <code><a href="#topic+fitqtl">fitqtl</a></code>.  This is a data
frame (given class <code>"addcovarint"</code>, with the following columns:
degrees of freedom (df), Type III sum of squares (Type III
SS), LOD score(LOD), percentage of variance explained (%var), F
statistics (F value),  and P values for chi square (Pvalue(chi2))
and F distribution (Pvalue(F)).
</p>
<p>Note that the degree of freedom, Type III sum of squares, the LOD
score and the percentage of variance explained are the values
comparing the full to the sub-model with the term dropped. Also note
that for imputation method, the percentage of variance explained, the
the F values and the P values are approximations calculated from the
LOD score.
</p>
<p>QTL x covariate interactions already included in the input <code>formula</code> are
not tested.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+addint">addint</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+addqtl">addqtl</a></code>, <code><a href="#topic+addpair">addpair</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 8, 13)
qp &lt;- c(26, 56, 28)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

# use the sex phenotype as the covariate
covar &lt;- data.frame(sex=fake.f2$pheno$sex)

# try all possible QTL x sex interactions, one at a time
addcovarint(fake.f2, pheno.col=1, qtl, covar, "sex", y~Q1+Q2+Q3,
            method="hk")
</code></pre>

<hr>
<h2 id='addint'>Add pairwise interaction to a multiple-QTL model</h2><span id='topic+addint'></span>

<h3>Description</h3>

<p>Try adding all possible pairwise interactions, one at a time, to a
multiple QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addint(cross, pheno.col=1, qtl, covar=NULL, formula, method=c("imp","hk"),
       model=c("normal", "binary"), qtl.only=FALSE, verbose=TRUE,
       pvalues=TRUE, simple=FALSE, tol=1e-4, maxit=1000, require.fullrank=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addint_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addint_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="addint_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>, as output from
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="addint_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="addint_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are referred to as
<code>Q1</code>, <code>Q2</code>, etc.  Covariates are referred to by their names
in the data frame <code>covar</code>.  If the new QTL is not included in
the formula, its main effect is added.</p>
</td></tr>
<tr><td><code id="addint_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="addint_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="addint_+3A_qtl.only">qtl.only</code></td>
<td>
<p>If TRUE, only test QTL:QTL interactions (and not
interactions with covariates).</p>
</td></tr>
<tr><td><code id="addint_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, will print a message if there are no
interactions to test.</p>
</td></tr>
<tr><td><code id="addint_+3A_pvalues">pvalues</code></td>
<td>
<p>If FALSE, p-values will not be included in the results.</p>
</td></tr>
<tr><td><code id="addint_+3A_simple">simple</code></td>
<td>
<p>If TRUE, don't include p-values or sums of squares in the summary.</p>
</td></tr>
<tr><td><code id="addint_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="addint_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="addint_+3A_require.fullrank">require.fullrank</code></td>
<td>
<p>If TRUE, give LOD=0 when covariate matrix in
the linear regression is not of full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect must also
be included.
</p>


<h3>Value</h3>

<p>An object of class <code>addint</code>, with results as in the
drop-one-term analysis from <code><a href="#topic+fitqtl">fitqtl</a></code>.  This is a data
frame (given class <code>"addint"</code>, with the following columns:
degrees of freedom (df), Type III sum of squares (Type III
SS), LOD score(LOD), percentage of variance explained (%var), F
statistics (F value),  and P values for chi square (Pvalue(chi2))
and F distribution (Pvalue(F)).
</p>
<p>Note that the degree of freedom, Type III sum of squares, the LOD
score and the percentage of variance explained are the values
comparing the full to the sub-model with the term dropped. Also note
that for imputation method, the percentage of variance explained, the
the F values and the P values are approximations calculated from the
LOD score.
</p>
<p>Pairwise interactions already included in the input <code>formula</code> are
not tested.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+addcovarint">addcovarint</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+addqtl">addqtl</a></code>, <code><a href="#topic+addpair">addpair</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 8, 13)
qp &lt;- c(26, 56, 28)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

# try all possible pairwise interactions, one at a time
addint(fake.f2, pheno.col=1, qtl, formula=y~Q1+Q2+Q3, method="hk")
</code></pre>

<hr>
<h2 id='addloctocross'>Add phenotype location into a cross object</h2><span id='topic+addloctocross'></span>

<h3>Description</h3>

<p>Add phenotype location(s) into a cross object
(with eQTL/pQTL studies)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    addloctocross(cross, locations=NULL, locfile="locations.txt", verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addloctocross_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="addloctocross_+3A_locations">locations</code></td>
<td>
<p>R variable holding location information</p>
</td></tr>
<tr><td><code id="addloctocross_+3A_locfile">locfile</code></td>
<td>
<p> load from a file, see the details section for the layout of the file.</p>
</td></tr>
<tr><td><code id="addloctocross_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give verbose output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>inputfile layout:
Num	Name	Chr	cM
1	X3.Hydroxypropyl	4	50.0
Num is the number of the phenotype in the cross object
Name is the name of the phenotype (will be checked against the name already in the cross object at position num
Chr Chromosome
cM	position from start of chromosome in cM
</p>


<h3>Value</h3>

<p>The input cross object, with the locations added as an additional component <code>locations</code>
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mqmplot.cistrans">mqmplot.cistrans</a></code> - Cis/trans plot
</p>
</li>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(multitrait)
    data(locations)
    multiloc &lt;- addloctocross(multitrait,locations)
    results &lt;- scanall(multiloc)
    mqmplot.cistrans(results, multiloc, 5, FALSE, TRUE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='addmarker'>Add a marker to a cross</h2><span id='topic+addmarker'></span>

<h3>Description</h3>

<p>Add a marker to a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addmarker(cross, genotypes, markername, chr, pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addmarker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addmarker_+3A_genotypes">genotypes</code></td>
<td>
<p>Vector of numeric genotypes.</p>
</td></tr>
<tr><td><code id="addmarker_+3A_markername">markername</code></td>
<td>
<p>Marker name as character string.</p>
</td></tr>
<tr><td><code id="addmarker_+3A_chr">chr</code></td>
<td>
<p>Chromosome ID as character string.</p>
</td></tr>
<tr><td><code id="addmarker_+3A_pos">pos</code></td>
<td>
<p>Position of marker, as numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function with caution.  It would be best to incorporate new
data into a single file to be imported with <code><a href="#topic+read.cross">read.cross</a></code>.
</p>
<p>But if you have genotypes on one or two additional markers that you
want to add, you might load them with <code><a href="utils.html#topic+read.csv">read.csv</a></code>
and incorporate them with this function.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object with the single marker added.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.markers">pull.markers</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# genotypes for new marker
gi &lt;- pull.geno(fill.geno(fake.f2))[,"D5M197"]

# add marker to cross
fake.f2 &lt;- addmarker(fake.f2, gi, "D5M197imp", "5", 11)
</code></pre>

<hr>
<h2 id='addpair'>Scan for an additional pair of QTL in a multiple-QTL model</h2><span id='topic+addpair'></span>

<h3>Description</h3>

<p>Scan for an additional pair of QTL in the context of a
multiple QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addpair(cross, chr, pheno.col=1, qtl, covar=NULL, formula,
        method=c("imp","hk"), model=c("normal", "binary"),
        incl.markers=FALSE, verbose=TRUE, tol=1e-4, maxit=1000,
        forceXcovar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addpair_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addpair_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to be scanned. If
missing, all chromosomes are scanned. Refer to chromosomes by
name. Refer to chromosomes with a preceding <code>-</code> to have all
chromosomes but those considered.  A logical (TRUE/FALSE) vector may
also be used.</p>
</td></tr>
<tr><td><code id="addpair_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="addpair_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>, as output from
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="addpair_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="addpair_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are referred to as
<code>Q1</code>, <code>Q2</code>, etc.  Covariates are referred to by their names
in the data frame <code>covar</code>.  If the new QTL are not included in
the formula, a two-dimensional scan as in <code><a href="#topic+scantwo">scantwo</a></code>
is performed.</p>
</td></tr>
<tr><td><code id="addpair_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="addpair_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="addpair_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.  If <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> or
<code><a href="#topic+sim.geno">sim.geno</a></code> were run with
<code>stepwidth="variable"</code> or <code>stepwidth="max"</code>, we force <code>incl.markers=TRUE</code>.</p>
</td></tr>
<tr><td><code id="addpair_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of
calculations.  If <code>verbose</code> is an integer &gt; 1, further messages
from <code><a href="#topic+scanqtl">scanqtl</a></code> are also displayed.</p>
</td></tr>
<tr><td><code id="addpair_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="addpair_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="addpair_+3A_forcexcovar">forceXcovar</code></td>
<td>
<p>If TRUE, force inclusion of X-chr-related covariates
(like sex and cross direction).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect must also
be included.
</p>
<p>If neither of the two new QTL are indicated in the <code>formula</code>, we
perform a two-dimensional scan as in <code><a href="#topic+scantwo">scantwo</a></code>.  That
is, for each pair of QTL positions, we fit two models: two
additive QTL added to the <code>formula</code>, and two interacting QTL
added to the <code>formula</code>.
</p>
<p>If the both of the new QTL are indicated in the <code>formula</code>, that
particular model is fit, with the positions of the new QTL allowed to
vary across the genome.  If just one of the QTL is indicated in the
<code>formula</code>, a main effect for the other is added, and that
particular model is fit, again with the positions of both QTL varying.
Note that in this case the LOD scores are not analogous to those
produced by <code><a href="#topic+scantwo">scantwo</a></code>.  Thus, there slightly modified forms
for the plots (produced by <code><a href="#topic+plot.scantwo">plot.scantwo</a></code>) and
summaries (produced by <code><a href="#topic+summary.scantwo">summary.scantwo</a></code> and
<code><a href="#topic+max.scantwo">max.scantwo</a></code>).  In the plot, the x-axis is to be
interpreted as the position of the first of the new QTL, and the
y-axis is to be interpreted as the position of the second of the new
QTL.  In the summaries, we give the single best pair of positions on
each pair of chromosomes, and give LOD scores comparing that pair of
positions to the base model (without each of these QTL), and to the
base model plus one additional QTL on one or the other of the chromosomes.
</p>


<h3>Value</h3>

<p>An object of class <code>scantwo</code>, as produced by
<code><a href="#topic+scantwo">scantwo</a></code>.
</p>
<p>If neither of the new QTL were indicated
in the <code>formula</code>, the result is just as in
<code><a href="#topic+scantwo">scantwo</a></code>, though with LOD scores relative to the
base model (omitting the new QTL).
</p>
<p>Otherwise, the results are contained in what would ordinarily be in
the full and additive LOD scores, with the additive LOD scores
corresponding to the case that the first of the new QTL is to the left
of the second of the new QTL, and the full LOD scores corresponding to
the case that the first of the new QTL is to the right of the second
of the new QTL.  Because the structure of the LOD scores in this
case is different from those output by <code><a href="#topic+scantwo">scantwo</a></code>, we
include, in this case, an attribute <code>"addpair"=TRUE</code>.  (We also
require results of single-dimensional scans, omitting each of the two
new QTL from the formula, one at a time; these are included as
attributes <code>"lod.minus1"</code> and <code>"lod.minus2"</code>.)  The
results are then treated somewhat differently by
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code>, <code><a href="#topic+max.scantwo">max.scantwo</a></code>,
and <code><a href="#topic+plot.scantwo">plot.scantwo</a></code>.  See the Details section.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+addint">addint</a></code>, <code><a href="#topic+addqtl">addqtl</a></code>,
<code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+addtoqtl">addtoqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># A totally contrived example to show some of what you can do

# simulate backcross data with 3 chromosomes (names "17", "18", "19")
#   one QTL on chr 17 at 40 cM
#   one QTL on chr 18 at 30 cM
#   two QTL on chr 19, at 10 and 40 cM
data(map10)
model &lt;- rbind(c(1,40,0), c(2,30,0), c(3,10,0), c(3,40,0))
## Not run: fakebc &lt;- sim.cross(map10[17:19], model=model, type="bc", n.ind=250)


# het at QTL on 17 and 1st QTL on 19 increases phenotype by 1 unit
# het at QTL on 18 and 2nd QTL on 19 decreases phenotype by 1 unit
qtlgeno &lt;- fakebc$qtlgeno
phe &lt;- rnorm(nind(fakebc))
w &lt;- qtlgeno[,1]==2 &amp; qtlgeno[,3]==2
phe[w] &lt;- phe[w] + 1
w &lt;- qtlgeno[,2]==2 &amp; qtlgeno[,4]==2
phe[w] &lt;- phe[w] - 1
fakebc$pheno[,1] &lt;- phe

## Not run: fakebc &lt;- calc.genoprob(fakebc, step=2, err=0.001)


# base model has QTLs on chr 17 and 18
qtl &lt;- makeqtl(fakebc, chr=c("17", "18"), pos=c(40,30), what="prob")

# scan for an additional pair of QTL, one interacting with the locus
#     on 17 and one interacting with the locus on 18
out.ap &lt;- addpair(fakebc, qtl=qtl, formula = y~Q1*Q3 + Q2*Q4, method="hk")

max(out.ap)
summary(out.ap)
plot(out.ap)
</code></pre>

<hr>
<h2 id='addqtl'>Scan for an additional QTL in a multiple-QTL model</h2><span id='topic+addqtl'></span>

<h3>Description</h3>

<p>Scan for an additional QTL in the context of a
multiple QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addqtl(cross, chr, pheno.col=1, qtl, covar=NULL, formula,
       method=c("imp","hk"), model=c("normal", "binary"),
       incl.markers=TRUE, verbose=FALSE, tol=1e-4, maxit=1000,
       forceXcovar=FALSE, require.fullrank=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to be scanned. If
missing, all chromosomes are scanned. Refer to chromosomes by
name. Refer to chromosomes with a preceding <code>-</code> to have all
chromosomes but those considered.  A logical (TRUE/FALSE) vector may
also be used.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>, as output from
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are referred to as
<code>Q1</code>, <code>Q2</code>, etc.  Covariates are referred to by their names
in the data frame <code>covar</code>.  If the new QTL is not included in
the formula, its main effect is added.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="addqtl_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.  If <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> or
<code><a href="#topic+sim.geno">sim.geno</a></code> were run with
<code>stepwidth="variable"</code> or <code>stepwidth="max"</code>, we force <code>incl.markers=TRUE</code>.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of
calculations.  If <code>verbose</code> is an integer &gt; 1, further messages
from <code><a href="#topic+scanqtl">scanqtl</a></code> are also displayed.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="addqtl_+3A_forcexcovar">forceXcovar</code></td>
<td>
<p>If TRUE, force inclusion of X-chr-related covariates
(like sex and cross direction).</p>
</td></tr>
<tr><td><code id="addqtl_+3A_require.fullrank">require.fullrank</code></td>
<td>
<p>If TRUE, give LOD=0 when covariate matrix in
the linear regression is not of full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect must also
be included.
</p>
<p>If one wishes to scan for QTL that interact with another QTL, include
it in the formula (with an index of one more than the number of QTL in
the input <code>qtl</code> object).
</p>


<h3>Value</h3>

<p>An object of class <code>scanone</code>, as produced by the
<code><a href="#topic+scanone">scanone</a></code> function.  LOD scores are relative to the
base model (with any terms that include the new QTL omitted).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+addtoqtl">addtoqtl</a></code>,
<code><a href="#topic+addpair">addpair</a></code>, <code><a href="#topic+addint">addint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 8, 13)
qp &lt;- c(26, 56, 28)

fake.f2 &lt;- subset(fake.f2, chr=c(1,2,3,8,13))


fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

# scan for an additional QTL
out1 &lt;- addqtl(fake.f2, qtl=qtl, formula=y~Q1+Q2+Q3, method="hk")
max(out1)

# scan for an additional QTL that interacts with the locus on chr 1
out2 &lt;- addqtl(fake.f2, qtl=qtl, formula=y~Q1*Q4+Q2+Q3, method="hk")
max(out2)

# plot interaction LOD scores
plot(out2-out1)
</code></pre>

<hr>
<h2 id='addtoqtl'>Add to a qtl object</h2><span id='topic+addtoqtl'></span>

<h3>Description</h3>

<p>Add a QTL or multiple QTL to a qtl object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addtoqtl(cross, qtl, chr, pos, qtl.name, drop.lod.profile=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addtoqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="addtoqtl_+3A_qtl">qtl</code></td>
<td>
<p>The qtl object to which additional QTL are to be added.</p>
</td></tr>
<tr><td><code id="addtoqtl_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosome for each new QTL. (These
should be character strings referring to the chromosomes by name.)</p>
</td></tr>
<tr><td><code id="addtoqtl_+3A_pos">pos</code></td>
<td>
<p>Vector (of same length as <code>chr</code>) indicating the
positions on the chromosome for each new QTL. If there is no marker or
pseudomarker at a position, the nearest position is used.</p>
</td></tr>
<tr><td><code id="addtoqtl_+3A_qtl.name">qtl.name</code></td>
<td>
<p>Optional user-specified name for each new QTL, used in the
drop-one-term ANOVA table in <code><a href="#topic+fitqtl">fitqtl</a></code>.
If unspecified, the names will be of the form <code>"Chr1@10"</code> for a
QTL on Chromsome 1 at 10 cM.</p>
</td></tr>
<tr><td><code id="addtoqtl_+3A_drop.lod.profile">drop.lod.profile</code></td>
<td>
<p>If TRUE, remove any LOD profiles from the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtl</code>, just like the input <code>qtl</code> object,
but with additional QTL added.  See <code><a href="#topic+makeqtl">makeqtl</a></code> for
details.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>, <code><a href="#topic+replaceqtl">replaceqtl</a></code>,
<code><a href="#topic+reorderqtl">reorderqtl</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 6, 13)
qp &lt;- c(25.8, 33.6, 18.63)


fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")
qtl &lt;- addtoqtl(fake.f2, qtl, 14, 35)
</code></pre>

<hr>
<h2 id='allchrsplits'>Test all possible splits of a chromosome into two pieces</h2><span id='topic+allchrsplits'></span>

<h3>Description</h3>

<p>In order to assess the support for a linkage group, this function
splits the linkage groups into two pieces at each interval and in each
case calculates a LOD score comparing the combined linkage group to
the two pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allchrsplits(cross, chr, error.prob=0.0001,
                map.function=c("haldane","kosambi","c-f","morgan"),
                m=0, p=0, maxit=4000, tol=1e-6, sex.sp=TRUE,
                verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allchrsplits_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_chr">chr</code></td>
<td>
<p>A vector specifying which chromosomes to study.
This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions. (Ignored if m &gt; 0.)</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_m">m</code></td>
<td>
<p>Interference parameter for the chi-square model for
interference; a non-negative integer, with m=0 corresponding to no
interference. This may be used only for a backcross or intercross.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata from the NI mechanism, in the Stahl
model; p=0 gives a pure chi-square model.  This may be used only for
a backcross or intercross.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="allchrsplits_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information on progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (actually, an object of class <code>"scanone"</code>, so that
one may use <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, etc.) with each row being an interval
at which a split is made.
The first two columns are the chromosome ID and midpoint of the interval.  The third
column is a LOD score comparing the combined linkage group to the
split into two linkage groups.  A fourth column (<code>gap</code>) indicates the length of
each interval.
</p>
<p>The row names indicate the flanking markers for each interval.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+ripple">ripple</a></code>,
<code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+switch.order">switch.order</a></code>,
<code><a href="#topic+movemarker">movemarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
allchrsplits(fake.bc, 7, error.prob=0, verbose=FALSE)
</code></pre>

<hr>
<h2 id='argmax.geno'>Reconstruct underlying genotypes</h2><span id='topic+argmax.geno'></span>

<h3>Description</h3>

<p>Uses the Viterbi algorithm to identify the most likely sequence
of underlying genotypes, given the observed multipoint marker data,
with possible allowance for genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argmax.geno(cross, step=0, off.end=0, error.prob=0.0001,
            map.function=c("haldane","kosambi","c-f","morgan"),
            stepwidth=c("fixed", "variable", "max"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argmax.geno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="argmax.geno_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which the
genotypes are reconstructed, though for <code>step=0</code>, genotypes
are reconstructed only at the marker locations.</p>
</td></tr>
<tr><td><code id="argmax.geno_+3A_off.end">off.end</code></td>
<td>
<p>Distance (in cM) past the terminal markers on each
chromosome to which the genotype reconstructions will be carried.</p>
</td></tr>
<tr><td><code id="argmax.geno_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="argmax.geno_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="argmax.geno_+3A_stepwidth">stepwidth</code></td>
<td>
<p>Indicates whether the intermediate points should with
fixed or variable step sizes.  We recommend using
<code>"fixed"</code>; <code>"variable"</code> was included for the qtlbim
package (<a href="https://cran.r-project.org/src/contrib/Archive/qtlbim/">https://cran.r-project.org/src/contrib/Archive/qtlbim/</a>).  The <code>"max"</code>
option inserts the minimal number of intermediate points so that the
maximum distance between points is <code>step</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use the Viterbi algorithm to calculate
<code class="reqn">\arg \max_v \Pr(g = v | O)</code> where
<code class="reqn">g</code> is the underlying sequence of genotypes and <code class="reqn">O</code> is the
observed marker genotypes.
</p>
<p>This is done by calculating
<code class="reqn">\gamma_k(v_k) = \max_{v_1, \ldots, v_{k-1}} \Pr(g_1 = v_1,
    \ldots, g_k = v_k, O_1, \ldots, O_k)</code>
for <code class="reqn">k = 1, \ldots, n</code> and then tracing back through the
sequence.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component,
<code>argmax</code>, added to each component of <code>cross$geno</code>.
The <code>argmax</code> component is a matrix of size [n.ind x n.pos], where
n.pos is the
number of positions at which the reconstructed genotypes were obtained,
containing the most likely sequences of underlying genotypes.
Attributes <code>"error.prob"</code>, <code>"step"</code>, and <code>"off.end"</code>
are set to the values of the corresponding arguments, for later
reference.
</p>


<h3>Warning</h3>

<p>The Viterbi algorithm can behave badly when <code>step</code> is small but
positive. One may observe quite different results for different values
of <code>step</code>.
</p>
<p>The problem is that, in the presence of data like <code>A----H</code>,  the
sequences <code>AAAAAA</code> and <code>HHHHHH</code> may be more likely than any
one of the sequences <code>AAAAAH</code>, <code>AAAAHH</code>, <code>AAAHHH</code>,
<code>AAHHHH</code>, <code>AHHHHH</code>, <code>AAAAAH</code>.  The Viterbi algorithm
produces a single &quot;most likely&quot; sequence of underlying genotypes.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Lange, K. (1999) <em>Numerical analysis for statisticians</em>.
Springer-Verlag. Sec 23.3.
</p>
<p>Rabiner, L. R. (1989) A tutorial on hidden Markov models and selected
applications in speech recognition.  <em>Proceedings of the IEEE</em>
<b>77</b>, 257&ndash;286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+fill.geno">fill.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- argmax.geno(fake.f2, step=2, off.end=5, err=0.01)
</code></pre>

<hr>
<h2 id='arithscan'>Arithmetic operators for scanone and scantwo results</h2><span id='topic++2B.scanone'></span><span id='topic+-.scanone'></span><span id='topic++2B.scantwo'></span><span id='topic+-.scantwo'></span>

<h3>Description</h3>

<p>Add or subtract LOD scores in results
from <code><a href="#topic+scanone">scanone</a></code> or <code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1+scan2
scan1-scan2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arithscan_+3A_scan1">scan1</code>, <code id="arithscan_+3A_scan2">scan2</code></td>
<td>
<p>Genome scan results on the same set of chromosomes
and markers, as output by <code><a href="#topic+scanone">scanone</a></code> or <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used to calculate the sum or difference of LOD scores of two
genome scan results.  It is particularly useful for calculating the LOD
scores for QTL-by-covariate interactions (see the example, below).
Note that the degrees of freedom are also added or subtracted.
</p>


<h3>Value</h3>

<p>The same type of data structure as the input objects, with LOD scores
added or subtracted.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)

# covariates
ac &lt;- pull.pheno(fake.bc, c("sex","age"))
ic &lt;- pull.pheno(fake.bc, "sex")

# scan with additive but not the interactive covariate
out.acovar &lt;- scanone(fake.bc, addcovar=ac)

# scan with interactive covariate
out.icovar &lt;- scanone(fake.bc, addcovar=ac, intcovar=ic)

# plot the difference of with and without the interactive covariate
#     This is a LOD score for a test of QTL x covariate interaction
plot(out.icovar-out.acovar)
</code></pre>

<hr>
<h2 id='arithscanperm'>Arithmetic Operators for permutation results</h2><span id='topic++2B.scanoneperm'></span><span id='topic+-.scanoneperm'></span><span id='topic++2B.scantwoperm'></span><span id='topic+-.scantwoperm'></span>

<h3>Description</h3>

<p>Add or subtract LOD scores in permutation results from
<code><a href="#topic+scanone">scanone</a></code> or <code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm1+perm2
perm1-perm2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arithscanperm_+3A_perm1">perm1</code>, <code id="arithscanperm_+3A_perm2">perm2</code></td>
<td>
<p>Permutation results from
<code><a href="#topic+scanone">scanone</a></code> or <code><a href="#topic+scantwo">scantwo</a></code>, on the
same set of chromosomes and markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used to calculate the sum or difference of LOD scores of two
sets of permutation results from <code><a href="#topic+scanone">scanone</a></code> or
<code><a href="#topic+scantwo">scantwo</a></code>.  One must be careful to ensure that the
permutations are perfectly linked, which
will require the use of <code><a href="base.html#topic+Random">set.seed</a></code>.
</p>


<h3>Value</h3>

<p>The same data structure as the input objects, with LOD scores
added or subtracted.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)

# covariates
ac &lt;- pull.pheno(fake.bc, c("sex","age"))
ic &lt;- pull.pheno(fake.bc, "sex")

# set seed
theseed &lt;- round(runif(1, 1, 10^8))
set.seed(theseed)

# permutations with additive but not the interactive covariate
## Not run: operm.acovar &lt;- scanone(fake.bc, addcovar=ac, n.perm=1000)


# re-set the seed
set.seed(theseed)

# permutations with interactive covariate
## Not run: operm.icovar &lt;- scanone(fake.bc, addcovar=ac, intcovar=ic,
                      n.perm=1000)

## End(Not run)

# permutation results for the QTL x covariate interaction
operm.gxc &lt;- operm.icovar - operm.acovar

# LOD thresholds
summary(operm.gxc)
</code></pre>

<hr>
<h2 id='badorder'>An intercross with misplaced markers</h2><span id='topic+badorder'></span>

<h3>Description</h3>

<p>Simulated data for an intercross with some markers out of order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(badorder)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 250 F2 individuals typed at a total of 36 markers on four
chromosomes.  The data were simulated with QTLs at the center of
chromosomes 1 and 3.
</p>
<p>The order of several markers on chromosome 1 is incorrect.  Markers on
chromosomes 2 and 3 are switched.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+ripple">ripple</a></code>,
<code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+sim.cross">sim.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)

# estimate recombination fractions
badorder &lt;- est.rf(badorder)
plotRF(badorder)

# re-estimate map
newmap &lt;- est.map(badorder)
plotMap(badorder, newmap)

# assess marker order on chr 1
rip3 &lt;- ripple(badorder, chr=1, window=3)
summary(rip3)
</code></pre>

<hr>
<h2 id='bayesint'>Bayesian credible interval</h2><span id='topic+bayesint'></span>

<h3>Description</h3>

<p>Calculate an approximate Bayesian credible interval for a particular
chromosome, using output from <code><a href="#topic+scanone">scanone</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesint(results, chr, qtl.index, prob=0.95, lodcolumn=1, expandtomarkers=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesint_+3A_results">results</code></td>
<td>
<p>Output from <code><a href="#topic+scanone">scanone</a></code>, or a qtl object
as output from <code><a href="#topic+refineqtl">refineqtl</a></code>.</p>
</td></tr>
<tr><td><code id="bayesint_+3A_chr">chr</code></td>
<td>
<p>A chromosome ID (if input <code>results</code> are from
<code><a href="#topic+scanone">scanone</a></code> (should have length 1).</p>
</td></tr>
<tr><td><code id="bayesint_+3A_qtl.index">qtl.index</code></td>
<td>
<p>Numeric index for a QTL (if input <code>results</code> are
from <code><a href="#topic+refineqtl">refineqtl</a></code> (should have length 1).</p>
</td></tr>
<tr><td><code id="bayesint_+3A_prob">prob</code></td>
<td>
<p>Probability coverage of the interval.</p>
</td></tr>
<tr><td><code id="bayesint_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer indicating which
of the LOD score columns should be considered (if input
<code>results</code> are from <code><a href="#topic+scanone">scanone</a></code>).</p>
</td></tr>
<tr><td><code id="bayesint_+3A_expandtomarkers">expandtomarkers</code></td>
<td>
<p>If TRUE, the interval is expanded to the nearest
flanking markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We take <code class="reqn">10^{LOD}</code>, rescale it to have area 1, and then
calculate the connected interval with density above some threshold
and having coverage matching the target probability.
</p>


<h3>Value</h3>

<p>An object of class <code>scanone</code> indicating the
estimated QTL position and the approximate endpoints
for the Bayesian credible interval.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+lodint">lodint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- calc.genoprob(hyper, step=0.5)
out &lt;- scanone(hyper, method="hk")
bayesint(out, chr=1)
bayesint(out, chr=4)
bayesint(out, chr=4, prob=0.99)
bayesint(out, chr=4, expandtomarkers=TRUE)
</code></pre>

<hr>
<h2 id='bristle3'>Data on bristle number in Drosophila</h2><span id='topic+bristle3'></span>

<h3>Description</h3>

<p>Data from bristle number in chromosome 3 recombinant isogenic lines of
<em>Drosophila melanogaster</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bristle3)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 66 chromosome 3 recombinant isogenic lines, derived from
inbred lines that were selected for low (A) and high (B) abdominal
bristle numbers.  A recombinant chromosome 3 was placed in an isogenic
low background.
</p>
<p>There are eight phenotypes: the average and SD of the number of
abdominal and sternopleural bristles in males and females for each
line.
</p>
<p>Each line is typed at 29 genetic markers on chromosome 3.
</p>


<h3>References</h3>

<p>Long, A. D., Mullaney, S. L., Reid, L. A., Fry, J. D., Langley,
C. H. and MacKay, T. F. C. (1995) High resolution mapping of genetic
factors affecting abdominal bristle number in <em>Drosophila
melanogaster</em>.  <em>Genetics</em> <b>139</b>, 1273&ndash;1291.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bristleX">bristleX</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+fake.bc">fake.bc</a></code>, <code><a href="#topic+fake.f2">fake.f2</a></code>,
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+hyper">hyper</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bristle3)
# Summaries
summary(bristle3)
plot(bristle3)

# genome scan for each of the average phenotypes
bristle3 &lt;- calc.genoprob(bristle3, step=2)
out &lt;- scanone(bristle3, pheno.col=c(1,3,5,7))

# Plot the results
    # maximum LOD score among four phenotypes
ym &lt;- max(apply(out[,-(1:2)], 2, max))
plot(out, lod=1:3, ylim=c(0,ym))
plot(out, lod=4, add=TRUE, col="green")
</code></pre>

<hr>
<h2 id='bristleX'>Data on bristle number in Drosophila</h2><span id='topic+bristleX'></span>

<h3>Description</h3>

<p>Data from bristle number in chromosome X recombinant isogenic lines of
<em>Drosophila melanogaster</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bristleX)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 92 chromosome X recombinant isogenic lines, derived from
inbred lines that were selected for low (A) and high (B) abdominal
bristle numbers.  A recombinant chromosome X was placed in an isogenic
low background.
</p>
<p>There are eight phenotypes: the average and SD of the number of
abdominal and sternopleural bristles in males and females for each
line.
</p>
<p>Each line is typed at 17 genetic markers on chromosome 3.
</p>


<h3>References</h3>

<p>Long, A. D., Mullaney, S. L., Reid, L. A., Fry, J. D., Langley,
C. H. and MacKay, T. F. C. (1995) High resolution mapping of genetic
factors affecting abdominal bristle number in <em>Drosophila
melanogaster</em>.  <em>Genetics</em> <b>139</b>, 1273&ndash;1291.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bristleX">bristleX</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+fake.bc">fake.bc</a></code>, <code><a href="#topic+fake.f2">fake.f2</a></code>,
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+hyper">hyper</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bristleX)
# Summaries
summary(bristleX)
plot(bristleX)

# genome scan for each of the average phenotypes
bristleX &lt;- calc.genoprob(bristleX, step=2)
out &lt;- scanone(bristleX, pheno.col=c(1,3,5,7))

# Plot the results
    # maximum LOD score among four phenotypes
ym &lt;- max(apply(out[,-(1:2)], 2, max))
plot(out, lod=1:3, ylim=c(0,ym))
plot(out, lod=4, add=TRUE, col="green")
</code></pre>

<hr>
<h2 id='c.cross'>Combine data for QTL experiments</h2><span id='topic+c.cross'></span>

<h3>Description</h3>

<p>Concatenate the data for multiple QTL experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.cross_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.  These must all either be of the
same cross type or be a combination of backcrosses and intercrosses.
All crosses must have the same number of chromosomes and chromosome
names, and the same marker orders and positions, though the set of
markers need not be precisely the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concatenated input, as a <code>cross</code> object. Additional
columns are added to the phenotype data indicating which cross an
individual comes from; another column indicates cross type (0=BC,
1=intercross), if there are crosses of different types.  The crosses
are not required to have exactly the same set of phenotypes;
phenotypes with the same names are assumed to be the same.
</p>
<p>If the crosses have different sets of markers, we
interpolate marker order, but the cM positions of markers that are in
common between crosses must be precisely the same in the different crosses.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+subset.cross">subset.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
junk &lt;- fake.f2
junk &lt;- c(fake.f2,junk)
</code></pre>

<hr>
<h2 id='c.scanone'>Combine columns from multiple scanone results</h2><span id='topic+c.scanone'></span><span id='topic+cbind.scanone'></span>

<h3>Description</h3>

<p>Concatenate the columns from different runs of
<code><a href="#topic+scanone">scanone</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
c(..., labels)
## S3 method for class 'scanone'
cbind(..., labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.scanone_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scanone</code>. (This can also
be a list of <code>scanone</code> objects.) These are
the results from  <code><a href="#topic+scanone">scanone</a></code> (with <code>n.perm=0</code>),
generally run with different phenotypes or methods.  All must
conform with each other, meaning that
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> and/or <code><a href="#topic+sim.geno">sim.geno</a></code>
were run with the same values for <code>step</code> and <code>off.end</code> and
with data having the same genetic map.</p>
</td></tr>
<tr><td><code id="c.scanone_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings, of length 1 or of the same
length as the input, to be appended to the column names
in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results from multiple
runs <code><a href="#topic+scanone">scanone</a></code>, generally for
different phenotypes and/or methods, to be used in parallel with
<code><a href="#topic+summary.scanone">summary.scanone</a></code>.
</p>


<h3>Value</h3>

<p>The concatenated input, as a <code>scanone</code> object.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scanone">summary.scanone</a></code>,
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+cbind.scanoneperm">cbind.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2)

out.hk &lt;- scanone(fake.f2, method="hk")
out.np &lt;- scanone(fake.f2, model="np")

out &lt;- c(out.hk, out.np, labels=c("hk","np"))
plot(out, lod=1:2, col=c("blue", "red"))
</code></pre>

<hr>
<h2 id='c.scanoneperm'>Combine data from scanone permutations</h2><span id='topic+c.scanoneperm'></span><span id='topic+rbind.scanoneperm'></span>

<h3>Description</h3>

<p>Concatenate the data for multiple runs of <code><a href="#topic+scanone">scanone</a></code>
with <code>n.perm &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneperm'
c(...)
## S3 method for class 'scanoneperm'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.scanoneperm_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scanoneperm</code>. (This can
also be a list of <code>scanoneperm</code> objects.) These are
the permutation results from <code><a href="#topic+scanone">scanone</a></code> (that is,
when <code>n.perm &gt; 0</code>).  These must all have the same number of
columns. (That is, they must have been created with the same number
of phenotypes, and it is assumed that they were generated in
precisely the same way.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results from multiple
runs of a permutation test <code><a href="#topic+scanone">scanone</a></code>, to assist with
the case that such permutations are done on multiple processors in
parallel.
</p>


<h3>Value</h3>

<p>The concatenated input, as a <code>scanoneperm</code> object.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>,
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+cbind.scanoneperm">cbind.scanoneperm</a></code>,
<code><a href="#topic+c.scantwoperm">c.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2)
operm1 &lt;- scanone(fake.f2, method="hk", n.perm=100, perm.Xsp=TRUE)
operm2 &lt;- scanone(fake.f2, method="hk", n.perm=50, perm.Xsp=TRUE)

operm &lt;- c(operm1, operm2)
</code></pre>

<hr>
<h2 id='c.scantwo'>Combine columns from multiple scantwo results</h2><span id='topic+c.scantwo'></span><span id='topic+cbind.scantwo'></span>

<h3>Description</h3>

<p>Concatenate the columns from different runs of
<code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
c(...)
## S3 method for class 'scantwo'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.scantwo_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scantwo</code>. (This can also
be a list of <code>scantwo</code> objects.) These are
the results from  <code><a href="#topic+scantwo">scantwo</a></code> (with <code>n.perm=0</code>),
generally run with different phenotypes or methods.  All must
conform with each other, meaning that
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> and/or <code><a href="#topic+sim.geno">sim.geno</a></code>
were run with the same values for <code>step</code> and <code>off.end</code> and
with data having the same genetic map.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results from multiple
runs <code><a href="#topic+scantwo">scantwo</a></code>, generally for
different phenotypes and/or methods.
</p>


<h3>Value</h3>

<p>The concatenated input, as a <code>scantwo</code> object.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+c.scanone">c.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
fake.bc &lt;- calc.genoprob(fake.bc)

out2a &lt;- scantwo(fake.bc, method="hk")
out2b &lt;- scantwo(fake.bc, pheno.col=2, method="hk")

out2 &lt;- c(out2a, out2b)
</code></pre>

<hr>
<h2 id='c.scantwoperm'>Combine data from scantwo permutations</h2><span id='topic+c.scantwoperm'></span><span id='topic+rbind.scantwoperm'></span>

<h3>Description</h3>

<p>Concatenate the data for multiple runs of <code><a href="#topic+scantwo">scantwo</a></code>
with <code>n.perm &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwoperm'
c(...)
## S3 method for class 'scantwoperm'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.scantwoperm_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scantwoperm</code>. (This can
also be a list of <code>scantwoperm</code> objects.)  These are
the permutation results from <code><a href="#topic+scantwo">scantwo</a></code> (that is,
when <code>n.perm &gt; 0</code>).  These must all concern the same number of
LOD columns. (That is, they must have been created with the same number
of phenotypes, and it is assumed that they were generated in
precisely the same way.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results from multiple
runs of a permutation test <code><a href="#topic+scantwo">scantwo</a></code>, to assist with
the case that such permutations are done on multiple processors in
parallel.
</p>


<h3>Value</h3>

<p>The concatenated input, as a <code>scantwoperm</code> object.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code>,
<code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+cbind.scantwoperm">cbind.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2)
## Not run: operm1 &lt;- scantwo(fake.f2, method="hk", n.perm=50)
operm2 &lt;- scantwo(fake.f2, method="hk", n.perm=50)
## End(Not run)

operm &lt;- c(operm1, operm2)
</code></pre>

<hr>
<h2 id='calc.errorlod'>Identify likely genotyping errors</h2><span id='topic+calc.errorlod'></span>

<h3>Description</h3>

<p>Calculates a LOD score for each genotype, measuring the evidence for
genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.errorlod(cross, error.prob=0.01,
              map.function=c("haldane","kosambi","c-f","morgan"),
              version=c("new","old"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.errorlod_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="calc.errorlod_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype)</p>
</td></tr>
<tr><td><code id="calc.errorlod_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="calc.errorlod_+3A_version">version</code></td>
<td>
<p>Specifies whether to use the original version of this
function or the current (preferred) version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates, for each individual at each marker, a LOD score
measuring the strength of evidence for a genotyping error, as
described by Lincoln and Lander (1992).
</p>
<p>In the latest version, evidence for a genotype being in
error is considered assuming that all other genotypes (for that
individual, on that chromosome) are correct.  The argument
<code>version</code> allows one to specify whether this new version is used,
or whether the original (old) version of the calculation is
performed.
</p>
<p>Note that values below 4 are generally not interesting.  Also note
that if markers are extremely tightly linked, <em>recombination
events</em> can give large error LOD scores.  The error LOD scores should
not be trusted blindly, but should be viewed as a tool for identifying
genotypes deserving further study.
</p>
<p>Use <code><a href="#topic+top.errorlod">top.errorlod</a></code> to print all genotypes with error
LOD scores above a specified threshold,
<code><a href="#topic+plotErrorlod">plotErrorlod</a></code> to plot the error LOD scores for
specified chromosomes, and <code><a href="#topic+plotGeno">plotGeno</a></code> to view the
observed genotype data with likely errors flagged.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component,
<code>errorlod</code>, added to each component of <code>cross$geno</code>.  The
<code>errorlod</code> component is a matrix of size (n.ind x n.mar).  An
attribute <code>"error.prob"</code> is set to the value of the corresponding
argument, for later reference.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Lincoln, S. E. and Lander, E. S. (1992) Systematic detection of
errors in genetic linkage data.  <em>Genomics</em> <b>14</b>, 604&ndash;610.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotErrorlod">plotErrorlod</a></code>,
<code><a href="#topic+top.errorlod">top.errorlod</a></code>, <code><a href="#topic+cleanGeno">cleanGeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- calc.errorlod(hyper,error.prob=0.01)

# print those above a specified cutoff
top.errorlod(hyper, cutoff=4)

# plot genotype data, flagging genotypes with error LOD &gt; cutoff
plotGeno(hyper, chr=1, ind=160:200, cutoff=7, min.sep=2)
</code></pre>

<hr>
<h2 id='calc.genoprob'>Calculate conditional genotype probabilities</h2><span id='topic+calc.genoprob'></span>

<h3>Description</h3>

<p>Uses the hidden Markov model technology to calculate the
probabilities of the true underlying genotypes given the observed
multipoint marker data, with possible allowance for genotyping
errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.genoprob(cross, step=0, off.end=0, error.prob=0.0001,
              map.function=c("haldane","kosambi","c-f","morgan"),
              stepwidth=c("fixed", "variable", "max"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.genoprob_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="calc.genoprob_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which the
genotype probabilities are calculated, though for <code>step = 0</code>,
probabilities are calculated only at the marker locations.</p>
</td></tr>
<tr><td><code id="calc.genoprob_+3A_off.end">off.end</code></td>
<td>
<p>Distance (in cM) past the terminal markers on each
chromosome to which the genotype probability calculations will be
carried.</p>
</td></tr>
<tr><td><code id="calc.genoprob_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="calc.genoprob_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi or
Carter-Falconer map function when converting genetic distances into
recombination fractions.</p>
</td></tr>
<tr><td><code id="calc.genoprob_+3A_stepwidth">stepwidth</code></td>
<td>
<p>Indicates whether the intermediate points should with
fixed or variable step sizes.  We recommend using
<code>"fixed"</code>; <code>"variable"</code> was included for the qtlbim
package (<a href="https://cran.r-project.org/src/contrib/Archive/qtlbim/">https://cran.r-project.org/src/contrib/Archive/qtlbim/</a>).  The <code>"max"</code>
option inserts the minimal number of intermediate points so that the
maximum distance between points is <code>step</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">O_k</code> denote the observed marker genotype at position
<code class="reqn">k</code>, and <code class="reqn">g_k</code> denote the corresponding true underlying
genotype.
</p>
<p>We use the forward-backward equations to calculate
<code class="reqn">\alpha_{kv} = \log Pr(O_1, \ldots, O_k, g_k = v)</code>
and
<code class="reqn">\beta_{kv} = \log Pr(O_{k+1}, \ldots, O_n | g_k = v)</code>
</p>
<p>We then obtain
<code class="reqn">Pr(g_k | O_1, \ldots, O_n) = \exp(\alpha_{kv} + \beta_{kv}) / s</code>
where
<code class="reqn">s = \sum_v \exp(\alpha_{kv} + \beta_{kv})</code>
</p>
<p>In the case of the 4-way cross, with a sex-specific map, we assume a
constant ratio of female:male recombination rates within the
inter-marker intervals.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component,
<code>prob</code>, added to each component of <code>cross$geno</code>.
<code>prob</code> is an array of size [n.ind x n.pos x n.gen] where n.pos is
the number of positions at which the probabilities were calculated and
n.gen = 3 for an intercross, = 2 for a backcross, and = 4 for a 4-way
cross.  Attributes <code>"error.prob"</code>, <code>"step"</code>,
<code>"off.end"</code>, and <code>"map.function"</code> are set to the values of
the corresponding arguments, for later reference (especially by the
function <code><a href="#topic+calc.errorlod">calc.errorlod</a></code>).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Lange, K. (1999) <em>Numerical analysis for statisticians</em>.
Springer-Verlag. Sec 23.3.
</p>
<p>Rabiner, L. R. (1989) A tutorial on hidden Markov models and selected
applications in speech recognition.  <em>Proceedings of the IEEE</em>
<b>77</b>, 257&ndash;286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+argmax.geno">argmax.geno</a></code>,
<code><a href="#topic+calc.errorlod">calc.errorlod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2, step=2, off.end=5)

data(fake.bc)
fake.bc &lt;- calc.genoprob(fake.bc, step=0, off.end=0, err=0.01)
</code></pre>

<hr>
<h2 id='calc.penalties'>Calculate LOD penalties</h2><span id='topic+calc.penalties'></span>

<h3>Description</h3>

<p>Derive penalties for the penalized LOD scores (used by
<code><a href="#topic+stepwiseqtl">stepwiseqtl</a></code>) on the basis of permutation results
from a two-dimensional, two-QTL scan (obtained by <code><a href="#topic+scantwo">scantwo</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.penalties(perms, alpha=0.05, lodcolumn)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.penalties_+3A_perms">perms</code></td>
<td>
<p>Permutation results from <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="calc.penalties_+3A_alpha">alpha</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="calc.penalties_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If the scantwo permutation results contain LOD scores for
multiple phenotypes, this argument indicates which to use in the
summary.  This may be a vector.  If missing, penalties for all
phenotypes are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thresholds derived from <code><a href="#topic+scantwo">scantwo</a></code> permutations (that
is, for a two-dimensional, two-QTL genome scan) are used to calculate
penalties on main effects and interactions.
</p>
<p>The main effect penalty is the 1-<code>alpha</code> quantile of the null
distribution of the genome-wide maximum LOD score from a single-QTL
genome scan (as with <code><a href="#topic+scanone">scanone</a></code>).
</p>
<p>The &quot;heavy&quot; interaction penalty is the 1-<code>alpha</code> quantile of
the null distribution of the maximum interaction LOD score (that is,
the <code class="reqn">\log_{10}</code> likelihood ratio comparing the best model
with two interacting QTL to the best model with two additive QTL) from
a two-dimensional, two-QTL genome scan (as with
<code><a href="#topic+scantwo">scantwo</a></code>).
</p>
<p>The &quot;light&quot; interaction penality is the difference between the
<code>"fv1"</code> threshold from the <code><a href="#topic+scantwo">scantwo</a></code>
permutations (that is, the 1-<code>alpha</code> quantile of the LOD score
comparing the best model with two interacting QTL to the best
single-QTL model) and the main effect penalty.
</p>
<p>If the permutations results were obtained with <code>perm.Xsp=TRUE</code>,
to give X-chr-specific results, six penalties are calculated: main
effect for autosomes, main effect for X chr, heavy penalty on A:A
interactions, light penalty on A:A interactions, penalty on A:X
interactions, and penalty on X:X interactions.
</p>


<h3>Value</h3>

<p>Vector of three values indicating the penalty on main
effects and heavy and light penalties on interactions,
or a matrix of such results, with each row corresponding to a
different phenotype.
</p>
<p>If the input permutations are X-chromosome-specific, the result has
six values: main effect for autosomes, main effect for X chr, heavy
penalty on A:A interactions, light penalty on A:A interactions,
penalty on A:X interactions, and penalty on X:X interactions.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Manichaikul, A., Moon, J. Y., Sen, &#346;, Yandell, B. S. and Broman,
K. W. (2009) A model selection approach for the identification of
quantitative trait loci in experimental crosses, allowing
epistasis. <em>Genetics</em>, <b>181</b>, 1077&ndash;1086.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+stepwiseqtl">stepwiseqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
out.2dim &lt;- scantwo(fake.f2, method="hk")

# permutations

## Not run: permo.2dim &lt;- scantwo(fake.f2, method="hk", n.perm=1000)
summary(permo.2dim, alpha=0.05)

# penalties
calc.penalties(permo.2dim)
</code></pre>

<hr>
<h2 id='cbind.scanoneperm'>Combine columns from multiple scanone permutation results</h2><span id='topic+cbind.scanoneperm'></span>

<h3>Description</h3>

<p>Concatenate the columns from different runs of
<code><a href="#topic+scanone">scanone</a></code> with <code>n.perm &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneperm'
cbind(..., labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind.scanoneperm_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scanoneperm</code>. These are
the permutation results from <code><a href="#topic+scanone">scanone</a></code> (that is,
when <code>n.perm &gt; 0</code>), generally run with different phenotypes or
methods.</p>
</td></tr>
<tr><td><code id="cbind.scanoneperm_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings, of length 1 or of the same
length as the input <code>...</code>, to be appended to the column names
in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results from multiple
runs of a permutation test <code><a href="#topic+scanone">scanone</a></code>, generally for
different phenotypes and/or methods, to be used in parallel with
<code><a href="#topic+c.scanone">c.scanone</a></code>.
</p>


<h3>Value</h3>

<p>The concatenated input, as a <code>scanoneperm</code> object. If
different numbers of permutation replicates were used, those columns
with fewer replicates are padded with missing values (<code>NA</code>).</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>,
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+c.scanoneperm">c.scanoneperm</a></code>,
<code><a href="#topic+c.scanone">c.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2)

operm1 &lt;- scanone(fake.f2, method="hk", n.perm=10, perm.Xsp=TRUE)
operm2 &lt;- scanone(fake.f2, method="em", n.perm=5, perm.Xsp=TRUE)

operm &lt;- cbind(operm1, operm2, labels=c("hk","em"))
summary(operm)
</code></pre>

<hr>
<h2 id='cbind.scantwoperm'>Combine scantwo permutations by column</h2><span id='topic+cbind.scantwoperm'></span>

<h3>Description</h3>

<p>Column-bind permutations results from <code><a href="#topic+scantwo">scantwo</a></code>
for multiple phenotypes or models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwoperm'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind.scantwoperm_+3A_...">...</code></td>
<td>
<p>A set of objects of class <code>scantwoperm</code>. (This can
also be a list of <code>scantwoperm</code> objects.)  These are
the permutation results from <code><a href="#topic+scantwo">scantwo</a></code> (that is,
when <code>n.perm &gt; 0</code>).  These must all concern the same number of
permutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The column-binded input, as a <code>scantwoperm</code> object.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+c.scantwoperm">c.scantwoperm</a></code>,
<code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc)
## Not run: operm1 &lt;- scantwo(fake.bc, pheno.col=1, method="hk", n.perm=50)
operm2 &lt;- scantwo(fake.bc, pheno.col=2, method="hk", n.perm=50)
## End(Not run)

operm &lt;- cbind(operm1, operm2)
</code></pre>

<hr>
<h2 id='checkAlleles'>Identify markers with switched alleles</h2><span id='topic+checkAlleles'></span>

<h3>Description</h3>

<p>Identify markers whose alleles might have been switched by comparing
the LOD score for linkage to all other autosomal markers with the
original data to that when the alleles have been switched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAlleles(cross, threshold=3, verbose)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkAlleles_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="checkAlleles_+3A_threshold">threshold</code></td>
<td>
<p>Only an increase in maximum 2-point LOD of at least
this amount will lead to a marker being flagged.</p>
</td></tr>
<tr><td><code id="checkAlleles_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE and there are no markers above the threshold,
print a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each marker, we compare the maximum LOD score for the cases where
the estimated recombination fraction &gt; 0.5 to those where r.f. &lt; 0.5.
The function <code><a href="#topic+est.rf">est.rf</a></code> must first be run.
</p>
<p><b>Note</b>: Markers that are tightly linked to a marker whose alleles
are switched are likely to also be flagged by this method.  The real
problem markers are likely those with the biggest difference in LOD
scores.
</p>


<h3>Value</h3>

<p>A data frame containing the flagged markers, having four columns: the
marker name, chromosome ID, numeric index within chromosome, and the
difference between the maximum two-point LOD score with the alleles
switched to that from the original data.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+geno.crosstab">geno.crosstab</a></code>, <code><a href="#topic+switchAlleles">switchAlleles</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)


# switch homozygotes at marker D5M391
fake.f2 &lt;- switchAlleles(fake.f2, "D5M391")

fake.f2 &lt;- est.rf(fake.f2)
checkAlleles(fake.f2)
</code></pre>

<hr>
<h2 id='chrlen'>Chromosome lengths in QTL experiment</h2><span id='topic+chrlen'></span>

<h3>Description</h3>

<p>Obtain the chromosome lengths in a <code>cross</code> or <code>map</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrlen(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chrlen_+3A_object">object</code></td>
<td>
<p>An object of class <code>map</code> or of class <code>cross</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of chromosome lengths.  If the cross has sex-specific
maps, it returns a 2-row matrix with the two lengths for each chromosome.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summaryMap">summaryMap</a></code>, <code><a href="#topic+pull.map">pull.map</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
chrlen(fake.f2)

map &lt;- pull.map(fake.f2)
chrlen(map)
</code></pre>

<hr>
<h2 id='chrnames'>Pull out the chromosome names from a cross</h2><span id='topic+chrnames'></span>

<h3>Description</h3>

<p>Pull out the chromosome names from a cross object as one big vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrnames(cross)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chrnames_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings (the chromosome names).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+markernames">markernames</a></code>, <code><a href="#topic+phenames">phenames</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
chrnames(listeria)
</code></pre>

<hr>
<h2 id='cim'>Composite interval mapping</h2><span id='topic+cim'></span>

<h3>Description</h3>

<p>Composite interval mapping by a scheme from QTL Cartographer:
forward selection at the markers (here, with filled-in genotype data)
to a fixed number, followed by interval mapping with the selected
markers as covariates, dropping marker covariates if they are within
some fixed window size of the location under test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cim(cross, pheno.col=1, n.marcovar=3, window=10,
    method=c("em", "imp", "hk", "ehk"),
    imp.method=c("imp", "argmax"), error.prob=0.0001,
    map.function=c("haldane", "kosambi", "c-v", "morgan"),
    addcovar=NULL, n.perm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cim_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="cim_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="cim_+3A_n.marcovar">n.marcovar</code></td>
<td>
<p>Number of marker covariates to use.</p>
</td></tr>
<tr><td><code id="cim_+3A_window">window</code></td>
<td>
<p>Window size, in cM.</p>
</td></tr>
<tr><td><code id="cim_+3A_method">method</code></td>
<td>
<p>Indicates whether to use the EM algorithm,
imputation, Haley-Knott regression, or the extended Haley-Knott
method.</p>
</td></tr>
<tr><td><code id="cim_+3A_imp.method">imp.method</code></td>
<td>
<p>Method used to impute any missing marker genotype
data.</p>
</td></tr>
<tr><td><code id="cim_+3A_error.prob">error.prob</code></td>
<td>
<p>Genotyping error probability assumed when imputing
the missing marker genotype data.</p>
</td></tr>
<tr><td><code id="cim_+3A_map.function">map.function</code></td>
<td>
<p>Map function used when imputing the missing marker
genotype data.</p>
</td></tr>
<tr><td><code id="cim_+3A_addcovar">addcovar</code></td>
<td>
<p>Optional numeric matrix of additional covariates to include.</p>
</td></tr>
<tr><td><code id="cim_+3A_n.perm">n.perm</code></td>
<td>
<p>If specified, a permutation test is performed rather than
an analysis of the observed data.  This argument defines the number
of permutation replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first use <code><a href="#topic+fill.geno">fill.geno</a></code> to impute any missing marker
genotype data, either via a simple random imputation or using the
Viterbi algorithm.
</p>
<p>We then perform forward selection to a fixed number of markers.  These
will be used (again, with any missing data filled in) as covariates in
the subsequent genome scan.
</p>


<h3>Value</h3>

<p>The function returns an object of the same form as the function
<code><a href="#topic+scanone">scanone</a></code>:
</p>
<p>If <code>n.perm</code> is missing, the function returns the scan results as
a data.frame with three columns: chromosome, position, LOD score.
Attributes indicate the names and positions of the chosen marker
covariates.
</p>
<p>If <code>n.perm</code> &gt; 0, the function results the results of a
permutation test: a vector giving the genome-wide maximum LOD score in
each of the permutations.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Jansen, R. C. (1993) Interval mapping of multiple quantitative trait
loci.  <em>Genetics</em>, <b>135</b>, 205&ndash;211.
</p>
<p>Jansen, R. C. and Stam, P. (1994) High resolution of quantitative
traits into multiple loci via interval mapping.  <em>Genetics</em>,
<b>136</b>, 1447-1455.
</p>
<p>Zeng, Z. B. (1993) Theoretical basis for separation of multiple linked
gene effects in mapping quantitative trait loci.
<em>Proc. Natl. Acad. Sci. USA</em>, <b>90</b>, 10972&ndash;10976.
</p>
<p>Zeng, Z. B. (1994) Precision mapping of quantitative trait loci.
<em>Genetics</em>, <b>136</b>, 1457&ndash;1468.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+add.cim.covar">add.cim.covar</a></code>, <code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+fill.geno">fill.geno</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper &lt;- calc.genoprob(hyper, step=2.5)


out &lt;- scanone(hyper)
out.cim &lt;- cim(hyper, n.marcovar=3)
plot(out, out.cim, chr=c(1,4,6,15), col=c("blue", "red"))

add.cim.covar(out.cim, chr=c(1,4,6,15))
</code></pre>

<hr>
<h2 id='clean.cross'>Remove derived data</h2><span id='topic+clean.cross'></span>

<h3>Description</h3>

<p>Remove any intermediate calculations from a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
clean(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean.cross_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="clean.cross_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, with any intermediate calculations
(such as is produced by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+argmax.geno">argmax.geno</a></code> and <code><a href="#topic+sim.geno">sim.geno</a></code>)
removed.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code>,
<code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+clean.scantwo">clean.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
names(fake.f2$geno)
fake.f2 &lt;- calc.genoprob(fake.f2)
names(fake.f2$geno)
fake.f2 &lt;- clean(fake.f2)
names(fake.f2$geno)
</code></pre>

<hr>
<h2 id='clean.scantwo'>Clean up scantwo output</h2><span id='topic+clean.scantwo'></span>

<h3>Description</h3>

<p>In an object output from <code><a href="#topic+scantwo">scantwo</a></code>, replaces negative
and missing LOD scores with 0, and replaces LOD scores for pairs of
positions that are not separated by <code>n.mar</code> markers, or that are
less than <code>distance</code> cM apart, with 0.  Further, if the LOD
for full model is less than the LOD for the additive model, the
additive LOD is pasted over the full LOD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
clean(object, n.mar=1, distance=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean.scantwo_+3A_object">object</code></td>
<td>
<p>An object of class <code>scantwo</code>.  See
<code><a href="#topic+scantwo">scantwo</a></code> for details.</p>
</td></tr>
<tr><td><code id="clean.scantwo_+3A_n.mar">n.mar</code></td>
<td>
<p>Pairs of positions not separated by at least this many
markers have LOD scores set to 0.</p>
</td></tr>
<tr><td><code id="clean.scantwo_+3A_distance">distance</code></td>
<td>
<p>Pairs of positions not separated by at least this
distance have LOD scores set to 0.</p>
</td></tr>
<tr><td><code id="clean.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input scantwo object, with any negative or missing LOD scores
replaced by 0, and LOD scores for pairs of positions separated by
fewer than <code>n.mar</code> markers, or less than <code>distance</code> cM, are
set to 0.
Also, if the LOD for the full model is less than the LOD for the
additive model, the additive LOD is used in place of the full LOD.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
out2 &lt;- scantwo(fake.f2, method="hk")
out2 &lt;- clean(out2)
out2cl2 &lt;- clean(out2, n.mar=2, distance=5)
</code></pre>

<hr>
<h2 id='cleanGeno'>Delete genotypes that are possibly in error</h2><span id='topic+cleanGeno'></span>

<h3>Description</h3>

<p>Delete genotypes from a cross that are indicated to be possibly in
error, as they result in apparent tight double-crossovers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanGeno(cross, chr, maxdist=2.5, maxmark=2, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanGeno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="cleanGeno_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="cleanGeno_+3A_maxdist">maxdist</code></td>
<td>
<p>A vector specifying the maximum distance between two
crossovers.</p>
</td></tr>
<tr><td><code id="cleanGeno_+3A_maxmark">maxmark</code></td>
<td>
<p>A vector specifying the maximum number of typed markers
between two crossovers.</p>
</td></tr>
<tr><td><code id="cleanGeno_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information on the numbers of genotypes
omitted from each chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first use <code><a href="#topic+locateXO">locateXO</a></code> to identify crossover locations.
If a pair of adjacted crossovers are separated by no more than
<code>maxdist</code> and contain no more than <code>maxmark</code> genotyped
markers, the intervening genotypes are omitted (that is, changed to
<code>NA</code>).
</p>
<p>The arguments <code>maxdist</code> and <code>maxmark</code> may be vectors.  (If
both have length greater than 1, they must have the same length.)  If
they are vectors, genotypes are omitted if they satisify any one of
the (<code>maxdist</code>, <code>maxmark</code>) pairs.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object with suspect genotypes omitted.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+locateXO">locateXO</a></code>,
<code><a href="#topic+countXO">countXO</a></code>, <code><a href="#topic+calc.errorlod">calc.errorlod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
sum(ntyped(hyper))
hyperc &lt;- cleanGeno(hyper, chr=4, maxdist=c(2.5, 10), maxmark=c(2, 1))
sum(ntyped(hyperc))
</code></pre>

<hr>
<h2 id='comparecrosses'>Compare two cross objects</h2><span id='topic+comparecrosses'></span>

<h3>Description</h3>

<p>Verify that two objects of class <code>cross</code> have identical classes,
chromosomes, markers, genotypes, genetic maps, and phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparecrosses(cross1, cross2, tol=1e-5)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comparecrosses_+3A_cross1">cross1</code></td>
<td>
<p>An object of class <code>cross</code> (must be an
intercross). See <code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="comparecrosses_+3A_cross2">cross2</code></td>
<td>
<p>An object of class <code>cross</code> (must be an
intercross). See <code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="comparecrosses_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for comparing genetic map positions and
numeric phenotypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.cross">summary.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
comparecrosses(listeria, listeria)
</code></pre>

<hr>
<h2 id='comparegeno'>Compare individuals' genotype data</h2><span id='topic+comparegeno'></span>

<h3>Description</h3>

<p>Count proportion of matching genotypes between all pairs of
individuals, to look for unusually closely related individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparegeno(cross, what=c("proportion","number","both"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comparegeno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="comparegeno_+3A_what">what</code></td>
<td>
<p>Indicates whether to return the proportion or number of matching
genotypes (or both).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose (i,j)th element is the proportion or number of matching
genotypes for individuals i and j.
</p>
<p>If called with <code>what="both"</code>, the lower triangle contains the
proportion and the upper triangle contains the number.
</p>
<p>If called with <code>what="proportion"</code>, the diagonal contains missing
values.  Otherwise, the diagonal contains the number of typed markers
for each individual.
</p>
<p>The output is given class <code>"comparegeno"</code> so that appropriate
<code>summary</code> and <code>plot</code> functions may be used.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmissing">nmissing</a></code>, <code><a href="#topic+summary.comparegeno">summary.comparegeno</a></code>,
<code><a href="#topic+plot.comparegeno">plot.comparegeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

cg &lt;- comparegeno(listeria)

summary(cg, 0.7)
plot(cg)
</code></pre>

<hr>
<h2 id='compareorder'>Compare two orderings of markers on a chromosome</h2><span id='topic+compareorder'></span>

<h3>Description</h3>

<p>Compare the likelihood of an alternative order for markers on a
chromosome to the current order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareorder(cross, chr, order, error.prob=0.0001,
             map.function=c("haldane","kosambi","c-f","morgan"),
             maxit=4000, tol=1e-6, sex.sp=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareorder_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="compareorder_+3A_chr">chr</code></td>
<td>
<p>The chromosome to investigate.  Only one chromosome is
allowed. (This should be a character string referring to the
chromosomes by name.)</p>
</td></tr>
<tr><td><code id="compareorder_+3A_order">order</code></td>
<td>
<p>The alternate order of markers on the chromosome: a numeric
vector that is a permutation of the integers from 1 to the
number of markers on the chromosome.</p>
</td></tr>
<tr><td><code id="compareorder_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="compareorder_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="compareorder_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="compareorder_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="compareorder_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two rows: the current order in the input cross object, and the
revised order.  The first column is the log10 likelihood of the new order relative
to the original one (positive values indicate that the new order is better supported).
The second column is the estimated genetic length of the chromosome for each order.
In the case of sex-specific maps, there are separate columns for the female and male
genetic lengths.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ripple">ripple</a></code>, <code><a href="#topic+switch.order">switch.order</a></code>,
<code><a href="#topic+movemarker">movemarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
compareorder(badorder, chr=1, order=c(1:8,11,10,9,12))
</code></pre>

<hr>
<h2 id='condense.scantwo'>Condense the output from a 2-d genome scan</h2><span id='topic+condense.scantwo'></span>

<h3>Description</h3>

<p>Produces a very condensed version of the output of <code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
condense(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condense.scantwo_+3A_object">object</code></td>
<td>
<p>An object of class <code>scantwo</code>, the output of the
function <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This produces a very reduced version of the output of
<code><a href="#topic+scantwo">scantwo</a></code>, for which a summary may still be created
via <code><a href="#topic+summary.scantwo">summary.scantwo</a></code>, though plots can no longer be
made.
</p>


<h3>Value</h3>

<p>An object of class <code>scantwocondensed</code>, containing just the
maximum full, additive and interactive LOD scores, and the positions
where they occured, on each pair of chromosomes.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+max.scantwo">max.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2)

out2 &lt;- scantwo(fake.f2, method="hk")

out2c &lt;- condense(out2)
summary(out2c, allpairs=FALSE)
max(out2c)
</code></pre>

<hr>
<h2 id='convert.map'>Change map function for a genetic map</h2><span id='topic+convert.map'></span>

<h3>Description</h3>

<p>Convert a genetic map from using one map function to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
convert(object, old.map.function=c("haldane", "kosambi", "c-f", "morgan"),
         new.map.function=c("haldane", "kosambi", "c-f", "morgan"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.map_+3A_object">object</code></td>
<td>
<p>A genetic map object, of class <code>"map"</code>: A list whose
components are vectors of marker locations.</p>
</td></tr>
<tr><td><code id="convert.map_+3A_old.map.function">old.map.function</code></td>
<td>
<p>The map function used in forming the map in
<code>object</code>.</p>
</td></tr>
<tr><td><code id="convert.map_+3A_new.map.function">new.map.function</code></td>
<td>
<p>The new map function to be used.</p>
</td></tr>
<tr><td><code id="convert.map_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location of the first marker on each chromosome is left
unchanged.  Inter-marker distances are converted to recombination
fractions with the inverse of the <code>old.map.function</code>, and then
back to distances with the <code>new.map.function</code>.
</p>


<h3>Value</h3>

<p>The same as the input, but with inter-marker distances changed to
reflect a different map function.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+replace.map">replace.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
map &lt;- pull.map(listeria)
map &lt;- convert(map, "haldane", "kosambi")
listeria &lt;- replace.map(listeria, map)
</code></pre>

<hr>
<h2 id='convert.scanone'>Convert output from scanone for R/qtl version 0.98</h2><span id='topic+convert.scanone'></span>

<h3>Description</h3>

<p>Convert the output from scanone from the format used in R/qtl version
0.97 and earlier to that used in version 0.98 and later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
convert(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.scanone_+3A_object">object</code></td>
<td>
<p>Output from the function <code><a href="#topic+scanone">scanone</a></code>, for
R/qtl version 0.97 and earlier.</p>
</td></tr>
<tr><td><code id="convert.scanone_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Previously, inter-marker locations were named as, for example,
<code>loc7.5.c3</code>; these were changed to <code>c3.loc7.5</code>.
</p>


<h3>Value</h3>

<p>The same scanone output, but revised for use with R/qtl version 0.98
and later.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+convert.scantwo">convert.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: out.new &lt;- convert(out.old)
</code></pre>

<hr>
<h2 id='convert.scantwo'>Convert output from scantwo for R/qtl version 1.03 and earlier</h2><span id='topic+convert.scantwo'></span>

<h3>Description</h3>

<p>Convert the output from scantwo from the format used in R/qtl version
1.03 and earlier to that used in version 1.04 and later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
convert(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.scantwo_+3A_object">object</code></td>
<td>
<p>Output from the function <code><a href="#topic+scantwo">scantwo</a></code>, for
R/qtl version 1.03 and earlier.</p>
</td></tr>
<tr><td><code id="convert.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Previously, the output from <code><a href="#topic+scantwo">scantwo</a></code> contained the
full and interaction LOD scores.  In R/qtl version 1.04 and later,
the output contains the LOD scores from the full and
additive QTL models.
</p>


<h3>Value</h3>

<p>The same scanone output, but revised for use with R/qtl version 1.03
and later.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+convert.scanone">convert.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: out2.new &lt;- convert(out2.old)
</code></pre>

<hr>
<h2 id='convert2riself'>Convert a cross to RIL by selfing</h2><span id='topic+convert2riself'></span>

<h3>Description</h3>

<p>Convert a cross to type <code>"riself"</code> (RIL by selfing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2riself(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2riself_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are more genotypes with code 3 (BB) than code 2 (AB), we omit
the genotypes with code==2 and call those with code==3 the BB
genotypes.
</p>
<p>If, instead, there are more genotypes with code 2 than code 3, we omit
the genotypes with code==3 and call those with code==2 the BB genotypes.
</p>
<p>Any chromosomes with class <code>"X"</code> (X chromosome) are changed to
class <code>"A"</code> (autosomal).
</p>


<h3>Value</h3>

<p>The input cross object, with genotype codes possibly changed and cross
type changed to <code>"riself"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+convert2risib">convert2risib</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper.as.riself &lt;- convert2riself(hyper)
</code></pre>

<hr>
<h2 id='convert2risib'>Convert a cross to RIL by sib mating</h2><span id='topic+convert2risib'></span>

<h3>Description</h3>

<p>Convert a cross to type <code>"risib"</code> (RIL by sib mating).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2risib(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2risib_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are more genotypes with code 3 (BB) than code 2 (AB), we omit
the genotypes with code==2 and call those with code==3 the BB
genotypes.
</p>
<p>If, instead, there are more genotypes with code 2 than code 3, we omit
the genotypes with code==3 and call those with code==2 the BB genotypes.
</p>


<h3>Value</h3>

<p>The input cross object, with genotype codes possibly changed and cross
type changed to <code>"risib"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+convert2riself">convert2riself</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper.as.risib &lt;- convert2risib(hyper)
</code></pre>

<hr>
<h2 id='convert2sa'>Convert a sex-specific map to a sex-averaged one</h2><span id='topic+convert2sa'></span>

<h3>Description</h3>

<p>Convert a sex-specific map to a sex-averaged one, assuming that the
female and male maps are actually the same (that is, that the map was
estimated assuming a common recombination rate in females and males).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2sa(map, tol=1e-4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2sa_+3A_map">map</code></td>
<td>
<p>A map object with sex-specific locations (but assuming that
the female and male maps are the same), as output by the function
<code><a href="#topic+est.map">est.map</a></code> for a 4-way cross, with argument
<code>sex.sp=FALSE</code>.</p>
</td></tr>
<tr><td><code id="convert2sa_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for inspecting the differences between the
female and male maps; if they differ by more than this tolerance, a
warning is issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We pull out just the female marker locations, and give a warning if
there are large differences between the female and male maps.
</p>


<h3>Value</h3>

<p>A map object, with sex-averaged distances.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+plotMap">plotMap</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.4way)
## Not run: fake.4way &lt;- subset(fake.4way, chr="-X")

nm &lt;- est.map(fake.4way, sex.sp=FALSE)
plot(convert2sa(nm))
</code></pre>

<hr>
<h2 id='countXO'>Count number of obligate crossovers for each individual</h2><span id='topic+countXO'></span>

<h3>Description</h3>

<p>Count the number of obligate crossovers for each individual in a
cross, either by chromosome or overall.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countXO(cross, chr, bychr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countXO_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="countXO_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to investigate.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="countXO_+3A_bychr">bychr</code></td>
<td>
<p>If TRUE, return counts for each individual chromosome; if
FALSE, return the overall number across the selected chromosomes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each individual we count the minimal number of crossovers that
explain the observed genotype data.
</p>


<h3>Value</h3>

<p>If <code>bychr=TRUE</code>, a matrix of counts is returned, with rows
corresponding to individuals and columns corresponding to
chromosomes.
</p>
<p>If <code>bychr=FALSE</code>, a vector of counts (the total number of
crossovers across all selected chromosomes) is returned.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ripple">ripple</a></code>, <code><a href="#topic+locateXO">locateXO</a></code>, <code><a href="#topic+cleanGeno">cleanGeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
plot(countXO(hyper))
</code></pre>

<hr>
<h2 id='drop.dupmarkers'>Drop duplicate markers</h2><span id='topic+drop.dupmarkers'></span>

<h3>Description</h3>

<p>Drop markers with duplicate names; retaining the first of each set,
with consensus genotyps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.dupmarkers(cross, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop.dupmarkers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="drop.dupmarkers_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information on the numbers of genotypes
and markers omitted.  If &gt; 1, give more detailed information
on genotypes omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> object, with any duplicate markers omitted
(except for one).  The marker retained will have consensus genotypes;
if multiple versions of a marker have different genotypes for an
individual, they will be replaced by <code>NA</code>.
</p>
<p>Any derived data (such as produced by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>)
will be stripped off.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code>, <code><a href="#topic+pull.markers">pull.markers</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>, <code><a href="#topic+clean.cross">clean.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

listeria &lt;- drop.dupmarkers(listeria)
</code></pre>

<hr>
<h2 id='drop.markers'>Drop a set of markers</h2><span id='topic+drop.markers'></span>

<h3>Description</h3>

<p>Drop a vector of markers from the data matrices and genetic maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.markers(cross, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop.markers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="drop.markers_+3A_markers">markers</code></td>
<td>
<p>A character vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, with any markers in the vector <code>markers</code> removed
from the genotype data matrices, genetic maps, and, if applicable, any
derived data (such as produced by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>).
(It might be a good idea to re-derive such things after using this
function.)
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code>, <code><a href="#topic+pull.markers">pull.markers</a></code>, <code><a href="#topic+geno.table">geno.table</a></code>,
<code><a href="#topic+clean.cross">clean.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria2 &lt;- drop.markers(listeria, c("D10M44","D1M3","D1M75"))
</code></pre>

<hr>
<h2 id='drop.nullmarkers'>Drop markers without any genotype data</h2><span id='topic+drop.nullmarkers'></span>

<h3>Description</h3>

<p>Drop markers, from the data matrices and genetic maps, that have no
genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.nullmarkers(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop.nullmarkers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, with any markers lacking genotype data removed from
the genotype data matrices, genetic maps, and, if applicable, any
derived data (such as produced by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>).
(It might be a good idea to re-derive such things after using this
function.)
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nullmarkers">nullmarkers</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+clean.cross">clean.cross</a></code>,
<code><a href="#topic+geno.table">geno.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># removes one marker from hyper
data(hyper)
hyper &lt;- drop.nullmarkers(hyper)

# shouldn't do anything to listeria
data(listeria)
listeria &lt;- drop.nullmarkers(listeria)
</code></pre>

<hr>
<h2 id='dropfromqtl'>Drop a QTL from a qtl object</h2><span id='topic+dropfromqtl'></span>

<h3>Description</h3>

<p>Drop a QTL or multiple QTL from a QTL object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropfromqtl(qtl, index, chr, pos, qtl.name, drop.lod.profile=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropfromqtl_+3A_qtl">qtl</code></td>
<td>
<p>A qtl object, as created by <code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="dropfromqtl_+3A_index">index</code></td>
<td>
<p>Vector specifying the numeric indices of the QTL to be dropped.</p>
</td></tr>
<tr><td><code id="dropfromqtl_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosome for each QTL to drop.</p>
</td></tr>
<tr><td><code id="dropfromqtl_+3A_pos">pos</code></td>
<td>
<p>Vector (of same length as <code>chr</code>) indicating the
positions of the QTL to be dropped.</p>
</td></tr>
<tr><td><code id="dropfromqtl_+3A_qtl.name">qtl.name</code></td>
<td>
<p>Vector specifying the names of the QTL to be dropped.</p>
</td></tr>
<tr><td><code id="dropfromqtl_+3A_drop.lod.profile">drop.lod.profile</code></td>
<td>
<p>If TRUE, remove any LOD profiles from the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide either <code>chr</code> and <code>pos</code>, or one of <code>qtl.name</code> or
<code>index</code>.
</p>


<h3>Value</h3>

<p>The input <code>qtl</code> object with the specified QTL omitted.   See <code><a href="#topic+makeqtl">makeqtl</a></code> for
details on the format.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <code>broman@wisc.edu</code></p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+addtoqtl">addtoqtl</a></code>, <code><a href="#topic+replaceqtl">replaceqtl</a></code> ,
<code><a href="#topic+reorderqtl">reorderqtl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 6, 13)
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

newqtl &lt;- dropfromqtl(qtl, chr=1, pos=25.8)
altqtl &lt;- dropfromqtl(qtl, index=1)
</code></pre>

<hr>
<h2 id='droponemarker'>Drop one marker at a time and determine effect on genetic map</h2><span id='topic+droponemarker'></span>

<h3>Description</h3>

<p>Drop one marker at a time from a genetic map and calculate the change
in log likelihood and in the chromosome length, in order to identify
problematic markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>droponemarker(cross, chr, error.prob=0.0001,
                map.function=c("haldane","kosambi","c-f","morgan"),
                m=0, p=0, maxit=4000, tol=1e-6, sex.sp=TRUE,
                verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="droponemarker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_chr">chr</code></td>
<td>
<p>A vector specifying which chromosomes to test for the
position of the marker.    This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions. (Ignored if m &gt; 0.)</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_m">m</code></td>
<td>
<p>Interference parameter for the chi-square model for
interference; a non-negative integer, with m=0 corresponding to no
interference. This may be used only for a backcross or intercross.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata from the NI mechanism, in the Stahl
model; p=0 gives a pure chi-square model.  This may be used only for
a backcross or intercross.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="droponemarker_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information on progress; if &gt; 1, print
even more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (actually, an object of class <code>"scanone"</code>, so that
one may use <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, etc.) with each row being a marker.
The first two columns are the chromosome ID and position.  The third
column is a LOD score comparing the hypothesis that the marker is not
linked to the hypothesis that it belongs at that position.
</p>
<p>In the case of a 4-way cross, with <code>sex.sp=TRUE</code>, there are two
additional columns with the change in the estimated female and male genetic lengths
of the respective chromosome, upon deleting that marker.
With <code>sex.sp=FALSE</code>, or for other types of crosses, there is one
additional column, with the change in estimated genetic length of the respective
chromosome, when the marker is omitted.
</p>
<p>A well behaved marker will have a negative LOD score and a small
change in estimated genetic length.  A poorly behaved marker will have a large
positive LOD score and a large change in estimated genetic length.  But note
that dropping the first or last marker on a chromosome could result in
a large change in estimated length, even if they are not badly
behaved; for these markers one should focus on the LOD scores, with a large
positive LOD score being bad.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code>tryallpositions</code>, <code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+ripple">ripple</a></code>,
<code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+switch.order">switch.order</a></code>,
<code><a href="#topic+movemarker">movemarker</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
droponemarker(fake.bc, 7, error.prob=0, verbose=FALSE)
</code></pre>

<hr>
<h2 id='effectplot'>Plot phenotype means against genotypes at one or two markers</h2><span id='topic+effectplot'></span>

<h3>Description</h3>

<p>Plot the phenotype means for each group defined by the genotypes at
one or two markers (or the values at a discrete covariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectplot(cross, pheno.col=1, mname1, mark1, geno1, mname2, mark2,
           geno2, main, ylim, xlab, ylab, col, add.legend=TRUE,
           legend.lab, draw=TRUE, var.flag=c("pooled","group"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effectplot_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
drawn in the plot.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_mname1">mname1</code></td>
<td>
<p>Name for the first marker or pseudomarker.
Pseudomarkers (that is, non-marker positions on the imputation grid)
may be referred to in a form like <code>"5@30.3"</code>, for position 30.3
on chromosome 5.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_mark1">mark1</code></td>
<td>
<p>Genotype data for the first marker.  If unspecified,
genotypes will be taken from the data in the input cross object,
using the name specified in <code>mname1</code>.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_geno1">geno1</code></td>
<td>
<p>Optional labels for the genotypes (or classes in a covariate).</p>
</td></tr>
<tr><td><code id="effectplot_+3A_mname2">mname2</code></td>
<td>
<p>Name for the second marker or pseudomarker (optional).</p>
</td></tr>
<tr><td><code id="effectplot_+3A_mark2">mark2</code></td>
<td>
<p>Like <code>mark1</code> (optional).</p>
</td></tr>
<tr><td><code id="effectplot_+3A_geno2">geno2</code></td>
<td>
<p>Optional labels for the genotypes (or classes in a covariate).</p>
</td></tr>
<tr><td><code id="effectplot_+3A_main">main</code></td>
<td>
<p>Optional figure title.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_ylim">ylim</code></td>
<td>
<p>Optional y-axis limits.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_xlab">xlab</code></td>
<td>
<p>Optional x-axis label.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_ylab">ylab</code></td>
<td>
<p>Optional y-axis label.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_col">col</code></td>
<td>
<p>Optional vector of colors for the different line segments.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_add.legend">add.legend</code></td>
<td>
<p>A logical value to indicate whether to add a legend.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_legend.lab">legend.lab</code></td>
<td>
<p>Optional title for the legend.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_draw">draw</code></td>
<td>
<p>A logical value to indicate generate the plot or not. If
FALSE, no figure will be plotted and this function can be used to
calculate the group means and standard errors.</p>
</td></tr>
<tr><td><code id="effectplot_+3A_var.flag">var.flag</code></td>
<td>
<p>The method to calculate the group variance. &quot;pooled&quot;
means to use the pooled variance and &quot;group&quot; means to calculate from
individual group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plot, the y-axis is the phenotype.  In the case of one marker,
the x-axis is the genotype for that marker. In the case of two
markers, the x-axis is for different genotypes of the second marker,
and the genotypes of first marker are represented by lines in
different colors.  Error bars are plotted at <code class="reqn">\pm</code> 1 SE.
</p>
<p>The results of <code>sim.geno</code> are used; if they are not available,
<code>sim.geno</code> is run with <code>n.draws=16</code>.  The average phenotype
for each genotype group takes account of missing genotype data by
averaging across the imputations.  The SEs take account of both the
residual phenotype variation and the imputation error.
</p>


<h3>Value</h3>

<p>A data.frame containing the phenotype means and standard errors
for each group.
</p>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotPXG">plotPXG</a></code>, <code><a href="#topic+find.marker">find.marker</a></code>,
<code><a href="#topic+effectscan">effectscan</a></code>, <code><a href="#topic+find.pseudomarker">find.pseudomarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)


# impute genotype data
## Not run: fake.f2 &lt;- sim.geno(fake.f2, step=5, n.draws=64)


########################################
# one marker plots
########################################
### plot of genotype-specific phenotype means for 1 marker
mname &lt;- find.marker(fake.f2, 1, 37) # marker D1M437
effectplot(fake.f2, pheno.col=1, mname1=mname)

### output of the function contains the means and SEs
output &lt;- effectplot(fake.f2, mname1=mname)
output

### plot a phenotype
# Plot of sex-specific phenotype means,
# note that "sex" must be a phenotype name here
effectplot(fake.f2, mname1="sex", geno1=c("F","M"))
# alternatively:
sex &lt;- pull.pheno(fake.f2, "sex")
effectplot(fake.f2, mname1="Sex", mark1=sex, geno1=c("F","M"))

########################################
# two markers plots
########################################

### plot two markers
# plot of genotype-specific phenotype means for 2 markers
mname1 &lt;- find.marker(fake.f2, 1, 37) # marker D1M437
mname2 &lt;- find.marker(fake.f2, 13, 24) # marker D13M254
effectplot(fake.f2, mname1=mname1, mname2=mname2)

### plot two pseudomarkers
#####  refer to pseudomarkers by their positions
effectplot(fake.f2, mname1="1@35", mname2="13@25")

#####  alternatively, find their names via find.pseudomarker
pmnames &lt;- find.pseudomarker(fake.f2, chr=c(1, 13), c(35, 25))
effectplot(fake.f2, mname1=pmnames[1], mname2=pmnames[2])

### Plot of sex- and genotype-specific phenotype means
mname &lt;- find.marker(fake.f2, 13, 24) # marker D13M254
# sex and a marker
effectplot(fake.f2, mname1=mname, mname2="Sex",
           mark2=sex, geno2=c("F","M"))

# Same as above, switch role of sex and the marker
# sex and marker
effectplot(fake.f2, mname1="Sex", mark1=sex,
           geno1=c("F","M"), mname2=mname)

# X chromosome marker
mname &lt;- find.marker(fake.f2, "X", 14) # marker DXM66
effectplot(fake.f2, mname1=mname)

# Two markers, including one on the X
mnames &lt;- find.marker(fake.f2, c(13, "X"), c(24, 14))
effectplot(fake.f2, mname1=mnames[1], mname2=mnames[2])
</code></pre>

<hr>
<h2 id='effectscan'>Plot estimated QTL effects across the whole genome</h2><span id='topic+effectscan'></span>

<h3>Description</h3>

<p>This function is used to plot the estimated QTL effects along
selected chromosomes. For a backcross, there will be only one line,
representing the additive effect. For an intercross, there will be two
lines, representing the additive and dominance effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectscan(cross, pheno.col=1, chr, get.se=FALSE, draw=TRUE,
           gap=25, ylim, mtick=c("line","triangle"),
           add.legend=TRUE, alternate.chrid=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effectscan_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which to be
drawn in the plot.  One may also give a character string matching
a phenotype name.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to be drawn in
the plot. This should be a vector of character strings referring to
chromosomes by name; numeric values are converted to strings.  Refer
to chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_get.se">get.se</code></td>
<td>
<p>If TRUE, estimated standard errors are calculated.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_draw">draw</code></td>
<td>
<p>If TRUE, draw the figure.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).</p>
</td></tr>
<tr><td><code id="effectscan_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits (optional).</p>
</td></tr>
<tr><td><code id="effectscan_+3A_mtick">mtick</code></td>
<td>
<p>Tick mark type for markers.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_add.legend">add.legend</code></td>
<td>
<p>If TRUE, add a legend.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="effectscan_+3A_...">...</code></td>
<td>
<p>Passed to the function <code>plot</code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of <code><a href="#topic+sim.geno">sim.geno</a></code> are required for taking
account of missing genotype information.
</p>
<p>For a backcross, the additive effect is estimated as the difference
between the phenotypic averages for heterozygotes and homozygotes.
</p>
<p>For recombinant inbred lines, the additive effect is estimated as half
the difference between the phenotypic averages for the two homozygotes.
</p>
<p>For an intercross, the additive and dominance effects are estimated
from linear regression on <code class="reqn">a</code> and <code class="reqn">d</code> with <code class="reqn">a</code> = -1, 0, 1,
for the AA, AB and BB genotypes, respectively, and <code class="reqn">d</code> = 0, 1, 0,
for the AA, AB and BB genotypes, respectively.
</p>
<p>As usual, the X chromosome is a bit more complicated.  We estimate
separate additive effects for the two sexes, and for the two
directions within females.
</p>
<p>There is an internal function <code>plot.effectscan</code> that creates
the actual plot by calling <code>plot.scanone</code>.  In the case
<code>get.se=TRUE</code>, colored regions indicate <code class="reqn">\pm</code> 1 SE.
</p>


<h3>Value</h3>

<p>The results are returned silently, as an object of class
<code>"effectscan"</code>, which is the same as the form returned by the
function <code><a href="#topic+scanone">scanone</a></code>, though with estimated effects
where LOD scores might be.  That is, it is a data frame with the first
two columns being chromosome ID and position (in cM), and subsequent
columns being estimated effects, and (if <code>get.se=TRUE</code>) standard
errors.
</p>


<h3>Author(s)</h3>

<p>Karl W. Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+effectplot">effectplot</a></code>, <code><a href="#topic+plotPXG">plotPXG</a></code>,
<code><a href="#topic+sim.geno">sim.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- sim.geno(fake.f2, step=2.5, n.draws=16)

# allelic effect on whole genome
effectscan(fake.f2)

# on chromosome 13, include standard errors
effectscan(fake.f2, chr="13", mtick="triangle", get.se=TRUE)
</code></pre>

<hr>
<h2 id='est.map'>Estimate genetic maps</h2><span id='topic+est.map'></span>

<h3>Description</h3>

<p>Uses the Lander-Green algorithm (i.e., the hidden Markov model
technology) to re-estimate the genetic map for an experimental cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.map(cross, chr, error.prob=0.0001,
        map.function=c("haldane","kosambi","c-f","morgan"),
        m=0, p=0, maxit=10000, tol=1e-6, sex.sp=TRUE,
        verbose=FALSE, omit.noninformative=TRUE, offset, n.cluster=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.map_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="est.map_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="est.map_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="est.map_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions. (Ignored if m &gt; 0.)</p>
</td></tr>
<tr><td><code id="est.map_+3A_m">m</code></td>
<td>
<p>Interference parameter for the chi-square model for
interference; a non-negative integer, with m=0 corresponding to no
interference. This may be used only for a backcross or intercross.</p>
</td></tr>
<tr><td><code id="est.map_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata from the NI mechanism, in the Stahl
model; p=0 gives a pure chi-square model.  This may be used only for
a backcross or intercross.</p>
</td></tr>
<tr><td><code id="est.map_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="est.map_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="est.map_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="est.map_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print tracing information.</p>
</td></tr>
<tr><td><code id="est.map_+3A_omit.noninformative">omit.noninformative</code></td>
<td>
<p>If TRUE, on each chromosome, omit individuals
with fewer than two typed markers, since they are not informative for
linkage.</p>
</td></tr>
<tr><td><code id="est.map_+3A_offset">offset</code></td>
<td>
<p>Defines the starting position
for each chromosome.  If missing, we use the starting positions that
are currently present in the input cross object.  This should be a
single value (to be used for all chromosomes) or a vector with length
equal to the number of chromosomes, defining individual starting
positions for each chromosome.  For a sex-specific map (as in a 4-way
cross), we use the same offset for both the male and female maps.</p>
</td></tr>
<tr><td><code id="est.map_+3A_n.cluster">n.cluster</code></td>
<td>
<p>If the package <code>snow</code> is available
calculations for multiple chromosomes are run in parallel using this
number of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the map is estimated assuming no crossover interference,
but a map function is used to derive the genetic distances (though, by
default, the Haldane map function is used).
</p>
<p>For a backcross or intercross, inter-marker distances may be estimated
using the Stahl model for crossover interference, of which the
chi-square model is a special case.
</p>
<p>In the chi-square model, points are tossed down onto the four-strand
bundle according to a Poisson process, and every <code class="reqn">(m+1)</code>st point is a
chiasma.  With the assumption of no chromatid interference, crossover
locations on a random meiotic product are obtained by thinning the
chiasma process.  The parameter <code class="reqn">m</code> (a non-negative integer)
governs the strength of crossover interference, with <code class="reqn">m=0</code>
corresponding to no interference.
</p>
<p>In the Stahl model, chiasmata on the four-strand bundle are a
superposition of chiasmata from two mechanisms, one following a
chi-square model and one exhibiting no interference.  An additional
parameter, <code class="reqn">p</code>, gives the proportion of chiasmata from the no
interference mechanism.
</p>


<h3>Value</h3>

<p>A <code>map</code> object; a list whose components (corresponding to
chromosomes) are either vectors of marker positions (in cM) or
matrices with two rows of sex-specific marker positions.
The maximized log likelihood for each chromosome is saved as an
attribute named <code>loglik</code>.  In the case that estimation was under
an interference model (with m &gt; 0), allowed only for a backcross, m
and p are also included as attributes.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Armstrong, N. J., McPeek, M. J. and Speed, T. P. (2006) Incorporating
interference into linkage analysis for experimental crosses.
<em>Biostatistics</em> <b>7</b>, 374&ndash;386.
</p>
<p>Lander, E. S. and Green, P. (1987) Construction of multilocus genetic linkage
maps in humans.  <em>Proc. Natl. Acad. Sci. USA</em> <b>84</b>, 2363&ndash;2367.
</p>
<p>Lange, K. (1999) <em>Numerical analysis for statisticians</em>.
Springer-Verlag. Sec 23.3.
</p>
<p>Rabiner, L. R. (1989) A tutorial on hidden Markov models and selected
applications in speech recognition.  <em>Proceedings of the IEEE</em>
<b>77</b>, 257&ndash;286.
</p>
<p>Zhao, H., Speed, T. P. and McPeek, M. S. (1995) Statistical analysis of
crossover interference using the chi-square model.  <em>Genetics</em>
<b>139</b>, 1045&ndash;1056.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+map2table">map2table</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>, <code><a href="#topic+replace.map">replace.map</a></code>,
<code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+fitstahl">fitstahl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

newmap &lt;- est.map(fake.f2)
logliks &lt;- sapply(newmap, attr, "loglik")
plotMap(fake.f2, newmap)
fake.f2 &lt;- replace.map(fake.f2, newmap)
</code></pre>

<hr>
<h2 id='est.rf'>Estimate pairwise recombination fractions</h2><span id='topic+est.rf'></span>

<h3>Description</h3>

<p>Estimate the sex-averaged recombination fraction between all pairs of
genetic markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.rf(cross, maxit=10000, tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.rf_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="est.rf_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the EM algorithm (not
used with backcrosses).</p>
</td></tr>
<tr><td><code id="est.rf_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence (not used with
backcrosses).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a backcross, one can simply count recombination events.  For an
intercross or 4-way cross, a version of the EM algorithm must be used
to estimate recombination fractions. (Since, for example, in an
intercross individual that is heterozygous at two loci, it is not
known whether there were 0 or 2 recombination events.)  Note that, for
the 4-way cross, we estimate sex-averaged recombination fractions.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component, <code>rf</code>,
added.  This is a matrix of size (tot.mar x tot.mar).  The diagonal
contains the number of typed meioses per marker, the lower triangle
contains the estimated recombination fractions, and the upper triangle
contains the LOD scores (testing rf = 0.5).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotRF">plotRF</a></code>, <code><a href="#topic+pull.rf">pull.rf</a></code>, <code><a href="#topic+plot.rfmatrix">plot.rfmatrix</a></code>,
<code><a href="#topic+est.map">est.map</a></code>,
<code><a href="#topic+badorder">badorder</a></code>, <code><a href="#topic+checkAlleles">checkAlleles</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
badorder &lt;- est.rf(badorder)
plotRF(badorder)
</code></pre>

<hr>
<h2 id='fake.4way'>Simulated data for a 4-way cross</h2><span id='topic+fake.4way'></span>

<h3>Description</h3>

<p>Simulated data for a phase-known 4-way cross, obtained using
<code><a href="#topic+sim.cross">sim.cross</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fake.4way)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 250 individuals typed at 157 markers, including 8 on the X
chromosome.
</p>
<p>There are two phenotypes (including sex, for which 0=female and 1=male).
The quantitative phenotype is affected by three QTLs: two on chromosome
2 at positions 10 and 25 cM on the female genetic map, and one on
chromosome 7 at position 40 cM on the female map.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="#topic+fake.bc">fake.bc</a></code>,
<code><a href="#topic+fake.f2">fake.f2</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+hyper">hyper</a></code>,
<code><a href="#topic+bristle3">bristle3</a></code>, <code><a href="#topic+bristleX">bristleX</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.4way)

plot(fake.4way)
summary(fake.4way)

# estimate recombination fractions
fake.4way &lt;- est.rf(fake.4way)
plotRF(fake.4way)

# estimate genetic maps
ssmap &lt;- est.map(fake.4way, verbose=TRUE)
samap &lt;- est.map(fake.4way, sex.sp=FALSE, verbose=TRUE)
plot(ssmap, samap)

# error lod scores
fake.4way &lt;- calc.genoprob(fake.4way, err=0.01)
fake.4way &lt;- calc.errorlod(fake.4way, err=0.01)
top.errorlod(fake.4way, cutoff=2.5)

# genome scan
fake.4way &lt;- calc.genoprob(fake.4way, step=2.5)
out.hk &lt;- scanone(fake.4way, method="hk")
out.em &lt;- scanone(fake.4way, method="em")
plot(out.em,out.hk,chr=c(2,7))
</code></pre>

<hr>
<h2 id='fake.bc'>Simulated data for a backcross</h2><span id='topic+fake.bc'></span>

<h3>Description</h3>

<p>Simulated data for a backcross, obtained using
<code><a href="#topic+sim.cross">sim.cross</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fake.bc)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 400 backcross individuals typed at 91 markers and with two
phenotypes and two covariates (sex and age).
</p>
<p>The two phenotypes are due to four QTLs, with no epistasis.  There is
one on chromosome 2 (at 30 cM), two on chromosome 5 (at 10 and 50 cM),
and one on chromosome 10 (at 30 cM).  The QTL on chromosome 2 has an
effect only in the males (sex=1); the two QTLs on chromosome 5 have
effect in coupling for the first phenotype and in repulsion for the
second phenotype. Age has an effect of increasing the phenotypes.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="#topic+fake.4way">fake.4way</a></code>,
<code><a href="#topic+fake.f2">fake.f2</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+hyper">hyper</a></code>,
<code><a href="#topic+bristle3">bristle3</a></code>, <code><a href="#topic+bristleX">bristleX</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

summary(fake.bc)
plot(fake.bc)

# genome scans without covariates
fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)
out.nocovar &lt;- scanone(fake.bc, pheno.col=1:2)

# genome scans with covariates
ac &lt;- pull.pheno(fake.bc, c("sex","age"))
ic &lt;- pull.pheno(fake.bc, "sex")
out.covar &lt;- scanone(fake.bc, pheno.col=1:2,
                      addcovar=ac, intcovar=ic)

# summaries
summary(out.nocovar, thr=3, format="allpeaks")
summary(out.covar, thr=3, format="allpeaks")

# plots
plot(out.nocovar, out.covar, chr=c(2,5,10), lod=1, col="blue",
     lty=1:2, ylim=c(0,13))
plot(out.nocovar, out.covar, chr=c(2,5,10), lod=2, col="red",
     lty=1:2, add=TRUE)
</code></pre>

<hr>
<h2 id='fake.f2'>Simulated data for an F2 intercross</h2><span id='topic+fake.f2'></span>

<h3>Description</h3>

<p>Simulated data for an F2 intercross, obtained using
<code><a href="#topic+sim.cross">sim.cross</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fake.f2)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 200 F2 individuals typed at 94 markers, including 3 on the X
chromosome.  There is one quantitative phenotype, along with an
indication of sex (0=female, 1=male) and the direction of the cross (pgm
= paternal grandmother, 0=A, meaning the cross was (AxB)x(AxB), and
1=B, meaning the cross was (AxB)x(BxA)).
</p>
<p>Note that the X chromosome genotypes are coded in a special way (see
<code><a href="#topic+read.cross">read.cross</a></code>).  For the individuals with pgm=0, sex=0,
1=AA and 2=AB; for individuals with pgm=0, sex=1, 1=A and 2=B
(hemizygous); for individuals with pgm=1, sex=0, 1=BB and 2=AB; for
individuals with pgm=1, sex=1, 1=A and 2=B.  <b>This requires special
care!</b>
</p>
<p>The data were simulated using an additive model with three QTLs on
chromosome 1 (at 30, 50 and 70 cM), one QTL on chromosome 13 (at 30
cM), and one QTL on the X chromosome (at 10 cM).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="#topic+fake.bc">fake.bc</a></code>,
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+hyper">hyper</a></code>,
<code><a href="#topic+bristle3">bristle3</a></code>, <code><a href="#topic+bristleX">bristleX</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
summary(fake.f2)
plot(fake.f2)
</code></pre>

<hr>
<h2 id='fill.geno'>Fill holes in genotype data</h2><span id='topic+fill.geno'></span>

<h3>Description</h3>

<p>Replace the genotype data for a cross with a version imputed either
by simulation with <code><a href="#topic+sim.geno">sim.geno</a></code>, by the Viterbi
algorithm with <code><a href="#topic+argmax.geno">argmax.geno</a></code>, or simply filling in
genotypes between markers that have matching genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill.geno(cross, method=c("imp","argmax", "no_dbl_XO", "maxmarginal"),
          error.prob=0.0001,
          map.function=c("haldane","kosambi","c-f","morgan"),
          min.prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill.geno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="fill.geno_+3A_method">method</code></td>
<td>
<p>Indicates whether to impute using a single simulation
replicate from <code><a href="#topic+sim.geno">sim.geno</a></code>, using the Viterbi
algorithm, as implemented in <code><a href="#topic+argmax.geno">argmax.geno</a></code>, by simply
filling in missing genotypes between markers with matching genotypes,
or by choosing (at each marker) the genotype with maximal marginal probability.</p>
</td></tr>
<tr><td><code id="fill.geno_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="fill.geno_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi or
Carter-Falconer map function when converting genetic distances into
recombination fractions.</p>
</td></tr>
<tr><td><code id="fill.geno_+3A_min.prob">min.prob</code></td>
<td>
<p>For <code>method="maxmarginal"</code>, genotypes with
probability greater than this value will be imputed; those less than
this value will be made missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is written so that one may perform rough genome scans by
marker regression without having to drop individuals with missing
genotype data.  <b>We must caution the user that little trust
should be placed in the results</b>.
</p>
<p>With <code>method="imp"</code>, a single random imputation is performed,
using <code><a href="#topic+sim.geno">sim.geno</a></code>.
</p>
<p>With <code>method="argmax"</code>, for each individual the most probable
sequence of genotypes, given the observed data (via
<code>argmax.geno</code>), is used.
</p>
<p>With <code>method="no_dbl_XO"</code>, non-recombinant intervals are filled
in; recombinant intervals are left missing. For example, a sequence of
genotypes like <code>A---A---H---H---A</code> (with <code>A</code> and <code>H</code>
corresponding to genotypes AA and AB, respectively, and with <code>-</code>
being a missing value) will be filled in as
<code>AAAAA---HHHHH---A</code>.
</p>
<p>With <code>method="maxmarginal"</code>, the conditional genotype
probabilities are calculated with <code>calc.genoprob</code>, and then at
each marker, the most probable genotype is determined. This is taken
as the imputed genotype if it has probability greater than
<code>min.prob</code>; otherwise it is made missing.
</p>
<p>With <code>method="no_dbl_XO"</code> and <code>method="maxmarginal"</code>,
some missing genotypes likely remain. With
<code>method="maxmarginal"</code>, some observed genotypes may be made
missing.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object with the genotype data replaced by an
imputed version.  Any intermediate calculations (such as is produced
by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>, <code><a href="#topic+argmax.geno">argmax.geno</a></code>
and <code><a href="#topic+sim.geno">sim.geno</a></code>) are removed.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.geno">sim.geno</a></code>,
<code><a href="#topic+argmax.geno">argmax.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

out.mr &lt;- scantwo(fill.geno(hyper,method="argmax"), method="mr")
plot(out.mr)
</code></pre>

<hr>
<h2 id='find_large_intervals'>Find large intervals in a map</h2><span id='topic+find_large_intervals'></span>

<h3>Description</h3>

<p>Find large inter-marker intervals in a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_large_intervals(map, min_length=35)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_large_intervals_+3A_map">map</code></td>
<td>
<p>A list of numeric vectors; each component is a chromosome
with the positions of markers on that chromosome. Can also
be an object of class <code>cross</code>, in which case
<code><a href="#topic+pull.map">pull.map</a></code> is used.</p>
</td></tr>
<tr><td><code id="find_large_intervals_+3A_min_length">min_length</code></td>
<td>
<p>Minimum length of interval to be flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with chromosome, left and right markers and interval length.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+summaryMap">summaryMap</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

find_large_intervals(fake.f2, 30)
</code></pre>

<hr>
<h2 id='find.flanking'>Find flanking markers for a specified position</h2><span id='topic+find.flanking'></span>

<h3>Description</h3>

<p>Find the genetic markers flanking a specified position on a
chromosome, as well as the marker that is closest to the specified
position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.flanking(cross, chr, pos)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.flanking_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.flanking_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosome identifiers, or a single such.</p>
</td></tr>
<tr><td><code id="find.flanking_+3A_pos">pos</code></td>
<td>
<p>A vector of cM positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame, each row corresponding to one of the input positions.
The first column contains the left-flanking markers, the second column
contains the right-flanking markers, and the third column contains the
markers closest to the specified positions.
</p>


<h3>Author(s)</h3>

<p>Brian Yandell</p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.marker">find.marker</a></code>, <code><a href="#topic+plotPXG">plotPXG</a></code>,
<code><a href="#topic+find.markerpos">find.markerpos</a></code>, <code><a href="#topic+find.pseudomarker">find.pseudomarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
find.flanking(listeria, 5, 28)
find.flanking(listeria, c(1, 5, 13), c(81, 28, 26))
</code></pre>

<hr>
<h2 id='find.marker'>Find marker closest to a specified position</h2><span id='topic+find.marker'></span>

<h3>Description</h3>

<p>Find the genetic marker closest to a specified position on a
chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.marker(cross, chr, pos, index)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.marker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.marker_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosome identifiers, or a single such.</p>
</td></tr>
<tr><td><code id="find.marker_+3A_pos">pos</code></td>
<td>
<p>A vector of cM positions.</p>
</td></tr>
<tr><td><code id="find.marker_+3A_index">index</code></td>
<td>
<p>A vector of numeric indices of the markers within
chromosomes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide one of <code>pos</code> or <code>index</code>.
</p>
<p>If the input <code>chr</code> has length one, it is expanded to the same
length as the input <code>pos</code> or <code>index</code>.
</p>
<p>If <code>pos</code> is specified and multiple markers are exactly the same
distance from the specified position, one is chosen at random from
among those with the most genotype data.
</p>
<p>For a cross with sex-specific maps, positions specified by <code>pos</code>
are assumed to correspond to the female genetic map.
</p>


<h3>Value</h3>

<p>A vector of marker names (of the same length as the input <code>pos</code>),
corresponding to the markers nearest to the specified
chromosomes/positions (if <code>pos</code> is specified) or to the input
numeric indices (in <code>index</code> is specified).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.flanking">find.flanking</a></code>, <code><a href="#topic+plotPXG">plotPXG</a></code>,
<code><a href="#topic+find.pseudomarker">find.pseudomarker</a></code>, <code><a href="#topic+effectplot">effectplot</a></code>,
<code><a href="#topic+find.markerpos">find.markerpos</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
find.marker(listeria, 5, 28)
find.marker(listeria, 5, index=6)
find.marker(listeria, c(1, 5, 13), c(81, 28, 26))
</code></pre>

<hr>
<h2 id='find.markerindex'>Determine the numeric index for a marker</h2><span id='topic+find.markerindex'></span>

<h3>Description</h3>

<p>Determine the numeric index for a marker in a cross object, when all
markers on all chromosomes are pasted together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.markerindex(cross, name)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.markerindex_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.markerindex_+3A_name">name</code></td>
<td>
<p>A vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric indices, from 1, 2, ..., <code>totmar(cross)</code>,
with <code>NA</code> for markers not found.
</p>


<h3>Author(s)</h3>

<p>Danny Arends; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.markerpos">find.markerpos</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
mar &lt;- find.marker(hyper, 4, 30)
find.markerindex(hyper, mar)
</code></pre>

<hr>
<h2 id='find.markerpos'>Find position of a marker</h2><span id='topic+find.markerpos'></span>

<h3>Description</h3>

<p>Find the chromosome and cM position of a set of genetic markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.markerpos(cross, marker)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.markerpos_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.markerpos_+3A_marker">marker</code></td>
<td>
<p>A vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: the chromosome and position of the
markers.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.flanking">find.flanking</a></code>, <code><a href="#topic+find.marker">find.marker</a></code>,
<code><a href="#topic+find.pseudomarker">find.pseudomarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
find.markerpos(hyper, "D4Mit164")
find.markerpos(hyper, c("D4Mit164", "D1Mit94"))
</code></pre>

<hr>
<h2 id='find.pheno'>Find column number for a particular phenotype</h2><span id='topic+find.pheno'></span>

<h3>Description</h3>

<p>Find the column number corresponding to a particular
phenotype name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.pheno(cross, pheno)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.pheno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.pheno_+3A_pheno">pheno</code></td>
<td>
<p>Vector of phenotype names (as character strings).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numbers, corresponding to the column numbers of the
phenotype in the input cross with the specified names.
</p>


<h3>Author(s)</h3>

<p>Brian Yandell</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
find.pheno(fake.bc, "sex")
</code></pre>

<hr>
<h2 id='find.pseudomarker'>Find the pseudomarker closest to a specified position</h2><span id='topic+find.pseudomarker'></span>

<h3>Description</h3>

<p>Find the pseudomarker closest to a specified position on a
chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.pseudomarker(cross, chr, pos, where=c("draws", "prob"), addchr=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.pseudomarker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="find.pseudomarker_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosome identifiers, or a single such.</p>
</td></tr>
<tr><td><code id="find.pseudomarker_+3A_pos">pos</code></td>
<td>
<p>A vector of cM positions.</p>
</td></tr>
<tr><td><code id="find.pseudomarker_+3A_where">where</code></td>
<td>
<p>Indicates whether to look in the <code>draws</code> or
<code>prob</code> components of the input cross.</p>
</td></tr>
<tr><td><code id="find.pseudomarker_+3A_addchr">addchr</code></td>
<td>
<p>If TRUE, include something like <code>"c5."</code> at the
beginning of the names of non-pseudomarker locations, as in the output
of <code><a href="#topic+scanone">scanone</a></code>; if FALSE, don't include this sort of string,
as in the genotype probabilities from <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input <code>chr</code> has length one, it is expanded to the same
length as the input <code>pos</code>.
</p>
<p>If multiple markers are exactly the same distance from the specified
position, one is chosen at random from among those with the most
genotype data.
</p>
<p>For a cross with sex-specific maps, the input positions are assumed to
correspond to the female genetic map.
</p>


<h3>Value</h3>

<p>A vector of pseudomarker names (of the same length as the input <code>pos</code>),
corresponding to the markers nearest to the specified chromosomes/positions.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.flanking">find.flanking</a></code>, <code><a href="#topic+plotPXG">plotPXG</a></code>,
<code><a href="#topic+effectplot">effectplot</a></code>, <code><a href="#topic+find.marker">find.marker</a></code>,
<code><a href="#topic+find.markerpos">find.markerpos</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria &lt;- calc.genoprob(listeria, step=2.5)
find.pseudomarker(listeria, 5, 28, "prob")
find.pseudomarker(listeria, c(1, 5, 13), c(81, 28, 26), "prob")
</code></pre>

<hr>
<h2 id='findDupMarkers'>Find markers with identical genotype data</h2><span id='topic+findDupMarkers'></span>

<h3>Description</h3>

<p>Identify sets of markers with identical genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findDupMarkers(cross, chr, exact.only=TRUE, adjacent.only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findDupMarkers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="findDupMarkers_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to consider.
This may be a logical, numeric, or character string vector.</p>
</td></tr>
<tr><td><code id="findDupMarkers_+3A_exact.only">exact.only</code></td>
<td>
<p>If TRUE, look only for markers that have matching
genotypes and the same pattern of missing data; if FALSE, also look for
cases where the observed genotypes at one marker match those at
another, and where the first marker has missing genotype whenever the
genotype for the second marker is missing.</p>
</td></tr>
<tr><td><code id="findDupMarkers_+3A_adjacent.only">adjacent.only</code></td>
<td>
<p>If TRUE, look only for sets of markers that are
adjacent to each other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>exact.only=TRUE</code>, we look only for groups of markers whose
pattern of missing data and observed genotypes match exactly.  One
marker (chosen at random) is selected as the name of the group (in the
output of the function).
</p>
<p>If <code>exact.only=FALSE</code>, we look also for markers whose observed genotypes
are contained in the observed genotypes of another marker.  We use a
pair of nested loops, working from the markers with the most observed
genotypes to the markers with the fewest observed genotypes.
</p>


<h3>Value</h3>

<p>A list of marker names; each component is a set of markers whose
genotypes match one other marker, and the name of the component is the
name of the marker that they match.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code>,
<code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+pickMarkerSubset">pickMarkerSubset</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- drop.nullmarkers(hyper)

dupmar &lt;- findDupMarkers(hyper) # finds 4 pairs
dupmar.adjonly &lt;- findDupMarkers(hyper, adjacent.only=TRUE) # finds 4 pairs

dupmar.nexact &lt;- findDupMarkers(hyper, exact.only=FALSE, adjacent.only=TRUE) # finds 6 pairs

# one might consider dropping the extra markers
totmar(hyper) # 173 markers
hyper &lt;- drop.markers(hyper, unlist(dupmar.adjonly))
totmar(hyper) # 169 markers
</code></pre>

<hr>
<h2 id='fitqtl'>Fit a multiple-QTL model</h2><span id='topic+fitqtl'></span>

<h3>Description</h3>

<p>Fits a user-specified multiple-QTL model.  If specified,
a drop-one-term analysis will be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitqtl(cross, pheno.col=1, qtl, covar=NULL, formula, method=c("imp", "hk"),
       model=c("normal", "binary"), dropone=TRUE, get.ests=FALSE,
       run.checks=TRUE, tol=1e-4, maxit=1000, forceXcovar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>, as output from
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are referred to as
<code>Q1</code>, <code>Q2</code>, etc.  Covariates are referred to by their names
in the data frame <code>covar</code>.  </p>
</td></tr>
<tr><td><code id="fitqtl_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_dropone">dropone</code></td>
<td>
<p>If TRUE, do drop-one-term analysis.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_get.ests">get.ests</code></td>
<td>
<p>If TRUE, return estimated QTL effects and their
estimated variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_run.checks">run.checks</code></td>
<td>
<p>If TRUE, check the input formula and check for
individuals with missing phenotypes or covariates.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="fitqtl_+3A_forcexcovar">forceXcovar</code></td>
<td>
<p>If TRUE, force inclusion of X-chr-related covariates
(like sex and cross direction).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect must also
be included.
</p>
<p>In the drop-one-term analysis, for a given QTL/covariate model, all
submodels will be analyzed.  For each term in the input formula, when
it is dropped, all higher order terms that contain it will also be
dropped.  The comparison between the new model and the full (input)
model will be output.
</p>
<p>The estimated percent variances explained for the QTL are simply
transformations of the conditional LOD scores by the formula <code class="reqn">h^2
  = 1 - 10^{-(2/n) {\rm LOD}}</code>.  While these may be reasonable for
unlinked, additive QTL, <b>they can be completely wrong in the case
of linked QTL</b>, but we don't currently have any alternative.
</p>
<p>For <code>model="binary"</code>, a logistic regression model is used.
</p>
<p><b>The part to get estimated QTL effects is not complete for the
case of the X chromosome and 4-way crosses.  The values returned in
these cases are based on a design matrix that is convenient for
calculations but not easily interpreted.</b>
</p>
<p>The estimated QTL effects for a backcross are derived by the coding
scheme <code class="reqn">\pm</code> 1/2 for AA and AB, so that the additive
effect corresponds to the difference between phenotype averages for
the two genotypes.  For doubled haploids and RIL, the coding scheme is
<code class="reqn">\pm</code> 1 for AA and BB, so that the additive effect
corresponds to half the difference between the phenotype averages for
the two homozygotes.
</p>
<p>For an intercross, the additive effect is derived from the coding
scheme -1/0/+1 for genotypes AA/AB/BB, and so is half the difference
between the phenotype averages for the two homozygotes.  The dominance
deviation is derived from the coding scheme 0/+1/0 for genotypes
AA/AB/BB, and so is the difference between the phenotype average for
the heterozygotes and the midpoint between the phenotype averages for
the two homozygotes.
</p>
<p>Epistatic effects and QTL <code class="reqn">\times</code> covariate interaction
effects are obtained through the products of the corresponding
additive/dominant effect columns.
</p>


<h3>Value</h3>

<p>An object of class <code>fitqtl</code>. It may contains as many as four components:
</p>

<ul>
<li> <p><code>result.full</code> is the ANOVA table as a matrix for the full model
result. It contains the degree of freedom (df), Sum of squares (SS),
mean square (MS), LOD score (LOD), percentage of variance explained
(%var) and P value (Pvalue).
</p>
</li>
<li> <p><code>lod</code> is the LOD score from the fit of the full model.
</p>
</li>
<li> <p><code>result.drop</code> is a drop-one-term ANOVA table as a
matrix. It contains degrees of freedom (df), Type III sum of squares
(Type III SS), LOD score(LOD), percentage of variance explained
(%var), F statistics (F value), and P values for chi square
(Pvalue(chi2)) and F distribution (Pvalue(F)).  Note that the degree
of freedom, Type III sum of squares, the LOD score and the
percentage of variance explained are the values comparing the full
to the sub-model with the term dropped. Also note that for
imputation method, the percentage of variance explained, the the F
values and the P values are approximations calculated from the LOD
score.
</p>
</li>
<li> <p><code>ests</code> contains the estimated QTL effects and standard errors.
</p>
</li></ul>

<p>When <code>method="normal"</code>, residuals are saved as an attribute of
the output, named <code>"residuals"</code> and accessible via the
<code><a href="base.html#topic+attr">attr</a></code> function.
</p>
<p><b>The part to get estimated QTL effects is fully working only for
the case of autosomes in a backcross, intercross, RIL or doubled haploids.
In other cases the values returned are based on a
design matrix that is convenient for calculations but not easily
interpreted.</b>
</p>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.fitqtl">summary.fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+addtoqtl">addtoqtl</a></code> ,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>,
<code><a href="#topic+replaceqtl">replaceqtl</a></code>,
<code><a href="#topic+reorderqtl">reorderqtl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 8, 13)
qp &lt;- c(26, 56, 28)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

# fit model with 3 interacting QTLs interacting
# (performing a drop-one-term analysis)
lod &lt;- fitqtl(fake.f2, pheno.col=1, qtl, formula=y~Q1*Q2*Q3, method="hk")
summary(lod)

## Not run: 
# fit an additive QTL model
lod.add &lt;- fitqtl(fake.f2, pheno.col=1, qtl, formula=y~Q1+Q2+Q3, method="hk")
summary(lod.add)

# fit the model including sex as an interacting covariate
Sex &lt;- data.frame(Sex=pull.pheno(fake.f2, "sex"))
lod.sex &lt;- fitqtl(fake.f2, pheno.col=1, qtl, formula=y~Q1*Q2*Q3*Sex,
                  cov=Sex, method="hk")
summary(lod.sex)

# fit the same with an additive model
lod.sex.add &lt;- fitqtl(fake.f2, pheno.col=1, qtl, formula=y~Q1+Q2+Q3+Sex,
                      cov=Sex, method="hk")
summary(lod.sex.add)

# residuals
residuals &lt;- attr(lod.sex.add, "residuals")
plot(residuals)

## End(Not run)</code></pre>

<hr>
<h2 id='fitstahl'>Fit Stahl interference model</h2><span id='topic+fitstahl'></span>

<h3>Description</h3>

<p>Fit the Stahl model for crossover inference (or the chi-square model,
which is a special case).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitstahl(cross, chr, m, p, error.prob=0.0001, maxit=4000, tol=1e-4,
         maxm=15, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitstahl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_m">m</code></td>
<td>
<p>Interference parameter (a non-negative integer); if
unspecified, this is estimated.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_p">p</code></td>
<td>
<p>The proportion of chiasmata coming from the no interference
mechanism in the Stahl model (0 &lt;= p &lt;= 1).  p=0 gives the chi-square
model.  If unspecified, this is estimated.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_error.prob">error.prob</code></td>
<td>
<p>The genotyping error probability.  If = NULL, it is
estimated.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_maxm">maxm</code></td>
<td>
<p>Maximum value of m to consider, if m is unspecified.</p>
</td></tr>
<tr><td><code id="fitstahl_+3A_verbose">verbose</code></td>
<td>
<p>Logical; indicates whether to print tracing information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently only available for backcrosses and
intercrosses.
</p>
<p>The Stahl model of crossover interference (of which the chi-square
model is a special case) is fit.      In the chi-square model, points
are tossed down onto the four-strand bundle according to a Poisson
process, and every <code class="reqn">(m+1)</code>st point is a chiasma.  With the
assumption of no chromatid interference, crossover locations on a
random meiotic product are obtained by thinning the chiasma process.
The parameter <code class="reqn">m</code> (a non-negative integer) governs the strength of
crossover interference, with <code class="reqn">m=0</code> corresponding to no
interference.
</p>
<p>In the Stahl model, chiasmata on the four-strand bundle are a
superposition of chiasmata from two mechanisms, one following a
chi-square model and one exhibiting no interference.  An additional
parameter, <code class="reqn">p</code>, gives the proportion of chiasmata from the no
interference mechanism.
</p>
<p>If all of <code>m</code>, <code>p</code>, and <code>error.prob</code> are specified, any
of them with length &gt; 1 must all have the same length.
</p>
<p>If <code>m</code> is unspecified, we do a grid search starting at 0 and stop
when the likelihood decreases (thus assuming a single mode), or
<code>maxm</code> is reached.
</p>


<h3>Value</h3>

<p>A matrix with four columns: m, p, error.prob, and the log likelihood.
</p>
<p>If specific values for m, p, error.prob are provided, the log
likelihood for each set are given.
</p>
<p>If some are left unspecified, the maximum likelihood estimates are
provided in the results.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Armstrong, N. J., McPeek, M. J. and Speed, T. P. (2006) Incorporating
interference into linkage analysis for experimental crosses.
<em>Biostatistics</em> <b>7</b>, 374&ndash;386.
</p>
<p>Zhao, H., Speed, T. P. and McPeek, M. S. (1995) Statistical analysis of
crossover interference using the chi-square model.  <em>Genetics</em>
<b>139</b>, 1045&ndash;1056.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+sim.cross">sim.cross</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate genetic map: one chromosome of length 200 cM with
# a 2 cM marker spacing
mymap &lt;- sim.map(200, 51, anchor.tel=TRUE, include.x=FALSE,
                 sex.sp=FALSE, eq.spacing=TRUE)

# Simulate data under the chi-square model, no errors
mydata &lt;- sim.cross(mymap, n.ind=250, type="bc",
                    error.prob=0, m=3, p=0)

# Fit the chi-square model for specified m's
## Not run: output &lt;- fitstahl(mydata, m=1:5, p=0, error.prob=0)

plot(output$m, output$loglik, lwd=2, type="b")

# Find the MLE of m in the chi-square model
## Not run: mle &lt;- fitstahl(mydata, p=0, error.prob=0)

## Not run: 
# Simulate data under the Stahl model, no errors
mydata &lt;- sim.cross(mymap, n.ind=250, type="bc",
                    error.prob=0, m=3, p=0.1)

# Find MLE of m for the Stahl model with known p
mle.stahl &lt;- fitstahl(mydata, p=0.1, error.prob=0)

# Fit the Stahl model with unknown p and m,
# get results for m=0, 1, 2, ..., 8
output &lt;- fitstahl(mydata, m=0:8, error.prob=0)
plot(output$m, output$loglik, type="b", lwd=2)
## End(Not run)
</code></pre>

<hr>
<h2 id='flip.order'>Flip the orders of markers on a set of chromosomes</h2><span id='topic+flip.order'></span>

<h3>Description</h3>

<p>Flip the orders of markers on a specified set of chromosome,
so that the markers will be in the reverse order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip.order(cross, chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip.order_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="flip.order_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosomes to flip. This should be a
vector of character strings referring to chromosomes by name. A logical
(TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the cross contains results from <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+argmax.geno">argmax.geno</a></code>, or
<code><a href="#topic+calc.errorlod">calc.errorlod</a></code>, those results are also updated.
</p>
<p>Results of <code><a href="#topic+est.rf">est.rf</a></code> and <code><a href="#topic+markerlrt">markerlrt</a></code> are
deleted.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object, but with the marker order on the
specified chromosomes flipped.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+switch.order">switch.order</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- flip.order(fake.f2, c(1, 5, 13))
</code></pre>

<hr>
<h2 id='formLinkageGroups'>Partition markers into linkage groups</h2><span id='topic+formLinkageGroups'></span>

<h3>Description</h3>

<p>Use pairwise linkage information between markers (as calculated by
<code><a href="#topic+est.rf">est.rf</a></code> to partition markers into linkage groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formLinkageGroups(cross, max.rf=0.25, min.lod=3, reorgMarkers=FALSE,
                  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formLinkageGroups_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="formLinkageGroups_+3A_max.rf">max.rf</code></td>
<td>
<p>Maximum recombination fraction for placing two markers in
the same linkage group (see Details).</p>
</td></tr>
<tr><td><code id="formLinkageGroups_+3A_min.lod">min.lod</code></td>
<td>
<p>Minimum LOD score for placing two markers in the same
linkage group (see Details).</p>
</td></tr>
<tr><td><code id="formLinkageGroups_+3A_reorgmarkers">reorgMarkers</code></td>
<td>
<p>If TRUE, the output is a cross object, like the
input, but with the markers organized into the inferred linkage
groups.  If FALSE, the output is a table indicating the initial
chromosome assignments and the inferred linkage group partitions.</p>
</td></tr>
<tr><td><code id="formLinkageGroups_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of the
calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two markers are placed in the same linkage group if the estimated
recombination fraction between them is <code class="reqn">\le</code> <code>max.rf</code> and
the LOD score (for the test of the rec. frac. = 1/2) is <code class="reqn">\ge</code>
<code>min.lod</code>.  The transitive property (if A is linked to B and B is
linked to C then A is linked to C) is used to close the groups.
</p>


<h3>Value</h3>

<p>If <code>reorgMarkers=FALSE</code> (the default), the output is a data frame
with rows corresponding to the markers and with two columns: the
initial chromosome assignment and the inferred linkage group.  Linkage
groups are ordered by the number of markers they contain (from largest
to smallest).
</p>
<p>If <code>reorgMarkers=TRUE</code>, the output is a cross object, like the
input, but with the markers reorganized into the inferred linkage
groups.  The marker order and marker positions within the linkage
groups are arbitrary.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+orderMarkers">orderMarkers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria &lt;- est.rf(listeria)
result &lt;- formLinkageGroups(listeria)
tab &lt;- table(result[,1], result[,2])
apply(tab, 1, function(a) sum(a!=0))
apply(tab, 2, function(a) sum(a!=0))
</code></pre>

<hr>
<h2 id='formMarkerCovar'>Create matrix of marker covariates for QTL analysis</h2><span id='topic+formMarkerCovar'></span>

<h3>Description</h3>

<p>Pull out a matrix of genotypes or genotype probabilities to use
markers as covariates in QTL analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formMarkerCovar(cross, markers, method=c("prob", "imp", "argmax"), ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formMarkerCovar_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="formMarkerCovar_+3A_markers">markers</code></td>
<td>
<p>A vector of character strings of marker or pseudomarker
names. Pseudomarker names may be of the form <code>"5@21.5"</code> (for chr 5
at 21.5 cM), but then all names must be of this form.</p>
</td></tr>
<tr><td><code id="formMarkerCovar_+3A_method">method</code></td>
<td>
<p>If <code>method="prob"</code>, the genotype probabilities from
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> are used; otherwise we use
<code><a href="#topic+fill.geno">fill.geno</a></code> to impute missing data, with this method.</p>
</td></tr>
<tr><td><code id="formMarkerCovar_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+fill.geno">fill.geno</a></code>, if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing genotype probabilities or genotype indicators,
suitable for use as covariates in <code><a href="#topic+scanone">scanone</a></code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.geno">pull.geno</a></code>, <code><a href="#topic+pull.genoprob">pull.genoprob</a></code>,
<code><a href="#topic+fill.geno">fill.geno</a></code>, <code><a href="#topic+scanone">scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper &lt;- calc.genoprob(hyper, step=0)
peakMarker &lt;- "D4Mit164"
X &lt;- formMarkerCovar(hyper, peakMarker)

out &lt;- scanone(hyper, addcovar=X)
</code></pre>

<hr>
<h2 id='geno.crosstab'>Create table of two-locus genotypes</h2><span id='topic+geno.crosstab'></span>

<h3>Description</h3>

<p>Create a cross tabulation of the genotypes at a pair of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.crosstab(cross, mname1, mname2, eliminate.zeros=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno.crosstab_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="geno.crosstab_+3A_mname1">mname1</code></td>
<td>
<p>The name of the first marker (as a character
string). (Alternatively, a vector with the two character strings, in
which case <code>mname2</code> should not be given.)</p>
</td></tr>
<tr><td><code id="geno.crosstab_+3A_mname2">mname2</code></td>
<td>
<p>The name of the second marker (as a character string).</p>
</td></tr>
<tr><td><code id="geno.crosstab_+3A_eliminate.zeros">eliminate.zeros</code></td>
<td>
<p>If TRUE, don't show the rows and columns that
have no data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the number of individuals having each possible
pair of genotypes.  Genotypes for the first marker are in the rows;
genotypes for the second marker are in the columns.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+geno.table">geno.table</a></code>,
<code><a href="#topic+find.marker">find.marker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
geno.crosstab(hyper, "D1Mit123", "D1Mit156")
geno.crosstab(hyper, "DXMit22", "DXMit16")
geno.crosstab(hyper, c("DXMit22", "DXMit16"))
</code></pre>

<hr>
<h2 id='geno.image'>Plot grid of genotype data</h2><span id='topic+geno.image'></span>

<h3>Description</h3>

<p>Plot a grid showing which the genotype data in a cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.image(x, chr, reorder=FALSE, main="Genotype data",
           alternate.chrid=FALSE, col=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno.image_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details. </p>
</td></tr>
<tr><td><code id="geno.image_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to be drawn in
the plot. This should be a vector of character strings referring to
chromosomes by name; numeric values are converted to strings.  Refer
to chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="geno.image_+3A_reorder">reorder</code></td>
<td>
<p>Specify whether to reorder individuals according to
their phenotypes.
</p>

<table>
<tr>
 <td style="text-align: left;">
    FALSE </td><td style="text-align: left;"> Don't reorder </td>
</tr>
<tr>
 <td style="text-align: left;">
    TRUE  </td><td style="text-align: left;"> Reorder according to the sum of the phenotypes </td>
</tr>
<tr>
 <td style="text-align: left;">
    n </td><td style="text-align: left;"> Reorder according to phenotype n</td>
</tr>

</table>
</td></tr>
<tr><td><code id="geno.image_+3A_main">main</code></td>
<td>
<p>Title to place on plot.</p>
</td></tr>
<tr><td><code id="geno.image_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="geno.image_+3A_col">col</code></td>
<td>
<p>Vector of colors. The first is for missing genotypes,
followed by colors for each of the genotypes. If <code>NULL</code>, a
default set of colors are used.</p>
</td></tr>
<tr><td><code id="geno.image_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+image">image</a></code> to plot a grid with the genotype
data.  The genotypes AA, AB, BB are displayed in the colors red, blue,
and green, respectively.  In an intercross, if there are genotypes
&quot;not BB&quot; and &quot;not AA&quot;, these are displayed in purple and orange,
respectively.  White pixels indicate missing data.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+plotMissing">plotMissing</a></code>, <code><a href="#topic+plotGeno">plotGeno</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
geno.image(listeria)
</code></pre>

<hr>
<h2 id='geno.table'>Create table of genotype distributions</h2><span id='topic+geno.table'></span>

<h3>Description</h3>

<p>Create table showing the observed numbers of individuals with each
genotype at each marker, including P-values from chi-square tests
for Mendelian segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.table(cross, chr, scanone.output=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno.table_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="geno.table_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="geno.table_+3A_scanone.output">scanone.output</code></td>
<td>
<p>If TRUE, give result in the form output by
<code><a href="#topic+scanone">scanone</a></code>, so that one may use <code><a href="#topic+plot.scanone">plot.scanone</a></code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The P-values are obtained from chi-square tests of Mendelian
segregation.  In the case of the X chromosome, the sexes and cross
directions are tested separately, and the chi-square statistics
combined, and so the test is of whether any of the groups show
deviation from Mendel's rules.
</p>


<h3>Value</h3>

<p>If <code>scanone.output=FALSE</code>, the output is a matrix containing, for
each marker, the number of individuals with each possible genotype, as
well as the number that were not typed.  The first column gives the
chromosome ID, and the last column gives P-values from chi-square
tests of Mendelian segregation.
</p>
<p>If <code>scanone.output=TRUE</code>, the output is of the form produced by
<code><a href="#topic+scanone">scanone</a></code>, with the first two columns being chromosome IDs
and cM positions of the markers.  The third column is
<code class="reqn">-\log_{10}(P)</code> from chi-square tests of Mendelian
segregation.  The fourth column is the proportion of missing data.
The remaining columns are the proportions of the different genotypes
(among typed individuals).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
geno.table(listeria)

geno.table(listeria, chr=13)

gt &lt;- geno.table(listeria)
gt[gt$P.value &lt; 0.01,]

out &lt;- geno.table(listeria, scanone.output=TRUE)
plot(out)
plot(out, lod=2)
</code></pre>

<hr>
<h2 id='getid'>Pull out the individual identifiers from a cross</h2><span id='topic+getid'></span>

<h3>Description</h3>

<p>Pull out the individual identifiers from a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getid(cross)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getid_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of individual identifiers, pulled from the phenotype data (a
column named <code>id</code> or <code>ID</code>).
</p>
<p>If there are no such identifiers in the cross, the function returns
<code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+subset.cross">subset.cross</a></code>, <code><a href="#topic+top.errorlod">top.errorlod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# create an ID column
fake.f2$pheno$id &lt;- paste("ind", sample(nind(fake.f2)), sep="")

getid(fake.f2)
</code></pre>

<hr>
<h2 id='groupclusteredheatmap'>Retrieving groups of traits after clustering</h2><span id='topic+groupclusteredheatmap'></span>

<h3>Description</h3>

<p>Retrieving groups of clustered traits from the output of mqmplot.clusteredheatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  groupclusteredheatmap(cross, clusteredheatmapresult, height)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupclusteredheatmap_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="groupclusteredheatmap_+3A_clusteredheatmapresult">clusteredheatmapresult</code></td>
<td>
<p> Resultint dendrogram object from <code><a href="#topic+mqmplot.clusteredheatmap">mqmplot.clusteredheatmap</a></code> </p>
</td></tr>
<tr><td><code id="groupclusteredheatmap_+3A_height">height</code></td>
<td>
<p> Height at which to 'cut' the dendrogram, a higher cut-off gives less but larger groups.
Height represents the maximum distance between two traits clustered together using hclust. the 'normal'
behaviour of bigger groups when using a higher heigh cut-off depends on the tree stucture and the amount
of traits clustered using <code><a href="#topic+mqmplot.clusteredheatmap">mqmplot.clusteredheatmap</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing groups of traits which were clustered together with a distance less that <code>height</code>
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

multitrait &lt;- fill.geno(multitrait) # impute missing genotype data
result &lt;- mqmscanall(multitrait, logtransform=TRUE)
cresults &lt;- mqmplot.clusteredheatmap(multitrait,result)
groupclusteredheatmap(multitrait,cresults,10)
</code></pre>

<hr>
<h2 id='hyper'>Data on hypertension</h2><span id='topic+hyper'></span>

<h3>Description</h3>

<p>Data from an experiment on hypertension in the mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hyper)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 250 male backcross individuals typed at 174 markers (actually one
contains only missing values), including 4 on the X chromosome, with one
phenotype.
</p>
<p>The phenotype is the blood pressure.  See the reference below.  Note
that, for most markers, genotypes are available on only the individuals
with extreme phenotypes.  At many markers, only recombinant individuals
were typed.
</p>


<h3>Source</h3>

<p>Bev Paigen and Gary Churchill (The Jackson Laboratory, Bar Harbor,
Maine)
<a href="https://phenome.jax.org/projects/Sugiyama2">https://phenome.jax.org/projects/Sugiyama2</a>
</p>


<h3>References</h3>

<p>Sugiyama, F., Churchill, G. A., Higgens, D. C., Johns, C.,
Makaritsis, K. P., Gavras, H. and Paigen, B. (2001) Concordance of
murine quantitative trait loci for salt-induced hypertension with rat
and human loci. <em>Genomics</em> <b>71</b>, 70&ndash;77.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fake.bc">fake.bc</a></code>, <code><a href="#topic+fake.f2">fake.f2</a></code>,
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+listeria">listeria</a></code>,
<code><a href="#topic+bristle3">bristle3</a></code>, <code><a href="#topic+bristleX">bristleX</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
summary(hyper)
plot(hyper)

# Note the selective genotyping
## Not run: plotMissing(hyper, reorder=TRUE)

# A marker on c14 has no data; remove it
hyper &lt;- drop.nullmarkers(hyper)
</code></pre>

<hr>
<h2 id='inferFounderHap'>Crude reconstruction of founder haplotypes in multi-parent RIL</h2><span id='topic+inferFounderHap'></span>

<h3>Description</h3>

<p>Uses groups of adjacent markers to infer the founder haplotypes in SNP
data on multi-parent recombinant inbred lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferFounderHap(cross, chr, max.n.markers=15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferFounderHap_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="inferFounderHap_+3A_chr">chr</code></td>
<td>
<p>Indicator of chromosome to consider.  If multiple
chromosomes are selected, only the first is used.</p>
</td></tr>
<tr><td><code id="inferFounderHap_+3A_max.n.markers">max.n.markers</code></td>
<td>
<p>Maximum number of adjacent markers to consider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We omit SNPs for which any of the founders are missing.
</p>
<p>We then consider groups of adjacent SNPs, looking for founder
haplotypes that are unique; RIL sharing such a unique haplotype are
then inferred to have that founder's DNA.
</p>
<p>We consider each marker as the center of a haplotype, and consider
haplotypes of size 1, 3, 5, ..., <code>max.n.markers</code>.  We end the
extension of the haplotypes when all founders have a unique haplotype.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>nind(cross)</code> <code class="reqn">\times</code> no. markers,
with the inferred founder origin for each line at each marker.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+fill.geno">fill.geno</a></code>, <code><a href="#topic+argmax.geno">argmax.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>map &lt;- sim.map(100, n.mar=101, include.x=FALSE, eq.spacing=TRUE)
founderGeno &lt;- simFounderSnps(map, "8")
ril &lt;- sim.cross(map, n.ind=10, type="ri8sib", founderGeno=founderGeno)

h &lt;- inferFounderHap(ril, max.n.markers=11)
mean(!is.na(h)) # proportion inferred
plot(map[[1]], h[1,], ylim=c(0.5, 8.5), xlab="Position", ylab="Genotype")
</code></pre>

<hr>
<h2 id='inferredpartitions'>Identify inferred partitions in mapping QTL to a phylogenetic tree</h2><span id='topic+inferredpartitions'></span>

<h3>Description</h3>

<p>Identify the inferred partitions for a chromosome from the results of scanPhyloQTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferredpartitions(output, chr, lodthreshold, probthreshold=0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferredpartitions_+3A_output">output</code></td>
<td>
<p>An object output by the function
<code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.</p>
</td></tr>
<tr><td><code id="inferredpartitions_+3A_chr">chr</code></td>
<td>
<p>A character string indicating the chromosome to
consider. (It can also be a number, but it's then converted to a
character string.)</p>
</td></tr>
<tr><td><code id="inferredpartitions_+3A_lodthreshold">lodthreshold</code></td>
<td>
<p>LOD threshold; if maximum LOD score is less than
this, the null model is considered.</p>
</td></tr>
<tr><td><code id="inferredpartitions_+3A_probthreshold">probthreshold</code></td>
<td>
<p>Threshold on posterior probabilities.  See Details
below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a single chromosome, and take the maximum LOD score for
each partition on that chromosome.  The presence of a QTL is inferred
if at least one partition has LOD score greater than
<code>lodthreshold</code>.  In this case, we then convert the LOD scores for
the partitions to approximate posterior probabilities by taking
<code class="reqn">10^{LOD}</code> and then rescaling them to sum to 1.
These are sorted from largest to smallest, and we
then take as the inferred partitions the smallest set whose posterior
probabilities cumulatively add up to at least <code>probthreshold</code>.
</p>


<h3>Value</h3>

<p>A vector of character strings.  If the null model (no QTL) is
inferred, the output is <code>"null"</code>.  Otherwise, it is the set of
inferred partitions.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>, <code><a href="#topic+plot.scanPhyloQTL">plot.scanPhyloQTL</a></code>,
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>, <code><a href="#topic+max.scanPhyloQTL">max.scanPhyloQTL</a></code>,
<code><a href="#topic+simPhyloQTL">simPhyloQTL</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]


# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
## Not run: x &lt;- lapply(x, calc.genoprob, step=2)


# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# inferred partitions
inferredpartitions(out, chr=3, lodthreshold=3)

# inferred partitions with prob'y threshold = 0.95
inferredpartitions(out, chr=3, lodthreshold=3, probthreshold=0.95)
</code></pre>

<hr>
<h2 id='interpPositions'>Interpolate positions from one map to another</h2><span id='topic+interpPositions'></span>

<h3>Description</h3>

<p>On the basis of a pair of marker maps with common markers, take
positions along one map and interpolate (or, past the terminal markers
on a chromosome, extrapolate) their positions on the second map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpPositions(oldpositions, oldmap, newmap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpPositions_+3A_oldpositions">oldpositions</code></td>
<td>
<p>A data frame with two columns: <code>chr</code>
(chromosome identifiers) and
<code>pos</code> (positions, along <code>oldmap</code>).</p>
</td></tr>
<tr><td><code id="interpPositions_+3A_oldmap">oldmap</code></td>
<td>
<p>An object of class <code>"map"</code>; see
<code><a href="#topic+sim.map">sim.map</a></code> for details.</p>
</td></tr>
<tr><td><code id="interpPositions_+3A_newmap">newmap</code></td>
<td>
<p>An object of class <code>"map"</code>, with the same
chromosomes and markers as <code>oldmap</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this explanation, take <code>oldmap</code> and <code>newmap</code> to be the
physical and genetic maps, respectively.
</p>
<p>We use linear interpolation within each interval, assuming a constant
recombination rate within the interval.  Past the terminal
markers, we use linear extrapolation, using the chromosome-wide average
recombination rate.
</p>


<h3>Value</h3>

<p>The input data frame, <code>oldpositions</code>, with an additional
column <code>newpos</code> with the interpolated positions along
<code>newmap</code>.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+shiftmap">shiftmap</a></code>, <code><a href="#topic+rescalemap">rescalemap</a></code>, <code><a href="#topic+pull.map">pull.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

# hyper genetic map
gmap &lt;- pull.map(hyper)

# a fake physical map, with each chromosome starting at 0.
pmap &lt;- shiftmap(rescalemap(gmap, 2))

# positions on pmap to determine location on gmap
tofind &lt;- data.frame(chr=c(1, 5, 17, "X"), pos=c(220, 20, 105, 10))
rownames(tofind) &lt;- paste("loc", 1:nrow(tofind), sep="")

interpPositions(tofind, pmap, gmap)
</code></pre>

<hr>
<h2 id='jittermap'>Jitter marker positions in a genetic map</h2><span id='topic+jittermap'></span>

<h3>Description</h3>

<p>Jitter the marker positions in a genetic map so that no two markers
are on top of each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jittermap(object, amount=1e-6)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jittermap_+3A_object">object</code></td>
<td>
<p>Either a cross (an object of class <code>cross</code>; see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or a map (an object of
class <code>map</code>; see <code><a href="#topic+pull.map">pull.map</a></code> for details).</p>
</td></tr>
<tr><td><code id="jittermap_+3A_amount">amount</code></td>
<td>
<p>The amount by which markers should be moved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the input cross object or the input map, but with marker
positions slightly jittered.  If the input was a cross, the function
<code><a href="#topic+clean.cross">clean</a></code> is run to strip off any intermediate
calculations.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+replace.map">replace.map</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper &lt;- jittermap(hyper)
</code></pre>

<hr>
<h2 id='listeria'>Data on Listeria monocytogenes susceptibility</h2><span id='topic+listeria'></span>

<h3>Description</h3>

<p>Data from an experiment on susceptibility to <em>Listeria
monocytogenes</em> infection in the mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(listeria)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p>There are 120 F2 individuals typed at 133 markers, including 2 on the
X chromosome, with one phenotype.
</p>
<p>The phenotype is the survival time (in hours) following infection.
Mice with phenotype 264 hours may be considered to have recovered
from the infection. See the references below.
</p>


<h3>Source</h3>

<p>Victor Boyartchuk and William Dietrich (Department of Genetics,
Harvard Medical School and Howard Hughes Medical Institute)
</p>


<h3>References</h3>

<p>Boyartchuk, V. L., Broman, K. W., Mosher, R. E., D'Orazio
S. E. F., Starnbach, M. N. and Dietrich, W. F. (2001) Multigenic
control of <em>Listeria monocytogenes</em> susceptibility in
mice. <em>Nature Genetics</em> <b>27</b>, 259&ndash;260.
</p>
<p>Broman,  K. W. (2003) Mapping quantitative trait loci in the case of a
spike in the phenotype distribution. <em>Genetics</em> <b>163</b>,
1169&ndash;1175.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fake.bc">fake.bc</a></code>, <code><a href="#topic+fake.f2">fake.f2</a></code>,
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+hyper">hyper</a></code>,
<code><a href="#topic+bristle3">bristle3</a></code>, <code><a href="#topic+bristleX">bristleX</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

# Summaries
summary(listeria)
plot(listeria)

# Take log of phenotype
listeria$pheno[,1] &lt;- log2(listeria$pheno[,1])
plot(listeria)

# Genome scan with a two-part model, using log survival
listeria &lt;- calc.genoprob(listeria, step=2)
out &lt;- scanone(listeria, model="2part", method="em",
               upper=TRUE)

# Summary of the results
summary(out, thr=c(5,3,3), format="allpeaks")

# Plot LOD curves for interesting chromosomes
#     (The two-part model gives three LOD scores)
plot(out, chr=c(1,5,6,13,15), lodcolumn=1:3,
     lty=1, col=c("black","red","blue"))
</code></pre>

<hr>
<h2 id='locateXO'>Estimate locations of crossovers</h2><span id='topic+locateXO'></span>

<h3>Description</h3>

<p>Estimate the locations of crossovers for each individual on a given
chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locateXO(cross, chr, full.info=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locateXO_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="locateXO_+3A_chr">chr</code></td>
<td>
<p>Chromosome to investigate (if unspecified, the first
chromosome is considered).
This should be a character string referring to a chromosome
by name; numeric values are converted to strings.</p>
</td></tr>
<tr><td><code id="locateXO_+3A_full.info">full.info</code></td>
<td>
<p>If TRUE, output will include information on the left
and right endpoints of the intervals to which recombination events
are known, as well as the corresponding marker indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each individual we detemine the locations of obligate crossovers,
and estimate their location to be at the midpoint between the nearest
flanking typed markers.
</p>
<p>The function currently only works for a backcross, intercross, or
recombinant inbred line.
</p>


<h3>Value</h3>

<p>A list with one component per individual.  Each component is either
NULL or is a numeric vector with the estimated crossover locations.
</p>
<p>If <code>full.info=TRUE</code>, in place of a numeric vector with estimated
locations, there is a matrix that includes those locations, the left
and right endpoints of the intervals to which crossovers can be
placed, the marker indices corresponding to those endpoint, and
genotype codes for the genotypes to the left and right of each crossover.  The
final column indicates the number of typed markers between the current
crossover and the next one (useful for identifying potential
genotyping errors).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+countXO">countXO</a></code>, <code><a href="#topic+cleanGeno">cleanGeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
xoloc &lt;- locateXO(hyper, chr=4)
table(sapply(xoloc, length))
</code></pre>

<hr>
<h2 id='locations'>
Genetic locations of traits for the multitrait dataset
</h2><span id='topic+locations'></span>

<h3>Description</h3>

<p>A table with genetic locations of the traits in the <code><a href="#topic+multitrait">multitrait</a></code> dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(locations)</code></pre>


<h3>Format</h3>

<p>Each row is a trait with the following information:
<code>Name</code>,	Name of the trait (will be checked against the name in the cross object
<code>Chr</code>,		Chromosome of the trait
<code>cM</code>,		Location in cM from the start of the chromosome
</p>


<h3>Source</h3>

<p>Additional information from the Arabidopsis RIL selfing experiment with Landsberg erecta (Ler) and Cape Verde Islands (Cvi) with 162 individuals scored (with errors at) 117 markers.
Dataset obtained from GBIC - Groningen BioInformatics Centre
</p>


<h3>References</h3>


<ul>
<li><p> Keurentijes JJB, Fu J, de Vos CHR,Lommen A, Jansen RC et al
(2006), The genetics of plant metabolism. <em>Nature Genetics</em>
<b>38</b>, 842&ndash;849.
</p>
</li>
<li><p> Alonso-Blanco C., Peeters, A. J. and Koornneef, M. (2006)
Development of an AFLP based linkage map of Ler, Col and Cvi
Arabidopsis thaliana ecotypes and construction of a Ler/Cvi recombinant
inbred line population. <em>Plant J.</em> <b>14</b>(2), 259&ndash;271.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+multitrait">multitrait</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(multitrait)
    data(locations)
    multiloc &lt;- addloctocross(multitrait,locations)
    results &lt;- scanall(multiloc)
    mqmplot.cistrans(results,multiloc, 5, FALSE, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='lodint'>LOD support interval</h2><span id='topic+lodint'></span>

<h3>Description</h3>

<p>Calculate a LOD support interval for a particular chromosome,
using output from scanone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lodint(results, chr, qtl.index, drop=1.5, lodcolumn=1, expandtomarkers=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lodint_+3A_results">results</code></td>
<td>
<p>Output from <code><a href="#topic+scanone">scanone</a></code>, or a qtl object
as output from <code><a href="#topic+refineqtl">refineqtl</a></code>.</p>
</td></tr>
<tr><td><code id="lodint_+3A_chr">chr</code></td>
<td>
<p>A chromosome ID (if input <code>results</code> are from
<code><a href="#topic+scanone">scanone</a></code> (should have length 1).</p>
</td></tr>
<tr><td><code id="lodint_+3A_qtl.index">qtl.index</code></td>
<td>
<p>Numeric index for a QTL (if input <code>results</code> are
from <code><a href="#topic+refineqtl">refineqtl</a></code> (should have length 1).</p>
</td></tr>
<tr><td><code id="lodint_+3A_drop">drop</code></td>
<td>
<p>LOD units to drop to form the interval.</p>
</td></tr>
<tr><td><code id="lodint_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer indicating which
of the LOD score columns should be considered (if input
<code>results</code> are from <code><a href="#topic+scanone">scanone</a></code>).</p>
</td></tr>
<tr><td><code id="lodint_+3A_expandtomarkers">expandtomarkers</code></td>
<td>
<p>If TRUE, the interval is expanded to the nearest
flanking markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scanone</code> indicating the
estimated QTL position and the approximate endpoints
for the LOD support interval.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+bayesint">bayesint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- calc.genoprob(hyper, step=0.5)
out &lt;- scanone(hyper, method="hk")
lodint(out, chr=1)
lodint(out, chr=4)
lodint(out, chr=4, drop=2)
lodint(out, chr=4, expandtomarkers=TRUE)
</code></pre>

<hr>
<h2 id='makeqtl'>Make a qtl object</h2><span id='topic+makeqtl'></span>

<h3>Description</h3>

<p>This function takes a cross object and specified chromosome numbers
and positions and pulls out the genotype probabilities or imputed
genotypes at the nearest pseudomarkers, for later use by the function
<code><a href="#topic+fitqtl">fitqtl</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeqtl(cross, chr, pos, qtl.name, what=c("draws","prob"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="makeqtl_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosome for each QTL. (These should
be character strings referring to the chromosomes by name.)</p>
</td></tr>
<tr><td><code id="makeqtl_+3A_pos">pos</code></td>
<td>
<p>Vector (of same length as <code>chr</code>) indicating the
positions on the chromosome to be taken. If there is no marker or
pseudomarker at a position, the nearest position is used.</p>
</td></tr>
<tr><td><code id="makeqtl_+3A_qtl.name">qtl.name</code></td>
<td>
<p>Optional user-specified name for each QTL, used in the
drop-one-term ANOVA table in <code><a href="#topic+fitqtl">fitqtl</a></code>.
If unspecified, the names will be of the form <code>"Chr1@10"</code> for a
QTL on Chromsome 1 at 10 cM.</p>
</td></tr>
<tr><td><code id="makeqtl_+3A_what">what</code></td>
<td>
<p>Indicates whether to pull out the imputed genotypes or the
genotype probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take out the genotype probabilities and imputed
genotypes if they are present in the input <code>cross</code> object. If both
fields are missing in the input object, the function will report an
error. Before running this function, the user must have first run either
<code><a href="#topic+sim.geno">sim.geno</a></code> (for <code>what="draws"</code>) or
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> (for <code>what="prob"</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>qtl</code> with the following elements (though only
one of <code>geno</code> and <code>prob</code> will be included, according to
whether <code>what</code> is given as <code>"draws"</code> or <code>"prob"</code>):
</p>
<table role = "presentation">
<tr><td><code>geno</code></td>
<td>
<p>Imputed genotypes.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>Genotype probabilities.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>User-defined name for each QTL, or a name of the
form <code>"Chr1@10"</code>.</p>
</td></tr>
<tr><td><code>altname</code></td>
<td>
<p>QTL names of the form <code>"Q1"</code>, <code>"Q2"</code>,
etc.</p>
</td></tr>
<tr><td><code>chr</code></td>
<td>
<p>Input vector of chromosome numbers.</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>
<p>Input vector of chromosome positions.</p>
</td></tr>
<tr><td><code>n.qtl</code></td>
<td>
<p>Number of QTLs.</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code>n.gen</code></td>
<td>
<p>A vector indicating the number of genotypes for each QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+dropfromqtl">dropfromqtl</a></code>,
<code><a href="#topic+replaceqtl">replaceqtl</a></code>, <code><a href="#topic+addtoqtl">addtoqtl</a></code>, <code><a href="#topic+summary.qtl">summary.qtl</a></code>,
<code><a href="#topic+reorderqtl">reorderqtl</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c("1", "6", "13")
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- sim.geno(fake.f2, n.draws=8, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="draws")
summary(qtl)
</code></pre>

<hr>
<h2 id='map10'>An example genetic map</h2><span id='topic+map10'></span>

<h3>Description</h3>

<p>A genetic map corresponding approximately to the mouse genome with
a 10 cM marker spacing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(map10)</code></pre>


<h3>Format</h3>

<p>An object of class <code>map</code>: a list whose components are vectors of
marker locations.  This map approximates the mouse genome, with 20
chromosomes (including the X chromosome) and 187 markers at an
approximately 10 cM spacing.  The markers are equally spaced on each
chromosome, but the spacings are a bit above or below 10 cM, so that
the lengths match those in the Mouse Genome Database.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.map">sim.map</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+pull.map">pull.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(map10)
  plot(map10)

  mycross &lt;- sim.cross(map10, type="f2", n.ind=100)
</code></pre>

<hr>
<h2 id='map2table'>Convert genetic map from list to table.</h2><span id='topic+map2table'></span>

<h3>Description</h3>

<p>Convert a map object (as a list) to a table (as a data frame).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2table(map, chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map2table_+3A_map">map</code></td>
<td>
<p>A <code>map</code> object: a list whose components (corresponding
to chromosomes) are either vectors of marker positions or matrices with
two rows of sex-specific marker positions.</p>
</td></tr>
<tr><td><code id="map2table_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two or three columns: chromosome and sex-averaged
position, or chromosome, female position, and male position.
</p>
<p>The row names are the marker names.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+table2map">table2map</a></code>, <code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+est.map">est.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
map &lt;- pull.map(fake.f2)
map_as_tab &lt;- map2table(map)
</code></pre>

<hr>
<h2 id='mapthis'>Simulated data for illustrating genetic map construction</h2><span id='topic+mapthis'></span>

<h3>Description</h3>

<p>Simulated data for an F2 intercross, obtained using
<code><a href="#topic+sim.cross">sim.cross</a></code>, useful for illustrating the process of
constructing a genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapthis)</code></pre>


<h3>Format</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code>
for details.
</p>


<h3>Details</h3>

<p> These are simulated data, consisting of 300 F2 individuals
typed at 100 markers on five chromosomes. There are no real phenotypes,
just a set of individual identifiers.  The data were simulated for the
purpose of illustrating the process of constructing a genetic map.  The
markers are all assigned to a single chromosome and in a random order,
and there are a number of problematic markers and individuals.
</p>
<p>See <a href="https://rqtl.org/tutorials/geneticmaps.pdf">https://rqtl.org/tutorials/geneticmaps.pdf</a> for a tutorial
on how to construct a genetic map with these data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Broman, K. W. (2010) Genetic map construction with R/qtl.  Technical
report #214, Department of Biostatistics and Medical Informatics,
University of Wisconsin&ndash;Madison
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fake.f2">fake.f2</a></code>, <code><a href="#topic+est.rf">est.rf</a></code>,
<code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+formLinkageGroups">formLinkageGroups</a></code>,
<code><a href="#topic+orderMarkers">orderMarkers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mapthis)
summary(mapthis)
plot(mapthis)
</code></pre>

<hr>
<h2 id='markerlrt'>General likelihood ratio test for association between marker pairs</h2><span id='topic+markerlrt'></span>

<h3>Description</h3>

<p>Calculate a LOD score for a general likelihood ratio test for each
pair of markers, to assess their association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markerlrt(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markerlrt_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component, <code>rf</code>,
added.  This is a matrix of size (tot.mar x tot.mar).  The diagonal
contains the number of typed meioses per marker, the upper and lower triangles
each contain the LOD scores.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotRF">plotRF</a></code>, <code><a href="#topic+est.rf">est.rf</a></code>,
<code><a href="#topic+badorder">badorder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
badorder &lt;- markerlrt(badorder)
plotRF(badorder)
</code></pre>

<hr>
<h2 id='markernames'>Pull out the marker names from a cross</h2><span id='topic+markernames'></span>

<h3>Description</h3>

<p>Pull out the marker names from a cross object as one big vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markernames(cross, chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markernames_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="markernames_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings (the marker names).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+phenames">phenames</a></code>, <code><a href="#topic+chrnames">chrnames</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
markernames(listeria, chr=5)
</code></pre>

<hr>
<h2 id='max.scanone'>Maximum peak in genome scan</h2><span id='topic+max.scanone'></span>

<h3>Description</h3>

<p>Print the row of the output from <code><a href="#topic+scanone">scanone</a></code> that
corresponds to the maximum LOD, genome-wide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
max(object, chr, lodcolumn=1, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max.scanone_+3A_object">object</code></td>
<td>
<p>An object of the form output by the function
<code><a href="#topic+scanone">scanone</a></code>: a data.frame whose third column is the
LOD score.</p>
</td></tr>
<tr><td><code id="max.scanone_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="max.scanone_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer, indicating which of the LOD score columns
should be considered in pulling out the peak (these are indexed 1,
2, ...).</p>
</td></tr>
<tr><td><code id="max.scanone_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical indicating whether missing values should be
removed.</p>
</td></tr>
<tr><td><code id="max.scanone_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.scanone</code>, to be printed by
<code>print.summary.scanone</code>.  This is a data.frame with one row,
corresponding to the maximum LOD peak either genome-wide or for the
particular chromosome specified.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

listeria &lt;- calc.genoprob(listeria, step=2.5)
out &lt;- scanone(listeria, model="2part", upper=TRUE)
# Maximum peak for LOD(p,mu)
max(out)

# Maximum peak for LOD(p,mu) on chr 5
max(out,chr=5)

# Maximum peak for LOD(p,mu) on chromosomes other than chr 13
max(out,chr="-13")

# Maximum peak for LOD(p)
max(out, lodcolumn=2)

# Maximum peak for LOD(mu)
max(out, lodcolumn=3)
</code></pre>

<hr>
<h2 id='max.scanPhyloQTL'>Maximum peak in genome scan to map a QTL to a phylogenetic tree</h2><span id='topic+max.scanPhyloQTL'></span>

<h3>Description</h3>

<p>Print the chromosome with the maximum LOD score across partitions,
from the results of <code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanPhyloQTL'
max(object, chr, format=c("postprob", "lod"),
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max.scanPhyloQTL_+3A_object">object</code></td>
<td>
<p>An object output by the function
<code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.</p>
</td></tr>
<tr><td><code id="max.scanPhyloQTL_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="max.scanPhyloQTL_+3A_format">format</code></td>
<td>
<p>Indicates whether to provide LOD scores or approximate
posterior probabilities; see the help file for <code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>.</p>
</td></tr>
<tr><td><code id="max.scanPhyloQTL_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output, and the use of the argument <code>format</code>, is as in
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scanPhyloQTL</code>, to be printed by
<code>print.summary.scanPhyloQTL</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>, <code><a href="#topic+plot.scanPhyloQTL">plot.scanPhyloQTL</a></code>,
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>, <code><a href="#topic+max.scanone">max.scanone</a></code>,
<code><a href="#topic+inferredpartitions">inferredpartitions</a></code>,
<code><a href="#topic+simPhyloQTL">simPhyloQTL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]

# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
x &lt;- lapply(x, calc.genoprob, step=2)

# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# maximum peak
max(out, format="lod")

# approximate posterior probabilities at peak
max(out, format="postprob")

# all peaks above a threshold for LOD(best) - LOD(2nd best)
summary(out, threshold=1, format="lod")

# all peaks above a threshold for LOD(best), showing approx post'r prob
summary(out, format="postprob", threshold=3)

# plot of results
plot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='max.scantwo'>Maximum peak in two-dimensional genome scan</h2><span id='topic+max.scantwo'></span>

<h3>Description</h3>

<p>Print the pair of loci with the largest LOD score in the results of
<code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
max(object, lodcolumn=1,
    what=c("best", "full", "add", "int"),
    na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max.scantwo_+3A_object">object</code></td>
<td>
<p>An object of class <code>scantwo</code>, the output of the
function <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="max.scantwo_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If the scantwo results contain LOD scores for
multiple phenotypes, this argument indicates which to use.</p>
</td></tr>
<tr><td><code id="max.scantwo_+3A_what">what</code></td>
<td>
<p>Indicates for which LOD score the maximum should be reported.</p>
</td></tr>
<tr><td><code id="max.scantwo_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="max.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is very similar to the <code><a href="#topic+summary.scantwo">summary.scantwo</a></code>
function, though this pulls out one pair of positions.
</p>
<p>If <code>what="best"</code>, we find the pair of positions at which the LOD
score for the full model (2 QTL + interaction) is maximized, and then
also print the positions on that same pair of chromosomes at which the
additive LOD score is maximized.
</p>
<p>In the other cases, we pull out the pair of positions with the largest
LOD score; which LOD score is considered is indicated by the
<code>what</code> argument.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scantwo</code>, to be printed by
<code>print.summary.scantwo</code>, with the pair of positions with the
maximum LOD score. (Which LOD score is considered is indicated by the
<code>what</code> argument.)
</p>


<h3>Output of addpair</h3>

<p><b>Note</b> that, for output from <code><a href="#topic+addpair">addpair</a></code> in which the
new loci are indicated explicitly in the formula, the summary provided
by <code>max.scantwo</code> is somewhat special.
</p>
<p>All arguments (except, of course, the input
<code>object</code>) are ignored.
</p>
<p>If the formula is symmetric in the two new QTL, the output has just two LOD
score columns: <code>lod.2v0</code> comparing the full model to the model
with neither of the new QTL, and <code>lod.2v1</code> comparing the full
model to the model with just one new QTL.
</p>
<p>If the formula is <em>not</em> symmetric in the two new QTL, the output
has three LOD score columns: <code>lod.2v0</code> comparing the full model
to the model with neither of the new QTL, <code>lod.2v1b</code> comparing
the full model to the model in which the first of the new QTL is
omitted, and <code>lod.2v1a</code> comparing the full model to the model
with the second of the new QTL omitted.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+plot.scantwo">plot.scantwo</a></code>,
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=10)
out.2dim &lt;- scantwo(fake.f2, method="hk")
max(out.2dim)
</code></pre>

<hr>
<h2 id='movemarker'>Move a marker to a new chromosome</h2><span id='topic+movemarker'></span>

<h3>Description</h3>

<p>Move a specified marker to a different chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movemarker(cross, marker, newchr, newpos)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="movemarker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="movemarker_+3A_marker">marker</code></td>
<td>
<p>The name of the marker to be moved (a character string).</p>
</td></tr>
<tr><td><code id="movemarker_+3A_newchr">newchr</code></td>
<td>
<p>The chromosome to which the marker should be moved.</p>
</td></tr>
<tr><td><code id="movemarker_+3A_newpos">newpos</code></td>
<td>
<p>The position (in cM) at which the marker should be
placed.  If missing, the marker is placed at the end of the
chromosome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> object, but with the specified marker moved to
the specified chromosome.
</p>
<p>All intermediate calculations (such as the results of
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> and <code><a href="#topic+est.rf">est.rf</a></code>) are
removed.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+switch.order">switch.order</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
badorder &lt;- movemarker(badorder, "D2M937", 3, 48.15)
badorder &lt;- movemarker(badorder, "D3M160", 2, 28.83)
</code></pre>

<hr>
<h2 id='MQM'>Introduction to Multiple QTL Model (MQM) mapping</h2><span id='topic+MQM'></span>

<h3>Description</h3>

<p>Overview of the MQM mapping functions
</p>


<h3>Introduction</h3>

<p>Multiple QTL Mapping (MQM) provides a sensitive approach for
mapping quantititive trait loci (QTL) in experimental populations. MQM
adds higher statistical power compared to many other methods.  The
theoretical framework of MQM was introduced and explored by
Ritsert Jansen, explained in the &lsquo;Handbook of Statistical Genetics&rsquo;
(see references), and used effectively in practical research, with the
commercial &lsquo;mapqtl&rsquo; software package. Here we present the first free
and open source implementation of MQM, with extra features like high
performance parallelization on multi-CPU computers, new plots and
significance testing.
</p>
<p>MQM is an automatic three-stage procedure in which, in the first
stage, missing data is &lsquo;augmented&rsquo;. In other words, rather than guessing one
likely genotype, multiple
genotypes are modeled with their estimated
probabilities.  In the second stage important markers are selected by
multiple regression and backward elimination. In the third stage a QTL is moved
along the chromosomes using these pre-selected markers as cofactors,
except for the markers in the window around the interval under study. QTL are
(interval) mapped using the most &lsquo;informative&rsquo; model through maximum
likelihood.  A refined and automated procedure for cases with large
numbers of marker cofactors is included.  The method internally
controls false discovery rates (FDR) and lets users test different QTL
models by elimination of non-significant cofactors.
</p>
<p>R/qtl-MQM has the following advantages:
</p>

<ul>
<li><p> Higher power to detect linked as well as unlinked QTL, as long as the QTL explain a reasonable amount of variation
</p>
</li>
<li><p> Protection against overfitting, because it fixes the residual variance from the full model. For this reason more parameters (cofactors) can be used compared to, for example, CIM
</p>
</li>
<li><p> Prevention of ghost QTL (between two QTL in coupling phase)
</p>
</li>
<li><p> Detection of negating QTL (QTL in repulsion phase)</p>
</li></ul>



<h3>Note</h3>

<p>The current implementation of R/qtl-MQM has the following
limitations: (1) MQM is limited to experimental crosses F2,
BC, and selfed RIL, (2) MQM does not treat sex
chromosomes differently from autosomal chromosomes - though one can
introduce sex as a cofactor. Future versions of R/qtl-MQM may improve on
these points. Check the website and change log
(<a href="https://github.com/kbroman/qtl/blob/main/NEWS.md">https://github.com/kbroman/qtl/blob/main/NEWS.md</a>) for updates.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>References</h3>


<ul>
<li><p> Arends D, Prins P, Jansen RC.  R/qtl: High-throughput multiple QTL mapping. <em>Bioinformatics</em>, to appear
</p>
</li>
<li><p> Jansen RC, (2007) Quantitative trait loci in inbred lines. Chapter 18 of <em>Handbook of Stat. Genetics</em> 3rd edition. John Wiley &amp; Sons, Ltd.
</p>
</li>
<li><p> Jansen RC, Nap JP (2001), Genetical genomics: the added value from segregation. <em>Trends in Genetics</em>, <b>17</b>, 388&ndash;391.
</p>
</li>
<li><p> Jansen RC, Stam P (1994), High resolution of quantitative traits into multiple loci via interval mapping. <em>Genetics</em>, <b>136</b>, 1447&ndash;1455.
</p>
</li>
<li><p> Jansen RC (1993), Interval mapping of multiple quantitative trait loci. <em>Genetics</em>, <b>135</b>, 205&ndash;211.
</p>
</li>
<li><p> Swertz MA, Jansen RC. (2007), Beyond standardization: dynamic software infrastructures for systems biology. <em>Nat Rev Genet.</em> <b>3</b>, 235&ndash;243.
</p>
</li>
<li><p> Dempster, A. P., Laird, N. M. and Rubin, D. B. (1977) Maximum likelihood from incomplete data via the EM algorithm.  <em>J. Roy. Statist. Soc.</em> B, <b>39</b>, 1&ndash;38.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(map10)                    # Genetic map modeled after mouse

# simulate a cross (autosomes 1-10)
qtl &lt;- c(3,15,1,0)             # QTL model: chr, pos'n, add've &amp; dom effects
cross &lt;- sim.cross(map10[1:10],qtl,n=100,missing.prob=0.01)

# MQM
crossaug &lt;- mqmaugment(cross)  # Augmentation
cat(crossaug$mqm$Nind,'real individuals retained in dataset',
    crossaug$mqm$Naug,'individuals augmented\n')

result &lt;- mqmscan(crossaug)    # Scan

# show LOD interval of the QTL on chr 3
lodint(result,chr=3)
</code></pre>

<hr>
<h2 id='mqmaugment'>MQM augmentation</h2><span id='topic+mqmaugment'></span>

<h3>Description</h3>

<p>Fill in missing genotypes for MQM mapping. For each missing or incomplete
marker it fills in (or &lsquo;augments&rsquo;) all possible genotypes, thus creating new
candidate &lsquo;individuals&rsquo;. The probability of each indidual is calculated using
information on neighbouring markers and recombination frequencies. When a
genotype of an augmented genotype is less likely than the <code>minprob</code>
parameter it is dropped from the dataset. The <em>augmented</em> list of
individuals is returned in a new cross object. For a full discussion on
augmentation see the MQM tutorial online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmaugment(cross, maxaugind=82, minprob=0.1,
           strategy=c("default","impute","drop"),
           verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmaugment_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmaugment_+3A_maxaugind">maxaugind</code></td>
<td>

<p>Maximum number of augmentations per individual.  The default of 82
allows for six missing markers for an individual in a BC cross
(<code class="reqn">2^6=64</code>) and four missing markers in an F2 (<code class="reqn">3^4=81</code>). When a
large number of markers are missing this default number is quickly
reached.
</p>
</td></tr>
<tr><td><code id="mqmaugment_+3A_minprob">minprob</code></td>
<td>

<p>Return individuals with augmented genotypes that have at least this probability of
occurring. <code>minprob</code> is a value between 0 and 1. For example a value of 0.5
will drop all genotypes that are half as likely as the most likely
genotype (candidate of the individual). The default value of 0.1 will drop
all genotypes that are less likely of ocurring than 1 in 10, compared
against the most likely genotype. Use a value of 1.0 to return a single
filled in genotype for each individual.
</p>
</td></tr>
<tr><td><code id="mqmaugment_+3A_strategy">strategy</code></td>
<td>

<p>When individuals have too much missing data and augmentation fails three
options are provided:
1. <code>"default"</code>: Calculate genotypes at missing marker positions,
accounting for <code>minprob</code>, and add this individual to the set.
2. <code>"impute"</code>: Calculate the most likely genotypes at missing marker
positions and impute <code>maxaugind</code> individual-variants around the most
likely genotype.
3. <code>"drop"</code>: Drop individuals that cannot be augmented from the
dataset, this option is not advised because information from the dropped
individuals will be lost.
</p>
</td></tr>
<tr><td><code id="mqmaugment_+3A_verbose">verbose</code></td>
<td>
<p> If TRUE, give verbose output </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the cross object with augmented individuals (many individuals from
the data set will be repeated multiple times). Some individuals may have been
dropped completely when the probability falls below <code>minprob</code>. An added
component to the cross object named <code>mqm</code> contains information on
exactly which individuals are retained and repeated.
</p>


<h3>Note</h3>

<p>The sex chromosome 'X' is treated like autosomes during augmentation.
With an F2 the sex chromosome is not considered. This will change in
a future version of MQM.
Run with <code>verbose=TRUE</code> to verify how many individuals are augmented
versus moved to the second augmentation round. This could have an effect
on the resulting dataset or check the return <code>cross$mqm</code> values. Compare
results by using <code>minprob=1</code>.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+fill.geno">fill.geno</a></code> - Alternative routine for estimating missing data
</p>
</li>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(map10)                    # Genetic map modeled after mouse

# simulate a cross (autosomes 1-10)
qtl &lt;- c(3,15,1,0)             # QTL model: chr, pos'n, add've &amp; dom effects
cross &lt;- sim.cross(map10[1:10],qtl,n=100,missing.prob=0.01)

# MQM
crossaug &lt;- mqmaugment(cross)  # Augmentation
cat(crossaug$mqm$Nind,'real individuals retained in dataset',
    crossaug$mqm$Naug,'individuals augmented\n')

result &lt;- mqmscan(crossaug)    # Scan

# show LOD interval of the QTL on chr 3
lodint(result,chr=3)
</code></pre>

<hr>
<h2 id='mqmautocofactors'>Automatic setting of cofactors, taking marker density into account</h2><span id='topic+mqmautocofactors'></span>

<h3>Description</h3>

<p>Sets cofactors, taking underlying marker density into account. Together
with <code>mqmscan</code> cofactors are selected through backward elimination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmautocofactors(cross, num=50, distance=5, dominance=FALSE, plot=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmautocofactors_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmautocofactors_+3A_num">num</code></td>
<td>
<p> Number of cofactors to set (warns when setting too many cofactors).</p>
</td></tr>
<tr><td><code id="mqmautocofactors_+3A_distance">distance</code></td>
<td>
<p> Minimal distance between two cofactors, in cM.</p>
</td></tr>
<tr><td><code id="mqmautocofactors_+3A_dominance">dominance</code></td>
<td>
<p>If TRUE, create a cofactor list that is safe to use
with the dominance scan mode of MQM. See <code><a href="#topic+mqmscan">mqmscan</a></code> for details.</p>
</td></tr>
<tr><td><code id="mqmautocofactors_+3A_plot">plot</code></td>
<td>
<p>If TRUE, plots a genetic map displaying the selected markers as cofactors.</p>
</td></tr>
<tr><td><code id="mqmautocofactors_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give verbose output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cofactors to be used with <code><a href="#topic+mqmscan">mqmscan</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    data(hyper)                     # hyper dataset
    
    hyperfilled &lt;- fill.geno(hyper)
    cofactors &lt;- mqmautocofactors(hyperfilled,15)	# Set 15 Cofactors
    result &lt;- mqmscan(hyperfilled,cofactors)	# Backward model selection
    mqmgetmodel(result)
</code></pre>

<hr>
<h2 id='mqmextractmarkers'>MQM marker extraction</h2><span id='topic+mqmextractmarkers'></span>

<h3>Description</h3>

<p>Extract the real markers from a cross object that includes pseudo markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmextractmarkers(mqmresult)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmextractmarkers_+3A_mqmresult">mqmresult</code></td>
<td>
<p>result from <code>mqmscan</code>, including pseudo markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scanone object with the pseudo markers removed
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

multitrait &lt;- fill.geno(multitrait)

result &lt;- mqmscan(multitrait)
newresult &lt;- mqmextractmarkers(result)
</code></pre>

<hr>
<h2 id='mqmfind.marker'> Fetch significant markers after permutation analysis </h2><span id='topic+mqmfind.marker'></span>

<h3>Description</h3>

<p>Fetch significant makers after permutation analysis.  These markers can be
used as cofactors for model selection in a forward stepwise approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmfind.marker(cross, mqmscan = NULL, perm = NULL, alpha = 0.05, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmfind.marker_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmfind.marker_+3A_mqmscan">mqmscan</code></td>
<td>
<p> Results from either <code><a href="#topic+scanone">scanone</a></code> or <code><a href="#topic+mqmscan">mqmscan</a></code> </p>
</td></tr>
<tr><td><code id="mqmfind.marker_+3A_perm">perm</code></td>
<td>
<p> a <code>scanoneperm</code> object </p>
</td></tr>
<tr><td><code id="mqmfind.marker_+3A_alpha">alpha</code></td>
<td>
<p> Threshold value, everything with significance &lt; alpha is reported </p>
</td></tr>
<tr><td><code id="mqmfind.marker_+3A_verbose">verbose</code></td>
<td>

<p>Display more output on verbose=TRUE 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix with at each row a significant marker (determined from the
<code>scanoneperm</code> object) and with columns: markername, chr and pos (cM)
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mqmprocesspermutation">mqmprocesspermutation</a></code> - Function called to convert results from an mqmpermutation into an scanoneperm object
</p>
</li>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Use the multitrait dataset
data(multitrait)

# Set cofactors at each 3th marker
cof &lt;- mqmsetcofactors(multitrait,3)

# impute missing genotypes
multitrait &lt;- fill.geno(multitrait)

# log transform the 7th phenotype
multitrait &lt;- transformPheno(multitrait, 7)

# Bootstrap 50 runs in batches of 10
## Not run: result &lt;- mqmpermutation(multitrait,scanfunction=mqmscan,cofactors=cof,
                         pheno.col=7,n.perm=50,batchsize=10)

## End(Not run)

# Create a permutation object
f2perm &lt;- mqmprocesspermutation(result)

# What LOD score is considered significant ?
summary(f2perm)

# Find markers with a significant QTL effect (First run is original phenotype data)
marker &lt;- mqmfind.marker(multitrait,result[[1]],f2perm)

# Print it to the screen
marker
</code></pre>

<hr>
<h2 id='mqmgetmodel'> Retrieve the QTL model used in mapping from the results of an MQM scan </h2><span id='topic+mqmgetmodel'></span>

<h3>Description</h3>

<p>Retrieves the QTL model used for scanning from the output of an MQM scan. The
model only contains the selected cofactors significant at the specified
cofactor.significance from the results of an mqm scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mqmgetmodel(scanresult)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmgetmodel_+3A_scanresult">scanresult</code></td>
<td>

<p>An object returned by <code>mqmscan</code>, including cofactors and QTL model. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the multiple QTL model created, which consists of the cofactors selected during the modeling phase of the algorithm.
This model was used when scanning for additional QTL in the mqmscan function. The format of the model is compatible with the
<code><a href="#topic+makeqtl">makeqtl</a></code> function. For more information about the format of the model see the <code><a href="#topic+makeqtl">makeqtl</a></code> page.
When no cofactor was selected in the modeling phase no model was created, then this function will return a NULL value.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Setting multiple cofactors for backward elimination
</p>
</li>
<li> <p><code><a href="#topic+makeqtl">makeqtl</a></code> - Make a qtl object

</p>
</li>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    data(hyper)
        
    hyperfilled &lt;- fill.geno(hyper)
    cofactors &lt;- mqmsetcofactors(hyperfilled,4)
    result &lt;- mqmscan(hyperfilled,cofactors)
    mqmgetmodel(result)
    plot(mqmgetmodel(result))
</code></pre>

<hr>
<h2 id='mqmpermutation'>Estimate QTL LOD score significance using permutations or simulations </h2><span id='topic+mqmpermutation'></span>

<h3>Description</h3>

<p>Two randomization approaches to obtain estimates of QTL significance:
</p>

<ul>
<li><p> Random redistribution of traits (method='permutation')
</p>
</li>
<li><p> Random redistribution of simulated trait values (method='simulation')
</p>
</li></ul>

<p>Calculations can be parallelized using the SNOW package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmpermutation(cross, scanfunction=scanone, pheno.col=1, multicore=TRUE,
               n.perm=10, file="MQM_output.txt",
               n.cluster=1, method=c("permutation","simulation"),
               cofactors=NULL, plot=FALSE, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmpermutation_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_scanfunction">scanfunction</code></td>
<td>
<p> Function to use when mappingQTL's (either scanone,cim or mqm)</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_pheno.col">pheno.col</code></td>
<td>

<p>Column number in the phenotype matrix which should be used as the phenotype. This can be a vector of integers. 
</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_multicore">multicore</code></td>
<td>
<p> Use multicore (if available)</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_n.perm">n.perm</code></td>
<td>
<p> Number of permutations to perform (DEFAULT=10, should be 1000, or higher,
for publications) </p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_file">file</code></td>
<td>
<p> Name of the intermediate output file used </p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_n.cluster">n.cluster</code></td>
<td>
<p> Number of child processes to split the job into </p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_method">method</code></td>
<td>
<p> What kind permutation should occur: permutation or simulation </p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_cofactors">cofactors</code></td>
<td>
<p>cofactors, only used when scanfunction is mqm.
List of cofactors to be analysed in the QTL model. To set cofactors use <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> or <code>mqmsetcofactors</code></p>
</td></tr></table>
<p>. 
</p>
<table role = "presentation">
<tr><td><code id="mqmpermutation_+3A_plot">plot</code></td>
<td>
<p>If TRUE, make a plot</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print tracing information</p>
</td></tr>
<tr><td><code id="mqmpermutation_+3A_...">...</code></td>
<td>
<p>Parameters passed through to the
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+cim">cim</a></code> or
<code><a href="#topic+mqmscan">mqmscan</a></code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analysis of <code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+cim">cim</a></code> or
<code><a href="#topic+mqmscan">mqmscan</a></code> to scan for QTL in shuffled/randomized data. It is recommended to also install the <code>snow</code> library.
The <code>snow</code> library allows calculations to run on multiple cores or even scale it up to an entire cluster, thus speeding up calculation.
</p>


<h3>Value</h3>

<p>Returns a mqmmulti object. this object is a list of scanone objects that can be plotted using <code>plot.scanone(result[[trait]])</code>
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>References</h3>


<ul>
<li><p> Bruno M. Tesson, Ritsert C. Jansen (2009) Chapter 3.7. Determining the significance threshold <em>eQTL Analysis in Mice and Rats</em> <b>1</b>, 20&ndash;25
</p>
</li>
<li><p> Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for quantitative trait mapping. <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>
</li>
<li><p> Rossini, A., Tierney, L., and Li, N. (2003), Simple parallel statistical computing.  <em>R. UW Biostatistics working paper series</em> University of Washington. <b>193</b>
</p>
</li>
<li><p> Tierney, L., Rossini, A., Li, N., and Sevcikova, H. (2004), The snow Package: Simple Network of Workstations. Version 0.2-1.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Use the multitrait dataset
data(multitrait)



multitrait &lt;- calc.genoprob(multitrait)
result &lt;- mqmpermutation(multitrait,pheno.col=7, n.perm=2, batchsize=2)

## Not run: #Set 50 cofactors
cof &lt;- mqmautocofactors(multitrait,50)

## End(Not run)

multitrait &lt;- fill.geno(multitrait)
result &lt;- mqmpermutation(multitrait,scanfunction=mqmscan,cofactors=cof,
                         pheno.col=7, n.perm=2,batchsize=2,verbose=FALSE)

#Create a permutation object
f2perm &lt;- mqmprocesspermutation(result)

#Get Significant LOD thresholds
summary(f2perm)
</code></pre>

<hr>
<h2 id='mqmplot.circle'>Circular genome plot for MQM</h2><span id='topic+mqmplot.circle'></span>

<h3>Description</h3>

<p>Circular genome plot - shows QTL locations and relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.circle(cross,result,highlight=0,spacing=25, interactstrength=2,
               axis.legend=TRUE, col.legend=FALSE, verbose=FALSE, transparency=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.circle_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code> with optionally phenotype locations. See
<code><a href="#topic+read.cross">read.cross</a></code> for details on reading in cross objects, and optionally
<code><a href="#topic+addloctocross">addloctocross</a></code> for adding phenotype locations.
</p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_result">result</code></td>
<td>
<p>An object of class <code>mqmmulti</code> or <code>scanone</code>.
See <code><a href="#topic+mqmscanall">mqmscanall</a></code> <code><a href="#topic+scanone">scanone</a></code> for details.
</p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_highlight">highlight</code></td>
<td>
<p> With a mqmmulti object, highlight this phenotype (value between
one and the number of results in the mqmmultiobject)
</p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_interactstrength">interactstrength</code></td>
<td>
<p> When highlighting a trait, consider interactions
significant they have a change of more than interactstrength*SEs. A higher value
will show less interactions.  However the interactions reported at higher
interactstrength values will generaty be more reliable.
</p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_spacing">spacing</code></td>
<td>
<p> User defined spacing between chromosomes in cM </p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_axis.legend">axis.legend</code></td>
<td>
<p> When set to FALSE, suppresses the legends. (defaults to plotting legends besides the axis.  </p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_col.legend">col.legend</code></td>
<td>
<p> With a mqmmulti object, plots a legend for the non-highlighed version </p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_transparency">transparency</code></td>
<td>
<p> Use transparency when drawing the plots (defaults to no transparency) </p>
</td></tr>
<tr><td><code id="mqmplot.circle_+3A_verbose">verbose</code></td>
<td>
<p> Be verbose </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the input of the result being either <code><a href="#topic+scanone">scanone</a></code> or <code>mqmmulti</code> a different plot is drawn.
If model information is present from <code><a href="#topic+mqmscan">mqmscan</a></code> (by setting cofactors) This will be highlighted in
red (see example).
If phenotypes have genetic locations (e.g. eQTL) they will be plotted on the genome otherwise
phenotypes will be plotted in the middle of the circle (with a small offset)
Locations can be added by using the <code><a href="#topic+addloctocross">addloctocross</a></code> function.
</p>


<h3>Value</h3>

<p>Plotting routine, no return
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

data(locations)


multifilled &lt;- fill.geno(multitrait)                    # impute missing genotypes
multicof &lt;- mqmsetcofactors(multitrait,10)              # create cofactors
multiloc &lt;- addloctocross(multifilled,locations)        # add phenotype information to cross
multires &lt;- mqmscanall(multifilled,cofactors=multicof)  # run mqmscan for all phenotypes

#Basic mqmmulti, color = trait, round circle = significant
mqmplot.circle(multifilled,multires)

#mqmmulti with locations of traits in multiloc
mqmplot.circle(multiloc,multires)

#mqmmulti with highlighting
mqmplot.circle(multitrait,multires,highlight=3)

#mqmmulti with locations of traits in multiloc and highlighting
mqmplot.circle(multiloc,multires,highlight=3)
</code></pre>

<hr>
<h2 id='mqmplot.cistrans'>cis-trans plot</h2><span id='topic+mqmplot.cistrans'></span>

<h3>Description</h3>

<p>Plot results for a genomescan using a multiple-QTL model. With genetic location
for the traits it is possible to show cis- and trans- locations, and detect
trans-bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.cistrans(result, cross, threshold=5, onlyPEAK=TRUE,
                 highPEAK=FALSE, cisarea=10, pch=22, cex=0.5,
                 verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.cistrans_+3A_result">result</code></td>
<td>
<p>An object of class <code>mqmmulti</code>. See <code><a href="#topic+mqmscanall">mqmscanall</a></code> for details.</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_threshold">threshold</code></td>
<td>
<p> Threshold value in LOD, Markers that have a
LOD score above this threshold are plotted as small squares
(see <code>pch</code> parameter). The markers with LODscores below
this threshold are not visible
</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_onlypeak">onlyPEAK</code></td>
<td>
<p> Plot only the peak markers ? (TRUE/FALSE)
(Peak markers are markers that have a QTL likelihood above
<code>threshold</code> and higher than other markers in the same region)
</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_highpeak">highPEAK</code></td>
<td>
<p> Highlight peak markers ? (TRUE/FALSE).
When using this option peak markers (the marker with the
highest LOD score in a region above the threshold gets
an 25% increase in size and is displayed in red)
</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_cisarea">cisarea</code></td>
<td>
<p> Adjust the two green lines around the line y=x </p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_pch">pch</code></td>
<td>
<p> What kind of character is used in plotting of the figure (Default: 22, small square) </p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_cex">cex</code></td>
<td>
<p> Size of the points plotted (default to 0.5 half of the original size)</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give verbose output</p>
</td></tr>
<tr><td><code id="mqmplot.cistrans_+3A_...">...</code></td>
<td>
<p> Extra parameters will be passed to points </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plotting routine, so no return
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

data(locations)
multiloc &lt;- addloctocross(multitrait,locations)
multiloc &lt;- calc.genoprob(multiloc)
results &lt;- scanall(multiloc, method="hk")
mqmplot.cistrans(results, multiloc, 5, FALSE, TRUE)
</code></pre>

<hr>
<h2 id='mqmplot.clusteredheatmap'>Plot clustered heatmap
of MQM scan on multiple phenotypes</h2><span id='topic+mqmplot.clusteredheatmap'></span>

<h3>Description</h3>

<p>Plot the results from a MQM scan on multiple phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.clusteredheatmap(cross, mqmresult, directed=TRUE, legend=FALSE,
                         Colv=NA, scale="none", verbose=FALSE,
                         breaks = c(-100,-10,-3,0,3,10,100),
                         col = c("darkblue","blue","lightblue","yellow",
                                 "orange","red"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.clusteredheatmap_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_mqmresult">mqmresult</code></td>
<td>
<p> Result object from mqmscanall, the object needs to be of class <code>mqmmulti</code> </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_directed">directed</code></td>
<td>
<p> Take direction of QTLs into account (takes more time because of QTL direction calculations </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_legend">legend</code></td>
<td>
<p> If TRUE, add a legend to the plot </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_colv">Colv</code></td>
<td>
<p> Cluster only the Rows, the columns (Markers) should not be clustered </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_scale">scale</code></td>
<td>
<p> character indicating if the values should be centered and scaled in either
the row direction or the column direction, or none. The default &quot;none&quot; </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give verbose output.</p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_breaks">breaks</code></td>
<td>
<p> Color break points for the LOD scores </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_col">col</code></td>
<td>
<p> Colors used between breaks </p>
</td></tr>
<tr><td><code id="mqmplot.clusteredheatmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+heatmap">heatmap</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

multitrait &lt;- fill.geno(multitrait) # impute missing genotype data
result &lt;- mqmscanall(multitrait, logtransform=TRUE)
cresults &lt;- mqmplot.clusteredheatmap(multitrait,result)
groupclusteredheatmap(multitrait,cresults,10)
</code></pre>

<hr>
<h2 id='mqmplot.cofactors'>Plot cofactors on the genetic map</h2><span id='topic+mqmplot.cofactors'></span>

<h3>Description</h3>

<p>Plots cofactors as created by <code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code>
or <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> on the genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.cofactors(cross,cofactors, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.cofactors_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmplot.cofactors_+3A_cofactors">cofactors</code></td>
<td>

<p>List of cofactors to be analysed in the QTL model. To set cofactors use <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> or <code>mqmsetcofactors</code></p>
</td></tr></table>
<p>. 
</p>
<table role = "presentation">
<tr><td><code id="mqmplot.cofactors_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+plot.qtl">plot.qtl</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)
cof1 &lt;- mqmsetcofactors(multitrait,20)
cof2 &lt;- mqmsetcofactors(multitrait,10)
op &lt;- par(mfrow=c(2,1))
mqmplot.cofactors(multitrait,cof1,col="blue")
mqmplot.cofactors(multitrait,cof2,col="blue")
op &lt;- par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='mqmplot.directedqtl'>Plot LOD*Effect curves of a multiple-QTL model </h2><span id='topic+mqmplot.directedqtl'></span>

<h3>Description</h3>

<p>Plot the LOD*Effect curve for a genome scan with a multiple-QTL model (the
output of <code><a href="#topic+mqmscan">mqmscan</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.directedqtl(cross, mqmresult, pheno.col=1, draw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.directedqtl_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmplot.directedqtl_+3A_mqmresult">mqmresult</code></td>
<td>
<p> Results from mqmscan of type <code>scanone</code> </p>
</td></tr>
<tr><td><code id="mqmplot.directedqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p> From which phenotype in the crossobject are the result calculated </p>
</td></tr>
<tr><td><code id="mqmplot.directedqtl_+3A_draw">draw</code></td>
<td>
<p> If TRUE, draw the figure. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scanone object, with added the effectsign calculated
internally by the function effect.scan. For more info on the
scanone object see: <code><a href="#topic+scanone">scanone</a></code>
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Simulated F2 Population
f2qtl &lt;- c(3,15,1,0)                                    # QTL at chromosome 3
data(map10)                                             # Mouse genetic map

f2cross &lt;- sim.cross(map10,f2qtl,n=100,type="f2")       # Simulate a F2 Cross
f2cross &lt;- fill.geno(f2cross)                           # Fill in missing genotypes
f2result &lt;- mqmscan(f2cross)                        # Do a MQM scan of the genome
mqmplot.directedqtl(f2cross,f2result)
</code></pre>

<hr>
<h2 id='mqmplot.heatmap'>Heatmap of a genome of MQM scan on multiple phenotypes</h2><span id='topic+mqmplot.heatmap'></span>

<h3>Description</h3>

<p>Plotting routine to display a heatmap of results obtained from a multiple-QTL model on multiple phenotypes (the
output of <code><a href="#topic+mqmscanall">mqmscanall</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.heatmap(cross, result, directed=TRUE, legend=FALSE, breaks =
c(-100,-10,-3,0,3,10,100), col =
c("darkblue","blue","lightblue","yellow","orange","red"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.heatmap_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_result">result</code></td>
<td>
<p> Result object from mqmscanall, the object needs to be of class <code>mqmmulti</code> </p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_directed">directed</code></td>
<td>
<p> Take direction of QTLs into account (takes more time because of QTL direction calculations </p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_legend">legend</code></td>
<td>
<p> If TRUE, add a legend to the plot </p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_breaks">breaks</code></td>
<td>
<p> Color break points for the LOD scores </p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_col">col</code></td>
<td>
<p> Colors used between breaks </p>
</td></tr>
<tr><td><code id="mqmplot.heatmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="graphics.html#topic+image">image</a></code> function </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

multitrait &lt;- fill.geno(multitrait) # impute missing genotype data
result &lt;- mqmscanall(multitrait, logtransform=TRUE)
mqmplot.heatmap(multitrait,result)
</code></pre>

<hr>
<h2 id='mqmplot.multitrait'>Plot the results from a genomescan using a multiple-QTL model on multiple phenotypes</h2><span id='topic+mqmplot.multitrait'></span>

<h3>Description</h3>

<p>Plotting routine to display the results from a  multiple-QTL model on
multiple phenotypes.  It supports four different visualizations: a
contourmap, heatmap, 3D graph or a multiple QTL plot created by using
<code><a href="#topic+plot.scanone">plot.scanone</a></code> on the <code>mqmmulti</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.multitrait(result, type=c("lines","image","contour","3Dplot"),
                   group=NULL, meanprofile=c("none","mean","median"),
                   theta=30, phi=15, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.multitrait_+3A_result">result</code></td>
<td>
<p> Result object from <code><a href="#topic+mqmscanall">mqmscanall</a></code> </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_type">type</code></td>
<td>
<p> Selection of the plot method to visualize the data: &quot;lines&quot; (defaut plotting option), &quot;image&quot;, &quot;contour&quot; and &quot;3Dplot&quot; </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_group">group</code></td>
<td>
<p> A numeric vector indicating which traits to plot. NULL means no grouping </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_meanprofile">meanprofile</code></td>
<td>
<p> Plot a mean/median profile from the group selected </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_theta">theta</code></td>
<td>
<p> Horizontal axis rotation in a 3D plot </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_phi">phi</code></td>
<td>
<p> Vertical axis rotation in a 3D plot </p>
</td></tr>
<tr><td><code id="mqmplot.multitrait_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

multitrait &lt;- fill.geno(multitrait) # impute missing genotype data
result &lt;- mqmscanall(multitrait, logtransform=TRUE)
mqmplot.multitrait(result,"lines")
mqmplot.multitrait(result,"contour")
mqmplot.multitrait(result,"image")
mqmplot.multitrait(result,"3Dplot")
</code></pre>

<hr>
<h2 id='mqmplot.permutations'>Plot results from mqmpermutation</h2><span id='topic+mqmplot.permutations'></span>

<h3>Description</h3>

<p>Plotting routine to display the results from a permutation QTL scan. (the
output of <code><a href="#topic+mqmpermutation">mqmpermutation</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.permutations(permutationresult, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.permutations_+3A_permutationresult">permutationresult</code></td>
<td>
 <p><code>mqmmulti</code> object returned by
<code><a href="#topic+mqmpermutation">mqmpermutation</a></code> permutation analysis.
</p>
</td></tr>
<tr><td><code id="mqmplot.permutations_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to <code><a href="#topic+polyplot">polyplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p> No value returned (plotting routine) </p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
, Rutger Brouwer
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simulated F2 Population
# QTL at chromosome 3
f2qtl &lt;- c(3,15,1,0)

# Mouse genetic map
data(map10)


# Simulate a F2 Cross
f2cross &lt;- sim.cross(map10,f2qtl,n=100,type="f2")
f2cross &lt;- calc.genoprob(f2cross)
## Not run: # Permutations to obtain significance threshold
f2result &lt;- mqmpermutation(f2cross, n.perm=1000, method="permutation")

## End(Not run)

# Plot results
mqmplot.permutations(f2result)
</code></pre>

<hr>
<h2 id='mqmplot.singletrait'>Plot LOD curves of a multiple-QTL model</h2><span id='topic+mqmplot.singletrait'></span>

<h3>Description</h3>

<p>Plot the LOD curve for a genome scan for a single trait, with a multiple-QTL model (the
output of <code><a href="#topic+mqmscan">mqmscan</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmplot.singletrait(result, extended = 0 ,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmplot.singletrait_+3A_result">result</code></td>
<td>
 <p><code><a href="#topic+mqmscan">mqmscan</a></code> result.</p>
</td></tr>
<tr><td><code id="mqmplot.singletrait_+3A_extended">extended</code></td>
<td>
<p> Extended plotting of the information content </p>
</td></tr>
<tr><td><code id="mqmplot.singletrait_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to <code><a href="#topic+plot.scanone">plot.scanone</a></code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Simulated F2 Population
f2qtl &lt;- c(3,15,1,0)                                    # QTL at chromosome 3
data(map10)                                             # Mouse genetic map

f2cross &lt;- sim.cross(map10,f2qtl,n=100,type="f2")       # Simulate a F2 Cross
f2cross &lt;- mqmaugment(f2cross)
f2result &lt;- mqmscan(f2cross)                        # Do a MQM scan of the genome
mqmplot.singletrait(f2result)					# Use our fancy plotting routine
</code></pre>

<hr>
<h2 id='mqmprocesspermutation'>Convert mqmmulti objects into a scanoneperm object</h2><span id='topic+mqmprocesspermutation'></span>

<h3>Description</h3>

<p>Function to convert <code>mqmmulti</code> objects into a <code>scanoneperm</code>
object, this allows the use of R/qtl methods for permutation analysis
that do not support the output of a multiple QTL scan using mqm's
outputstructure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmprocesspermutation(mqmpermutationresult = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmprocesspermutation_+3A_mqmpermutationresult">mqmpermutationresult</code></td>
<td>
 <p><code>mqmmulti</code> object obtained
after performing permutations on a single trait.using the
function <code><a href="#topic+mqmpermutation">mqmpermutation</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output of the algorithm is a <code>scanoneperm</code> object. See also: <code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># QTL at chromosome 3
f2qtl &lt;- c(3,15,1,0)

# Mouse genetic map
data(map10)


# Simulate a F2 Cross
f2cross &lt;- sim.cross(map10,f2qtl,n=100,type="f2")
## Not run: # Bootstrap MQM mapping on the f2cross
f2result &lt;- mqmpermutation(f2cross,scanfunction=mqmscan)

## End(Not run)

# Create a permutation object
f2perm &lt;- mqmprocesspermutation(f2result)

# What LOD score is considered significant?
summary(f2perm)
</code></pre>

<hr>
<h2 id='mqmscan'>Genome scan with a multiple QTL model (MQM)</h2><span id='topic+mqmscan'></span>

<h3>Description</h3>

<p>Genome scan with a multiple QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmscan(cross, cofactors=NULL, pheno.col = 1,
  model=c("additive","dominance"), forceML=FALSE,
  cofactor.significance=0.02, em.iter=1000,
  window.size=25.0, step.size=5.0,
  logtransform = FALSE, estimate.map = FALSE,
  plot=FALSE, verbose=FALSE, outputmarkers=TRUE,
  multicore=TRUE, batchsize=10, n.clusters=1, test.normality=FALSE,off.end=0
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmscan_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_cofactors">cofactors</code></td>
<td>
<p> List of cofactors to be analysed as cofactors in backward elimination
procedure when building the QTL model. See <code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> on how-to manually set cofactors
for backward elimination. Or use <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> for automatic selection of cofactors. Only
three kind of (integer) values are allowed in the cofactor list. (0: no cofactor at this marker, 1: Use
this marker as an additive cofactor, 2: Use this marker as an sexfactor (Dominant cofactor))
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_pheno.col">pheno.col</code></td>
<td>
<p> Column number in the phenotype matrix which should be
used as the phenotype.  This can be a vector of integers; One may also
give a character strings matching the phenotype names.  Finally, one
may give a numeric vector of phenotypeIDs. This should consist of
integers with  0 &lt; value &lt; no. phenotypes.
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_model">model</code></td>
<td>
<p> When scanning for QTLs should haplotype dominance be
considered in an F2 intercross. Using the dominance model we scan
for additive effects but also allow an additional effect where AA+AB
versus BB and AA versus AB+BB. This setting is ignored for BC and RIL
populations
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_forceml">forceML</code></td>
<td>
<p> Specify which statistical method to use to estimate
variance components to use when QTL modeling and mapping. Default
usage is the Restricted maximum likelihood approach (REML). With this
option a user can disable REML and use maximum likelihood.
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_cofactor.significance">cofactor.significance</code></td>
<td>
<p> Significance level at which a cofactor is
considered significant. This is estimated using an analysis of
deviance, and compared to the level specified by the user. The
cofactors that dont reach this level of statistical significance
are NOT used in the mapping stage. Value between 0 and 1 </p>
</td></tr>
<tr><td><code id="mqmscan_+3A_em.iter">em.iter</code></td>
<td>
<p> Maximum number of iterations for the EM algorithm to converge </p>
</td></tr>
<tr><td><code id="mqmscan_+3A_window.size">window.size</code></td>
<td>
<p> Window size for mapping QTL locations,
this parameter is used in the interval mapping stage. When
calculating LOD scores at a genomic position all cofactors
within window.size are dropped to estimate the (unbiased)
effect of the location under interest.
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_step.size">step.size</code></td>
<td>
<p> Step size used in interval mapping. A lower
step.size parameter increases the number of output points,
this creates a smoother QTL profile
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_off.end">off.end</code></td>
<td>
<p>Distance (in cM) past the terminal markers on each
chromosome to which the genotype simulations will be carried.
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_logtransform">logtransform</code></td>
<td>
<p> Indicate if the algorithm should do a log
transformation on the trait data in the pheno.col
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_estimate.map">estimate.map</code></td>
<td>
<p> Should Re-estimation of the marker locations
on the genetic map occur before mapping QTLs. This method is
deprecated rather use the <code><a href="#topic+est.map">est.map</a></code> function in R/qtl.
This is because no map is returned into the crossobject.
The old map remains in the cross object.
</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_plot">plot</code></td>
<td>
<p> plot the results (default FALSE)</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_verbose">verbose</code></td>
<td>
<p> verbose output</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_outputmarkers">outputmarkers</code></td>
<td>
<p>If TRUE (the default), the results include the
marker locations as well as along a grid of pseudomarkers; if FALSE,
the results include only the grid positions.</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_multicore">multicore</code></td>
<td>
<p>Use multicore (if available)</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of traits being analyzed as a batch.</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_n.clusters">n.clusters</code></td>
<td>
<p>Number of child processes to split the job into.</p>
</td></tr>
<tr><td><code id="mqmscan_+3A_test.normality">test.normality</code></td>
<td>
<p>If TRUE, test whether the phenotype follows a
normal distribution via <code><a href="#topic+mqmtestnormal">mqmtestnormal</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When scanning a single phenotype the function returns a <code><a href="#topic+scanone">scanone</a></code>
object.
</p>
<p>The object contains a matrix of three columns for LOD scores, information content
and LOD*information content with pseudo markers sorted in increasing
order. For more information on the scanone object see: <code><a href="#topic+scanone">scanone</a></code>
</p>


<h3>Note</h3>

<p>The resulting scanone object itself can be visualized using the standard R/qtl
plotting routines (<code><a href="#topic+plot.scanone">plot.scanone</a></code>) or specialized function to show
the mqm model (<code><a href="#topic+mqmplot.singletrait">mqmplot.singletrait</a></code>) and QTL profile. If cofactors
were specified the QTL model used in scanning is also returned as a named
attribute of the scanone object called mqmmodel. It can be extracted from the
resulting scanone object by using the <code><a href="#topic+mqmgetmodel">mqmgetmodel</a></code> function or the
<code><a href="base.html#topic+attr">attr</a></code> function.
</p>
<p>Also note the <code>estimate.map</code> parameter does not return
its re-estimated genetic map, altough it is used internally.  When scanning
multiple genotypes a <code>mqmmulti</code> object is created.  This object is just a
list composed of scanone objects. The results for a single trait can be
obtained from the <code>mqmmulti</code> object, in scanone format.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(map10)                    # Genetic map modeled after mouse

# simulate a cross (autosomes 1-10)
qtl &lt;- c(3,15,1,0)             # QTL model: chr, pos'n, add've &amp; dom effects
cross &lt;- sim.cross(map10[1:10],qtl,n=100,missing.prob=0.01)

# MQM
crossaug &lt;- mqmaugment(cross)  # Augmentation
cat(crossaug$mqm$Nind,'real individuals retained in dataset',
    crossaug$mqm$Naug,'individuals augmented\n')

result &lt;- mqmscan(crossaug)    # Scan

# show LOD interval of the QTL on chr 3
lodint(result,chr=3)
</code></pre>

<hr>
<h2 id='mqmscanall'>Parallelized MQM on multiple phenotypes in a cross object</h2><span id='topic+mqmscanall'></span>

<h3>Description</h3>

<p>Parallelized QTL analysis using MQM on multiple phenotypes in a cross object (uses SNOW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mqmscanall(cross, multicore=TRUE, n.clusters = 1,batchsize=10,cofactors=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmscanall_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmscanall_+3A_multicore">multicore</code></td>
<td>
<p> Use multiple cores (only if the package SNOW is available, otherwise this setting will be ignored)
</p>
</td></tr>
<tr><td><code id="mqmscanall_+3A_n.clusters">n.clusters</code></td>
<td>
<p> Number of parallel processes to spawn, recommended is setting this lower than the number of cores in the computer
</p>
</td></tr>
<tr><td><code id="mqmscanall_+3A_batchsize">batchsize</code></td>
<td>
<p> Batch size. The entire set is split in
jobs to reduce memory load per core. Each job contains batchsize number of traits per job.
</p>
</td></tr>
<tr><td><code id="mqmscanall_+3A_cofactors">cofactors</code></td>
<td>
<p>cofactors, only used when scanfunction is mqmscan.
List of cofactors to be analysed in the QTL model. To set cofactors use <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> or <code>mqmsetcofactors</code></p>
</td></tr></table>
<p>. 
</p>
<table role = "presentation">
<tr><td><code id="mqmscanall_+3A_...">...</code></td>
<td>
<p> Parameters passed through to the <code><a href="#topic+mqmscan">mqmscan</a></code> function used in
scanning for QTLs
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>mqmscan</code> to scan for QTL's for each phenotype in the cross object.
It is recomended that the package SNOW is installed before using this function
on large numbers of phenotypes.
</p>


<h3>Value</h3>

<p>Returns a MQMmulti object. This object is a list of <code><a href="#topic+scanone">scanone</a></code>
objects that can be plotted using <code>plot.scanone(result[[trait]])</code> or using <code>mqmplot.multitrait(result)</code>
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>References</h3>


<ul>
<li><p> Rossini, A., Tierney, L., and Li, N. (2003), Simple parallel statistical computing.  <em>R. UW Biostatistics working paper series</em> University of Washington. <b>193</b>
</p>
</li>
<li><p> Tierney, L., Rossini, A., Li, N., and Sevcikova, H. (2004), The snow Package: Simple Network of Workstations. Version 0.2-1.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Doing a multitrait analysis
data(multitrait)

multitrait &lt;- calc.genoprob(multitrait)
cof &lt;- mqmsetcofactors(multitrait,3)
multitrait &lt;- fill.geno(multitrait)
result &lt;- mqmscanall(multitrait,cofactors=cof,batchsize=5)
mqmplot.multitrait(result,"lines")
</code></pre>

<hr>
<h2 id='mqmscanfdr'> Estimate FDR for multiple trait QTL analysis </h2><span id='topic+mqmscanfdr'></span>

<h3>Description</h3>

<p>Estimate the false discovery rate (FDR) for multiple trait analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmscanfdr(cross, scanfunction=mqmscanall,
  thresholds=c(1,2,3,4,5,7,10,15,20), n.perm=10,
  verbose=FALSE, ...
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmscanfdr_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmscanfdr_+3A_scanfunction">scanfunction</code></td>
<td>
<p> QTL mapping function, Note: Must use scanall or mqmscanall. Otherwise this will
not produce usefull results. Reason: We need a function that maps all traits ecause of the correlation
structure which is not changed (between traits) during permutation (Valis options: scanall or mqmscanall)
</p>
</td></tr>
<tr><td><code id="mqmscanfdr_+3A_thresholds">thresholds</code></td>
<td>
<p> False discovery rate (FDR) is calculated for peaks
above these LOD thresholds (DEFAULT=Range from 1 to 20, using 10 thresholds)
Parameter is a list of LOD scores at which FDR is calculated.
</p>
</td></tr>
<tr><td><code id="mqmscanfdr_+3A_n.perm">n.perm</code></td>
<td>
<p> Number of permutations (DEFAULT=10 for quick analysis, however
for publications use 1000, or higher)
</p>
</td></tr>
<tr><td><code id="mqmscanfdr_+3A_verbose">verbose</code></td>
<td>
<p> verbose output </p>
</td></tr>
<tr><td><code id="mqmscanfdr_+3A_...">...</code></td>
<td>
<p> Parameters passed to the mapping function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the analysis of <code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+cim">cim</a></code>
and <code><a href="#topic+mqmscan">mqmscan</a></code> to scan for QTL in shuffled/randomized data. It is
recommended to also install the <code>snow</code> library for parallelization of
calculations. The <code>snow</code> library allows
calculations to run on multiple cores or even scale it up to an entire cluster,
thus speeding up calculation by the number of computers used.
</p>


<h3>Value</h3>

<p>Returns a data.frame with 3 columns: FalsePositives, FalseNegatives and False Discovery Rates.
In the rows the userspecified thresholds are with scores for the 3 columns.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>References</h3>


<ul>
<li><p> Bruno M. Tesson, Ritsert C. Jansen (2009) Chapter 3.7. Determining the significance threshold <em>eQTL Analysis in Mice and Rats</em> <b>1</b>, 20&ndash;25
</p>
</li>
<li><p> Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for quantitative trait mapping. <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>
</li>
<li><p> Rossini, A., Tierney, L., and Li, N. (2003), Simple parallel statistical computing.  <em>R. UW Biostatistics working paper series</em> University of Washington. <b>193</b>
</p>
</li>
<li><p> Tierney, L., Rossini, A., Li, N., and Sevcikova, H. (2004), The snow Package: Simple Network of Workstations. Version 0.2-1.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

# impute missing genotype data
multitrait &lt;- fill.geno(multitrait)
## Not run: # Calculate the thresholds
result &lt;- mqmscanfdr(multitrait, threshold=10.0, n.perm=1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='mqmsetcofactors'>Set cofactors at fixed intervals, to be used with MQM</h2><span id='topic+mqmsetcofactors'></span>

<h3>Description</h3>

<p>Set cofactors, at fixed marker intervals. Together
with <code>mqmscan</code> cofactors are selected through backward elimination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqmsetcofactors(cross, each = NULL, cofactors=NULL, sexfactors=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmsetcofactors_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="mqmsetcofactors_+3A_each">each</code></td>
<td>
<p> Every 'each' marker will be used as a cofactor, when each is used the <code>cofactors</code> and <code>sexfactors</code> parameter is ignored </p>
</td></tr>
<tr><td><code id="mqmsetcofactors_+3A_cofactors">cofactors</code></td>
<td>

<p>List of cofactors to be analysed in the QTL model. To set cofactors use <code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> or <code>mqmsetcofactors</code>; when <code>each</code> is set, this parameter is ignored </p>
</td></tr>
<tr><td><code id="mqmsetcofactors_+3A_sexfactors">sexfactors</code></td>
<td>
<p> list of markers which should be treated as dominant cofactors (sexfactors), when <code>each</code> is set, this parameter is ignored </p>
</td></tr>
<tr><td><code id="mqmsetcofactors_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print tracing information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list of cofactors to be passed into <code><a href="#topic+mqmscan">mqmscan</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ritsert C Jansen; Danny Arends; Pjotr Prins; Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    data(hyper)                                 # Hyper dataset
    
    hyperfilled &lt;- fill.geno(hyper)
  # Automatic cofactors every third marker
    cofactors &lt;- mqmsetcofactors(hyperfilled,3)
    result &lt;- mqmscan(hyperfilled,cofactors)	# Backward model selection
    mqmgetmodel(result)
  #Manual cofactors at markers 3,6,9,12,40 and 60
  cofactors &lt;- mqmsetcofactors(hyperfilled,cofactors=c(3,6,9,12,40,60))
    result &lt;- mqmscan(hyperfilled,cofactors)	# Backward model selection
    mqmgetmodel(result)
</code></pre>

<hr>
<h2 id='mqmtestnormal'> Shapiro normality test used for MQM </h2><span id='topic+mqmtestnormal'></span>

<h3>Description</h3>

<p>Wraps a shapiro's normality test from the nortest package.
This function is used in MQM to test the normality of the
trait under investigation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mqmtestnormal(cross, pheno.col = 1,significance=0.05, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mqmtestnormal_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="mqmtestnormal_+3A_pheno.col">pheno.col</code></td>
<td>

<p>Column number in the phenotype matrix which should be used as the phenotype. This can be a vector of integers. 
</p>
</td></tr>
<tr><td><code id="mqmtestnormal_+3A_significance">significance</code></td>
<td>

<p>Significance level used in the normality test. Lower significance levels will accept larger deviations from normality.
</p>
</td></tr>
<tr><td><code id="mqmtestnormal_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, print result as well as return it.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For augmented data (as from <code><a href="#topic+mqmaugment">mqmaugment</a></code>), the cross
is first reduced to distinct individuals. Furthermore the shapiro used to
test normality works only for 3 &lt;= nind(cross) &lt;= 5000
</p>


<h3>Value</h3>

<p>Boolean indicating normality of the trait in pheno.col. (FALSE
when not normally distributed.)
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> - Function wrapped by our mqmtestnormal
</p>
</li>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

# test normality of 7th phenotype
mqmtestnormal(multitrait, pheno.col=7)

# take log
multitrait &lt;- transformPheno(multitrait, pheno.col=7, transf=log)

# test again
mqmtestnormal(multitrait, pheno.col=7)
</code></pre>

<hr>
<h2 id='multitrait'>
Example Cross object from R/QTL with multiple traits
</h2><span id='topic+multitrait'></span>

<h3>Description</h3>

<p>Cross object from R/QTL, an object of class <code>cross</code> from R/QTL. See <code><a href="#topic+read.cross">read.cross</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multitrait)</code></pre>


<h3>Format</h3>

<p>Cross object from R/QTL
</p>


<h3>Details</h3>

<p>Arabidopsis recombinant inbred lines by selfing.  There are 162
lines, 24 phenotypes, and 117 markers on 5 chromosomes.
</p>


<h3>Source</h3>

<p>Part of the Arabidopsis RIL selfing experiment with Landsberg erecta (Ler) and Cape Verde Islands (Cvi) with 162 individuals scored (with errors at) 117 markers.
Dataset obtained from GBIC - Groningen BioInformatics Centre
</p>


<h3>References</h3>


<ul>
<li><p> Keurentjes, J. J. and Fu, J. and de Vos, C. H. and Lommen, A. and Hall, R. D. and Bino, R. J. and van der Plas, L. H. and Jansen, R. C. and Vreugdenhil, D. and Koornneef, M.
(2006), The genetics of plant metabolism. <em>Nature Genetics.</em>
<b>38</b>-7, 842&ndash;849.
</p>
</li>
<li><p> Alonso-Blanco, C. and Peeters, A. J. and Koornneef, M. and Lister, C. and Dean, C. and van den Bosch, N. and Pot, J. and Kuiper, M. T. (1998),
Development of an AFLP based linkage map of Ler, Col and Cvi
Arabidopsis thaliana ecotypes and construction of a Ler/Cvi recombinant
inbred line population</p>
</li></ul>
<p>. <em>Plant J.</em> <b>14</b>(2), 259&ndash;271.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)					# Load dataset
multitrait &lt;- fill.geno(multitrait)                     # impute missing genotype data

result &lt;- mqmscanall(multitrait, logtransform=TRUE)	# Analyse all 24 traits
</code></pre>

<hr>
<h2 id='nchr'>Determine the number of chromosomes</h2><span id='topic+nchr'></span>

<h3>Description</h3>

<p>Determine the number of chromosomes in a cross
or map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchr(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nchr_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code> (see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or <code>map</code> (see
<code><a href="#topic+sim.map">sim.map</a></code> for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of chromosomes in the input.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>,
<code><a href="#topic+totmar">totmar</a></code>,
<code><a href="#topic+nmar">nmar</a></code>,
<code><a href="#topic+nphe">nphe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
nchr(fake.f2)
map &lt;- pull.map(fake.f2)
nchr(map)
</code></pre>

<hr>
<h2 id='nind'>Determine the number of individuals QTL experiment</h2><span id='topic+nind'></span>

<h3>Description</h3>

<p>Determine the number of individuals in cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nind(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nind_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of individuals in the input cross object.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nmar">nmar</a></code>,
<code><a href="#topic+nchr">nchr</a></code>,
<code><a href="#topic+totmar">totmar</a></code>,
<code><a href="#topic+nphe">nphe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
nind(fake.f2)
</code></pre>

<hr>
<h2 id='nmar'>Determine the numbers of markers on each chromosome</h2><span id='topic+nmar'></span>

<h3>Description</h3>

<p>Determine the number of markers on each chromosome in a cross
or map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmar(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmar_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code> (see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or <code>map</code> (see
<code><a href="#topic+sim.map">sim.map</a></code> for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the numbers of markers on each chromosome in the input.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>,
<code><a href="#topic+nchr">nchr</a></code>,
<code><a href="#topic+totmar">totmar</a></code>,
<code><a href="#topic+nphe">nphe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
nmar(fake.f2)
map &lt;- pull.map(fake.f2)
nmar(map)
</code></pre>

<hr>
<h2 id='nmissing'>Number of missing genotypes</h2><span id='topic+nmissing'></span>

<h3>Description</h3>

<p>Count the number of missing genotypes for each individual or each marker
in a cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmissing(cross, what=c("ind","mar"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmissing_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="nmissing_+3A_what">what</code></td>
<td>
<p>Indicates whether to count missing genotypes for each
individual or each marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the number of missing genotypes for each
individual or for each marker.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ntyped">ntyped</a></code>, <code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>, <code><a href="#topic+totmar">totmar</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

# plot number of missing genotypes for each individual
plot(nmissing(listeria))

# plot number of missing genotypes for each marker
plot(nmissing(listeria, what="mar"))
</code></pre>

<hr>
<h2 id='nphe'>Determine the number of phenotypes QTL experiment</h2><span id='topic+nphe'></span>

<h3>Description</h3>

<p>Determine the number of phenotypes in cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nphe(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nphe_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of phenotypes in the input cross object.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nmar">nmar</a></code>,
<code><a href="#topic+nchr">nchr</a></code>,
<code><a href="#topic+totmar">totmar</a></code>,
<code><a href="#topic+nind">nind</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
nphe(fake.f2)
</code></pre>

<hr>
<h2 id='nqrank'>Transform a vector of quantitative values to the corresponding
normal quantiles</h2><span id='topic+nqrank'></span>

<h3>Description</h3>

<p>Transform a vector of quantitative values to the corresponding normal
quantiles (preserving the mean and SD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nqrank(x, jitter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nqrank_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="nqrank_+3A_jitter">jitter</code></td>
<td>
<p>If TRUE, randomly jitter the values to break ties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector; the input <code>x</code> is converted to ranks and then to
normal quantiles.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+rank">rank</a></code>, <code><a href="stats.html#topic+qnorm">qnorm</a></code>, <code>transformPheno</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- transformPheno(hyper, pheno.col=1, transf=nqrank)
</code></pre>

<hr>
<h2 id='nqtl'>Determine the number of QTL in a QTL object</h2><span id='topic+nqtl'></span>

<h3>Description</h3>

<p>Determine the number of QTL in a QTL object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nqtl(qtl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nqtl_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>qtl</code>.  See
<code><a href="#topic+makeqtl">makeqtl</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of QTL in the input QTL object.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>, <code><a href="#topic+replaceqtl">replaceqtl</a></code>,
<code><a href="#topic+addtoqtl">addtoqtl</a></code>, <code><a href="#topic+summary.qtl">summary.qtl</a></code>,
<code><a href="#topic+reorderqtl">reorderqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c("1", "6", "13")
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

nqtl(qtl)
</code></pre>

<hr>
<h2 id='ntyped'>Number of genotypes</h2><span id='topic+ntyped'></span>

<h3>Description</h3>

<p>Count the number of genotypes for each individual or each marker
in a cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntyped(cross, what=c("ind","mar"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntyped_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="ntyped_+3A_what">what</code></td>
<td>
<p>Indicates whether to count genotypes for each
individual or each marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the number of genotypes for each
individual or for each marker.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmissing">nmissing</a></code>,  <code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>, <code><a href="#topic+totmar">totmar</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)

# plot number of genotypes for each individual
plot(ntyped(listeria))

# plot number of genotypes for each marker
plot(ntyped(listeria, what="mar"))
</code></pre>

<hr>
<h2 id='nullmarkers'>Identify markers without any genotype data</h2><span id='topic+nullmarkers'></span>

<h3>Description</h3>

<p>Identify markers in a cross that have no genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullmarkers(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullmarkers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Marker names (a vector of character strings) with no genotype data.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># one marker with no data
data(hyper)
nullmarkers(hyper)

# nothing in listeria
data(listeria)
nullmarkers(listeria)
</code></pre>

<hr>
<h2 id='orderMarkers'>Find an initial order for markers within chromosomes</h2><span id='topic+orderMarkers'></span>

<h3>Description</h3>

<p>Establish initial orders for markers within chromosomes by a greedy
algorithm, adding one marker at a time with locations of previous
markers fixed, in the position giving the miniminum number of obligate
crossovers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderMarkers(cross, chr, window=7, use.ripple=TRUE, error.prob=0.0001,
             map.function=c("haldane","kosambi","c-f","morgan"),
             maxit=4000, tol=1e-4, sex.sp=TRUE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderMarkers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_window">window</code></td>
<td>
<p>If <code>use.ripple=TRUE</code>, this indicates the number of
markers to include in the sliding window of permuted markers.  Larger
numbers result in the comparison of a greater number of marker
orders, but will require a considerable increase in computation
time.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_use.ripple">use.ripple</code></td>
<td>
<p>If TRUE, the initial order is refined by a call to
the function <code><a href="#topic+ripple">ripple</a></code>.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the final
estimated map.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_map.function">map.function</code></td>
<td>
<p>Indicates the map function to use in the final
estimated map.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform in the final
estimated map.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence in the final estimated
map.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps in the
final estimated map; this is used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="orderMarkers_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, information about the progress of the
calculations is displayed; if &gt; 1, even more information is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markers within a linkage group are considered in order of decreasing
number of genotyped individuals.  The first two markers are placed in
an arbitrary order.  Additional markers are considered one at a time,
and each possible placement of a marker is compared (with the order of
the previously placed markers taken as fixed) via the number of
obligate crossovers (that is, the minimal number of crossovers that
would explain the observed data).  The marker is placed in the
position giving the minimal number of obligate crossovers.  If
multiple positions give the same number of obligate crossovers, a
single location (among those positions) is chosen at random.
</p>
<p>If <code>use.ripple=TRUE</code>, the final order is passed to
<code><a href="#topic+ripple">ripple</a></code> with <code>method="countxo"</code> to refine the
marker order.  If <code>use.ripple=TRUE</code> and the number of markers on
a chromosome is <code class="reqn">\le</code> the argument <code>window</code>, the initial
greedy algorithm is skipped and all possible marker orders are
compared via <code><a href="#topic+ripple">ripple</a></code>.
</p>


<h3>Value</h3>

<p>The output is a cross object, as in the input, with orders of markers
on selected chromosomes revised.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+formLinkageGroups">formLinkageGroups</a></code>,
<code><a href="#topic+ripple">ripple</a></code>, <code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+countXO">countXO</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
pull.map(listeria, chr=3)
revcross &lt;- orderMarkers(listeria, chr=3, use.ripple=FALSE)
pull.map(revcross, chr=3)
</code></pre>

<hr>
<h2 id='phenames'>Pull out the phenotypes names from a cross</h2><span id='topic+phenames'></span>

<h3>Description</h3>

<p>Pull out the phenotype names from a cross object as a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenames(cross)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phenames_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings (the phenotype names).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+markernames">markernames</a></code>, <code><a href="#topic+chrnames">chrnames</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
phenames(listeria)
</code></pre>

<hr>
<h2 id='pickMarkerSubset'>Identify the largest subset of markers that are some distance apart</h2><span id='topic+pickMarkerSubset'></span>

<h3>Description</h3>

<p>Identify the largest subset of markers for which no two adjacent
markers are separated by less than some specified distance; if weights
are provided, find the marker subset for which the sum of the weights
is maximized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickMarkerSubset(locations, min.distance, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pickMarkerSubset_+3A_locations">locations</code></td>
<td>
<p>A vector of marker locations.</p>
</td></tr>
<tr><td><code id="pickMarkerSubset_+3A_min.distance">min.distance</code></td>
<td>
<p>Minimum distance between adjacent markers in the
chosen subset.</p>
</td></tr>
<tr><td><code id="pickMarkerSubset_+3A_weights">weights</code></td>
<td>
<p>(Optional) vector of weights for the markers.  If
missing, we take <code>weights == 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d_i</code> be
the location of marker <code class="reqn">i</code>, for <code class="reqn">i \in 1, \dots, M</code>.  We use the dynamic programming algorithm of Broman and Weber
(1999) to identify the subset of markers <code class="reqn">i_1, \dots, i_k</code> for which <code class="reqn">d_{i_{j+1}} - d_{i_j} \le</code>
<code>min.distance</code> and <code class="reqn">\sum w_{i_j}</code> is maximized.
</p>
<p>If there are multiple optimal subsets, we pick one at random.
</p>


<h3>Value</h3>

<p>A vector of marker names.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Broman,  K. W. and Weber,  J. L. (1999) Method for constructing
confidently ordered linkage maps. <em>Genet. Epidemiol.</em>, <b>16</b>,
337&ndash;343.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+pull.markers">pull.markers</a></code>,
<code><a href="#topic+findDupMarkers">findDupMarkers</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

# subset of markers on chr 4 spaced &gt;= 5 cM
pickMarkerSubset(pull.map(hyper)[[4]], 5)

# no. missing genotypes at each chr 4 marker
n.missing &lt;- nmissing(subset(hyper, chr=4), what="mar")

# weight by -log(prop'n missing), but don't let 0 missing go to +Inf
wts &lt;- -log( (n.missing+1) / (nind(hyper)+1) )

# subset of markers on chr 4 spaced &gt;= 5 cM, with weights = -log(prop'n missing)
pickMarkerSubset(pull.map(hyper)[[4]], 5, wts)
</code></pre>

<hr>
<h2 id='plot.comparegeno'>Plot genotype comparison</h2><span id='topic+plot.comparegeno'></span>

<h3>Description</h3>

<p>Plot the results of the comparison of all pairs of individuals'
genotypes. A histogram of the proportion of matching genotypes, with
tick marks at individual values below, via <code><a href="graphics.html#topic+rug">rug</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'comparegeno'
plot(x, breaks=NULL, main="",
     xlab="Proportion matching genotypes", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.comparegeno_+3A_x">x</code></td>
<td>
<p>An object of class <code>"comparegeno"</code>, as produced by
<code><a href="#topic+comparegeno">comparegeno</a></code>.</p>
</td></tr>
<tr><td><code id="plot.comparegeno_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code>, with the default
<code class="reqn">2 \sqrt{n}</code> where <code class="reqn">n</code> is the number of pairs of individuals.</p>
</td></tr>
<tr><td><code id="plot.comparegeno_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="plot.comparegeno_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label for the plot.</p>
</td></tr>
<tr><td><code id="plot.comparegeno_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a histogram with <code><a href="graphics.html#topic+hist">hist</a></code> with ticks at
individual values using <code><a href="graphics.html#topic+rug">rug</a></code>.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+comparegeno">comparegeno</a></code>, <code><a href="#topic+summary.comparegeno">summary.comparegeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
cg &lt;- comparegeno(fake.f2)
plot(cg)
</code></pre>

<hr>
<h2 id='plot.cross'>Plot various features of a cross object</h2><span id='topic+plot.cross'></span>

<h3>Description</h3>

<p>Plots grid of the missing genotypes, genetic map, and histograms or
barplots of phenotypes for the data from an experimental cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
plot(x, auto.layout=TRUE, pheno.col,
          alternate.chrid=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cross_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.cross_+3A_auto.layout">auto.layout</code></td>
<td>
<p>If TRUE, <code>par(mfrow)</code> is set so that all plots
fit within one figure.</p>
</td></tr>
<tr><td><code id="plot.cross_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Vector of numbers or character strings corresponding to
phenotypes that should be plotted. If unspecified, all phenotypes are
plotted.</p>
</td></tr>
<tr><td><code id="plot.cross_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plot.cross_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code><a href="#topic+plotMissing">plotMissing</a></code>, <code><a href="#topic+plotMap">plotMap</a></code> and
<code><a href="#topic+plotPheno">plotPheno</a></code> to plot the missing genotypes, genetic
map, and histograms or barplots of all phenotypes.
</p>
<p>If <code>auto.format=TRUE</code>, <code>par(mfrow)</code> is used with
<code>ceiling(sqrt(n.phe+2))</code> rows and the minimum number of columns
so that all plots fit on the plotting device.
</p>
<p>Numeric phenotypes are displayed as histograms or barplots by calling
<code><a href="#topic+plotPheno">plotPheno</a></code>.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Brian Yandell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotMissing">plotMissing</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotPheno">plotPheno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
plot(fake.bc)
</code></pre>

<hr>
<h2 id='plot.qtl'>Plot QTL locations</h2><span id='topic+plot.qtl'></span>

<h3>Description</h3>

<p>Plot the locations of the QTL against a genetic map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtl'
plot(x, chr, horizontal=FALSE, shift=TRUE,
     show.marker.names=FALSE, alternate.chrid=FALSE, justdots=FALSE,
     col="red", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.qtl_+3A_x">x</code></td>
<td>
<p>An object of class <code>"qtl"</code>, as produced by
<code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_horizontal">horizontal</code></td>
<td>
<p>Specifies whether the chromosomes should be
plotted horizontally.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_shift">shift</code></td>
<td>
<p>If TRUE, shift the first marker on each chromosome to be
at 0 cM.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_show.marker.names">show.marker.names</code></td>
<td>
<p>If TRUE, marker names are included.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_justdots">justdots</code></td>
<td>
<p>If FALSE, just plot dots at the QTL, rather than
arrows and QTL names.</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_col">col</code></td>
<td>
<p>Color used to plot indications of QTL</p>
</td></tr>
<tr><td><code id="plot.qtl_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+plotMap">plotMap</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a plot, via <code><a href="#topic+plotMap">plotMap</a></code>, and indicates the
locations of the QTL in the input QTL object, <code>x</code>.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotMap">plotMap</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c("1", "6", "13")
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")
plot(qtl)
plot(qtl, justdots=TRUE, col="seagreen")
</code></pre>

<hr>
<h2 id='plot.rfmatrix'>Plot recombination fractions or LOD scores for a single marker</h2><span id='topic+plot.rfmatrix'></span>

<h3>Description</h3>

<p>Plot a slice (corresponding to a single marker) through the pairwise
recombination fractions or LOD scores calculated by
<code><a href="#topic+est.rf">est.rf</a></code> and extracted with <code><a href="#topic+pull.rf">pull.rf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfmatrix'
plot(x, marker, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rfmatrix_+3A_x">x</code></td>
<td>
<p>An object of class <code>rfmatrix</code>, as output by <code><a href="#topic+pull.rf">pull.rf</a></code>.</p>
</td></tr>
<tr><td><code id="plot.rfmatrix_+3A_marker">marker</code></td>
<td>
<p>A single marker name, as a character string.</p>
</td></tr>
<tr><td><code id="plot.rfmatrix_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"scanone"</code> (as output by <code><a href="#topic+scanone">scanone</a></code>,
and which may be summarized by <code><a href="#topic+summary.scanone">summary.scanone</a></code> or plotted
with <code><a href="#topic+plot.scanone">plot.scanone</a></code>), containing the estimated recombination
fractions or LOD scores for the input marker against all others.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.rf">pull.rf</a></code>, <code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+plotRF">plotRF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- est.rf(fake.f2)
marker &lt;- markernames(fake.f2, chr=5)[6]
lod &lt;- pull.rf(fake.f2, "lod")
plot(lod, marker, bandcol="gray70")
</code></pre>

<hr>
<h2 id='plot.scanone'>Plot LOD curves</h2><span id='topic+plot.scanone'></span>

<h3>Description</h3>

<p>Plot the LOD curve for a genome scan with a single-QTL model (the
output of <code><a href="#topic+scanone">scanone</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
plot(x, x2, x3, chr, lodcolumn=1, incl.markers=TRUE,
     xlim, ylim, lty=1, col=c("black","blue","red"), lwd=2,
     add=FALSE, gap=25, mtick = c("line", "triangle"),
     show.marker.names=FALSE, alternate.chrid=FALSE,
     bandcol=NULL, type="l", cex=1, pch=1, bg="transparent",
     bgrect=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scanone_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scanone"</code>, as output by
<code><a href="#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_x2">x2</code></td>
<td>
<p>Optional second <code>scanone</code> object.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_x3">x3</code></td>
<td>
<p>Optional third <code>scanone</code> object.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer, or vector of 3 integers, indicating which
of the LOD score columns should be plotted (generally this is 1).</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_incl.markers">incl.markers</code></td>
<td>
<p>Indicate whether to plot line segments at the
marker locations.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis (optional).</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis (optional).</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_lty">lty</code></td>
<td>
<p>Line types; a vector of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_col">col</code></td>
<td>
<p>Line colors; a vector of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_lwd">lwd</code></td>
<td>
<p>Line widths; a vector of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_add">add</code></td>
<td>
<p>If TRUE, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_mtick">mtick</code></td>
<td>
<p>Tick mark type for markers (line segments or
upward-pointing triangels).</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_show.marker.names">show.marker.names</code></td>
<td>
<p>If TRUE, show the marker names along the x axis.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_bandcol">bandcol</code></td>
<td>
<p>Optional color for alternating bands to indicate
chromosomes.  If NULL (the default), no bands are plotted.  A good
choice might be <code>bandcol="gray70"</code>.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>plot</code>): for
example, <code>type="l"</code> for lines or <code>type="p"</code> for points only,
may be of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_cex">cex</code></td>
<td>
<p>Point size expansion, for example if <code>type="p"</code> is used.
May be of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_pch">pch</code></td>
<td>
<p>Point type, for example if <code>type="p"</code> is used. See <code><a href="graphics.html#topic+points">points</a></code>.
May be of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_bg">bg</code></td>
<td>
<p>Background color for points, for example if <code>type="p"</code>
and <code>pch=21</code> are used. See <code><a href="graphics.html#topic+points">points</a></code>.
May be of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_bgrect">bgrect</code></td>
<td>
<p>Optional background color for the rectangular plotting region.</p>
</td></tr>
<tr><td><code id="plot.scanone_+3A_...">...</code></td>
<td>
<p>Passed to the function <code>plot</code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to plot the results of up to three genome
scans against one another.  Such objects must conform with each
other.
</p>
<p>One may alternatively use the argument <code>add</code> to add the plot of
an additional genome scan to the current figure, but some care is
required: the same chromosomes should be selected, and the results
must concern crosses with the same genetic maps.
</p>
<p>If a single <code>scanone</code> object containing multiple LOD score
columns (for example, from different phenotypes) is input, up to three
LOD curves may be plotted, by providing a vector in the argument
<code>lodcolumn</code>.  If multiple <code>scanone</code> objects are input (via
<code>x</code>, <code>x2</code> and <code>x3</code>), the LOD score columns to be
plotted are chosen from the corresponding element of the
<code>lodcolumn</code> argument.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="#topic+add.threshold">add.threshold</a></code>, <code><a href="#topic+xaxisloc.scanone">xaxisloc.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2,step=2.5)
out.mr &lt;- scanone(fake.f2, method="mr")
out.em &lt;- scanone(fake.f2, method="em")
plot(out.mr)
plot(out.mr, out.em, chr=c(1,13), lty=1, col=c("violetred","black"))
out.hk &lt;- scanone(fake.f2, method="hk")
plot(out.hk, chr=c(1,13), add=TRUE, col="slateblue")

plot(out.hk, chr=13, show.marker.names=TRUE)

plot(out.hk, bandcol="gray70")

# plot points rather than lines
plot(out.hk, bandcol="gray70", type="p", cex=0.3, pch=21, bg="slateblue")
</code></pre>

<hr>
<h2 id='plot.scanoneboot'>Plot results of bootstrap for QTL position</h2><span id='topic+plot.scanoneboot'></span>

<h3>Description</h3>

<p>Plot a histogram of the results of a nonparametric bootstrap to assess
uncertainty in QTL position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneboot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scanoneboot_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scanoneboot"</code>, as output by
<code><a href="#topic+scanoneboot">scanoneboot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scanoneboot_+3A_...">...</code></td>
<td>
<p>Passed to the function <code><a href="graphics.html#topic+hist">hist</a></code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots a histogram of the bootstrap results obtained by
<code><a href="#topic+scanoneboot">scanoneboot</a></code>.  Genetic marker locations are
displayed by vertical lines at the bottom of the plot.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanoneboot">summary.scanoneboot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2, step=1)

## Not run: out.boot &lt;- scanoneboot(fake.f2, chr=13, method="hk")


summary(out.boot)
plot(out.boot)
</code></pre>

<hr>
<h2 id='plot.scanoneperm'>Plot permutation results for a single-QTL genome scan</h2><span id='topic+plot.scanoneperm'></span>

<h3>Description</h3>

<p>Plot a histogram of the permutation results from a single-QTL genome
scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneperm'
plot(x, lodcolumn=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scanoneperm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scanoneperm"</code>, as output by
<code><a href="#topic+scanone">scanone</a></code> when <code>n.perm</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.scanoneperm_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>This indicates the LOD score column to plot.  This
should be a single number between 1 and the number of LOD columns in
the object input.</p>
</td></tr>
<tr><td><code id="plot.scanoneperm_+3A_...">...</code></td>
<td>
<p>Passed to the function <code><a href="graphics.html#topic+hist">hist</a></code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots a histogram of the permutation results obtained by
<code><a href="#topic+scanone">scanone</a></code> when <code>n.perm</code> is specified. If
separate permutations were performed for the autosomes and the X
chromosome (using <code>perm.Xsp=TRUE</code>), separate histograms are given.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
fake.bc &lt;- calc.genoprob(fake.bc)

operm &lt;- scanone(fake.bc, method="hk", n.perm=100)
plot(operm)
</code></pre>

<hr>
<h2 id='plot.scanPhyloQTL'>Plot LOD curves from single-QTL scan to map QTL to a phylogenetic tree</h2><span id='topic+plot.scanPhyloQTL'></span>

<h3>Description</h3>

<p>Plot the LOD curves for each partition for a genome scan with a single
diallelic QTL (the
output of <code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanPhyloQTL'
plot(x, chr, incl.markers=TRUE,
     col, xlim, ylim, lwd=2, gap=25, mtick=c("line", "triangle"),
     show.marker.names=FALSE, alternate.chrid=FALSE, legend=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scanPhyloQTL_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scanPhyloQTL"</code>, as output by
<code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_incl.markers">incl.markers</code></td>
<td>
<p>Indicate whether to plot line segments at the
marker locations.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_col">col</code></td>
<td>
<p>Optional vector of colors to use for each partition.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis (optional).</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis (optional).</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_lwd">lwd</code></td>
<td>
<p>Line width.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_mtick">mtick</code></td>
<td>
<p>Tick mark type for markers (line segments or
upward-pointing triangels).</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_show.marker.names">show.marker.names</code></td>
<td>
<p>If TRUE, show the marker names along the x axis.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_legend">legend</code></td>
<td>
<p>Indicates whether to include a legend in the plot.</p>
</td></tr>
<tr><td><code id="plot.scanPhyloQTL_+3A_...">...</code></td>
<td>
<p>Passed to the function <code><a href="#topic+plot.scanone">plot.scanone</a></code> when it
is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>, <code><a href="#topic+max.scanPhyloQTL">max.scanPhyloQTL</a></code>,
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+inferredpartitions">inferredpartitions</a></code>,
<code><a href="#topic+simPhyloQTL">simPhyloQTL</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]

# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
x &lt;- lapply(x, calc.genoprob, step=2)

# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# maximum peak
max(out, format="lod")

# approximate posterior probabilities at peak
max(out, format="postprob")

# all peaks above a threshold for LOD(best) - LOD(2nd best)
summary(out, threshold=1, format="lod")

# all peaks above a threshold for LOD(best), showing approx post'r prob
summary(out, format="postprob", threshold=3)

# plot of results
plot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.scantwo'>Plot LOD scores for a two-dimensional genome scan</h2><span id='topic+plot.scantwo'></span>

<h3>Description</h3>

<p>Plot the results of a two-dimensional, two-QTL genome scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
plot(x, chr, incl.markers=FALSE, zlim, lodcolumn=1,
     lower = c("full", "add", "cond-int", "cond-add", "int"),
     upper = c("int", "cond-add", "cond-int", "add", "full"),
     nodiag=TRUE, contours=FALSE, main, zscale=TRUE, point.at.max=FALSE,
     col.scheme = c("viridis", "redblue","cm","gray","heat","terrain","topo"),
     gamma=0.6, allow.neg=FALSE, alternate.chrid=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scantwo_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scantwo"</code>, as output by
<code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, plot LOD scores on an evenly
spaced grid (not including the results at the markers).</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 (optional), indicating the z limits
for the lower-right and upper-left triangles, respectively.  If one
number is given, the same limits are used for both triangles.  If
<code>zlim</code> is missing, the maximum limits are used for each.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If the scantwo results contain LOD scores for
multiple phenotypes, this argument indicates which to use in the
plot.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_lower">lower</code></td>
<td>
<p>Indicates which LOD scores should be plotted in the lower
triangle.  See the details below.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_upper">upper</code></td>
<td>
<p>Indicates which LOD scores should be plotted in the upper
triangle.  See the details below.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_nodiag">nodiag</code></td>
<td>
<p>If TRUE, suppress the plot of the scanone output
(which is normally along the diagonal.)</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_contours">contours</code></td>
<td>
<p>If TRUE, add a contour to the plot at 1.5-LOD below
its maximum, using a call to <code><a href="graphics.html#topic+contour">contour</a></code>.  If a
numeric vector, contours are drawn at these values below the maximum
LOD.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_main">main</code></td>
<td>
<p>An optional title for the plot.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_zscale">zscale</code></td>
<td>
<p>If TRUE, a color scale is plotted at the right.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_point.at.max">point.at.max</code></td>
<td>
<p>If TRUE, plot an X at the maximum LOD.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_col.scheme">col.scheme</code></td>
<td>
<p>Name of color pallet. The default is &quot;viridis&quot;; see
Option D at <a href="https://bids.github.io/colormap/">https://bids.github.io/colormap/</a></p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_gamma">gamma</code></td>
<td>
<p>Parameter affecting range of colors when
<code>col.scheme="gray"</code> or <code>="redblue"</code>.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_allow.neg">allow.neg</code></td>
<td>
<p>If TRUE, allow the plot of negative LOD scores; in
this case, the z-limits are symmetric about 0.  This option is
chiefly to allow a plot of difference between LOD scores from
different methods, calculated via <code><a href="#topic+-.scantwo">-.scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plot.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+image">image</a></code> to plot a grid of LOD scores.  The
particular LOD scores plotted in the upper-left and lower-right
triangles are selected via <code>upper</code> and <code>lower</code>,
respectively.  By default, the upper-left triangle contains the
epistasis LOD
scores (<code>"int"</code>), and the lower-right triangle contains the LOD
scores for the full model (<code>"full"</code>).
The diagonal contains either all zeros or the main effects LOD scores
(from <code><a href="#topic+scanone">scanone</a></code>).
</p>
<p>The <code><a href="#topic+scantwo">scantwo</a></code> function calculates, for each pair of
putative QTLs, <code class="reqn">(q_1,q_2)</code>, the likelihood under the
null model <code class="reqn">L_0</code>, the likelihood under each of the single-QTL
models, <code class="reqn">L(q_1)</code> and <code class="reqn">L(q_2)</code>, the likelihood
under an additive QTL model, <code class="reqn">L_a(q_1,q_2)</code>, and the
likelihood under a full QTL model (including QTL-QTL interaction),
<code class="reqn">L_f(q_1,q_2)</code>.
</p>
<p>The five possible LOD scores that may be plotted are the following.
The epistasis LOD scores (<code>"int"</code>) are <code class="reqn">LOD_i = \log_{10}
    L_f(q_1,q_2) - \log_{10} L_a(q_1,q_2)</code>.
</p>
<p>The full LOD scores (<code>"full"</code>) are
<code class="reqn">LOD_f = \log_{10} L_f(q_1,q_2) - \log_{10} L_0</code>.
</p>
<p>The additive LOD scores (<code>"add"</code>) are
<code class="reqn">LOD_a = \log_{10} L_a(q_1,q_2) - \log_{10} L_0</code>.
</p>
<p>In addition, we may calculate, for each pair of
chromosomes, the difference between the full LOD score and the
maximum single-QTL LOD scores for that pair of chromosomes
(<code>"cond-int"</code>).
</p>
<p>Finally, we may calculate, for each pair of
chromosomes, the difference between the additive LOD score and the
maximum single-QTL LOD scores for that pair of chromosomes
(<code>"cond-add"</code>).
</p>
<p>If a color scale is plotted (<code>zscale=TRUE</code>), the axis on the
left indicates the scale for the upper-left triangle,
while the axis on the right indicates the scale for the
lower-right triangle.  Note that the axis labels can get screwed up
if you change the size of the figure window; you'll need to redo the
plot.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Output of addpair</h3>

<p><b>Note</b> that, for output from <code><a href="#topic+addpair">addpair</a></code> in which the
new loci are indicated explicitly in the formula, the summary provided
by <code>plot.scantwo</code> is somewhat special.  In particular, the
<code>lower</code> and <code>upper</code> arguments are ignored.
</p>
<p>In the case that the formula used in <code><a href="#topic+addpair">addpair</a></code> was
not symmetric in the two new QTL, the x-axis in the plot corresponds
to the first of the new QTL and the y-axis corresponds to the second
of the new QTL.
</p>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman,
<a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Brian Yandell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+-.scantwo">-.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- calc.genoprob(hyper, step=5)


# 2-d scan by EM and by Haley-Knott regression
out2.em &lt;- scantwo(hyper, method="em")
out2.hk &lt;- scantwo(hyper, method="hk")

# plot epistasis and full LOD scores
plot(out2.em)

# plot cond-int in upper triangle and full in lower triangle
#     for chromosomes 1, 4, 6, 15
plot(out2.em, upper="cond-int", chr=c(1,4,6,15))

# plot cond-add in upper triangle and add in lower triangle
#     for chromosomes 1, 4
plot(out2.em, upper="cond-add", lower="add", chr=c(1,4))

# plot the differences between the LOD scores from Haley-Knott
#     regression and the EM algorithm
plot(out2.hk - out2.em, allow.neg=TRUE)
</code></pre>

<hr>
<h2 id='plot.scantwoperm'>Plot permutation results for a 2d, 2-QTL genome scan</h2><span id='topic+plot.scantwoperm'></span>

<h3>Description</h3>

<p>Plot a histogram of the permutation results from a two-dimensional,
two-QTL genome scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwoperm'
plot(x, lodcolumn=1, include_rug=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scantwoperm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scantwoperm"</code>, as output by
<code><a href="#topic+scantwo">scantwo</a></code> when <code>n.perm</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.scantwoperm_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>This indicates the LOD score column to plot.  This
should be a single number between 1 and the number of LOD columns in
the object input.</p>
</td></tr>
<tr><td><code id="plot.scantwoperm_+3A_include_rug">include_rug</code></td>
<td>
<p>If TRUE, include a call to <code><a href="graphics.html#topic+rug">rug</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scantwoperm_+3A_...">...</code></td>
<td>
<p>Passed to the function <code><a href="graphics.html#topic+hist">hist</a></code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots a histogram of the permutation results obtained by
<code><a href="#topic+scantwo">scantwo</a></code> when <code>n.perm</code> is specified. Separate
histograms are provided for the five LOD scores, <code>full</code>,
<code>fv1</code>, <code>int</code>, <code>add</code>, and <code>av1</code>.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
fake.bc &lt;- calc.genoprob(fake.bc)

operm2 &lt;- scantwo(fake.bc, method="hk", n.perm=10)
plot(operm2)
</code></pre>

<hr>
<h2 id='plotErrorlod'>Plot grid of error LOD values</h2><span id='topic+plotErrorlod'></span>

<h3>Description</h3>

<p>Plot a grid of the LOD scores indicating which genotypes are
likely to be in error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotErrorlod(x, chr, ind, breaks=c(-Inf,2,3,4.5,Inf),
              col=c("white","gray85","hotpink","purple3"),
              alternate.chrid=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotErrorlod_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to be drawn in
the plot. This should be a vector of character strings referring to
chromosomes by name; numeric values are converted to strings.  Refer
to chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_ind">ind</code></td>
<td>
<p>Indicates the individuals for which the error LOD scores
should be plotted (passed to <code><a href="#topic+subset.cross">subset.cross</a></code>).</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_breaks">breaks</code></td>
<td>
<p>A set of breakpoints for the colors; must give one more
breakpoint than color.  Intervals are open on the left and closed on
the right, except for the lowest interval.</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_col">col</code></td>
<td>
<p>A vector of colors to appear in the image.</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotErrorlod_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+image">image</a></code> to plot a grid with different shades
of pixels to indicate which genotypes are likely to be in error.
</p>
<p>Darker pixels have higher error LOD scores:
<code class="reqn">LOD \le 2</code> in white;
<code class="reqn">2 &lt; LOD \le 3</code> in gray;
<code class="reqn">3 &lt; LOD \le 4.5</code> in pink;
<code class="reqn">LOD &gt; 4.5</code> in purple.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Lincoln, S. E. and Lander, E. S. (1992) Systematic detection of
errors in genetic linkage data.  <em>Genomics</em> <b>14</b>, 604&ndash;610.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.errorlod">calc.errorlod</a></code>,
<code><a href="#topic+top.errorlod">top.errorlod</a></code>, <code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="#topic+subset.cross">subset.cross</a></code>, <code><a href="#topic+plotGeno">plotGeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

# Calculate error LOD scores
hyper &lt;- calc.errorlod(hyper,error.prob=0.01)

# plot the error LOD scores; print those above a specified cutoff
plotErrorlod(hyper)
plotErrorlod(hyper,chr=1)
</code></pre>

<hr>
<h2 id='plotGeno'>Plot observed genotypes, flagging likely errors</h2><span id='topic+plotGeno'></span>

<h3>Description</h3>

<p>Plot the genotypes on a particular chromosome for a set of
individuals, flagging likely errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeno(x, chr, ind, include.xo=TRUE, horizontal=TRUE,
          cutoff=4, min.sep=2, cex=1.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGeno_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details. </p>
</td></tr>
<tr><td><code id="plotGeno_+3A_chr">chr</code></td>
<td>
<p>The chromosome to plot.  Only one chromosome is
allowed. (This should be a character string referring to the
chromosomes by name.)</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_ind">ind</code></td>
<td>
<p>Vector of individuals to plot (passed to <code><a href="#topic+subset.cross">subset.cross</a></code>).  If missing, all individuals
are plotted.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_include.xo">include.xo</code></td>
<td>
<p>If TRUE, plot X's in intervals having a
crossover. Not available for a 4-way cross.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_horizontal">horizontal</code></td>
<td>
<p>If TRUE, chromosomes are plotted horizontally.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_cutoff">cutoff</code></td>
<td>
<p>Genotypes with error LOD scores above this value are
flagged as possible errors.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_min.sep">min.sep</code></td>
<td>
<p>Markers separated by less than this value (as a
percent of the chromosome length) are pulled apart, so that they may
be distinguished in the picture.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_cex">cex</code></td>
<td>
<p>Character expansion for the size of points in the plot.
Larger numbers give larger points; see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotGeno_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the genotypes for a set of individuals.  Likely errors are
indicated by red squares.  In a backcross, genotypes AA and AB are
indicated by white and black circles, respectively.  In an intercross,
genotypes AA, AB and BB are indicated by white, gray, and black
circles, respectively, and the partially missing genotypes &quot;not BB&quot;
(D in mapmaker) and &quot;not AA&quot; (C in mapmaker) are indicated by green
and orange circles, respectively.
</p>
<p>For the X chromosome in a backcross or intercross, hemizygous males
are plotted as if they were homozygous (that is, with white and black
circles).
</p>
<p>For a 4-way cross, two lines are plotted for each individual.  The
left or upper line indicates the allele A (white) or B (black); the
right or lower line indicates the allele C (white) or D (black).  For
the case that genotype is known to be only AC/BD or AD/BC, we use
green and orange, respectively.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.errorlod">calc.errorlod</a></code>,
<code><a href="#topic+top.errorlod">top.errorlod</a></code>, <code><a href="#topic+subset.cross">subset.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

# Calculate error LOD scores
hyper &lt;- calc.errorlod(hyper,error.prob=0.01)

# print those above a specified cutoff
top.errorlod(hyper,cutoff=4)

# plot genotype data, flagging genotypes with error LOD &gt; cutoff
plotGeno(hyper, chr=1, ind=160:200, cutoff=7, min.sep=2)
</code></pre>

<hr>
<h2 id='plotInfo'>Plot the proportion of missing genotype information</h2><span id='topic+plotInfo'></span>

<h3>Description</h3>

<p>Plot a measure of the proportion of missing information in the
genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotInfo(x, chr, method=c("entropy","variance","both"), step=1,
          off.end=0, error.prob=0.001,
          map.function=c("haldane","kosambi","c-f","morgan"),
          alternate.chrid=FALSE, fourwaycross=c("all", "AB", "CD"),
          include.genofreq=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotInfo_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_method">method</code></td>
<td>
<p>Indicates whether to plot the entropy version of the
information, the variance version, or both.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which the
missing information is calculated, though for <code>step=0</code>,
it is are calculated only at the marker locations.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_off.end">off.end</code></td>
<td>
<p>Distance (in cM) past the terminal markers on each
chromosome to which the genotype probability calculations will be
carried.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi or
Carter-Falconer map function when converting genetic distances into
recombination fractions.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_fourwaycross">fourwaycross</code></td>
<td>
<p>For a phase-known four-way cross, measure missing
genotype information overall (<code>"all"</code>), or just for the alleles
from the first parent (<code>"AB"</code>) or from the second parent (<code>"CD"</code>).</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_include.genofreq">include.genofreq</code></td>
<td>
<p>If TRUE, estimated genotype frequencies (from
the results of
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code> averaged across the individuals) are
included as additional columns in the output.</p>
</td></tr>
<tr><td><code id="plotInfo_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entropy version of the missing information: for a single
individual at a single genomic position, we measure the missing
information as <code class="reqn">H = \sum_g p_g \log p_g / \log n</code>, where <code class="reqn">p_g</code> is the probability of the
genotype <code class="reqn">g</code>, and <code class="reqn">n</code> is the number of possible genotypes,
defining <code class="reqn">0 \log 0 = 0</code>.  This takes values between 0
and 1, assuming the value 1 when the genotypes (given the marker data)
are equally likely and 0 when the genotypes are completely determined.
We calculate the missing information at a particular position as the
average of <code class="reqn">H</code> across individuals.  For an intercross, we don't
scale by <code class="reqn">\log n</code> but by the entropy in the case of genotype
probabilities (1/4, 1/2, 1/4).
</p>
<p>The variance version of the missing information: we calculate the
average, across individuals, of the variance of the genotype
distribution (conditional on the observed marker data) at a particular
locus, and scale by the maximum such variance.
</p>
<p>Calculations are done in C (for the sake of speed in the presence of
little thought about programming efficiency) and the plot is created
by a call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.
</p>
<p>Note that <code><a href="#topic+summary.scanone">summary.scanone</a></code> may be used to display
the maximum missing information on each chromosome.
</p>


<h3>Value</h3>

<p>An object with class <code>scanone</code>: a data.frame with columns the
chromosome IDs and cM positions followed by the entropy and/or
variance version of the missing information.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+plotMissing">plotMissing</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+geno.table">geno.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

plotInfo(hyper,chr=c(1,4))

# save the results and view maximum missing info on each chr
info &lt;- plotInfo(hyper)
summary(info)

plotInfo(hyper, bandcol="gray70")
</code></pre>

<hr>
<h2 id='plotLodProfile'>Plot 1-d LOD profiles for a multiple QTL model</h2><span id='topic+plotLodProfile'></span>

<h3>Description</h3>

<p>Use the results of <code><a href="#topic+refineqtl">refineqtl</a></code> to plot
one-dimensional LOD profiles for each QTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLodProfile(qtl, chr, incl.markers=TRUE, gap=25, lwd=2, lty=1, col="black",
               qtl.labels=TRUE, mtick=c("line", "triangle"),
               show.marker.names=FALSE, alternate.chrid=FALSE,
               add=FALSE, showallchr=FALSE, labelsep=5, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLodProfile_+3A_qtl">qtl</code></td>
<td>
<p>An object of class <code>"qtl"</code>; must have been produced by
<code><a href="#topic+refineqtl">refineqtl</a></code> using <code>keeplodprofiles=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_incl.markers">incl.markers</code></td>
<td>
<p>Indicate whether to plot line segments at the
marker locations.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_lwd">lwd</code></td>
<td>
<p>Line widths for each QTL trace (length 1 or the number of QTL).</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_lty">lty</code></td>
<td>
<p>Line types for each QTL trace (length 1 or the number of QTL).</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_col">col</code></td>
<td>
<p>Line col for each QTL trace (length 1 or the number of QTL).</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_qtl.labels">qtl.labels</code></td>
<td>
<p>If TRUE, place a label on each QTL trace.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_mtick">mtick</code></td>
<td>
<p>Tick mark type for markers (line segments or
upward-pointing triangels).</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_show.marker.names">show.marker.names</code></td>
<td>
<p>If TRUE, show the marker names along the x axis.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_add">add</code></td>
<td>
<p>If TRUE, add curves to a current plot.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_showallchr">showallchr</code></td>
<td>
<p>If FALSE (the default), only show the chr with a QTL</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_labelsep">labelsep</code></td>
<td>
<p>If <code>qtl.labels=TRUE</code>, separation between peak LOD
and QTL label, as percent of the height of the plot.</p>
</td></tr>
<tr><td><code id="plotLodProfile_+3A_...">...</code></td>
<td>
<p>Passed to the function <code>plot</code> when it
is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots LOD profiles in the context of a multiple QTL
model, using a scheme best described in Zeng et al. (2000).  The
position of each QTL is varied, keeping all other loci fixed.  If a
QTL is isolated on a chromosome, the entire chromosome is scanned; if
there are additional linked QTL, the position of a QTL is scanned over
the largest interval possible without allowing the order of QTLs along
a chromosome to change.  At each position for the QTL being scanned,
we calculate a LOD score comparing the full model, with the QTL of
interest at that particular position (and all others at their fixed
positions) to the model with the QTL of interest (and any
interactions that include that QTL) omitted.
</p>
<p>Care should be take regarding the arguments <code>lwd</code>, <code>lty</code>,
and <code>col</code>; if vectors are given, they should be in the order of
the QTL within the object, which may be different than the order in
which they are plotted.  (The LOD profiles are sorted by chromosome
and position.)
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Zeng  Z.-B., Liu, J., Stam, L. F., Kao, C.-H., Mercer, J. M. and
Laurie, C. C. (2000) Genetic architecture of a morphological shape
difference between two Drosophila species. <em>Genetics</em> <b>154</b>,
299&ndash;310.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+scanqtl">scanqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2)
qtl &lt;- makeqtl(fake.bc, chr=c(2,5), pos=c(32.5, 17.5), what="prob")

out &lt;- scanone(fake.bc, method="hk")

# refine QTL positions and keep LOD profiles
rqtl &lt;- refineqtl(fake.bc, qtl=qtl, method="hk", keeplodprofile=TRUE)

# plot the LOD profiles
plotLodProfile(rqtl)

# add the initial scan results, for comparison
plot(out, add=TRUE, chr=c(2,5), col="red")
</code></pre>

<hr>
<h2 id='plotMap'>Plot genetic map</h2><span id='topic+plotMap'></span><span id='topic+plot.map'></span>

<h3>Description</h3>

<p>Plot genetic map of marker locations for all chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
plot(x, map2, chr, horizontal=FALSE, shift=TRUE,
     show.marker.names=FALSE, alternate.chrid=FALSE, ...)
plotMap(x, map2, chr, horizontal=FALSE, shift=TRUE,
     show.marker.names=FALSE, alternate.chrid=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMap_+3A_x">x</code></td>
<td>
<p>A list whose components are vectors of marker locations.  A
<code>cross</code> object may be given instead, in which case the genetic
map it contains is used.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_map2">map2</code></td>
<td>
<p>An optional second genetic map with the same number (and
names) of chromosomes.  As with the first argument, a
<code>cross</code> object may be given instead.  If this argument is
given, a comparison of the two genetic maps is plotted.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_horizontal">horizontal</code></td>
<td>
<p>Specifies whether the chromosomes should be
plotted horizontally.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_shift">shift</code></td>
<td>
<p>If TRUE, shift the first marker on each chromosome to be
at 0 cM.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_show.marker.names">show.marker.names</code></td>
<td>
<p>If TRUE, marker names are included.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotMap_+3A_...">...</code></td>
<td>
<p>Passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the genetic map for each chromosome, or a comparison of the
genetic maps if two maps are given.
</p>
<p>For a comparison of two maps, the first
map is on the left (or, if <code>horizontal=TRUE</code>, on the top).  Lines
are drawn to connect markers.  Markers that exist in just one map and
not the other are indicated by short line segments, on one side or the
other, that are not connected across.
</p>
<p>For a sex-specific map, female and male maps are plotted against one
another.  For two sex-specific maps, the two female maps are plotted
against one another and the two male maps are plotted against one
another.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

plotMap(fake.bc)
plotMap(fake.bc,horizontal=TRUE)

newmap &lt;- est.map(fake.bc)
plot(newmap)
plotMap(fake.bc, newmap)

plotMap(fake.bc, show.marker.names=TRUE)

</code></pre>

<hr>
<h2 id='plotMissing'>Plot grid of missing genotypes</h2><span id='topic+plotMissing'></span>

<h3>Description</h3>

<p>Plot a grid showing which genotypes are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMissing(x, chr, reorder=FALSE, main="Missing genotypes",
             alternate.chrid=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMissing_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details. </p>
</td></tr>
<tr><td><code id="plotMissing_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotMissing_+3A_reorder">reorder</code></td>
<td>
<p>Specify whether to reorder individuals according to
their phenotypes.
</p>

<table>
<tr>
 <td style="text-align: left;">
    FALSE </td><td style="text-align: left;"> Don't reorder </td>
</tr>
<tr>
 <td style="text-align: left;">
    TRUE  </td><td style="text-align: left;"> Reorder according to the sum of the phenotypes </td>
</tr>
<tr>
 <td style="text-align: left;">
    n </td><td style="text-align: left;"> Reorder according to phenotype n</td>
</tr>

</table>
</td></tr>
<tr><td><code id="plotMissing_+3A_main">main</code></td>
<td>
<p>Title to place on plot.</p>
</td></tr>
<tr><td><code id="plotMissing_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotMissing_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+image">image</a></code> to plot a grid with black pixels where the
genotypes are missing.  For intercross and 4-way cross data, gray
pixels are plotted for the partially missing genotypes (for example,
&quot;not AA&quot;).
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cross">plot.cross</a></code>,  <code><a href="#topic+geno.image">geno.image</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
plotMissing(fake.f2)
</code></pre>

<hr>
<h2 id='plotModel'>Plot a QTL model</h2><span id='topic+plotModel'></span>

<h3>Description</h3>

<p>Plot a graphical representation of a QTL model, with nodes
representing QTL and line segments representing pairwise
interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModel(qtl, formula, circrad.rel=0.25, circrad.abs,
         cex.name=1, chronly=FALSE, order, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotModel_+3A_qtl">qtl</code></td>
<td>
<p>A QTL object (as created by <code><a href="#topic+makeqtl">makeqtl</a></code>) or
vector of character strings indicating the names for the QTL.  This
is also allowed to be a list that contains a component named
<code>"chr"</code> (and, optionally, components names <code>"pos"</code> and
<code>"formula"</code>).</p>
</td></tr>
<tr><td><code id="plotModel_+3A_formula">formula</code></td>
<td>
<p>Optional formula defining the QTL model.  If missing,
we look for an attribute <code>"formula"</code> to the input QTL object or a
item named <code>"formula"</code> within the QTL object.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_circrad.rel">circrad.rel</code></td>
<td>
<p>Radius of the circles that
indicate the QTL, relative to the distance between the circles.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_circrad.abs">circrad.abs</code></td>
<td>
<p>Optional radius of the circles that
indicate the QTL; note that the plotting region will have x- and
y-axis limits spanning 3 units.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_cex.name">cex.name</code></td>
<td>
<p>Character expansion for the QTL names.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_chronly">chronly</code></td>
<td>
<p>If TRUE and a formal QTL object is given, only the
chromosome IDs are used to identify the QTL.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_order">order</code></td>
<td>
<p>Optional vector indicating a permutation of the QTL to
define where they are to appear in the plot.  QTL are placed around a
circle, starting at the top and going clockwise.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_...">...</code></td>
<td>
<p>Passed to the function <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+stepwiseqtl">stepwiseqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># plot a QTL model, using a vector of character strings to define the QTL
plotModel(c("1","4","6","15"), formula=y~Q1+Q2+Q3*Q4)

# plot an additive QTL model
data(hyper)
hyper &lt;- calc.genoprob(hyper)
qtl &lt;- makeqtl(hyper, chr=c(1,4,6,15), pos=c(68.3,30,60,18), what="prob")
plotModel(qtl)

# include an interaction
plotModel(qtl, formula=y~Q1+Q2+Q3*Q4)

# alternatively, include the formula as an attribute to the QTL object
attr(qtl, "formula") &lt;- y~Q1+Q2+Q3*Q4
plotModel(qtl)

# if formula given, the attribute within the object is ignored
plotModel(qtl, y~Q1+Q2+Q3+Q4)

# NULL formula indicates additive QTL model
plotModel(qtl, NULL)

# reorder the QTL in the figure
plotModel(qtl, order=c(1,3,4,2))

# show just the chromosome numbers
plotModel(qtl, chronly=TRUE)
</code></pre>

<hr>
<h2 id='plotPheno'>Plot a phenotype distribution</h2><span id='topic+plotPheno'></span>

<h3>Description</h3>

<p>Plots a histogram or barplot of the data for a phenotype from an
experimental cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPheno(x, pheno.col=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPheno_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotPheno_+3A_pheno.col">pheno.col</code></td>
<td>
<p>The phenotype column to plot: a numeric index, or the
phenotype name as a character string. Alternatively, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="plotPheno_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code> or
<code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric phenotypes are displayed as histograms with approximately
<code class="reqn">2\sqrt{n}</code> bins.  Phenotypes that are factors or that
have very few unique values are displayed as barplots.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cross">plot.cross</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+plotMissing">plotMissing</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
plotPheno(fake.bc, pheno.col=1)
plotPheno(fake.bc, pheno.col=3)
plotPheno(fake.bc, pheno.col="age")
</code></pre>

<hr>
<h2 id='plotPXG'>Plot phenotypes versus marker genotypes</h2><span id='topic+plotPXG'></span>

<h3>Description</h3>

<p>Plot the phenotype values versus the genotypes at a marker or markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPXG(x, marker, pheno.col=1, jitter=1, infer=TRUE,
         pch, ylab, main, col, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPXG_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details. </p>
</td></tr>
<tr><td><code id="plotPXG_+3A_marker">marker</code></td>
<td>
<p>Marker name (a character string; can be a vector).</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give a character string matching
a phenotype name. Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_jitter">jitter</code></td>
<td>
<p>A positive number indicating how much to spread out the
points horizontally.  (Larger numbers correspond to greater spread.)</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_infer">infer</code></td>
<td>
<p>If TRUE, missing genotypes are filled in with a single
random imputation and plotted in red; if FALSE, only individuals
typed at the specified marker are plotted.</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_pch">pch</code></td>
<td>
<p>Plot symbol.</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_main">main</code></td>
<td>
<p>Main title for the plot.  If missing, the names of the
markers are used.</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_col">col</code></td>
<td>
<p>A vector of colors to use for the confidence intervals
(optional).</p>
</td></tr>
<tr><td><code id="plotPXG_+3A_...">...</code></td>
<td>
<p>Passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the phenotype data against the genotypes at the specified
marker.  If infer=TRUE, the genotypes of individuals that were not
typed is inferred based the genotypes at linked markers via a single
imputation from <code><a href="#topic+sim.geno">sim.geno</a></code>; these points are plotted
in red.  For each genotype, the phenotypic mean is plotted, with error
bars at <code class="reqn">\pm</code> 1 SE.
</p>


<h3>Value</h3>

<p>A data.frame with initial columns the marker genotypes, then the
phenotype data, then a column indicating whether any of the marker
genotypes were inferred (1=at least one genotype inferred, 0=none were
inferred).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Brian Yandell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+find.marker">find.marker</a></code>, <code><a href="#topic+effectplot">effectplot</a></code>,
<code><a href="#topic+find.flanking">find.flanking</a></code>, <code><a href="#topic+effectscan">effectscan</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
mname &lt;- find.marker(listeria, 5, 28) # marker D5M357
plotPXG(listeria, mname)

mname2 &lt;- find.marker(listeria, 13, 26) # marker D13Mit147
plotPXG(listeria, c(mname, mname2))
plotPXG(listeria, c(mname2, mname))

# output of the function contains the raw data
output &lt;- plotPXG(listeria, mname)
head(output)

# another example
data(fake.f2)
mname &lt;- find.marker(fake.f2, 1, 37) # marker D1M437
plotPXG(fake.f2, mname)

mname2 &lt;- find.marker(fake.f2, "X", 14) # marker DXM66
plotPXG(fake.f2, mname2)

plotPXG(fake.f2, c(mname,mname2))
plotPXG(fake.f2, c(mname2,mname))

</code></pre>

<hr>
<h2 id='plotRF'>Plot recombination fractions</h2><span id='topic+plotRF'></span>

<h3>Description</h3>

<p>Plot a grid showing the recombination fractions for all pairs of
markers, and/or the LOD scores for tests of linkage between pairs of
markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRF(x, chr, what=c("both","lod","rf"), alternate.chrid=FALSE,
        zmax=12, mark.diagonal=FALSE,
        col.scheme=c("viridis", "redblue"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRF_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to plot.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_what">what</code></td>
<td>
<p>Indicate whether to plot LOD scores, recombination
fractions or both.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_alternate.chrid">alternate.chrid</code></td>
<td>
<p>If TRUE and more than one chromosome is
plotted, alternate the placement of chromosome
axis labels, so that they may be more easily distinguished.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_zmax">zmax</code></td>
<td>
<p>Maximum LOD score plotted; values above this are all
thresholded at this value.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_mark.diagonal">mark.diagonal</code></td>
<td>
<p>If TRUE, include black line segments around the
pixels along the diagonal, to better separate the upper left triangle
from the lower right triangle.</p>
</td></tr>
<tr><td><code id="plotRF_+3A_col.scheme">col.scheme</code></td>
<td>
<p>The color palette. The default is &quot;viridis&quot;; see
Option D at <a href="https://bids.github.io/colormap/">https://bids.github.io/colormap/</a></p>
</td></tr>
<tr><td><code id="plotRF_+3A_...">...</code></td>
<td>
<p>Generally ignored, but you can include <code>main</code> to
change or omit the title of the figure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+image">image</a></code> to plot a grid showing the
recombination fractions and/or LOD scores for all pairs of markers.
(The LOD scores are for a test of <code class="reqn">r = 1/2</code>.)
If both are plotted, the recombination fractions are in the upper left
triangle while the LOD scores are in the lower right triangle.
</p>
<p>With <code>col.scheme="viridis"</code> (the default), purple corresponds to
a large LOD score or a small recombination fraction, while yellow is
the reverse. With <code>col.scheme="redblue"</code>, red corresponds to a
large LOD or a small recombination fraction, while blue is the
reverse.  Note that missing values appear in light gray.
</p>
<p>Recombination fractions are transformed by <code class="reqn">-4(\log_2{r}+1)</code> to make them on the same sort of scale as LOD
scores.  Values of LOD or the transformed recombination fraction that
are above 12 are set to 12.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+pull.rf">pull.rf</a></code>, <code><a href="#topic+plot.rfmatrix">plot.rfmatrix</a></code>,
<code><a href="graphics.html#topic+image">image</a></code>,
<code><a href="#topic+badorder">badorder</a></code>, <code><a href="#topic+ripple">ripple</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
badorder &lt;- est.rf(badorder)
plotRF(badorder)

# plot just chr 1
plotRF(badorder, chr=1)

# plot just the recombination fractions
plotRF(badorder, what="rf")

# plot just the LOD scores, and just for chr 2 and 3
plotRF(badorder, chr=2:3, what="lod")
</code></pre>

<hr>
<h2 id='pull.argmaxgeno'>Pull out the results of the Viterbi algorithm from a cross</h2><span id='topic+pull.argmaxgeno'></span>

<h3>Description</h3>

<p>Pull out the results of <code><a href="#topic+argmax.geno">argmax.geno</a></code> from a cross as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.argmaxgeno(cross, chr, include.pos.info=FALSE, rotate=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.argmaxgeno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.argmaxgeno_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="pull.argmaxgeno_+3A_include.pos.info">include.pos.info</code></td>
<td>
<p>If TRUE, include columns with marker name,
chromosmoe ID, and cM position.  (If <code>include.pos.info=TRUE</code>, we
take <code>rotate=TRUE</code>.)</p>
</td></tr>
<tr><td><code id="pull.argmaxgeno_+3A_rotate">rotate</code></td>
<td>
<p>If TRUE, return matrix with individuals as columns and
positions as rows.  If FALSE, rows correspond to individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing numeric indicators of the inferred genotypes.
Multiple chromosomes are pasted together.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.geno">pull.geno</a></code>, <code><a href="#topic+pull.genoprob">pull.genoprob</a></code>,
<code><a href="#topic+pull.draws">pull.draws</a></code>, <code><a href="#topic+argmax.geno">argmax.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria &lt;- argmax.geno(listeria, step=1, stepwidth="max")
amg &lt;- pull.argmaxgeno(listeria, chr=c(5,13), include.pos.info=TRUE, rotate=TRUE)
amg[1:5,1:10]
</code></pre>

<hr>
<h2 id='pull.draws'>Pull out the genotype imputations from a cross</h2><span id='topic+pull.draws'></span>

<h3>Description</h3>

<p>Pull out the results of <code><a href="#topic+sim.geno">sim.geno</a></code> from a cross as an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.draws(cross, chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.draws_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.draws_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing numeric indicators of the imputed genotypes.
Multiple chromosomes are pasted together.  The dimensions are
individuals by positions by imputations
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.geno">pull.geno</a></code>, <code><a href="#topic+pull.genoprob">pull.genoprob</a></code>,
<code><a href="#topic+pull.argmaxgeno">pull.argmaxgeno</a></code>, <code><a href="#topic+sim.geno">sim.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria &lt;- sim.geno(listeria, step=5, stepwidth="max", n.draws=8)
dr &lt;- pull.draws(listeria, chr=c(5,13))
dr[1:20,1:10,1]
</code></pre>

<hr>
<h2 id='pull.geno'>Pull out the genotype data from a cross</h2><span id='topic+pull.geno'></span>

<h3>Description</h3>

<p>Pull out the genotype data from a cross object, as a single big matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.geno(cross, chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.geno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.geno_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size n.ind x tot.mar.  The raw genotype data in the input
cross object, with the chromosomes pasted together.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.pheno">pull.pheno</a></code>, <code><a href="#topic+pull.map">pull.map</a></code>
<code><a href="#topic+pull.draws">pull.draws</a></code>, <code><a href="#topic+pull.genoprob">pull.genoprob</a></code>,
<code><a href="#topic+pull.argmaxgeno">pull.argmaxgeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
dat &lt;- pull.geno(listeria)

# image of the genotype data
image(1:ncol(dat),1:nrow(dat),t(dat),ylab="Individuals",xlab="Markers",
      col=c("red","yellow","blue","green","violet"))
abline(v=cumsum(c(0,nmar(listeria)))+0.5)
abline(h=nrow(dat)+0.5)
</code></pre>

<hr>
<h2 id='pull.genoprob'>Pull out the genotype probabilities from a cross</h2><span id='topic+pull.genoprob'></span>

<h3>Description</h3>

<p>Pull out the results of <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> from a cross as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.genoprob(cross, chr, omit.first.prob=FALSE,
              include.pos.info=FALSE, rotate=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.genoprob_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.genoprob_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="pull.genoprob_+3A_omit.first.prob">omit.first.prob</code></td>
<td>
<p>If TRUE, omit the probabilities for the first
genotype at each position (since they sum to 1).</p>
</td></tr>
<tr><td><code id="pull.genoprob_+3A_include.pos.info">include.pos.info</code></td>
<td>
<p>If TRUE, include columns with marker name,
genotype, chromosome ID, and cM position.  (If
<code>include.pos.info=TRUE</code>, we take <code>rotate=TRUE</code>.)</p>
</td></tr>
<tr><td><code id="pull.genoprob_+3A_rotate">rotate</code></td>
<td>
<p>If TRUE, return matrix with individuals as columns and
positions/genotypes as rows.  If FALSE, rows correspond to individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing genotype probabilities.
Multiple chromosomes and the multiple genotypes at each position are
pasted together.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.geno">pull.geno</a></code>, <code><a href="#topic+pull.argmaxgeno">pull.argmaxgeno</a></code>,
<code><a href="#topic+pull.draws">pull.draws</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria &lt;- calc.genoprob(listeria, step=1, stepwidth="max")
pr &lt;- pull.genoprob(listeria, chr=c(5,13), omit.first.prob=TRUE, include.pos.info=TRUE, rotate=TRUE)
pr[1:5,1:10]
</code></pre>

<hr>
<h2 id='pull.map'>Pull out the genetic map from a cross</h2><span id='topic+pull.map'></span>

<h3>Description</h3>

<p>Pull out the map portion of a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.map(cross, chr, as.table=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.map_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.map_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="pull.map_+3A_as.table">as.table</code></td>
<td>
<p>If TRUE, return the genetic map as a table with
chromosome assignments and marker names.  If FALSE, return the map as a
<code>"map"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genetic map: a list with each component containing the marker
positions (in cM) for a chromosome.  Each component has class
<code>A</code> or <code>X</code> according to whether it is an autosome or the X
chromosome.  The components are either vectors of marker positions or,
for a sex-specific map, 2-row matrices containing the female and male
marker locations.  The map itself is given class <code>map</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+replace.map">replace.map</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>, <code><a href="#topic+map2table">map2table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
map &lt;- pull.map(fake.f2)
plot(map)
</code></pre>

<hr>
<h2 id='pull.markers'>Drop all but a selected set of markers</h2><span id='topic+pull.markers'></span>

<h3>Description</h3>

<p>Drop all but a selected set of markers from the data matrices and genetic maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.markers(cross, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.markers_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.markers_+3A_markers">markers</code></td>
<td>
<p>A character vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, with any markers not specified in the vector <code>markers</code> removed
from the genotype data matrices, genetic maps, and, if applicable, any
derived data (such as produced by <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>).
(It might be a good idea to re-derive such things after using this
function.)
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+drop.nullmarkers">drop.nullmarkers</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code>,
<code><a href="#topic+geno.table">geno.table</a></code>,
<code><a href="#topic+clean.cross">clean.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
listeria2 &lt;- pull.markers(listeria, c("D10M44","D1M3","D1M75"))
</code></pre>

<hr>
<h2 id='pull.pheno'>Pull out phenotype data from a cross</h2><span id='topic+pull.pheno'></span>

<h3>Description</h3>

<p>Pull out selected phenotype data from a cross object, as a data frame
or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.pheno(cross, pheno.col)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.pheno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.pheno_+3A_pheno.col">pheno.col</code></td>
<td>
<p>A vector specifying which phenotypes to keep or discard.
This may be a logical vector, a numeric vector, or a vector
of character strings (for the phenotype names). If missing, the
entire set of phenotypes is output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns specifying phenotypes and rows specifying individuals.
If there is just one phenotype, a vector (rather than a data.frame) is returned.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.geno">pull.geno</a></code>, <code><a href="#topic+pull.map">pull.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
pull.pheno(listeria, "sex")
</code></pre>

<hr>
<h2 id='pull.rf'>Pull out recombination fractions or LOD scores from a cross object</h2><span id='topic+pull.rf'></span>

<h3>Description</h3>

<p>Pull out either the pairwise recombination fractions or the LOD
scores, as calculated by <code><a href="#topic+est.rf">est.rf</a></code>, from a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull.rf(cross, what=c("rf", "lod"), chr)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.rf_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="pull.rf_+3A_what">what</code></td>
<td>
<p>Indicates whether to pull out a matrix of estimated
recombination fractions or a matrix of LOD scores.</p>
</td></tr>
<tr><td><code id="pull.rf_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"rfmatrix"</code>, which is a matrix of either
estimated recombination fractions between all marker pairs or of LOD
scores (for the test of rf=1/2) for all marker pairs.
</p>
<p>The genetic map is included as an attribute.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+plot.rfmatrix">plot.rfmatrix</a></code>, <code><a href="#topic+plotRF">plotRF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- est.rf(fake.f2)
rf &lt;- pull.rf(fake.f2)
lod &lt;- pull.rf(fake.f2, "lod")
plot(rf[1,], lod[1,], xlab="rec frac", ylab="LOD score")
marker &lt;- markernames(fake.f2, chr=5)[6]
par(mfrow=c(2,1))
plot(rf, marker, bandcol="gray70")
plot(lod, marker, bandcol="gray70")
</code></pre>

<hr>
<h2 id='qtl-internal'>Internal qtl functions</h2><span id='topic+reviseXdata'></span><span id='topic+calc.plod'></span><span id='topic+checkcovar'></span><span id='topic+clean'></span><span id='topic+condense'></span><span id='topic+convert'></span><span id='topic+convert2bcsft'></span><span id='topic+create.map'></span><span id='topic+find.pseudomarkerpos'></span><span id='topic+flipcross'></span><span id='topic+genAllPartitions'></span><span id='topic+getsex'></span><span id='topic+addmarkerstointervalmap'></span><span id='topic+mqm_version'></span><span id='topic+scanall'></span><span id='topic+getgenonames'></span><span id='topic+imf.cf'></span><span id='topic+imf.h'></span><span id='topic+imf.k'></span><span id='topic+imf.m'></span><span id='topic+imf.stahl'></span><span id='topic+locatemarker'></span><span id='topic+max.scantwocondensed'></span><span id='topic+mf.cf'></span><span id='topic+mf.h'></span><span id='topic+mf.k'></span><span id='topic+mf.m'></span><span id='topic+mf.stahl'></span><span id='topic+polyplot'></span><span id='topic+print.addcovarint'></span><span id='topic+print.addint'></span><span id='topic+print.compactqtl'></span><span id='topic+print.cross'></span><span id='topic+print.map'></span><span id='topic+print.qtl'></span><span id='topic+print.scanoneboot'></span><span id='topic+print.scantwo'></span><span id='topic+print.summary.addpair'></span><span id='topic+print.summary.compactqtl'></span><span id='topic+print.summary.comparegeno'></span><span id='topic+print.summary.cross'></span><span id='topic+print.summary.fitqtl'></span><span id='topic+print.summary.map'></span><span id='topic+print.summary.qtl'></span><span id='topic+print.summary.ripple'></span><span id='topic+print.summary.scanone'></span><span id='topic+print.summary.scanoneperm'></span><span id='topic+print.summary.scantwo'></span><span id='topic+print.summary.scantwo.old'></span><span id='topic+print.summary.scantwoperm'></span><span id='topic+replacemap'></span><span id='topic+subrousummaryscantwo'></span><span id='topic+summary.scantwocondensed'></span><span id='topic+summary.addcovarint'></span><span id='topic+summary.addint'></span><span id='topic+summary.compactqtl'></span><span id='topic+checkStepwiseqtlStart'></span><span id='topic+checkformula'></span><span id='topic+countqtlterms'></span><span id='topic+deparseQTLformula'></span><span id='topic+fitqtlengine'></span><span id='topic+matchchr'></span><span id='topic+parseformula'></span><span id='topic+reviseqtlnuminformula'></span>

<h3>Description</h3>

<p>Internal qtl functions. These are generally not to be called by the
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reviseXdata(type=c("f2","bc","bcsft"), expandX=c("simple","standard","full"),
            sexpgm, geno, prob, draws, pairprob, cross.attr, force=FALSE)
calc.plod(lod, nterms, type=c("f2","bc"), penalties)
checkcovar(cross, pheno.col, addcovar, intcovar, perm.strata,
           ind.noqtl=NULL, weights=NULL, verbose=TRUE)
clean(object, ...)
condense(object)
convert(object, ...)
convert2bcsft(cross, BC.gen = 0, F.gen = 0, estimate.map = TRUE,
              error.prob=0.0001, map.function=c("haldane","kosambi","c-f","morgan"),
              verbose=FALSE)
create.map(map, step, off.end, stepwidth=c("fixed", "variable", "max"))
find.pseudomarkerpos(cross, marker, where=c("draws", "prob"))
flipcross(cross)
genAllPartitions(n.taxa, taxa)
getsex(cross)
addmarkerstointervalmap(cross,intervalresult,verbose=FALSE)
mqm_version()
scanall(cross, scanfunction=scanone, multicore=TRUE, n.clusters=1,
        batchsize=10, FF=0,cofactors=NULL, ..., plot=FALSE, verbose=FALSE)
getgenonames(type=c("f2","bc","riself","risib","4way","dh","haploid","special","bcsft"),
             chrtype=c("A","X"), expandX=c("simple","standard","full"),
             sexpgm, cross.attr)
imf.cf(r)
imf.h(r)
imf.k(r)
imf.m(r)
imf.stahl(r, m=0, p=0, tol=1e-12, maxit=1000)
locatemarker(map, pos, chr, flag)
## S3 method for class 'scantwocondensed'
max(object, lodcolumn=1,
    what=c("best", "full", "add", "int"),
    na.rm=TRUE, ...)
mf.cf(d)
mf.h(d)
mf.k(d)
mf.m(d)
mf.stahl(d, m=0, p=0)
polyplot(x, type='b', legend=TRUE,legendloc=0, labels=NULL, cex =
         par("cex"), pch = 19, gpch = 21, bg = par("bg"), color = par("fg"),
         col=NULL, ylim=range(x[is.finite(x)]), xlim = NULL, main = NULL, xlab =
         NULL, ylab = NULL, add=FALSE, ...)
## S3 method for class 'addcovarint'
print(x, ...)
## S3 method for class 'addint'
print(x, ...)
## S3 method for class 'compactqtl'
print(x, ...)
## S3 method for class 'summary.comparegeno'
print(x, ...)
## S3 method for class 'cross'
print(x, ...)
## S3 method for class 'map'
print(x, ...)
## S3 method for class 'qtl'
print(x, ...)
## S3 method for class 'scanoneboot'
print(x, ...)
## S3 method for class 'scantwo'
print(x, ...)
## S3 method for class 'summary.addpair'
print(x, ...)
## S3 method for class 'summary.compactqtl'
print(x, ...)
## S3 method for class 'summary.cross'
print(x, ...)
## S3 method for class 'summary.fitqtl'
print(x, ...)
## S3 method for class 'summary.map'
print(x, ...)
## S3 method for class 'summary.qtl'
print(x, ...)
## S3 method for class 'summary.ripple'
print(x, ...)
## S3 method for class 'summary.scanone'
print(x, ...)
## S3 method for class 'summary.scanoneperm'
print(x, ...)
## S3 method for class 'summary.scantwo'
print(x, ...)
## S3 method for class 'summary.scantwo.old'
print(x, ...)
## S3 method for class 'summary.scantwoperm'
print(x, ...)
replacemap(object, map)
subrousummaryscantwo(object, for.perm=FALSE)
## S3 method for class 'scantwocondensed'
summary(object, thresholds,
         what=c("best", "full", "add", "int"),
         perms, alphas, lodcolumn=1, pvalues=FALSE,
         allpairs=TRUE, ...)
## S3 method for class 'addcovarint'
summary(object, ...)
## S3 method for class 'addint'
summary(object, ...)
## S3 method for class 'compactqtl'
summary(object, ...)
checkStepwiseqtlStart(qtl, formula, covar=NULL)
checkformula(formula, qtl.name, covar.name)
countqtlterms(formula, ignore.covar=TRUE)
deparseQTLformula(formula, reorderterms=FALSE)
fitqtlengine(pheno, qtl, covar=NULL, formula, method=c("imp", "hk"),
         model=c("normal", "binary"),
         dropone=TRUE, get.ests=FALSE, run.checks=TRUE, cross.attr,
         crosstype, sexpgm, tol, maxit, forceXcovar=FALSE)
matchchr(selection, thechr)
parseformula(formula, qtl.dimname, covar.dimname)
reviseqtlnuminformula(formula, oldnum, newnum)
</code></pre>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>

<hr>
<h2 id='qtlversion'>Installed version of R/qtl</h2><span id='topic+qtlversion'></span>

<h3>Description</h3>

<p>Print the version number of the currently installed version of R/qtl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtlversion()</code></pre>


<h3>Value</h3>

<p>A character string with the version number of the currently installed
version of R/qtl.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  qtlversion()
</code></pre>

<hr>
<h2 id='read.cross'>Read data for a QTL experiment</h2><span id='topic+read.cross'></span>

<h3>Description</h3>

<p>Data for a QTL experiment is read from a set of files and converted
into an object of class <code>cross</code>.  The comma-delimited format
(<code>csv</code>) is recommended.  All formats require chromosome
assignments for the genetic markers, and assume that markers are in
their correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cross(format=c("csv", "csvr", "csvs", "csvsr", "mm", "qtx",
                    "qtlcart", "gary", "karl", "mapqtl", "tidy"),
           dir="", file, genfile, mapfile, phefile, chridfile,
           mnamesfile, pnamesfile, na.strings=c("-","NA"),
           genotypes=c("A","H","B","D","C"), alleles=c("A","B"),
           estimate.map=FALSE, convertXdata=TRUE, error.prob=0.0001,
           map.function=c("haldane", "kosambi", "c-f", "morgan"),
           BC.gen=0, F.gen=0, crosstype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.cross_+3A_format">format</code></td>
<td>
<p>Specifies the format of the data file or files. Details
on the various file formats are provided below.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_dir">dir</code></td>
<td>
<p>Directory in which the data files will be found.  In
Windows, use forward slashes (<code>"/"</code>) or double backslashes
(<code>"\\"</code>) to specify directory trees.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_file">file</code></td>
<td>
<p>The main input file for formats <code>csv</code>, <code>csvr</code>
and <code>mm</code>.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_genfile">genfile</code></td>
<td>
<p>File with genotype data (formats <code>csvs</code>,
<code>csvsr</code>, <code>karl</code>, <code>gary</code> and <code>mapqtl</code> only).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_mapfile">mapfile</code></td>
<td>
<p>File with marker position information (all
except the <code>csv</code> formats).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_phefile">phefile</code></td>
<td>
<p>File with phenotype data (formats <code>csvs</code>,
<code>csvsr</code>, <code>karl</code>, <code>gary</code> and <code>mapqtl</code> only).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_chridfile">chridfile</code></td>
<td>
<p>File with chromosome ID for each marker (<code>gary</code>
format only).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_mnamesfile">mnamesfile</code></td>
<td>
<p>File with marker names (<code>gary</code> format only).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_pnamesfile">pnamesfile</code></td>
<td>
<p>File with phenotype names (<code>gary</code> format
only).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_na.strings">na.strings</code></td>
<td>
<p>A vector of strings which are to be interpreted as
missing values (<code>csv</code> and <code>gary</code> formats only).  For the
<code>csv</code> formats, these are interpreted globally
for the entire
file, so missing value codes in phenotypes must not be valid
genotypes, and vice versa. For the <code>gary</code> format, these are
used only for the phenotype data.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_genotypes">genotypes</code></td>
<td>
<p>A vector of character strings specifying the genotype
codes (<code>csv</code> formats only).  Generally this is a vector of
length 5, with the elements corresponding to AA, AB, BB, not BB
(i.e., AA or AB), and not AA (i.e., AB or BB).  <b>Note</b>: Pay
careful attention to the third and fourth of these; the order of
these can be confusing.
</p>
<p>If you are trying to read 4-way cross data, your file must have
genotypes coded as described below, and you need to set
<code>genotypes=NULL</code> so that no re-coding gets done.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_alleles">alleles</code></td>
<td>
<p>A vector of two one-letter character strings (or four,
for the four-way cross), to be used as labels for the two alleles.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_estimate.map">estimate.map</code></td>
<td>
<p>For all formats but <code>qtlcart</code>, <code>mapqtl</code>,
and <code>karl</code>: if TRUE and marker positions are not included in
the input files, the genetic map is estimated using the function
<code><a href="#topic+est.map">est.map</a></code>.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_convertxdata">convertXdata</code></td>
<td>
<p>If TRUE, any X chromosome genotype data is
converted to the internal standard, using columns <code>sex</code> and
<code>pgm</code> in the phenotype data if they available or by inference
if they are not.  If FALSE, the X chromsome data is read as is.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_error.prob">error.prob</code></td>
<td>
<p>In the case that the marker map must be estimated:
Assumed genotyping error rate used in the calculation of the
penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="read.cross_+3A_map.function">map.function</code></td>
<td>
<p>In the case that the marker map must be estimated:
Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions. (Ignored if m &gt; 0.)</p>
</td></tr>
<tr><td><code id="read.cross_+3A_bc.gen">BC.gen</code></td>
<td>
<p>Used only for cross type <code>"bcsft"</code>.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_f.gen">F.gen</code></td>
<td>
<p>Used only for cross type <code>"bcsft"</code>.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_crosstype">crosstype</code></td>
<td>
<p>Optional character string to force a particular cross type.</p>
</td></tr>
<tr><td><code id="read.cross_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the function
<code><a href="utils.html#topic+read.table">read.table</a></code> in the case of
<code>csv</code> and <code>csvr</code> formats.  In particular, one may use the
argument
<code>sep</code> to specify the field separator (the default is a comma),
<code>dec</code> to specify the character used for the decimal point
(the default is a period), and <code>comment.char</code> to specify a
character to indicate comment lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available formats are comma-delimited (<code>csv</code>), rotated
comma-delimited (<code>csvr</code>), comma-delimited with separate files for
genotype and phenotype data (<code>csvs</code>), rotated comma-delimited
with separate files for genotype and phenotype data (<code>csvsr</code>),
Mapmaker (<code>mm</code>), Map Manager QTX (<code>qtx</code>), Gary Churchill's
format (<code>gary</code>), Karl Broman's format (<code>karl</code>) and
MapQTL/JoinMap (<code>mapqtl</code>).  The required files and their
specification for each format appears below. The comma-delimited
formats are recommended. Note that most of these formats work only
for backcross and intercross data.
</p>
<p>The <code>sampledata</code> directory in the package distribution contains
sample data files in multiple formats.    Also see
<a href="https://rqtl.org/sampledata/">https://rqtl.org/sampledata/</a>.
</p>
<p>The <code>...</code> argument enables additional arguments to be passed to
the function <code><a href="utils.html#topic+read.table">read.table</a></code> in the case of <code>csv</code>
and <code>csvr</code> formats.  In particular, one may use the argument
<code>sep</code> to specify the field separator (the default is a comma),
<code>dec</code> to specify the character used for the decimal point (the
default is a period), and <code>comment.char</code> to specify a character
to indicate comment lines.
</p>


<h3>Value</h3>

<p>An object of class <code>cross</code>, which is a list with two components:
</p>
<table role = "presentation">
<tr><td><code>geno</code></td>
<td>
<p>This is a list with elements corresponding to
chromosomes.  <code>names(geno)</code> contains the names of the
chromsomes.  Each chromosome is itself a list, and is given class
<code>A</code> or <code>X</code> according to whether it is autosomal
or the X chromosome.
</p>
<p>There are two components for each chromosome: <code>data</code>, a matrix
whose rows are individuals and whose columns are markers, and
<code>map</code>, either a vector of marker positions (in cM) or a matrix
of dim (<code>2 x n.mar</code>) where the rows correspond to marker
positions in female and male genetic distance, respectively.
</p>
<p>The genotype data gets converted into numeric codes, as follows.
</p>
<p>The genotype data for a backcross is coded as NA = missing,
1 = AA, 2 = AB.
</p>
<p>For an F2 intercross, the coding is NA = missing, 1 = AA, 2 = AB, 3
= BB, 4 = not BB (i.e. AA or AB; D in Mapmaker/qtl), 5 = not AA (i.e. AB
or BB; C in Mapmaker/qtl).
</p>
<p>For a 4-way cross, the mother and father are assumed to have
genotypes AB and CD, respectively.  The genotype data for the
progeny is assumed to be phase-known, with the following coding
scheme: NA = missing, 1 = AC, 2 = BC, 3 = AD, 4 = BD, 5 = A = AC or AD,
6 = B = BC or BD, 7 = C = AC or BC, 8 = D = AD or BD, 9 = AC or BD,
10 = AD or BC, 11 = not AC, 12 = not BC, 13 = not AD, 14 = not BD.
</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p>data.frame of size (<code>n.ind x n.phe</code>) containing the
phenotypes.  If a phenotype with the name <code>id</code> or <code>ID</code> is
included, these identifiers will be used in <code><a href="#topic+top.errorlod">top.errorlod</a></code>,
<code><a href="#topic+plotErrorlod">plotErrorlod</a></code>, and <code><a href="#topic+plotGeno">plotGeno</a></code> as
identifiers for the individual.</p>
</td></tr>
</table>
<p>While the data format is complicated, there are a number of functions,
such as <code><a href="#topic+subset.cross">subset.cross</a></code>, to
assist in pulling out portions of the data.
</p>


<h3>X chromosome</h3>

<p><b>The genotypes for the X chromosome require special care!</b>
</p>
<p>The X chromosome should be given chromosome identifier <code>X</code> or
<code>x</code>.  If it is labeled by a number or by <code>Xchr</code>, it will be
interpreted as an autosome.
</p>
<p>The phenotype data should contain a column named <code>"sex"</code> which
indicates the sex of each individual, either coded as <code>0</code>=female and
<code>1</code>=male, or as a factor with levels <code>female</code>/<code>male</code> or
<code>f</code>/<code>m</code>.  Case will be
ignored both in the name and in the factor levels.  If no such
phenotype column is included, it will be assumed that all individuals
are of the same sex.
</p>
<p>In the case of an intercross, the phenotype data may also contain a
column named <code>"pgm"</code> (for &quot;paternal grandmother&quot;) indicating the
direction of the cross.  It should be coded as 0/1 with 0 indicating
the cross (AxB)x(AxB) or (BxA)x(AxB) and 1 indicating the cross
(AxB)x(BxA) or (BxA)x(BxA).  If no such phenotype column is included,
it will be assumed that all individuals come from the same direction
of cross.
</p>
<p>The internal storage of X chromosome data is quite different from that
of autosomal data.  Males are coded 1=AA and 2=BB; females with pgm==0
are coded 1=AA and 2=AB; and females with pgm==1 are coded 1=BB and
2=AB.  If the argument <code>convertXdata</code> is TRUE, conversion to this
format is made automatically; if FALSE, no conversion is done,
<code><a href="#topic+summary.cross">summary.cross</a></code> will likely return a warning, and
most analyses will not work properly.
</p>
<p>Use of <code>convertXdata=FALSE</code> (in which case the X chromosome
genotypes will not be converted to our internal standard) can be
useful for diagnosing problems in the data, but will require some
serious mucking about in the internal data structure.
</p>


<h3>CSV format</h3>

<p>The input file is a comma-delimited text file.  A different field
separator may be specified via the argument <code>sep</code>, which will be passed
to the function <code><a href="utils.html#topic+read.table">read.table</a></code>).  For example, in
Europe, it is common to use a comma in place of the decimal point in
numbers and so a semi-colon in place of a comma as the field
separator; such data may be read by using <code>sep=";"</code> and
<code>dec=","</code>.
</p>
<p>The first line should contain the phenotype names followed by the
marker names.  <b>At least one phenotype must be included</b>; for
example, include a numerical index for each individual.
</p>
<p>The second line should contain blanks in the phenotype columns,
followed by chromosome identifiers for each marker in all other
columns. If a chromosome has the identifier <code>X</code> or <code>x</code>, it
is assumed to be the X chromosome; otherwise, it is assumed to be an
autosome.
</p>
<p>An optional third line should contain blanks in the phenotype
columns, followed by marker positions, in cM.
</p>
<p>Marker order is taken from the cM positions, if provided; otherwise,
it is taken from the column order.
</p>
<p>Subsequent lines should give the data, with one line for each
individual, and with phenotypes followed by genotypes.  If possible,
phenotypes are made numeric; otherwise they are converted to factors.
</p>
<p>The genotype codes must be the same across all markers.  For example,
you can't have one marker coded AA/AB/BB and another coded A/H/B.
This includes genotypes for the X chromosome, for which hemizygous
individuals should be coded as if they were homoyzogous.
</p>
<p>The cross is determined to be a backcross if only the first two elements
of the <code>genotypes</code> string are found; otherwise, it is assumed to
be an intercross.
</p>


<h3>CSVr format</h3>

<p>This is just like the <code>csv</code> format, but rotated (or really
transposed), so that rows are columns and columns are rows.
</p>


<h3>CSVs format</h3>

<p>This is like the <code>csv</code> format, but with separate files for the
genotype and phenotype data.
</p>
<p>The first column in the genotype data must specify individuals'
identifiers, and there must be a column in the phenotype data with
precisely the same information (and with the same name).  These IDs
will be included in the data as a phenotype.  If the name <code>id</code> or
<code>ID</code> is used, these identifiers will be used in
<code><a href="#topic+top.errorlod">top.errorlod</a></code>, <code><a href="#topic+plotErrorlod">plotErrorlod</a></code>, and
<code><a href="#topic+plotGeno">plotGeno</a></code> as identifiers for the individual.
</p>
<p>The first row in each file contains the column names.  For the
phenotype file, these are the names of the phenotypes.  For the
genotype file, the first cell will be the name of the identifier
column (<code>id</code> or <code>ID</code>) and the subsequent fields will be the
marker names.
</p>
<p>In the genotype data file, the second row gives the chromosome IDs.
The cell in the second row, first column, must be blank.  A third
row giving cM positions of markers may be included, in which case the
cell in the third row, first column, must be blank.
</p>
<p>There need be no blank rows in the phenotype data file.
</p>


<h3>CSVsr format</h3>

<p>This is just like the <code>csvs</code> format, but with each file rotated
(or really transposed), so that rows are columns and columns are rows.
</p>


<h3>Mapmaker format</h3>

<p>This format requires two files.  The so-called rawfile, specified by
the argument <code>file</code>, contains the genotype and phenotype
data. Rows beginning with the symbol <code>#</code> are ignored.  The first
line should be either <code>data type f2 intercross</code> or
<code>data type f2 backcross</code>.  The second line should begin with
three numbers indicating the numbers of individuals, markers and
phenotypes in the file.  This line may include the word <code>symbols</code>
followed by symbol assignments (see the documentation for mapmaker,
and cross your fingers).  The rest of the lines give genotype data
followed by phenotype data, with marker and phenotype names always
beginning with the <code>*</code> symbol.
</p>
<p>A second file contains the genetic map information, specified with
the argument <code>mapfile</code>.  The map file may be in
one of two formats.  The function will determine which format of map
file is presented.
</p>
<p>The simplest format for the map file is not standard for the Mapmaker
software, but is easy to create.  The file contains two or three
columns separated by white space and with no header row.  The first
column gives the chromosome assignments.  The second column gives the
marker names, with markers listed in the order along the chromosomes.
An optional third column lists the map positions of the markers.
</p>
<p>Another possible format for the map file is the <code>.maps</code>
format, which is produced by Mapmaker.  The code for reading this
format was written by Brian Yandell.
</p>
<p>Marker order is taken from the map file, either by the order they are
presented or by the cM positions, if specified.
</p>


<h3>Map Manager QTX format</h3>

<p>This format requires a single file (that produced by the Map Manager
QTX program).
</p>


<h3>QTL Cartographer format</h3>

<p>This format requires two files: the <code>.cro</code> and <code>.map</code> files
for QTL Cartographer (produced by the QTL Cartographer
sub-program, Rmap and Rcross).
</p>
<p>Note that the QTL Cartographer cross types are converted as follows:
RF1 to riself, RF2 to risib, RF0 (doubled haploids) to bc, B1 or B2 to
bc, RF2 or SF2 to f2.
</p>


<h3>Tidy format</h3>

<p>This format requires three simple CSV files, separating the genotype,
phenotype, and marker map information so that each file may be of a
simple form.
</p>


<h3>Gary format</h3>

<p>This format requires the six files.  All files have default names, and
so the file names need not be specified if the default names are used.
</p>
<p><code>genfile</code> (default = <code>"geno.dat"</code>) contains the genotype
data.  The file contains one line per individual, with genotypes for
the set of markers separated by white space.  Missing values are
coded as 9, and genotypes are coded as 0/1/2 for AA/AB/BB.
</p>
<p><code>mapfile</code> (default = <code>"markerpos.txt"</code>) contains two
columns with no header row: the marker names in the first column and
their cM position in the second column.  If marker positions are not
available, use <code>mapfile=NULL</code>, and a dummy map will be inserted.
</p>
<p><code>phefile</code> (default = <code>"pheno.dat"</code>) contains the phenotype
data, with one row for each mouse and one column for each phenotype.
There should be no header row, and missing values are coded as
<code>"-"</code>.
</p>
<p><code>chridfile</code> (default = <code>"chrid.dat"</code>) contains the
chromosome identifier for each marker.
</p>
<p><code>mnamesfile</code> (default = <code>"mnames.txt"</code>) contains the marker
names.
</p>
<p><code>pnamesfile</code> (default = <code>"pnames.txt"</code>) contains the names
of the phenotypes.  If phenotype names file is not available, use
<code>pnamesfile=NULL</code>; arbitrary phenotype names will then be
assigned.
</p>


<h3>Karl format</h3>

<p>This format requires three files; all files have default names, and so
need not be specified if the default name is used.
</p>
<p><code>genfile</code> (default = <code>"gen.txt"</code>) contains the genotype
data.  The file contains one line per individual, with genotypes
separated by white space.  Missing values are coded 0; genotypes are
coded as 1/2/3/4/5 for AA/AB/BB/not BB/not AA.
</p>
<p><code>mapfile</code> (default = <code>"map.txt"</code>) contains the map
information, in the following complicated format: <br /> <br />
<code>n.chr</code> <br />
<code>n.mar(1) rf(1,1) rf(1,2) ... rf(1,n.mar(1)-1)</code><br />
<code>mar.name(1,1)</code><br />
<code>mar.name(1,2)</code><br />
<code>...</code><br />
<code>mar.name(1,n.mar(1))</code><br />
<code>n.mar(2)</code><br />
<code>...</code><br />
<code>etc.</code> <br />
</p>
<p><code>phefile</code> (default = <code>"phe.txt"</code>) contains a matrix of
phenotypes, with one individual per line.  The first line in the
file should give the phenotype names.
</p>


<h3>MapQTL format</h3>

<p>This format requires three files, described in the manual of the
MapQTL program (same as JoinMap).
</p>
<p><code>genfile</code> corresponds to the loc file containing the genotype
data. Each marker and its genotypes should be on a single line.
</p>
<p><code>mapfile</code> corresponds to the map file containing the linkage
group assignment, marker names and their map positions.
</p>
<p><code>phefile</code> corresponds to the qua file containing the phenotypes.
</p>
<p>For the moment, only 4-way crosses are supported (CP population type
in MapQTL).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Brian
S. Yandell; Aaron Wolen</p>


<h3>References</h3>

<p>Broman, K. W. and Sen,
&#346;. (2009) <em>A
guide to QTL mapping with R/qtl.</em>  Springer.  <a href="https://rqtl.org/book/">https://rqtl.org/book/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+subset.cross">subset.cross</a></code>, <code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+plot.cross">plot.cross</a></code>, <code><a href="#topic+c.cross">c.cross</a></code>, <code><a href="#topic+clean.cross">clean.cross</a></code>,
<code><a href="#topic+write.cross">write.cross</a></code>, <code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="utils.html#topic+read.table">read.table</a></code>.
The <code>sampledata</code> directory in the package distribution contains
sample data files in multiple formats.  Also see
<a href="https://rqtl.org/sampledata/">https://rqtl.org/sampledata/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CSV format
dat1 &lt;- read.cross("csv", dir="Mydata", file="mydata.csv")

# CSVS format
dat2 &lt;- read.cross("csvs", dir="Mydata", genfile="mydata_gen.csv",
                   phefile="mydata_phe.csv")

# you can read files directly from the internet
datweb &lt;- read.cross("csv", "https://rqtl.org/sampledata",
                     "listeria.csv")

# Mapmaker format
dat3 &lt;- read.cross("mm", dir="Mydata", file="mydata.raw",
                   mapfile="mydata.map")

# Map Manager QTX format
dat4 &lt;- read.cross("qtx", dir="Mydata", file="mydata.qtx")

# QTL Cartographer format
dat5 &lt;- read.cross("qtlcart", dir="Mydata", file="qtlcart.cro",
                   mapfile="qtlcart.map")

# Gary format
dat6 &lt;- read.cross("gary", dir="Mydata", genfile="geno.dat",
                   mapfile="markerpos.txt", phefile="pheno.dat",
                   chridfile="chrid.dat", mnamesfile="mnames.txt",
                   pnamesfile="pnames.txt")

# Karl format
dat7 &lt;- read.cross("karl", dir="Mydata", genfile="gen.txt",
                   phefile="phe.txt", mapfile="map.txt")
## End(Not run)
</code></pre>

<hr>
<h2 id='readMWril'>Read data for 4- or 8-way RIL</h2><span id='topic+readMWril'></span>

<h3>Description</h3>

<p>Data for a set of 4- or 8-way recombinant inbred lines (RIL) is read
from a pair of comma-delimited files and converted
into an object of class <code>cross</code>.
We require chromosome
assignments for the genetic markers, and assume that markers are in
their correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMWril(dir="", rilfile, founderfile,
          type=c("ri4self", "ri4sib", "ri8self", "ri8selfIRIP1", "ri8sib", "bgmagic16"),
          na.strings=c("-","NA"), rotate=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readMWril_+3A_dir">dir</code></td>
<td>
<p>Directory in which the data files will be found.  In
Windows, use forward slashes (<code>"/"</code>) or double backslashes
(<code>"\\"</code>) to specify directory trees.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_rilfile">rilfile</code></td>
<td>
<p>Comma-delimited file for the RIL, in the <code>"csv"</code>
format described in the help file for <code><a href="#topic+read.cross">read.cross</a></code>.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_founderfile">founderfile</code></td>
<td>
<p>File with founder strains' genotypes, in the same
orientation as the <code>rilfile</code>, but with just marker names and the
founders' marker genotypes.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_type">type</code></td>
<td>
<p>The type of RIL.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_na.strings">na.strings</code></td>
<td>
<p>A vector of strings which are to be interpreted as
missing values.  For the
<code>csv</code> formats, these are interpreted globally
for the entire
file, so missing value codes in phenotypes must not be valid
genotypes, and vice versa. For the <code>gary</code> format, these are
used only for the phenotype data.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_rotate">rotate</code></td>
<td>
<p>If TRUE, the <code>rilfile</code> and <code>founderfile</code> are
rotated (really transposed), with rows corresponding to markers
and columns corresponding to individuals.</p>
</td></tr>
<tr><td><code id="readMWril_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the function
<code><a href="utils.html#topic+read.table">read.table</a></code> in the case of
<code>csv</code> and <code>csvr</code> formats.  In particular, one may use the
argument
<code>sep</code> to specify the field separator (the default is a comma)
and <code>dec</code> to specify the character used for the decimal point
(the default is a period).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rilfile</code> should include a phenotype <code>cross</code> containing
character strings of the form <code>ABCDEFGH</code>, indicating the cross
used to generate each RIL.  The genotypes should be coded as
<b>integers</b> (e.g., 1 and 2).
</p>
<p>The founder strains in the <code>founderfile</code> should be the strains
<code>A</code>, <code>B</code>, <code>C</code>, ..., as indicated in the <code>cross</code>
phenotype.
</p>
<p>The default arrangement of the files is to have markers as columns and
individuals/founders as rows. If <code>rotate=TRUE</code>, do the opposite:
markers as rows and individuals/founders as columns.
</p>


<h3>Value</h3>

<p>An object of class <code>cross</code>; see the help file for
<code><a href="#topic+read.cross">read.cross</a></code> for details.
</p>
<p>An additional component <code>crosses</code> is included; this is a matrix
indicating the crosses used to generate the RIL.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+sim.cross">sim.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ril &lt;- read.cross("../Data", "ril_data.csv", "founder_geno.csv", "ri4self",
                  rotate=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='reduce2grid'>Reduce to a grid of pseudomarkers.</h2><span id='topic+reduce2grid'></span>

<h3>Description</h3>

<p>For high-density marker data, rather than run <code><a href="#topic+scanone">scanone</a></code> at both the
markers and at a set of pseudomarkers, we reduce to just
a set of evenly-spaced pseudomarkers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce2grid(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce2grid_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotype probabilities (from <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>) and/or
imputations (from <code><a href="#topic+sim.geno">sim.geno</a></code>) are subset to a grid of
pseudomarkers.
</p>
<p>This is so that, in the case of high-density markers, we can do the
genome scan calculations at a smaller set of points (on an
evenly-spaced grid, but not at the markers) to save computation time.
</p>
<p>You need to first have run <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> and/or
<code><a href="#topic+sim.geno">sim.geno</a></code>, and you must use <code>stepwidth="fixed"</code>.
</p>
<p>When plotting results with <code><a href="#topic+plot.scanone">plot.scanone</a></code>, use
<code>incl.markers=FALSE</code>, as the output of <code><a href="#topic+scanone">scanone</a></code>
won't include information about the marker locations and so will plot
tick marks only at the first marker on each chromosome.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object with included genotype probabilities or
imputations subset to an evenly-spaced grid.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+sim.geno">sim.geno</a></code>, <code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
hyper &lt;- calc.genoprob(hyper, step=2)
hypersub &lt;- reduce2grid(hyper)

## Not run: out &lt;- scanone(hypersub)
plot(out, incl.markers=FALSE)
## End(Not run)
</code></pre>

<hr>
<h2 id='refineqtl'>Refine the positions of QTL</h2><span id='topic+refineqtl'></span>

<h3>Description</h3>

<p>Iteratively scan the positions for QTL in the context of a multiple
QTL model, to try to identify the positions with maximum likelihood,
for a fixed QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refineqtl(cross, pheno.col=1, qtl, chr, pos, qtl.name, covar=NULL, formula,
          method=c("imp","hk"), model=c("normal", "binary"), verbose=TRUE, maxit=10,
          incl.markers=TRUE, keeplodprofile=TRUE, tol=1e-4,
          maxit.fitqtl=1000, forceXcovar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refineqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
used as the phenotype.  One may also give a character string matching
the phenotype name.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_qtl">qtl</code></td>
<td>
<p>A QTL object, as produced by <code><a href="#topic+makeqtl">makeqtl</a></code>,
containing the positions of the QTL.  Provide either <code>qtl</code> or
the pair <code>chr</code> and <code>pos</code>.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosome for each QTL; if <code>qtl</code>
is provided, this should not be.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_pos">pos</code></td>
<td>
<p>Vector indicating the positions for each QTL; if <code>qtl</code>
is provided, this should not be.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_qtl.name">qtl.name</code></td>
<td>
<p>Optional user-specified name for each QTL.  If
<code>qtl</code> is provided, this should not be.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are indicated as <code>Q1</code>,
<code>Q2</code>, etc.  Covariates are indicated by their names in <code>covar</code>.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give feedback about progress.  If
<code>verbose</code> is an integer &gt; 1, further messages from
<code><a href="#topic+scanqtl">scanqtl</a></code> are also displayed.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_keeplodprofile">keeplodprofile</code></td>
<td>
<p>If TRUE, keep the LOD profiles from the last
iteration as attributes to the output.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_maxit.fitqtl">maxit.fitqtl</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="refineqtl_+3A_forcexcovar">forceXcovar</code></td>
<td>
<p>If TRUE, force inclusion of X-chr-related covariates
(like sex and cross direction).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>QTL positions are optimized, within the context of a fixed QTL model,
by a scheme described in Zeng et al. (1999).  Each QTL is considered
one at a time (in a random order), and a scan is performed, allowing
the QTL to vary across its chromosome, keeping the positions of all
other QTL fixed.  If there is another QTL on the chromosome, the
position of the floating QTL is scanned from the end of the chromosome
to the position of the flanking QTL.  If the floating QTL is between
two QTL on a chromosome, its position is scanned between those two QTL
positions.  Each QTL is moved to the position giving the highest
likelihood, and the entire process is repeated until no further
improvement in likelihood can be obtained.
</p>
<p>One may provide either a <code>qtl</code> object (as produced by
<code><a href="#topic+makeqtl">makeqtl</a></code>), or vectors <code>chr</code> and <code>pos</code>
(and, optionally, <code>qtl.name</code>) indicating the positions of the
QTL.
</p>
<p>If a <code>qtl</code> object is provided, QTL that do not appear in
the model <code>formula</code> are ignored, but they remain part of the QTL
object that is output.
</p>


<h3>Value</h3>

<p>An object of class <code>qtl</code>, with QTL placed in their new positions.
</p>
<p>If <code>keeplodprofile=TRUE</code>, LOD profiles from the last pass through
the refinement algorithm are retained as an attribute,
<code>"lodprofile"</code>, to the object.  These may be plotted with
<code><a href="#topic+plotLodProfile">plotLodProfile</a></code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Zeng, Z.-B., Kao, C.-H., and Basten, C. J. (1999) Estimating the
genetic architecture of quantitative traits.  <em>Genet. Res.</em>
<b>74</b>, 279&ndash;289.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code>, <code><a href="#topic+addtoqtl">addtoqtl</a></code>,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>, <code><a href="#topic+replaceqtl">replaceqtl</a></code>,
<code><a href="#topic+plotLodProfile">plotLodProfile</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2)
qtl &lt;- makeqtl(fake.bc, chr=c(2,5), pos=c(32.5, 17.5), what="prob")
rqtl &lt;- refineqtl(fake.bc, qtl=qtl, method="hk")
</code></pre>

<hr>
<h2 id='reorderqtl'>Reorder the QTL in a qtl object</h2><span id='topic+reorderqtl'></span>

<h3>Description</h3>

<p>This function changes the order of the QTL in a QTL object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorderqtl(qtl, neworder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorderqtl_+3A_qtl">qtl</code></td>
<td>
<p>A qtl object, as created by <code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="reorderqtl_+3A_neworder">neworder</code></td>
<td>
<p>A vector containing the positive integers up to the
number of QTL in <code>qtl</code>, indicating the new order for the QTL.
If missing, the QTL are ordered by chromosome and then by their
position within a chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Everything in the input <code>qtl</code> is reordered except the
<code>altname</code> component, which contains names of the form <code>Q1</code>,
<code>Q2</code>, etc.
</p>


<h3>Value</h3>

<p>The input <code>qtl</code> object, with the loci reordered.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>, <code><a href="#topic+addtoqtl">addtoqtl</a></code>,
<code><a href="#topic+replaceqtl">replaceqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 6, 13)
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

qtl &lt;- reorderqtl(qtl, c(2,3,1))
qtl

qtl &lt;- reorderqtl(qtl)
qtl
</code></pre>

<hr>
<h2 id='replace.map'>Replace the genetic map of a cross</h2><span id='topic+replace.map'></span><span id='topic+replacemap.cross'></span>

<h3>Description</h3>

<p>Replace the map portion of a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.map(cross, map)
## S3 method for class 'cross'
replacemap(object, map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace.map_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="replace.map_+3A_object">object</code></td>
<td>
<p>Same as <code>cross</code>.</p>
</td></tr>
<tr><td><code id="replace.map_+3A_map">map</code></td>
<td>
<p>A list containing the new genetic map.  This must be the
same length and with the same marker names as that contained in
<code>cross</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> object with the genetic map replaced by
the input <code>map</code>.  Maps for results from
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code>, <code><a href="#topic+sim.geno">sim.geno</a></code> and
<code><a href="#topic+argmax.geno">argmax.geno</a></code> are also replaced, using interpolation if
necessary.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+est.map">est.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

newmap &lt;- est.map(fake.f2)
plotMap(fake.f2, newmap)
fake.f2 &lt;- replace.map(fake.f2, newmap)
</code></pre>

<hr>
<h2 id='replacemap.scanone'>Replace the genetic map in QTL mapping results with an alternate map</h2><span id='topic+replacemap.scanone'></span>

<h3>Description</h3>

<p>Replace the positions of LOD scores in output from
<code><a href="#topic+scanone">scanone</a></code> with values
based on an alternative map (such as a physical map), with
pseudomarker locations determined by linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
replacemap(object, map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replacemap.scanone_+3A_object">object</code></td>
<td>
<p>An object of class <code>"scanone"</code>, as output by the
function <code><a href="#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code id="replacemap.scanone_+3A_map">map</code></td>
<td>
<p>A list containing the alternative genetic map.  All
chromosomes in <code>object</code> should have corresponding chromosomes in
<code>map</code>, and markers must be in the same order in the two maps.
There must be at least two markers on each chromosome in <code>map</code>
that appear in <code>object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The positions of pseudomarkers are determined by linear interpolation
between markers.  In the case of pseudomarkers beyond the ends of the
terminal markers on chromosomes, we use the overall lengths of the
chromosome in <code>object</code> and <code>map</code> to determine the new
spacing.
</p>


<h3>Value</h3>

<p>The input <code>object</code> with the positions of LOD scores
revised to match those in the input <code>map</code>.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+replace.map">replacemap.cross</a></code>,
<code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+replacemap.scantwo">replacemap.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

origmap &lt;- pull.map(fake.f2)
newmap &lt;- est.map(fake.f2)
fake.f2 &lt;- replacemap(fake.f2, newmap)
fake.f2 &lt;- calc.genoprob(fake.f2, step=2.5)
out &lt;- scanone(fake.f2, method="hk")
out.rev &lt;- replacemap(out, origmap)
</code></pre>

<hr>
<h2 id='replacemap.scantwo'>Replace the genetic map in QTL mapping results with an alternate map</h2><span id='topic+replacemap.scantwo'></span>

<h3>Description</h3>

<p>Replace the positions of LOD scores in output from
<code><a href="#topic+scantwo">scantwo</a></code> with values
based on an alternative map (such as a physical map), with
pseudomarker locations determined by linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
replacemap(object, map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replacemap.scantwo_+3A_object">object</code></td>
<td>
<p>An object of class <code>"scantwo"</code>, as output by the
function <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="replacemap.scantwo_+3A_map">map</code></td>
<td>
<p>A list containing the alternative genetic map.  All
chromosomes in <code>object</code> should have corresponding chromosomes in
<code>map</code>, and markers must be in the same order in the two maps.
There must be at least two markers on each chromosome in <code>map</code>
that appear in <code>object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The positions of pseudomarkers are determined by linear interpolation
between markers.  In the case of pseudomarkers beyond the ends of the
terminal markers on chromosomes, we use the overall lengths of the
chromosome in <code>object</code> and <code>map</code> to determine the new
spacing.
</p>


<h3>Value</h3>

<p>The input <code>object</code> with the positions of LOD scores
revised to match those in the input <code>map</code>.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+replace.map">replacemap.cross</a></code>,
<code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+replacemap.scanone">replacemap.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

origmap &lt;- pull.map(hyper)
newmap &lt;- est.map(hyper)
hyper &lt;- replacemap(hyper, newmap)
hyper &lt;- calc.genoprob(hyper, step=0)
out &lt;- scantwo(hyper, method="hk")
out.rev &lt;- replacemap(out, origmap)
</code></pre>

<hr>
<h2 id='replaceqtl'>Replace a QTL in a qtl object with a different position</h2><span id='topic+replaceqtl'></span>

<h3>Description</h3>

<p>This function replaces a QTL or QTLs in a qtl object with a different
position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceqtl(cross, qtl, index, chr, pos, qtl.name, drop.lod.profile=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replaceqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_qtl">qtl</code></td>
<td>
<p>A qtl object, as created by <code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_index">index</code></td>
<td>
<p>Numeric index indicating the QTL to be replaced.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_chr">chr</code></td>
<td>
<p>Vector (of same length as <code>index</code>) indicating the
chromosomes for the new QTL.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_pos">pos</code></td>
<td>
<p>Vector (of same length as <code>index</code>) indicating the
positions for the new QTL. If there is no marker or pseudomarker at a
position, the nearest position is used.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_qtl.name">qtl.name</code></td>
<td>
<p>Optional vector (of same length as <code>index</code>)
of user-specified names for each new QTL, used in the
drop-one-term ANOVA table in <code><a href="#topic+fitqtl">fitqtl</a></code>.
If unspecified, the names will be of the form <code>"Chr1@10"</code> for a
QTL on Chromsome 1 at 10 cM.</p>
</td></tr>
<tr><td><code id="replaceqtl_+3A_drop.lod.profile">drop.lod.profile</code></td>
<td>
<p>If TRUE, remove any LOD profiles from the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>qtl</code> object,
but with some QTL replaced by new ones.  See <code><a href="#topic+makeqtl">makeqtl</a></code> for
details on the format.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code>, <code><a href="#topic+fitqtl">fitqtl</a></code>,
<code><a href="#topic+dropfromqtl">dropfromqtl</a></code>, <code><a href="#topic+addtoqtl">addtoqtl</a></code>,
<code><a href="#topic+reorderqtl">reorderqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 6, 13)
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

qtl &lt;- replaceqtl(fake.f2, qtl, 2, 6, 48.1)
</code></pre>

<hr>
<h2 id='rescalemap'>Rescale genetic maps</h2><span id='topic+rescalemap'></span>

<h3>Description</h3>

<p>Rescale a genetic map by multiplying all positions by a constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescalemap(object, scale=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescalemap_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code> (see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or <code>map</code> (see
<code><a href="#topic+sim.map">sim.map</a></code> for details).</p>
</td></tr>
<tr><td><code id="rescalemap_+3A_scale">scale</code></td>
<td>
<p>Scale factor by which all positions will be multiplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included particularly for the case that map positions
in a cross object were provided in basepairs and one wishes to quickly
convert them to Mbp or some other approximation of cM distances.  (In
the mouse, 1 cM is approximation 2 Mbp, so one might use
<code>scale=5e-7</code> in this function.)
</p>


<h3>Value</h3>

<p>If the input is a <code>map</code> object, a <code>map</code> object is returned; if
the input is a <code>cross</code> object, a <code>cross</code> object is returned.
In either case, the positions of markers are simply multiplied by
<code>scale</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+replace.map">replace.map</a></code>,
<code><a href="#topic+est.map">est.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
rescaled &lt;- rescalemap(hyper, scale=2)
plotMap(hyper, rescaled)
</code></pre>

<hr>
<h2 id='ripple'>Compare marker orders</h2><span id='topic+ripple'></span>

<h3>Description</h3>

<p>Investigate different marker orders for a given chromosome, comparing
all possible permutations of a sliding window of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripple(cross, chr, window=4, method=c("countxo","likelihood"),
       error.prob=0.0001, map.function=c("haldane","kosambi","c-f","morgan"),
       maxit=4000, tol=1e-6, sex.sp=TRUE, verbose=TRUE, n.cluster=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ripple_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="ripple_+3A_chr">chr</code></td>
<td>
<p>The chromosome to investigate.  Only one chromosome is
allowed. (This should be a character string referring to the
chromosomes by name.)</p>
</td></tr>
<tr><td><code id="ripple_+3A_window">window</code></td>
<td>
<p>Number of markers to include in the sliding window of
permuted markers.  Larger numbers result in the comparison of a
greater number of marker orders, but will require a considerable
increase in computation time.</p>
</td></tr>
<tr><td><code id="ripple_+3A_method">method</code></td>
<td>
<p>Indicates whether to compare orders by counting the
number of obligate crossovers, or by a likelihood analysis.</p>
</td></tr>
<tr><td><code id="ripple_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="ripple_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="ripple_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="ripple_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="ripple_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="ripple_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, information about the number of orders (and, if
<code>method="likelihood"</code>, about progress) are printed.</p>
</td></tr>
<tr><td><code id="ripple_+3A_n.cluster">n.cluster</code></td>
<td>
<p>If the package <code>snow</code> is available and
<code>n.perm</code> &gt; 0, permutations are run in parallel using this number
of nodes.  This is really only useful with <code>method="likelihood"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method="likelihood"</code>, calculations are done by first
constructing a matrix of marker orders and then making repeated calls
to the R function <code><a href="#topic+est.map">est.map</a></code>.  Of course, it would be
faster to do everything within C, but this was a lot easier to code.
</p>
<p>For <code>method="countxo"</code>, calculations are done within C.
</p>


<h3>Value</h3>

<p>A matrix, given class <code>"ripple"</code>; the first set of columns are
marker indices describing the order.  In the case of
<code>method="countxo"</code>, the last column is the number of obligate
crossovers for each particular order.  In the case of
<code>method="likelihood"</code>, the last two columns are LOD scores (log
base 10 likelihood ratios) comparing each order to the initial order
and the estimated chromosome length for the given order.  Positive LOD
scores indicate that the alternate order has more support than the
original.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.ripple">summary.ripple</a></code>, <code><a href="#topic+switch.order">switch.order</a></code>,
<code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+est.rf">est.rf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(badorder)
rip1 &lt;- ripple(badorder, chr=1, window=3)
summary(rip1)

## Not run: 
rip2 &lt;- ripple(badorder, chr=1, window=2, method="likelihood")
summary(rip2)

## End(Not run)

badorder &lt;- switch.order(badorder, 1, rip1[2,])
</code></pre>

<hr>
<h2 id='scanone'>Genome scan with a single QTL model</h2><span id='topic+scanone'></span>

<h3>Description</h3>

<p>Genome scan with a single QTL model, with possible allowance for
covariates, using any of several possible models for the phenotype and
any of several possible numerical methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanone(cross, chr, pheno.col=1, model=c("normal","binary","2part","np"),
        method=c("em","imp","hk","ehk","mr","mr-imp","mr-argmax"),
        addcovar=NULL, intcovar=NULL, weights=NULL,
        use=c("all.obs", "complete.obs"), upper=FALSE,
        ties.random=FALSE, start=NULL, maxit=4000,
        tol=1e-4, n.perm, perm.Xsp=FALSE, perm.strata=NULL, verbose,
        batchsize=250, n.cluster=1, ind.noqtl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanone_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanone_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes for which LOD
scores should be calculated.  This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="scanone_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This can be a vector of integers; for methods
<code>"hk"</code> and <code>"imp"</code> this can be considerably faster than doing
them one at a time.  One may also give a character strings matching
the phenotype names.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanone_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual normal model, a model for
binary traits, a two-part model or non-parametric analysis</p>
</td></tr>
<tr><td><code id="scanone_+3A_method">method</code></td>
<td>
<p>Indicates whether to use the EM algorithm,
imputation, Haley-Knott regression, the extended Haley-Knott method,
or marker regression.  Not all methods are available for all models.
Marker regression is performed either by dropping individuals with
missing genotypes (<code>"mr"</code>), or by first filling in missing data
using a single imputation (<code>"mr-imp"</code>) or by the Viterbi
algorithm (<code>"mr-argmax"</code>).</p>
</td></tr>
<tr><td><code id="scanone_+3A_addcovar">addcovar</code></td>
<td>
<p>Additive covariates;
allowed only for the normal and binary models.</p>
</td></tr>
<tr><td><code id="scanone_+3A_intcovar">intcovar</code></td>
<td>
<p>Interactive covariates (interact with QTL genotype);
allowed only for the normal and binary models.</p>
</td></tr>
<tr><td><code id="scanone_+3A_weights">weights</code></td>
<td>
<p>Optional weights of individuals.  Should be either NULL
or a vector of length n.ind containing positive weights.  Used only
in the case <code>model="normal"</code>.</p>
</td></tr>
<tr><td><code id="scanone_+3A_use">use</code></td>
<td>
<p>In the case that multiple phenotypes are selected to be
scanned, this argument indicates whether to use all individuals,
including those missing some phenotypes, or just those individuals
that have data on all selected phenotypes.</p>
</td></tr>
<tr><td><code id="scanone_+3A_upper">upper</code></td>
<td>
<p>Used only for the two-part model; if true, the
&quot;undefined&quot; phenotype is the maximum observed phenotype; otherwise,
it is the smallest observed phenotype.</p>
</td></tr>
<tr><td><code id="scanone_+3A_ties.random">ties.random</code></td>
<td>
<p>Used only for the non-parametric &quot;model&quot;; if TRUE,
ties in the phenotypes are ranked at random.  If FALSE, average ranks
are used and a corrected LOD score is calculated.</p>
</td></tr>
<tr><td><code id="scanone_+3A_start">start</code></td>
<td>
<p>Used only for the EM algorithm with the normal model and
no covariates.  If <code>NULL</code>, use the usual starting values; if
length 1, use random initial weights for EM; otherwise, this should
be a vector of length n+1 (where n is the number of possible
genotypes for the cross), giving the initial values for EM.</p>
</td></tr>
<tr><td><code id="scanone_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for methods <code>"em"</code> and
<code>"ehk"</code>.</p>
</td></tr>
<tr><td><code id="scanone_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for determining convergence for methods
<code>"em"</code> and <code>"ehk"</code>.</p>
</td></tr>
<tr><td><code id="scanone_+3A_n.perm">n.perm</code></td>
<td>
<p>If specified, a permutation test is performed rather than
an analysis of the observed data.  This argument defines the number
of permutation replicates.</p>
</td></tr>
<tr><td><code id="scanone_+3A_perm.xsp">perm.Xsp</code></td>
<td>
<p>If <code>n.perm</code> &gt; 0, so that a permutation test will
be performed, this indicates whether separate permutations should be
performed for the autosomes and the X chromosome, in order to get an
X-chromosome-specific LOD threshold.  In this case, additional
permutations are performed for the X chromosome.</p>
</td></tr>
<tr><td><code id="scanone_+3A_perm.strata">perm.strata</code></td>
<td>
<p>If <code>n.perm</code> &gt; 0, this may be used to perform a
stratified permutation test.  This should be a vector with the same
number of individuals as in the cross data.  Unique values indicate
the individual strata, and permutations will be performed within the
strata.</p>
</td></tr>
<tr><td><code id="scanone_+3A_verbose">verbose</code></td>
<td>
<p>In the case <code>n.perm</code> is specified, display
information about the progress of the permutation tests.</p>
</td></tr>
<tr><td><code id="scanone_+3A_batchsize">batchsize</code></td>
<td>
<p>The number of phenotypes (or permutations) to be run
as a batch; used only for methods <code>"hk"</code> and <code>"imp"</code>.</p>
</td></tr>
<tr><td><code id="scanone_+3A_n.cluster">n.cluster</code></td>
<td>
<p>If the package <code>snow</code> is available and
<code>n.perm</code> &gt; 0, permutations are run in parallel using this number
of nodes.</p>
</td></tr>
<tr><td><code id="scanone_+3A_ind.noqtl">ind.noqtl</code></td>
<td>
<p>Indicates individuals who should not be allowed a QTL
effect (used rarely, if at all); this is a logical vector of same
length as there are individuals in the cross.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use of the EM algorithm, Haley-Knott regression, and the extended
Haley-Knott method require that multipoint genotype probabilities are
first calculated using <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>.  The
imputation method uses the results of <code><a href="#topic+sim.geno">sim.geno</a></code>.
</p>
<p>Individuals with missing phenotypes are dropped.
</p>
<p>In the case that <code>n.perm</code>&gt;0, so that a permutation
test is performed, the R function <code>scanone</code> is called repeatedly.
If <code>perm.Xsp=TRUE</code>, separate permutations are performed for the
autosomes and the X chromosome, so that an X-chromosome-specific
threshold may be calculated.  In this case, <code>n.perm</code> specifies
the number of permutations used for the autosomes; for the X
chromosome, <code>n.perm</code> <code class="reqn">\times \, L_A/L_X</code> permutations
will be run, where <code class="reqn">L_A</code> and <code class="reqn">L_X</code> are the total genetic
lengths of the autosomes and X chromosome, respectively.  More
permutations are needed for the X chromosome in order to obtain
thresholds of similar accuracy.
</p>
<p>For further details on the models, the methods and the use of
covariates, see below.
</p>


<h3>Value</h3>

<p>If <code>n.perm</code> is missing, the function returns a data.frame whose
first two columns contain the chromosome IDs and cM positions.
Subsequent columns contain the LOD scores for each phenotype.
In the case of the two-part model, there are three LOD score columns
for each phenotype: LOD(<code class="reqn">p,\mu</code>), LOD(<code class="reqn">p</code>) and
LOD(<code class="reqn">\mu</code>).   The result is given class <code>"scanone"</code> and
has attributes  <code>"model"</code>, <code>"method"</code>, and
<code>"type"</code> (the latter is the type of cross analyzed).
</p>
<p>If <code>n.perm</code> is specified, the function returns the results of a
permutation test and the output has class <code>"scanoneperm"</code>.  If
<code>perm.Xsp=FALSE</code>, the function returns a matrix with
<code>n.perm</code> rows, each row containing the genome-wide
maximum LOD score for each of the phenotypes.  In the case of the
two-part model, there are three columns for each phenotype,
corresponding to the three different LOD scores. If
<code>perm.Xsp=TRUE</code>, the result contains separate permutation results
for the autosomes and the X chromosome respectively, and an attribute
indicates the lengths of the chromosomes and an indicator of which
chromosome is X.
</p>


<h3>Models</h3>

<p><b>The normal model</b> is the standard model for QTL mapping (see
Lander and Botstein 1989).  The
residual phenotypic variation is assumed to follow a normal
distribution, and analysis is analogous to analysis of variance.
</p>
<p><b>The binary model</b> is for the case of a binary phenotype, which
must have values 0 and 1.  The proportions of 1's in the different
genotype groups are compared.  Currently only methods <code>em</code>, <code>hk</code>, and
<code>mr</code> are available for this model.  See Xu and Atchley (1996) and
Broman (2003).
</p>
<p><b>The two-part model</b> is appropriate for the case of a spike in
the phenotype distribution (for example, metastatic density when many
individuals show no metastasis, or survival time following an
infection when individuals may recover from the infection and fail to
die).  The two-part model was described by
Boyartchuk et al. (2001) and Broman (2003).  Individuals with QTL
genotype <code class="reqn">g</code> have probability <code class="reqn">p_g</code> of having an
undefined phenotype (the spike), while if their phenotype is defined,
it comes from a normal distribution with mean <code class="reqn">\mu_g</code> and
common standard deviation <code class="reqn">\sigma</code>. Three LOD scores are
calculated: LOD(<code class="reqn">p,\mu</code>) is for the test of the hypothesis
that <code class="reqn">p_g = p</code> and <code class="reqn">\mu_g = \mu</code>.
LOD(<code class="reqn">p</code>) is for the test that <code class="reqn">p_g = p</code> while the
<code class="reqn">\mu_g</code> may vary. LOD(<code class="reqn">\mu</code>) is for the test that
<code class="reqn">\mu_g = \mu</code> while the <code class="reqn">p_g</code> may vary.
</p>
<p><b>With the non-parametric &quot;model&quot;</b>, an extension of the
Kruskal-Wallis test is used; this is similar to the method described
by Kruglyak and Lander (1995).  In the case of incomplete genotype
information (such as at locations between genetic markers), the
Kruskal-Wallis statistic is modified so that the rank for each
individual is weighted by the genotype probabilities, analogous to
Haley-Knott regression.  For this method, if the argument
<code>ties.random</code> is TRUE, ties in the phenotypes are assigned random
ranks; if it is FALSE, average ranks are used and a corrected LOD
score is calculate.  Currently the <code>method</code> argument is ignored
for this model.
</p>


<h3>Methods</h3>

<p><b><code>em</code></b>: maximum likelihood is performed via the
EM algorithm (Dempster et al. 1977), first used in this context by
Lander and Botstein (1989).
</p>
<p><b><code>imp</code></b>: multiple imputation is used, as described by Sen
and Churchill (2001).
</p>
<p><b><code>hk</code></b>: Haley-Knott regression is used (regression of the
phenotypes on the multipoint QTL genotype probabilities), as described
by Haley and Knott (1992).
</p>
<p><b><code>ehk</code></b>: the extended Haley-Knott method is used (like H-K,
but taking account of the variances), as described in Feenstra et
al. (2006).
</p>
<p><b><code>mr</code></b>: Marker regression is used.  Analysis is performed
only at the genetic markers, and individuals with missing genotypes
are discarded.  See Soller et al. (1976).
</p>


<h3>Covariates</h3>

<p>Covariates are allowed only for the normal and binary models.  The
normal model is <code class="reqn">y = \beta_q + A \gamma + Z \delta_q + \epsilon</code> where <em>q</em> is the unknown QTL genotype, <em>A</em>
is a matrix of additive covariates, and <em>Z</em> is a matrix of
covariates that interact with the QTL genotype.  The columns of <em>Z</em>
are forced to be contained in the matrix <em>A</em>.  The binary model is
the logistic regression analog.
</p>
<p>The LOD score is calculated comparing the likelihood of the above
model to that of the null model <code class="reqn">y = \mu + A \gamma + \epsilon</code>.
</p>
<p>Covariates must be numeric matrices.  Individuals with any missing
covariates are discarded.
</p>


<h3>X chromosome</h3>

<p>The X chromosome must be treated specially in QTL mapping.  See Broman
et al. (2006).
</p>
<p>If both males and females are included, male hemizygotes are allowed
to be different from female homozygotes.  Thus, in a backcross, we will
fit separate means for the genotype classes AA, AB, AY, and BY.  In such
cases, sex differences in the phenotype could cause spurious linkage to
the X chromosome, and so the null hypothesis must be changed to allow
for a sex difference in the phenotype.
</p>
<p>Numerous special cases must be considered, as detailed in the following
table.
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>BC</b>
 </td><td style="text-align: left;"> </td><td style="text-align: left;"> <b>Sexes</b> </td><td style="text-align: center;"> <b>Null</b> </td><td style="text-align: center;"> <b>Alternative</b> </td><td style="text-align: center;"> <b>df</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> </td><td style="text-align: left;"> both sexes   </td><td style="text-align: center;"> sex         </td><td style="text-align: center;"> AA/AB/AY/BY        </td><td style="text-align: center;"> 2         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> </td><td style="text-align: left;"> all female   </td><td style="text-align: center;"> grand mean  </td><td style="text-align: center;"> AA/AB              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> </td><td style="text-align: left;"> all male     </td><td style="text-align: center;"> grand mean  </td><td style="text-align: center;"> AY/BY              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> </td><td style="text-align: left;">              </td><td style="text-align: center;">             </td><td style="text-align: center;">                    </td><td style="text-align: center;">           </td>
</tr>
<tr>
 <td style="text-align: left;">

<b>F2</b>
 </td><td style="text-align: left;"> <b>Direction</b> </td><td style="text-align: left;"> <b>Sexes</b></td><td style="text-align: center;"> <b>Null</b></td><td style="text-align: center;"> <b>Alternative</b> </td><td style="text-align: center;"> <b>df</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Both             </td><td style="text-align: left;"> both sexes  </td><td style="text-align: center;"> femaleF/femaleR/male </td><td style="text-align: center;"> AA/ABf/ABr/BB/AY/BY </td><td style="text-align: center;"> 3         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all female  </td><td style="text-align: center;"> pgm        </td><td style="text-align: center;"> AA/ABf/ABr/BB      </td><td style="text-align: center;"> 2         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all male    </td><td style="text-align: center;"> grand mean </td><td style="text-align: center;"> AY/BY              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Forward          </td><td style="text-align: left;"> both sexes  </td><td style="text-align: center;"> sex        </td><td style="text-align: center;"> AA/AB/AY/BY        </td><td style="text-align: center;"> 2         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all female  </td><td style="text-align: center;"> grand mean </td><td style="text-align: center;"> AA/AB              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all male    </td><td style="text-align: center;"> grand mean </td><td style="text-align: center;"> AY/BY              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Backward         </td><td style="text-align: left;"> both sexes  </td><td style="text-align: center;"> sex        </td><td style="text-align: center;"> AB/BB/AY/BY        </td><td style="text-align: center;"> 2         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all female  </td><td style="text-align: center;"> grand mean </td><td style="text-align: center;"> AB/BB              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">                  </td><td style="text-align: left;"> all male    </td><td style="text-align: center;"> grand mean </td><td style="text-align: center;"> AY/BY              </td><td style="text-align: center;"> 1         </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In the case that the number of degrees of freedom for the linkage test
for the X chromosome is different from that for autosomes, a separate
X-chromosome LOD threshold is recommended.  Autosome- and
X-chromosome-specific LOD thresholds may be estimated by permutation
tests with <code>scanone</code> by setting <code>n.perm</code>&gt;0 and using
<code>perm.Xsp=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Hao Wu</p>


<h3>References</h3>

<p>Boyartchuk,  V. L., Broman, K. W., Mosher, R. E., D'Orazio
S. E. F., Starnbach, M. N. and Dietrich, W. F. (2001) Multigenic
control of <em>Listeria monocytogenes</em> susceptibility in
mice. <em>Nature Genetics</em> <b>27</b>, 259&ndash;260.
</p>
<p>Broman,  K. W. (2003) Mapping quantitative trait loci in the case of a
spike in the phenotype distribution. <em>Genetics</em> <b>163</b>,
1169&ndash;1175.
</p>
<p>Broman, K. W., Sen, &#346;, Owens, S. E., Manichaikul, A.,
Southard-Smith, E. M. and Churchill G. A. (2006)  The X chromosome in
quantitative trait locus mapping.  <em>Genetics</em>, <b>174</b>, 2151&ndash;2158.
</p>
<p>Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for
quantitative trait mapping.  <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>
<p>Dempster, A. P., Laird, N. M. and Rubin, D. B. (1977) Maximum
likelihood from incomplete data via the EM algorithm.  <em>J. Roy.
Statist. Soc.</em> B, <b>39</b>, 1&ndash;38.
</p>
<p>Feenstra, B., Skovgaard, I. M. and Broman, K. W. (2006) Mapping
quantitative trait loci by an extension of the Haley-Knott regression
method using estimating equations. <em>Genetics</em>, <b>173</b>,
2111&ndash;2119.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Kruglyak, L. and Lander, E. S. (1995) A nonparametric approach for
mapping quantitative trait loci.  <em>Genetics</em> <b>139</b>,
1421&ndash;1428.
</p>
<p>Lander, E. S. and Botstein, D. (1989) Mapping Mendelian factors underlying
quantitative traits using RFLP linkage maps.  <em>Genetics</em>
<b>121</b>, 185&ndash;199.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>
<p>Soller, M., Brody, T. and Genizi, A. (1976) On the power of experimental
designs for the detection of linkage between marker loci and
quantitative loci in crosses between inbred lines.
<em>Theor. Appl. Genet.</em> <b>47</b>, 35&ndash;39.
</p>
<p>Xu, S., and Atchley, W.R. (1996) Mapping quantitative trait loci for
complex binary diseases using line crosses. <em>Genetics</em>
<b>143</b>, 1417&ndash;1424.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, <code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+calc.genoprob">calc.genoprob</a></code>, <code><a href="#topic+sim.geno">sim.geno</a></code>,
<code><a href="#topic+max.scanone">max.scanone</a></code>,
<code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>,
<code><a href="#topic+-.scanone">-.scanone</a></code>, <code><a href="#topic++2B.scanone">+.scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>###################
# Normal Model
###################
data(hyper)

# Genotype probabilities for EM and H-K
## Not run: hyper &lt;- calc.genoprob(hyper, step=2.5)

out.em &lt;- scanone(hyper, method="em")
out.hk &lt;- scanone(hyper, method="hk")

# Summarize results: peaks above 3
summary(out.em, thr=3)
summary(out.hk, thr=3)

# An alternate method of summarizing:
#     patch them together and then summarize
out &lt;- c(out.em, out.hk)
summary(out, thr=3, format="allpeaks")

# Plot the results
plot(out.hk, out.em)
plot(out.hk, out.em, chr=c(1,4), lty=1, col=c("blue","black"))

# Imputation; first need to run sim.geno
# Do just chromosomes 1 and 4, to save time
## Not run: hyper.c1n4 &lt;- sim.geno(subset(hyper, chr=c(1,4)),
                       step=2.5, n.draws=8)

## End(Not run)
out.imp &lt;- scanone(hyper.c1n4, method="imp")
summary(out.imp, thr=3)

# Plot all three results
plot(out.imp, out.hk, out.em, chr=c(1,4), lty=1,
     col=c("red","blue","black"))

# extended Haley-Knott
out.ehk &lt;- scanone(hyper, method="ehk")
plot(out.hk, out.em, out.ehk, chr=c(1,4))

# Permutation tests
## Not run: permo &lt;- scanone(hyper, method="hk", n.perm=1000)


# Threshold from the permutation test
summary(permo, alpha=c(0.05, 0.10))

# Results above the 0.05 threshold
summary(out.hk, perms=permo, alpha=0.05)


####################
# scan with square-root of phenotype
#   (Note that pheno.col can be a vector of phenotype values)
####################
out.sqrt &lt;- scanone(hyper, pheno.col=sqrt(pull.pheno(hyper, 1)))
plot(out.em - out.sqrt, ylim=c(-0.1,0.1),
     ylab="Difference in LOD")
abline(h=0, lty=2, col="gray")


####################
# Stratified permutations
####################
extremes &lt;- (nmissing(hyper)/totmar(hyper) &lt; 0.5)

## Not run: operm.strat &lt;- scanone(hyper, method="hk", n.perm=1000,
                       perm.strata=extremes)

## End(Not run)

summary(operm.strat)



####################
# X-specific permutations
####################
data(fake.f2)

## Not run: fake.f2 &lt;- calc.genoprob(fake.f2, step=2.5)


# genome scan
out &lt;- scanone(fake.f2, method="hk")

# X-chr-specific permutations
## Not run: operm &lt;- scanone(fake.f2, method="hk", n.perm=1000, perm.Xsp=TRUE)


# thresholds
summary(operm)

# scanone summary with p-values
summary(out, perms=operm, alpha=0.05, pvalues=TRUE)



###################
# Non-parametric
###################
out.np &lt;- scanone(hyper, model="np")
summary(out.np, thr=3)

# Plot with previous results
plot(out.np, chr=c(1,4), lty=1, col="green")
plot(out.imp, out.hk, out.em, chr=c(1,4), lty=1,
     col=c("red","blue","black"), add=TRUE)

###################
# Two-part Model
###################
data(listeria)

## Not run: listeria &lt;- calc.genoprob(listeria,step=2.5)

out.2p &lt;- scanone(listeria, model="2part", upper=TRUE)
summary(out.2p, thr=c(5,3,3), format="allpeaks")

# Plot all three LOD scores together
plot(out.2p, out.2p, out.2p, lodcolumn=c(2,3,1), lty=1, chr=c(1,5,13),
     col=c("red","blue","black"))

# Permutation test
## Not run: permo &lt;- scanone(listeria, model="2part", upper=TRUE,
                 n.perm=1000)

## End(Not run)

# Thresholds
summary(permo)

###################
# Binary model
###################
binphe &lt;- as.numeric(pull.pheno(listeria,1)==264)
out.bin &lt;- scanone(listeria, pheno.col=binphe, model="binary")
summary(out.bin, thr=3)

# Plot LOD for binary model with LOD(p) from 2-part model
plot(out.bin, out.2p, lodcolumn=c(1,2), lty=1, col=c("black", "red"),
     chr=c(1,5,13))

# Permutation test
## Not run: permo &lt;- scanone(listeria, pheno.col=binphe, model="binary",
                 n.perm=1000)

## End(Not run)

# Thresholds
summary(permo)

###################
# Covariates
###################
data(fake.bc)

## Not run: fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)


# genome scans without covariates
out.nocovar &lt;- scanone(fake.bc)

# genome scans with covariates
ac &lt;- pull.pheno(fake.bc, c("sex","age"))
ic &lt;- pull.pheno(fake.bc, "sex")

out.covar &lt;- scanone(fake.bc, pheno.col=1,
                     addcovar=ac, intcovar=ic)
summary(out.nocovar, thr=3)
summary(out.covar, thr=3)
plot(out.covar, out.nocovar, chr=c(2,5,10))
</code></pre>

<hr>
<h2 id='scanoneboot'>Bootstrap to get interval estimate of QTL location</h2><span id='topic+scanoneboot'></span>

<h3>Description</h3>

<p>Nonparametric bootstrap to get an estimated confidence interval for
the location of a QTL, in the context of a single-QTL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanoneboot(cross, chr, pheno.col=1, model=c("normal","binary","2part","np"),
            method=c("em","imp","hk","ehk","mr","mr-imp","mr-argmax"),
            addcovar=NULL, intcovar=NULL, weights=NULL,
            use=c("all.obs", "complete.obs"), upper=FALSE,
            ties.random=FALSE, start=NULL, maxit=4000,
            tol=1e-4, n.boot=1000, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanoneboot_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_chr">chr</code></td>
<td>
<p>The chromosome to investigate.  Only one chromosome is
allowed. (This should be a character string referring to the
chromosomes by name.)</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give a character string matching
a phenotype name.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_model">model</code></td>
<td>
<p>The phenotypic model: the usual normal model, a model for
binary traits, a two-part model or non-parametric analysis</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_method">method</code></td>
<td>
<p>Indicates whether to use the EM algorithm,
imputation, Haley-Knott regression, the extended Haley-Knott method,
or marker regression.  Not all methods are available for all models.
Marker regression is performed either by dropping individuals with
missing genotypes (<code>"mr"</code>), or by first filling in missing data
using a single imputation (<code>"mr-imp"</code>) or by the Viterbi
algorithm (<code>"mr-argmax"</code>).</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_addcovar">addcovar</code></td>
<td>
<p>Additive covariates;
allowed only for the normal and binary models.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_intcovar">intcovar</code></td>
<td>
<p>Interactive covariates (interact with QTL genotype);
allowed only for the normal and binary models.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_weights">weights</code></td>
<td>
<p>Optional weights of individuals.  Should be either NULL
or a vector of length n.ind containing positive weights.  Used only
in the case <code>model="normal"</code>.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_use">use</code></td>
<td>
<p>In the case that multiple phenotypes are selected to be
scanned, this argument indicates whether to use all individuals,
including those missing some phenotypes, or just those individuals
that have data on all selected phenotypes.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_upper">upper</code></td>
<td>
<p>Used only for the two-part model; if true, the
&quot;undefined&quot; phenotype is the maximum observed phenotype; otherwise,
it is the smallest observed phenotype.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_ties.random">ties.random</code></td>
<td>
<p>Used only for the non-parametric &quot;model&quot;; if TRUE,
ties in the phenotypes are ranked at random.  If FALSE, average ranks
are used and a corrected LOD score is calculated.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_start">start</code></td>
<td>
<p>Used only for the EM algorithm with the normal model and
no covariates.  If <code>NULL</code>, use the usual starting values; if
length 1, use random initial weights for EM; otherwise, this should
be a vector of length n+1 (where n is the number of possible
genotypes for the cross), giving the initial values for EM.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for methods <code>"em"</code> and
<code>"ehk"</code>.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for determining convergence for methods
<code>"em"</code> and <code>"ehk"</code>.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="scanoneboot_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of the
bootstrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend against the use of the bootstrap to derive a confidence
interval for the location of a QTL; see Manichaikul et al. (2006).
Use <code><a href="#topic+lodint">lodint</a></code> or <code><a href="#topic+bayesint">bayesint</a></code> instead.
</p>
<p>The bulk of the arguments are the same as for the
<code><a href="#topic+scanone">scanone</a></code> function.  A single chromosome should be
indicated with the <code>chr</code> argument; otherwise, we focus on the
first chromosome in the input <code>cross</code> object.
</p>
<p>A single-dimensional scan on the relevant chromosome is performed.  We
further perform a nonparametric bootstrap (sampling individuals <em>with
replacement</em> from the available data, to create a new data set with
the same size as the input cross; some individuals with be duplicated
and some omitted).  The same scan is performed with the resampled data;
for each bootstrap replicate, we store only the location with maximum
LOD score.
</p>
<p>Use <code><a href="#topic+summary.scanoneboot">summary.scanoneboot</a></code> to obtain the desired
confidence interval.
</p>


<h3>Value</h3>

<p>A vector of length <code>n.boot</code>, giving the estimated QTL locations
in the bootstrap replicates.  The results for the original data are
included as an attribute, <code>"results"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Manichaikul, A., Dupuis, J., Sen, &#346; and Broman, K. W. (2006) Poor
performance of bootstrap confidence intervals for the location of a
quantitative trait locus. <em>Genetics</em> <b>174</b>, 481&ndash;489.
</p>
<p>Visscher, P. M., Thompson, R. and Haley, C. S. (1996) Confidence
intervals in QTL mapping by bootstrap.  <em>Genetics</em> <b>143</b>,
1013&ndash;1020.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+summary.scanoneboot">summary.scanoneboot</a></code>,
<code><a href="#topic+plot.scanoneboot">plot.scanoneboot</a></code>,
<code><a href="#topic+lodint">lodint</a></code>, <code><a href="#topic+bayesint">bayesint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2, step=1, err=0.001)
## Not run: bootoutput &lt;- scanoneboot(fake.f2, chr=13, method="hk")


plot(bootoutput)
summary(bootoutput)
</code></pre>

<hr>
<h2 id='scanonevar'>Genome scan for QTL affecting mean and/or variance</h2><span id='topic+scanonevar'></span>

<h3>Description</h3>

<p>Genome scan with a single QTL model for loci that can
affect the variance as well as the mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanonevar(cross, pheno.col=1, mean_covar=NULL, var_covar=NULL,
           maxit=25, tol=1e-6, quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanonevar_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This must be a single value (integer index or
phenotype name) or a numeric vector of
phenotype values, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the mean.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_var_covar">var_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the variances.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations in the algorithm to fit the
model at a given position.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence.</p>
</td></tr>
<tr><td><code id="scanonevar_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print some information about the course
of the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (with class <code>"scanone"</code>, in the form output by
<code><a href="#topic+scanone">scanone</a></code>), with four columns: chromosome, position, the -log P-value for
the mean effect, and the -log P-value for the effect on the variance.
The result is given class <code>"scanone"</code>
</p>


<h3>Author(s)</h3>

<p>Lars Ronnegard and Karl Broman</p>


<h3>References</h3>

<p>Ronnegard, L. and Valdar W. (2011) Detecting major genetic loci
controlling phenotypic variability in experimental crosses. Genetics
188:435-447
</p>
<p>Ronnegard, L. and Valdar W. (2012) Recent developments in statistical
methods for detecting genetic loci affecting phenotypic
variability. BMC Genetics 13:63
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)
out &lt;- scanonevar(fake.bc)
color &lt;- c("slateblue", "violetred")
plot(out, lod=1:2, col=color, bandcol="gray80")
legend("topright", lwd=2, c("mean", "variance"), col=color)

# use format="allpeaks" to get summary for each of mean and variance
#  also consider format="tabByCol" or format="tabByChr"
summary(out, format="allpeaks")

# with sex and age as covariates
covar &lt;- fake.bc$pheno[,c("sex", "age")]
out.cov &lt;- scanonevar(fake.bc, mean_covar=covar, var_covar=covar)
</code></pre>

<hr>
<h2 id='scanonevar.meanperm'>Permutation test for mean effect in scanonevar</h2><span id='topic+scanonevar.meanperm'></span>

<h3>Description</h3>

<p>Executes permutations of the genotypes in the mean-effect part of scanonevar</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanonevar.meanperm(cross, pheno.col=1, mean_covar=NULL, var_covar=NULL,
           maxit=25, tol=1e-6, n.mean.perm = 2, seed = 27517, quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanonevar.meanperm_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This must be a single value (integer index or
phenotype name) or a numeric vector of
phenotype values, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the mean.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_var_covar">var_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the variances.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations in the algorithm to fit the
model at a given position.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_n.mean.perm">n.mean.perm</code></td>
<td>
<p>Numeric vector of length one indicates the number of permutations to execute.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_seed">seed</code></td>
<td>
<p>Numeric vector of length one indicates the random seed to start the permutations.</p>
</td></tr>
<tr><td><code id="scanonevar.meanperm_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print some information about the course
of the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>n.mean.perm</code> of the maximum negative log10 p-value that resulted from each permutation.
</p>

<hr>
<h2 id='scanonevar.varperm'>Permutation test for variance effect in scanonevar</h2><span id='topic+scanonevar.varperm'></span>

<h3>Description</h3>

<p>Executes permutations of the genotypes in the variance-effect part of scanonevar</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanonevar.varperm(cross, pheno.col=1, mean_covar=NULL, var_covar=NULL,
                   maxit=25, tol=1e-6, n.var.perm = 2, seed = 27517, quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanonevar.varperm_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This must be a single value (integer index or
phenotype name) or a numeric vector of
phenotype values, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the mean.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_var_covar">var_covar</code></td>
<td>
<p>Numeric matrix with covariates affecting the variances.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations in the algorithm to fit the
model at a given position.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_n.var.perm">n.var.perm</code></td>
<td>
<p>Numeric vector of length one indicates the number of permutations to execute.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_seed">seed</code></td>
<td>
<p>Numeric vector of length one indicates the random seed to start the permutations.</p>
</td></tr>
<tr><td><code id="scanonevar.varperm_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print some information about the course
of the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>n.var.perm</code> of the maximum negative log10 p-value that resulted from each permutation.
</p>

<hr>
<h2 id='scanPhyloQTL'>Single-QTL genome scan to map QTL to a phylogenetic tree</h2><span id='topic+scanPhyloQTL'></span>

<h3>Description</h3>

<p>Jointly consider multiple intercrosses with a single diallelic QTL
model, considering all possible partitions of the strains into the two
QTL allele groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanPhyloQTL(crosses, partitions, chr, pheno.col=1,
             model=c("normal", "binary"), method=c("em", "imp", "hk"),
             addcovar, maxit=4000, tol=0.0001, useAllCrosses=TRUE,
             verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanPhyloQTL_+3A_crosses">crosses</code></td>
<td>
<p>A list with each component being an intercross, as an object of class
<code>cross</code> (see <code><a href="#topic+read.cross">read.cross</a></code> for details).  The names
(of the form &quot;AB&quot;) indicate the strains in the cross.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_partitions">partitions</code></td>
<td>
<p>A vector of character strings of the form &quot;AB|CD&quot; or
&quot;A|BCD&quot; indicating the set of paritions of the strains into two
allele groups.  If missing, all partitions should be considered.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes for which LOD
scores should be calculated.  This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This can be a vector of integers; for methods
<code>"hk"</code> and <code>"imp"</code> this can be considerably faster than doing
them one at a time.  One may also give a character strings matching
the phenotype names.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual normal model or a model for
binary traits</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_method">method</code></td>
<td>
<p>Indicates whether to use the EM algorithm,
imputation, or Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_addcovar">addcovar</code></td>
<td>
<p>Optional set of additive covariates to include in the
analysis, as a list with the same length as <code>crosses</code>.  They
must be numeric vectors or matrices, as for <code><a href="#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for method <code>"em"</code>.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for determining convergence for method
<code>"em"</code>.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_useallcrosses">useAllCrosses</code></td>
<td>
<p>If TRUE, use all crosses in the analysis of all
partitions, with crosses not segregating the QTL included in the
estimation of the residual variance.</p>
</td></tr>
<tr><td><code id="scanPhyloQTL_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information about progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim is to jointly consider multiple intercrosses to not just map
QTL but to also, under the assumption of a single diallelic QTL,
identify the set of strains with each QTL allele.
</p>
<p>For each partition (of the strains into two groups) that is under
consideration, we pull out the set of crosses that are segregating the
QTL, re-code the alleles, and combine the crosses into one large cross.
Crosses not segregating the QTL are also used, though with no QTL
effects.
</p>
<p>Additive covariate indicators for the crosses are included in the
analysis, to allow for the possibility that there are overall shifts
in the phenotypes between crosses.
</p>


<h3>Value</h3>

<p>A data frame, as for the output of <code><a href="#topic+scanone">scanone</a></code>, though with
LOD score columns for each partition that is considered.  The result
is given class <code>"scanPhyloQTL"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.scanPhyloQTL">plot.scanPhyloQTL</a></code>,
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>, <code><a href="#topic+max.scanPhyloQTL">max.scanPhyloQTL</a></code>,
<code><a href="#topic+inferredpartitions">inferredpartitions</a></code>,
<code><a href="#topic+simPhyloQTL">simPhyloQTL</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]


# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
## Not run: x &lt;- lapply(x, calc.genoprob, step=2)


# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# maximum peak
max(out, format="lod")

# approximate posterior probabilities at peak
max(out, format="postprob")

# all peaks above a threshold for LOD(best) - LOD(2nd best)
summary(out, threshold=1, format="lod")

# all peaks above a threshold for LOD(best), showing approx post'r prob
summary(out, format="postprob", threshold=3)

# plot results
plot(out)
</code></pre>

<hr>
<h2 id='scanqtl'>General QTL scan</h2><span id='topic+scanqtl'></span>

<h3>Description</h3>

<p>Performs a multiple QTL scan for specified chromosomes and positions
or intervals, with the possible inclusion of QTL-QTL interactions and/or
covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanqtl(cross, pheno.col=1, chr, pos, covar=NULL, formula,
        method=c("imp","hk"), model=c("normal", "binary"),
        incl.markers=FALSE, verbose=TRUE, tol=1e-4, maxit=1000,
        forceXcovar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix to be
used as the phenotype.  One may also give a character string matching
a phenotype name.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_chr">chr</code></td>
<td>
<p>Vector indicating the chromosome for each QTL. (These should
be character strings referring to the chromosomes by name.)</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_pos">pos</code></td>
<td>
<p>List indicating the positions or intervals on the chromosome
to be scanned.  Each element should be either a single number (for a
specific position) or a pair of numbers (for an interval).</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_covar">covar</code></td>
<td>
<p>A matrix or data.frame of covariates.  These must be
strictly numeric.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>
indicating the model to be fitted.  (It can also be the character
string representation of a formula.)  QTLs are indicated as <code>Q1</code>,
<code>Q2</code>, etc.  Covariates are indicated by their names in <code>covar</code>.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.  If <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> or
<code><a href="#topic+sim.geno">sim.geno</a></code> were run with
<code>stepwidth="variable"</code> or <code>stepwidth="max"</code>, we force <code>incl.markers=TRUE</code>.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give feedback about progress.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="scanqtl_+3A_forcexcovar">forceXcovar</code></td>
<td>
<p>If TRUE, force inclusion of X-chr-related covariates
(like sex and cross direction).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is used to specified the model to be fit. In the
formula, use <code>Q1</code>, <code>Q2</code>, etc., or <code>q1</code>,
<code>q2</code>, etc., to represent the QTLs, and the column names in the
covariate data frame to represent the covariates.
</p>
<p>We enforce a hierarchical structure on the model formula: if a QTL or
covariate is in involved in an interaction, its main effect are also
be included.
</p>
<p>Only the interaction terms need to be specifed in the formula. The
main effects of all input QTLs (as specified by chr and pos) and
covariates (as specifed by covar) will be included by default. For
example, if the formula is <code>y~Q1*Q2*Sex</code>, and there are three
elements in input <code>chr</code> and <code>pos</code> and Sex is one of the
column names for
input covariates, the formula used in genome scan will be
<code>y ~ Q1 + Q2 + Q3 + Sex + Q1:Q2 + Q1:Sex + Q2:Sex + Q1:Q2:Sex</code>.
</p>
<p>The input <code>pos</code> is a list or vector to specify the position/range
of the input chromosomes to be scanned. If it is a vector, it gives the
precise positions of the QTL on the chromosomes. If it is a list, it will
contain either the precise positions or a range on the chromosomes. For
example, consider the case that the input <code>chr = c(1, 6,
    13)</code>. If <code>pos = c(9.8, 34.0, 18.6)</code>,
it means to fit a model with QTL on chromosome 1 at 9.8cM, chromosome
6 at 34cM and  chromosome 13 at 18.6cM.
If <code>pos = list(c(5,15), c(30,36), 18)</code>, it
means to scan chromosome 1 from 5cM to 15cM, chromosome 6 from 30cM to
36cM, fix the QTL on chromosome 13 at 18cM.
</p>


<h3>Value</h3>

<p>An object of class <code>scanqtl</code>. It is a multi-dimensional
array of LOD scores, with the number of dimension equal to the number
of QTLs specifed.</p>


<h3>Author(s)</h3>

<p>Hao Wu</p>


<h3>References</h3>

<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+refineqtl">refineqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs
qc &lt;- c(1, 8, 13)
fake.f2 &lt;- subset(fake.f2, chr=qc)

# imputate genotypes

fake.f2 &lt;- calc.genoprob(fake.f2, step=5, err=0.001)

# 2-dimensional genome scan with additive 3-QTL model
pos &lt;- list(c(15,35), c(45,65), 28)
result &lt;- scanqtl(fake.f2, pheno.col=1, chr=qc, pos=pos,
                  formula=y~Q1+Q2+Q3, method="hk")

# image of the results
# chr locations
chr1 &lt;- as.numeric(matrix(unlist(strsplit(colnames(result),"@")),
                   ncol=2,byrow=TRUE)[,2])
chr8 &lt;- as.numeric(matrix(unlist(strsplit(rownames(result),"@")),
                   ncol=2,byrow=TRUE)[,2])
# image plot
image(chr1, chr8, t(result), las=1, col=rev(rainbow(256,start=0,end=2/3)))

# do the same, allowing the QTLs on chr 1 and 13 to interact
result2 &lt;- scanqtl(fake.f2, pheno.col=1, chr=qc, pos=pos,
                   formula=y~Q1+Q2+Q3+Q1:Q3, method="hk")
# image plot
image(chr1, chr8, t(result2), las=1, col=rev(rainbow(256,start=0,end=2/3)))
</code></pre>

<hr>
<h2 id='scantwo'>Two-dimensional genome scan with a two-QTL model</h2><span id='topic+scantwo'></span>

<h3>Description</h3>

<p>Perform a two-dimensional genome scan with a two-QTL model, with
possible allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scantwo(cross, chr, pheno.col=1, model=c("normal","binary"),
        method=c("em","imp","hk","mr","mr-imp","mr-argmax"),
        addcovar=NULL, intcovar=NULL, weights=NULL,
        use=c("all.obs", "complete.obs"),
        incl.markers=FALSE, clean.output=FALSE,
        clean.nmar=1, clean.distance=0,
        maxit=4000, tol=1e-4,
        verbose=TRUE, n.perm, perm.Xsp=FALSE, perm.strata=NULL,
        assumeCondIndep=FALSE, batchsize=250, n.cluster=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scantwo_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes for which LOD
scores should be calculated.  This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This can be a vector of integers; for methods
<code>"hk"</code> and <code>"imp"</code> this can be considerably faster than doing
them one at a time.  One may also give character strings matching
the phenotype names.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual normal model or a model for
binary traits.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_method">method</code></td>
<td>
<p>Indicates whether to use the
the EM algorithm, imputation, Haley-Knott regression, or marker
regression.  Marker regression is performed either by dropping
individuals with missing genotypes (<code>"mr"</code>), or by first filling
in missing data using a single imputation (<code>"mr-imp"</code>) or by the
Viterbi algorithm (<code>"mr-argmax"</code>).</p>
</td></tr>
<tr><td><code id="scantwo_+3A_addcovar">addcovar</code></td>
<td>
<p>Additive covariates.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_intcovar">intcovar</code></td>
<td>
<p>Interactive covariates (interact with QTL genotype).</p>
</td></tr>
<tr><td><code id="scantwo_+3A_weights">weights</code></td>
<td>
<p>Optional weights of individuals.  Should be either NULL
or a vector of length n.ind containing positive weights. Used only
in the case <code>model="normal"</code>.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_use">use</code></td>
<td>
<p>In the case that multiple phenotypes are selected to be
scanned, this argument indicates whether to use all individuals,
including those missing some phenotypes, or just those individuals
that have data on all selected phenotypes.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.  If <code><a href="#topic+calc.genoprob">calc.genoprob</a></code> or
<code><a href="#topic+sim.geno">sim.geno</a></code> were run with
<code>stepwidth="variable"</code> or <code>stepwidth="max"</code>, we force <code>incl.markers=TRUE</code>.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_clean.output">clean.output</code></td>
<td>
<p>If TRUE, clean the output with
<code><a href="#topic+clean.scantwo">clean.scantwo</a></code>, replacing LOD scores for pairs of
positions that are not well separated with 0.  In permutations, this
will be done for each permutation replicate.  This can be important
for the case of <code>method="em"</code>, as there can be difficulty with
algorithm convergence in these regions.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_clean.nmar">clean.nmar</code></td>
<td>
<p>If <code>clean.output=TRUE</code>, this is the number of
markers that must separate two positions.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_clean.distance">clean.distance</code></td>
<td>
<p>If <code>clean.output=TRUE</code>, this is the cM distance
that must separate two positions.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations; used
only with method <code>"em"</code>.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for determining convergence; used only with
method <code>"em"</code>.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of
calculations.  For method <code>"em"</code>, if <code>verbose</code> is an integer
above 1, further details on the progress of the algorithm will be
displayed.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_n.perm">n.perm</code></td>
<td>
<p>If specified, a permutation test is performed rather than
an analysis of the observed data.  This argument defines the number
of permutation replicates.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_perm.xsp">perm.Xsp</code></td>
<td>
<p>If <code>n.perm</code> &gt; 0, so that a permutation test will
be performed, this indicates whether separate permutations should be
performed for the autosomes and the X chromosome, in order to get an
X-chromosome-specific LOD threshold.  In this case, additional
permutations are performed for the X chromosome.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_perm.strata">perm.strata</code></td>
<td>
<p>If <code>n.perm</code> &gt; 0, this may be used to perform a
stratified permutation test.  This should be a vector with the same
number of individuals as in the cross data.  Unique values indicate
the individual strata, and permutations will be performed within the
strata.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_assumecondindep">assumeCondIndep</code></td>
<td>
<p>If TRUE, assume conditional independence of QTL
genotypes given marker genotypes.  This is an approximation, but it
may speed things up.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_batchsize">batchsize</code></td>
<td>
<p>The number of phenotypes (or permutations) to be run
as a batch; used only for methods <code>"hk"</code> and <code>"imp"</code>.</p>
</td></tr>
<tr><td><code id="scantwo_+3A_n.cluster">n.cluster</code></td>
<td>
<p>If the package <code>snow</code> is available and
<code>n.perm</code> &gt; 0, permutations are run in parallel using this number
of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard interval mapping (<code>method="em"</code>) and Haley-Knott
regression (<code>method="hk"</code>) require that multipoint genotype probabilities are
first calculated using <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>.  The
imputation method uses the results of <code><a href="#topic+sim.geno">sim.geno</a></code>.
</p>
<p>The method <code>"em"</code> is standard interval mapping by the EM algorithm
(Dempster et al. 1977; Lander and Botstein 1989).  Marker regression
(<code>method="mr"</code>) is simply linear regression of phenotypes on
marker genotypes  (individuals with missing genotypes are
discarded). Haley-Knott regression (<code>method="hk"</code>) uses the
regression of phenotypes on multipoint genotype probabilities.  The
imputation method (<code>method="imp"</code>) uses the pseudomarker
algorithm described by Sen and Churchill (2001).
</p>
<p>Individuals with missing phenotypes are dropped.
</p>
<p>In the presence of covariates, the full model is
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \beta_{q_1} + \beta_{q_2} + \beta_{q_1 \times q_2} +
    A \gamma + Z \delta_{q_1} + Z \delta_{q_2} + Z \delta_{q_1 \times q_2} +
    \epsilon</code>
</p>

<p>where <code class="reqn">q_1</code> and <code class="reqn">q_2</code> are the unknown QTL genotypes at two
locations, <em>A</em> is a matrix of covariates, and <em>Z</em> is a
matrix of covariates that interact with QTL genotypes.  The columns of
<em>Z</em> are forced to be contained in the matrix <em>A</em>.
</p>
<p>The above full model is compared to the additive QTL model,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \beta_{q_1} + \beta_{q_2} + A \gamma + Z \delta_{q_1} + Z
    \delta_{q_2} + \epsilon</code>
</p>

<p>and also to the null model, with no QTL,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + A \gamma + \epsilon</code>
</p>

<p>In the case that <code>n.perm</code> is specified, the R function
<code>scantwo</code> is called repeatedly.
</p>
<p>For <code>model="binary"</code>, a logistic regression model is used.
</p>


<h3>Value</h3>

<p>If <code>n.perm</code> is missing, the function returns a list with class
<code>"scantwo"</code> and containing three components.  The first component
is a matrix of dimension [tot.pos x tot.pos]; the upper triangle
contains the LOD scores for the additive model, and the lower triangle
contains the LOD scores for the full model.  The diagonal contains the
results of <code><a href="#topic+scanone">scanone</a></code>. The second component of the
output is a data.frame indicating the locations at which the two-QTL
LOD scores were calculated.  The first column is the chromosome
identifier, the second column is the position in cM, the third column
is a 1/0 indicator for ease in later pulling out only the equally
spaced positions, and the fourth column indicates whether the position
is on the X chromosome or not.  The final component is a version of
the results of <code><a href="#topic+scanone">scanone</a></code> including sex and/or cross
direction as additive covariates, which is needed for a proper
calculation of conditional LOD scores.
</p>
<p>If <code>n.perm</code> is specified, the function returns a list with six
different LOD scores from each of the permutation replicates.
First, the maximum LOD score for the full model (two QTLs plus an
interaction).  Second, for each pair of
chromosomes, we take the difference between the full LOD and the
maximum single-QTL LOD for those two chromosomes, and then maximize
this across chromosome pairs.  Third, for each pair of chromosomes we
take the difference between the maximum full LOD and the maximum
additive LOD, and then maximize this across chromosome pairs.  Fourth,
the maximum LOD score for the additive QTL model.  Fifth, for each
pair of chromosomes, we take the difference between the additive LOD
and the maximum single-QTL LOD for those two chromosomes, and then
maximize this across chromosome pairs.  Finally, the maximum
single-QTL LOD score (that is, from a single-QTL scan).  The latter is
not used in <code><a href="#topic+summary.scantwo">summary.scantwo</a></code>, but does get
calculated at each permutation, so we include it for the sake of
completeness.
</p>
<p>If <code>n.perm</code> is specified and <code>perm.Xsp=TRUE</code>, the result is
a list with the permutation results for the regions A:A, A:X, and X:X,
each of which is a list with the six different LOD scores. Independent
permutations are performed in each region, <code>n.perm</code> is the number
of permutations for the A:A region; additional permutations are are
used for the A:X and X:X parts, as estimates of quantiles farther out
into the tails are needed.
</p>


<h3>X chromosome</h3>

<p>The X chromosome must be treated specially in QTL mapping.
</p>
<p>As in <code><a href="#topic+scanone">scanone</a></code>, if both males and females are
included, male hemizygotes are allowed to be different from female
homozygotes, and the null hypothesis must be changed in order to ensure
that sex- or pgm-differences in the phenotype do not results in spurious
linkage to the X chromosome.  (See the help file for
<code><a href="#topic+scanone">scanone</a></code>.)
</p>
<p>If <code>n.perm</code> is specified and <code>perm.Xsp=TRUE</code>,
X-chromosome-specific permutations are performed, to obtain separate
thresholds for the regions A:A, A:X, and X:X.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Hao Wu</p>


<h3>References</h3>

<p>Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for
quantitative trait mapping.  <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>
<p>Dempster, A. P., Laird, N. M. and Rubin, D. B. (1977) Maximum
likelihood from incomplete data via the EM algorithm.  <em>J. Roy.
Statist. Soc.</em> B, <b>39</b>, 1&ndash;38.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Lander, E. S. and Botstein, D. (1989) Mapping Mendelian factors underlying
quantitative traits using RFLP linkage maps.  <em>Genetics</em>
<b>121</b>, 185&ndash;199.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>
<p>Soller, M., Brody, T. and Genizi, A. (1976) On the power of experimental
designs for the detection of linkage between marker loci and
quantitative loci in crosses between inbred lines.
<em>Theor. Appl. Genet.</em> <b>47</b>, 35&ndash;39.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.scantwo">plot.scantwo</a></code>, <code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+max.scantwo">max.scantwo</a></code>,
<code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code>,
<code><a href="#topic+c.scantwoperm">c.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
out.2dim &lt;- scantwo(fake.f2, method="hk")
plot(out.2dim)

# permutations

## Not run: permo.2dim &lt;- scantwo(fake.f2, method="hk", n.perm=1000)
summary(permo.2dim, alpha=0.05)

# summary with p-values
summary(out.2dim, perms=permo.2dim, pvalues=TRUE,
        alphas=c(0.05, 0.10, 0.10, 0.05, 0.10))

# covariates
data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=10)

ac &lt;- pull.pheno(fake.bc, c("sex","age"))
ic &lt;- pull.pheno(fake.bc, "sex")

out &lt;- scantwo(fake.bc, method="hk", pheno.col=1,
               addcovar=ac, intcovar=ic)
plot(out)
</code></pre>

<hr>
<h2 id='scantwopermhk'>Permutation test for 2d genome scan by Haley-Knott regression</h2><span id='topic+scantwopermhk'></span>

<h3>Description</h3>

<p>Perform a permutation test with a two-dimensional genome scan with a
two-QTL model, with possible allowance for additive covariates, by
Haley-Knott regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scantwopermhk(cross, chr, pheno.col=1,
              addcovar=NULL, weights=NULL, n.perm=1,
              batchsize=1000,
              perm.strata=NULL, perm.Xsp=NULL,
              verbose=FALSE, assumeCondIndep=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scantwopermhk_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes for which LOD
scores should be calculated.  This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  This should be a single value (numeric index
or character string for a phenotype name), but it may also be a
vector of numeric values with length equal to the number
of individuals in the cross, in which case it is taken to be a vector
of individuals' phenotypes.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_addcovar">addcovar</code></td>
<td>
<p>Additive covariates.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_weights">weights</code></td>
<td>
<p>Optional weights of individuals.  Should be either NULL
or a vector of length n.ind containing positive weights. Used only
in the case <code>model="normal"</code>.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_n.perm">n.perm</code></td>
<td>
<p>Number of permutation replicates.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_batchsize">batchsize</code></td>
<td>
<p>If <code>n.perm &gt; batchsize</code>, permutations will be
run in batches of no more than <code>batchsize</code> permutations.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_perm.strata">perm.strata</code></td>
<td>
<p>Used to perform a
stratified permutation test.  This should be a vector with the same
number of individuals as in the cross data.  Unique values indicate
the individual strata, and permutations will be performed within the
strata.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_perm.xsp">perm.Xsp</code></td>
<td>
<p>If TRUE, run separate permutations for A:A, A:X, and
X:X. In this case, <code>n.perm</code> refers to the number of permutations
for the A:A part; more permutations are used for the A:X and X:X parts,
as estimates of quantiles farther out into the tails are needed.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, display information about the progress of
calculations.</p>
</td></tr>
<tr><td><code id="scantwopermhk_+3A_assumecondindep">assumeCondIndep</code></td>
<td>
<p>If TRUE, assume conditional independence of QTL
genotypes given marker genotypes.  This is an approximation, but it
may speed things up.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a scaled-back version of the permutation test provided by
<code><a href="#topic+scantwo">scantwo</a></code>: only for a normal model with Haley-Knott
regression, and not allowing interactive covariates.
</p>
<p>This is an attempt to speed things up and attentuate the memory usage
problems in <code><a href="#topic+scantwo">scantwo</a></code>.
</p>
<p>In the case of <code>perm.Xsp=TRUE</code> (X-chr-specific thresholds), we
use a stratified permutation test, stratified by sex and
cross-direction.
</p>


<h3>Value</h3>

<p>A list with six
different LOD scores from each of the permutation replicates.
First, the maximum LOD score for the full model (two QTLs plus an
interaction).  Second, for each pair of
chromosomes, we take the difference between the full LOD and the
maximum single-QTL LOD for those two chromosomes, and then maximize
this across chromosome pairs.  Third, for each pair of chromosomes we
take the difference between the maximum full LOD and the maximum
additive LOD, and then maximize this across chromosome pairs.  Fourth,
the maximum LOD score for the additive QTL model.  Fifth, for each
pair of chromosomes, we take the difference between the additive LOD
and the maximum single-QTL LOD for those two chromosomes, and then
maximize this across chromosome pairs.  Finally, the maximum
single-QTL LOD score (that is, from a single-QTL scan).  The latter is
not used in <code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code>, but does get
calculated at each permutation, so we include it for the sake of
completeness.
</p>
<p>If <code>perm.Xsp=TRUE</code>, this is a list of lists, for the A:A, A:X,
and X:X sections, each being a list as described above.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Hao Wu</p>


<h3>References</h3>

<p>Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for
quantitative trait mapping.  <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+plot.scantwoperm">plot.scantwoperm</a></code>,
<code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code>,
<code><a href="#topic+c.scantwoperm">c.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
operm &lt;- scantwopermhk(fake.f2, n.perm=2)
summary(operm, alpha=0.05)
</code></pre>

<hr>
<h2 id='shiftmap'>Shift starting points in genetic maps</h2><span id='topic+shiftmap'></span>

<h3>Description</h3>

<p>Shift starting points in a genetic map to a set of defined positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiftmap(object, offset=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shiftmap_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code> (see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or <code>map</code> (see
<code><a href="#topic+sim.map">sim.map</a></code> for details).</p>
</td></tr>
<tr><td><code id="shiftmap_+3A_offset">offset</code></td>
<td>
<p>Defines the starting position
for each chromosome.  This should be a
single value (to be used for all chromosomes) or a vector with length
equal to the number of chromosomes, defining individual starting
positions for each chromosome.  For a sex-specific map (as in a 4-way
cross), we use the same offset for both the male and female maps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is a <code>map</code> object, a <code>map</code> object is returned; if
the input is a <code>cross</code> object, a <code>cross</code> object is returned.
In either case, the positions of markers are shifted so that the
starting positions are as in <code>offset</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+replace.map">replace.map</a></code>,
<code><a href="#topic+est.map">est.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
shiftedhyper &lt;- shiftmap(hyper, offset=0)
par(mfrow=c(1,2))
plotMap(hyper, shift=FALSE, alternate.chrid=TRUE)
plotMap(shiftedhyper, shift=FALSE, alternate.chrid=TRUE)
</code></pre>

<hr>
<h2 id='sim.cross'>Simulate a QTL experiment</h2><span id='topic+sim.cross'></span>

<h3>Description</h3>

<p>Simulates data for a QTL experiment using a model in which QTLs act additively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cross(map, model=NULL, n.ind=100,
         type=c("f2", "bc", "4way", "risib", "riself",
           "ri4sib", "ri4self", "ri8sib", "ri8self", "bcsft"),
          error.prob=0, missing.prob=0, partial.missing.prob=0,
          keep.qtlgeno=TRUE, keep.errorind=TRUE, m=0, p=0,
      map.function=c("haldane","kosambi","c-f","morgan"),
          founderGeno, random.cross=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cross_+3A_map">map</code></td>
<td>
<p>A list whose components are vectors containing the marker
locations on each of the chromosomes.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_model">model</code></td>
<td>
<p>A matrix where each row corresponds to a
different QTL, and gives the chromosome number, cM position and
effects of the QTL.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_n.ind">n.ind</code></td>
<td>
<p>Number of individuals to simulate.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_type">type</code></td>
<td>
<p>Indicates whether to simulate an intercross (<code>f2</code>),
a backcross (<code>bc</code>), a phase-known 4-way cross (<code>4way</code>),
or recombinant inbred lines (by selfing or by sib-mating, and with
the usual 2 founder strains or with 4 or 8 founder strains).</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_error.prob">error.prob</code></td>
<td>
<p>The genotyping error rate.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_missing.prob">missing.prob</code></td>
<td>
<p>The rate of missing genotypes.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_partial.missing.prob">partial.missing.prob</code></td>
<td>
<p>When simulating an intercross or 4-way
cross, this gives the rate at which markers will be incompletely
informative (i.e., dominant or recessive).</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_keep.qtlgeno">keep.qtlgeno</code></td>
<td>
<p>If TRUE, genotypes for the simulated QTLs will be
included in the output.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_keep.errorind">keep.errorind</code></td>
<td>
<p>If TRUE, and if <code>error.prob &gt; 0</code>, the
identity of genotyping errors will be included in the output.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_m">m</code></td>
<td>
<p>Interference parameter; a non-negative integer.  0 corresponds
to no interference.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_p">p</code></td>
<td>
<p>Probability that a chiasma comes from the no-interference
mechanism</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_foundergeno">founderGeno</code></td>
<td>
<p>For 4- or 8-way RIL, the genotype data of the
founder strains, as a list whose components are numeric matrices
(no. markers x no. founders), one for each chromosome.</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_random.cross">random.cross</code></td>
<td>
<p>For 4- or 8-way RIL, indicates whether the order of the
founder strains should be randomized, independently for each RIL, or
whether all RIL be derived from a common cross.  In the latter case,
for a 4-way RIL, the cross would be (AxB)x(CxD).</p>
</td></tr>
<tr><td><code id="sim.cross_+3A_...">...</code></td>
<td>
<p>For <code>type = "bcsft"</code>, additional arguments passed to <code>sim.cross.bcsft</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meiosis is assumed to follow the Stahl model for crossover
interference (see the references, below), of which the no interference
model and the chi-square model are special cases.  Chiasmata on the
four-strand bundle are a superposition of chiasmata from two different
mechanisms.  With probability <code>p</code>, they arise by a mechanism
exhibiting no interference; the remainder come from a chi-square model
with inteference parameter <code>m</code>.  Note that <code>m=0</code> corresponds
to no interference, and with <code>p=0</code>, one gets a pure chi-square
model.
</p>
<p>If a chromosomes has class <code>X</code>, it is assumed to be the X
chromosome, and is assumed to be segregating in the cross.  Thus, in
an intercross, it is segregating like a backcross chromosome.  In a
4-way cross, a second phenotype, <code>sex</code>, will be generated.
</p>
<p>QTLs are assumed to act additively, and the residual phenotypic
variation is assumed to be normally distributed with variance 1.
</p>
<p>For a backcross, the effect of a QTL is a single number corresponding
to the difference between the homozygote and the heterozygote.
</p>
<p>For an intercross, the effect of a QTL is a pair of numbers,
(<code class="reqn">a,d</code>), where <code class="reqn">a</code> is the additive effect (half the difference
between the homozygotes) and <code class="reqn">d</code> is the dominance deviation (the
difference between the heterozygote and the midpoint between the
homozygotes).
</p>
<p>For a four-way cross, the effect of a QTL is a set of three numbers,
(<code class="reqn">a,b,c</code>), where, in the case of one QTL, the mean phenotype,
conditional on the QTL genotyping being AC, BC, AD or BD, is  <code class="reqn">a</code>,
<code class="reqn">b</code>, <code class="reqn">c</code> or 0, respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code> for
details.
</p>
<p>If <code>keep.qtlgeno</code> is TRUE, the cross object will contain a
component <code>qtlgeno</code> which is a matrix containing the QTL
genotypes (with complete data and no errors), coded as in the genotype
data.
</p>
<p>If <code>keep.errorind</code> is TRUE and errors were simulated, each
component of <code>geno</code> will each contain a matrix <code>errors</code>,
with 1's indicating simulated genotyping errors.
</p>


<h3>Recombinant inbred lines</h3>

<p>In the simulation of recombinant inbred lines (RIL), we simulate a
single individual from each line, and no phenotypes are simulated (so the
argument <code>model</code> is ignored).
</p>
<p>The types <code>riself</code> and <code>risib</code> are the usual two-way RIL.
</p>
<p>The types <code>ri4self</code>, <code>ri4sib</code>, <code>ri8self</code>, and
<code>ri8sib</code> are RIL by selfing or sib-mating derived from four or
eight founding parental strains.
</p>
<p>For the 4- and 8-way RIL, one must include the genotypes of the
founding individuals; these may be simulated with
<code><a href="#topic+simFounderSnps">simFounderSnps</a></code>.  Also, the output cross will
contain a component <code>cross</code>, which is a matrix with rows
corresponding to RIL and columns corresponding to the founders,
indicating order of the founder strains in the crosses used to
generate the RIL.
</p>
<p>The coding of genotypes in 4- and 8-way RIL is rather complicated.  It
is a binary encoding of which founder strains' genotypes match the
RIL's genotype at a marker, and not that this is specific to the order
of the founders in the crosses used to generate the RIL.  For example,
if an RIL generated from 4 founders has the 1 allele at a SNP, and the
four founders have SNP alleles 0, 1, 0, 1, then the RIL allele matches
that of founders B and D.  If the RIL was derived by the cross (AxB)x(CxD),
then the RIL genotype would be encoded <code class="reqn">2^{2-1} + 2^{3-1} = 6</code>.
If the cross was derived by the cross (DxA)x(CxB), then the RIL
genotype would be encoded <code class="reqn">2^{1-1} + 2^{4-1} = 9</code>.
These get reorganized after calls to <code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+sim.geno">sim.geno</a></code>, or <code><a href="#topic+argmax.geno">argmax.geno</a></code>, and
this approach simplifies the hidden Markov model (HMM) code.
</p>
<p>For the 4- and 8-way RIL, genotyping errors are simulated only if the
founder genotypes are 0/1 SNPs.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Copenhaver, G. P., Housworth, E. A. and Stahl, F. W. (2002) Crossover
interference in arabidopsis.  <em>Genetics</em> <b>160</b>, 1631&ndash;1639.
</p>
<p>Foss, E., Lande, R., Stahl, F. W. and Steinberg, C. M. (1993) Chiasma
interference as a function of genetic distance. <em>Genetics</em>
<b>133</b>, 681&ndash;691.
</p>
<p>Zhao, H., Speed, T. P. and McPeek, M. S. (1995) Statistical analysis
of crossover interference using the chi-square model.  <em>Genetics</em>
<b>139</b>, 1045&ndash;1056.
</p>
<p>Broman, K. W. (2005) The genomes of recombinant inbred lines
<em>Genetics</em> <b>169</b>, 1133&ndash;1146.
</p>
<p>Teuscher, F. and Broman, K. W. (2007) Haplotype probabilities for
multiple-strain recombinant inbred lines.  <em>Genetics</em> <b>175</b>,
1267&ndash;1274.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.map">sim.map</a></code>, <code><a href="#topic+read.cross">read.cross</a></code>,
<code><a href="#topic+fake.f2">fake.f2</a></code>, <code><a href="#topic+fake.bc">fake.bc</a></code>
<code><a href="#topic+fake.4way">fake.4way</a></code>, <code><a href="#topic+simFounderSnps">simFounderSnps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a genetic map
map &lt;- sim.map()


### simulate 250 intercross individuals with 2 QTLs
fake &lt;- sim.cross(map, type="f2", n.ind=250,
                  model = rbind(c(1,45,1,1),c(5,20,0.5,-0.5)))


### simulate 100 backcross individuals with 3 QTL
# a 10-cM map model after the mouse
data(map10)

fakebc &lt;- sim.cross(map10, type="bc", n.ind=100,
                    model=rbind(c(1,45,1), c(5,20,1), c(5,50,1)))


### simulate 8-way RIL by sibling mating
# get lengths from the above 10-cM map
L &lt;- ceiling(sapply(map10, max))

# simulate a 1 cM map
themap &lt;- sim.map(L, n.mar=L+1, eq.spacing=TRUE)

# simulate founder genotypes
pg &lt;- simFounderSnps(themap, "8")

# simulate the 8-way RIL by sib mating (256 lines)
ril &lt;- sim.cross(themap, n.ind=256, type="ri8sib", founderGeno=pg)
</code></pre>

<hr>
<h2 id='sim.geno'>Simulate genotypes given observed marker data</h2><span id='topic+sim.geno'></span>

<h3>Description</h3>

<p>Uses the hidden Markov model technology to simulate from the joint
distribution Pr(g | O) where g is the underlying genotype vector and O
is the observed multipoint marker data, with possible allowance for
genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.geno(cross, n.draws=16, step=0, off.end=0, error.prob=0.0001,
         map.function=c("haldane","kosambi","c-f","morgan"),
         stepwidth=c("fixed", "variable", "max"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.geno_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_n.draws">n.draws</code></td>
<td>
<p>Number of simulation replicates to perform.</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which the
simulated genotypes will be drawn, though for <code>step=0</code>,
genotypes are drawn only at the marker locations.</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_off.end">off.end</code></td>
<td>
<p>Distance (in cM) past the terminal markers on each
chromosome to which the genotype simulations will be carried.</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
<tr><td><code id="sim.geno_+3A_stepwidth">stepwidth</code></td>
<td>
<p>Indicates whether the intermediate points should with
fixed or variable step sizes.  We recommend using
<code>"fixed"</code>; <code>"variable"</code> was included for the qtlbim
package (<a href="https://cran.r-project.org/src/contrib/Archive/qtlbim/">https://cran.r-project.org/src/contrib/Archive/qtlbim/</a>).  The <code>"max"</code>
option inserts the minimal number of intermediate points so that the
maximum distance between points is <code>step</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After performing the forward-backward equations, we draw from
<code class="reqn">Pr(g_1 = v | O)</code> and then <code class="reqn">Pr(g_{k+1} = v |
    O, g_k = u)</code>.
</p>
<p>In the case of the 4-way cross, with a sex-specific map, we assume a
constant ratio of female:male recombination rates within the
inter-marker intervals.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object is returned with a component,
<code>draws</code>, added to each component of <code>cross$geno</code>.
This is an array of size [n.ind x n.pos x n.draws] where n.pos is
the number of positions at which the simulations were performed and
n.draws is the number of replicates.  Attributes <code>"error.prob"</code>,
<code>"step"</code>, and <code>"off.end"</code> are set to the values of the
corresponding arguments, for later reference.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.genoprob">calc.genoprob</a></code>,
<code><a href="#topic+argmax.geno">argmax.geno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- sim.geno(fake.f2, step=2, n.draws=8)
</code></pre>

<hr>
<h2 id='sim.map'>Simulate a genetic map</h2><span id='topic+sim.map'></span>

<h3>Description</h3>

<p>Simulate the positions of markers on a genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.map(len=rep(100,20), n.mar=10, anchor.tel=TRUE,
        include.x=TRUE, sex.sp=FALSE, eq.spacing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.map_+3A_len">len</code></td>
<td>
<p>A vector specifying the chromosome lengths (in cM)</p>
</td></tr>
<tr><td><code id="sim.map_+3A_n.mar">n.mar</code></td>
<td>
<p>A vector specifying the number of markers per chromosome.</p>
</td></tr>
<tr><td><code id="sim.map_+3A_anchor.tel">anchor.tel</code></td>
<td>
<p>If true, markers at the two telomeres will always be
included, so if <code>n.mar</code> = 1 or 2, we'll give just the two
telomeric markers.</p>
</td></tr>
<tr><td><code id="sim.map_+3A_include.x">include.x</code></td>
<td>
<p>Indicates whether the last chromosome should be
considered the X chromosome.</p>
</td></tr>
<tr><td><code id="sim.map_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to create sex-specific maps, in which
case the output will be a vector of 2-row matrices, with rows
corresponding to the maps for the two sexes.</p>
</td></tr>
<tr><td><code id="sim.map_+3A_eq.spacing">eq.spacing</code></td>
<td>
<p>If TRUE, markers will be equally spaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aside from the telomeric markers, marker positions are simulated as
iid Uniform(<code class="reqn">0,L</code>).  If <code>len</code> or <code>n.mar</code> has just one element,
it is expanded to the length of the other argument.  If they both have
just one element, only one chromosome is simulated.
</p>
<p>If <code>eq.spacing</code> is TRUE, markers are equally spaced between 0 and
<code class="reqn">L</code>.  If <code>anchor.tel</code> is FALSE, telomeric markers are not
included.
</p>


<h3>Value</h3>

<p>A list of vectors, each specifying the locations of the markers.  Each
component of the list is given class <code>A</code> or <code>X</code>, according
to whether it is autosomal or the X chromosome.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="#topic+plotMap">plotMap</a></code>,
<code><a href="#topic+replace.map">replace.map</a></code>, <code><a href="#topic+pull.map">pull.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 4 autosomes, each with 10 markers
map &lt;- sim.map(c(100,90,80,40), 10, include.x=FALSE)
plotMap(map)

# equally spaced markers
map2 &lt;- sim.map(c(100,90,80,40), 10, include.x=FALSE, eq.spacing=TRUE)
plot(map2)
</code></pre>

<hr>
<h2 id='simFounderSnps'>Simulate founder SNPs for a multiple-strain RIL</h2><span id='topic+simFounderSnps'></span>

<h3>Description</h3>

<p>Simulate genotype data for the founding strains for a panel of
multiple-strain RIL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simFounderSnps(map, n.str=c("4","8"), pat.freq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simFounderSnps_+3A_map">map</code></td>
<td>
<p>A list whose components are vectors containing the marker
locations on each of the chromosomes.</p>
</td></tr>
<tr><td><code id="simFounderSnps_+3A_n.str">n.str</code></td>
<td>
<p>Number of founding strains (4 or 8).</p>
</td></tr>
<tr><td><code id="simFounderSnps_+3A_pat.freq">pat.freq</code></td>
<td>
<p>Frequency of SNP genotype patterns in the founder (a
vector of length <code>n.str</code>/2 + 1): (monoallelic, SNP unique to one
founder, SNP present in 2 founders, [and, for the case of 8 founders,
SNP in 3/8 founders, SNP in 4/8 founders].)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SNPs are simulated to be in linkage equilibrium.
</p>


<h3>Value</h3>

<p>A vector of the same length as there are chromosomes in <code>map</code>,
with each component being a matrix of 0's and 1's, of dim <code>n.str</code>
x <code>n.mar</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.map">sim.map</a></code>, <code><a href="#topic+sim.cross">sim.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map10)
x &lt;- simFounderSnps(map10, "8", c(0, 0.5, 0.2, 0.2, 0.1))
</code></pre>

<hr>
<h2 id='simPhyloQTL'>Simulate a set of intercrosses for a single diallelic QTL</h2><span id='topic+simPhyloQTL'></span>

<h3>Description</h3>

<p>Simulate a set of intercrosses with a single diallelic QTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPhyloQTL(n.taxa=3, partition, crosses, map, n.ind=100, model,
            error.prob=0, missing.prob=0, partial.missing.prob=0,
            keep.qtlgeno=FALSE, keep.errorind=TRUE, m=0, p=0,
        map.function=c("haldane","kosambi","c-f","morgan"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPhyloQTL_+3A_n.taxa">n.taxa</code></td>
<td>
<p>Number of taxa (i.e., strains).</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_partition">partition</code></td>
<td>
<p>A vector of character strings of the form &quot;AB|CD&quot; or &quot;A|BCD&quot;
indicating, for each QTL, which taxa have which allele.  If missing,
simulate under the null hypothesis of no QTL.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_crosses">crosses</code></td>
<td>
<p>A vector of character strings indicating the crosses to
do (for the form &quot;AB&quot;, &quot;AC&quot;, etc.).  These will be sorted and then only
unique ones used.  If missing, all crosses will be simulated.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_map">map</code></td>
<td>
<p>A list whose components are vectors containing the marker
locations on each of the chromosomes.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_n.ind">n.ind</code></td>
<td>
<p>The number of individuals in each cross.  If length 1, all
crosses will have the same number of individuals; otherwise the length
should be the same as <code>crosses</code>.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_model">model</code></td>
<td>
<p>A matrix where each row corresponds to a
different QTL, and gives the chromosome number, cM position and
effects of the QTL (assumed to be the same in each cross in which the
QTL is segregating).</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_error.prob">error.prob</code></td>
<td>
<p>The genotyping error rate.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_missing.prob">missing.prob</code></td>
<td>
<p>The rate of missing genotypes.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_partial.missing.prob">partial.missing.prob</code></td>
<td>
<p>When simulating an intercross or 4-way
cross, this gives the rate at which markers will be incompletely
informative (i.e., dominant or recessive).</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_keep.qtlgeno">keep.qtlgeno</code></td>
<td>
<p>If TRUE, genotypes for the simulated QTLs will be
included in the output.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_keep.errorind">keep.errorind</code></td>
<td>
<p>If TRUE, and if <code>error.prob &gt; 0</code>, the
identity of genotyping errors will be included in the output.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_m">m</code></td>
<td>
<p>Interference parameter; a non-negative integer.  0 corresponds
to no interference.</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_p">p</code></td>
<td>
<p>Probability that a chiasma comes from the no-interference
mechanism</p>
</td></tr>
<tr><td><code id="simPhyloQTL_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meiosis is assumed to follow the Stahl model for crossover
interference (see the references, below), of which the no interference
model and the chi-square model are special cases.  Chiasmata on the
four-strand bundle are a superposition of chiasmata from two different
mechanisms.  With probability <code>p</code>, they arise by a mechanism
exhibiting no interference; the remainder come from a chi-square model
with inteference parameter <code>m</code>.  Note that <code>m=0</code> corresponds
to no interference, and with <code>p=0</code>, one gets a pure chi-square
model.
</p>
<p>QTLs are assumed to act additively, and the residual phenotypic
variation is assumed to be normally distributed with variance 1.
</p>
<p>The effect of a QTL is a pair of numbers,
(<code class="reqn">a,d</code>), where <code class="reqn">a</code> is the additive effect (half the difference
between the homozygotes) and <code class="reqn">d</code> is the dominance deviation (the
difference between the heterozygote and the midpoint between the
homozygotes).
</p>


<h3>Value</h3>

<p>A list with each component being an object of class <code>cross</code>.  See <code><a href="#topic+read.cross">read.cross</a></code> for
details.  The names (e.g. &quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;) indicate the crosses.
</p>
<p>If <code>keep.qtlgeno</code> is TRUE, each cross object will contain a
component <code>qtlgeno</code> which is a matrix containing the QTL
genotypes (with complete data and no errors), coded as in the genotype
data.
</p>
<p>If <code>keep.errorind</code> is TRUE and errors were simulated, each
component of <code>geno</code> in each cross will each contain a matrix <code>errors</code>,
with 1's indicating simulated genotyping errors.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>,   <code><a href="#topic+inferredpartitions">inferredpartitions</a></code>,
<code><a href="#topic+summary.scanPhyloQTL">summary.scanPhyloQTL</a></code>, <code><a href="#topic+max.scanPhyloQTL">max.scanPhyloQTL</a></code>,
<code><a href="#topic+plot.scanPhyloQTL">plot.scanPhyloQTL</a></code>,
<code><a href="#topic+sim.cross">sim.cross</a></code>, <code><a href="#topic+read.cross">read.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]

# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
x &lt;- lapply(x, calc.genoprob, step=2)

# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# maximum peak
max(out, format="lod")

# approximate posterior probabilities at peak
max(out, format="postprob")

# all peaks above a threshold for LOD(best) - LOD(2nd best)
summary(out, threshold=1, format="lod")

# all peaks above a threshold for LOD(best), showing approx post'r prob
summary(out, format="postprob", threshold=3)

# plot of results
plot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulatemissingdata'>Simulates missing genotype data</h2><span id='topic+simulatemissingdata'></span>

<h3>Description</h3>

<p>Simulate missing genotype data by removing some genotype data from the cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  simulatemissingdata(cross, percentage = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulatemissingdata_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="simulatemissingdata_+3A_percentage">percentage</code></td>
<td>
<p> How much of the genotype data do we need to randomly drop? </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cross</code> with <code>percentage</code> 
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>



<ul>
<li><p> The MQM tutorial: <a href="https://rqtl.org/tutorials/MQM-tour.pdf">https://rqtl.org/tutorials/MQM-tour.pdf</a>
</p>
</li>
<li> <p><code><a href="#topic+MQM">MQM</a></code> - MQM description and references
</p>
</li>
<li> <p><code><a href="#topic+mqmscan">mqmscan</a></code> - Main MQM single trait analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmscanall">mqmscanall</a></code> - Parallellized traits analysis
</p>
</li>
<li> <p><code><a href="#topic+mqmaugment">mqmaugment</a></code> - Augmentation routine for estimating missing data
</p>
</li>
<li> <p><code><a href="#topic+mqmautocofactors">mqmautocofactors</a></code> - Set cofactors using marker density
</p>
</li>
<li> <p><code><a href="#topic+mqmsetcofactors">mqmsetcofactors</a></code> - Set cofactors at fixed locations
</p>
</li>
<li> <p><code><a href="#topic+mqmpermutation">mqmpermutation</a></code> - Estimate significance levels
</p>
</li>
<li> <p><code><a href="#topic+scanone">scanone</a></code> - Single QTL scanning
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)
multitrait &lt;- fill.geno(multitrait)
multimissing5 &lt;- simulatemissingdata(multitrait,perc=5)
perc &lt;- (sum(nmissing(multimissing5))/sum(ntyped(multimissing5)))
</code></pre>

<hr>
<h2 id='stepwiseqtl'>Stepwise selection for multiple QTL</h2><span id='topic+stepwiseqtl'></span>

<h3>Description</h3>

<p>Performs forward/backward selection to identify a multiple QTL model,
with model choice made via a penalized LOD score, with separate
penalties on main effects and interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwiseqtl(cross, chr, pheno.col=1, qtl, formula, max.qtl=10, covar=NULL,
            method=c("imp", "hk"), model=c("normal", "binary"),
            incl.markers=TRUE, refine.locations=TRUE,
            additive.only=FALSE, scan.pairs=FALSE, penalties,
            keeplodprofile=TRUE, keeptrace=FALSE, verbose=TRUE,
            tol=1e-4, maxit=1000, require.fullrank=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepwiseqtl_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider in
search for QTL.  This should be a vector of character strings
referring to chromosomes by name; numeric values are converted to
strings.  Refer to chromosomes with a preceding <code>-</code> to have all
chromosomes but those considered.  A logical (TRUE/FALSE) vector may
also be used.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>Column number in the phenotype matrix which should be
used as the phenotype.  One may also give character strings matching
the phenotype names.  Finally, one may give a numeric vector of
phenotypes, in which case it must have the length equal to the number
of individuals in the cross, and there must be either non-integers or
values &lt; 1 or &gt; no. phenotypes; this last case may be useful for studying
transformations.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_qtl">qtl</code></td>
<td>
<p>Optional QTL object (of class <code>"qtl"</code>, as created by
<code><a href="#topic+makeqtl">makeqtl</a></code>) to use as a starting point.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_formula">formula</code></td>
<td>
<p>Optional formula to define the QTL model to be used as a
starting point.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_max.qtl">max.qtl</code></td>
<td>
<p>Maximum number of QTL to which forward selection should
proceed.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_covar">covar</code></td>
<td>
<p>Data frame of additive covariates.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_method">method</code></td>
<td>
<p>Indicates whether to use multiple imputation or
Haley-Knott regression.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_model">model</code></td>
<td>
<p>The phenotype model: the usual model or a model for binary
traits</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_incl.markers">incl.markers</code></td>
<td>
<p>If FALSE, do calculations only at points on an
evenly spaced grid.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_refine.locations">refine.locations</code></td>
<td>
<p>If TRUE, use <code><a href="#topic+refineqtl">refineqtl</a></code> to
refine the QTL locations after each step of forward and backward
selection.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_additive.only">additive.only</code></td>
<td>
<p>If TRUE, allow only additive QTL models; if FALSE,
consider also pairwise interactions among QTL.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_scan.pairs">scan.pairs</code></td>
<td>
<p>If TRUE, perform a two-dimensional, two-QTL scan at
each step of forward selection.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_penalties">penalties</code></td>
<td>
<p>Vector of three (or six) values indicating the penalty
on the number of QTL terms. If three values, these are the penalties
on main effects and heavy and light penalties on interactions.  If
six values, these include X-chr-specific penalties, and the values
are: main effect for autosomes, main effect for X chr, heavy penalty
on A:A interactions, light penalty on A:A interactions, penalty on
A:X interactions, and penalty on X:X interactions. See the Details
below. If missing, default values are used that are based on
simulations of backcrosses and intercrosses with genomes modeled
after that of the mouse.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_keeplodprofile">keeplodprofile</code></td>
<td>
<p>If TRUE, keep the LOD profiles from the last
iteration as attributes to the output.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_keeptrace">keeptrace</code></td>
<td>
<p>If TRUE, keep information on the sequence of models
visited through the course of forward and backward selection as an
attribute to the output.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, give feedback about progress.  If
<code>verbose</code> is an integer &gt; 1, even more information is printed.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence for the binary trait model.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for fitting the binary trait
model.</p>
</td></tr>
<tr><td><code id="stepwiseqtl_+3A_require.fullrank">require.fullrank</code></td>
<td>
<p>If TRUE, give LOD=0 when covariate matrix in
the linear regression is not of full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We seek to identify the model with maximal penalized LOD score.  The
penalized LOD score, defined in Manichaikul et al. (2009),
is the LOD score for the model (the <code class="reqn">\log_{10}</code> likelihood
ratio comparing the model to the null model with no QTL) with
penalties on the number of QTL and QTL:QTL interactions.
</p>
<p>We consider QTL models allowing pairwise interactions among QTL but
with an enforced hierarchy in which inclusion of a pairwise
interaction requires the inclusion of both of the corresponding main
effects.  Additive covariates may be included, but currently we do not
explore QTL:covariate interactions.  Also, the penalized LOD score
criterion is currently defined only for autosomal loci, and results
with the X chromosome should be considered with caution.
</p>
<p>The penalized LOD score is of the form <code class="reqn">pLOD(\gamma) = LOD(\gamma)
  - T_m p_m - T_h p_h - T_l p_l</code> where <code class="reqn">\gamma</code> denotes a model,
<code class="reqn">p_m</code> is the number of QTL in the model (&quot;main effects&quot;),
<code class="reqn">p_h</code> is the number of pairwise interactions that will be
given a heavy interaction penalty, <code class="reqn">p_l</code> is the number of pairwise
interactions that will be given a light interaction penalty,
<code class="reqn">T_m</code> is the penalty on main effects, <code class="reqn">T_h</code> is the heavy
interaction penalty, and <code class="reqn">T_l</code> is the light interaction
penalty.  The <code>penalties</code> argument is the vector <code class="reqn">(T_m, T_h,
  T_l)</code>.  If <code class="reqn">T_l</code> is missing (<code>penalties</code>
has a vector of length 2), we assume <code class="reqn">T_l = T_h</code>, and so
all pairwise interactions are assigned the same penalty.
</p>
<p>The &quot;heavy&quot; and &quot;light&quot; interaction penalties can be a bit
confusing.  Consider the clusters of QTL that are connected via one or
more pairwise interactions.  To each such cluster, we assign at most
one &quot;light&quot; interaction penalty, and give all other pairwise
interactions the heavy interaction penalty.  In other words, if
<code class="reqn">p_i</code> is the total number of pairwise interactions for a QTL
model, we let <code class="reqn">p_l</code> be the number of clusters of connected QTL
with at least one pairwise interaction, and then let <code class="reqn">p_h - p_i -
    p_l</code>.
</p>
<p>Let us give an explicit example.  Consider a model with 6 QTL, and
with interactions between QTL 2 and 3, QTL 4 and 5 and QTL 4 and 6
(so we have the model formula
<code>y ~ Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q2:Q3 + Q4:Q5 + Q4:Q6</code>).
There are three clusters of connected QTL: (1), (2,3) and (4,5,6).  We
would assign 6 main effect penalties (<code class="reqn">T_m</code>), 2 light
interaction penalties (<code class="reqn">T_l</code>), and 1 heavy interaction penalty
(<code class="reqn">T_h</code>).
</p>
<p>Manichaikul et al. (2009) described a system for deriving the
three penalties on the basis of permutation results from a
two-dimensional, two-QTL genome scan (as calculated with
<code><a href="#topic+scantwo">scantwo</a></code>).  These may be calculated with the
function <code><a href="#topic+calc.penalties">calc.penalties</a></code>.
</p>
<p>A forward/backward search method is used, with the aim to optimize the
penalized LOD score criterion.  That is, we seek to identify the
model with maximal the penalized LOD score.  The search algorithm was
based closely on an algorithm described by Zeng et al. (1999).
</p>
<p>We use forward selection to a model of moderate size (say 10 QTL),
followed by backward elimination all the way to the null model.  The
chosen model is that which optimizes the penalized LOD score
criterion, among all models visited.  The detailed algorithm is as
follows.  Note that if <code>additive.only=TRUE</code>, no pairwise
interactions are considered.
</p>

<ol>
<li><p> Start at the null model, and perform a single-QTL genome scan,
and choose the position giving the largest LOD score.  If
<code>scan.pairs=TRUE</code>, start with a two-dimensional, two-QTL genome
scan instead.  If an initial QTL model were defined through the
arguments <code>qtl</code> and <code>formula</code>, start with this model and
jump immediately to step 2.
</p>
</li>
<li><p> With a fixed QTL model in hand:
</p>

<ol>
<li><p> Scan for an additional additive QTL.
</p>
</li>
<li><p> For each QTL in the current model, scan for an additional
interacting QTL.
</p>
</li>
<li><p> If there are <code class="reqn">\ge</code> 2 QTL in the current model,
consider adding one of the possible pairwise interactions.
</p>
</li>
<li><p> If <code>scan.pairs=TRUE</code> perform a two-dimensional, two-QTL
scan, seeking to add a pair of novel QTL, either additive or
interacting.
</p>
</li>
<li><p> Step to the model that gives the largest value for the model
comparison criterion, among those considered at the current step.
</p>
</li></ol>

</li>
<li><p> Refine the locations of the QTL in the current model (if
<code>refine.locations=TRUE</code>).
</p>
</li>
<li><p> Repeat steps 2 and 3 up to a model with some pre-determined
number of loci.
</p>
</li>
<li><p> Perform backward elimination, all the way back to the null
model.  At each step, consider dropping one of the current main
effects or interactions; move to the model that maximizes the model
comparison criterion, among those considered at this step.  Follow
this with a refinement of the locations of the QTL.
</p>
</li>
<li><p> Finally, choose the model having the largest model comparison
criterion, among all models visited.
</p>
</li></ol>

<p>In this forward/backward algorithm, it is likely best to build up to
an overly large model and then prune it back.  Note that there is no
&quot;stopping rule&quot;; the chosen model is that which optimizes the model
comparison criterion, among all models visited.  The search can be
time consuming, particularly if a two-dimensional scan is performed at
each forward step.  Such two-dimensional scans may be useful for
identifying QTL linked in repulsion (having effects of opposite sign)
or interacting QTL with limited marginal effects, but our limited
experience suggests that they are not necessary; important linked or
interacting QTL pairs can be picked up in the forward selection to a
large model, and will be retained in the backward elimination phase.
</p>


<h3>Value</h3>

<p>The output is a representation of the best model, as measured by the
penalized LOD score (see Details), among all models visited.
This is QTL object (of class <code>"qtl"</code>, as produced by
<code><a href="#topic+makeqtl">makeqtl</a></code>), with attributes <code>"formula"</code>,
indicating the model formula, and <code>"pLOD"</code> indicating the
penalized LOD score.
</p>
<p>If <code>keeplodprofile=TRUE</code>, LOD profiles from the last pass through
the refinement algorithm are retained as an attribute,
<code>"lodprofile"</code>, to the object.  These may be plotted with
<code><a href="#topic+plotLodProfile">plotLodProfile</a></code>.
</p>
<p>If <code>keeptrace=TRUE</code>, the output will contain an attribute
<code>"trace"</code> containing information on the best model at each step
of forward and backward elimination.  This is a list of objects of
class <code>"compactqtl"</code>, which is similar to a QTL object (as
produced by <code><a href="#topic+makeqtl">makeqtl</a></code>) but containing just
a vector of chromosome IDs and positions for the QTL.  Each will also
have attributes <code>"formula"</code> (containing the model formula) and
<code>"pLOD"</code> (containing the penalized LOD score.
</p>


<h3>Methods</h3>

<p><b><code>imp</code></b>: multiple imputation is used, as described by Sen
and Churchill (2001).
</p>
<p><b><code>hk</code></b>: Haley-Knott regression is used (regression of the
phenotypes on the multipoint QTL genotype probabilities), as described
by Haley and Knott (1992).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Manichaikul, A., Moon, J. Y., Sen, &#346;, Yandell, B. S. and Broman,
K. W. (2009) A model selection approach for the identification of
quantitative trait loci in experimental crosses, allowing
epistasis. <em>Genetics</em>, <b>181</b>, 1077&ndash;1086.
</p>
<p>Broman,  K. W. and Speed, T. P. (2002) A model selection approach for the
identification of quantitative trait loci in experimental crosses (with
discussion). <em>J Roy Stat Soc B</em> <b>64</b>, 641&ndash;656, 731&ndash;775.
</p>
<p>Haley, C. S. and Knott, S. A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
<em>Heredity</em> <b>69</b>, 315&ndash;324.
</p>
<p>Sen, &#346;. and Churchill, G. A. (2001) A statistical framework for quantitative
trait mapping.  <em>Genetics</em> <b>159</b>, 371&ndash;387.
</p>
<p>Zeng, Z.-B., Kao, C.-H. and Basten, C. J. (1999) Estimating the
genetic architecture of quantitative traits.  <em>Genetical
Research</em>, <b>74</b>, 279&ndash;289.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.penalties">calc.penalties</a></code>,
<code><a href="#topic+plotModel">plotModel</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+refineqtl">refineqtl</a></code>,
<code><a href="#topic+addqtl">addqtl</a></code>, <code><a href="#topic+addpair">addpair</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

## Not run: fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)

outsw &lt;- stepwiseqtl(fake.bc, max.qtl=3, method="hk", keeptrace=TRUE)

# best model
outsw
plotModel(outsw)

# path through model space
thetrace &lt;- attr(outsw, "trace")

# plot of these
par(mfrow=c(3,3))
for(i in seq(along=thetrace))
  plotModel(thetrace[[i]], main=paste("pLOD =",round(attr(thetrace[[i]],"pLOD"), 2)))
</code></pre>

<hr>
<h2 id='strip.partials'>Strip partially informative genotypes</h2><span id='topic+strip.partials'></span>

<h3>Description</h3>

<p>Replace all partially informative genotypes (e.g., dominant markers in
an intercross) with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.partials(cross, verbose=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip.partials_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="strip.partials_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print the number of genotypes removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same class <code>cross</code> object as in the input, but with partially
informative genotypes made missing.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotMissing">plotMissing</a></code>, <code><a href="#topic+plotInfo">plotInfo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(listeria)
sum(nmissing(listeria))
listeria &lt;- strip.partials(listeria)
sum(nmissing(listeria))
</code></pre>

<hr>
<h2 id='subset.cross'>Subsetting data for QTL experiment</h2><span id='topic+subset.cross'></span><span id='topic++5B.cross'></span>

<h3>Description</h3>

<p>Pull out a specified set of chromosomes and/or individuals from a
<code>cross</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
subset(x, chr, ind, ...)
## S3 method for class 'cross'
x[chr, ind]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.cross_+3A_x">x</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="subset.cross_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to keep or discard.
This may be a logical, numeric, or character string vector.  See
Details, below.</p>
</td></tr>
<tr><td><code id="subset.cross_+3A_ind">ind</code></td>
<td>
<p>Optional vector specifying which individuals to keep
discard. This may be a logical, numeric or chacter string vector.
See Details, below.</p>
</td></tr>
<tr><td><code id="subset.cross_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>chr</code> argument may be a logical vector with length equal to
the number of chromosomes in the input cross <code>x</code>.  Alternatively, it
should be a vector of character strings referring to chromosomes by
name.  Numeric values are converted to strings.  Refer to chromosomes
with a preceding <code>-</code> to have all chromosomes but those
considered.
</p>
<p>If the <code>ind</code> argument is a logical vector
(<code>TRUE</code>/<code>FALSE</code>), it should have length equal to the number
of individuals in the input cross <code>x</code>.  The individuals with
corresponding <code>TRUE</code> values are retained.
</p>
<p>If the <code>ind</code> argument is numeric, it should have values either
between 1 and the number of individuals in the input cross <code>x</code>
(in which case these individuals will be retained),
or it should have values between <code>-1</code> and <code>-n</code>, where
<code>n</code> is the number of individuals in the input cross <code>x</code>, in
which case all <em>except</em> these individuals will be retained.
</p>
<p>If the input cross object <code>x</code> contains individual identifiers (a
phenotype column labeled <code>"id"</code> or <code>"ID"</code>), and if the
<code>ind</code> argument contains character strings, then these will be
matched against the individual identifiers.
If all values in <code>ind</code> are
preceded by a <code>-</code>), we omit those individuals whose IDs match
those in <code>ind</code>.  Otherwise, we retain those individuals whose IDs
match those in <code>ind</code>.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> object, but with only the specified subset
of the data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+drop.markers">drop.markers</a></code>, <code><a href="#topic+subset.map">subset.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2.A &lt;- subset(fake.f2, chr=c("5","13"))
fake.f2.B &lt;- subset(fake.f2, ind = -c(1,5,10))
fake.f2.C &lt;- subset(fake.f2, chr=1:5, ind=1:50)

data(listeria)
y &lt;- pull.pheno(listeria, 1)
listeriaB &lt;- subset(listeria, ind = (!is.na(y) &amp; y &lt; 264))

# individual identifiers
listeria$pheno$ID &lt;- paste("mouse", 1:nind(listeria), sep="")
listeriaC &lt;- subset(listeria, ind=c("mouse1","mouse11","mouse21"))
listeriaD &lt;- subset(listeria, ind=c("-mouse1","-mouse11","-mouse21"))

# you can also use brackets (like matrix with rows=chromosomes and columns=individuals)
temp &lt;- listeria[c("5","13"),]  # chr 5 and 13
temp &lt;- listeria[ , 1:10]       # first ten individuals
temp &lt;- listeria[5, 1:10]       # chr 5 for first ten individuals
</code></pre>

<hr>
<h2 id='subset.map'>Subsetting chromosomes for a genetic map</h2><span id='topic+subset.map'></span><span id='topic++5B.map'></span>

<h3>Description</h3>

<p>Pull out a specified set of chromosomes from a
<code>map</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
subset(x, ...)
## S3 method for class 'map'
x[...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.map_+3A_x">x</code></td>
<td>
<p>A list whose components are vectors of marker locations.</p>
</td></tr>
<tr><td><code id="subset.map_+3A_...">...</code></td>
<td>
<p>Vector of chromosome indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>map</code> object, but with only the specified subset
of chromosomes.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+subset.cross">subset.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map10)
map10 &lt;- subset(map10, chr=1:5)

# you can also use brackets
map10 &lt;- map10[2:3]
</code></pre>

<hr>
<h2 id='subset.scanone'>Subsetting the results of a genome scan</h2><span id='topic+subset.scanone'></span>

<h3>Description</h3>

<p>Pull out a specified set of chromosomes and/or LOD columns from
<code><a href="#topic+scanone">scanone</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
subset(x, chr, lodcolumn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.scanone_+3A_x">x</code></td>
<td>
<p>An object of class <code>scanone</code>, output from
<code><a href="#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code id="subset.scanone_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to keep.
This should be a vector of character strings referring to
chromosomes by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but those
considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="subset.scanone_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>A vector specifying which LOD columns to keep (or, if
negative), omit.  These should be between 1 and the number of LOD
columns in the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="subset.scanone_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>scanone</code> object, but with only the specified
subset of the data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scanone">summary.scanone</a></code>,
<code><a href="#topic+scanone">scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=2.5)
out &lt;- scanone(fake.bc, method="hk", pheno.col=1:2)

summary(subset(out, chr=18:19), format="allpeaks")
</code></pre>

<hr>
<h2 id='subset.scanoneperm'>Subsetting permutation test results</h2><span id='topic+subset.scanoneperm'></span><span id='topic++5B.scanoneperm'></span>

<h3>Description</h3>

<p>Pull out results for a specified set LOD columns from
permutation results from <code><a href="#topic+scanone">scanone</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneperm'
subset(x, repl, lodcolumn, ...)
## S3 method for class 'scanoneperm'
x[repl, lodcolumn]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.scanoneperm_+3A_x">x</code></td>
<td>
<p>Permutation results from
<code><a href="#topic+scanone">scanone</a></code>, run with <code>n.perm</code>&gt;0.</p>
</td></tr>
<tr><td><code id="subset.scanoneperm_+3A_repl">repl</code></td>
<td>
<p>A vector specifying which permutation replicates to keep or (if
negative) omit.</p>
</td></tr>
<tr><td><code id="subset.scanoneperm_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>A vector specifying which LOD columns to keep or (if
negative) omit.  These should be between 1 and the number of LOD
columns in the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="subset.scanoneperm_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>scanone</code> permutation results, but with only the specified
subset of the data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>,
<code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+c.scanoneperm">c.scanoneperm</a></code>,
<code><a href="#topic+cbind.scanoneperm">cbind.scanoneperm</a></code>,
<code><a href="#topic+c.scanoneperm">rbind.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=5)
operm &lt;- scanone(fake.bc, method="hk", pheno.col=1:2, n.perm=25)
operm2 &lt;- subset(operm, lodcolumn=2)

# alternatively
operm2alt &lt;- operm[,2]
</code></pre>

<hr>
<h2 id='subset.scantwo'>Subsetting the results of a 2-d genome scan</h2><span id='topic+subset.scantwo'></span>

<h3>Description</h3>

<p>Pull out a specified set of chromosomes and/or LOD columns from
<code><a href="#topic+scantwo">scantwo</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
subset(x, chr, lodcolumn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.scantwo_+3A_x">x</code></td>
<td>
<p>An object of class <code>scantwo</code>, output from
<code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="subset.scantwo_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to keep.
This should be a vector of character strings referring to
chromosomes by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but those
considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="subset.scantwo_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>A vector specifying which LOD columns to keep (or, if
negative), omit.  These should be between 1 and the number of LOD
columns in the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="subset.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>scantwo</code> object, but with only the specified
subset of the data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+scantwo">scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc)
out &lt;- scantwo(fake.bc, method="hk", pheno.col=1:2)

summary(subset(out, chr=18:19))
</code></pre>

<hr>
<h2 id='subset.scantwoperm'>Subsetting two-dimensional permutation test results</h2><span id='topic+subset.scantwoperm'></span><span id='topic++5B.scantwoperm'></span>

<h3>Description</h3>

<p>Pull out results for a specified set LOD columns from
permutation results from <code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwoperm'
subset(x, repl, lodcolumn, ...)
## S3 method for class 'scantwoperm'
x[repl, lodcolumn]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.scantwoperm_+3A_x">x</code></td>
<td>
<p>Permutation results from
<code><a href="#topic+scantwo">scantwo</a></code>, run with <code>n.perm</code>&gt;0.</p>
</td></tr>
<tr><td><code id="subset.scantwoperm_+3A_repl">repl</code></td>
<td>
<p>A vector specifying which permutation replicates to keep or (if
negative) omit. Ignored in case of X-chr specific permutations</p>
</td></tr>
<tr><td><code id="subset.scantwoperm_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>A vector specifying which LOD columns to keep or (if
negative) omit.  These should be between 1 and the number of LOD
columns in the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="subset.scantwoperm_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>scantwo</code> permutation results, but with only the specified
subset of the data.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scantwoperm">summary.scantwoperm</a></code>,
<code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+c.scantwoperm">c.scantwoperm</a></code>,
<code><a href="#topic+c.scantwoperm">rbind.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=0)
operm &lt;- scantwo(fake.bc, method="hk", pheno.col=1:2, n.perm=5)
operm2 &lt;- subset(operm, lodcolumn=2)

# alternatively
operm2alt &lt;- operm[,2]
</code></pre>

<hr>
<h2 id='summary.comparegeno'>Print pairs of individuals with similar genotype data.</h2><span id='topic+summary.comparegeno'></span>

<h3>Description</h3>

<p>Prints a summary the output from <code><a href="#topic+comparegeno">comparegeno</a></code> that
includes pairs of individuals whose proportion of matching genotypes
is above a chosen threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'comparegeno'
summary(object, thresh=0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.comparegeno_+3A_object">object</code></td>
<td>
<p>An object of class <code>comparegeno</code>, the output of the
function <code><a href="#topic+comparegeno">comparegeno</a></code>.</p>
</td></tr>
<tr><td><code id="summary.comparegeno_+3A_thresh">thresh</code></td>
<td>
<p>Threshold on the proportion of matching genotypes.</p>
</td></tr>
<tr><td><code id="summary.comparegeno_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row being a pair of individuals and columns
including the individual identifiers (via <code>getid</code>, or just as
numeric indexes) along with the proportion of matching genotypes.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+comparegeno">comparegeno</a></code>, <code><a href="#topic+plot.comparegeno">plot.comparegeno</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
cg &lt;- comparegeno(fake.f2)
summary(cg, 0.7)
</code></pre>

<hr>
<h2 id='summary.cross'>Print summary of QTL experiment</h2><span id='topic+summary.cross'></span>

<h3>Description</h3>

<p>Print summary information about a <code>cross</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cross_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="summary.cross_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.cross</code>
containing a variety of summary information about the cross (this is
generally printed automatically).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>,
<code><a href="#topic+nmar">nmar</a></code>,
<code><a href="#topic+nchr">nchr</a></code>,
<code><a href="#topic+totmar">totmar</a></code>,
<code><a href="#topic+nphe">nphe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
summary(fake.f2)
</code></pre>

<hr>
<h2 id='summary.fitqtl'>Summary of fit of qtl model</h2><span id='topic+summary.fitqtl'></span>

<h3>Description</h3>

<p>Print summary information about the results of <code><a href="#topic+fitqtl">fitqtl</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitqtl'
summary(object, pvalues=TRUE, simple=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fitqtl_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+fitqtl">fitqtl</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fitqtl_+3A_pvalues">pvalues</code></td>
<td>
<p>If FALSE, don't include p-values in the summary.</p>
</td></tr>
<tr><td><code id="summary.fitqtl_+3A_simple">simple</code></td>
<td>
<p>If TRUE, don't include p-values or sums of squares in the summary.</p>
</td></tr>
<tr><td><code id="summary.fitqtl_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.fitqtl</code>, which is not all that
different than the input, but when printed gives summary information
about the results.
</p>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitqtl">fitqtl</a></code>, <code><a href="#topic+makeqtl">makeqtl</a></code>,
<code><a href="#topic+scanqtl">scanqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 8, 13)
qp &lt;- c(26, 56, 28)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

# fit model with 3 interacting QTLs interacting
# (performing a drop-one-term analysis)
lod &lt;- fitqtl(fake.f2, pheno.col=1, qtl, formula=y~Q1*Q2*Q3,
              method="hk")
summary(lod)
</code></pre>

<hr>
<h2 id='summary.qtl'>Print summary of a QTL object</h2><span id='topic+summary.qtl'></span>

<h3>Description</h3>

<p>Print summary information about a <code>qtl</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtl'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.qtl_+3A_object">object</code></td>
<td>
<p>An object of class <code>qtl</code>, created by <code><a href="#topic+makeqtl">makeqtl</a></code>.</p>
</td></tr>
<tr><td><code id="summary.qtl_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.qtl</code>, which is just a data.frame
containing the chromosomes, positions, and number of possible
genotypes for each QTL.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+makeqtl">makeqtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

# take out several QTLs and make QTL object
qc &lt;- c(1, 6, 13)
qp &lt;- c(25.8, 33.6, 18.63)
fake.f2 &lt;- subset(fake.f2, chr=qc)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2, err=0.001)
qtl &lt;- makeqtl(fake.f2, qc, qp, what="prob")

summary(qtl)
</code></pre>

<hr>
<h2 id='summary.ripple'>Print summary of ripple results</h2><span id='topic+summary.ripple'></span>

<h3>Description</h3>

<p>Print marker orders, from the output of the function <code>ripple</code>,
for which the log10 likelihood relative to the initial order is above
a specified cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ripple'
summary(object, lod.cutoff = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ripple_+3A_object">object</code></td>
<td>
<p>An object of class <code>ripple</code>, the output of the
function <code><a href="#topic+ripple">ripple</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ripple_+3A_lod.cutoff">lod.cutoff</code></td>
<td>
<p>Only marker orders with LOD score (relative to the
initial order) above this cutoff will be displayed.  For output of
<code><a href="#topic+ripple">ripple</a></code> in the case of minimization of the number
of obligate crossovers, we double this argument and treat it as a
cutoff for the number of obligate crossovers.</p>
</td></tr>
<tr><td><code id="summary.ripple_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.ripple</code>, whose rows correspond to
marker orders with likelihood (or number of obligate crossovers)
within some cutoff of the initial order. If no marker order, other
than the initial one, has likelihood within the specified range, the
initial and next-best orders are returned.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ripple">ripple</a></code>, <code><a href="#topic+est.map">est.map</a></code>,
<code><a href="#topic+est.rf">est.rf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: data(badorder)
rip1 &lt;- ripple(badorder, 1, 7)
summary(rip1)

rip2 &lt;- ripple(badorder, 1, 2, method="likelihood")
summary(rip2)

badorder &lt;- switch.order(badorder, 1, rip2[2,])

## End(Not run)</code></pre>

<hr>
<h2 id='summary.scanone'>Summarize the results of a genome scans</h2><span id='topic+summary.scanone'></span>

<h3>Description</h3>

<p>Print the rows of the output from <code><a href="#topic+scanone">scanone</a></code> that
correspond to the maximum LOD for each chromosome, provided that they
exceed some specified thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanone'
summary(object, threshold,
        format=c("onepheno", "allpheno", "allpeaks", "tabByCol", "tabByChr"),
        perms, alpha, lodcolumn=1, pvalues=FALSE,
        ci.function=c("lodint", "bayesint"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scanone_+3A_object">object</code></td>
<td>
<p>An object output by the function
<code><a href="#topic+scanone">scanone</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_threshold">threshold</code></td>
<td>
<p>LOD score thresholds. Only peaks with LOD score above
this value will be returned. This could be a single number or (for
formats other than <code>"onepheno"</code>) a threshold for each LOD score
column.  If <code>alpha</code> is specified, <code>threshold</code> should not be.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_format">format</code></td>
<td>
<p>Format for the output.  See Details, below.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_perms">perms</code></td>
<td>
<p>Optional permutation results used to derive thresholds or
to calculate genome-scan-adjusted p-values.  This must be consistent
with the <code>object</code> input, in that it must have the same number of
LOD score columns, though it can have just one column of permutation
results, in which case they are reused for all LOD score columns in
the <code><a href="#topic+scanone">scanone</a></code> output, <code>object</code>.
(These can also be permutation results from
<code><a href="#topic+scantwo">scantwo</a></code>, which permutations for a one-dimensional scan.)</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_alpha">alpha</code></td>
<td>
<p>If perms are included, this is the significance level used
to calculate thresholds for determining which peaks to pull out.
If <code>threshold</code> is specified, <code>alpha</code> should not be.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If <code>format="onepheno"</code>, this indicates the LOD
score column to focus on.  This should be a single number between 1
and the number of LOD columns in the object input.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_pvalues">pvalues</code></td>
<td>
<p>If TRUE, include columns with genome-scan-adjusted
p-values in the results.  This requires that <code>perms</code> be
provided.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_ci.function">ci.function</code></td>
<td>
<p>For formats <code>"tabByCol"</code> and <code>"tabByChr"</code>,
indicates the function to use to get approximate confidence intervals
for QTL location.</p>
</td></tr>
<tr><td><code id="summary.scanone_+3A_...">...</code></td>
<td>
<p>For formats <code>"tabByCol"</code> and <code>"tabByChr"</code>,
additional arguments are passed to the function indicated by
<code>ci.function</code> (for example, <code>drop</code> for <code><a href="#topic+lodint">lodint</a></code>
or <code>prob</code> for <code><a href="#topic+bayesint">bayesint</a></code>, or <code>expandtomarkers</code>
for either).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to report loci deemed interesting from a one-QTL
genome scan (by <code><a href="#topic+scanone">scanone</a></code>).
</p>
<p>For <code>format="onepheno"</code>, we focus on a single LOD score column,
indicated by <code>lodcolumn</code>.  The single largest LOD score peak on
each chromosome is extracted.  If <code>threshold</code> is specified, only
those peaks with LOD meeting the threshold will be
returned.  If <code>perms</code> and <code>alpha</code> are specified, a threshold
is calculated based on the permutation results in <code>perms</code> for the
significance level <code>alpha</code>.  If neither <code>threshold</code> nor
<code>alpha</code> are specified, the peak on each chromosome is returned.
Again note that with this format, only the LOD score column indicated
by <code>lodcolumn</code> is considered in deciding which chromosomes to
return, but the LOD scores from other columns, at the position with
maximum LOD score in the <code>lodcolumn</code> column, are also returned.
</p>
<p>For <code>format="allpheno"</code>, we consider all LOD score columns, and
pull out the position, on each chromosome, showing the largest LOD
score.  The output thus may contain multiple rows for a chromosome.
Here <code>threshold</code> may be a vector of LOD score thresholds, one for
each LOD score column, in which case only those positions for which a
LOD score column exceeded its threshold are given.  If
<code>threshold</code> is a single number, it is applied to all of the LOD
score columns.  If <code>alpha</code> is specified, it must   be a single
significance level, applied for all LOD score columns, and again
<code>perms</code> must be specified, and these are used to calculate the
LOD score threshold for the significance level <code>alpha</code>.
</p>
<p>For <code>format="allpeaks"</code>, the output will contain, for each
chromosome, the maximum LOD score for each LOD score column, at the
position at which it achieved its maximum.  Thus, the output will
contain no more than one row per chromosome, but will contain the
position and maximum LOD score for each of the LOD score columns.
The arguments <code>threshold</code> and <code>alpha</code> may be specified as
for the <code>"allpheno"</code> format.  The results for a chromosome are
returned if at least one of the LOD score columns exceeded its
threshold.
</p>
<p>For <code>format="tabByCol"</code>, there will be a separate table for each
LOD score column, with a single peak per chromosome.  Included are
columns indicating chromosome, peak position, lower and upper limits
of the confidence interval calculated via <code><a href="#topic+lodint">lodint</a></code> or
<code><a href="#topic+bayesint">bayesint</a></code>, and lod score.
</p>
<p>The output for <code>format="tabByChr"</code>, is similar to that of
<code>format="tabByCol"</code>, but with results organized by chromosome
rather than by LOD score column.
</p>
<p>If <code>pvalues=TRUE</code>, and <code>perms</code> is specified,
genome-scan-adjusted p-values are calculated for each LOD score
column, and there are additional columns in the output containing
these p-values.
</p>
<p>In the case that X-chromosome specific permutations were performed
(with <code>perm.Xsp=TRUE</code> in <code><a href="#topic+scanone">scanone</a></code>), autosome-
and X-chromosome specific thresholds and p-values are calculated by
the method in Broman et al. (2006).
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scanone</code>, to be printed by
<code>print.summary.scanone</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman, K. W., Sen, &#346;, Owens, S. E., Manichaikul, A.,
Southard-Smith, E. M. and Churchill G. A. (2006)  The X chromosome in
quantitative trait locus mapping.  <em>Genetics</em>, <b>174</b>, 2151&ndash;2158.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>, <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+max.scanone">max.scanone</a></code>, <code><a href="#topic+subset.scanone">subset.scanone</a></code>,
<code><a href="#topic+c.scanone">c.scanone</a></code>, <code><a href="#topic+summary.scanoneperm">summary.scanoneperm</a></code>
<code><a href="#topic+c.scanoneperm">c.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fake.bc)

fake.bc &lt;- calc.genoprob(fake.bc, step=5)

# genome scan by Haley-Knott regression
out &lt;- scanone(fake.bc, method="hk")

# permutation tests
## Not run: operm &lt;- scanone(fake.bc, method="hk", n.perm=1000)


# peaks for all chromosomes
summary(out)

# results with LOD &gt;= 3
summary(out, threshold=3)

# the same, but also showing the p-values
summary(out, threshold=3, perms=operm, pvalues=TRUE)

# results with LOD meeting the 0.05 threshold from the permutation results
summary(out, perms=operm, alpha=0.05)

# the same, also showing the p-values
summary(out, perms=operm, alpha=0.05, pvalues=TRUE)

##### summary with multiple phenotype results
out2 &lt;- scanone(fake.bc, pheno.col=1:2, method="hk")

# permutations
## Not run: operm2 &lt;- scanone(fake.bc, pheno.col=1:2, method="hk", n.perm=1000)


# results with LOD &gt;= 2 for the 1st phenotype and &gt;= 1 for the 2nd phenotype
#     using format="allpheno"
summary(out2, thr=c(2, 1), format="allpheno")

# The same with format="allpeaks"
summary(out2, thr=c(2, 1), format="allpeaks")

# The same with p-values
summary(out2, thr=c(2, 1), format="allpeaks", perms=operm2, pvalues=TRUE)

# results with LOD meeting the 0.05 significance level by the permutations
#     using format="allpheno"
summary(out2, format="allpheno", perms=operm2, alpha=0.05)

# The same with p-values
summary(out2, format="allpheno", perms=operm2, alpha=0.05, pvalues=TRUE)

# The same with format="allpeaks"
summary(out2, format="allpeaks", perms=operm2, alpha=0.05, pvalues=TRUE)

# format="tabByCol"
summary(out2, format="tabByCol", perms=operm2, alpha=0.05, pvalues=TRUE)

# format="tabByChr", but using bayes intervals
summary(out2, format="tabByChr", perms=operm2, alpha=0.05, pvalues=TRUE,
        ci.function="bayesint")

# format="tabByChr", but using 99% bayes intervals
summary(out2, format="tabByChr", perms=operm2, alpha=0.05, pvalues=TRUE,
        ci.function="bayesint", prob=0.99)
</code></pre>

<hr>
<h2 id='summary.scanoneboot'>Bootstrap confidence interval for QTL location</h2><span id='topic+summary.scanoneboot'></span>

<h3>Description</h3>

<p>Calculates a bootstrap confidence interval for QTL location, using the
bootstrap results from <code><a href="#topic+scanoneboot">scanoneboot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneboot'
summary(object, prob=0.95, expandtomarkers=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scanoneboot_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+scanoneboot">scanoneboot</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scanoneboot_+3A_prob">prob</code></td>
<td>
<p>Desired coverage.</p>
</td></tr>
<tr><td><code id="summary.scanoneboot_+3A_expandtomarkers">expandtomarkers</code></td>
<td>
<p>If TRUE, the interval is expanded to the nearest
flanking markers.</p>
</td></tr>
<tr><td><code id="summary.scanoneboot_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scanone</code>, indicating the
position with the maximum LOD, and indicating endpoints
for the estimated bootstrap confidence interval.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanoneboot">scanoneboot</a></code>, <code><a href="#topic+plot.scanoneboot">plot.scanoneboot</a></code>,
<code><a href="#topic+lodint">lodint</a></code>, <code><a href="#topic+bayesint">bayesint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(fake.f2)
fake.f2 &lt;- calc.genoprob(fake.f2, step=1, err=0.001)
bootoutput &lt;- scanoneboot(fake.f2, chr=13, method="hk")

summary(bootoutput)
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.scanoneperm'>LOD thresholds from scanone permutation results</h2><span id='topic+summary.scanoneperm'></span>

<h3>Description</h3>

<p>Print the estimated genome-wide LOD thresholds on the basis of
permutation results from <code><a href="#topic+scanone">scanone</a></code> (with
<code>n.perm</code> &gt; 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanoneperm'
summary(object, alpha=c(0.05, 0.10),
                    controlAcrossCol=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scanoneperm_+3A_object">object</code></td>
<td>
<p>Output from the function <code><a href="#topic+scanone">scanone</a></code>
with <code>n.perm</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="summary.scanoneperm_+3A_alpha">alpha</code></td>
<td>
<p>Genome-wide significance levels.</p>
</td></tr>
<tr><td><code id="summary.scanoneperm_+3A_controlacrosscol">controlAcrossCol</code></td>
<td>
<p>If TRUE, control error rate not just across
the genome but also across the columns of LOD scores.</p>
</td></tr>
<tr><td><code id="summary.scanoneperm_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there were autosomal data only or <code><a href="#topic+scanone">scanone</a></code> was
run with <code>perm.Xsp=FALSE</code>, genome-wide LOD thresholds are given;
these are the 1-<code class="reqn">\alpha</code> quantiles of the genome-wide maximum LOD
scores from the permutations.
</p>
<p>If there were autosomal and X chromosome data and
<code><a href="#topic+scanone">scanone</a></code> was run with <code>perm.Xsp=TRUE</code>,
autosome- and X-chromsome-specific LOD thresholds are given, by the
method described in Broman et al. (2006).  Let <code class="reqn">L_A</code> and
<code class="reqn">L_X</code> be total the genetic lengths of the autosomes and X
chromosome, respectively, and let <code class="reqn">L_T = L_A + L_X</code>
Then in place of <code class="reqn">\alpha</code>, we use
</p>
<p style="text-align: center;"><code class="reqn">\alpha_A = 1 - (1-\alpha)^{L_A/L_T}</code>
</p>

<p>as the significance level for the autosomes and
</p>
<p style="text-align: center;"><code class="reqn">\alpha_X = 1 - (1-\alpha)^{L_X/L_T}</code>
</p>

<p>as the significance level for the X chromosome.  The result is a list
with two matrices, one for the autosomes and one for the X chromosome.
</p>
<p>If <code>controlAcrossCol=TRUE</code>, we use a trick to control the error
rate not just across the genome but also across the LOD score
columns.  Namely, we convert each column of permutation results to
ranks, and then for each permutation replicate we find the maximum
rank across the columns.  We then find the appropriate quantile of the
maximized ranks, and then backtrack to the corresponding LOD score
within each of the columns. See Burrage et al. (2010),
right column on page 118.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scanoneperm</code>, to be printed by
<code>print.summary.scanoneperm</code>.  If there were X chromosome data and
<code>scanone</code> was run with <code>perm.Xsp=TRUE</code>, there are two
matrices in the results, for the autosome and X-chromosome LOD
thresholds.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman KW, Sen &#346;, Owens SE, Manichaikul A,
Southard-Smith EM, Churchill GA (2006)  The X chromosome in
quantitative trait locus mapping.  <em>Genetics</em>, <b>174</b>, 2151&ndash;2158.
</p>
<p>Burrage LC, Baskin-Hill AE, Sinasac DS, Singer JB, Croniger CM, Kirby A,
Kulbokas EJ, Daly MJ, Lander ES, Broman KW, Nadeau JH (2010) Genetic
resistance to diet-induced obesity in chromosome substitution strains of
mice. <em>Mamm Genome</em>, <b>21</b>, 115&ndash;129.
</p>
<p>Churchill GA, Doerge RW (1994) Empirical threshold values for
quantitative trait mapping.  <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanone">scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>,
<code><a href="#topic+plot.scanoneperm">plot.scanoneperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=2.5)

operm1 &lt;- scanone(fake.f2, n.perm=100, method="hk")
summary(operm1)

operm2 &lt;- scanone(fake.f2, n.perm=100, method="hk", perm.Xsp=TRUE)
summary(operm2)

# Add noise column
fake.f2$pheno$noise &lt;- rnorm(nind(fake.f2))
operm3 &lt;- scanone(fake.f2, pheno.col=c("phenotype", "noise"), n.perm=10, method="hk")
summary(operm3)
summary(operm3, controlAcrossCol=TRUE, alpha=c(0.05, 0.36))
</code></pre>

<hr>
<h2 id='summary.scanPhyloQTL'>Summarize the results a genome scan to map a QTL to a phylogenetic tree</h2><span id='topic+summary.scanPhyloQTL'></span>

<h3>Description</h3>

<p>Print the maximum LOD scores for each partition on each chromosome,
from the results of <code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanPhyloQTL'
summary(object, format=c("postprob", "lod"),
        threshold, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scanPhyloQTL_+3A_object">object</code></td>
<td>
<p>An object output by the function
<code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scanPhyloQTL_+3A_format">format</code></td>
<td>
<p>Indicates whether to provide LOD scores or approximate
posterior probabilities; see Details below.</p>
</td></tr>
<tr><td><code id="summary.scanPhyloQTL_+3A_threshold">threshold</code></td>
<td>
<p>A threshold determining which chromosomes should be
output; see Details below.</p>
</td></tr>
<tr><td><code id="summary.scanPhyloQTL_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to report chromosomes deemed interesting from a one-QTL
genome scan to map QTL to a phylogenetic tree (by <code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>).
</p>
<p>For <code>format="lod"</code>, the output contains the maximum LOD score for
each partition on each chromosome (which do not necessarily occur at
the same position).  The position corresponds to the peak location for
the partition with the largest LOD score on that chromosome.  The
last column is the overall maximum LOD (across partitions) on that
chromosome.  The second-to-last column is the inferred partition
(i.e., that with the largest LOD
score.  The third-to-last column is the difference between the LOD score for
the best partition and that for the second-best.
</p>
<p>For <code>format="postprob"</code>, the final column contains the maximum
LOD score across partitions.  But instead of providing the LOD
scores for each partition, these are converted to approximate
posterior probabilities under the assumption of a single diallelic QTL
on that chromosome:  on each chromosome, we take
<code class="reqn">10^{LOD}</code> for the partitions and rescale them to sum to 1.
</p>
<p>The <code>threshold</code> argument is applied to the last column (the
maximum LOD score across partitions).
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scanPhyloQTL</code>, to be printed by
<code>print.summary.scanPhyloQTL</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Broman, K. W., Kim, S., An\'e, C. and Payseur, B. A.  Mapping
quantitative trait loci to a phylogenetic tree.  In preparation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scanPhyloQTL">scanPhyloQTL</a></code>, <code><a href="#topic+plot.scanPhyloQTL">plot.scanPhyloQTL</a></code>,
<code><a href="#topic+max.scanPhyloQTL">max.scanPhyloQTL</a></code>, <code><a href="#topic+summary.scanone">summary.scanone</a></code>,
<code><a href="#topic+inferredpartitions">inferredpartitions</a></code>,
<code><a href="#topic+simPhyloQTL">simPhyloQTL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example map; drop X chromosome
data(map10)
map10 &lt;- map10[1:19]

# simulate data
x &lt;- simPhyloQTL(4, partition="AB|CD", crosses=c("AB", "AC", "AD"),
                 map=map10, n.ind=150,
                 model=c(1, 50, 0.5, 0))

# run calc.genoprob on each cross
x &lt;- lapply(x, calc.genoprob, step=2)

# scan genome, at each position trying all possible partitions
out &lt;- scanPhyloQTL(x, method="hk")

# maximum peak
max(out, format="lod")

# approximate posterior probabilities at peak
max(out, format="postprob")

# all peaks above a threshold for LOD(best) - LOD(2nd best)
summary(out, threshold=1, format="lod")

# all peaks above a threshold for LOD(best), showing approx post'r prob
summary(out, format="postprob", threshold=3)

# plot of results
plot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.scantwo'>Summarize the results of a two-dimensional genome scan</h2><span id='topic+summary.scantwo'></span>

<h3>Description</h3>

<p>Summarize the interesting aspects of the results of <code><a href="#topic+scantwo">scantwo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwo'
summary(object, thresholds,
        what=c("best", "full", "add", "int"),
        perms, alphas, lodcolumn=1, pvalues=FALSE,
        allpairs=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scantwo_+3A_object">object</code></td>
<td>
<p>An object of class <code>scantwo</code>, the output of the
function <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_thresholds">thresholds</code></td>
<td>
<p>A vector of length 5, giving LOD thresholds
for the full, conditional-interactive, interaction, additive, and
conditional-additive LOD scores. See Details, below.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_what">what</code></td>
<td>
<p>Indicates for which LOD score the maximum should be
reported. See Details, below.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_perms">perms</code></td>
<td>
<p>Optional permutation results used to derive thresholds or
to calculate genome-scan-adjusted p-values.  This must be consistent
with the <code>object</code> input, in that it must have the same number of
LOD score columns, though it can have just one column of permutation
results, in which case they are assumed to apply to any chosen LOD
score column.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_alphas">alphas</code></td>
<td>
<p>If perms are included, these are the significance levels used
to calculate thresholds for determining which peaks to pull out.  It
should be a vector of length 5, giving significance levels
for the full, conditional-interactive, interaction, additive, and
conditional-additive LOD scores.  (It can also be a single number, in
which case it is assumed that the same value is used for all five LOD
scores.)  If <code>thresholds</code> is specified, <code>alphas</code> should not
be.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If the scantwo results contain LOD scores for
multiple phenotypes, this argument indicates which to use in the
summary.  Only one LOD score column may be considered at a time.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_pvalues">pvalues</code></td>
<td>
<p>If TRUE, include columns with genome-scan-adjusted
p-values in the results.  This requires that <code>perms</code> be
provided.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_allpairs">allpairs</code></td>
<td>
<p>If TRUE, all pairs of chromosomes are considered.  If
FALSE, only self-self pairs are considered, so that one may more
conveniently check for possible linked QTL.</p>
</td></tr>
<tr><td><code id="summary.scantwo_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>what="best"</code>, we calculate, for each pair of chromosomes, the
maximum LOD score for the full model (two QTL plus interaction) and
the maximum LOD score for the additive model.  The difference between
these is a LOD score for a test for interaction.  We also calculate
the difference between the maximum full LOD and the maximum single-QTL LOD
score for the two chromosomes; this is the LOD score for a test for a
second QTL, allowing for epistasis, which we call either the
conditional-interactive or &quot;fv1&quot; LOD score.  Finally,
we calculate the difference between the maximum additive LOD score and
the maximum single-QTL LOD score for the two chromosomes; this is the
LOD score for a test for a second QTL, assuming that the two QTL act
additively, which we call either the conditional-additive or &quot;av1&quot; LOD
score.  Note that the maximum full LOD and additive LOD are allowed to
occur in different places.
</p>
<p>If <code>what="full"</code>, we find the maximum full LOD and extract the
additive LOD at the corresponding pair of positions; we derive
the other three LOD scores for that fixed pair of positions.
</p>
<p>If <code>what="add"</code>, we find the maximum additive LOD and extract the
full LOD  at the corresponding pair of positions; we derive
the other three LOD scores for that fixed pair of positions.
</p>
<p>If <code>what="int"</code>, we find the pair of positions for which the
difference between the full and additive LOD scores is largest, and
then calculate the five LOD scores at that pair of positions.
</p>
<p>If <code>thresholds</code> or <code>alphas</code> is provided (and note that when
<code>alphas</code> is provided, <code>perms</code> must also), we extract just
those pairs of chromosomes for which either (a) the full LOD score
exceeds its thresholds and either the conditional-interactive LOD or
the interaction LOD exceed their threshold, or (b) the additive LOD
score exceeds its threshold and the conditional-additive LOD exceeds
its threshold.  The thresholds or alphas must be given in the order
full, cond-int, int, add, cond-add.
</p>
<p>Thresholds may be obtained by a permutation test with
<code><a href="#topic+scantwo">scantwo</a></code>, but these are extremely time-consuming.
For a mouse backcross, we suggest the thresholds (6.0, 4.7, 4.4, 4.7,
2.6) for the full, conditional-interactive, interaction, additive, and
conditional-additive LOD scores, respectively.
For a mouse intercross, we suggest the thresholds (9.1, 7.1, 6.3, 6.3,
3.3) for the full, conditional-interactive, interaction, additive, and
conditional-additive LOD scores, respectively.  These were obtained by
10,000 simulations of crosses with 250 individuals, markers at a 10 cM
spacing, and analysis by Haley-Knott regression.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scantwo</code>, to be printed by
<code>print.summary.scantwo</code>;
</p>


<h3>Output of addpair</h3>

<p><b>Note</b> that, for output from <code><a href="#topic+addpair">addpair</a></code> in which the
new loci are indicated explicitly in the formula, the summary provided
by <code>summary.scantwo</code> is somewhat special.
</p>
<p>All arguments except <code>allpairs</code> and <code>thresholds</code> (and, of
course, the input <code>object</code>) are ignored.
</p>
<p>If the formula is symmetric in the two new QTL, the output has just two LOD
score columns: <code>lod.2v0</code> comparing the full model to the model
with neither of the new QTL, and <code>lod.2v1</code> comparing the full
model to the model with just one new QTL.
</p>
<p>If the formula is <em>not</em> symmetric in the two new QTL, the output
has three LOD score columns: <code>lod.2v0</code> comparing the full model
to the model with neither of the new QTL, <code>lod.2v1b</code> comparing
the full model to the model in which the first of the new QTL is
omitted, and <code>lod.2v1a</code> comparing the full model to the model
with the second of the new QTL omitted.
</p>
<p>The <code>thresholds</code> argument should have length 1 or 2, rather than
the usual 5.  Rows will be retained if <code>lod.2v0</code> is greater than
<code>thresholds[1]</code> and <code>lod.2v1</code> (or either of <code>lod.2v1a</code>
or <code>lod.2v1b</code>) is greater than <code>thresholds[2]</code>.  (If a
single thresholds is given, we assume that <code>thresholds[2]==0</code>.)
</p>


<h3>The older version</h3>

<p>The previous version of this function is still available, though it is
now named <code><a href="#topic+summaryScantwoOld">summaryScantwoOld</a></code>.
</p>
<p>We much prefer the revised function.  However, while we are confident
that this function (and the permutations in
<code><a href="#topic+scantwo">scantwo</a></code>) are calculating the relevant statistics,
the appropriate significance levels for these relatively complex
series of statistical tests is not yet completely clear.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+plot.scantwo">plot.scantwo</a></code>,
<code><a href="#topic+max.scantwo">max.scantwo</a></code>, <code><a href="#topic+condense.scantwo">condense.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
out.2dim &lt;- scantwo(fake.f2, method="hk")

# All pairs of chromosomes
summary(out.2dim)

# Chromosome pairs meeting specified criteria
summary(out.2dim, thresholds=c(9.1, 7.1, 6.3, 6.3, 3.3))

# Similar, but ignoring the interaction LOD score in the rule
summary(out.2dim, thresholds=c(9.1, 7.1, Inf, 6.3, 3.3))

# Pairs having largest interaction LOD score, if it's &gt; 4
summary(out.2dim, thresholds=c(0, Inf, 4, Inf, Inf), what="int")

# permutation test to get thresholds; run in two batches
#     and then combined with c.scantwoperm
## Not run: operm.2dimA &lt;- scantwo(fake.f2, method="hk", n.perm=500)
operm.2dimB &lt;- scantwo(fake.f2, method="hk", n.perm=500)
operm.2dim &lt;- c(operm.2dimA, operm.2dimB)
## End(Not run)


# estimated LOD thresholds
summary(operm.2dim)

# Summary, citing significance levels and so estimating thresholds
#     from the permutation results
summary(out.2dim, perms=operm.2dim, alpha=rep(0.05, 5))

# Similar, but ignoring the interaction LOD score in the rule
summary(out.2dim, perms=operm.2dim, alpha=c(0.05, 0.05, 0, 0.05, 0.05))

# Similar, but also getting genome-scan-adjusted p-values
summary(out.2dim, perms=operm.2dim, alpha=c(0.05, 0.05, 0, 0.05, 0.05),
        pvalues=TRUE)
</code></pre>

<hr>
<h2 id='summary.scantwoperm'>LOD thresholds from scantwo permutation results</h2><span id='topic+summary.scantwoperm'></span>

<h3>Description</h3>

<p>Print the estimated genome-wide LOD thresholds on the basis of
permutation results from <code><a href="#topic+scantwo">scantwo</a></code> (with
<code>n.perm</code> &gt; 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scantwoperm'
summary(object, alpha=c(0.05, 0.10), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scantwoperm_+3A_object">object</code></td>
<td>
<p>Output from the function <code><a href="#topic+scantwo">scantwo</a></code>
with <code>n.perm</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="summary.scantwoperm_+3A_alpha">alpha</code></td>
<td>
<p>Genome-wide significance levels.</p>
</td></tr>
<tr><td><code id="summary.scantwoperm_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We take the <code class="reqn">1-\alpha</code> quantiles of the individual LOD
scores.
</p>
<p>In the case of X-chr-specific permutations, we use the combined length
of the autosomes, <code class="reqn">L_A</code>, and the length of the X chromosome,
<code class="reqn">L_X</code>, and calculate the area of the A:A, A:X, and X:X regions as
<code class="reqn">L_A^2/2</code>, <code class="reqn">L_A L_X</code>, and <code class="reqn">L_X^2/2</code>, and then use the
nominal significance levels of <code class="reqn">1 - (1-\alpha)^p</code>,
where <code class="reqn">p</code> is the proportional area for that region.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scantwoperm</code>, to be printed by
<code>print.summary.scantwoperm</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a></p>


<h3>References</h3>

<p>Churchill, G. A. and Doerge, R. W. (1994) Empirical threshold values for
quantitative trait mapping.  <em>Genetics</em> <b>138</b>, 963&ndash;971.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scantwo">scantwo</a></code>,
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+plot.scantwoperm">plot.scantwoperm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=0)

## Not run: operm &lt;- scantwo(fake.f2, n.perm=100, method="hk")
summary(operm)
</code></pre>

<hr>
<h2 id='summaryMap'>Print summary of a genetic map</h2><span id='topic+summary.map'></span><span id='topic+summaryMap'></span>

<h3>Description</h3>

<p>Print summary information about a <code>map</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
summary(object, ...)
summaryMap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryMap_+3A_object">object</code></td>
<td>
<p>An object of class <code>map</code>, which is a list of
vectors (or, for a sex-specific map, 2-row matrices), each specifying
the locations of the markers.  The object can also be of class
<code>cross</code>, in which case the function <code><a href="#topic+pull.map">pull.map</a></code>
is used to extract the genetic map from the object.</p>
</td></tr>
<tr><td><code id="summaryMap_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.map</code>, which is just a data.frame
containing the number of markers, length, the average inter-marker
spacing, and the maximum distance between markers, for each chromosome
and overall.  An attribute <code>sexsp</code> indicates whether the map was
sex-specific.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+chrlen">chrlen</a></code>, <code><a href="#topic+pull.map">pull.map</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map10)
summary(map10)
</code></pre>

<hr>
<h2 id='summaryScantwoOld'>Summarize the results of a two-dimensional genome scan</h2><span id='topic+summaryScantwoOld'></span>

<h3>Description</h3>

<p>Summarize the interesting aspects of the results of
<code><a href="#topic+scantwo">scantwo</a></code>; this is the version of
<code><a href="#topic+summary.scantwo">summary.scantwo</a></code> that was included in R/qtl version
1.03 and earlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryScantwoOld(object, thresholds = c(0, 0, 0), lodcolumn=1,
                type = c("joint","interaction"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryScantwoOld_+3A_object">object</code></td>
<td>
<p>An object of class <code>scantwo</code>, the output of the
function <code><a href="#topic+scantwo">scantwo</a></code>.</p>
</td></tr>
<tr><td><code id="summaryScantwoOld_+3A_thresholds">thresholds</code></td>
<td>
<p>A vector of length three, giving LOD thresholds
for the joint LOD, interaction LOD and single-QTL conditional
LOD. Negative threshold values are taken relative to the maximum
joint, interaction, or individual QTL LOD, respectively.</p>
</td></tr>
<tr><td><code id="summaryScantwoOld_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>If the scantwo results contain LOD scores for
multiple phenotypes, this argument indicates which to use in the
summary.</p>
</td></tr>
<tr><td><code id="summaryScantwoOld_+3A_type">type</code></td>
<td>
<p>Indicates whether to pick peaks with maximal joint or
interaction LOD.</p>
</td></tr>
<tr><td><code id="summaryScantwoOld_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of chromosomes, the pair of loci for which the
LOD score (either joint or interaction LOD, according to the argument
<code>type</code>) is a maximum is considered.  The pair is printed only if
its joint LOD score exceeds the joint threshold and either (a) the
interaction LOD score exceeds its threshold or (b) both of the loci have
conditional LOD scores that are above the conditional LOD threshold,
where the conditional LOD score for locus <code class="reqn">q_1</code>, <code class="reqn">LOD(q_1
    | q_2)</code>, is the <code class="reqn">\log_{10}</code> likelihood ratio
comparing the model with <code class="reqn">q_1</code> and <code class="reqn">q_2</code> acting
additively to the model with <code class="reqn">q_2</code> alone.
</p>
<p>In the case the results of <code><a href="#topic+scanone">scanone</a></code> are not
available, the maximum locus pair for each chromosome is printed
whenever its joint LOD exceeds the joint LOD threshold.
</p>
<p>The criterion used in this summary is due to Gary Churchill and &#346;aunak
Sen, and deserves careful consideration and possible revision.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scantwo.old</code>, to be printed by
<code>print.summary.scantwo.old</code>.  Pairs of loci meeting
the specified criteria are printed, with their joint LOD, interaction
LOD, and the conditional LOD for each locus, along with single-point
P-values calculated by the <code class="reqn">\chi^2</code> approximation.
P-values are printed as <code class="reqn">-\log_{10}(P)</code>. <br />
</p>
<p>If the input <code>scantwo</code> object does not include the results of
<code>scanone</code>, the interaction and conditional LOD thresholds are
ignored, and all pairs of loci for which the joint LOD exceeds its
threshold are printed, though without their conditional LOD scores.
</p>


<h3>Author(s)</h3>

<p>Hao Wu; Karl W Broman,
<a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Brian Yandell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.scantwo">summary.scantwo</a></code>,
<code><a href="#topic+scantwo">scantwo</a></code>, <code><a href="#topic+plot.scantwo">plot.scantwo</a></code>,
<code><a href="#topic+max.scantwo">max.scantwo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)

fake.f2 &lt;- calc.genoprob(fake.f2, step=5)
out.2dim &lt;- scantwo(fake.f2, method="hk")

# All pairs of loci
summaryScantwoOld(out.2dim)

# Pairs meeting specified criteria
summaryScantwoOld(out.2dim, c(7, 3, 3))

# Pairs with both conditional LODs &gt; 2
summaryScantwoOld(out.2dim,c(0,1000,2))

# Pairs with interaction LOD is above 3
summaryScantwoOld(out.2dim,c(0,3,1000))
</code></pre>

<hr>
<h2 id='switch.order'>Switch the order of markers on a chromosome</h2><span id='topic+switch.order'></span>

<h3>Description</h3>

<p>Switch the order of markers on a specified chromosome to a specified
new order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch.order(cross, chr, order, error.prob=0.0001,
                    map.function=c("haldane","kosambi","c-f","morgan"),
                    maxit=4000, tol=1e-6, sex.sp=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch.order_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="switch.order_+3A_chr">chr</code></td>
<td>
<p>The chromosome for which the marker order is to be
switched. Only one chromosome is allowed. (This should be a character
string referring to the chromosomes by name.)</p>
</td></tr>
<tr><td><code id="switch.order_+3A_order">order</code></td>
<td>
<p>A vector of numeric indices defining the new marker
order. The vector may have length two more than the number of
markers, for easy in use with the output of the function
<code><a href="#topic+ripple">ripple</a></code>.</p>
</td></tr>
<tr><td><code id="switch.order_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate (passed to
<code><a href="#topic+est.map">est.map</a></code>).</p>
</td></tr>
<tr><td><code id="switch.order_+3A_map.function">map.function</code></td>
<td>
<p>Map function to be used (passed to
<code><a href="#topic+est.map">est.map</a></code>).</p>
</td></tr>
<tr><td><code id="switch.order_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="switch.order_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="switch.order_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> object, but with the marker order on the
specified chromosome updated, and with any derived data removed
(except for recombination fractions, if present, which are not
removed);  the genetic map for the relevant chromosome is
re-estimated.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+flip.order">flip.order</a></code>, <code><a href="#topic+ripple">ripple</a></code>, <code><a href="#topic+clean.cross">clean.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
fake.f2 &lt;- switch.order(fake.f2, 1, c(1,3,2,4:7))
</code></pre>

<hr>
<h2 id='switchAlleles'>Switch alleles at selected markers</h2><span id='topic+switchAlleles'></span>

<h3>Description</h3>

<p>Switch alleles at selected markers in a cross object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchAlleles(cross, markers, switch=c("AB", "CD", "ABCD", "parents"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switchAlleles_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="switchAlleles_+3A_markers">markers</code></td>
<td>
<p>Names of markers whose alleles are to be switched.</p>
</td></tr>
<tr><td><code id="switchAlleles_+3A_switch">switch</code></td>
<td>
<p>For a 4-way cross, indicates how to switch the alleles (A
for B, C for D, both A for B and C for D), or both A for C and B for D (<code>parents</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a backcross, we exchange homozygotes (AA) and heterozygotes (AB).
</p>
<p>For doubled haploids and recombinant inbred lines, we
exchange the two homozygotes.
</p>
<p>For an intercross, we exchange the two homozygotes, and exchange C
(i.e., not AA) and D (i.e., not BB). (The heterozygotes in an intercross are
left unchanged.)
</p>
<p>For a 4-way cross, we consider the argument <code>switch</code>, and the
exchanges among the genotypes are more complicated.
</p>


<h3>Value</h3>

<p>The input cross object, with alleles at selected markers switched.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+checkAlleles">checkAlleles</a></code>, <code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+geno.crosstab">geno.crosstab</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
geno.crosstab(fake.f2, "D5M391", "D5M81")

# switch homozygotes at marker D5M391
fake.f2 &lt;- switchAlleles(fake.f2, "D5M391")

geno.crosstab(fake.f2, "D5M391", "D5M81")

## Not run: fake.f2 &lt;- est.rf(fake.f2)
checkAlleles(fake.f2)

## End(Not run)
</code></pre>

<hr>
<h2 id='table2map'>Convert a table of marker positions to a map object.</h2><span id='topic+table2map'></span>

<h3>Description</h3>

<p>Convert a data frame with marker positions to a map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table2map(tab)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table2map_+3A_tab">tab</code></td>
<td>
<p>A data frame with two columns: chromosome and position.
The row names are the marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>map</code> object: a list whose components (corresponding
to chromosomes) are vectors of marker positions.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+map2table">map2table</a></code>, <code><a href="#topic+pull.map">pull.map</a></code>, <code><a href="#topic+est.map">est.map</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- data.frame(chr=c(1,1,1,1,2,2,2,2,3,3,3,3),
                  pos=c(0,2,4,8,0,2,4,8,0,2,4,8))
rownames(tab) &lt;- paste0("marker", 1:nrow(tab))

map &lt;- table2map(tab)
</code></pre>

<hr>
<h2 id='top.errorlod'>List genotypes with large error LOD scores</h2><span id='topic+top.errorlod'></span>

<h3>Description</h3>

<p>Prints those genotypes with error LOD scores above a specified
cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.errorlod(cross, chr, cutoff=4, msg=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top.errorlod_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="top.errorlod_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character strings referring to chromosomes
by name; numeric values are converted to strings.  Refer to
chromosomes with a preceding <code>-</code> to have all chromosomes but
those considered.  A logical (TRUE/FALSE) vector may also be used.</p>
</td></tr>
<tr><td><code id="top.errorlod_+3A_cutoff">cutoff</code></td>
<td>
<p>Only those genotypes with error LOD scores above this
cutoff will be listed.</p>
</td></tr>
<tr><td><code id="top.errorlod_+3A_msg">msg</code></td>
<td>
<p>If TRUE, print a message if there are no apparent errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with 4 columns, whose rows correspond to the genotypes
that are possibly in error.  The four columns give the chromosome
number, individual number, marker name, and error LOD score.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.errorlod">calc.errorlod</a></code>, <code><a href="#topic+plotGeno">plotGeno</a></code>, <code><a href="#topic+plotErrorlod">plotErrorlod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

# Calculate error LOD scores
hyper &lt;- calc.errorlod(hyper,error.prob=0.01)

# Print those above a specified cutoff
top.errorlod(hyper,cutoff=4)
</code></pre>

<hr>
<h2 id='totmar'>Determine the total number of markers</h2><span id='topic+totmar'></span>

<h3>Description</h3>

<p>Determine the total number of markers in a cross
or map object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totmar(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="totmar_+3A_object">object</code></td>
<td>
<p>An object of class <code>cross</code> (see
<code><a href="#topic+read.cross">read.cross</a></code> for details) or <code>map</code> (see
<code><a href="#topic+sim.map">sim.map</a></code> for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total number of markers in the input.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code>, <code><a href="#topic+plot.cross">plot.cross</a></code>,
<code><a href="#topic+summary.cross">summary.cross</a></code>,
<code><a href="#topic+nind">nind</a></code>,
<code><a href="#topic+nchr">nchr</a></code>,
<code><a href="#topic+nmar">nmar</a></code>,
<code><a href="#topic+nphe">nphe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.f2)
totmar(fake.f2)
map &lt;- pull.map(fake.f2)
totmar(map)
</code></pre>

<hr>
<h2 id='transformPheno'>Transformation of the phenotypes in a cross object</h2><span id='topic+transformPheno'></span>

<h3>Description</h3>

<p>Transform phenotypes in a cross object; by default use a logarithmic
transformation, though any function may be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformPheno(cross, pheno.col=1, transf=log, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformPheno_+3A_cross">cross</code></td>
<td>

<p>An object of class <code>cross</code>. See <code><a href="#topic+read.cross">read.cross</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="transformPheno_+3A_pheno.col">pheno.col</code></td>
<td>

<p>A vector of numeric indices or character strings (indicating phenotypes by
name) of phenotypes to be transformed.
</p>
</td></tr>
<tr><td><code id="transformPheno_+3A_transf">transf</code></td>
<td>
<p>The function to use in the transformation.</p>
</td></tr>
<tr><td><code id="transformPheno_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to <code>transf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input cross object with the transformed phenotypes
</p>


<h3>Author(s)</h3>

<p>Danny Arends <a href="mailto:danny.arends@gmail.com">danny.arends@gmail.com</a> 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mqmscan">mqmscan</a></code>, <code><a href="#topic+scanone">scanone</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(multitrait)

# Log transformation of all phenotypes
multitrait.log &lt;- transformPheno(multitrait, pheno.col=1:nphe(multitrait))

# Square-root transformation of all phenotypes
multitrait.sqrt &lt;- transformPheno(multitrait, pheno.col=1:nphe(multitrait),
                                  transf=sqrt)
</code></pre>

<hr>
<h2 id='tryallpositions'>Test all possible positions for a marker</h2><span id='topic+tryallpositions'></span>

<h3>Description</h3>

<p>Try all possible positions for a marker, keeping all other markers
fixed, and evaluate the log likelihood and estimate the chromosome
length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryallpositions(cross, marker, chr, error.prob=0.0001,
                map.function=c("haldane","kosambi","c-f","morgan"),
                m=0, p=0, maxit=4000, tol=1e-6, sex.sp=TRUE,
                verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tryallpositions_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_marker">marker</code></td>
<td>
<p>Character string with name of the marker to move about.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_chr">chr</code></td>
<td>
<p>A vector specifying which chromosomes to test for the
position of the marker.    This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_error.prob">error.prob</code></td>
<td>
<p>Assumed genotyping error rate used in the calculation
of the penetrance Pr(observed genotype | true genotype).</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_map.function">map.function</code></td>
<td>
<p>Indicates whether to use the Haldane, Kosambi,
Carter-Falconer, or Morgan map function when converting genetic
distances into recombination fractions. (Ignored if m &gt; 0.)</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_m">m</code></td>
<td>
<p>Interference parameter for the chi-square model for
interference; a non-negative integer, with m=0 corresponding to no
interference. This may be used only for a backcross or intercross.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata from the NI mechanism, in the Stahl
model; p=0 gives a pure chi-square model.  This may be used only for
a backcross or intercross.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of EM iterations to perform.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_sex.sp">sex.sp</code></td>
<td>
<p>Indicates whether to estimate sex-specific maps; this is
used only for the 4-way cross.</p>
</td></tr>
<tr><td><code id="tryallpositions_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print information on progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (actually, an object of class <code>"scanone"</code>, so that
one may use <code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+summary.scanone">summary.scanone</a></code>, etc.) with each row being a
possible position for the marker.
The first two columns are the chromosome ID and position.  The third
column is a LOD score comparing the hypotheses that the marker is in that
position versus the hypothesis that it is not linked to that chromosome.
</p>
<p>In the case of a 4-way cross, with <code>sex.sp=TRUE</code>, there are two
additional columns with the estimated female and male genetic lengths
of the respective chromosome, when the marker is in that position.
With <code>sex.sp=FALSE</code>, or for other types of crosses, there is one
additional column, with the estimated genetic length of the respective
chromosome, when the marker is in that position.
</p>
<p>The row names indicate the nearest flanking markers for each interval.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+droponemarker">droponemarker</a></code>, <code><a href="#topic+est.map">est.map</a></code>, <code><a href="#topic+ripple">ripple</a></code>,
<code><a href="#topic+est.rf">est.rf</a></code>, <code><a href="#topic+switch.order">switch.order</a></code>,
<code><a href="#topic+movemarker">movemarker</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fake.bc)
tryallpositions(fake.bc, "D7M301", 7, error.prob=0, verbose=FALSE)
</code></pre>

<hr>
<h2 id='typingGap'>Maximum distance between genotyped markers</h2><span id='topic+typingGap'></span>

<h3>Description</h3>

<p>Calculates, for each individual on each chromosome, the maximum
distance between genotyped markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typingGap(cross, chr, terminal=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="typingGap_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>.  See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="typingGap_+3A_chr">chr</code></td>
<td>
<p>Optional vector indicating the chromosomes to consider.
This should be a vector of character
strings referring to chromosomes by name; numeric values are
converted to strings.  Refer to chromosomes with a preceding <code>-</code>
to have all chromosomes but those considered.  A logical (TRUE/FALSE)
vector may also be used.</p>
</td></tr>
<tr><td><code id="typingGap_+3A_terminal">terminal</code></td>
<td>
<p>If TRUE, just look at terminal typing gaps (from the
terminal markers to the first typed marker).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider not just the distances between internal genotypes, but
also distances from the beginning of the chromosome to the first typed
marker, and similarly for the end of the chromosome.  (The start and end
of a chromosome are taken to be the locations of the initial and final
markers.)  If <code>terminal=TRUE</code>, we look only at those beginning
and end distances.
</p>


<h3>Value</h3>

<p>A matrix with rows corresponding to individuals and columns
corresponding to chromosomes.  (If there is just one chromosome, it is
a numeric vector rather than a matrix.)
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ntyped">ntyped</a></code>,
<code><a href="#topic+nmissing">nmissing</a></code>, <code><a href="#topic+locateXO">locateXO</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)
plot(typingGap(hyper, chr=5),
     ylab="Maximum gap between typed markers (cM)",
     ylim=c(0, diff(range(pull.map(hyper,chr=5)[[1]]))))

plot(typingGap(hyper, chr=4),
     ylab="Maximum gap between typed markers (cM)",
     ylim=c(0, diff(range(pull.map(hyper,chr=4)[[1]]))))

plot(typingGap(hyper, chr=4, terminal=TRUE),
     ylab="Maximum gap between chr end and typed marker (cM)",
     ylim=c(0, diff(range(pull.map(hyper,chr=4)[[1]]))))
</code></pre>

<hr>
<h2 id='write.cross'>Write data for a QTL experiment to a file</h2><span id='topic+write.cross'></span>

<h3>Description</h3>

<p>Data for a QTL experiment is written to a file (or files).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.cross(cross, format=c("csv", "csvr", "csvs", "csvsr",
                            "mm", "qtlcart", "gary", "qtab",
                            "mapqtl", "tidy"),
            filestem="data", chr, digits=NULL, descr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.cross_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>cross</code>. See
<code><a href="#topic+read.cross">read.cross</a></code> for details.</p>
</td></tr>
<tr><td><code id="write.cross_+3A_format">format</code></td>
<td>
<p>Specifies whether to write the data in comma-delimited,
rotated comma-delimited, Mapmaker, QTL Cartographer, Gary
Churchill's, QTAB, MapQTL format.</p>
</td></tr>
<tr><td><code id="write.cross_+3A_filestem">filestem</code></td>
<td>
<p>A character string giving the first part of the output
file names (the bit before the dot).  In Windows, use forward
slashes (<code>"/"</code>) or double backslashes (<code>"\\"</code>) to
specify directory trees.</p>
</td></tr>
<tr><td><code id="write.cross_+3A_chr">chr</code></td>
<td>
<p>A vector specifying for which chromosomes genotype data
should be written.  This should be a vector of character strings
referring to chromosomes by name; numeric values are converted to
strings.  Refer to chromosomes with a preceding <code>-</code> to have all
chromosomes but those considered.  A logical (TRUE/FALSE) vector may
also be used.</p>
</td></tr>
<tr><td><code id="write.cross_+3A_digits">digits</code></td>
<td>
<p>Number of digits to which phenotype values and genetic
map positions should be rounded. If NULL (the default), they are
not rounded.</p>
</td></tr>
<tr><td><code id="write.cross_+3A_descr">descr</code></td>
<td>
<p>Character string description; used only with <code>format="qtab"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comma-delimited formats: a single csv file is created in the formats
<code>"csv"</code> or <code>"csvr"</code>. Two files are created (one for the
genotype data and one for the phenotype data) for the formats
<code>"csvs"</code> and <code>"csvsr"</code>; if <code>filestem="file"</code>, the two
files will be names <code>"file_gen.csv"</code> and <code>"file_phe.csv"</code>.
See the help file for <code><a href="#topic+read.cross">read.cross</a></code> for details on these formats.
</p>
<p>Mapmaker format: Data is written to two files.
Suppose <code>filestem="file"</code>.  Then <code>"file.raw"</code> will contain
the genotype and phenotype data, and <code>"file.prep"</code> will contain
the necessary code for defining the chromosome assignments, marker
order, and inter-marker distances.
</p>
<p>QTL Cartographer format: Data is written to two files.    Suppose
<code>filestem="file"</code>.  Then <code>"file.cro"</code> will contain
the genotype and phenotype data, and <code>"file.map"</code> will contain
the genetic map information.  Note that cross types are converted to
QTL Cartographer cross types as follows: riself to RF1, risib to RF2,
bc to B1 and f2 to RF2.
</p>
<p>Gary's format: Data is written to six files. They are: <br />
<code>"geno.data"</code> - genotype data; <br />
<code>"pheno.data"</code> - phenotype data; <br />
<code>"chrid.dat"</code> - the chromosome identifier for each marker; <br />
<code>"mnames.txt"</code> - the marker names; <br />
<code>"markerpos.txt"</code> - the marker positions; <br />
<code>"pnames.txt"</code> - the phenotype names
</p>
<p>QTAB format: See
<a href="https://github.com/qtlHD/qtlHD/blob/master/doc/input/qtab.md">documentation</a>.
</p>
<p>MapQTL format: See
<a href="https://www.kyazma.nl/docs/MQ7Manual.pdf">documentation</a>.
</p>
<p>Tidy format: Data is written to three files, <code>"stem_gen.csv"</code>,
<code>"stem_phe.csv"</code>, and <code>"stem_map.csv"</code> (where <code>stem</code> is
taken from the <code>filestem</code> argument.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>; Hao Wu; Brian
S. Yandell; Danny Arends; Aaron Wolen</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.cross">read.cross</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(fake.bc)

# comma-delimited format
write.cross(fake.bc, "csv", "Data/fakebc", c(1,5,13))

# rotated comma-delimited format
write.cross(fake.bc, "csvr", "Data/fakebc", c(1,5,13))

# split comma-delimited format
write.cross(fake.bc, "csvs", "Data/fakebc", c(1,5,13))

# split and rotated comma-delimited format
write.cross(fake.bc, "csvsr", "Data/fakebc", c(1,5,13))

# Mapmaker format
write.cross(fake.bc, "mm", "Data/fakebc", c(1,5,13))

# QTL Cartographer format
write.cross(fake.bc, "qtlcart", "Data/fakebc", c(1,5,13))

# Gary's format
write.cross(fake.bc, "gary", c(1,5,13))
## End(Not run) </code></pre>

<hr>
<h2 id='xaxisloc.scanone'>Get x-axis locations in scanone plot</h2><span id='topic+xaxisloc.scanone'></span>

<h3>Description</h3>

<p>Get x-axis locations for given cM positions on given chromosomes in a
plot from <code><a href="#topic+plot.scanone">plot.scanone</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xaxisloc.scanone(out, thechr, thepos, chr, gap=25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xaxisloc.scanone_+3A_out">out</code></td>
<td>
<p>An object of class <code>"scanone"</code>, as output by
<code><a href="#topic+scanone">scanone</a></code>.  This must be identical to what was used
in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="xaxisloc.scanone_+3A_thechr">thechr</code></td>
<td>
<p>Chromosome IDs at which x-axis locations are to be determined.</p>
</td></tr>
<tr><td><code id="xaxisloc.scanone_+3A_thepos">thepos</code></td>
<td>
<p>Chromosome positions at which x-axis locations are to be
determined.</p>
</td></tr>
<tr><td><code id="xaxisloc.scanone_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes were plotted.
This must be identical to what was used in the call to
<code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
<tr><td><code id="xaxisloc.scanone_+3A_gap">gap</code></td>
<td>
<p>Gap separating chromosomes (in cM).  This must be identical
to what was used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to identify the x-axis locations in a plot of
genome scan results, produced by
<code><a href="#topic+plot.scanone">plot.scanone</a></code>.  This is useful for adding
annotations, such as text or arrows.
</p>
<p>The arguments <code>out</code>, <code>chr</code>, and <code>gap</code> must match what
was used in the call to <code><a href="#topic+plot.scanone">plot.scanone</a></code>.
</p>
<p>The arguments <code>thechr</code> and <code>thepos</code> indicate the genomic
positions for which x-axis locations are desired.  If they both have
length &gt; 1, they must have the same length.  If one has length &gt; 1 and
one has length 1, the one with length 1 is expanded to match.
</p>


<h3>Value</h3>

<p>A numeric vector of x-axis locations.</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.scanone">plot.scanone</a></code>,
<code><a href="#topic+add.threshold">add.threshold</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyper)

hyper &lt;- calc.genoprob(hyper)
out &lt;- scanone(hyper, method="hk")
plot(out, chr=c(1, 4, 6, 15))

# add arrow and text to indicate peak LOD score
mxout &lt;- max(out)
x &lt;- xaxisloc.scanone(out, mxout$chr, mxout$pos, chr=c(1,4,6,15))
arrows(x+30, mxout$lod, x+5, mxout$lod, len=0.1, col="blue")
text(x+35, mxout$lod, "the peak", col="blue", adj=c(0, 0.5))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
