<!DOCTYPE html><html><head><title>Help for package peptoolkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {peptoolkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#appearance_to_binary'><p>Transform Amino Acid Appearance Probability into -1, 0, or 1</p></a></li>
<li><a href='#count_aa'><p>Count Amino Acids</p></a></li>
<li><a href='#extract_features_OHE'><p>Extract One-Hot Encoded (OHE) Features from Peptide Sequences</p></a></li>
<li><a href='#extract_features_QSAR'><p>Extract QSAR Features from Peptide Sequences</p></a></li>
<li><a href='#filter_residues'><p>Filter Peptides by Residue Counts</p></a></li>
<li><a href='#increment'><p>Increment Peptide Sequences</p></a></li>
<li><a href='#reduce_sequences'><p>Reduce Peptide Sequences by One Residue</p></a></li>
<li><a href='#select_best_vs_worst'><p>Select Best vs Worst Peptides</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolkit for Using Peptide Sequences in Machine Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>This toolkit is designed for manipulation and analysis of peptides. It provides functionalities to assist researchers in peptide engineering and proteomics. Users can manipulate peptides by adding amino acids at every position, count occurrences of each amino acid at each position, and transform amino acid counts based on probabilities. The package offers functionalities to select the best versus the worst peptides and analyze these peptides, which includes counting specific residues, reducing peptide sequences, extracting features through One Hot Encoding (OHE), and utilizing Quantitative Structure-Activity Relationship (QSAR) properties (based in the package 'Peptides' by Osorio et al. (2015) &lt;<a href="https://doi.org/10.32614%2FRJ-2015-001">doi:10.32614/RJ-2015-001</a>&gt;). This package is intended for both researchers and bioinformatics enthusiasts working on peptide-based projects, especially for their use with machine learning.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Peptides, stats, dplyr, stringr, caret</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jrcodina/peptoolkit">https://github.com/jrcodina/peptoolkit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jrcodina/peptoolkit/issues">https://github.com/jrcodina/peptoolkit/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-13 14:18:54 UTC; Josep</td>
</tr>
<tr>
<td>Author:</td>
<td>Josep-Ramon Codina
    <a href="https://orcid.org/0000-0003-4391-450X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josep-Ramon Codina &lt;jrc356@miami.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-13 15:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='appearance_to_binary'>Transform Amino Acid Appearance Probability into -1, 0, or 1</h2><span id='topic+appearance_to_binary'></span>

<h3>Description</h3>

<p>This function transforms the counts of amino acids to a -1, 0, 1 matrix
based on a probability of appearance of each peptide in each position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appearance_to_binary(x, threshold = 1.65, group = "Best", percentage = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appearance_to_binary_+3A_x">x</code></td>
<td>
<p>A data frame containing peptide sequences.</p>
</td></tr>
<tr><td><code id="appearance_to_binary_+3A_threshold">threshold</code></td>
<td>
<p>The probability threshold to determine the transformation.</p>
</td></tr>
<tr><td><code id="appearance_to_binary_+3A_group">group</code></td>
<td>
<p>A character string indicating which part of the data to consider. Either 'Best' or 'Worst'.</p>
</td></tr>
<tr><td><code id="appearance_to_binary_+3A_percentage">percentage</code></td>
<td>
<p>The percentage of the data to consider, if group is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same dimensions as the input where each cell
has been transformed to -1, 0, or 1 based on the probability threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a mock data frame
peptide_data &lt;- data.frame(Sequence = c("ACGT", "TGCA", "GATC", "CGAT"))

# Apply the function to the mock data
appearance_to_binary(peptide_data, group = "Best", percentage = 0.5)
</code></pre>

<hr>
<h2 id='count_aa'>Count Amino Acids</h2><span id='topic+count_aa'></span>

<h3>Description</h3>

<p>This function counts the occurrence of each of the 20 amino acids
at each of the first 'n' positions across a vector of peptide sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_aa(peptides, n = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_aa_+3A_peptides">peptides</code></td>
<td>
<p>A character vector of peptide sequences.</p>
</td></tr>
<tr><td><code id="count_aa_+3A_n">n</code></td>
<td>
<p>The number of initial positions to consider in each peptide sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 'n' rows and 20 columns where each row represents a position
in the peptide sequence and each column represents an amino acid. Each cell
in the data frame contains the count of a particular amino acid at a particular position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_aa(c("ACDF", "BCDE", "ABCD"), n = 2)
</code></pre>

<hr>
<h2 id='extract_features_OHE'>Extract One-Hot Encoded (OHE) Features from Peptide Sequences</h2><span id='topic+extract_features_OHE'></span>

<h3>Description</h3>

<p>This function takes a data frame or a vector of peptide sequences and generates
a one-hot encoded data frame representing each amino acid in the sequences.
It can also include additional data (such as docking information), if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_features_OHE(df, sequence_col = "Sequence", docking_col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_features_OHE_+3A_df">df</code></td>
<td>
<p>A data frame or a vector of peptide sequences.</p>
</td></tr>
<tr><td><code id="extract_features_OHE_+3A_sequence_col">sequence_col</code></td>
<td>
<p>A string representing the name of the column containing the peptide sequences.</p>
</td></tr>
<tr><td><code id="extract_features_OHE_+3A_docking_col">docking_col</code></td>
<td>
<p>A string representing the name of the column containing the docking information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing one-hot encoded peptide sequences and, if provided, docking information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load required library caret
library(caret)
# Generate a mock data frame of peptide sequences
df &lt;- data.frame(Sequence = c("AVILG", "VILGA", "ILGAV", "LGAVI"), X = c(1,1,2,3))
# Apply the function to the mock data
extract_features_OHE(df)
</code></pre>

<hr>
<h2 id='extract_features_QSAR'>Extract QSAR Features from Peptide Sequences</h2><span id='topic+extract_features_QSAR'></span>

<h3>Description</h3>

<p>This function extracts various Quantitative Structure-Activity Relationship (QSAR) features
from peptide sequences. The extraction is based on a variety of amino acid properties
and functions from the &quot;Peptides&quot; package (https://github.com/dosorio/Peptides/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_features_QSAR(
  n,
  pH = 7.4,
  custom.list = FALSE,
  PeList = NULL,
  rem.cys = FALSE,
  rem.met = FALSE,
  rem.sali = FALSE,
  norm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_features_QSAR_+3A_n">n</code></td>
<td>
<p>The length of the peptide sequences.Must be more than 2.</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_ph">pH</code></td>
<td>
<p>The pH used for calculating charge (default is 7.4).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_custom.list">custom.list</code></td>
<td>
<p>A boolean indicating if a custom peptide list is provided (default is FALSE).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_pelist">PeList</code></td>
<td>
<p>The custom list of peptides (required if custom.list is TRUE).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_rem.cys">rem.cys</code></td>
<td>
<p>A boolean indicating if sequences with Cys should be removed (default is FALSE).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_rem.met">rem.met</code></td>
<td>
<p>A boolean indicating if sequences with Met should be removed (default is FALSE).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_rem.sali">rem.sali</code></td>
<td>
<p>A boolean indicating if sequences with 2 or more small aliphatic amino acids should be removed (default is FALSE).</p>
</td></tr>
<tr><td><code id="extract_features_QSAR_+3A_norm">norm</code></td>
<td>
<p>A boolean indicating if the data should be normalized (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the calculated peptide properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_features_QSAR(n = 3, custom.list = TRUE, PeList = c('ACA', 'ADE'))
</code></pre>

<hr>
<h2 id='filter_residues'>Filter Peptides by Residue Counts</h2><span id='topic+filter_residues'></span>

<h3>Description</h3>

<p>This function counts the number of specified residues in each peptide sequence
and filters out the ones with more than the specified limit. It's defaults is
for filtering out small alliphatic residues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_residues(
  df,
  sequence_col = "Sequence",
  residues = c("A", "V", "I", "L", "G"),
  max_residues = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_residues_+3A_df">df</code></td>
<td>
<p>A data frame containing peptide sequences.</p>
</td></tr>
<tr><td><code id="filter_residues_+3A_sequence_col">sequence_col</code></td>
<td>
<p>The name of the column that contains the sequences.</p>
</td></tr>
<tr><td><code id="filter_residues_+3A_residues">residues</code></td>
<td>
<p>A character vector of residues to count.</p>
</td></tr>
<tr><td><code id="filter_residues_+3A_max_residues">max_residues</code></td>
<td>
<p>The maximum number of allowed residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a mock data frame
peptide_data &lt;- data.frame(Sequence = c("AVILG", "VILGA", "ILGAV", "LGAVI"))
# Apply the function to the mock data
filter_residues(peptide_data, residues = c("A", "V", "I", "L", "G"), max_residues = 2)
</code></pre>

<hr>
<h2 id='increment'>Increment Peptide Sequences</h2><span id='topic+increment'></span>

<h3>Description</h3>

<p>This function generates new peptide sequences by adding each of the 20 amino acids
to each position of the input peptide or peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increment(peptides, num_added = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment_+3A_peptides">peptides</code></td>
<td>
<p>A character vector of peptide sequences.</p>
</td></tr>
<tr><td><code id="increment_+3A_num_added">num_added</code></td>
<td>
<p>The number of amino acids to be added to each position of the peptide.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of new peptide sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>increment(c("AC", "DE"))
increment("ACDE", num_added = 2)
</code></pre>

<hr>
<h2 id='reduce_sequences'>Reduce Peptide Sequences by One Residue</h2><span id='topic+reduce_sequences'></span>

<h3>Description</h3>

<p>This function takes a vector of peptide sequences and generates all possible
sequences by removing one amino acid residue at a time. It can also associate each
sequence with an ID, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_sequences(peptides, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_sequences_+3A_peptides">peptides</code></td>
<td>
<p>A character vector of peptide sequences.</p>
</td></tr>
<tr><td><code id="reduce_sequences_+3A_id">id</code></td>
<td>
<p>A character vector of IDs that correspond to the peptides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, each containing all possible sequences resulting
from removing one amino acid from the original sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a mock vector of peptide sequences
peptides &lt;- c("AVILG", "VILGA", "ILGAV", "LGAVI")
# Apply the function to the mock data
reduce_sequences(peptides)
</code></pre>

<hr>
<h2 id='select_best_vs_worst'>Select Best vs Worst Peptides</h2><span id='topic+select_best_vs_worst'></span>

<h3>Description</h3>

<p>This function identifies the peptides from the function *appearance_to_binary*
that are 1 in one group and 0 or -1 in another group, and expands the grid
to all possible combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_best_vs_worst(appearance_best, appearance_worst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_best_vs_worst_+3A_appearance_best">appearance_best</code></td>
<td>
<p>A matrix with transformed counts for the 'best' group.</p>
</td></tr>
<tr><td><code id="select_best_vs_worst_+3A_appearance_worst">appearance_worst</code></td>
<td>
<p>A matrix with transformed counts for the 'worst' group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with combinations of 'best' peptides.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some mock data
appearance_best &lt;- matrix(c(1, -1, 0, 1, -1), nrow = 5, ncol = 4)
appearance_worst &lt;- matrix(c(-1, 1, 0, -1, 1), nrow = 5, ncol = 4)
# Call the function
select_best_vs_worst(appearance_best, appearance_worst)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
