<!DOCTYPE html><html><head><title>Help for package ergmgp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergmgp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#durations'>
<p>Obtain Edge Spell Durations from an ERGM Generating Process Trajectory</p></a></li>
<li><a href='#EGPHazard'>
<p>Calculate Transition Hazards for an ERGM Generating Process</p></a></li>
<li><a href='#EGPRateEst'>
<p>Estimate Event Rates for an ERGM Generating Process</p></a></li>
<li><a href='#ergmgp-package'><p>Tools for Modeling ERGM Generating Processes</p></a></li>
<li><a href='#simEGP'>
<p>Simulate Trajectories from an ERGM Generating Process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Modeling ERGM Generating Processes</td>
</tr>
<tr>
<td>Depends:</td>
<td>network (&ge; 1.15), ergm (&ge; 3.10.1), networkDynamic (&ge; 0.10),
parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common (&ge; 4.2.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ergm</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for simulating draws from continuous time processes with well-defined exponential family random graph (ERGM) equilibria, i.e. ERGM generating processes (EGPs).  A number of EGPs are supported, including the families identified in Butts (2023) &lt;<a href="https://doi.org/10.1080%2F0022250X.2023.2180001">doi:10.1080/0022250X.2023.2180001</a>&gt;, as are functions for hazard calculation and timing calibration.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/ergmgp/issues">https://github.com/statnet/ergmgp/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 04:57:15 UTC; buttsc</td>
</tr>
<tr>
<td>Author:</td>
<td>Carter T. Butts [aut, cre],
  Statnet Commons [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carter T. Butts &lt;buttsc@uci.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 11:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='durations'>
Obtain Edge Spell Durations from an ERGM Generating Process Trajectory
</h2><span id='topic+durations'></span>

<h3>Description</h3>

<p>Given an input trajectory (in networkDynamic form, or network form with additional attributes), return the set of all edge durations (along with censoring information, if desired).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>durations(net, censor = c("obs", "omit"), return.censoring = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durations_+3A_net">net</code></td>
<td>

<p>a <code>network</code> or <code>networkDynamic</code> object containing the trajectory information.
</p>
</td></tr>
<tr><td><code id="durations_+3A_censor">censor</code></td>
<td>

<p>how should censoring be handled?  (Currently, only returning observed spell lengths and omitting censored spells are supported.)
</p>
</td></tr>
<tr><td><code id="durations_+3A_return.censoring">return.censoring</code></td>
<td>

<p>logical; return censoring information?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts information on edge spells (periods of time in which edges are present) from the input network, and returns the spell durations (optionally, together with censoring information).  The durations should not be assumed to be in any particular order; this function is generally invoked to examine duration distributions.
</p>
<p>If <code>net</code> is a <code>networkDynamic</code> object, both spell and censoring information are extracted from its edge activities.  If <code>net</code> is a <code>network</code> object, then its <code>"LastChangeTime"</code> network attribute is used to obtain spell information.  (Both can be obtained from <code><a href="#topic+simEGP">simEGP</a></code> with appropriate settings.)  Currently, <code>network</code> objects with <code>"EventHistory"</code> attributes are not supported - use the <code>networkDynamic</code> output type to examine complete event histories.  For the <code>network</code> case, the observation period is assumed to span the interval from 0 to <code>net%n%"Time"</code> (so be sure that temporal offsets were not used if employing that data type).
</p>
<p>Spells may be left-censored, right-censored, or both.  <code>censor=="obs"</code> results in lengths being reported as-is (subject to truncation to the observation period), and <code>censor=="omit"</code> results in censored spells being omitted.  Censoring indicators are also included when <code>return.censoring==TRUE</code>.  Note that if <code>"LastChangeTime"</code> information is being used, all spells are censored (we see only the onset times for edges that were present when the simulation was terminated), so the <code>"omit"</code> option will return a zero-length vector.  
</p>
<p>When using <code>durations</code> to estimate equilibrium duration distributions, it is important to bear in mind that EGP trajectories stopped by event count are not terminated at a random time, and hence will provide biased estimates.  Consider using <code><a href="#topic+EGPRateEst">EGPRateEst</a></code> to calibrate a reasonable simulation time, and sampling with a temporal stopping rule.
</p>


<h3>Value</h3>

<p>A vector of spell durations (order not guaranteed), or a matrix containing said durations and censoring indicators (0=uncensored, 1=right-censored, 2=left-censored, and 3=interval censored).
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simEGP">simEGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Examples are a bit slow, so not automatically run

#Generate a simple CD-CSTERGM trajectory; equilibrium mean outdegree
#is 2, dissolution rate is 1/3
set.seed(1331)
n &lt;- 25
net &lt;- simulate(network.initialize(n)~edges, coef=log(2/(n-3)))
traj &lt;- simEGP(net~edges, coef=list(formation=log(2/(n-3)*1/3),
    dissolution=log(1/3)), time=5000, process="CDCSTERGM", 
    return.changetime=TRUE, verbose=FALSE)
network.edgecount(traj)/(n-1)             #Mean degree apx 2
dur &lt;- durations(traj)                    #Get durations
head(dur)                                 #All are right-censored
mean(dur[,1])                             #Apx 3 (despite censoring)

#Repeat, but now using a networkDynamic object
set.seed(1331)
net &lt;- simulate(network.initialize(n)~edges, coef=log(2/(n-3)))
traj &lt;- simEGP(net~edges, coef=list(formation=log(2/(n-3)*1/3),
    dissolution=log(1/3)), time=500, process="CDCSTERGM", 
    return.networkDynamic=TRUE, verbose=FALSE)
slice &lt;- traj %t% 499                     #Take a slice near the end
network.edgecount(slice)/(n-1)            #Mean degree apx 2
dur &lt;- durations(traj)                    #Get durations
head(dur)                                 #More of a mix
mean(dur[,1])                             #Apx 3
hist(dur[,1], xlab="Time", main="Duration Distribution")  #Visualize


</code></pre>

<hr>
<h2 id='EGPHazard'>
Calculate Transition Hazards for an ERGM Generating Process
</h2><span id='topic+EGPHazard'></span>

<h3>Description</h3>

<p>Given an EGP and an initial state, calculate the transition rates to one or more neighboring states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGPHazard(form, coef, toggles = NULL, rate.factor = 1, process = c("LERGM",
    "CRSAOM", "CI", "DS", "CDCSTERGM", "CFCSTERGM", "CSTERGM", "CTERGM"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGPHazard_+3A_form">form</code></td>
<td>

<p>an ERGM formula for the EGP (or a list with <code>formation</code> and <code>dissolution</code> formulas, for <code>CSTERGM</code> processes).  The left-hand side is used as the current state when computing transition rates.
</p>
</td></tr>
<tr><td><code id="EGPHazard_+3A_coef">coef</code></td>
<td>

<p>a vector of EGP coefficients, or a list of vectors with elements <code>formation</code> and <code>dissolution</code> for <code>CSTERGM</code> and variants.
</p>
</td></tr>
<tr><td><code id="EGPHazard_+3A_toggles">toggles</code></td>
<td>

<p>edge variables to evaluate; passing <code>"all"</code> or <code>NULL</code> leads to all edge variables being evaluated, <code>"edges"</code> evaluates only dissolution events, <code>"nulls"</code> evaluates only formation events, and passing a two-column matrix of IDs (tail, head order) evaluates the selected dyads.
</p>
</td></tr>
<tr><td><code id="EGPHazard_+3A_rate.factor">rate.factor</code></td>
<td>

<p>rate or pacing factor (sets the time scale).
</p>
</td></tr>
<tr><td><code id="EGPHazard_+3A_process">process</code></td>
<td>

<p>the ERGM generating process to use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ERGM generating process (EGP) is a continuous time graph process with an equilibrium distribution having a known ERGM form.  See <code><a href="#topic+ergmgp">ergmgp</a></code> for an overview of EGPs, including the specifications supported here.
</p>
<p><code>EGPHazard</code> calculates the log transition rates (i.e., hazards) from an initial or current state (specified by the left-hand side of the input formula) to one or more target states.  These states are specified by the edge variables whose states would change (often called &ldquo;toggles&rdquo; in ERGM nomenclature).  By default, all possible transitions are evaluated; this can also be obtained by setting <code>toggles=="all"</code>.  Dissolution rates for all current edges can be obtained by setting <code>toggles=="edges"</code>, and formation rates for all current nulls can be obtained by setting <code>toggles=="nulls"</code>.  Otherwise, the <code>toggles</code> argument expects a two-column matrix of tail and head vertex IDs indicating the edge variables to be evaluated.  Note that only instantaneous rates from the origin state are computed; toggles are not cumulative.
</p>
<p>EGP specifications are as per <code><a href="#topic+simEGP">simEGP</a></code>.  Transition rates for all currently implemented EGPs follow the specifications of Butts (2023), with the trivial addition of a pacing constant for all families (which simply sets the timescale).
</p>


<h3>Value</h3>

<p>a matrix containing the toggles, indicators for whether each event would have been a formation event, and the log event hazards (one row per toggle).
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, Carter T.  (2023).  &ldquo;Continuous Time Graph Processes with Known ERGM Equilibria: Contextual Review, Extensions, and Synthesis.&rdquo; <em>Journal of Mathematical Sociology</em>.  <a href="https://doi.org/10.1080/0022250X.2023.2180001">doi:10.1080/0022250X.2023.2180001</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmgp">ergmgp</a></code> for information on EGPs, <code><a href="ergm.html#topic+ergm">ergm</a></code> for information on ERGM specifications, <code><a href="#topic+simEGP">simEGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a small network with triadic dependence
n &lt;- 25
set.seed(1331)
co &lt;- c(log(2.5/(n-3.5)), -0.75)
net &lt;- simulate(network.initialize(n, directed=FALSE) ~ edges + esp(0),
    coef = co)

#Compute all rates under a LERGM
lr &lt;- EGPHazard(net ~ edges + esp(0), coef = co, process = "LERGM")
head(lr)  #Sender, receiver, formation (1=yes), log rate

#Use a toggle matrix to obtain the same outcome
lrt &lt;- EGPHazard(net ~ edges + esp(0), coef = co, toggles = lr[,1:2],
    process = "LERGM")
all(lrt == lr)   #TRUE

#Examine edge dissolution rates
ldissr &lt;- EGPHazard(net ~ edges + esp(0), coef = co, toggles = "edges", 
    process = "LERGM")
a &lt;- function(z){(z-min(z))/diff(range(z))}
plot(net, edge.col = hsv(a(ldissr[,4])*0.6))  #Blue=fast, red=slow

</code></pre>

<hr>
<h2 id='EGPRateEst'>
Estimate Event Rates for an ERGM Generating Process
</h2><span id='topic+EGPRateEst'></span>

<h3>Description</h3>

<p>Given an EGP, estimate either the expected time required for a specified number of transitions to occur, or the expected number of transitions within a specified time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGPRateEst(formula, coef, process = c("LERGM", "CRSAOM", "CI", "DS",
    "CDCSTERGM", "CFCSTERGM", "CSTERGM", "CTERGM"), time.target = NULL,
    event.target = NULL, reps = 25, cores = 1, rate.factor = 1, 
    verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGPRateEst_+3A_formula">formula</code></td>
<td>

<p>an ERGM formula for the EGP (or a list with <code>formation</code> and <code>dissolution</code> formulas, for <code>CSTERGM</code> processes).  The left-hand side is used as the initial state.
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_coef">coef</code></td>
<td>

<p>a vector of EGP coefficients, or a list of vectors with elements <code>formation</code> and <code>dissolution</code> for <code>CSTERGM</code> and variants.
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_process">process</code></td>
<td>

<p>the ERGM generating process to use.
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_time.target">time.target</code></td>
<td>

<p>if specified, the length of the time period for which trajectories should be simulated (in which case the estimand is the number of events within this period). 
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_event.target">event.target</code></td>
<td>

<p>if specified, the number of transition events over which trajectories should be simulated (in which case the estimand is the time required for this number of events to be realized). 
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_reps">reps</code></td>
<td>

<p>number of replicate trajectories to use.
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_cores">cores</code></td>
<td>

<p>number of cores to use for simultaneous simulation of trajectories.
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_rate.factor">rate.factor</code></td>
<td>

<p>rate or pacing factor (sets the time scale).
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_verbose">verbose</code></td>
<td>

<p>logical; show progress information?
</p>
</td></tr>
<tr><td><code id="EGPRateEst_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="#topic+simEGP">simEGP</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to estimate the expected amount of time needed for a specific number of transitions to be realized (in which case <code>event.target</code> should be supplied) or the expected number of transition events occurring within a specified time period (in which case <code>time.target</code> should be supplied).  Either way, one of <code>time.target</code> and <code>event.target</code> must be given.  The function works by simulating <code>reps</code> trajectories (using <code>simEGP</code>) for the specified time/number of events, and returning the mean outcome (along with some other associated statistics).
</p>
<p>A typical use case for this function is to calibrate the simulation time needed to obtain a reasonable number of transitions from some starting point (e.g., to ensure burn-in).  Simply simulating a fixed number of transition events will result in a biased system state; however, one can avoid this problem by using this function to determine the average duration needed for the desired number of events to be realized, and then using this duration as a stopping rule for subsequent simulations.  Alternately, another use is to estimate the rate at which events accrue, e.g. to estimate compute time or memory requirements for a longer simulation study.  Some processes are particularly prone to entering regimes in which they produce very large numbers of events per unit phenomenological time, and it can be useful to identify this issue before committing resources to simulating a long trajectory.
</p>
<p>Note that, at present, all trajectories have the same starting point (the network on the left-hand side of the input formula).  They are hence coupled by the initial condition (despite being otherwise independent).  When equilibrium estimates from short sequences are desired, it may be wise to call this function more than once with different starting networks and integrate the results.
</p>


<h3>Value</h3>

<p>A vector containing the mean outcome (time or event count), its standard error, the standard deviation of the outcome, and the number of replicates used.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, Carter T.  (2023).  &ldquo;Continuous Time Graph Processes with Known ERGM Equilibria: Contextual Review, Extensions, and Synthesis.&rdquo; <em>Journal of Mathematical Sociology</em>.  <a href="https://doi.org/10.1080/0022250X.2023.2180001">doi:10.1080/0022250X.2023.2180001</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmgp">ergmgp</a></code> for information on EGPs, <code><a href="ergm.html#topic+ergm">ergm</a></code> for information on ERGM specifications, <code><a href="#topic+simEGP">simEGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a small network with triadic dependence
n &lt;- 25
set.seed(1331)
co &lt;- c(log(2.5/(n-3.5)), -0.75)
net &lt;- simulate(network.initialize(n, directed=FALSE) ~ edges + esp(0),
    coef = co)

#Estimate the time needed for 500 events in a LERGM
etime &lt;- EGPRateEst(net ~ edges + esp(0), coef = co, process = "LERGM",
    event.target = 500)
etime

#Estimate the mean number of events in the above time
eevents &lt;- EGPRateEst(net ~ edges + esp(0), coef = co, process = "LERGM",
    time.target = etime[1])
eevents   #Expectation should be close to 500

</code></pre>

<hr>
<h2 id='ergmgp-package'>Tools for Modeling ERGM Generating Processes</h2><span id='topic+ergmgp-package'></span><span id='topic+ergmgp'></span><span id='topic+EGP_init'></span>

<h3>Description</h3>

<p>Tools for simulation and analysis of continuous time graph processes with equilibria that can be described in exponential family random graph (ERGM) form.
</p>


<h3>Details</h3>

<p>A random graph <code class="reqn">G</code> on support <code class="reqn">\mathcal{G}</code> is said to be expressed in exponential family random graph (ERGM) form when its probability mass function (pmf) is written as
</p>
<p style="text-align: center;"><code class="reqn">\Pr(G=g|\theta,X) = \frac{\exp\left(\theta^T w(g,X)\right) h(g)}{\sum_{g' \in \mathcal{G}} \exp\left(\theta^T w(g',X)\right) h(g')}</code>
</p>

<p>where <code class="reqn">\theta</code> is a parameter vector, <code class="reqn">w</code> is a vector of sufficient statistics, <code class="reqn">X</code> is a covariate set, and <code class="reqn">h</code> is a reference measure.  This form is quite general; in particular, any pmf on finite support can be written in ERGM form (albeit not always elegantly), making it a natural language for expressing graph distributions.
</p>
<p>Now, consider a continuous time process whose state space is <code class="reqn">\mathcal{G}</code>.  A process of this type having an equilibrium distribution that can be written in (known) ERGM form is said to be an <em>ERGM generating process</em> or EGP.  Although there are many types of EGPs, perhaps the most natural are continuous time Markov chains (CTMCs) whose transitions involve the addition or removal of individual edges from the current graph state.  The transition rates of such CTMCs have the topology of the Hamming adjacency on <code class="reqn">\mathcal{G}</code>; this is only sensible when considering graphs on a fixed vertex set, which is the typical use case.  We can think of this class of EGPs as continuous time analogs of the Markov chains used in ERGM simulation (see <code><a href="ergm.html#topic+ergm">ergm</a></code>), with equilibrium obtained in the limit of time rather than simulation steps.  EGPs are potentially useful as dynamic interpretations of empirically obtained ERGMs, or as <em>a priori</em> models in their own right.  Since many Markovian EGPs are identified by their equilibrium ERGM together with a pacing constant, they are also natural choices when dynamics must be inferred from limited data (e.g., a cross-sectional network observation together with pacing or duration information).
</p>
<p>The <code>ergmgp</code> package supports a number of different EGPs, all of which are currently Markovian with support on graphs or digraphs of fixed order.  The following EGPs are currently supported; all definitions and notation follow Butts (2023).  Define  <code class="reqn">q(g) = \theta^T w(g,X) + \ln h(g)</code> to be the <em>graph potential</em>; in some cases, separate potentials (<code class="reqn">q_f</code> and <code class="reqn">q_d</code>) may be employed for the formation and dissolution of edges.  For brevity, we define the normalizing factor of the equilibrium ERGM distribution by <code class="reqn">Z = \sum_{g' \in \mathcal{G}} q(g')</code>, let <code class="reqn">w_e</code> be the edge count statistic, and let <code class="reqn">\mathcal{H}(g)</code> be the Hamming neighborhood of <code class="reqn">g</code> (i.e., the set of graphs reachable by single edge changes, or &ldquo;toggles&rdquo;).  All transition rates from graph <code class="reqn">a</code> to <code class="reqn">b</code> (denoted <code class="reqn">a \to b</code>) zero for <code class="reqn">b \not\in \mathcal{H}(a)</code>.  Processes not otherwise noted were introduced in Butts (2023).
</p>

<dl>
<dt>Longitudinal ERGM (<code>LERGM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> Introduced by Koskinen and Snijders (2007), this process was originally conceived of as a continuum analog to the Gibbs sampler, with transition rates that are increasing with differences in graph potential.  Grazioli et al. (2019) subsequently showed that it can also be derived from a physical model with locally Arrhenius-like kinetics.  This process has a maximum change rate (but no minimum), and may thus be plausible in settings for which changes can only be made when (exogenously determined) opportunities arise.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p><code class="reqn">[1+\exp[q(a)-q(b)]]^{-1}</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Competing Rate Stochastic Actor-Oriented Model (<code>CRSAOM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> Introduced as an EGP by Snijders (2001), this model was originally proposed as a behavioral process, where vertices represent actors controlling their outgoing edges, the rate at which actors make tie changes is a function of the attractiveness of the networks reachable by making such changes, and (given opportunity to act) edge changes are chosen by a multinomial logit with utility function <code class="reqn">q</code>.  Dynamics in this model are distinctive in being driven solely by the attractiveness of the target state, which can sometimes lead to rapid state switching when multiple high-potential states are Hamming-adjacent.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p><code class="reqn">\exp[q(b)]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Change Inhibition (<code>CI</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p>  In the same sense that the LERGM is analogous to a continuum Gibbs sampler, this process is loosely analogous to continuum Metropolis algorithm.  Downhill transitions with respect to the graph potential occur with a rate that is decreasing with the potential difference; uphill transitions, however, occur at a fixed rate (irrespective of the potential difference).  The process thus works by selectively inhibiting downhill moves, rather than by preferentially moving to graphs of highest local potential.  
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p><code class="reqn">\min(1,\exp[q(b)-q(a)])</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Differential Statibility (<code>DS</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> Analogous to a &ldquo;win-stay, lose-shift&rdquo; process, transition targets in this EGP are chosen uniformly at random, with structure arising entirely from transition <em>times</em>.  The time to exit a state <code class="reqn">g</code> is proportional to <code class="reqn">\exp[q(g)]</code>, making high-potential states exponentially more persistent than low-potential states.  Note that this process is in a sense the inverse of the <code>CRSAOM</code>, being dependent only on the potential of the source state (while the <code>CRSAOM</code> depends only on the potential of the target state).  Since the transitions themselves from a random walk, it should be noted that this process can generate very large numbers of transition events involving low-potential states that, while taking little phenomenological time, nevertheless are expensive to compute.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p><code class="reqn">|\mathcal{H}(a)|^{-1} \exp[-q(a)]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Constant Dissolution Continuum STERGM (<code>CDCSTERGM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> This process is a continuum version of the discrete time constant dissolution separable temporal ERGM (STERGM) introduced by Carnegie et al. (2015); here, edges are lost randomly at a fixed rate, with a formation potential <code class="reqn">q_f</code> that governs edge addition.  This is a special case of the continuum STERGMs (below), and is particularly easy to identify from limited information.  
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p>If <code class="reqn">b</code> is formed by adding an edge to <code class="reqn">a</code>, then <code class="reqn">\exp[q_f(b)-q_f(a)]</code>; otherwise <code class="reqn">\exp[\theta_d]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q_f(a) - \theta_d w_e(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Constant Formation Continuum STERGM (<code>CFCSTERGM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> This process is analogous to the <code>CDCSTERGM</code>, except that in this case edge <em>formation</em> occurs randomly at a fixed rate, with a dissolution potential <code class="reqn">q_d</code> governing edge loss.  It is a simple model for settings in which edges arise from essentially idiosyncratic events, with the resulting network structure subsequently stabilizing or destabilizing particular edges.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p>If <code class="reqn">b</code> is formed by adding an edge to <code class="reqn">a</code>, then <code class="reqn">\exp[\theta_f]</code>; otherwise <code class="reqn">\exp[q_d(b)-q_d(a)]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q_d(a) + \theta_f w_e(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Continuum STERGM (<code>CSTERGM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> This process represents a continuum limit of the discrete time separable temporal ERGMs (STERGMs) introduced by Krivitsky and Handcock (2014).  Edge formation is here governed by one potential (<code class="reqn">q_f</code>), while dissolution is governed by another (<code class="reqn">q_d</code>), allowing these processes to be governed by different effects.  The resulting equilibrium pmf is based on the sum of both potentials.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p>If <code class="reqn">b</code> is formed by adding an edge to <code class="reqn">a</code>, then <code class="reqn">\exp[q_f(b)-q_f(a)]</code>; otherwise <code class="reqn">\exp[q_d(b)-q_d(a)]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[q_d(a) + q_f(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
<dt>Continuum TERGM (<code>CTERGM</code>)</dt><dd>

<dl>
<dt>Description:</dt><dd><p> This process is a continuum limit of the discrete time temporal ERGMs (TERGMs) introduced in Robins and Pattison (2001).  The transition rates for this class are particularly natural, with the log rates being equal to the potential differences between states.  Note that the potential of the equilibrium ERGM is scaled by a factor of 2 from the transition potential (as can be obtained from the <code>CSTERGM</code> by letting <code class="reqn">q_f=q_d</code>); intuitively, this arises because states of higher potential are both more stable (lower exit rates) and more attractive (higher entrance rates) than states of lower potential.
</p>
</dd>
<dt>Event Rate (<code class="reqn">a \to b</code>):</dt><dd>
<p><code class="reqn">\exp[q(b)-q(a)]</code>
</p>
</dd>
<dt>Equilibrium:</dt><dd>
<p><code class="reqn">\exp[2q(a)]/Z</code>
</p>
</dd>
</dl>

</dd>
</dl>

<p>Further details on each process can be found in Butts (2023).  All of the above transition rates are defined up to an arbitrary pacing constant (which is generally specified separately, and taken to be 1 in package tools if not otherwise indicated).  Note that the LERGM and Change Inhibition processes have unit-maximum transition rates, and thus the pacing constant sets the maximum rate of change.
</p>
<p>Information on functions for simulation or analysis of EGPs is provided in their respective manual pages.  Information on ERGMs and their specification can be found within the <code><a href="ergm.html#topic+ergm">ergm</a></code> page in the <code>ergm</code> library.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, Carter T.  (2023).  &ldquo;Continuous Time Graph Processes with Known ERGM Equilibria: Contextual Review, Extensions, and Synthesis.&rdquo; <em>Journal of Mathematical Sociology</em>.  <a href="https://doi.org/10.1080/0022250X.2023.2180001">doi:10.1080/0022250X.2023.2180001</a>
</p>
<p>Carnegie, Nicole B.; Krivitsky, Pavel N.; Hunter, David R.; and Goodreau, Steven M. (2015). &ldquo;An Approximation Method for Improving Dynamic Network Model Fitting.&rdquo;  <em>Journal of Computational and Graphical Statistics</em>, 24(2):502-519.
</p>
<p>Grazioli, Gianmarc; Yu, Yue; Unhelkar, Megha H.; Martin, Rachel W.; and Butts, Carter T. (2019). &ldquo;Network-based Classification and Modeling of Amyloid Fibrils.&rdquo;  <em>Journal of Physical Chemistry, B</em>, 123(26):5452-5462.
</p>
<p>Koskinen, Johan H. and Snijders, Tom A. (2007). &ldquo;Bayesian Inference for Dynamic Social Network Data.&rdquo;  <em>Journal of Statistical Planning and Inference</em>, 137(12):393&ndash;3938. 5th St. Petersburg Workshop on Simulation, Part II.
</p>
<p>Krivitsky, Pavel N. and Handcock, Mark S. (2014). &ldquo;A Separable Model for Dynamic Networks.&rdquo; <em>Journal of the Royal Statistical Society, Series B,</em> 76(1):29-46.
</p>
<p>Robins, Garry L. and Pattison, Philippa E. (2001). &ldquo;Random Graph Models for Temporal Processes in Social Networks.&rdquo; <em>Journal of Mathematical Sociology</em>, 25:5-41.
</p>
<p>Snijders, Tom A. B. (2001). &ldquo;The Statistical Evaluation of Social Network Dynamics.&rdquo;  <em>Sociological Methodology,</em> 31:361-395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simEGP">simEGP</a></code>, <code><a href="#topic+EGPHazard">EGPHazard</a></code>, <code><a href="#topic+EGPRateEst">EGPRateEst</a></code>, <code><a href="ergm.html#topic+ergm">ergm</a></code>, <code><a href="#topic+durations">durations</a></code>
</p>

<hr>
<h2 id='simEGP'>
Simulate Trajectories from an ERGM Generating Process
</h2><span id='topic+simEGP'></span><span id='topic+simEGPTraj'></span>

<h3>Description</h3>

<p>Given an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula, simulate trajectories from a continuous time graph process having the specified ERGM as a limiting distribution.  A number of different processes are supported, and termination may be specified either by phenomenological time or event counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simEGP(form, coef, events = 1, time = NULL, rate.factor = 1, 
    time.offset = 0, event.offset = 0, process = c("LERGM", "CRSAOM", 
    "CI", "DS", "CDCSTERGM", "CFCSTERGM", "CSTERGM", "CTERGM"), 
    use.logtime = FALSE, return.changetime = FALSE, 
    changetime.offset = NULL, return.history = FALSE, 
    return.networkDynamic = FALSE, verbose = TRUE,  trace.interval = 100,
    ...)

simEGPTraj(form, coef, events = 1, time = NULL, checkpoints = 1, 
    rate.factor = 1, trajectories = 1, mc.cores = 1, 
    log.sampling = FALSE, process = c("LERGM", "CRSAOM", "CI", "DS",
    "CDCSTERGM", "CFCSTERGM", "CSTERGM", "CTERGM"), use.logtime = FALSE,
    return.changetime = FALSE, return.history = FALSE, verbose = TRUE,
    trace.interval = 100, statsonly = FALSE, monitor = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simEGP_+3A_form">form</code></td>
<td>

<p>an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula defining terms for the EGP; the left-hand side must be a network object, whose properties are used to determine the state space.  For the <code>CSTERGM</code> process, a list containing two such formulas must be used, with named elements <code>formation</code> (for the formation model) and <code>dissolution</code> (for the dissolution model).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_coef">coef</code></td>
<td>

<p>vector of coefficients for the EGP; for the CSTERGMs, this should be a containing named elements <code>formation</code> and <code>dissolution</code>, each of which should be the coefficient vector for its respective model.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_events">events</code></td>
<td>

<p>optionally, the number of simulated events to draw (if <code>time==NULL</code>); if <code>time</code> is specified, this is ignored.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_time">time</code></td>
<td>

<p>optionally, the temporal length of the simulation; if not supplied, <code>events</code> is used instead to determine when to stop.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_rate.factor">rate.factor</code></td>
<td>

<p>a multiplicative factor scaling the time evolution of the system; higher values correspond to faster dynamics.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_time.offset">time.offset</code></td>
<td>

<p>optionally, an initial &ldquo;clock&rdquo; offset for the start of a trajectory; this allows time 0 (the start of the simulation interval) to be set to an arbitrary time point.  This is only used for book-keeping (e.g., when a trajectory is run as multiple segments), and does not affect e.g. the meaning of the <code>time</code> argument (which is always interpreted as units after the start time).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_event.offset">event.offset</code></td>
<td>

<p>optionally, an initial offset to the step or event count for the start of a trajectory (e.g., for trajectories being run in segments).  As with <code>time.offset</code>, this only affects book-keeping, and has no other effect.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_process">process</code></td>
<td>

<p>the ERGM generating process to use (described below).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_use.logtime">use.logtime</code></td>
<td>

<p>logical; internally, use logarithmic timescale?  This can potentially protect against overflow or underflow when rates are extreme, but can reduce precision and adds some overhead.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_return.changetime">return.changetime</code></td>
<td>

<p>logical; should we return a matrix with the last update times for each edge variable as a network attribute?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_changetime.offset">changetime.offset</code></td>
<td>

<p>optionally, an <code>n x n</code> matrix of last change times (for trajectories being resumed in process).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_return.history">return.history</code></td>
<td>

<p>logical; return the entire event history as a network attribute?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_return.networkdynamic">return.networkDynamic</code></td>
<td>

<p>logical; retain the entire event history and return as a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_verbose">verbose</code></td>
<td>

<p>logical; provide trace messages regarding simulation progress?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_trace.interval">trace.interval</code></td>
<td>

<p>for verbose output, the interval at which messages should be printed (in events).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_checkpoints">checkpoints</code></td>
<td>

<p>number of checkpoints at which the trajectory should be sampled (in addition to the initial state).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_trajectories">trajectories</code></td>
<td>

<p>number of independent trajectories to simulate (all start from the seed network, but evolve independently).
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use when simulating trajectories.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_log.sampling">log.sampling</code></td>
<td>

<p>logical; should time points to sample be logarithmically spaced?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_statsonly">statsonly</code></td>
<td>

<p>logical; should only network statistics be retained (and not the graphs themselves)?
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_monitor">monitor</code></td>
<td>

<p>optionally, an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula with additional statistics to track.
</p>
</td></tr>
<tr><td><code id="simEGP_+3A_...">...</code></td>
<td>

<p>additional arguments (currently unused).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ERGM generating process (EGP) is a continuous time graph process with an equilibrium distribution having a known ERGM form.  See <code><a href="#topic+ergmgp">ergmgp</a></code> for an overview of EGPs, including the specifications supported here.
</p>
<p><code>simEGP</code> generates a single trajectory from an EGP, with the EGP being specified via its graph potential (as a <code><a href="ergm.html#topic+ergm">ergm</a></code> formula or pair thereof and associated coefficients) and its initial state being given by the left-hand side of the input formula.  The trajectory length can be specified either in terms of the number of transitions to be simulated (<code>events</code>) or the length of the trajectory in phenomenological time (<code>time</code>); only the latter leads to the specified ERGM equilibrium (since event times are not &ldquo;random&rdquo; times, stopping after a fixed number of events biases the final state).  If desired for bookkeeping purposes, an offset can be added to the simulation clock (which otherwise starts at 0), event count (likewise), and most recent change times (also likewise).  By default, the return value is a <code><a href="network.html#topic+network">network</a></code> object containing the final graph state, with network attributes giving the final time (<code>"Time"</code>), event count (<code>"Events"</code>), ERGM potential (<code>"Potential"</code>).  A square matrix containing the time of the most recent transition experienced by each edge variable can be returned as a network attribute (<code>"LastChangeTime"</code>) if <code>return.changetime</code> is selected.  By default, the entire event history is not stored (as it can become extremely large).  However, if <code>return.history==TRUE</code>, a matrix containing the event history is saved and returned as a network attribute (<code>"EventHistory"</code>). Alternately, setting <code>return.networkDynamic=TRUE</code> will lead to the event history being stored and the entire trajectory being returned as a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object, with edge activities set based on the observed transitions.  This format may be easier to use for visualization, or to query the state of the network at an arbitrary point in the trajectory.  The <code><a href="#topic+durations">durations</a></code> function can be used to extract edge durations from such objects, as well.
</p>
<p>For models with extreme transition rates, the option <code>use.logtime</code> may be useful for avoiding overflow or underflow; this only affects internal calculation, and not reported event times.  Note that logscale calculations add some overhead, and may be less precise in some cases than the default, so this option is not suggested unless specifically needed.  
</p>
<p><code>simEGPTraj</code> is a wrapper for <code>simEGP</code>, which adds additional capabilities for simulation of multiple trajectories and/or sampling of longer trajectories.  Each returned trajectory contains the initial state, as well as <code>simEGP</code> output from <code>checkpoints</code> points along the trajectory (including the end).  The default behavior (<code>checkpoints==1</code>) returns the initial and final states.  Checkpoints are evenly spaced (with termination criteria indicated as per <code>simEGP</code>) by default, or logarithmically spaced if <code>log.sampling==TRUE</code>.  Multiple independent trajectories can be simulated by setting <code>trajectories&gt;1</code>; these can be run in parallel by setting <code>mc.cores&gt;1</code>.  If desired, the model statistics can be returned without the graph state by choosing <code>statsonly=TRUE</code>, and a one-sided <code>monitor</code> formula can likewise be used to calculate additional statistics if desired (with similar functionality to the <code>ergm</code> <code>simulate</code> method).  Otherwise, <code>network.list</code> objects are returned containing the states in the respective trajectories.
</p>
<p>Simulation itself follows the discrete event approach described in Butts (2023).  Transition hazards are computed for all edge variables (making the scaling no better then <code class="reqn">O(N^2)</code> for each update, and are used to draw both the next event and the event time.  Because the cost of computing each transition is unrelated to waiting time, this algorithm can be quite efficient at simulating long time periods when events are sparse (unlike, e.g. a discrete-time algorithm that updates in every period).  By turns, however, trajectories can become quite expensive (per unit phenomenological time) when event rates are high.  This issue is especially pronounced for the <code>CRSAOM</code> and <code>DS</code> processes, which can both generate very high transition rates in some cases.  Unless otherwise specified, event histories are not stored, so storage costs are by default unrelated to trajectory length.  Care should be taken when storing event histories, as they can become quite large when transition rates are high. 
</p>
<p>To obtain equilibrium graph distributions from an EGP, it is generally (much) more efficient to use the <code>simulate</code> functions in the <code><a href="ergm.html#topic+ergm">ergm</a></code> package: they employ MCMC algorithms that are unconstrained by the need to follow realistic trajectories, and that are optimized for rapid mixing.  (In particular, note that many systems can become <em>kinetically trapped</em>, spending very long periods in metastable states that are far from equilibrium.  This can be a real-world phenomenon, but is not always desirable from a computational point of view.  Functions such as <code>simEGP</code> are intended to faithfully reproduce such dynamics, while MCMC algorithms are intended to avoid them.)  Comparison of late-phase draws from a <code>simERGMPot</code> trajectory with equilibrium ERGM draws can be used to evaluate convergence to equilibrium behavior (where desired); alternately, <code>simEGP</code> can be seeded with ERGM draws to follow trajectories from equilibrated states.  Consult the <code>ergm</code> package documentation for details.
</p>


<h3>Value</h3>

<p>For <code>simEGP</code>, a network object containing the final graph state, with network attributes <code>Time</code>, <code>Events</code>, and <code>Potential</code> listing the time, event count, and ERGM potential at the end of the simulation interval.  See above for additional attributes that may be added if history retention is activated.  If <code>return.networkDynamic==TRUE</code>, then the return value is instead a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object containing the event history as edge activity data; be aware that an edge will exist in this object if any corresponding edge is ever active, so the raw graph state should not be used to access the final system state.  Instead, use the <code><a href="networkDynamic.html#topic+network.extract">network.extract</a></code> method to query the network state at the desired time point.
</p>
<p>For <code>simERGMPotTraj</code>, a list containing the simulated trajectories.  These are either <em>network.list</em> objects containing the networks at each checkpoint (with time, step, and potential attribute as described above), or else matrices of trace statistics (if <code>statsonly==TRUE</code>).  Note that the statistics are in any event included as an attribute to each network list, so the effect of <code>statsonly==TRUE</code> is simply not to retain the graph states.
</p>


<h3>Note</h3>

<p>Using <code>steps</code> to control trajectory termination will lead to biased samples (sometimes severely so); this is because transitions are not random times. If your goal is to obtain equilibrium draws (or draws en route thereto), use <code>time</code> to set the stopping point.  See <code><a href="#topic+EGPRateEst">EGPRateEst</a></code> for a simple tool for calibrating simulation times.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, Carter T.  (2023).  &ldquo;Continuous Time Graph Processes with Known ERGM Equilibria: Contextual Review, Extensions, and Synthesis.&rdquo; <em>Journal of Mathematical Sociology</em>.  <a href="https://doi.org/10.1080/0022250X.2023.2180001">doi:10.1080/0022250X.2023.2180001</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmgp">ergmgp</a></code> for information on EGPs, <code><a href="ergm.html#topic+ergm">ergm</a></code> for information on ERGM specifications, <code><a href="#topic+EGPHazard">EGPHazard</a></code>, <code><a href="#topic+EGPRateEst">EGPRateEst</a></code>, <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Small example of 2-ribbon generation
n&lt;-100
set.seed(1331)
net&lt;-network.initialize(n,directed=FALSE)
sim&lt;-simEGP(net~edges+kstar(2)+nsp(1:2), 
    coef=c(109-log(n),-25,-1.25,3.25), time=100, process="LERGM",
    verbose = TRUE)
plot(sim) #Return value is a single network

#Generate a trajectory showing the process at multiple stages
set.seed(1331)
sim&lt;-simEGPTraj(net~edges+kstar(2)+nsp(1:2), 
    coef=c(109-log(n),-25,-1.25,3.25), time=100, checkpoints = 5, 
    trajectories = 2, mc.cores = 1, log.sampling = TRUE, 
    process = "LERGM", verbose = TRUE) 
length(sim)==2        #One entry per simulated trajectory
op&lt;-par(mfrow=c(2,3))
for(i in 1:6)         #Show the first trajectory
  plot(sim[[1]][[i]],main=paste("Time",round(sim[[1]][[i]]%n%"Time",2)))
summary(sim[[2]]~edges+kstar(2))  #Show selected stats from the second
attributes(sim[[1]])  #Show precomputed statistics
par(op)

#A simple example with statsonly
set.seed(1331)
sim&lt;-simEGPTraj(net~edges+esp(0), coef = c(log(2)-log(n), -1), time = 200,
    checkpoints = 25, process = "LERGM", statsonly = TRUE, 
    monitor = ~triangle)
sim                   #Note the monitor stat
op&lt;-par(mfrow=c(1,1))
plot(sim[,"Time"], sim[,"edges"], type = "l")  #Time by edge count
lines(sim[,"Time"], sim[,"esp0"], col = 2)     #Add ESP(0)s
par(op)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
