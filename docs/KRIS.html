<!DOCTYPE html><html><head><title>Help for package KRIS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KRIS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#KRIS-package'><p>Keen and Reliable Interface Subroutines for bioinformatic analysis</p></a></li>
<li><a href='#cal.pc.linear'><p>Calculate linear principal component analysis (PCA) from numeric data and</p>
Single-nucleotide polymorphism (SNP) dataset</a></li>
<li><a href='#cal.pc.projection'><p>Calculate linear principal component analysis (PCA) with a projection method</p>
for Single-nucleotide polymorphism (SNP) dataset.</a></li>
<li><a href='#fst.each.snp.hudson'><p>Calculate the fixation index (Fst) for all SNPs between two groups of</p>
individuals from Single-nucleotide polymorphism (SNP)</a></li>
<li><a href='#fst.hudson'><p>Calculate the average fixation index (Fst) between two groups of individuals</p>
from Single-nucleotide polymorphism (SNP)</a></li>
<li><a href='#plot3views'><p>Create scatter plots in three views.</p></a></li>
<li><a href='#read.bed'><p>Read the binary PLINK format (BED, BIM, and FAM)</p></a></li>
<li><a href='#replace.missing'><p>(Internal) Replace missing values with other values,internally used for</p>
parallelization</a></li>
<li><a href='#rubikclust'><p>Unsupervised clustering to detect rough structures and outliers.</p></a></li>
<li><a href='#sample_labels'><p>Synthetic dataset containing population labels for the dataset simsnp.</p></a></li>
<li><a href='#simsnp'><p>Synthetic dataset containing single nucleotide polymorphisms (SNP)</p></a></li>
<li><a href='#write.bed'><p>Write a list of SNP object to the binary PLINK format (BED, BIM, and FAM)</p></a></li>
<li><a href='#xxt'><p>Calculate matrix multipication between a matrix and its</p>
transpose for large data.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Keen and Reliable Interface Subroutines for Bioinformatic
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides useful functions which are needed for bioinformatic analysis such as calculating linear principal components from numeric data and Single-nucleotide polymorphism (SNP) dataset, calculating fixation index (Fst) using Hudson method, creating scatter plots in 3 views, handling with PLINK binary file format, detecting rough structures and outliers using unsupervised clustering, and calculating matrix multiplication in the faster way for big data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>rARPACK,grDevices,graphics,stats,utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/kris.ccp/kris/-/issues">https://gitlab.com/kris.ccp/kris/-/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/kris.ccp/kris">https://gitlab.com/kris.ccp/kris</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-20 15:02:56 UTC; kris</td>
</tr>
<tr>
<td>Author:</td>
<td>Kridsadakorn Chaichoompu [aut, cre],
  Kristel Van Steen [aut],
  Fentaw Abegaz [aut],
  Sissades Tongsima [aut],
  Philip James Shaw [aut],
  Anavaj Sakuntabhai [aut],
  Luisa Pereira [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kridsadakorn Chaichoompu &lt;kridsadakorn@biostatgen.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-21 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='KRIS-package'>Keen and Reliable Interface Subroutines for bioinformatic analysis</h2><span id='topic+KRIS'></span><span id='topic+KRIS-package'></span>

<h3>Description</h3>

<p>Provides useful functions which are needed for bioinformatic analysis such as
calculating linear principal components from numeric data and
Single-nucleotide polymorphism (SNP) dataset, calculating fixation index
(Fst) using Hudson method, creating scatter plots in 3 views, handling with
PLINK binary file format, detecting rough structures and outliers using
unsupervised clustering, and calculating matrix multiplication in the faster
way for big data.
</p>


<h3>Details</h3>

<p>The R package <span class="pkg">KRIS</span> requires the package <span class="pkg">rARPACK</span>.
</p>
<p>Here is the list of functions in the R package <span class="pkg">KRIS</span>:
</p>

<ul>
<li> <p><code><a href="#topic+cal.pc.linear">cal.pc.linear</a></code>
</p>
</li>
<li> <p><code><a href="#topic+cal.pc.projection">cal.pc.projection</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fst.each.snp.hudson">fst.each.snp.hudson</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fst.hudson">fst.hudson</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot3views">plot3views</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read.bed">read.bed</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rubikclust">rubikclust</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write.bed">write.bed</a></code>
</p>
</li>
<li> <p><code><a href="#topic+xxt">xxt</a></code>
</p>
</li></ul>

<p>Moreover, here is the list of example datasets in the R package <span class="pkg">KRIS</span>:
</p>

<ul>
<li> <p><code><a href="#topic+simsnp">simsnp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+sample_labels">sample_labels</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kridsadakorn Chaichoompu <a href="mailto:kridsadakorn@biostatgen.org">kridsadakorn@biostatgen.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Kristel Van Steen
</p>
</li>
<li><p> Fentaw Abegaz
</p>
</li>
<li><p> Sissades Tongsima
</p>
</li>
<li><p> Philip James Shaw
</p>
</li>
<li><p> Anavaj Sakuntabhai
</p>
</li>
<li><p> Luisa Pereira
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/kris.ccp/kris">https://gitlab.com/kris.ccp/kris</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/kris.ccp/kris/-/issues">https://gitlab.com/kris.ccp/kris/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cal.pc.linear'>Calculate linear principal component analysis (PCA) from numeric data and
Single-nucleotide polymorphism (SNP) dataset</h2><span id='topic+cal.pc.linear'></span>

<h3>Description</h3>

<p>Available for two types of data; numeric data and
Single-nucleotide polymorphism (SNP) dataset in additive coding (0, 1, and 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.pc.linear(X, PCscore = TRUE, no.pc = NA, data.type = "linear", XXT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.pc.linear_+3A_x">X</code></td>
<td>
<p>A data matrix which rows represent samples and columns represent
features.</p>
</td></tr>
<tr><td><code id="cal.pc.linear_+3A_pcscore">PCscore</code></td>
<td>
<p>To specify whether scaled PCs will be calculated or not. If
FALSE, eigenvectors are returned instead. Default = TRUE.</p>
</td></tr>
<tr><td><code id="cal.pc.linear_+3A_no.pc">no.pc</code></td>
<td>
<p>A number of PCs to be calculated. If no.pc is set, PCs are
patially calculated. Otherwise all PCs are obtained after calculation.
Default = NA.</p>
</td></tr>
<tr><td><code id="cal.pc.linear_+3A_data.type">data.type</code></td>
<td>
<p>To specify a type of data matrix X. It can be set to
&quot;linear&quot; and &quot;snp&quot;. Default = &quot;linear&quot;.</p>
</td></tr>
<tr><td><code id="cal.pc.linear_+3A_xxt">XXT</code></td>
<td>
<p>To specify how pricipal components (PCs) are calculated. If TRUE,
PCs are calculated from X.t(X), otherwise X is used directly. XXT is useful
option especially an input matrix X contains many columns. Enabling this
option, it helps to reduce computation complexity. Regardless the option XXT
is enable or not, optained PCs are the same. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list with 2 objects, <code>$PC</code>,
<code>$evalue</code>:
</p>

<ul>
<li> <p><code>$PC</code> is a PC matrix which rows represent samples and columns
represent PCs.
</p>
</li>
<li> <p><code>$evalue</code> is a vector of eigen values.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cal.pc.projection">cal.pc.projection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load simulated dataset
data(example_SNP)

#Using default parameters
PCs &lt;- cal.pc.linear(simsnp$snp)
summary(PCs)

#Preview $PC
print(PCs$PC[1:5,1:3])

#Preview $evalue
print(PCs$evalue[1:3])

plot3views(PCs$PC[,1:3], sample_labels)

#Calculate PCs without PC scores

PCs &lt;- cal.pc.linear(simsnp$snp, PCscore = FALSE)
summary(PCs)

#Preview $PC
print(PCs$PC[1:5,1:3])

#Preview $evalue
print(PCs$evalue[1:3])

plot3views(PCs$PC[,1:3], sample_labels)

#Calculate the top 3 PCs
PCs &lt;- cal.pc.linear(simsnp$snp, no.pc = 3)
summary(PCs)

#Preview $PC
print(PCs$PC[1:5,1:3])

#Preview $evalue
print(PCs$evalue[1:3])

plot3views(PCs$PC[,1:3], sample_labels)
</code></pre>

<hr>
<h2 id='cal.pc.projection'>Calculate linear principal component analysis (PCA) with a projection method
for Single-nucleotide polymorphism (SNP) dataset.</h2><span id='topic+cal.pc.projection'></span>

<h3>Description</h3>

<p>In order to perform the projection method, disease status for all individuals
are required. First, PCA is performed only in control group, then project
the scores from control group into case group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.pc.projection(
  X,
  status,
  individual_id = NULL,
  labels = NULL,
  no.pc = NA,
  data.type = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.pc.projection_+3A_x">X</code></td>
<td>
<p>A data matrix which rows represent samples and columns represent
features.</p>
</td></tr>
<tr><td><code id="cal.pc.projection_+3A_status">status</code></td>
<td>
<p>A vector of numbers that contains disease status for all
individuals. For control group, the status is &quot;1&quot;, and &quot;2&quot; for case group.
Individuals with unknown status (other numbers) are ignored and excluded from
the result.</p>
</td></tr>
<tr><td><code id="cal.pc.projection_+3A_individual_id">individual_id</code></td>
<td>
<p>A vector of charactors that contains individuals IDs</p>
</td></tr>
<tr><td><code id="cal.pc.projection_+3A_labels">labels</code></td>
<td>
<p>A vector of charactors that contains labels for all lindividuals</p>
</td></tr>
<tr><td><code id="cal.pc.projection_+3A_no.pc">no.pc</code></td>
<td>
<p>A number of PCs to be calculated. If no.pc is set, PCs are
patially calculated. Otherwise all PCs are obtained after calculation.
Default = NA.</p>
</td></tr>
<tr><td><code id="cal.pc.projection_+3A_data.type">data.type</code></td>
<td>
<p>To specify a type of data matrix X. It can be set to
&quot;linear&quot; and &quot;snp&quot;. Default = &quot;linear&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list with 4 objects, <code>$PC</code>,
<code>$id</code>, <code>$label</code>,and <code>$status</code>. Individuals with unknown status
are excluded.
</p>

<ul>
<li> <p><code>$PC</code> is a PC matrix which rows represent samples and columns
represent PCs.
</p>
</li>
<li> <p><code>$individual_id</code> is a vector of charactors that contains individuals IDs.
</p>
</li>
<li> <p><code>$label</code> is a vector of charactors that contains labels for all lindividuals.
</p>
</li>
<li> <p><code>$status</code> is a vector of numbers that contains disease status for all.
individuals.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cal.pc.linear">cal.pc.linear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_SNP)

#Create a random list of disease status, 1 = Control and 2 = Case

ind_status &lt;- sample(c(1,2), size = length(sample_labels), replace = TRUE)

PCs &lt;- cal.pc.projection(simsnp$snp, status = ind_status,
labels = sample_labels)
summary(PCs)

#Preview $PC
print(PCs$PC[1:5,1:3])

#Preview $status
print(PCs$status[1:3])

plot3views(PCs$PC[,1:3], PCs$label)

#Calculate the top 3 PCs

PCs &lt;- cal.pc.projection(simsnp$snp, status = ind_status,
labels = sample_labels, no.pc = 3)
summary(PCs)

#Preview $PC
print(PCs$PC[1:5,1:3])

plot3views(PCs$PC[,1:3], PCs$label)


</code></pre>

<hr>
<h2 id='fst.each.snp.hudson'>Calculate the fixation index (Fst) for all SNPs between two groups of
individuals from Single-nucleotide polymorphism (SNP)</h2><span id='topic+fst.each.snp.hudson'></span>

<h3>Description</h3>

<p>Fixation index (Fst) calculation was implemented using Hudson
method as in Bhatia (2013) and Hudson (1992).
</p>
<p>Fixation index (Fst) calculation was implemented using Hudson
method as in Bhatia (2013) and Hudson (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fst.each.snp.hudson(X, idx.p1, idx.p2)

fst.each.snp.hudson(X, idx.p1, idx.p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst.each.snp.hudson_+3A_x">X</code></td>
<td>
<p>A matrix contains the number 0, 1, and 2 representing SNP in
additive coding. Rows represent individuals and columns represent SNP.</p>
</td></tr>
<tr><td><code id="fst.each.snp.hudson_+3A_idx.p1">idx.p1</code></td>
<td>
<p>An integer vector contains the row indices of first population
in the matrix X.</p>
</td></tr>
<tr><td><code id="fst.each.snp.hudson_+3A_idx.p2">idx.p2</code></td>
<td>
<p>An integer vector contains the row indices of second population
in the matrix X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix of pairwise Fst values for all SNPs
between 2 specified groups.
</p>
<p>The function returns a matrix of pairwise Fst values for all SNPs
between 2 specified groups.
</p>


<h3>References</h3>

<p>Bhatia, G., Patterson, N., Sankararaman, S., and Price, A.L. (2013).
Estimating and interpreting FST: The impact of rare variants. Genome Res. 23,
1514-1521.
</p>
<p>Hudson, R.R., Slatkin, M., and Maddison, W.P. (1992). Estimation of levels of
gene flow from DNA sequence data. Genetics 132, 583-589.
</p>
<p>Bhatia, G., Patterson, N., Sankararaman, S., and Price, A.L. (2013).
Estimating and interpreting FST: The impact of rare variants. Genome Res. 23,
1514-1521.
</p>
<p>Hudson, R.R., Slatkin, M., and Maddison, W.P. (1992). Estimation of levels of
gene flow from DNA sequence data. Genetics 132, 583-589.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fst.hudson">fst.hudson</a></code>
</p>
<p><code><a href="#topic+fst.hudson">fst.hudson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Load simulated dataset
data(example_SNP)

idx1 &lt;- which(sample_labels == 'pop1')
idx2 &lt;- which(sample_labels == 'pop2')
fst.pairwise &lt;- fst.each.snp.hudson(simsnp$snp, idx1, idx2)

#Print out the Fst values of the first three SNPs between 'pop1' and 'pop2'
print(fst.pairwise[1:3])



#Load simulated dataset
data(example_SNP)

idx1 &lt;- which(sample_labels == 'pop1')
idx2 &lt;- which(sample_labels == 'pop2')
fst.pairwise &lt;- fst.each.snp.hudson(simsnp$snp, idx1, idx2)

#Print out the Fst values of the first three SNPs between 'pop1' and 'pop2'
print(fst.pairwise[1:3])

</code></pre>

<hr>
<h2 id='fst.hudson'>Calculate the average fixation index (Fst) between two groups of individuals
from Single-nucleotide polymorphism (SNP)</h2><span id='topic+fst.hudson'></span>

<h3>Description</h3>

<p>Fixation index (Fst) calculation was implemented using Hudson
method as in Bhatia (2013) and Hudson (1992).
</p>
<p>Fixation index (Fst) calculation was implemented using Hudson
method as in Bhatia (2013) and Hudson (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fst.hudson(X, idx.p1, idx.p2)

fst.hudson(X, idx.p1, idx.p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst.hudson_+3A_x">X</code></td>
<td>
<p>A matrix contains the number 0, 1, and 2 representing SNP in
additive coding. Rows represent individuals and columns represent SNP.</p>
</td></tr>
<tr><td><code id="fst.hudson_+3A_idx.p1">idx.p1</code></td>
<td>
<p>An integer vector contains the row indices of first population
in the matrix X.</p>
</td></tr>
<tr><td><code id="fst.hudson_+3A_idx.p2">idx.p2</code></td>
<td>
<p>An integer vector contains the row indices of second population
in the matrix X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an average Fst value between 2 specified groups.
</p>
<p>The function returns an average Fst value between 2 specified groups.
</p>


<h3>References</h3>

<p>Bhatia, G., Patterson, N., Sankararaman, S., and Price, A.L. (2013).
Estimating and interpreting FST: The impact of rare variants. Genome Res. 23,
1514-1521.
</p>
<p>Hudson, R.R., Slatkin, M., and Maddison, W.P. (1992). Estimation of levels of
gene flow from DNA sequence data. Genetics 132, 583-589.
</p>
<p>Bhatia, G., Patterson, N., Sankararaman, S., and Price, A.L. (2013).
Estimating and interpreting FST: The impact of rare variants. Genome Res. 23,
1514-1521.
</p>
<p>Hudson, R.R., Slatkin, M., and Maddison, W.P. (1992). Estimation of levels of
gene flow from DNA sequence data. Genetics 132, 583-589.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fst.each.snp.hudson">fst.each.snp.hudson</a></code>
</p>
<p><code><a href="#topic+fst.each.snp.hudson">fst.each.snp.hudson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Load simulated dataset
data(example_SNP)

idx1 &lt;- which(sample_labels == 'pop1')
idx2 &lt;- which(sample_labels == 'pop2')
fst &lt;- fst.hudson(simsnp$snp, idx1, idx2)

#Print out the Fst value between 'pop1' and 'pop2'
print(fst)



#Load simulated dataset
data(example_SNP)

idx1 &lt;- which(sample_labels == 'pop1')
idx2 &lt;- which(sample_labels == 'pop2')
fst &lt;- fst.hudson(simsnp$snp, idx1, idx2)

#Print out the Fst value between 'pop1' and 'pop2'
print(fst)

</code></pre>

<hr>
<h2 id='plot3views'>Create scatter plots in three views.</h2><span id='topic+plot3views'></span>

<h3>Description</h3>

<p>Visualize data in X-Y plane, X-Z plane, and Y-Z
plane. The input object (matrix or data.frame) must contain at least 3
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3views(
  X,
  labels,
  only.row = NA,
  plot.legend = NA,
  plot.pattern = NA,
  plot.color = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3views_+3A_x">X</code></td>
<td>
<p>A matrix or a data.frame that contains at least 3 columns of numeric
data. If there are more than 3 columns in X, only the first 3 columns will be
used.</p>
</td></tr>
<tr><td><code id="plot3views_+3A_labels">labels</code></td>
<td>
<p>A vector containing row labels of X for display. All vector
elements should be of type &quot;character&quot; (as.character). The length of
vector equals the number of rows in X.</p>
</td></tr>
<tr><td><code id="plot3views_+3A_only.row">only.row</code></td>
<td>
<p>A vector that contains subset of row numbers that are
selected to be plotted. Default = NA.</p>
</td></tr>
<tr><td><code id="plot3views_+3A_plot.legend">plot.legend</code></td>
<td>
<p>A vector of characters representing legends, also see the note below. Default = NA.</p>
</td></tr>
<tr><td><code id="plot3views_+3A_plot.pattern">plot.pattern</code></td>
<td>
<p>A vector of characters or integer representing patterns, also see the note below. Default = NA.</p>
</td></tr>
<tr><td><code id="plot3views_+3A_plot.color">plot.color</code></td>
<td>
<p>A vector of characters or integer representing  colors, also see the note below. Default = NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the vectors of plot.legend, plot.pattern, and plot.color
need to be defined as the same length. All of these vectors need to be given
to the function otherwise the default colors and patterns will be used.
The vectors need to be set properly, see the section &quot;Examples&quot; for more details.
</p>
<p>From version 1.1.5 onward, the parameter 'col.pat.table' is removed out from the
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load simulated dataset
data(example_SNP)

PCs &lt;- cal.pc.linear(simsnp$snp, no.pc = 3)
plot3views( PCs$PC, sample_labels)

#To change colors and patterns using symbols
all.labels &lt;- unique(sample_labels)
my.colors &lt;- c('pink', 'yellow', 'cyan', 'green')
my.patterns &lt;- c(0,1,2,3)
plot3views(PCs$PC, labels = sample_labels, plot.legend = all.labels,
plot.pattern = my.patterns, plot.color = my.colors)

#To change patterns using characters
my.patterns &lt;- c('o', 'x', '&amp;', '#')
#To change colors using Hex code
my.colors &lt;- c('#E74C3C', '#8E44AD', '#2ECC71', '#E67E22')
plot3views(PCs$PC, labels = sample_labels, plot.legend = all.labels,
plot.pattern = my.patterns, plot.color = my.colors)
</code></pre>

<hr>
<h2 id='read.bed'>Read the binary PLINK format (BED, BIM, and FAM)</h2><span id='topic+read.bed'></span>

<h3>Description</h3>

<p>Require the complete set of 3 files in the binary
PLINK format. It includes BED file, BIM file and BAM file. For more
information about the binary PLINK format, please check in the manual of
PLINK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bed(bed, bim, fam, only.snp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bed_+3A_bed">bed</code></td>
<td>
<p>A path of BED file</p>
</td></tr>
<tr><td><code id="read.bed_+3A_bim">bim</code></td>
<td>
<p>A path of BIM file</p>
</td></tr>
<tr><td><code id="read.bed_+3A_fam">fam</code></td>
<td>
<p>A path of FAM file</p>
</td></tr>
<tr><td><code id="read.bed_+3A_only.snp">only.snp</code></td>
<td>
<p>If TRUE, the function to read only SNP matrix, otherwise all
files are loaded. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the binary PLINK format, please check
<a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>
</p>


<h3>Value</h3>

<p>The list containing the matrices of <code>$snp</code>, <code>$snp.info</code>,
and <code>$ind.info</code>.
</p>

<ul>
<li> <p><code>$snp</code> is a SNP matrix from BED file.
</p>
</li>
<li> <p><code>$snp.info</code> is a data.frame of SNP information from BIM file.
</p>
</li>
<li> <p><code>$ind.info</code> is a data.frame of individual information from FAM file.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+write.bed">write.bed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Use the example files embedded in the package.
bed &lt;- system.file("extdata", "example_SNP.bed", package="KRIS")
bim &lt;- system.file("extdata", "example_SNP.bim", package="KRIS")
fam &lt;- system.file("extdata", "example_SNP.fam", package="KRIS")
snp &lt;- read.bed(bed, bim, fam )

#Check the objects inside 'snp'
ls(snp)

#Preview $snp
print(snp$snp[1:10, 1:10])

#Preview $snp.info
head(snp$snp.info)

#Preview $ind.info
head(snp$ind.info)
</code></pre>

<hr>
<h2 id='replace.missing'>(Internal) Replace missing values with other values,internally used for
parallelization</h2><span id='topic+replace.missing'></span>

<h3>Description</h3>

<p>(Internal) Replace missing values with other values,internally used for
parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.missing(X, missing = NA, rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace.missing_+3A_x">X</code></td>
<td>
<p>An input vector</p>
</td></tr>
<tr><td><code id="replace.missing_+3A_missing">missing</code></td>
<td>
<p>A charactors representing a missing value</p>
</td></tr>
<tr><td><code id="replace.missing_+3A_rep">rep</code></td>
<td>
<p>A vector of new values to replace missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with replaced values
</p>

<hr>
<h2 id='rubikclust'>Unsupervised clustering to detect rough structures and outliers.</h2><span id='topic+rubikclust'></span>

<h3>Description</h3>

<p>Handle and operate on Nx3 matrix, where N is the number of
samples and data are collected on 3 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubikclust(X, min.space = 0.4, rotation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubikclust_+3A_x">X</code></td>
<td>
<p>A data matrix for which rows represent samples and the 3 columns
represent features. Missingness is not allowed.</p>
</td></tr>
<tr><td><code id="rubikclust_+3A_min.space">min.space</code></td>
<td>
<p>A value to specify a minimum space between 2 consecutive
projected values. Default = 0.4.</p>
</td></tr>
<tr><td><code id="rubikclust_+3A_rotation">rotation</code></td>
<td>
<p>To specify if rotation is enabled or not. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function rubikClust is able to take up to 3 variables
(N x 3 matrix). In case, a matrix contains more than 3 columns, only the
first three columns are used; the other columns are ignored.
</p>


<h3>Value</h3>

<p>The returned value is a vector of numbers representing cluster
memberships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load simulated dataset
data(example_SNP)

PCs &lt;- cal.pc.linear(simsnp$snp, no.pc = 3)

#Run rubikclust with the default parameters
groups &lt;- rubikclust(PCs$PC)
#Check clustering results
print(groups)

#Check cluster's distribution
table(groups)

#Check the plot, highlight the points according to the clustering result
mylabels &lt;- paste0("group", as.factor(groups))
plot3views( PCs$PC, labels = mylabels)

#Run rubikclust with min.space = 0.02
groups &lt;- rubikclust(PCs$PC, min.space = 0.02)
#Check clustering results
print(groups)

#Check cluster's distribution
table(groups)

#Check the plot, highlight the points according to the clustering result
mylabels &lt;- paste0("group", as.factor(groups))
plot3views( PCs$PC, labels = mylabels)
</code></pre>

<hr>
<h2 id='sample_labels'>Synthetic dataset containing population labels for the dataset simsnp.</h2><span id='topic+sample_labels'></span>

<h3>Description</h3>

<p>A dataset contains a character vector of 753 elements containing labels or
populations of 753 individuals which they belong. Three populations and
outliers were labeled as &quot;pop1&quot;, &quot;pop2&quot;, &quot;pop3&quot;, and &quot;outlier&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_SNP)
</code></pre>


<h3>Format</h3>

<p>A vector with 753 elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simsnp">simsnp</a></code>
</p>

<hr>
<h2 id='simsnp'>Synthetic dataset containing single nucleotide polymorphisms (SNP)</h2><span id='topic+simsnp'></span>

<h3>Description</h3>

<p>The simsnp is the simulated dataset which consists of 3,000 independent SNPs
and 753 individuals belonging to one of three populations (250 individuals
each) and 3 outlying individuals. The pairwise genetic distance between
populations was set to Fst=0.01 as in Balding (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_SNP)
</code></pre>


<h3>Format</h3>

<p>A list with 3 objects
</p>


<h3>Details</h3>


<dl>
<dt>ind.info</dt><dd><p>A character matrix of 753 rows and 6 columns representing
individuals and individual information respectively. The columns of
ind.info represents sample_ID, family_ID, father_ID, mother_ID, gender,
and phenotype respectively.</p>
</dd>
<dt>snp.info</dt><dd><p>A character matrix of 3,000 rows and 6 columns representing
SNPs and SNP information respectively. The columns of snp.info represents
SNP_CHR (chromosome), SNP_ID, centimorgan, position, allele1, and allele2
respectively.</p>
</dd>
<dt>snp</dt><dd><p>A numeric matrix of 753 rows and 3,000 columns representing
individuals and SNPs respectively. The matrix snp contains the number 0, 1,
and 2 representing SNP in additive coding.</p>
</dd>
</dl>



<h3>References</h3>

<p>Balding, D.J., and Nichols, R.A. (1995). A method for quantifying
differentiation between populations at multi-allelic loci and its
implications for investigating identity and paternity. Genetica 96, 3-12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_labels">sample_labels</a></code>
</p>

<hr>
<h2 id='write.bed'>Write a list of SNP object to the binary PLINK format (BED, BIM, and FAM)</h2><span id='topic+write.bed'></span>

<h3>Description</h3>

<p>Write a SNP object to the files in the binary
PLINK format. For more information about the binary PLINK format, please
check in the manual of PLINK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.bed(object, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bed_+3A_object">object</code></td>
<td>
<p>An object of SNP is a list consisting of 3 matrices, see the
<em>Details</em> section for more details.</p>
</td></tr>
<tr><td><code id="write.bed_+3A_file">file</code></td>
<td>
<p>A prefix of output files for BED, BIM and FAM to be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>object</code> should contain:
</p>

<ul>
<li> <p><code>$snp</code> is a SNP matrix from BED file.
</p>
</li>
<li> <p><code>$snp.info</code> is a data.frame of SNP information from BIM file.
</p>
</li>
<li> <p><code>$ind.info</code> is a data.frame of individual information from FAM file.
</p>
</li></ul>

<p>For more details about the binary PLINK format, please check
<a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bed">read.bed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Load example data
data(example_SNP)

#Save 'simsnp' to the file as defined in 'save.file'
save.file &lt;- file.path(tempdir(),"new_SNP")
write.bed(simsnp , save.file)
</code></pre>

<hr>
<h2 id='xxt'>Calculate matrix multipication between a matrix and its
transpose for large data.</h2><span id='topic+xxt'></span>

<h3>Description</h3>

<p>Calculate matrix multiplication using &quot;divide and
conquer technique&quot;, which accelerates the computation to be faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xxt(X, window.size = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xxt_+3A_x">X</code></td>
<td>
<p>An input matrix to be processed.</p>
</td></tr>
<tr><td><code id="xxt_+3A_window.size">window.size</code></td>
<td>
<p>The window size of matrices to be devided. The default
value is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multiplication matrix of <code>X.t(X)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Use the example files embedded in the package.
X &lt;-matrix(runif(100), ncol=20)
R1  &lt;- xxt(X)

#Show the result (R1)
print(R1)
R2 &lt;- X %*% t(X)

#Show the result (R2)
print(R2)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
