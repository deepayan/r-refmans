<!DOCTYPE html><html><head><title>Help for package DoE.base</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DoE.base}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.response'><p> Function to add response values to an experimental design</p></a></li>
<li><a href='#arrays'><p> Orthogonal arrays in the package</p></a></li>
<li><a href='#block.catlg3'>
<p>Catalogues for blocking full factorial 2-level and 3-level designs,</p>
and lists of generating columns for regular 2- and 3-level designs.</a></li>
<li><a href='#Class design and accessors'><p> Class design and its accessor functions</p></a></li>
<li><a href='#contr.FrF2'><p> Contrasts for orthogonal Fractional Factorial 2-level designs</p></a></li>
<li><a href='#corrPlot'>
<p>Function to Visualize Correlations Between Model Matrix Columns for an Experimental Design</p></a></li>
<li><a href='#cross.design'><p>Function to cross several designs</p></a></li>
<li><a href='#DoE.base-package'>
<p>Full factorials, orthogonal arrays and base utilities for DoE packages</p></a></li>
<li><a href='#expansive.replace'><p> Expansive replacement for two orthogonal arrays</p></a></li>
<li><a href='#export.design'><p> Function for exporting a design object</p></a></li>
<li><a href='#fac.design'><p> Function for full factorial designs</p></a></li>
<li><a href='#factorize'>
<p>Factorize integer numbers and factors</p></a></li>
<li><a href='#formula.design'><p> Function to change the default formula for a data frame of</p>
class design to involve the correct factors with the desired effects
and responses</a></li>
<li><a href='#genChild'>
<p>Internal utility functions to support automatic creation of child arrays</p>
from entries of the data frame oacat</a></li>
<li><a href='#generalized.word.length'>
<p>Functions for calculating the generalized word length pattern,</p>
projection frequency tables or optimizing column selection within an array</a></li>
<li><a href='#getblock'>
<p>Functions to extract a block factor from a class design object</p>
or to rerandomize a class design object</a></li>
<li><a href='#GRind'>
<p>Functions for calculating generalized resolution, average R-squared values and</p>
squared canonical correlations, and for checking design regularity</a></li>
<li><a href='#GWLP'><p> Function for fast calculation of GWLP</p></a></li>
<li><a href='#GWLP_internals'><p> Internal functions in support of function GWLP</p></a></li>
<li><a href='#halfnormal'>
<p>Creation of half normal effects plots and numeric methods for</p>
significance assessment</a></li>
<li><a href='#ICFTs'>
<p>Function for calculating interaction contribution frequency tables</p></a></li>
<li><a href='#iscube'>
<p>Functions to isolate cube points from 2-level fractional factorial design with center and / or star points</p></a></li>
<li><a href='#lm and aov method for class design objects'><p>lm and aov methods for class design objects</p></a></li>
<li><a href='#lowerbound_AR'>
<p>Function to Calculate a Lower Bound for A_R and Internal Auxiliary Functions</p></a></li>
<li><a href='#Methods for class design objects'><p>Methods for class design objects</p></a></li>
<li><a href='#oa_feasible'><p>Function to Check Whether an Array of Specified Strength Might Exist</p></a></li>
<li><a href='#oa.design'><p> Function for accessing orthogonal arrays</p></a></li>
<li><a href='#oacat'>
<p>Data Frames That List Available Orthogonal Arrays</p></a></li>
<li><a href='#param.design'><p> Function to generate Taguchi style parameter designs</p></a></li>
<li><a href='#planor2design'><p> Convert matrix, data frame or object of class planordesign</p>
to object of class design</a></li>
<li><a href='#Plotting class design objects'><p>Plotting class design objects</p></a></li>
<li><a href='#print.oa'>
<p>Function to Print oa Objects with a Lot of Added Info</p></a></li>
<li><a href='#qua.design'><p> Function to switch between qualitative and quantitative factors and</p>
different contrast settings</a></li>
<li><a href='#Reshape designs with repeated measurements'><p> Reshape designs with repeated measurements</p></a></li>
<li><a href='#show.oas'>
<p>Function to display list of available orthogonal arrays</p></a></li>
<li><a href='#SN'><p> Function for the signal-to-noise ratio 10 * log10(mean^2/var)</p></a></li>
<li><a href='#utilities'><p> Utility functions for DoE packages, not intended for direct use</p></a></li>
<li><a href='#VSGFS'><p> VSGFS: an experiment using an optimized orthogonal array in 72 runs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Full Factorials, Orthogonal Arrays and Base Utilities for DoE
Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), grid, conf.design</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices, vcd, combinat, MASS,
lattice, numbers, partitions</td>
</tr>
<tr>
<td>Suggests:</td>
<td>FrF2, DoE.wrapper, RColorBrewer</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates full factorial experimental designs and designs based on orthogonal arrays for (industrial) experiments. Provides diverse quality criteria. Provides utility functions for the class design, which is also used by other packages for designed experiments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prof.bht-berlin.de/groemping/DoE/">https://prof.bht-berlin.de/groemping/DoE/</a>,
<a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping [aut, cre],
  Boyko Amarov [ctb],
  Hongquan Xu [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 16:23:55 UTC; Gr√∂mping</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.response'> Function to add response values to an experimental design</h2><span id='topic+add.response'></span>

<h3>Description</h3>

<p>This function allows to add numeric response variables to an experimental plan of 
class design. The responses are added both to the data frame and to its desnum 
attribute; the response.names element of the design.info attribute is updated - 
the function is still experimental. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.response(design, response, rdapath=NULL, replace = FALSE, 
    InDec=options("OutDec")[[1]], tol = .Machine$double.eps ^ 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.response_+3A_design">design</code></td>
<td>
<p>a character string that gives the name of a class <code><a href="#topic+design">design</a></code> 
object, to which responses are to be added</p>
</td></tr>
<tr><td><code id="add.response_+3A_response">response</code></td>
<td>
<p>EITHER 
</p>
<p>a numeric vector, numeric matrix or data frame with at least 
one numeric variable (the treatment of these is explained in the details section)
</p>
<p>OR
</p>
<p>a character string indicating a csv file that contains the typed-in response values; 
after reading the csv file with the csv version indicated in the <code>InDec</code> argument, 
numeric variables from response will be added to the design as responses </p>
</td></tr>
<tr><td><code id="add.response_+3A_rdapath">rdapath</code></td>
<td>
<p>a character string indicating the path to a stored rda file that contains the 
design </p>
</td></tr>
<tr><td><code id="add.response_+3A_replace">replace</code></td>
<td>
<p> logical: TRUE implies that existing variables are overwritten in <code>design</code>; 
cf. also the details section</p>
</td></tr>
<tr><td><code id="add.response_+3A_indec">InDec</code></td>
<td>
<p> decimal separator in the external csv file; defaults to the 
<code>OutDec</code> option (viewable under <code>options("OutDec"</code>), 
and also governs whether the <code>csv</code>-file is read with <code><a href="utils.html#topic+read.table">read.csv</a></code> or with 
<code><a href="utils.html#topic+read.table">read.csv</a></code>: 
separator semicolon goes with decimal comma and triggers use of <code><a href="utils.html#topic+read.table">read.csv2</a></code>, 
separator comma goes with decimal point and trigggers use of <code><a href="utils.html#topic+read.table">read.csv</a></code>. )</p>
</td></tr>
<tr><td><code id="add.response_+3A_tol">tol</code></td>
<td>
<p>tolerance for comparing numerical values;<br />
useful for designs with numeric factors and for partial replacement of response values;
the value is used in comparisons of design and response via <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>; 
errors from peculiar rounding behavior of spreadsheet programs can be prevented by 
allowing a larger <code>tol</code> </p>
</td></tr>
<tr><td><code id="add.response_+3A_...">...</code></td>
<td>
<p>further arguments; currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>response</code> is a data frame or a matrix, responses are assumed to be 
all the numeric variables that are neither factor names or block names in <code>design</code> 
(i.e. names of the <code>factor.names</code> element of the <code>design.info</code> attribute 
or the <code>block.name</code> element of that same attribute)  
nor column names of the <code>run.order</code> attribute, nor <code>name</code> or <code>Name</code>. 
</p>
<p>If <code>design</code> already contains columns for the response(s), NA entries of these 
are overwritten, if all non-NA entries coincide between <code>design</code> 
and <code>response</code>. 
</p>
<p>The idea behind this function is as follows:
After using <code><a href="#topic+export.design">export.design</a></code> for storing an R work space with the 
design object and either a csv or html file externally, 
Excel or some other external software is used to type in experimental information. 
The thus-obtained data sheet is saved as a csv-file and imported into R again (name provided 
in argument <code>response</code>, and the design object with all attached information is 
linked to the typed in response values using function <code>add.response</code>.
</p>
<p>Alternatively, it is possible to simply type in experimental results in R, both 
using the R commander plugin (<span class="pkg">RcmdrPlugin.DoE</span>) or simply function <code><a href="utils.html#topic+fix">fix</a></code>. 
Copy-pasting into R from Excel is per default NOT possible, which has been the reason for programming this routine.
</p>


<h3>Value</h3>

<p>The value is a modified version of the argument object <code>design</code>, 
which remains an object of class <code><a href="#topic+design">design</a></code> with the following modifications: 
</p>

<ul>
<li><p> Response columns are added to the data frame
</p>
</li>
<li><p> the same response columns are added to the desnum attribute
</p>
</li>
<li><p> the <code>response.names</code> element of the <code>design.info</code> attribute is added or modified
</p>
</li></ul>



<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+export.design">export.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>       plan &lt;- fac.design(nlevels=c(2,3,2,4))
       result &lt;- rnorm(2*3*2*4)
       add.response(plan,response=result)
       ## direct use of rnorm() is also possible, but looks better with 48 
       add.response(plan,response=rnorm(48))
       
   ## Not run:    
       export.design(path="c:/projectA/experiments",plan)
       ## open exported file c:/projectA/experiments/plan.html
       ##        with Excel
       ## carry out the experiment, input data in Excel or elsewhere
       ##        store as csv file with the same name (or a different one, just use 
       ##        the correct storage name later in R), after deleting 
       ##        the legend portion to the right of the data area
       ##        (alternatively, input data by typing them in in R (function fix or R-commander)
       add.response(design="plan",response="c:/projectA/experiments/plan.csv",
                 rdapath="c:/projectA/experiments/plan.rda")
       ## plan is the name of the design in the workspace stored in rdapath
       ## assuming only responses were typed in
       ## should work on your computer regardless of system, 
       ##         if you adapt the path names accordingly
   
## End(Not run)
</code></pre>

<hr>
<h2 id='arrays'> Orthogonal arrays in the package </h2><span id='topic+arrays'></span><span id='topic+L18'></span><span id='topic+L36'></span><span id='topic+L54'></span><span id='topic+L4.2.3'></span><span id='topic+L8.2.4.4.1'></span><span id='topic+L9.3.4'></span><span id='topic+L12.2.11'></span><span id='topic+L12.2.2.6.1'></span><span id='topic+L12.2.4.3.1'></span><span id='topic+L16.2.8.8.1'></span><span id='topic+L16.4.5'></span><span id='topic+L18.3.6.6.1'></span><span id='topic+L20.2.19'></span><span id='topic+L20.2.2.10.1'></span><span id='topic+L20.2.8.5.1'></span><span id='topic+L24.2.11.4.1.6.1'></span><span id='topic+L24.2.12.12.1'></span><span id='topic+L24.2.13.3.1.4.1'></span><span id='topic+L24.2.20.4.1'></span><span id='topic+L25.5.6'></span><span id='topic+L27.3.9.9.1'></span><span id='topic+L28.2.12.7.1'></span><span id='topic+L28.2.2.14.1'></span><span id='topic+L28.2.27'></span><span id='topic+L32.2.16.16.1'></span><span id='topic+L32.4.8.8.1'></span><span id='topic+L36.2.1.3.3.6.3'></span><span id='topic+L36.2.10.3.1.6.2'></span><span id='topic+L36.2.10.3.8.6.1'></span><span id='topic+L36.2.13.3.2.6.1'></span><span id='topic+L36.2.13.6.2'></span><span id='topic+L36.2.16.9.1'></span><span id='topic+L36.2.18.3.1.6.1'></span><span id='topic+L36.2.2.18.1'></span><span id='topic+L36.2.2.3.5.6.2'></span><span id='topic+L36.2.20.3.2'></span><span id='topic+L36.2.27.3.1'></span><span id='topic+L36.2.3.3.2.6.3'></span><span id='topic+L36.2.3.3.9.6.1'></span><span id='topic+L36.2.35'></span><span id='topic+L36.2.4.3.1.6.3'></span><span id='topic+L36.2.8.6.3'></span><span id='topic+L36.2.9.3.4.6.2'></span><span id='topic+L36.3.12.12.1'></span><span id='topic+L36.3.7.6.3'></span><span id='topic+L40.2.19.4.1.10.1'></span><span id='topic+L40.2.20.20.1'></span><span id='topic+L40.2.25.4.1.5.1'></span><span id='topic+L40.2.36.4.1'></span><span id='topic+L44.2.15.11.1'></span><span id='topic+L44.2.2.22.1'></span><span id='topic+L44.2.43'></span><span id='topic+L45.3.9.15.1'></span><span id='topic+L48.2.24.24.1'></span><span id='topic+L48.2.31.6.1.8.1'></span><span id='topic+L48.2.33.3.1.8.1'></span><span id='topic+L48.2.40.8.1'></span><span id='topic+L48.4.12.12.1'></span><span id='topic+L49.7.8'></span><span id='topic+L50.5.10.10.1'></span><span id='topic+L52.2.16.13.1'></span><span id='topic+L52.2.2.26.1'></span><span id='topic+L52.2.51'></span><span id='topic+L54.3.18.18.1'></span><span id='topic+L54.3.20.6.1.9.1'></span><span id='topic+L56.2.27.4.1.14.1'></span><span id='topic+L56.2.28.28.1'></span><span id='topic+L56.2.37.4.1.7.1'></span><span id='topic+L56.2.52.4.1'></span><span id='topic+L60.2.15.6.1.10.1'></span><span id='topic+L60.2.17.15.1'></span><span id='topic+L60.2.2.30.1'></span><span id='topic+L60.2.21.10.1'></span><span id='topic+L60.2.23.5.1'></span><span id='topic+L60.2.24.6.1'></span><span id='topic+L60.2.30.3.1'></span><span id='topic+L60.2.59'></span><span id='topic+L63.3.12.21.1'></span><span id='topic+L64.2.32.32.1'></span><span id='topic+L64.2.5.4.10.8.4'></span><span id='topic+L64.2.5.4.17.8.1'></span><span id='topic+L64.4.14.8.3'></span><span id='topic+L64.4.16.16.1'></span><span id='topic+L64.4.7.8.6'></span><span id='topic+L64.8.9'></span><span id='topic+L68.2.18.17.1'></span><span id='topic+L68.2.2.34.1'></span><span id='topic+L68.2.67'></span><span id='topic+L72.2.10.3.13.4.1.6.3'></span><span id='topic+L72.2.10.3.16.6.2.12.1'></span><span id='topic+L72.2.10.3.20.4.1.6.2'></span><span id='topic+L72.2.11.3.17.4.1.6.2'></span><span id='topic+L72.2.11.3.20.6.1.12.1'></span><span id='topic+L72.2.12.3.21.4.1.6.1'></span><span id='topic+L72.2.14.3.3.4.1.6.6'></span><span id='topic+L72.2.15.3.7.4.1.6.5'></span><span id='topic+L72.2.17.3.12.4.1.6.3'></span><span id='topic+L72.2.18.3.16.4.1.6.2'></span><span id='topic+L72.2.19.3.20.4.1.6.1'></span><span id='topic+L72.2.27.3.11.6.1.12.1'></span><span id='topic+L72.2.27.3.6.6.4'></span><span id='topic+L72.2.28.3.2.6.4'></span><span id='topic+L72.2.30.3.1.6.4'></span><span id='topic+L72.2.31.6.4'></span><span id='topic+L72.2.34.3.3.4.1.6.3'></span><span id='topic+L72.2.34.3.8.4.1.6.2'></span><span id='topic+L72.2.35.3.12.4.1.6.1'></span><span id='topic+L72.2.35.3.5.4.1.6.2'></span><span id='topic+L72.2.35.4.1.18.1'></span><span id='topic+L72.2.36.3.2.4.1.6.3'></span><span id='topic+L72.2.36.3.9.4.1.6.1'></span><span id='topic+L72.2.36.36.1'></span><span id='topic+L72.2.37.3.1.4.1.6.3'></span><span id='topic+L72.2.37.3.13.4.1'></span><span id='topic+L72.2.41.4.1.6.3'></span><span id='topic+L72.2.42.3.4.4.1.6.2'></span><span id='topic+L72.2.43.3.1.4.1.6.2'></span><span id='topic+L72.2.43.3.8.4.1.6.1'></span><span id='topic+L72.2.44.3.12.4.1'></span><span id='topic+L72.2.46.3.2.4.1.6.1'></span><span id='topic+L72.2.46.4.1.6.2'></span><span id='topic+L72.2.49.4.1.9.1'></span><span id='topic+L72.2.5.3.3.4.1.6.7'></span><span id='topic+L72.2.51.3.1.4.1.6.1'></span><span id='topic+L72.2.53.3.2.4.1'></span><span id='topic+L72.2.6.3.3.6.6.12.1'></span><span id='topic+L72.2.6.3.7.4.1.6.6'></span><span id='topic+L72.2.60.3.1.4.1'></span><span id='topic+L72.2.68.4.1'></span><span id='topic+L72.2.7.3.4.4.1.6.6'></span><span id='topic+L72.2.7.3.7.6.5.12.1'></span><span id='topic+L72.2.8.3.12.4.1.6.4'></span><span id='topic+L72.2.8.3.8.4.1.6.5'></span><span id='topic+L72.2.9.3.12.6.3.12.1'></span><span id='topic+L72.2.9.3.16.4.1.6.3'></span><span id='topic+L72.3.24.24.1'></span><span id='topic+L75.5.8.15.1'></span><span id='topic+L76.2.19.19.1'></span><span id='topic+L76.2.2.38.1'></span><span id='topic+L76.2.75'></span><span id='topic+L80.2.40.40.1'></span><span id='topic+L80.2.51.4.3.20.1'></span><span id='topic+L80.2.55.8.1.10.1'></span><span id='topic+L80.2.61.5.1.8.1'></span><span id='topic+L80.2.72.8.1'></span><span id='topic+L80.4.10.20.1'></span><span id='topic+L81.3.27.27.1'></span><span id='topic+L81.9.10'></span><span id='topic+L84.2.14.6.1.14.1'></span><span id='topic+L84.2.2.42.1'></span><span id='topic+L84.2.20.21.1'></span><span id='topic+L84.2.20.3.1.14.1'></span><span id='topic+L84.2.22.6.1.7.1'></span><span id='topic+L84.2.27.6.1'></span><span id='topic+L84.2.28.7.1'></span><span id='topic+L84.2.33.3.1'></span><span id='topic+L84.2.83'></span><span id='topic+L88.2.43.4.1.22.1'></span><span id='topic+L88.2.44.44.1'></span><span id='topic+L88.2.56.4.1.11.1'></span><span id='topic+L88.2.84.4.1'></span><span id='topic+L90.3.26.6.1.15.1'></span><span id='topic+L90.3.30.30.1'></span><span id='topic+L92.2.2.46.1'></span><span id='topic+L92.2.21.23.1'></span><span id='topic+L92.2.91'></span><span id='topic+L96.2.12.4.20.24.1'></span><span id='topic+L96.2.17.4.23.6.1'></span><span id='topic+L96.2.18.4.22.12.1'></span><span id='topic+L96.2.19.3.1.4.23'></span><span id='topic+L96.2.26.4.23'></span><span id='topic+L96.2.39.3.1.4.14.8.1'></span><span id='topic+L96.2.43.4.12.6.1.8.1'></span><span id='topic+L96.2.43.4.15.8.1'></span><span id='topic+L96.2.44.4.11.8.1.12.1'></span><span id='topic+L96.2.48.48.1'></span><span id='topic+L96.2.71.6.1.16.1'></span><span id='topic+L96.2.73.3.1.16.1'></span><span id='topic+L96.2.80.16.1'></span><span id='topic+L98.7.14.14.1'></span><span id='topic+L99.3.13.33.1'></span><span id='topic+L100.2.16.5.3.10.3'></span><span id='topic+L100.2.18.5.9.10.1'></span><span id='topic+L100.2.2.50.1'></span><span id='topic+L100.2.22.25.1'></span><span id='topic+L100.2.29.5.5'></span><span id='topic+L100.2.34.5.3.10.1'></span><span id='topic+L100.2.4.10.4'></span><span id='topic+L100.2.40.5.4'></span><span id='topic+L100.2.5.5.4.10.3'></span><span id='topic+L100.2.51.5.3'></span><span id='topic+L100.2.7.5.10.10.1'></span><span id='topic+L100.2.99'></span><span id='topic+L100.5.20.20.1'></span><span id='topic+L100.5.8.10.3'></span><span id='topic+L104.2.100.4.1'></span><span id='topic+L104.2.51.4.1.26.1'></span><span id='topic+L104.2.52.52.1'></span><span id='topic+L104.2.65.4.1.13.1'></span><span id='topic+L108.2.1.3.33.6.2.18.1'></span><span id='topic+L108.2.1.3.35.6.3.9.1'></span><span id='topic+L108.2.10.3.31.6.1.18.1'></span><span id='topic+L108.2.10.3.33.6.2.9.1'></span><span id='topic+L108.2.10.3.40.6.1.9.1'></span><span id='topic+L108.2.107'></span><span id='topic+L108.2.12.3.29.6.3'></span><span id='topic+L108.2.13.3.30.6.1.18.1'></span><span id='topic+L108.2.13.6.3'></span><span id='topic+L108.2.15.6.1.18.1'></span><span id='topic+L108.2.17.3.29.6.2'></span><span id='topic+L108.2.18.3.31.18.1'></span><span id='topic+L108.2.18.3.33.6.1.9.1'></span><span id='topic+L108.2.2.3.35.6.1.18.1'></span><span id='topic+L108.2.2.3.37.6.2.9.1'></span><span id='topic+L108.2.2.3.42.18.1'></span><span id='topic+L108.2.2.54.1'></span><span id='topic+L108.2.20.3.34.9.1'></span><span id='topic+L108.2.21.3.1.6.2'></span><span id='topic+L108.2.22.27.1'></span><span id='topic+L108.2.27.3.33.9.1'></span><span id='topic+L108.2.3.3.16.6.8'></span><span id='topic+L108.2.3.3.32.6.2.18.1'></span><span id='topic+L108.2.3.3.34.6.3.9.1'></span><span id='topic+L108.2.3.3.39.18.1'></span><span id='topic+L108.2.3.3.41.6.1.9.1'></span><span id='topic+L108.2.34.3.29.6.1'></span><span id='topic+L108.2.4.3.31.6.2.18.1'></span><span id='topic+L108.2.4.3.33.6.3.9.1'></span><span id='topic+L108.2.40.6.1'></span><span id='topic+L108.2.8.3.30.6.2.18.1'></span><span id='topic+L108.2.9.3.34.6.1.18.1'></span><span id='topic+L108.2.9.3.36.6.2.9.1'></span><span id='topic+L108.3.36.36.1'></span><span id='topic+L108.3.37.6.2.18.1'></span><span id='topic+L108.3.39.6.3.9.1'></span><span id='topic+L108.3.4.6.11'></span><span id='topic+L108.3.44.9.1.12.1'></span><span id='topic+L112.2.104.8.1'></span><span id='topic+L112.2.56.56.1'></span><span id='topic+L112.2.75.4.3.28.1'></span><span id='topic+L112.2.79.8.1.14.1'></span><span id='topic+L112.2.89.7.1.8.1'></span><span id='topic+L112.4.12.28.1'></span><span id='topic+L116.2.115'></span><span id='topic+L116.2.2.58.1'></span><span id='topic+L116.2.23.29.1'></span><span id='topic+L117.3.13.39.1'></span><span id='topic+L120.2.116.4.1'></span><span id='topic+L120.2.28.10.1.12.1'></span><span id='topic+L120.2.30.6.1.20.1'></span><span id='topic+L120.2.59.4.1.30.1'></span><span id='topic+L120.2.60.60.1'></span><span id='topic+L120.2.68.4.1.6.1.10.1'></span><span id='topic+L120.2.70.3.1.4.1.10.1'></span><span id='topic+L120.2.70.4.1.5.1.6.1'></span><span id='topic+L120.2.74.4.1.15.1'></span><span id='topic+L120.2.75.4.1.10.1'></span><span id='topic+L120.2.75.4.1.6.1'></span><span id='topic+L120.2.79.4.1.5.1'></span><span id='topic+L120.2.87.3.1.4.1'></span><span id='topic+L121.11.12'></span><span id='topic+L124.2.123'></span><span id='topic+L124.2.2.62.1'></span><span id='topic+L124.2.22.31.1'></span><span id='topic+L125.5.25.25.1'></span><span id='topic+L126.3.20.6.1.21.1'></span><span id='topic+L126.3.21.42.1'></span><span id='topic+L126.3.23.6.1.7.1'></span><span id='topic+L126.3.24.14.1'></span><span id='topic+L128.2.3.4.11.8.13'></span><span id='topic+L128.2.3.4.18.8.10'></span><span id='topic+L128.2.3.4.25.8.7'></span><span id='topic+L128.2.4.4.15.8.9.16.1'></span><span id='topic+L128.2.4.4.22.8.6.16.1'></span><span id='topic+L128.2.4.4.29.8.3.16.1'></span><span id='topic+L128.2.4.4.36.16.1'></span><span id='topic+L128.2.4.4.8.8.12.16.1'></span><span id='topic+L128.2.5.4.10.8.11.16.1'></span><span id='topic+L128.2.5.4.17.8.8.16.1'></span><span id='topic+L128.2.5.4.24.8.5.16.1'></span><span id='topic+L128.2.5.4.31.8.2.16.1'></span><span id='topic+L128.2.5.4.8.8.14'></span><span id='topic+L128.2.6.4.12.8.10.16.1'></span><span id='topic+L128.2.6.4.19.8.7.16.1'></span><span id='topic+L128.2.6.4.26.8.4.16.1'></span><span id='topic+L128.2.6.4.33.8.1.16.1'></span><span id='topic+L128.2.6.4.5.8.13.16.1'></span><span id='topic+L128.2.15.8.1'></span><span id='topic+L128.2.64.64.1'></span><span id='topic+L128.4.32.32.1'></span><span id='topic+L128.8.16.16.1'></span><span id='topic+L132.2.131'></span><span id='topic+L132.2.15.6.1.22.1'></span><span id='topic+L132.2.18.3.1.22.1'></span><span id='topic+L132.2.18.6.1.11.1'></span><span id='topic+L132.2.2.66.1'></span><span id='topic+L132.2.22.33.1'></span><span id='topic+L132.2.27.11.1'></span><span id='topic+L132.2.42.6.1'></span><span id='topic+L135.3.27.45.1'></span><span id='topic+L135.3.32.9.1.15.1'></span><span id='topic+L136.2.132.4.1'></span><span id='topic+L136.2.67.4.1.34.1'></span><span id='topic+L136.2.68.68.1'></span><span id='topic+L136.2.83.4.1.17.1'></span><span id='topic+L140.2.139'></span><span id='topic+L140.2.17.10.1.14.1'></span><span id='topic+L140.2.2.70.1'></span><span id='topic+L140.2.21.7.1.10.1'></span><span id='topic+L140.2.22.35.1'></span><span id='topic+L140.2.25.5.1.14.1'></span><span id='topic+L140.2.27.5.1.7.1'></span><span id='topic+L140.2.34.14.1'></span><span id='topic+L140.2.36.10.1'></span><span id='topic+L140.2.38.7.1'></span><span id='topic+L144.12.7'></span><span id='topic+L144.2.103.8.1.18.1'></span><span id='topic+L144.2.111.6.1.24.1'></span><span id='topic+L144.2.113.3.1.24.1'></span><span id='topic+L144.2.117.8.1.9.1'></span><span id='topic+L144.2.136.8.1'></span><span id='topic+L144.2.16.3.3.6.6.24.1'></span><span id='topic+L144.2.44.3.11.12.2'></span><span id='topic+L144.2.72.72.1'></span><span id='topic+L144.2.74.3.4.6.6.8.1'></span><span id='topic+L144.2.75.3.3.4.1.6.6.12.1'></span><span id='topic+L144.2.76.3.12.6.4.8.1'></span><span id='topic+L144.2.76.3.7.4.1.6.5.12.1'></span><span id='topic+L144.3.48.48.1'></span><span id='topic+L144.4.11.12.2'></span><span id='topic+L144.4.36.36.1'></span><span id='topic+L144.2.1.3.2.4.2'></span><span id='topic+L144.2.2.3.2.4.2'></span><span id='topic+L216.2.1.3.2.4.1.6.1'></span><span id='topic+L288.3.2.4.2.6.1'></span><span id='topic+L432.2.1.3.3.4.2'></span><span id='topic+L256.2.19'></span><span id='topic+L2048.2.63'></span><span id='topic+L32.2.9'></span><span id='topic+L32.2.16'></span><span id='topic+L32.2.4.4.2'></span><span id='topic+L40.2.6.5.1'></span><span id='topic+L48.2.9.3.1'></span><span id='topic+L48.2.7.6.1'></span><span id='topic+L48.2.4.3.1.4.1'></span><span id='topic+L54.2.1.3.5'></span><span id='topic+L64.2.12.4.2'></span><span id='topic+L64.2.8.4.3'></span><span id='topic+L64.2.7.8.1'></span><span id='topic+L64.2.6.4.4'></span><span id='topic+L64.4.6'></span><span id='topic+L72.2.12.3.2'></span><span id='topic+L72.2.4.3.1.6.1'></span><span id='topic+L80.2.12.5.1'></span><span id='topic+L80.2.6.4.1.5.1'></span><span id='topic+L96.2.7.3.1'></span><span id='topic+L96.2.20.4.2'></span><span id='topic+L96.2.5.4.2.6.1'></span><span id='topic+L128.2.6.4.2'></span><span id='topic+L128.2.20.4.3'></span><span id='topic+L128.2.28.4.2'></span><span id='topic+L128.2.8.8.2'></span><span id='topic+L192.2.36.4.3'></span><span id='topic+L243.3.20'></span><span id='topic+L256.2.24.8.2'></span><span id='topic+L256.2.52.4.3'></span><span id='topic+L256.4.5'></span><span id='topic+L256.4.17'></span><span id='topic+L384.2.40.8.2'></span><span id='topic+L512.2.56.8.2'></span><span id='topic+L729.3.12'></span><span id='topic+L729.3.14'></span><span id='topic+L4096.4.12'></span><span id='topic+L243.3.121'></span><span id='topic+L256.4.85'></span><span id='topic+L27.3.4'></span><span id='topic+L48.2.3.3.1.4.1'></span><span id='topic+L81.3.5'></span><span id='topic+L81.3.8'></span><span id='topic+L81.3.10'></span><span id='topic+L125.5.6'></span><span id='topic+L192.2.3.3.1.4.2'></span><span id='topic+L192.2.2.4.2.6.1'></span><span id='topic+L192.2.1.3.1.4.3'></span><span id='topic+L243.3.6'></span><span id='topic+L243.3.11'></span><span id='topic+L243.3.121'></span><span id='topic+L343.7.8'></span><span id='topic+L384.2.4.3.1.4.2'></span><span id='topic+L512.8.9'></span><span id='topic+L576.2.2.3.1.4.2.6.1'></span><span id='topic+L576.3.1.4.3.6.1'></span><span id='topic+L625.5.6'></span><span id='topic+L729.3.56'></span><span id='topic+L729.9.10'></span><span id='topic+L1024.4.6'></span><span id='topic+L1024.4.11'></span><span id='topic+L1024.4.41'></span><span id='topic+L2187.3.112'></span><span id='topic+L2187.3.27'></span><span id='topic+L2187.3.14'></span><span id='topic+L2401.7.8'></span><span id='topic+L4096.4.126'></span><span id='topic+L4096.4.21'></span><span id='topic+L4096.8.9'></span><span id='topic+L6561.3.248'></span><span id='topic+L6561.3.41'></span><span id='topic+L6561.3.28'></span><span id='topic+L6561.9.10'></span>

<h3>Description</h3>

<p>Orthogonal arrays in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## strength 5 / resolution VI
L243.3.6
L384.2.4.3.1.4.2
L729.3.12
L1024.4.6
L2187.3.14
L4096.4.12
L6561.3.28 

## strength 4 / resolution V
L81.3.5
L96.2.7.3.1
L128.2.6.4.2
L192.2.3.3.1.4.2
L192.2.2.4.2.6.1 
L243.3.11
L256.2.19
L256.4.5
L576.2.2.3.1.4.2.6.1
L625.5.6 
L729.3.14
L1024.4.11
L2048.2.63
L2187.3.27
L2401.7.8
L4096.4.21
L4096.8.9
L6561.3.41 
L6561.9.10 

## strength 3 / resolution IV
L27.3.4
L32.2.9
L32.2.16
L32.2.4.4.2
L40.2.6.5.1
L48.2.9.3.1
L48.2.7.6.1
L48.2.3.3.1.4.1
L48.2.4.3.1.4.1
L54.2.1.3.5
L64.2.12.4.2
L64.2.8.4.3
L64.2.7.8.1
L64.2.6.4.4
L64.4.6
L72.2.12.3.2
L72.2.4.3.1.6.1
L80.2.12.5.1
L80.2.6.4.1.5.1
L81.3.8
L81.3.10
L96.2.20.4.2
L96.2.5.4.2.6.1
L125.5.6
L128.2.20.4.3
L128.2.28.4.2
L128.2.15.8.1
L128.2.8.8.2
L192.2.1.3.1.4.3 
L192.2.36.4.3
L243.3.20
L256.2.24.8.2
L256.2.52.4.3
L256.4.17
L256.4.85
L343.7.8 
L384.2.40.8.2
L512.2.56.8.2
L512.8.9
L576.3.1.4.3.6.1
L729.3.56
L729.9.10
L1024.4.41
L2187.3.112
L4096.4.126
L6561.3.248

## strength 2 / resolution III
L18
L36
L54
L4.2.3
L8.2.4.4.1
L9.3.4
L12.2.11
L12.2.2.6.1
L12.2.4.3.1
L16.2.8.8.1
L16.4.5
L18.3.6.6.1
L20.2.19
L20.2.2.10.1
L20.2.8.5.1
L24.2.11.4.1.6.1
L24.2.12.12.1
L24.2.13.3.1.4.1
L24.2.20.4.1
L25.5.6
L27.3.9.9.1
L28.2.12.7.1
L28.2.2.14.1
L28.2.27
L32.2.16.16.1
L32.4.8.8.1
L36.2.1.3.3.6.3
L36.2.10.3.1.6.2
L36.2.10.3.8.6.1
L36.2.13.3.2.6.1
L36.2.13.6.2
L36.2.16.9.1
L36.2.18.3.1.6.1
L36.2.2.18.1
L36.2.2.3.5.6.2
L36.2.20.3.2
L36.2.27.3.1
L36.2.3.3.2.6.3
L36.2.3.3.9.6.1
L36.2.35
L36.2.4.3.1.6.3
L36.2.8.6.3
L36.2.9.3.4.6.2
L36.3.12.12.1
L36.3.7.6.3
L40.2.19.4.1.10.1
L40.2.20.20.1
L40.2.25.4.1.5.1
L40.2.36.4.1
L44.2.15.11.1
L44.2.2.22.1
L44.2.43
L45.3.9.15.1
L48.2.24.24.1
L48.2.31.6.1.8.1
L48.2.33.3.1.8.1
L48.2.40.8.1
L48.4.12.12.1
L49.7.8
L50.5.10.10.1
L52.2.16.13.1
L52.2.2.26.1
L52.2.51
L54.3.18.18.1
L54.3.20.6.1.9.1
L56.2.27.4.1.14.1
L56.2.28.28.1
L56.2.37.4.1.7.1
L56.2.52.4.1
L60.2.15.6.1.10.1
L60.2.17.15.1
L60.2.2.30.1
L60.2.21.10.1
L60.2.23.5.1
L60.2.24.6.1
L60.2.30.3.1
L60.2.59
L63.3.12.21.1
L64.2.32.32.1
L64.2.5.4.10.8.4
L64.2.5.4.17.8.1
L64.4.14.8.3
L64.4.16.16.1
L64.4.7.8.6
L64.8.9
L68.2.18.17.1
L68.2.2.34.1
L68.2.67
L72.2.10.3.13.4.1.6.3
L72.2.10.3.16.6.2.12.1
L72.2.10.3.20.4.1.6.2
L72.2.11.3.17.4.1.6.2
L72.2.11.3.20.6.1.12.1
L72.2.12.3.21.4.1.6.1
L72.2.14.3.3.4.1.6.6
L72.2.15.3.7.4.1.6.5
L72.2.17.3.12.4.1.6.3
L72.2.18.3.16.4.1.6.2
L72.2.19.3.20.4.1.6.1
L72.2.27.3.11.6.1.12.1
L72.2.27.3.6.6.4
L72.2.28.3.2.6.4
L72.2.30.3.1.6.4
L72.2.31.6.4
L72.2.34.3.3.4.1.6.3
L72.2.34.3.8.4.1.6.2
L72.2.35.3.12.4.1.6.1
L72.2.35.3.5.4.1.6.2
L72.2.35.4.1.18.1
L72.2.36.3.2.4.1.6.3
L72.2.36.3.9.4.1.6.1
L72.2.36.36.1
L72.2.37.3.1.4.1.6.3
L72.2.37.3.13.4.1
L72.2.41.4.1.6.3
L72.2.42.3.4.4.1.6.2
L72.2.43.3.1.4.1.6.2
L72.2.43.3.8.4.1.6.1
L72.2.44.3.12.4.1
L72.2.46.3.2.4.1.6.1
L72.2.46.4.1.6.2
L72.2.49.4.1.9.1
L72.2.5.3.3.4.1.6.7
L72.2.51.3.1.4.1.6.1
L72.2.53.3.2.4.1
L72.2.6.3.3.6.6.12.1
L72.2.6.3.7.4.1.6.6
L72.2.60.3.1.4.1
L72.2.68.4.1
L72.2.7.3.4.4.1.6.6
L72.2.7.3.7.6.5.12.1
L72.2.8.3.12.4.1.6.4
L72.2.8.3.8.4.1.6.5
L72.2.9.3.12.6.3.12.1
L72.2.9.3.16.4.1.6.3
L72.3.24.24.1
L75.5.8.15.1
L76.2.19.19.1
L76.2.2.38.1
L76.2.75
L80.2.40.40.1
L80.2.51.4.3.20.1
L80.2.55.8.1.10.1
L80.2.61.5.1.8.1
L80.2.72.8.1
L80.4.10.20.1
L81.3.27.27.1
L81.9.10
L84.2.14.6.1.14.1
L84.2.2.42.1
L84.2.20.21.1
L84.2.20.3.1.14.1
L84.2.22.6.1.7.1
L84.2.27.6.1
L84.2.28.7.1
L84.2.33.3.1
L84.2.83
L88.2.43.4.1.22.1
L88.2.44.44.1
L88.2.56.4.1.11.1
L88.2.84.4.1
L90.3.26.6.1.15.1
L90.3.30.30.1
L92.2.2.46.1
L92.2.21.23.1
L92.2.91
L96.2.12.4.20.24.1
L96.2.17.4.23.6.1
L96.2.18.4.22.12.1
L96.2.19.3.1.4.23
L96.2.26.4.23
L96.2.39.3.1.4.14.8.1
L96.2.43.4.12.6.1.8.1
L96.2.43.4.15.8.1
L96.2.44.4.11.8.1.12.1
L96.2.48.48.1
L96.2.71.6.1.16.1
L96.2.73.3.1.16.1
L96.2.80.16.1
L98.7.14.14.1
L99.3.13.33.1
L100.2.16.5.3.10.3
L100.2.18.5.9.10.1
L100.2.2.50.1
L100.2.22.25.1
L100.2.29.5.5
L100.2.34.5.3.10.1
L100.2.4.10.4
L100.2.40.5.4
L100.2.5.5.4.10.3
L100.2.51.5.3
L100.2.7.5.10.10.1
L100.2.99
L100.5.20.20.1
L100.5.8.10.3
L104.2.100.4.1
L104.2.51.4.1.26.1
L104.2.52.52.1
L104.2.65.4.1.13.1
L108.2.1.3.33.6.2.18.1
L108.2.1.3.35.6.3.9.1
L108.2.10.3.31.6.1.18.1
L108.2.10.3.33.6.2.9.1
L108.2.10.3.40.6.1.9.1
L108.2.107
L108.2.12.3.29.6.3
L108.2.13.3.30.6.1.18.1
L108.2.13.6.3
L108.2.15.6.1.18.1
L108.2.17.3.29.6.2
L108.2.18.3.31.18.1
L108.2.18.3.33.6.1.9.1
L108.2.2.3.35.6.1.18.1
L108.2.2.3.37.6.2.9.1
L108.2.2.3.42.18.1
L108.2.2.54.1
L108.2.20.3.34.9.1
L108.2.21.3.1.6.2
L108.2.22.27.1
L108.2.27.3.33.9.1
L108.2.3.3.16.6.8
L108.2.3.3.32.6.2.18.1
L108.2.3.3.34.6.3.9.1
L108.2.3.3.39.18.1
L108.2.3.3.41.6.1.9.1
L108.2.34.3.29.6.1
L108.2.4.3.31.6.2.18.1
L108.2.4.3.33.6.3.9.1
L108.2.40.6.1
L108.2.8.3.30.6.2.18.1
L108.2.9.3.34.6.1.18.1
L108.2.9.3.36.6.2.9.1
L108.3.36.36.1
L108.3.37.6.2.18.1
L108.3.39.6.3.9.1
L108.3.4.6.11
L108.3.44.9.1.12.1
L112.2.104.8.1
L112.2.56.56.1
L112.2.75.4.3.28.1
L112.2.79.8.1.14.1
L112.2.89.7.1.8.1
L112.4.12.28.1
L116.2.115
L116.2.2.58.1
L116.2.23.29.1
L117.3.13.39.1
L120.2.116.4.1
L120.2.28.10.1.12.1
L120.2.30.6.1.20.1
L120.2.59.4.1.30.1
L120.2.60.60.1
L120.2.68.4.1.6.1.10.1
L120.2.70.3.1.4.1.10.1
L120.2.70.4.1.5.1.6.1
L120.2.74.4.1.15.1
L120.2.75.4.1.10.1
L120.2.75.4.1.6.1
L120.2.79.4.1.5.1
L120.2.87.3.1.4.1
L121.11.12
L124.2.123
L124.2.2.62.1
L124.2.22.31.1
L125.5.25.25.1
L126.3.20.6.1.21.1
L126.3.21.42.1
L126.3.23.6.1.7.1
L126.3.24.14.1
L128.2.3.4.11.8.13
L128.2.3.4.18.8.10
L128.2.3.4.25.8.7
L128.2.4.4.15.8.9.16.1
L128.2.4.4.22.8.6.16.1
L128.2.4.4.29.8.3.16.1
L128.2.4.4.36.16.1
L128.2.4.4.8.8.12.16.1
L128.2.5.4.10.8.11.16.1
L128.2.5.4.17.8.8.16.1
L128.2.5.4.24.8.5.16.1
L128.2.5.4.31.8.2.16.1
L128.2.5.4.8.8.14
L128.2.6.4.12.8.10.16.1
L128.2.6.4.19.8.7.16.1
L128.2.6.4.26.8.4.16.1
L128.2.6.4.33.8.1.16.1
L128.2.6.4.5.8.13.16.1
L128.2.15.8.1
L128.2.64.64.1
L128.4.32.32.1
L128.8.16.16.1
L132.2.131
L132.2.15.6.1.22.1
L132.2.18.3.1.22.1
L132.2.18.6.1.11.1
L132.2.2.66.1
L132.2.22.33.1
L132.2.27.11.1
L132.2.42.6.1
L135.3.27.45.1
L135.3.32.9.1.15.1
L136.2.132.4.1
L136.2.67.4.1.34.1
L136.2.68.68.1
L136.2.83.4.1.17.1
L140.2.139
L140.2.17.10.1.14.1
L140.2.2.70.1
L140.2.21.7.1.10.1
L140.2.22.35.1
L140.2.25.5.1.14.1
L140.2.27.5.1.7.1
L140.2.34.14.1
L140.2.36.10.1
L140.2.38.7.1
L144.2.1.3.2.4.2
L144.2.2.3.2.4.2
L144.2.103.8.1.18.1
L144.2.111.6.1.24.1
L144.2.113.3.1.24.1
L144.2.117.8.1.9.1
L144.2.136.8.1
L144.2.16.3.3.6.6.24.1
L144.2.44.3.11.12.2
L144.2.72.72.1
L144.2.74.3.4.6.6.8.1
L144.2.75.3.3.4.1.6.6.12.1
L144.2.76.3.12.6.4.8.1
L144.2.76.3.7.4.1.6.5.12.1
L144.3.48.48.1
L144.4.11.12.2
L144.4.36.36.1
L144.12.7
L216.2.1.3.2.4.1.6.1
L243.3.121
L288.3.2.4.2.6.1
L432.2.1.3.3.4.2

</code></pre>


<h3>Details</h3>

<p>All arrays are guaranteed to have orthogonal main effects. The package holds arrays of resolution III (strength 2), tabulated in the catalogue <code>oacat</code>, and stronger arrays that are tabulated in the catalogue <code>oacat3</code>. Inspection of all arrays is possible via function <code><a href="#topic+show.oas">show.oas</a></code>.
</p>
<p>The array names indicate the number of runs and the numbers of factors:
The first portion of each array name (starting with L) indicates number of runs,
each subsequent pair of numbers indicates a number of levels together with the
frequency with which it occurs.
For example, <code>L18.3.6.6.1</code> is an 18 run design with six factors with
3 levels each and one factor with 6 levels.
</p>
<p>It is possible to obtain an overview about
available arrays for a certain purpose by using function <code><a href="#topic+show.oas">show.oas</a></code>,
based on the data frames <code><a href="#topic+oacat">oacat</a></code> or <code><a href="#topic+oacat3">oacat3</a></code>, which hold
entries for most arrays and their numbers of factors (exceptions:
<code>L18</code>, <code>L36</code> and <code>L54</code> are Taguchi arrays explicitly given,
which are listed in <code><a href="#topic+oacat">oacat</a></code> in an isomorphic but not identical
form ). Data frame <code>oacat</code> additionally holds entries
for further arrays that can be constructed from the above-listed
explicitly available arrays
as &ldquo;child arrays&rdquo;, following so-called &ldquo;lineage&rdquo; recipes.
</p>
<p>The source for most parent arrays as listed in <code><a href="#topic+oacat">oacat</a></code>
as well as for the lineages for the child arrays is Warren Kuhfelds (2009)
collection; the Taguchi arrays <code>L18</code>, <code>L36</code> and <code>L54</code>
are available in addition (not listed in <code>oacat</code>),
and the Mee 2009 resolution V arrays mentioned above are for historical
reasons still listed in <code>oacat</code>.
All stronger parent arrays (strength &gt; 2, resolution &gt; III) are listed in
<code>oacat3</code>. The arrays from <code><a href="#topic+oacat3">oacat3</a></code> have been pulled
together from several sources,
as documented in the <code>origin</code> attribute of the respective array;
all the sources are listed in the references below.
</p>
<p>When being fully populated
with experimental factors, many of the strength 2 = resolution III arrays are guaranteed to work well only
under the ASSUMPTION that there are NO INTERACTIONS. Exceptions are, for example, arrays
<code>L128.2.15.8.1</code> (the 2-level factors have resolution V / strength 4, as noted in the array's comment attribute) or <code>L144.2.1.3.2.4.2</code> (the strength is almost 3, as can be seen from its GR value). 
</p>
<p>Populating a main effects array with fewer than the maximum number of factors can
result in a reasonable design even in the presence of interactions. The degree
of confounding can be checked using various functions based on <code><a href="#topic+generalized.word.length">generalized.word.length</a></code>,
and some optimization of column allocation is possible
with the <code>column</code> argument of function <code><a href="#topic+oa.design">oa.design</a></code>.
Such investigations of a designs properties
work well for smaller designs but may be resource-wise prohibitive for larger
designs / numbers of factors.
</p>
<p><code>oacat3</code> was added with version 0.28 of the package, and version 1.2 substantially extended that collection. Contrary to the resolution III arrays, there are no automatically created children for the stronger arrays. 
It is also possible to combine arrays with each other by so-called
expansive replacement (<code><a href="#topic+expansive.replace">expansive.replace</a></code>), using the
nesting process described by
Warren Kuhfeld. The &ldquo;Examples&rdquo; section shows how users can create custom expansions.
</p>


<h3>Value</h3>

<p>All arrays are matrices of class <code><a href="#topic+oa">oa</a></code>, with all colums coded as
integers from 1 to the number of levels.
Attributes <code>origin</code> and <code>comment</code> are sometimes available.
</p>


<h3>Warning</h3>

<p>For designs with only 2-level factors, it is usually more wise to
use package <span class="pkg"><a href="FrF2.html#topic+FrF2-package">FrF2</a></span>. Exceptions: Three arrays by
Mee (2009), namely <code>L128.2.15.8.1</code>, <code>L256.19</code>, <code>2048.2.63</code>, are very useful for 2-level factors.
</p>
<p>When using a strength 2 array with only few error degrees of freedom (<code>dfe</code> in <code>oacat</code>), make sure you understand the implications of using an orthogonal main effects
array for experimentation. In particular, for some arrays there is a very severe
risk of obtaining biased main effect estimates, if there are some interactions between
experimental factors. The documentations for <code><a href="#topic+generalized.word.length">generalized.word.length</a></code> and
function <code><a href="#topic+oa.design">oa.design</a></code> contain examples that illustrate this remark.
</p>


<h3>Note</h3>

<p> This package is still under development. Bug reports and feature requests are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Agrawal, V. and Dey, A. (1983). Orthogonal resolution IV designs for some asymmetrical factorials.
<em>Technometrics</em> <b>25</b>, 197&ndash;199.
</p>
<p>Brouwer, A. Small mixed fractional factorial designs of strength 3. <a href="https://www.win.tue.nl/~aeb/codes/oa/3oa.html#toc1">https://www.win.tue.nl/~aeb/codes/oa/3oa.html#toc1</a> accessed March 1 2016
</p>
<p>Brouwer, A., Cohen, A.M. and Nguyen, M.V.M. (2006). Orthogonal arrays of strength 3 and small run sizes. <em>Journal of Statistical Planning and Inference</em> <b>136</b>, 3268&ndash;3280.
</p>
<p>Eendebak, P. and Schoen, E. Complete Series of Orthogonal Arrays. <a href="http://www.pietereendebak.nl/oapackage/series.html">http://www.pietereendebak.nl/oapackage/series.html</a> accessed March 1 2016
</p>
<p>Groemping, U. and Fontana, R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics and Data Analysis</em> <b>137</b>, 101&ndash;114.
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York.
</p>
<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute <a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>.
New York: Springer.
</p>
<p>MinT, the online database for optimal parameters of (t,m,s)-nets, (t,s)-sequences, orthogonal arrays, linear codes, and OOAs. Accessed August 2021. http://mint.sbg.ac.at/index.php.
</p>
<p>Nguyen, M.V.M. (2005). <em>Journal of Statistical Planning and Inference</em> <b>138</b>,
220&ndash;233.
</p>
<p>Nguyen, M.V.M. (2008). Some new constructions of strength 3 mixed orthogonal arrays. <em>Journal of Statistical Planning and Inference</em> <b>138</b>,
220&ndash;233.
</p>
<p>Pirsic, I. (2021). Personal communication regarding various specific generators from MinT.
</p>
<p>Schuerer, R. and Schmid, W.Ch. (2010). MinT-Architecture and applications of the (t, m, s)-net and OOA database. <em>Mathematics and Computers in Simulation</em> <b>80</b>(6), 1124-1132. https://doi.org/10.1016/j.matcom.2007.09.010.
</p>
<p>Sloane, N. Orthogonal Arrays. <a href="http://neilsloane.com/oadir/">http://neilsloane.com/oadir/</a> accessed March 1 2016
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+oacat">oacat</a></code>, <code><a href="#topic+show.oas">show.oas</a></code>, <code><a href="#topic+generalized.word.length">generalized.word.length</a></code>,
<code><a href="#topic+oa.design">oa.design</a></code>, <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## we want 729 runs with six 3-level factors and one 9-level factor
    ## with resolution higher than 3
    show.oas(nruns=729, nlevels=c(3,3,3,3,3,3,9), Rgt3=TRUE)
    ## it can also be found if there is an OA with at least four 9-level factors
    show.oas(nruns=729, nlevels=c(9,9,9,9), Rgt3=TRUE)
    ## create full factorial replacement matrix
    threetimesthree &lt;- as.matrix(expand.grid(1:3,1:3))
    dim(threetimesthree)
    ## extract four nine-level columns, 
    ## and expand the first three
    L729.3.6.9.1 &lt;- 
    expansive.replace(
    expansive.replace(
      expansive.replace(L729.9.10[,1:4],
          threetimesthree),
          threetimesthree),
          threetimesthree)
   class(L729.3.6.9.1) &lt;- c("oa", "matrix")
   oa.design(L729.3.6.9.1)
</code></pre>

<hr>
<h2 id='block.catlg3'>
Catalogues for blocking full factorial 2-level and 3-level designs, 
and lists of generating columns for regular 2- and 3-level designs.
</h2><span id='topic+block.catlg'></span><span id='topic+block.catlg3'></span><span id='topic+Yates'></span><span id='topic+Yates3'></span>

<h3>Description</h3>

<p>The block data frames hold Yates matrix column numbers for blocking full factorials 
with 2-level (up to 256 runs) and 3-level factors (up to 243 runs). 
The Yates lists translate these column numbers into effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.catlg
block.catlg3
Yates
Yates3
</code></pre>


<h3>Details</h3>

<p>The constants documented here are used for blocking full factorial designs 
with function <code><a href="#topic+fac.design">fac.design</a></code>; <code>Yates</code> and <code>block.catlg</code> are 
internal here, as they have long been part of package <code><a href="FrF2.html#topic+FrF2-package">FrF2-package</a></code>.
</p>
<p>The block data frames hold Yates matrix column numbers for blocking full factorials 
with 2-level (up to 256 runs) and 3-level factors (up to 243 runs). 
The Yates lists translate these column numbers into effects (see below).
</p>
<p>Data frame <code>block.catlg</code> comes from Sun, Wu and Chen (1997).
Data frame <code>block.catlg3</code> comes from Cheng and Wu (2002, up to 81 runs) 
and has been derived from Hinkelmann and Kempthorne (2005, Table 10.6) 
for 243 runs. The blocking schemes from the papers are optimal; this has 
not been proven for the blocking scheme for 243 runs. 
</p>
<p><code>Yates</code> is a user-visible constant that is useful in design construction: 
</p>
<p><code>Yates</code> is a list of design column generators in Yates order (for 4096 runs), e.g. <code>Yates[1:8]</code> is identical to 
</p>
<p><code>list(1,2,c(1,2),3,c(1,3),c(2,3),c(1,2,3))</code>.
</p>
<p><code>Yates3</code> is a constant for 3-level designs, 
for which there are coefficients rather than generating factor numbers in the list.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

 
<p>Cheng, S.W. and Wu, C.F.J. (2002). Choice of Optimal Blocking Schemes in 
Two-Level and Three-Level Designs. <em>Technometrics</em> <b>44</b>, 269-277.
</p>
<p>Hinkelmann, K. and Kempthorne, O. (2005). <em>Design and analysis of experiments, Vol.2</em>. Wiley, New York.
</p>
<p>Sun, D.X., Wu, C.F.J. and Chen, Y.Y. (1997). 
Optimal blocking schemes for <code class="reqn">2^n</code> and <code class="reqn">2^{n-p}</code> designs. <em>Technometrics</em> <b>39</b>, 
298-307. 
</p>

<hr>
<h2 id='Class+20design+20and+20accessors'> Class design and its accessor functions </h2><span id='topic+design'></span><span id='topic+undesign'></span><span id='topic+redesign'></span><span id='topic+desnum'></span><span id='topic+desnum+3C-'></span><span id='topic+run.order'></span><span id='topic+run.order+3C-'></span><span id='topic+design.info'></span><span id='topic+design.info+3C-'></span><span id='topic+factor.names'></span><span id='topic+factor.names+3C-'></span><span id='topic+response.names'></span><span id='topic+response.names+3C-'></span><span id='topic+col.remove'></span><span id='topic+ord'></span>

<h3>Description</h3>

<p>Convenience functions to quickly access and modify attributes of data frames of the class 
design; methods for the class are described in a separate help topic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undesign(design)
redesign(design, undesigned)
desnum(design)
desnum(design) &lt;- value
run.order(design)
run.order(design) &lt;- value
design.info(design)
design.info(design) &lt;- value
factor.names(design)
factor.names(design, contr.modify = TRUE, levordold = FALSE) &lt;- value
response.names(design)
response.names(design, remove=FALSE) &lt;- value
col.remove(design, colnames)
ord(matrix, decreasing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_design">design</code></td>
<td>
<p> data frame of S3 class <code>design</code>. For the structures of design 
objects, refer to the details section and to the value sections of the 
functions that create them. </p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_undesigned">undesigned</code></td>
<td>
<p>an object that is currently not a design but could be (e.g. obtained by applying function <code>undesign</code></p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_value">value</code></td>
<td>
<p> an appropriate replacement value:<br />
a numeric version of the design matrix for function <code>desnum</code> (usage not encouraged for non-experts!)<br />
a run order data frame for function <code>run.order</code> (usage not encouraged for non-experts!)<br />
a list with appropriate design information for function <code>design.info</code> (usage not encouraged for non-experts!)<br />
for function <code>`factor.names&lt;-`</code> a character vector of new factor names (levels remain unchanged) 
or a named list of level combinations for the factors, 
like <code>factor.names</code> in function <code><a href="#topic+fac.design">fac.design</a></code> <br />
for function <code>`response.names&lt;-`</code> a character vector of response names referring to variables 
which are already available in <code>design</code>
</p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_contr.modify">contr.modify</code></td>
<td>
<p>logical to indicate whether contrasts are to be modified to match the new levels;
relevant for R factors only, not for numeric design variables;<br /> 
if <code>TRUE</code>, factors with 2 levels get -1/+1 contrasts, factors with more than two quantitative levels 
get polynomial contrasts with scores identical to the factor levels, and factors with more than two 
character levels get treatment contrasts; if FALSE, the contrasts remain unchanged from their previous state.<br />
If solely the contrasts are to be changed, function <code><a href="#topic+change.contr">change.contr</a></code> is preferrable.</p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_levordold">levordold</code></td>
<td>
<p>logical to indicate whether the level ordering should follow the old function behavior;<br />
the new behavior (from version 0.27) is more plausible, in that the level ordering in the 
new <code>factor.names</code> corresponds to the <code>factor.names</code> entry of the <code>design.info</code> 
attribute; previously, the automatic level ordering of factor levels deviated from that order 
which even led to a changed level order when reassigning exactly the <code>factor.names</code> element 
of the <code>design.info</code> attribute</p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_remove">remove</code></td>
<td>
<p>logical to indicate whether responses not indicated in <code>value</code> are to be removed from 
the design altogether. <br />
If <code>TRUE</code>, the respective columns are deleted from the design. 
Otherwise, the columns remain in the data frame but loose their status as a response variable. </p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_colnames">colnames</code></td>
<td>
<p>character vector of names of columns to be removed from the design;
design factors or the block factor cannot be removed; with non-numeric variables, 
the <code>desnum</code> attribute of the design may have to be manually modified for 
removing the respective columns in some cases.</p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_matrix">matrix</code></td>
<td>
<p>matrix, data frame or also object of class design that is to be ordered column by column</p>
</td></tr>
<tr><td><code id="Class+2B20design+2B20and+2B20accessors_+3A_decreasing">decreasing</code></td>
<td>
<p>logical, indicates whether decreasing order or not (increasing is default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Items of class <code>design</code> are data frames with attributes. They are generated 
by various functions that create experimental designs (cf. see also section), and 
by various utility functions for designs like 
the above extractor function for class <code>design</code>.
</p>
<p>The data frame itself always contains the design in uncoded form. For many 
design generation functions, these are factors. For designs for quantitative factors 
(bbd, ccd, lhs, 2-level designs with center points), the design variables are numeric. 
This is always indicated by the design.info element quantitative, for which all components 
are <code>TRUE</code> in that case. 
</p>
<p>Generally, its attributes are <code>desnum</code>, 
<code>run.order</code>, and <code>design.info</code>.<br /> 
Attribute <code>desnum</code> contains 
a numeric coded version of the design. For factor design variables, the content of 
<code>desnum</code> depends on the contrast information of the factors (cf. <code><a href="#topic+change.contr">change.contr</a></code> 
for modifying this).<br />  
Attribute <code>run.order</code> is a data frame 
with run order information (standard order, randomized order, order with replication info), <br />
and the details of <code>design.info</code> partly depend on the type of design. 
</p>
<p><code>design.info</code> generally is a list with first element <code>type</code>, 
further info on the design, 
and some options of the design call regarding randomization and replication. 
For almost all design types, elements include 
</p>

<dl>
<dt>nruns</dt><dd><p>number of runs (not adjusted for replications)</p>
</dd>
<dt>nfactors</dt><dd><p>number of factors</p>
</dd>
<dt>factor.names</dt><dd><p>named list, as can be handed to function <code><a href="#topic+oa.design">oa.design</a></code></p>
</dd>
<dt>replications</dt><dd><p>the integer number of replications (1=unreplicated)</p>
</dd> 
<dt>repeat.only</dt><dd><p>logical indicating whether replications are only repeat runs but not 
truly replicated</p>
</dd>
<dt>randomize</dt><dd><p>logical indicating whether the experiment was randomized</p>
</dd> 
<dt>seed</dt><dd><p> integer seed for the random number generator <br />
note that the randomization behavior has changed with R version 3.6.0;<br />
section &quot;Warning&quot; provides information on reproducing randomized designs.</p>
</dd>
<dt>response.names</dt><dd><p>in the presence of response data only; 
the character vector identifying response columns in the data frame</p>
</dd> 
<dt>creator</dt><dd><p>contains the call or 
the list of menu settings within package <span class="pkg">RcmdrPlugin.DoE</span> 
that led to creation of the design.<br />
Note that the randomization behavior has changed with R version 3.6.0;<br />
section &quot;Warning&quot; provides information on reproducing randomized designs.</p>
</dd>
</dl>

<p>For some design types, notably designs of types starting with &ldquo;FrF2&rdquo; and 
designs that have been created by combining other designs, 
there can be substantial additional information available from the <code>design.info</code> 
attribute in specialized situations. Detailed information on the structure of the 
<code>design.info</code> attribute 
can be found in the value sections of the respective functions. A tabular overview 
of the available <code>design.info</code> elements is given on the authors homepage.
</p>
<p>Function <code>undesign</code> removes all design-related attributes from a class design 
object; this may be necessary for making some independent code work on design objects. 
(For example, function <code><a href="stats.html#topic+reshape">reshape</a></code> from package <span class="pkg">stats</span> does not 
work on a class design object, presumably because of the specific extractor method for class <code>design</code>.) 
Occasionally, one may also want 
to reconnect a processed undesigned object to its design properties. This is the purpose of 
function <code>redesign</code>.
</p>
<p>The functions <code>desnum</code>, <code>run.order</code>, and <code>design.info</code> extract 
the respective attribute, i.e. e.g. function <code>design.info</code> 
extracts the design information for the design. The corresponding assignment 
functions should only be used by very experienced users, as they may 
mess up things badly if they are used naively .
</p>
<p>The functions <code>factor.names</code> and <code>response.names</code> extract the 
respective elements of the <code>design.info</code> attribute. The corresponding assignment 
functions allow to change factor names and/or factor codes and to exclude or include 
a numeric variable from the list of responses that are recognized as such by analysis 
procedures. Note that the <code>response.names</code> function can (on request, not by default) 
remove response variables from the data frame <code>design</code>. However, it is not directly able to 
add new responses from outside the data frame <code>design</code>. This is what the 
function <code><a href="#topic+add.response">add.response</a></code> is for.
</p>
<p>Function <code>col.remove</code> removes columns from the design and returns the 
design without these columns and an intact class <code>design</code> structure. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>desnum</code></td>
<td>
<p>returns a numeric matrix, 
the corresponding replacement function modifies a class design object </p>
</td></tr>
<tr><td><code>run.order</code></td>
<td>
<p>returns a 3-column data frame with standard and actual run order 
as well as a run order with replication identifiers attached; 
the corresponding replacement function modifies a class design object </p>
</td></tr>
<tr><td><code>design.info</code></td>
<td>
<p>returns the <code>design.info</code> attribute of the design; 
the corresponding replacement function modifies a class design object </p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>returns a named list the names of which are the names of the 
treatment factors of the design while the list elements are the vectors of levels 
for each factor</p>
</td></tr>
<tr><td><code>`factor.names&lt;-`</code></td>
<td>
<p>returns a class <code>design</code> object with modified 
factor names information (renamed factors and/or changed factor levels);
</p>
</td></tr>
<tr><td><code>response.names</code></td>
<td>
<p>returns a character vector of response names that 
(names of numeric variables within the data frame <code>design</code> 
that are to be treated as response variables ) ; 
the corresponding replacement function modifies the design </p>
</td></tr>
<tr><td><code>`response.names&lt;-`</code></td>
<td>
<p>returns a class <code>design</code> object with modified 
response names information (add or remove numeric columns of the design 
to or from set of response variables), and potentially response columns 
removed from the design.
</p>
</td></tr>
<tr><td><code>col.remove</code></td>
<td>
<p>returns a class <code>design</code> object with some columns 
removed from both the design itself and the <code>desnum</code> attribute.
Response columns may be removed, but factor or block columns may not.
</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>returns an index vector that orders the matrix or data frame; 
for example, <code>design[ord(design),]</code> orders the design in increasing order with respect to the first,
then the second etc. factor.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Function <code><a href="base.html#topic+sample">sample</a></code> is used for the randomization 
functionality of this package. With R version 3.6.0, the behavior of this 
function has changed. Since the R version is not stored with a class <code>design</code> 
object, please check carefully if a design you want to reproduce based on a given 
<code>creator</code> or <code>seed</code> element of the <code>design.info</code> attribute 
has the expected randomization order. 
</p>
<p>The randomization order of a design that was created with the default settings 
under R version 3.6.0 or newer can only be reproduced with such a new R version. <br />
If an R version 3.6.0 or newer is used for reproducing the randomization order 
of a randomized design that was created with an R version before 3.6.0, 
the <code>RNGkind</code> setting has to be modified: <br />
<code>RNGkind(sample.kind="Rounding")</code><br />
activates the old behavior,<br />
<code>RNGkind(sample.kind="default")</code><br />
switches back to the recommended new behavior.<br />
For an example, see the documentation of the example data set <code><a href="#topic+VSGFS">VSGFS</a></code>.
</p>


<h3>Note</h3>

<p>Note that R contains a few functions that generate or work with an S class <code>design</code>, 
which is cursorily documented in Appendix B of the white book (Chambers and Hastie 1993) 
to consist of a data frame of R factors which will later be extended by numeric response columns. 
Most class design objects as defined in packages <span class="pkg">DoE.base</span> and <span class="pkg">FrF2</span> are also 
compatible with this older class <code>design</code>; they are not, however, as soon as quantitative 
factors are involved, like for designs with center points in package <code>FrF2</code> or for most designs in 
package <span class="pkg">DoE.wrapper</span> (not yet on CRAN). If feasible with reasonable effort 
and useful, functions for the class <code>design</code> documented here incorporate the functions 
for the S class design (notably function <code><a href="#topic+plot.design">plot.design</a></code>). 
</p>
<p>This package is still under development; suggestions and bug reports are welcome.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Chambers, J.M. and Hastie, T.J. (1993). <em>Statistical Models in S</em>, 
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p> See also the following functions known to produce objects of class 
<code>design</code>: <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code>, 
<code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code>, 
<code><a href="DoE.wrapper.html#topic+bbd.design">bbd.design</a></code>, <code><a href="DoE.wrapper.html#topic+ccd.design">ccd.design</a></code>, 
<code><a href="DoE.wrapper.html#topic+ccd.augment">ccd.augment</a></code>, <code><a href="DoE.wrapper.html#topic+lhs.design">lhs.design</a></code>, 
as well as <code><a href="#topic+cross.design">cross.design</a></code>, <code><a href="#topic+param.design">param.design</a></code>, and 
utility functions in this package for reshaping designs.<br /> 
There are also special methods for class <code>design</code> (<code><a href="#topic++5B.design">[.design</a></code>, 
<code><a href="#topic+print.design">print.design</a></code>, <code><a href="#topic+summary.design">summary.design</a></code>, <code><a href="#topic+plot.design">plot.design</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oa12 &lt;- oa.design(nlevels=c(2,2,6))


#### Examples for factor.names and response.names
  factor.names(oa12)
  ## rename factors
  factor.names(oa12) &lt;- c("First.Factor", "Second.Factor", "Third.Factor")
  ## rename factors and relabel levels of first two factors
  namen &lt;- c(rep(list(c("current","new")),2),list(""))
  names(namen) &lt;- c("First.Factor", "Second.Factor", "Third.Factor")
  factor.names(oa12) &lt;- namen
  oa12

  ## add a few variables to oa12
  responses &lt;- cbind(temp=sample(23:34),y1=rexp(12),y2=runif(12))
  oa12 &lt;- add.response(oa12, responses)
  response.names(oa12)
  ## temp (for temperature) is not meant to be a response 
  ## --&gt; drop it from responselist but not from data
  response.names(oa12) &lt;- c("y1","y2")

## looking at attributes of the design
  desnum(oa12)
  run.order(oa12)
  design.info(oa12)

## undesign and redesign
  u.oa12 &lt;- undesign(oa12)
  str(u.oa12)  
  u.oa12$new &lt;- rnorm(12)
  r.oa12 &lt;- redesign(oa12, u.oa12)
## make known that new is also a response
  response.names(r.oa12) &lt;- c(response.names(r.oa12), "new") 
## look at design-specific summary
  summary(r.oa12)
## look at data frame style summary instead
  summary.data.frame(r.oa12)

</code></pre>

<hr>
<h2 id='contr.FrF2'> Contrasts for orthogonal Fractional Factorial 2-level designs </h2><span id='topic+contr.FrF2'></span>

<h3>Description</h3>

<p>Contrasts for orthogonal Fractional Factorial 2-level designs 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   contr.FrF2(n, contrasts=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.FrF2_+3A_n">n</code></td>
<td>
<p> power of 2; number of levels of the factor for which contrasts are 
to be generated</p>
</td></tr>
<tr><td><code id="contr.FrF2_+3A_contrasts">contrasts</code></td>
<td>
<p>must always be <code>TRUE</code>; option needed for 
function <code>model.matrix</code> to work properly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly supports <code>-1/+1</code> contrasts for 2-level factors.
It does also work if the number of levels is a power of 2. 
For more than four levels, the levels of the factor must be in an appropriate order 
in order to guarantee that the columns of the model matrix for an FrF2-derived structure 
are orthogonal.
</p>


<h3>Value</h3>

<p>The function returns orthogonal contrasts for factors with number of levels a power of 2. 
All contrast columns consist of <code>-1</code> and <code>+1</code> entries (half of each). 
If factors in orthogonal arrays 
with 2-level factors are assigned these contrasts, the columns of the model matrix 
for the main effects model are orthogonal to each other and to the column for the intercept.
</p>


<h3>Note</h3>

<p> This package is currently under intensive development. Substantial changes are to be expected in the near future.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See Also <code><a href="stats.html#topic+contrasts">contrasts</a></code>, <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, 
<code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## assign contr.FrF2 contrasts to a factor
status &lt;- as.factor(rep(c("current","new"),4))
contrasts(status) &lt;- contr.FrF2(2)
contrasts(status)
</code></pre>

<hr>
<h2 id='corrPlot'>
Function to Visualize Correlations Between Model Matrix Columns for an Experimental Design
</h2><span id='topic+corrPlot'></span>

<h3>Description</h3>

<p>Function corrplot plots absolute or squared values of correlations between model matrix 
columns of main effects up to three-factor interactions for factorial designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrPlot(design, scale = "corr", recode = TRUE, cor.out = TRUE, mm.out=FALSE,  
    main.only = TRUE, three = FALSE, run.order=FALSE,
    frml=as.formula(ifelse(three, ifelse(run.order, "~ run.no + .^3", "~ .^3"), 
                                   ifelse(run.order, "~ run.no + .^2", "~ .^2"))),
    pal = NULL, col.grid = "black", col.small = "grey", lwd.grid = 1.5, lwd.small = 0.5, 
    lty.grid = 1, lty.small = 3, cex.y = 1, cex.x = 0.7, x.grid = NULL,
    main = ifelse(scale == "corr", "Plot of absolute correlations", ifelse(scale == "R2",
         "Plot of squared correlations", 
         "Plot of absolute correlations of coefficient estimates")), 
    split = 0, ask = (split &gt; 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrPlot_+3A_design">design</code></td>
<td>

<p>a class <code><a href="#topic+design">design</a></code> object, or an object that can be made into 
that class by function <code><a href="#topic+data2design">data2design</a></code>
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_scale">scale</code></td>
<td>

<p><code>"corr"</code> for absolute correlation of model matrix columns (default), <br />
<code>"R2"</code> for squared correlation of model matrix columns, <br />
<code>"corr.est"</code> for absolute correlation of coefficient estimates; <br />
<code>"corr.est"</code> works for model matrices with full column rank only
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_recode">recode</code></td>
<td>

<p>logical indicating whether or not to recode each column into normalized orthogonal 
coding with function <code><a href="#topic+contr.XuWu">contr.XuWu</a></code>
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_cor.out">cor.out</code></td>
<td>

<p>logical; if TRUE (default), the correlation matrix is invisibly returned 
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_mm.out">mm.out</code></td>
<td>

<p>logical; if TRUE (default: FALSE), the correlation matrix is invisibly returned, 
with the model matrix attached to it as an attribute
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_main.only">main.only</code></td>
<td>

<p>logical; if TRUE (default), only correlations with main effects columns 
are visualized, otherwise also those with two-factor interactions
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_three">three</code></td>
<td>

<p>logical; if FALSE (default), only two-factor interactions are included, 
otherwise also three-factor interactions
</p>
</td></tr>  
<tr><td><code id="corrPlot_+3A_run.order">run.order</code></td>
<td>

<p>logical; if TRUE, the linear run order effect is included into the plot, 
and main effects are shown on the horizontal axis; <br />
used in conjunction with function <code><a href="#topic+rerandomize.design">rerandomize.design</a></code>, 
this option can help to find a suitable random order with reasonably low 
correlation to the effects of interest.
</p>
</td></tr>  
<tr><td><code id="corrPlot_+3A_frml">frml</code></td>
<td>

<p>the model formula; useful, if absolute correlation for the 
coefficient estimates are desired in a situation 
where a full model has a rank deficiency; for requirements on the formula, 
see the Details section.
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_pal">pal</code></td>
<td>

<p><code>NULL</code> (default), or a color palette. If <code>NULL</code>, the color palette 
depends on whether or not package <span class="pkg">RColorBrewer</span> is available: 
if so, the Blues palette with nine shades is used; otherwise, 
a 10 level palette of heat colors augmented with white is used.
The number of colors in <code>pal</code> determines the number of bins for plotting.
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_col.grid">col.grid</code></td>
<td>

<p>color of the main grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_col.small">col.small</code></td>
<td>

<p>color of the small grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_lwd.grid">lwd.grid</code></td>
<td>

<p>width of the main grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_lwd.small">lwd.small</code></td>
<td>

<p>with of the small grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_lty.grid">lty.grid</code></td>
<td>

<p>line type of the main grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_lty.small">lty.small</code></td>
<td>

<p>line type of the small grid lines
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_cex.y">cex.y</code></td>
<td>

<p>size of tick mark labels on vertical axis
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_cex.x">cex.x</code></td>
<td>

<p>size of tick mark labels on horizontal axis
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_x.grid">x.grid</code></td>
<td>

<p>vector of numerical positions for thicker vertical grid lines (default: <code>NULL</code> for none)
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_main">main</code></td>
<td>

<p>title
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_split">split</code></td>
<td>

<p>an integer number (default: 0, no split) of columns after which to split the horizontal axis; 
if this number is nonzero and smaller than the number of columns to display, 
several plots are created; note: the color legend needs attention, since it may differ between the 
different plots, depending on the plot's range of values
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_ask">ask</code></td>
<td>

<p>logical; if yes (default in case of splitting, otherwise not), the user is asked 
to confirm creation of each new plot
</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_...">...</code></td>
<td>

<p>additional arguments to function <code><a href="lattice.html#topic+levelplot">levelplot</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used for visualizing confounding within an experimental design. 
It is strongly recommended to apply it to designs with columns coded in normalized 
orthogonal coding (<code>contr.XuWu</code>, <code>contr.XuWuPoly</code>, if applicable also <code>contr.FrF2</code>). 
Nevertheless, for factors with more than two levels, the picture shown depends on the 
choice of normalized orthogonal coding (see examples). Option <code>recode=FALSE</code> is there to allow 
to keep a suitably-chosen normalized orthogonal coding for each factor.
</p>
<p>The function shows the absolute correlation or squared correlation between model matrix columns, 
or, on request and if possible, the absolute correlation between estimated coefficients (other than the intercept). 
In case the latter cannot be obtained for the full model, a model formula can be specified 
with option <code>frml</code>. Note that it is implicitly assumed that all main effects are included in the 
model formula, and for <code>main.only=FALSE</code> also all two-factor interactions.
</p>
<p>For resolution III and higher designs, the vertical axis shows the main effects 
(and, if <code>main.only=FALSE</code>, also the two-factor interactions), the horizontal axis 
shows the two-factor interactions (and, if <code>three=TRUE</code>, also the three-factor 
interactions). For resolution II designs, the horizontal axis additionally shows 
the main effect columns (since they are correlated with other main effect columns).
For resolution VI and higher designs, the function stops with an error. 
For resolution V designs, the function shows correlations between two-factor interactions 
on the vertical axis and three-factor interactions on the horizontal axis, if both 
are activated.
The most interesting cases are designs of resolution up to IV. 
</p>
<p>The diagonal of the correlation matrix is set to NA before plotting, in order to be able 
to better see differences in case there are only relatively low correlations.
</p>
<p>With <code>scale="R2"</code>, and using normalized orthogonal coding, some sums of matrix entries 
coincide with contributions to generalized word counts (resolution II: main effects with main effects; 
resolution III: main effects with two-factor interactions; 
resolution IV: main effects with three-factor interactions; see Groemping and Xu (2014) for the background of this result 
and Groemping (2017).
</p>


<h3>Value</h3>

<p>The entire matrix of absolute correlations is output invisibly.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping, Berliner Hochschule fuer Technik
</p>


<h3>References</h3>

<p>Groemping, U. (2017). Frequency Tables for the coding invariant quality assessment of factorial
designs. <em>IISE Transactions</em> <b>49</b>(5), 505&ndash;517.
</p>
<p>Groemping, U. and Xu, H. (2014). Generalized resolution for orthogonal arrays. <em>The Annals of Statistics</em> <b>42</b>, 918&ndash;939.
</p>
<p>The function works similarly  to <code>colormap</code> in package <span class="pkg">daewr</span> (but offers significantly more choices). That package accompanies the following book: 
</p>
<p>Lawson, J. (2013). Design and Analysis of Experiments with R. CRC, Boca Raton.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this is with the default contr.XuWu recoding
mat &lt;- corrPlot(VSGFS)
round(mat, 2)

## NOT RECOMMENDED: force-keep non-normalized coding
corrPlot(VSGFS, recode=FALSE)  # not useful!

## custom normalized orthogonal coding
## that has correlations more concentrated on fewer columns
plan &lt;- change.contr(VSGFS, "contr.XuWuPoly")
contrasts(plan$CDs) &lt;- contr.FrF2(4)
corrPlot(plan, recode=FALSE)  # that is the purpose of recode=FALSE

corrPlot(VSGFS, main.only=FALSE, three=TRUE, cex.x=0.5, cex.y=0.5, split=100)
</code></pre>

<hr>
<h2 id='cross.design'>Function to cross several designs</h2><span id='topic+cross.design'></span>

<h3>Description</h3>

<p>This function generates cartesian products of two or more experimental designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross.design(design1, design2, ..., randomize = TRUE, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross.design_+3A_design1">design1</code></td>
<td>
<p> a data frame of class <code>design</code> that restricted by certain 
criteria (cf. details)
</p>
<p>if <code>design1</code> is not of class <code>design</code>, crossing will nevertheless work, 
but the output object will be a data frame only without any design information; 
there is no guaranteed support for this usage</p>
</td></tr>
<tr><td><code id="cross.design_+3A_design2">design2</code></td>
<td>
<p> a data frame of class <code>design</code> with the same restrictions 
for design type as for <code>design1</code>; <br />
can also be a vector if <code>...</code> is not used; <br /> 
cf. details for what is allowed regarding replications </p>
</td></tr>
<tr><td><code id="cross.design_+3A_...">...</code></td>
<td>
<p> optional further data frames that are to be crossed; 
they must be of class <code>design</code> with the 
above-mentioned restrictions for design types; 
the last element can also be a vector</p>
</td></tr>
<tr><td><code id="cross.design_+3A_randomize">randomize</code></td>
<td>
<p> logical indicating whether randomization should take place 
after crossing the designs </p>
</td></tr>
<tr><td><code id="cross.design_+3A_seed">seed</code></td>
<td>
<p> integer seed for the random number generator <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>cross.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crossing is carried out recursively, following the <code>direct.sum</code> approach 
from package <span class="pkg">conf.design</span>. All but the last designs must fulfill various 
criteria (cf. below). The last design to be crossed can also be a vector. 
</p>
<p>Designs to be crossed must not be a blocked, nor splitplot, nor crossed, folded 
or Taguchi parameter design, nor designs in wide format. Furthermore, designs must 
not contain responses (checked via the response.names element of <code>design.info</code>).
</p>
<p>If replications are desired, it is recommended to accomodate them in the last 
design. Only the last design may have <code>repeat.only</code> replications. If the 
last design has <code>repeat.only</code> replications and there are also proper replications 
in earlier designs, a warning is thrown, but the <code>repeat.only</code> replications are 
nevertheless accomodated; this is experimental and may not yield the expected 
results under all circumstances.
</p>


<h3>Value</h3>

<p>Function <code>cross.design</code> returns a simple data frame without design 
information, if <code>design1</code> is not of class <code>design</code>.
</p>
<p>Otherwise, the value is a data frame of class <code><a href="#topic+design">design</a></code> 
with type &ldquo;crossed&rdquo; and the following extraordinary elements: 
</p>
<table>
<tr><td><code>cross.nruns</code></td>
<td>
<p>vector of run numbers of individual designs</p>
</td></tr>
<tr><td><code>cross.nfactors</code></td>
<td>
<p>vector of numbers of factors of individual designs</p>
</td></tr>
<tr><td><code>cross.types</code></td>
<td>
<p>vector of types of individual designs</p>
</td></tr>
<tr><td><code>cross.randomize</code></td>
<td>
<p>vector of logicals (randomized or not) of individual desigs</p>
</td></tr>
<tr><td><code>cross.seed</code></td>
<td>
<p>vector of seeds of individual designs</p>
</td></tr>
<tr><td><code>cross.replications</code></td>
<td>
<p>vector of numbers of replications of individual designs</p>
</td></tr>
<tr><td><code>cross.repeat.only</code></td>
<td>
<p>vector of logicals (repeat.only or not) of individual designs</p>
</td></tr>
<tr><td><code>cross.map</code></td>
<td>
<p>list with the map vectors for component designs of type <code>FrF2.estimable</code> </p>
</td></tr>
<tr><td><code>cross.selected.columns</code></td>
<td>
<p><code>NULL</code> (if no <code>oa</code> type design) or list of column vectors for each design</p>
</td></tr>
<tr><td><code>cross.nlevels</code></td>
<td>
<p>list with the <code>nlevels</code> vectors for those component designs that have them</p>
</td></tr>
</table>
<p>The standard elements are as usual, with <code>randomize</code> and <code>seed</code> referring to 
the randomization within function <code>cross.design</code> itself (previous randomizations are shown 
under <code>cross.randomize</code> and <code>cross.seed</code>). 
</p>
<p>The <code>nlevels</code> element of <code>design.info</code> is available only if it is 
available for all designs that have been crossed (otherwise refer to the element <code>cross.nlevels</code>.
</p>
<p>The <code>creator</code> element of the <code>design.info</code> attribute consists is a 2-element list 
containing<br />
the list <code>original</code> of all the original creators and <br />
the element <code>modify</code> that contains the call to <code>cross.design</code>. 
</p>
<p>If present, the <code>clear</code>, <code>ncube</code>, <code>ncenter</code>, <code>residual.df</code>, 
<code>origin</code>, <code>comment</code>, <code>generating.oa</code> elements of <code>design.info</code> are vector-valued. 
</p>
<p>If present, the <code>generators</code> element of <code>design.info</code> is a list of character vectors. 
</p>
<p>If present, the <code>aliased</code> and <code>catlg.entry</code> elements of <code>design.info</code> are lists of lists. 
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This function is still experimental.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+param.design">param.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## creating a Taguchi-style inner-outer array design
   ## with proper randomization
   ##   function param.design would generate such a design with all outer array runs 
   ##     for each inner array run conducted in sequence
   ##   alternatively, a split-plot approach can also handle control and noise factor 
   ##     designs without necessarily crossing two separate designs
   des.control &lt;- oa.design(ID=L18)
   des.noise &lt;- oa.design(ID=L4.2.3,nlevels=2,factor.names=c("N1","N2","N3"))
   crossed &lt;- cross.design(des.control, des.noise)
   crossed
   summary(crossed)
</code></pre>

<hr>
<h2 id='DoE.base-package'>
Full factorials, orthogonal arrays and base utilities for DoE packages
</h2><span id='topic+DoE.base-package'></span><span id='topic+DoE.base'></span>

<h3>Description</h3>

<p>This package creates full factorial designs and designs from orthogonal arrays. 
In addition, it provides some basic utilities like an exporting function for the DoE packages FrF2, 
DoE.wrapper and RcmdrPlugin.DoE, and some diagnostics for general orthogonal arrays 
(generalized word length calculations). 
</p>


<h3>Details</h3>

<p>The package is still in under development phase. 
Details about combining designs are particularly likely to be changed in the future 
(<code>param.design</code>, <code>cross.design</code>). Please contact me, if you have suggestions.
</p>
<p>This package designs full factorial experiments (function <code>fac.design</code>) 
and experiments based on orthogonal arrays (<code>oa.design</code>). 
Some aspects of functions <code>fac.design</code> and <code>oa.design</code> have been 
modeled after the functions of the same name given in Chambers and Hastie (1993) 
(e.g. for the option <code>factor.names</code> or for outputting a data frame 
with attributes). However, S compatibility has not been considered in 
devising this package.
</p>
<p>The orthogonal arrays underlying function <code><a href="#topic+oa.design">oa.design</a></code> are mainly taken from 
Kuhfeld (2009). While the 
arrays generally guarantee estimability of main effects in case there are no 
(or negligible) active interactions, some of them can also be used for 
designs for which some interactions are to be estimated, if only few of the design 
columns are used for experimentation. Optimization for such purposes 
and check of fitness for such purposes is supported, 
cf. <code><a href="#topic+generalized.word.length">generalized.word.length</a></code>.
</p>
<p>The package provides class <code><a href="#topic+design">design</a></code> for use also by packages 
<span class="pkg">FrF2</span>, <span class="pkg">DoE.wrapper</span> and <span class="pkg">RcmdrPlugin.DoE</span>. Furthermore, it provides 
utilities for printing, plotting, summarizing, exporting and combining 
experimental designs. 
Package <span class="pkg">FrF2</span> relies on function <code><a href="#topic+fac.design">fac.design</a></code> 
for full factorials in 2-level factors. 
</p>


<h3>Acknowledgments</h3>

<p>Thanks are due to Peter Theodor Wilrich for 
various useful suggestions in the early phase of this project!
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>
<p>Maintainer: Ulrike Groemping &lt;groemping@bht-berlin.de&gt;
</p>


<h3>References</h3>

<p>Chambers, J.M. and Hastie, T.J. (1993). <em>Statistical Models in S</em>, 
Chapman and Hall, London.
</p>
<p>Groemping, U. (2018).  R Package DoE.base for Factorial Designs. 
<em>Journal of Statistical Software</em> <b>85</b>(5), 1&ndash;41.
<a href="https://www.jstatsoft.org/issue/view/v085">https://www.jstatsoft.org/issue/view/v085</a>.
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) 
<em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>
<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute 
<a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>


<h3>See Also</h3>

<p>Functions <code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code> for generating designs, 
and various functions (<code><a href="#topic+generalized.word.length">generalized.word.length</a></code>) for optimizing and checking 
a designs properties,<br />
class <code><a href="#topic+design">design</a></code> which is utilized also by packages 
<span class="pkg"><a href="FrF2.html#topic+FrF2-package">FrF2</a></span> and <span class="pkg"><a href="DoE.wrapper.html#topic+DoE.wrapper-package">DoE.wrapper</a></span>.<br /> 
Furthermore, there are various utility functions like <code><a href="#topic+export.design">export.design</a></code> or 
<code><a href="#topic+add.response">add.response</a></code> and functions <code><a href="#topic+cross.design">cross.design</a></code> or <code><a href="#topic+param.design">param.design</a></code> 
for combining designs.<br />
Finally, several <code><a href="#topic+class-design-methods">methods for class design objects</a></code> 
are provided, 
especially also functions <code><a href="#topic+formula.design">formula.design</a></code> and <code><a href="#topic+lm.design">lm.design</a></code> 
for automatic generation of linear models (but beware: these are convenience functions 
that provide a quick first look but NOT necessarily the best statistical approach to analysis!).
</p>

<hr>
<h2 id='expansive.replace'> Expansive replacement for two orthogonal arrays </h2><span id='topic+expansive.replace'></span>

<h3>Description</h3>

<p>Expansive replacement for two orthogonal arrays 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   expansive.replace(array1, array2, fac1 = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expansive.replace_+3A_array1">array1</code></td>
<td>
<p> an orthogonal array, must be a matrix; <br />
the levels of column <code>fac1</code> of this array are replaced by the 
corresponding runs of <code>array2</code>; 
they must be numbered with integers starting with 1</p>
</td></tr>
<tr><td><code id="expansive.replace_+3A_array2">array2</code></td>
<td>
<p> an orthogonal array, must be a matrix <br />
this array is replaced for a column in <code>array1</code>  </p>
</td></tr>
<tr><td><code id="expansive.replace_+3A_fac1">fac1</code></td>
<td>
<p>if <code>NULL</code>, the first suitable column of <code>array1</code> 
is replaced with <code>array2</code>;<br />
alternatively, a suitable column number for <code>array1</code> can be specified</p>
</td></tr>
<tr><td><code id="expansive.replace_+3A_all">all</code></td>
<td>
<p>logical; <code>TRUE</code> is permitted, if <code>array2</code> is a full factorial in two factors; 
if <code>TRUE</code>, a list of permutations of the replacement array 
<code>array2</code> is used for creating all potentially combinatorially 
different outcomes, instead of a single expansive replacement based on the 
order of <code>array2</code> as stated (see Details section)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly is meant for combining two orthogonal arrays
via what Kuhfeld (2009) calls expansive replacement. 
</p>
<p>If <code>array2</code> is a full factorial in two factors, argument <code>all = TRUE</code> 
creates a list of expanded arrays obtained by permuting the second array in all ways 
that may lead to combinatorially different end results. With <code class="reqn">s_1</code> and <code class="reqn">s_2</code> the numbers 
of levels of the factors in <code>array2</code>, this is the number of partitions of the 
runs of <code>array2</code> into <code class="reqn">s_1</code> equally-sized groups, multiplied with <code class="reqn">s_2!^{s_1-1}</code> for 
the possibilities of permuting the levels of the second factor within all but the first 
level of the first factor. This functionality is primarily meant for the creation of 
strength 3 arrays in combination with arrays listed in the catalogue <code><a href="#topic+oacat3">oacat3</a></code> 
(see an example on expanding the 6-level factor in <code>L96.2.5.4.2.6.1</code>).
</p>


<h3>Value</h3>

<p>The function returns an object of classes <code>oa</code> and <code>matrix</code>, 
which can be used in function <code><a href="#topic+oa.design">oa.design</a></code>, or a list of such arrays, 
in case <code>all = TRUE</code>. 
</p>
<p>Whether or not the object is an orthogonal array depends on the choice of suitable input 
arrays by the user. The properties of the resulting array(s) can e.g. be inspected with functions 
<code><a href="#topic+GWLP">GWLP</a></code> or <code><a href="#topic+GRind">GRind</a></code>.
</p>


<h3>Note</h3>

<p> This package is still under development. Bug reports and feature requests are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute 
<a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+oacat">oacat</a></code>, <code><a href="#topic+oacat3">oacat3</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>myL24.2.14.6.1 &lt;- expansive.replace(L24.2.12.12.1, L12.2.2.6.1)

L96.2.6.3.1.4.2_list &lt;- expansive.replace(L96.2.5.4.2.6.1, 
      cbind(U=rep(c(1,2),each=3), V=rep(1:3,2)), all=TRUE)
## the list of 60 resolution IV arrays can be used for design creation, 
## e.g. as follows:
## Not run: 
     ## resolution IV designs obtained from the 60 different arrays
     deslist &lt;- lapply(L96.2.6.3.1.4.2_list, 
         function(aa) oa.design(aa, nlevels=c(2,2,2,2,3,4,4), columns="min34"))
     table(A4s &lt;- sapply(deslist, length4))  ## a single best design exists
     best &lt;- deslist[[which(A4s &lt; 2)]]
     GWLP(best)

## End(Not run)
</code></pre>

<hr>
<h2 id='export.design'> Function for exporting a design object </h2><span id='topic+export.design'></span><span id='topic+html'></span><span id='topic+html.data.frame'></span>

<h3>Description</h3>

<p>Function for exporting a design object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.design(design, response.names = NULL, 
       path = ".", filename = NULL, legend = NULL, type = "html", 
       OutDec = options("OutDec")$OutDec, replace = FALSE, version = 2, ...)
html(object, ...)
## S3 method for class 'data.frame'
html(object, file = paste(first.word(deparse(substitute(object))),
    "html", sep = "."), append = FALSE, link = NULL, linkCol = 1, bgs.col = NULL,
          OutDec=options("OutDec")$OutDec, linkType = c("href", "name"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.design_+3A_design">design</code></td>
<td>
<p> A data frame of class design; 
it must be stored in the global environment and referred to by its name, i.e. 
it cannot be created &ldquo;on the fly&rdquo;.  </p>
</td></tr>
<tr><td><code id="export.design_+3A_response.names">response.names</code></td>
<td>
<p> if not NULL (default), 
this must be a character vector of response names; 
the exported file contains a column for each entry;
it is NOT necessary to include responses that are already present in 
the design object!</p>
</td></tr>
<tr><td><code id="export.design_+3A_path">path</code></td>
<td>
<p> the path to the directory where the export files are to be stored;
the default corresponds to the R working directory that can (on some systems) 
be looked at using <code>getwd()</code></p>
</td></tr>
<tr><td><code id="export.design_+3A_filename">filename</code></td>
<td>
<p> character string that gives the file name (without extension) 
for the files to be exported; if NULL, it is the name of the design object </p>
</td></tr>
<tr><td><code id="export.design_+3A_legend">legend</code></td>
<td>
<p> data frame containing legend information; if NULL, 
the legend is automatically generated from the 
<code>factor.names</code> element of <code>design.info(design)</code></p>
</td></tr>
<tr><td><code id="export.design_+3A_type">type</code></td>
<td>
<p> one of <code>"rda"</code>, <code>"html"</code>, <code>"csv"</code>, or <code>"all"</code>. 
An R workspace with just the design object is always stored as an <code>"rda"</code> object. 
If one of the other types is specified, the design is additionally exported to <code>"html"</code> 
or <code>"csv"</code> or both. The <code>"csv"</code> file contains the design itself only, 
with formatting depending on the <code>OutDec</code> option. The <code>"html"</code> file contains 
some additional legend information and row color formatting.</p>
</td></tr>
<tr><td><code id="export.design_+3A_outdec">OutDec</code></td>
<td>
<p> decimal separator for the output file; one of <code>"."</code> or <code>","</code>; 
the default is the option setting in the R options; this option also directs  
whether <code><a href="utils.html#topic+write.table">write.csv</a></code> or 
<code><a href="utils.html#topic+write.table">write.csv2</a></code> is used and is very important for 
usability of the exported files e.g. with Excel</p>
</td></tr>
<tr><td><code id="export.design_+3A_replace">replace</code></td>
<td>
<p> logical indicating whether an existing file should be replaced; 
if FALSE (default), the routine aborts without any action if one of the 
files to be created exists; checking is not case-sensitive in order to protect 
users on case-insensitive platforms from inadvertent replacing of files (i.e. 
you cannot have TEST.html and test.html, even if it were allowed on your platform) </p>
</td></tr>
<tr><td><code id="export.design_+3A_version">version</code></td>
<td>
<p>the save version for the <code>rda</code> file; starting with R 3.6.0,
the default save version is 3; that version cannot be read by R versions 
before 3.5.0. Therefore, the default of this package is still 2, but can 
be overwritten by users who are certain to use the file only on new R versions.</p>
</td></tr> 
<tr><td><code id="export.design_+3A_object">object</code></td>
<td>
<p> object to be exported to html </p>
</td></tr>
<tr><td><code id="export.design_+3A_file">file</code></td>
<td>
<p> file to export the object to </p>
</td></tr>
<tr><td><code id="export.design_+3A_append">append</code></td>
<td>
<p> append data frame to existing file ? </p>
</td></tr>
<tr><td><code id="export.design_+3A_link">link</code></td>
<td>
<p> not used, unchanged from package <span class="pkg">Hmisc</span> </p>
</td></tr>
<tr><td><code id="export.design_+3A_linkcol">linkCol</code></td>
<td>
<p> not used, unchanged from package <span class="pkg">Hmisc</span> </p>
</td></tr>
<tr><td><code id="export.design_+3A_bgs.col">bgs.col</code></td>
<td>
<p> background colors for data frame rows, default white and grey </p>
</td></tr>
<tr><td><code id="export.design_+3A_linktype">linkType</code></td>
<td>
<p> not used, unchanged from package <span class="pkg">Hmisc</span> </p>
</td></tr>
<tr><td><code id="export.design_+3A_...">...</code></td>
<td>
<p> further arguments to function <code>html</code>, 
usable e.g. for modifying row coloring </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>export.design</code> always stores an R workspace that contains just 
the design (with attached attributes, cf. class <code><a href="#topic+design">design</a></code>). This file is stored 
with ending <code>rda</code>.<br /> 
If requested by options <code>type="csv"</code>, <code>type="html"</code>, or <code>type="all"</code>, 
<code>export.design</code> additionally creates an exported version of 
the design that is usable outside of R. This is achieved via functions 
<code>write.csv</code>, <code>write.csv2</code> or <code>html</code>. 
The csv-file contains the data frame itself only, the html file contains the data frame 
followed by the legend to the right of the data frame. The html file uses row coloring in 
order to prevent mistakes in recording of experimental results by mix-ups of rows. 
If the OutDec option is correct for the current computer, the csv and html files can 
be opened in Excel, and decimal numbers are correctly interpreted. 
</p>
<p>Generation of the html-file is particularly important for Taguchi inner/outer array designs 
in wide format, because it provides the legend to the suffix numbers of response columns in terms of 
outer array experimental setups!
</p>
<p>The function <code>html</code> and its data frame method are internal.
</p>


<h3>Value</h3>

<p>The functions are used for their side effects and do not generate a result.
</p>


<h3>Note</h3>

<p> This package is currently under intensive development. Substantial changes are to be expected in the near future.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping; the html functions have been adapted from package Hmisc </p>


<h3>References</h3>

 
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>


<h3>See Also</h3>

<p> See also <code><a href="FrF2.html#topic+FrF2-package">FrF2-package</a></code>, <code><a href="DoE.wrapper.html#topic+DoE.wrapper-package">DoE.wrapper-package</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## six 2-level factors
  test &lt;- oa.design(nlevels=c(2,3,3,3))
  ## export an html file with legend and two responses
  ## files test.rda and test.html will be written to the current working directory, 
  ##     if they do not exist yet
  ## Not run: 
  export.design(test, response.names=c("pressure", "temperature"))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='fac.design'> Function for full factorial designs </h2><span id='topic+fac.design'></span>

<h3>Description</h3>

<p>Function for creating full factorial designs with arbitrary numbers of levels, 
and potentially with blocking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.design(nlevels=NULL, nfactors=NULL, factor.names = NULL, 
        replications=1, repeat.only = FALSE, randomize=TRUE, seed=NULL, 
        blocks=1, block.gen=NULL, block.name="Blocks", bbreps=replications, 
        wbreps=1, block.old.behavior=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.design_+3A_nlevels">nlevels</code></td>
<td>
<p> number(s) of levels, vector with <code>nfactors</code> entries or single number; 
can be omitted, if obvious from <code>factor.names</code> </p>
</td></tr>
<tr><td><code id="fac.design_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors, can be omitted if obvious from entries <code>nlevels</code> or <code>factor.names</code> </p>
</td></tr>
<tr><td><code id="fac.design_+3A_factor.names">factor.names</code></td>
<td>
<p> if <code>nlevels</code> is given, <code>factor.names</code> can be a character vector of factor names. 
In this case, default factor levels are the numbers from 1 to the number of levels for each factor.<br />
Otherwise it must be a list of vectors with factor levels. 
If the list is named, list names represent factor names, otherwise default factor names are used.
Default factor names are the first elements of the character vector <code><a href="#topic+Letters">Letters</a></code>, 
or the factors position numbers preceded by capital F in case of more than 50 factors.
If both <code>nlevels</code> and factor.names are 
given, they must be compatible.</p>
</td></tr>
<tr><td><code id="fac.design_+3A_replications">replications</code></td>
<td>
<p> positive integer number. Default 1 (i.e. each row just once). 
If larger, each design run is executed replication times. 
If <code>repeat.only</code>, repeated measurements 
are carried out directly in sequence, i.e. no true replication takes place, 
and all the repeat runs are conducted together. It is likely that the error 
variation generated by such a procedure will be too small, so that average values 
should be analyzed for an unreplicated design. 
</p>
<p>Otherwise (default), the full experiment is first carried out once, then 
for the second replication and so forth. In case of randomization, 
each such blocks is randomized separately. In this case, replication variance is 
more likely suitable for usage as error variance 
(unless e.g. the same parts are used for replication runs although build 
variation is important).</p>
</td></tr>
<tr><td><code id="fac.design_+3A_repeat.only">repeat.only</code></td>
<td>
<p> logical, relevant only if replications &gt; 1. If <code>TRUE</code>, 
replications of each run are grouped together 
(repeated measurement rather than true replication). The default is 
<code>repeat.only=FALSE</code>, i.e. the complete experiment 
is conducted in <code>replications</code> blocks, and each run occurs in each block.  </p>
</td></tr>
<tr><td><code id="fac.design_+3A_randomize">randomize</code></td>
<td>
<p> logical. If <code>TRUE</code>, the design is randomized. This is the default. 
In case of replications, the nature of randomization depends on the setting of 
option <code>repeat.only</code>.</p>
</td></tr>
<tr><td><code id="fac.design_+3A_seed">seed</code></td>
<td>
<p> integer seed for the random number generator <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>fac.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="fac.design_+3A_blocks">blocks</code></td>
<td>
<p> is the number of blocks into which the experiment is to be subdivided; <br />
it must be a prime or a product of prime numbers which occur as common divisors 
of the numbers of levels of several factors (cf. Details section).<br />
</p>
<p>If the experiment is randomized, randomization happens within blocks. <br />
</p>
</td></tr> 
<tr><td><code id="fac.design_+3A_block.gen">block.gen</code></td>
<td>
<p> provides block generating information.<br />
Only specify <code>block.gen</code>, if <code>blocks</code>&gt;1. <br />
If <code>blocks</code> is a prime or a power of 2 (up to 2^8) or 3 (up to 3^5) 
or a product of powers of 2, 3, and an individual other prime, 
<code>block.gen</code> is not needed (but can be optionally specified).<br />
If given, <code>block.gen</code> can be <br />
a numeric vector of integer numbers that will be treated as a one-row matrix <br />
OR a numeric matrix with integer elements.
</p>
<p>There must be a row for each prime number into which <code>blocks</code> factorizes, 
and a column for each (pseudo)factor into which the experimental 
design factors can be partitioned (cf. Details and Examples sections and 
function <code><a href="conf.design.html#topic+factorize">factorize</a></code>).
</p>
<p>Rows for a p-level contributor to the block factor (p a prime) consist of 
entries 0 to p-1 only.
</p>
</td></tr>
<tr><td><code id="fac.design_+3A_block.name">block.name</code></td>
<td>
<p> name of the block factor, default &ldquo;Blocks&rdquo;</p>
</td></tr>
<tr><td><code id="fac.design_+3A_bbreps">bbreps</code></td>
<td>
<p> between block replications; these are always taken as genuine replications, 
not repeat runs; default: equal to <code>replications</code>;
CAUTION: you should not modify <code>bbreps</code> if you do not work with blocks, 
because the program code uses it instead of <code>replications</code> in some places </p>
</td></tr>
<tr><td><code id="fac.design_+3A_wbreps">wbreps</code></td>
<td>
<p> within block replications; whether or not these are taken as genuine replications 
depends on the setting of <code>repeat.only</code></p>
</td></tr>
<tr><td><code id="fac.design_+3A_block.old.behavior">block.old.behavior</code></td>
<td>
<p>logical that can be used to activate the old (prior 
to version 0.27) behavior of 
blocking full factorial designs; the new behavior is the default, as it 
often creates designs with less severe confounding </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fac.design</code> creates full factorial designs, i.e. the number of runs is the 
product of all numbers of levels.<br /><br />
It is possible to subdivide the design into blocks (one hierarchy level only) 
by specifying an appropriate number of blocks. The method used is a generalization of 
the one implemented in function <code><a href="conf.design.html#topic+conf.design">conf.design</a></code> for 
symmetric factorials (i.e. factorials with all factors at the same prime number 
of levels) and related to the method described in Collings (1984, 1989); 
function <code><a href="conf.design.html#topic+conf.set">conf.set</a></code> from 
package <span class="pkg">conf.design</span> is used for checking the confounding 
consequences of blocking. 
</p>
<p>Note that the number of blocks must 
be compatible with the factor levels; it must factor into primes that occur with 
high enough frequency among the pseudo-factors of the design. 
This statement is now explained by an example: Consider a design with five factors at 
2, 2, 3, 3, 6 levels. The 6-level factor can be thought of as consisting of 
two pseudo-factors, a 2-level and a 3-level pseudo-factor, according to the 
factorization of the number 6 into the two primes 2 and 3. It is possible <br />
to obtain two blocks by confounding the two-factor interaction of the 
two 2-level factors and the 2-level pseudo-factor of the 6-level factor, <br />
or to obtain three blocks by confounding the blocking factor with the 
three-factor interaction of the two three-level factors and the three-level 
pseudo-factor of the 6-level factor, <br />
or to get six blocks, by doing both simultaneously. <br />
It is also possible to obtain 4 or 9 or even 36 blocks, if one is happy to 
confound two-factor interactions with blocks. The 36 blocks are the product 
of the 4 blocks from the 2-level portion with the nine blocks from the 3-level 
portion. For each portion separately, there is a lookup-table for blocking 
possibilities (<code><a href="#topic+block.catlg">block.catlg</a></code>), for up to 128 blocks in 256 runs, 
or up to 81 blocks in 243 runs. 
</p>
<p>5 blocks cannot be done for the above example design. Even if there were one additional 
factor at 5 levels, it would still not be possible to do a number of blocks 
with divisor 5, because this would confound the main effect of a factor with 
blocks and would thus generate an error. 
</p>
<p>For any primes apart from 2 or 3, only one at a time can be handled automatically. 
For example, if a design has three 5-level factors, it can be automatically subdivided 
into 5 blocks by the option <code>blocks=5</code>. 
It is also possible to run the design in 25 blocks; however, as 25=5*5, this cannot be done 
automatically but has to be requested by specifying the <code>block.gen</code> option
in addition to the <code>blocks</code> option 
(in this case, <code>block.gen=rbind(c(1,0,1),c(1,1,0))</code> would do the job).
</p>


<h3>Value</h3>

<p><code>fac.design</code> returns a data frame of S3 class <code><a href="#topic+design">design</a></code> 
with attributes attached. 
</p>
<p>The experimental factors are all stored as R factors. <br />
For factors with 2 levels, <code><a href="#topic+contr.FrF2">contr.FrF2</a></code> contrasts (-1 / +1) are used. <br />
For factors with more than 2 numerical levels, polynomial contrasts are used 
(i.e. analyses will per default use orthogonal polynomials). <br />
For factors with more than 2 categorical levels, the default contrasts are used.
</p>
<p>For changing the contrasts, use function <code><a href="#topic+change.contr">change.contr</a></code>.
</p>
<p>The <code>design.info</code> attribute of the data frame has the following elements:
</p>

<dl>
<dt>type</dt><dd><p> character string &ldquo;full factorial&rdquo; or 
&ldquo;full factorial.blocked&rdquo;</p>
</dd>
<dt>nruns</dt><dd><p> number of runs (replications are not counted) </p>
</dd>
<dt>nfactors</dt><dd><p> number of factors</p>
</dd>
<dt>nlevels</dt><dd><p> vector with number of levels for each factor </p>
</dd>
<dt>factor.names </dt><dd><p> list named with (treatment) factor names and containing as 
entries vectors with coded factor levels </p>
</dd>
<dt>nblocks</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
number of blocks</p>
</dd>
<dt>block.gen</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
matrix the rows of which are the coefficients of the linear combinations 
that create block columns from of pseudo factors</p>
</dd>
<dt>blocksize</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
size of each block (without consideration of <code>wbreps</code>)</p>
</dd>
<dt>replication </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>repeat.only </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>bbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of between block replications</p>
</dd>
<dt>wbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of within block replications;<br />
<code>repeat.only</code> indicates whether these are replications or repetitions only</p>
</dd>
<dt>randomize </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>seed </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>creator </dt><dd><p> call to function FrF2 
(or stored menu settings, if the function has been called via the R commander plugin 
<span class="pkg">RcmdrPlugin.DoE</span>) </p>
</dd>
</dl>



<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under development. Suggestions and bug reports are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Collings, B.J. (1984). Generating the intrablock and interblock subgroups for 
confounding in general factorial experiments. <em>Annals of Statistics</em> <b>12</b>, 
1500&ndash;1509.
</p>
<p>Collings, B.J. (1989). Quick confounding. <em>Technometrics</em> <b>31</b>, 
107&ndash;110.
</p>


<h3>See Also</h3>

<p> See also <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="#topic+oa.design">oa.design</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code>, <code><a href="conf.design.html#topic+conf.set">conf.set</a></code>, 
<code><a href="#topic+block.catlg">block.catlg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## only specify level combination 
  fac.design(nlevels=c(4,3,3,2))
  ## design requested via factor.names
  fac.design(factor.names=list(one=c("a","b","c"), two=c(125,275), 
     three=c("old","new"), four=c(-1,1), five=c("min","medium","max")))
  ## design requested via character factor.names and nlevels 
  ##    (with a little German lesson for one two three)
  fac.design(factor.names=c("eins","zwei","drei"),nlevels=c(2,3,2))
  
  ### blocking designs
  fac.design(nlevels=c(2,2,3,3,6), blocks=6, seed=12345)
  ## the same design, now unnecessarily constructed via option block.gen
  ## preparation: look at the numbers of levels of pseudo factors
  ## (in this order)
  unlist(factorize(c(2,2,3,3,6)))
  ## or, for more annotation, factorize the unblocked design
  factorize(fac.design(nlevels=c(2,2,3,3,6)))
  ## positions 1 2 5 are 2-level pseudo factors
  ## positions 3 4 6 are 4-level pseudo factors
  ## blocking with highest possible interactions
  G &lt;- rbind(two=c(1,1,0,0,1,0),three=c(0,0,1,1,0,1))
  plan.6blocks &lt;- fac.design(nlevels=c(2,2,3,3,6), blocks=6, block.gen=G, seed=12345)
  plan.6blocks
  
  ## two blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=2, block.gen=c(1,1,0,0,1,0), seed=12345)
  
  ## three blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=3, block.gen=c(0,0,1,1,0,1), seed=12345)
  
  ## nine blocks
  ## confounding two-factor interactions cannot be avoided
  ## there are warnings to that effect
  G &lt;- rbind(CD=c(0,0,1,1,0,0),CE2=c(0,0,1,0,0,1))
  plan.9blocks &lt;- fac.design(nlevels=c(2,2,3,3,6), blocks=9, block.gen=G, seed=12345)

  ## further automatic designs, not run for shortening run time 
  ## Not run: 
  fac.design(nlevels=c(2,2,3,3,6), blocks=4, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=9, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=36, seed=12345)
  fac.design(nlevels=c(3,5,6,10), blocks=15, seed=12345)
  
## End(Not run)
   
  ## independently check aliasing
  ## model with block main effects and all two-factor interactions
  ## 6 factors: not aliased
  summary(plan.6blocks)
  alias(lm(1:nrow(plan.6blocks)~Blocks+(A+B+C+D+E)^2,plan.6blocks))
  ## 9 factors: aliased
  summary(plan.9blocks)
  alias(lm(1:nrow(plan.9blocks)~Blocks+(A+B+C+D+E)^2,plan.9blocks))
</code></pre>

<hr>
<h2 id='factorize'>
Factorize integer numbers and factors
</h2><span id='topic+factorize.factor'></span><span id='topic+factorize.design'></span><span id='topic+factorize.data.frame'></span>

<h3>Description</h3>

<p>Methods to factorize integer numbers into primes or factors 
into pseudo factors with integer numbers of levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'factor'
factorize(x, name = deparse(substitute(x)), extension = letters,
    drop = FALSE, sep = "", ...)
## S3 method for class 'design'
factorize(x, extension = letters, sep = ".", long=FALSE, ...)
## S3 method for class 'data.frame'
factorize(x, extension = letters, sep = ".", long=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorize_+3A_x">x</code></td>
<td>
<p>factor<br />
OR data frame of class <code>design</code>
OR data frame </p>
</td></tr>
<tr><td><code id="factorize_+3A_name">name</code></td>
<td>
<p>name to use for prefixing the pseudo factors</p>
</td></tr>
<tr><td><code id="factorize_+3A_extension">extension</code></td>
<td>
<p>extensions to use for postfixing the pseudo factors</p>
</td></tr>
<tr><td><code id="factorize_+3A_drop">drop</code></td>
<td>
<p>TRUE: have a vector only in case of just one pseudo factor </p>
</td></tr>
<tr><td><code id="factorize_+3A_sep">sep</code></td>
<td>
<p>separation between name and postfix for pseudo factors</p>
</td></tr>
<tr><td><code id="factorize_+3A_long">long</code></td>
<td>
<p>TRUE: create a complete matrix of pseudofactors; 
FALSE: only create the named numbers of levels </p>
</td></tr>
<tr><td><code id="factorize_+3A_...">...</code></td>
<td>
<p> currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used for blocking full factorials. 
The method for class <code>factors</code> is a modification of the analogous method 
from package <span class="pkg">conf.design</span>, the other two are convenience versions for designs 
and data frames.
</p>


<h3>Value</h3>

<p>All three methods return a matrix of pseudo factors (in case <code>long=TRUE</code>) 
or a named numeric vector of numbers of levels of the pseudo factors 
(for the default <code>long=FALSE</code>). 
</p>


<h3>Note</h3>

<p>There may be conflicts with functions from packages <span class="pkg">conf.design</span> or <span class="pkg">sfsmisc</span>.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping; Bill Venables authored the original of factorize.factor.
</p>


<h3>See Also</h3>

<p>The function <code><a href="conf.design.html#topic+factorize">factorize</a></code> from package <span class="pkg">conf.design</span>, <br />
the function <code>factorize</code> from package <span class="pkg">sfsmisc</span> (no link provided, 
in order to avoid having to include <span class="pkg">sfsmisc</span> in Suggests).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factorize(12)
factorize(c(2,2,3,3,6))
factorize(fac.design(nlevels=c(2,2,3,3,6)))
unlist(factorize(c(2,2,3,3,6)))
factorize(undesign(fac.design(nlevels=c(2,2,3,3,6))))
</code></pre>

<hr>
<h2 id='formula.design'> Function to change the default formula for a data frame of 
class design to involve the correct factors with the desired effects 
and responses </h2><span id='topic+formula.design'></span>

<h3>Description</h3>

<p>This function provides a reasonable default formula for linear model analyses 
of class design objects with response(s). Per default, the resulting formula 
refers to the first response in the design and is of design-type specific 
nature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'design'
formula(x, ..., response=NULL, degree=NULL, FUN=NULL, 
      use.center=NULL, use.star=NULL, use.dummies=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.design_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+design">design</a></code></p>
</td></tr>
<tr><td><code id="formula.design_+3A_...">...</code></td>
<td>
<p> further arguments to function <code><a href="stats.html#topic+formula">formula</a></code></p>
</td></tr>
<tr><td><code id="formula.design_+3A_response">response</code></td>
<td>
<p> character string giving the name of the response variable 
(must be among the numeric columns from <code>x</code>) <br />
OR<br />
integer number giving the position of the response in element 
<code>response.names</code> of attribute <code>design.info</code>
</p>
</td></tr>
<tr><td><code id="formula.design_+3A_degree">degree</code></td>
<td>
<p> degree of the model (1=main effects only, 2=with 2-factor 
interactions and quadratic effects, 3=with 3-factor interactions and 
up to cubic effects, ... </p>
</td></tr>
<tr><td><code id="formula.design_+3A_fun">FUN</code></td>
<td>
<p> function for the <code><a href="#topic+aggregate.design">aggregate.design</a></code> method; 
this must be an unquoted function name or <code>NULL</code>;<br />
This option is relevant for repeated measurement designs 
and parameter designs in long format only</p>
</td></tr>
<tr><td><code id="formula.design_+3A_use.center">use.center</code></td>
<td>
 <p><code>NULL</code> or logical indicating whether center points are to be used +
in the analysis; <br />
if <code>NULL</code>, the default is FALSE for <code>pb</code> and <code>FrF2</code> designs with 
center points and TRUE for <code>ccd</code> designs; the option is irrelevant 
for all other design types.
</p>
</td></tr>
<tr><td><code id="formula.design_+3A_use.star">use.star</code></td>
<td>
 <p><code>NULL</code> or logical indicating whether the star portion of a CCD design 
is to be used in the analysis (ignored for all other types of designs). 
</p>
</td></tr>
<tr><td><code id="formula.design_+3A_use.dummies">use.dummies</code></td>
<td>
<p> logical indicating whether the error dummies of a Plackett Burman design 
are to be used in the formula (ignored for all other types of designs). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="stats.html#topic+formula">formula</a></code> creates an appropriate formula for many kinds of 
objects, e.g. for data frames (try e.g. <code>formula(swiss)</code>). Function 
<code><a href="stats.html#topic+as.formula">as.formula</a></code> uses function formula, but cannot take any additional 
arguments. 
</p>
<p>The method for class <code>design</code> objects modifies the way a data frame 
would normally be treated by the <code>formula</code> function. This also carries through 
to default linear models.
</p>
<p>Without the additional arguments, the function creates the formula with the first 
response from the <code>response.names</code> element of the <code>design.info</code> attribute. 
The default degree depends on the type of design: it is 
</p>

<ul>
<li><p>1 for <code>oa</code> and <code>pb</code>
</p>
</li>
<li><p>2 for all other design types
</p>
</li></ul>

<p><code>degree</code> does not have an effect for response surface designs 
(types <code>bbd</code>, <code>bbd.blocked</code> and <code>ccd</code>) and latin hypercube designs (type <code>lhs</code>), 
where the function always creates the formula for a full second order model including quadratic 
effects.
</p>
<p>Where <code>degree</code> does have an effect, it is the exponent of the sum of all experimental factors, 
i.e. it refers to the degree of interactions, not to powers of the variables themselves 
(e.g. <code>(A+B+C)^2</code> for degree 2).
</p>
<p>For designs with a block variable (types <code>FrF2.blocked</code>, <code>bbd.blocked</code> and <code>ccd</code>) 
the block variable enters the formula as a main effect factor without any interactions. 
</p>
<p>For 2-level designs with center points (types <code>FrF2.center</code> or <code>pb.center</code>), 
the formula contains an indicator variable <code>center</code> for the center points 
that can is used for checking whether quadratic effects are needed.
</p>
<p>For designs with repeated measurements (<code>repeat.only</code> and parameter designs, 
the default is to analyse aggregated responses. For more detail, 
see the documentation of <code><a href="#topic+lm.design">lm.design</a></code>. 
</p>
<p>For optimal designs, the formula is the model formula 
used in optimizing the design.
</p>


<h3>Value</h3>

<p>a formula
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also <code><a href="stats.html#topic+formula">formula</a></code> and <code><a href="#topic+lm.design">lm.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## indirect usage via function lm.design is much more interesting
  ## cf help for lm design!

   my.L18 &lt;- oa.design(ID=L18, 
       factor.names = c("one","two","three","four","five","six","seven"), 
       nlevels=c(3,3,3,2,3,3,3))
   y &lt;- rnorm(18)
   my.L18 &lt;- add.response(my.L18, y)
   formula(my.L18)
   lm(my.L18)
</code></pre>

<hr>
<h2 id='genChild'>
Internal utility functions to support automatic creation of child arrays
from entries of the data frame oacat
</h2><span id='topic+parseArrayLine'></span><span id='topic+genChild'></span><span id='topic+getArray'></span><span id='topic+symb2oa'></span><span id='topic+oa2symb'></span>

<h3>Description</h3>

<p>The functions are used internally for creating the child arrays listed in
data frame <code>oacat</code> from the parent arrays that come with <span class="pkg">DoE.base</span>
(or using full factorials).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseArrayLine(array.line)
genChild(array.list)
getArray(nbRuns, descr)
symb2oa(nbRuns, descr)
oa2symb(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genChild_+3A_array.line">array.line</code></td>
<td>
<p> a row from data frame <code><a href="#topic+oacat">oacat</a></code></p>
</td></tr>
<tr><td><code id="genChild_+3A_array.list">array.list</code></td>
<td>
<p> the output from function <code>parseArrayLine</code></p>
</td></tr>
<tr><td><code id="genChild_+3A_nbruns">nbRuns</code></td>
<td>
<p> the number of runs of the array to be received</p>
</td></tr>
<tr><td><code id="genChild_+3A_descr">descr</code></td>
<td>
<p> a character string containing the description of the array
to be retrieved, of the form <br />
<code>nl1~fl1;nl2~fl2; ...</code>, where <code>nl</code> stands for the number of levels
and <code>fl</code> for their respective frequency; the string may (but need not)
contain a trailing semicolon</p>
</td></tr>
<tr><td><code id="genChild_+3A_name">name</code></td>
<td>
<p> name of an array according to the naming conventions in
<code><a href="#topic+oacat">oacat</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>parseArrayLine</code> transforms information from a row of <code>oacat</code>
into a list format digestible by function <code>genChild</code>.
</p>
<p>Function <code>genChild</code> creates a child array from the appropriate information
provided by function <code>parseArrayLine</code>.
</p>
<p>Function <code>getArray</code> retrieves a stored orthogonal array based on the list
information it receives.
</p>
<p>Functions <code>symb2oa</code> and <code>oa2symb</code> can be used for
switching between design names from data frame <code><a href="#topic+oacat">oacat</a></code>
and list type information used by functions internally. Note that the result
from <code>oa2symb</code> is not sufficient to get back to the <code>oa</code> representation,
but needs the number of runs in addition.
</p>


<h3>Value</h3>

<p><code>parseArrayLine</code> returns a list with design and lineage description in symbolic form.
</p>
<p><code>genChild</code> and <code>getArray</code> return an array matrix of class <code><a href="#topic+oa">oa</a></code>.
</p>
<p><code>symb2oa</code> and <code>oa2symb</code> return a character string.
</p>


<h3>Author(s)</h3>

<p> Boyko Amarov and Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+oacat">oacat</a></code>, <code><a href="#topic+oa">oa</a></code>
</p>

<hr>
<h2 id='generalized.word.length'>
Functions for calculating the generalized word length pattern,
projection frequency tables or optimizing column selection within an array
</h2><span id='topic+generalized.word.length'></span><span id='topic+length2'></span><span id='topic+length3'></span><span id='topic+length4'></span><span id='topic+length5'></span><span id='topic+lengths'></span><span id='topic+lengths.default'></span><span id='topic+lengths.design'></span><span id='topic+lengths.matrix'></span><span id='topic+contr.XuWu'></span><span id='topic+contr.XuWuPoly'></span><span id='topic+P2.2'></span><span id='topic+P3.3'></span><span id='topic+P4.4'></span><span id='topic+oa.min3'></span><span id='topic+oa.min4'></span><span id='topic+oa.min34'></span><span id='topic+oa.max3'></span><span id='topic+oa.max4'></span><span id='topic+oa.maxGR'></span><span id='topic+oa.minRelProjAberr'></span><span id='topic+nchoosek'></span><span id='topic+tupleSel'></span><span id='topic+tupleSel.design'></span><span id='topic+tupleSel.default'></span>

<h3>Description</h3>

<p>Functions length2, length3, length4 and length5 calculate the numbers of generalized words
of lengths 2, 3, 4, and 5 respectively, lengths calculates them all. Functions P3.3 and P4.4
calculate projection frequency tables, functions oa.min3, oa.min4, oa.min34, 
oa.maxGR (deprecated), oa.minRelProjAberr,
oa.max3 and oa.max4 determine column allocations with minimum or maximum aliasing.
Function nchoosek is an auxiliary function
for calculating all subsets without replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length2(design, with.blocks = FALSE, J = FALSE)
length3(design, with.blocks = FALSE, J = FALSE, rela = FALSE)
length4(design, with.blocks = FALSE, separate = FALSE, J = FALSE, rela = FALSE)
length5(design, with.blocks = FALSE, J = FALSE, rela = FALSE)
lengths(design, ...)
## Default S3 method:
lengths(design, ...)
## S3 method for class 'design'
lengths(design, ...)
## S3 method for class 'matrix'
lengths(design, ...)
contr.XuWu(n, contrasts=TRUE)
contr.XuWuPoly(n, contrasts=TRUE)
oa.min3(ID, nlevels, all, rela = FALSE, variants = NULL, crit = "total")
oa.min4(ID, nlevels, all, rela = FALSE, variants = NULL, crit = "total")
oa.min34(ID, nlevels, variants = NULL, min3=NULL, all = FALSE, rela = FALSE)
oa.max3(ID, nlevels, rela = FALSE)
oa.max4(ID, nlevels, rela = FALSE)
oa.maxGR(ID, nlevels, variants = NULL)
oa.minRelProjAberr(ID, nlevels, maxGR = NULL)
P2.2(ID, digits = 4, rela=FALSE, parft=FALSE, parftdf=FALSE, detailed=FALSE)
P3.3(ID, digits = 4, rela=FALSE, parft=FALSE, parftdf=FALSE, detailed=FALSE)
P4.4(ID, digits = 4, rela=FALSE, parft=FALSE, parftdf=FALSE, detailed=FALSE)
nchoosek(n, k)
tupleSel(design, type="complete", selprop=0.25, ...)
## S3 method for class 'design'
tupleSel(design, type="complete", selprop=0.25, ...)
## Default S3 method:
tupleSel(design, type="complete", selprop=0.25, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalized.word.length_+3A_design">design</code></td>
<td>
<p>an experimental design. This can either be a matrix or a data frame
in which all columns are experimental factors, or a special data frame
of class <code><a href="#topic+class-design">design</a></code>, which may also include response data.<br />
In any case, the design should be a factorial design;
the functions are not useful for quantitative designs (like e.g. latin hypercube samples).
</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_with.blocks">with.blocks</code></td>
<td>
<p>a logical, indicating whether or not an existing block factor
is to be included into word counting. This option is ignored if <code>design</code>
is not of class <code>design</code>.<br />
Per default, an existing block factor is ignored.<br />
For designs without a block factor, the option does not have an effect.<br />
If the design is blocked, and <code>with.blocks</code>
is <code>TRUE</code>, the block factor is treated like any other factor in terms of word counting.</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_j">J</code></td>
<td>
<p>a logical, indicating whether or not a vector of contributions from
individual degrees of freedom is produced. If <code>TRUE</code>, the entries of the vector
are absolute normalized J-characteristics from all 3- or 4-factor products respectively,
based on normalized Helmert contrasts (cf. Ai and Zhang 2004). <br />
This is not expected to be useful for practical purposes.<br />
<code>J</code> cannot be <code>TRUE</code> simultaneously with <code>separate</code> or <code>rela</code>.</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_rela">rela</code></td>
<td>
<p>logical indicating whether the word lengths are to be calculated in
absolute terms (as usual) or relative to the maximum possible word length in case of
complete aliasing; if <code>TRUE</code>, each word length is divided by the worst
case word length (that corresponds to a completely aliased set of factors)
derived in Groemping (2011).<br />
<code>rela=TRUE</code> is only permitted for the shortest possible word length,
i.e. <code>length3</code> or <code>P3.3</code> for resolution III designs,
<code>length4</code> or <code>P4.4</code> for resolution IV designs, or <code>length5</code>
for resolution V designs.<br />
<code>rela</code> cannot be <code>TRUE</code> simultaneously with <code>parft</code>, <code>parftdf</code>,
<code>J</code> or <code>separate</code>.
</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_separate">separate</code></td>
<td>
<p>a logical, indicating whether or not separate (and overlapping)
sums are requested for each two-factor interaction;
the idea is to be able to identify clear two-factor interactions;
this may be useful for a design for which <code>length3</code> returns zero,
in analogy to clear 2fis for regular fractional factorials,
implemented in function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>; this
is currently experimental and may be removed again if it does not prove useful.<br />
<code>separate</code> cannot be <code>TRUE</code> simultaneously with <code>J</code>.</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_n">n</code></td>
<td>
<p>integer; <br />
for functions <code>contr.XuWu</code> and <code>contr.XuWuPoly</code>:
number of levels of the factor for which to determine contrasts<br />
for function <code>nchoosek</code>: number of elements to choose from</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_contrasts">contrasts</code></td>
<td>
<p>must always be <code>TRUE</code>; option needed for
function <code>model.matrix</code> to work properly</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_id">ID</code></td>
<td>
<p>an orthogonal array, either a matrix or a data frame; need not be of class <code>oa</code>;
can also be a character string containing the name of an array listed in data frame <code><a href="#topic+oacat">oacat</a></code></p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_nlevels">nlevels</code></td>
<td>
<p>a vector of requested level informations (vector with an entry for each factor)</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_all">all</code></td>
<td>
<p>logical; if <code>FALSE</code>, the search stops whenever a design with 0 generalized words
of highest requested length is found; otherwise, the function always determines all best designs</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_variants">variants</code></td>
<td>
<p>matrix of integer column number entries; each row gives the column numbers
for one variant to be compared; the matrix columns must correspond to the entries of the <code>nlevels</code>
option</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_crit">crit</code></td>
<td>
<p>character string that requests <code>"total"</code> or <code>"worst"</code> triple optimization;
<code>"total"</code> corresponds to the previous version that optimizes the overall number of length 3 words;
<code>"worst"</code> minimizes the aliasing of the worst triple.</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_min3">min3</code></td>
<td>
<p>the outcome of a call to <code>oa.min3</code> with <code>crit="total"</code>,
which is to be used for a call to <code>oa.min34</code></p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_maxgr">maxGR</code></td>
<td>
<p>the outcome of a call to <code>oa.min3</code> with <code>crit="worst"</code> and <code>rela=TRUE</code>
(or the outcome of a call to <code>oa.maxGR</code>), which is to be used for a call to <code>oa.minRelProjAberr</code></p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_digits">digits</code></td>
<td>
<p>number of decimal points to which to round the result</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_parft">parft</code></td>
<td>
<p>logical indicating whether to tabulate projection averaged <code class="reqn">R^2</code>
values (see Groemping 2013) instead of word lengths;
if <code>TRUE</code>, the table shows projection averaged <code class="reqn">R^2</code> values as
detailed in Groemping (2013, 2017).<br />
<code>parft=TRUE</code> is only permitted for the shortest possible word length,
i.e. <code>length3</code> or <code>P3.3</code> for resolution III designs,
<code>length4</code> or <code>P4.4</code> for resolution IV designs.<br />
<code>parft</code> cannot be <code>TRUE</code> simultaneously with <code>rela</code> or <code>parftdf</code>.
</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_parftdf">parftdf</code></td>
<td>
<p>logical indicating whether to tabulate averaged <code class="reqn">R^2</code>
values, where averaging is over individual degrees of freedom; this variant
is not explicitly described in Groemping (2013, 2017) and usually yields very similar
results as <code>parft</code>, except for some situations where there are factors
with very unequal numbers of levels (e.g. 2-level and 8-level factors).<br />
<code>parftdf=TRUE</code> is only permitted for the shortest possible word length,
i.e. <code>length3</code> or <code>P3.3</code> for resolution III designs,
<code>length4</code> or <code>P4.4</code> for resolution IV designs.<br />
<code>parftdf</code> cannot be <code>TRUE</code> simultaneously with <code>rela</code> or <code>parft</code>.
</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_detailed">detailed</code></td>
<td>
<p>logical indicating whether the vector of all (relative) tuple word lengths
is to become an attribute of the output object (attribute <code>detail</code>); <br />
intended for supporting other functions (can be a very long vector!)
</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_k">k</code></td>
<td>
<p>number of elements to be chosen, integer from 0 to n</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_type">type</code></td>
<td>
<p>character string with type of worst case to consider;<br />
<code>"complete"</code>, <code>"worst"</code> and <code>"worst.rel"</code> are available.<br />
For a resolution R design, tuples of R factors are considered (works for R=3 and R=4 only).
<code>"complete"</code> selects all tuples with complete aliasing of at least one factor,
<code>"worst"</code> selects all tuples whose number of words is larger than the <code>1-selprop</code>
quantile of the word length distribution of R-tuples, <code>"worst.rel"</code> does the same
with relative words (i.e. increases the weight for tuples whose minimum number of levels
is small), <code>"worst.parft"</code> and <code>"worst.parftdf"</code> do the same with the
different versions of projection average <code class="reqn">R^2</code> values.</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_selprop">selprop</code></td>
<td>
<p>(approximate) proportion of worst case tuples to be selected (see <code>type</code>)</p>
</td></tr>
<tr><td><code id="generalized.word.length_+3A_...">...</code></td>
<td>
<p>further arguments; for the <code>design</code> method of function <code>lengths</code>,
the defaults <code>with.blocks = FALSE, J = FALSE</code> can be changed here;
for function <code>tupleSel</code>, ... is currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions work for factors only and are not intended for quantitative variables.
Nevertheless it is possible to apply them to class <code><a href="#topic+design">design</a></code> plans with quantitative
variables in them in some situations.
</p>
<p>The generalized word length pattern as introduced in Xu and Wu (2001) is the basis
for the functions described here. Consult their article or Groemping (2011)
for rigorous mathematical detail of this concept. A brief explanation is also given here,
before explaining the details for the functions: Assume a design with qualitative
factors, for which all factors are coded with specially normalized Helmert <code><a href="stats.html#topic+contrasts">contrasts</a></code>
(which orthogonalizes the model matrix columns to the intercept column).
Functions <code>contr.XuWu</code> and <code>contr.XuWuPoly</code> provide such contrasts
based on Helmert contrasts or orthogonal polynomial contrasts,
normalized according to the prescription by Xu and Wu (2001)
which implies that all model matrix columns
have Euclidean norm <code>sqrt(n)</code>, provided that each
individual factor is balanced.<br />
Then, the number of generalized words of length 3 is determined by taking the sum
of squares of the column averages of all three-factor interaction columns
(from a model matrix with all three-factor interactions included). <br />
Likewise, the number of generalized words of length 4 is determined by taking the sum
of squares of the column averages of all four-factor interaction columns
(from a model matrix with all four-factor interactions included), and so on.<br />
A certain plausibility can be found in these numbers by noting that they provide the
more well-known word length pattern for regular fractional factorial 2-level designs,
implying that they are exactly zero for resolution IV or resolution V fractional
factorial 2-level designs, respectively. Furthermore, Groemping and Xu (2014) provided
an interpretation in terms of <code class="reqn">R^2</code>-values from linear models for the number of
shortest words.
</p>
<p>Function <code>lengths</code> calculates the generalized word length
pattern (numbers of generalized words of lengths 2, 3, 4 and 5 respectively),
functions <code>length2</code>, <code>length3</code>, <code>length4</code> and <code>length5</code> calculate
each length separately. For designs with few rows and many columns, the newer
function <code><a href="#topic+GWLP">GWLP</a></code> is much faster; therefore it will be a better choice
than <code>lengths</code> for most applications. On the other hand, for designs with
many rows, <code>lengths</code> can be much faster. Furthermore, <code>lengths</code> and
the compoment functions <code>length2</code> to <code>length5</code> can calculate additional
detail not available from <code><a href="#topic+GWLP">GWLP</a></code>.
</p>
<p>The most important component length functions are
<code>length3</code> and <code>length4</code>; <code>length2</code>
should yield zero for all orthogonal arrays, and <code>length5</code> will in most
cases not be of interest either. The number of shortest possible words, e.g.
length 4 for resolution IV designs, can be calculated in relative terms, if
interest is in the extent of complete aliasing (cf. Groemping 2011).<br />
The length functions are fast for small numbers of factors but can take a
long time if the number of factors is large. Note that an orthogonal array
based design is called resolution III if the result of
function <code>length3</code> is non-zero, resolution IV,
if the result of function <code>length3</code> is zero and the
result of function <code>length4</code> is non-zero,
and resolution V+ (at least V), if the result of both functions <code>length3</code>
and <code>length4</code> are zero.
</p>
<p>Functions <code>P3.3</code> and <code>P4.4</code>
calculate the pattern of generalized words of length 3 for all three-factor
projections of an array and of generalized words of length 3 or 4 for all four-factor
projections of an array. Calculation of such projection frequency tables has been proposed
by Xu, Cheng and Wu (2004). The relative version for <code>P3.3</code> and <code>P4.4</code> has been
introduced by Groemping (2011) for better assessment of the projective properties of a design.
It divides each absolute number of words by the maximum possible number in case one
factor is completely determined by the combinations of the other two factors.
For <code>P4.4</code>, the relative version is valid only for resolution IV designs.
NOTE: For mixed-level designs, it is meanwhile recommended to use
ARFTs (Groemping 2013, 2017) instead of relative <code>P3.3</code> and <code>P4.4</code>;
these can be obtained by functions <code><a href="#topic+GRind">GRind</a></code> or <code><a href="#topic+SCFTs">SCFTs</a></code>
and have relevant advantages over the projection frequency tables from <code>P3.3</code> and <code>P4.4</code>
for mixed level designs. SCFTs (also treated in Groemping 2013, 2017) provide more detail
than ARFTs and are interesting for assessing the suitability of a design for screening purposes.
</p>
<p>The functions can be used in selecting among different possibilities to accomodate factors
within a given orthogonal array (cf. examples). For general purposes, it is recommended
to use designs with as small an outcome of <code>length3</code> as possible (either absolute or relative,
either total or worst case), and within the same result
for <code>length3</code> (particularly 0), with as small a result for <code>length4</code> as possible. This
corresponds to (a step towards) generalized minimum aberration. It can also be useful
to consider the patterns, particularly <code>P3.3</code>, or for mixed levels the aforementioned
ARFTs or SCFTs obtainable with functions <code><a href="#topic+GRind">GRind</a></code> or <code><a href="#topic+SCFTs">SCFTs</a></code>.
Note that some overall information on a design's behavior is available in the catalogue data frames
<code><a href="#topic+oacat">oacat</a></code> and <code><a href="#topic+oacat3">oacat3</a></code> and can be queried with function <code><a href="#topic+show.oas">show.oas</a></code>;
this helps for selecting a suitable array from which to start optimization efforts (see below).
</p>
<p>Functions <code>oa.min3</code>, <code>oa.min4</code>, <code>oa.min34</code>
optimize column allocation for a given array
for which a certain factor combination must be accomodated: They return designs that allocate
columns such that the number of generalized words of length 3 is minimized (<code>oa.min3</code>;
with a choice between minimizing the total number or minimizing the number for the worst-case triple
of factors), or
the number of generalized words of length 4 is minimized within all designs for which the number
of generalized words of length 3 is minimal (<code>oa.min34</code>, total number only); 
<code>oa.min4</code> does the same as <code>oa.min3</code>, but for designs of resolution IV, either entirely 
(e.g. designs from <code>oacat3</code>) or through the selection of suitable column variants.
Option <code>rela</code> allows to switch
from the default consideration of absolute numbers of words to relative numbers of words
according to Groemping (2011). This relative number corresponds to concentrating on the worst-case
ARFT entry for each set of R factors (R the resolution).
</p>
<p>Function <code>oa.maxGR</code> maximizes generalized resolution
according to Deng and Tang (1999) as generalized by Groemping (2011).    
**Note that function <code>oa.maxGR</code>
can be replaced by the much faster function <code>oa.min3</code> with options
<code>crit="worst"</code> and <code>rela=TRUE</code>, whenever GR&lt;=4. Only for designs with
GR &gt; 4, the extra effort with function <code>oa.maxGR</code> is useful.**
</p>
<p>Function <code>oa.minRelProjAberr</code> conducts minimum relative projection aberration
according to Groemping (2011), with the four steps <br /> 
(a) maximize GR (using function 
<code>oa.min3</code> with options <code>crit="worst"</code> and <code>rela=TRUE</code>), <br />
(b) minimize rA3 or
rA4 (depending on resolution), <br />
(c) optimize RPFT (as obtained by <code>P3.3</code>
or <code>P4.4</code>) and <br />
(d) minimize absolute words of lengths 4 etc. (only carried through
to length 4 by the function).
</p>
<p>Functions <code>oa.max3</code> and <code>oa.max4</code>
do the opposite: they search for the worst design in terms of the number of
generalized words of lengths 3 or 4. Such a design can e.g. be used
for demonstrating the benefit of optimizing the number of words,
or for exemplifying theoretical properties.
Occasionally, it may also be useful,
if there are severe restrictions on possible combinations.
(<code>oa.max4</code> should only be used for resolution IV designs.)
</p>
<p>Function <code>tupleSel</code> selects worst case tuples of R factors for resolution R designs.
Depending on the type requested, all completely aliased tuples are selected,
or the worst case tuples that exceed the <code>1-selprop</code> quantile of the numbers
of absolute or relative words are selected.
</p>


<h3>Value</h3>

<p>The functions <code>length3</code> and <code>length4</code> (currently) per default
return the number of generalized words. <br />
If option <code>J=TRUE</code> is set, their value
is a named vector of normalized absolute J-characteristics (cf. Ai and Zhang 2004)
for the respective length, based on normalized Helmert contrasts,
with names indicating factor indices.
(For blocked designs with the <code>with.blocks=TRUE</code> option,
the block factor has index 1.)
</p>
<p>Functions <code>P3.3</code> and <code>P4.4</code> return a matrix
with the numbers of generalized words of length 3 (4) that do occur
for 3 (4) factor projections (column <code>length3</code> or <code>length4</code> resp.)
and their frequencies. If option <code>rela=TRUE</code> is set, the numbers of generalized
words are normalized by dividing them by the number of words that corresponds
to perfect aliasing among the factors for each projection. For <code>P4.4</code>, the
relative version is only reasonable for resolution IV designs.
The matrix of projection frequencies has the overall number of generalized words
of the respective length as an attribute; in the case <code>rela=TRUE</code> it also
has the generalized resolution and the overall absolute number of generalized words
of the respective length as an attribute.
</p>
<p>The functions <code>oa.min3</code>, <code>oa.min34</code>, <code>oa.max3</code> and <code>oa.max4</code>
(currently) return a list with elements
<code>GWP</code> (the number(s) of generalized words of length 3 (lengths 3 and 4))
<code>column.variants</code> (the columns to be used for design creation, ordered with
ascending nlevels) and <code>complete</code> (logical indicating whether or not the list is
guaranteed to be complete).
<code>oa.min3</code>, the name of the first element is either <code>GWP3</code> (<code>crit="total"</code>),
<code>worst.a3</code> (<code>rela=FALSE, crit="worst"</code>) or <code>GR</code> (<code>rela=FALSE, crit="worst"</code>).
The function <code>oa.maxGR</code> returns a list with elements <code>GR</code>, <code>column.variants</code>
and <code>complete</code>, the function <code>oa.minRelProjAberr</code> returns a list with elements
<code>GR</code>, <code>GWP</code>, <code>column.variants</code> and <code>complete</code>.
</p>
<p>The function <code>nchoosek</code> returns a matrix with k rows and <code>choose(n, k)</code> columns,
each of which contains a different subset of k elements.
</p>
<p>The function <code>tupleSel</code> returns a sorted list of worst case tuples,
beginning with the worst case. In case of types <code>"worst"</code> or <code>"worst.rel"</code>,
attributes provide the (relative) projection frequency tables and the sorted
vector of the worst case projection values corresponding to the listed tuples.
</p>


<h3>Warning </h3>

<p>The functions have been checked on the types of designs for which
they are intended (especially orthogonal arrays produced with oa.design) and
on 2-level fractional factorial designs produced with package <span class="pkg">FrF2</span>.
They may produce meaningless results for some other types of designs.
</p>
<p>Furthermore, all optimizing functions work for relatively small problems only
and will break down for larger problems because of storage space requirements
(size depends on the number of possible selections among columns; for example, selecting
9 out of 31 columns is not doable on my computer because of storage space issues,
while selecting 29 out of 31 columns is doable within the available storage space).
Programming of a less storage-intensive algorithm is underway.
</p>


<h3>Note</h3>

<p>Function <code>nchoosek</code> has been taken from <span class="pkg">Bioconductor</span> package <span class="pkg">vsn</span>.<br />
Function <code>GWLP</code> is much faster (but also more inaccurate) than function <code>lengths</code>
and may be a better choice for designs with many factors.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Ai, M.-Y. and Zhang, R.-C. (2004). Projection justification of generalized minimum
aberration for asymmetrical fractional factorial designs.
<em>Metrika</em> <b>60</b>, 279&ndash;285.
</p>
<p>Groemping, U. (2011). Relative projection frequency tables for orthogonal arrays.
Report 1/2011, <em>Reports in Mathematics, Physics and Chemistry</em>
<a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2013). Frequency tables for the coding invariant ranking of
orthogonal arrays. Report 2/2013, <em>Reports in Mathematics, Physics and Chemistry</em>
<a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2017). Frequency tables for the coding invariant quality assessment
of factorial designs. <em>IISE Transactions</em> <b>49</b>(5), 505-517.
doi: <a href="https://doi.org/10.1080/0740817X.2016.1241458">10.1080/0740817X.2016.1241458</a>.
</p>
<p>Xu, H.-Q. and Wu, C.F.J. (2001). Generalized minimum aberration for asymmetrical
fractional factorial designs. <em>The Annals of Statistics</em> <b>29</b>, 1066&ndash;1077.
</p>
<p>Xu, H., Cheng, S., and Wu, C.F.J. (2004). Optimal projective three-level
designs for factor screening and interaction detection. <em>Technometrics</em> <b>46</b>,
280&ndash;292.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+GWLP">GWLP</a></code> for a version of lengths that is much
faster for designs with not so many runs, and <code><a href="#topic+GRind">GRind</a></code>
for another set of quality criteria for orthogonal arrays.<br />
Package <span class="pkg">DoE.MIParray</span> can create 
arrays for smallish situations for which the catalogued arrays do not provide 
satisfactory results; this package requires at least one of the commercial 
softwares Mosek or Gurobi to be installed (both provide free academic licenses).</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## check a small design
   oa12 &lt;- oa.design(nlevels=c(2,2,6))
   length3(oa12)
   ## length4 is of course 0, because there are only 3 factors
   P3.3(oa12)

   ## the results need not be an integer
   oa12 &lt;- oa.design(L12.2.11,columns=1:6)
   length3(oa12)
   length4(oa12)
   P3.3(oa12)  ## all projections have the same pattern
             ## which is known to be true for the complete L12.2.11 as well
   P3.3(L18)   ## this is the pattern of the Taguchi L18
             ## also published by Schoen 2009
   P3.3(L18[,-2])  ## without the 2nd column (= the 1st 3-level column)
   P3.3(L18[,-2], rela=TRUE)  ## relative pattern, divided by theoretical upper
                              ## bound for each 3-factor projection

   ## choosing among different assignment possibilities
   ## for two 2-level factors and one 3- and 4-level factor each
   show.oas(nlevels=c(2,2,3,4))
   ## default allocation: first two columns for the 2-level factors
   oa24.bad &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(1,2,14,15))
   length3(oa24.bad)
   ## much better: columns 3 and 10
   oa24.good &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(3,10,14,15))
   length3(oa24.good)
   length4(oa24.good)  ## there are several variants,
                       ## which produce the same pattern for lengths 3 and 4

   ## the difference matters
   plot(oa24.bad, select=c(2,3,4))
   plot(oa24.good, select=c(2,3,4))

   ## generalized resolution differs as well (resolution is III in both cases)
   GR(oa24.bad)
   GR(oa24.good)

   ## and analogously also GRind and ARFT and SCFT
   GRind(oa24.bad)
   GRind(oa24.good)

   ## GR and GRind can be different
   GRind(L18[, c(1:4,6:8)], arft=FALSE, scft=FALSE)

   ## choices for columns can be explored with functions oa.min3, oa.min34 or oa.max3
   oa.min3(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4))
   oa.min34(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4))
   ## columns for designs with maximum generalized resolution
   ##    (can take very long, if all designs have worst-case aliasing)
      ## then optimize these for overall relative number of words of length 3
      ##     and in addition absolute number of words of length 4
   mGR &lt;- oa.maxGR(L18, c(2,3,3,3,3,3,3))
   oa.minRelProjAberr(L18, c(2,3,3,3,3,3,3), maxGR=mGR)

   oa.max3(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4))    ## this is not for finding
                                                    ## a good design!!!

   ## Not run: 
   ## play with selection of optimum design
   ## somewhat experimental at present
   oa.min3(L32.2.10.4.7, nlevels=c(2,2,2,4,4,4,4,4))
   best3 &lt;- oa.min3(L32.2.10.4.7, nlevels=c(2,2,2,4,4,4,4,4), rela=TRUE)
   oa.min34(L32.2.10.4.7, nlevels=c(2,2,2,4,4,4,4,4))
   oa.min34(L32.2.10.4.7, nlevels=c(2,2,2,4,4,4,4,4), min3=best3)

   ## generalized resolution according to Groemping 2011, manually
   best3GR &lt;- oa.min3(L36.2.11.3.12, c(rep(2,3),rep(3,3)), rela=TRUE, crit="worst")
      ## optimum GR is 3.59
   ## subsequent optimization w.r.t. rA3
   best3reltot.GR &lt;- oa.min3(L36.2.11.3.12, c(rep(2,3),rep(3,3)), rela=TRUE,
           variants=best3GR$column.variants)
      ## optimum rA3 is 0.5069
   ## (note: different from first optimizing rA3 (0.3611) and then GR (3.5))
   ## remaining nine designs: optimize RPFTs
   L36 &lt;- oa.design(L36.2.11.3.12, randomize=FALSE)
   lapply(1:9, function(obj) P3.3(L36[,best3reltot.GR$column.variants[obj,]]))
      ## all identical
   oa.min34(L36, nlevels=c(rep(2,3),rep(3,3)), min3=best3reltot.GR)
      ## still all identical
   
## End(Not run)

   ## select among column variants with projection frequencies
   ## here, all variants have identical projection frequencies
   ## for larger problems, this may sometimes be relevant
   variants &lt;- oa.min34(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4))
   for (i in 1:nrow(variants$column.variants)){
      cat("variant ", i, "\n")
      print(P3.3(oa.design(L24.2.13.3.1.4.1, columns=variants$column.variants[i,])))
      }

   ## automatic optimization is possible, but can be time-consuming
   ## (cf. help for oa.design)
   plan &lt;- oa.design(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4), columns="min3")
   length3(plan)
   length4(plan)
   plan &lt;- oa.design(L24.2.13.3.1.4.1, nlevels=c(2,2,3,4), columns="min34")
   length3(plan)
   length4(plan)

   ## Not run: 
   ## blocked design from FrF2
   ## the design is of resolution IV
   ## there is one (generalized) 4-letter word that does not involve the block factor
   ## there are four more 4-letter words involving the block factor
   ## all this and more can also be learnt from design.info(plan)
   require(FrF2)
   plan &lt;- FrF2(32,6,blocks=4)
   length3(plan)
   length3(plan, with.blocks=TRUE)
   length4(plan)
   length4(plan, with.blocks=TRUE)
   design.info(plan)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='getblock'>
Functions to extract a block factor from a class design object 
or to rerandomize a class design object
</h2><span id='topic+getblock'></span><span id='topic+rerandomize.design'></span>

<h3>Description</h3>

<p>Function getblock creates block factors for designs with replications, repeated 
measurements or split plot designs. Function rerandomize.design rerandomizes 
an experimental design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getblock(design, combine=FALSE, ...)
rerandomize.design(design, seed=NULL, block=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getblock_+3A_design">design</code></td>
<td>

<p>an object of class <code><a href="#topic+design">design</a></code>, which is a design with replications 
or repeated measurements or a split plot design
</p>
</td></tr>
<tr><td><code id="getblock_+3A_combine">combine</code></td>
<td>

<p>logical with default <code>FALSE</code>. It has an effect for replicated blocked 
and splitplot designs only: If <code>TRUE</code>, all blocking information 
is combined into a single factor. Otherwise, a 
data frame with separate identifiers is returned.
</p>
</td></tr>
<tr><td><code id="getblock_+3A_seed">seed</code></td>
<td>

<p>integer number for initialization of the random number generator 
(needed for repeatable rerandomization) <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a rerandomization from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>rerandomize.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="getblock_+3A_block">block</code></td>
<td>

<p>character string giving the name of a block factor (only for unreplicated 
designs that do not have any prior blocking or split plot structure;
meant for block randomization of designs created with function <code>oa.design</code>)
</p>
</td></tr>
<tr><td><code id="getblock_+3A_...">...</code></td>
<td>

<p>currently not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of function <code>getblock</code> is to support users in doing their own analyses 
accomodating randomization restrictions like blocking and split plotting 
with R modeling functions. 
</p>
<p>The reason for including designs with proper replications is that these 
are randomized in blocks by packages <span class="pkg">DoE.base</span> and <span class="pkg">FrF2</span> and partly 
by <span class="pkg">DoE.wrapper</span>. 
While the package author does not consider it generally necessary to 
analyze these with a block factor, 
function getblock makes it easy for users with a different opinion 
(or for situations for which time turns out to be important in spite of 
not having explicitly blocked for time) to run an analysis with a block factor
for the replication. 
</p>
<p>For unreplicated split plot designs, a whole plot identifier is returned; 
the design itself contains the plot information via the settings of the 
whole plot factors only. Thus, it may be useful to be able to create the plot 
identifier.
</p>
<p>For replicated block or split plot designs, there is a randomization hierarchy 
that will depend on how the experiment was actually conducted. Therefore, 
a dataframe is generated the columns of which can be used in the appropriate way 
by a statistically literate user. 
</p>
<p>Function <code>rerandomize.design</code> rerandomizes a design. This can be useful if 
the user wants to obtain unblocked replications (packages <code>DoE.base</code> and <span class="pkg">FrF2</span> 
usually randomize in blocks on time) or wants to freely randomize the center point 
position over the whole range of the experiment (or a block, respectively), 
or if the user wants to also randomize the 
blocks (rather than randomizing the block units to the experimental blocks 
outside of the design), 
or if the user wants to do block randomization on a block factor specified with 
the <code>block</code> option  
for a design created with function <code>oa.design</code> or <code>pb</code> (which do not offer 
explicit specification of blocking).<br />
It can also be useful for ensuring a randomization that has little correlation 
between run order and model matrix columns; this correlation can e.g. be checked with 
the help of function <code><a href="#topic+corrPlot">corrPlot</a></code>, using the option <code>run.order=TRUE</code>.
</p>


<h3>Value</h3>

<p>Function <code>getblock</code> returns <br />
a single factor with block information (for split plot designs without replication 
or replicated designs without randomization restrictions) <br />
or a data frame with several blocking factors (for designs with randomization 
restrictions and replication).
</p>
<p>Function <code>rerandomize.design</code> returns a class <code>design</code> object; 
note that it will not be possible to add center points after re-randomization, 
i.e. if required, center points have to be added before using the function.
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a re-randomization that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## a blocked full factorial design
   ff &lt;- fac.design(nlevels=c(2,2,2,3,3,3), blocks=6, bbrep=2, wbrep=2, repeat.only=FALSE)
   getblock(ff)
   getblock(ff, combine=TRUE)
   rerandomize.design(ff)
   ff &lt;- fac.design(nlevels=c(2,2,2,3,3,3), replications=2, repeat.only=FALSE)
   getblock(ff)  
   ff &lt;- fac.design(nlevels=c(2,2,2,3,3,3), replications=2, repeat.only=FALSE)
   try(getblock(ff))
   ## a design created with oa.design
   small &lt;- oa.design(nlevels=c(2,2,2,2,2,2,2,2,8))
   rerandomize.design(small, block="J")
</code></pre>

<hr>
<h2 id='GRind'>
Functions for calculating generalized resolution, average R-squared values and
squared canonical correlations, and for checking design regularity
</h2><span id='topic+GR'></span><span id='topic+GRind'></span><span id='topic+print.GRind'></span><span id='topic+SCFTs'></span>

<h3>Description</h3>

<p>Function GR calculates generalized resolution, function GRind calculates
more detailed generalized resolution values, squared canonical correlations
and average R-squared values, the print method for class GRind appropriately prints the
detailed GRind values. Function SCFTs calculates squared canonical correlations for
factorial designs. SCFTs includes more projections than GRind (all full resolution
projections or even all projections) and decides on regularity of the design,
based on a conjecture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GR(ID, digits=2)
GRind(design, digits=3, arft=TRUE, scft=TRUE, cancors=FALSE, with.blocks=FALSE)
SCFTs(design, digits = 3, all = TRUE, resk.only = TRUE, kmin = NULL, kmax = ncol(design),
   regcheck = FALSE, arft = TRUE, cancors = FALSE, with.blocks = FALSE)
## S3 method for class 'GRind'
print(x, quote=FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRind_+3A_id">ID</code></td>
<td>
<p>an orthogonal array, either a matrix or a data frame; need not be of class <code>oa</code>;
can also be a character string containing the name of an array listed in data frame <code><a href="#topic+oacat">oacat</a></code></p>
</td></tr>
<tr><td><code id="GRind_+3A_digits">digits</code></td>
<td>
<p>number of decimal points to which to round the result</p>
</td></tr>
<tr><td><code id="GRind_+3A_design">design</code></td>
<td>
<p>a factorial design. This can either be a matrix or a data frame
in which all columns are experimental factors, or a special data frame
of class <code><a href="#topic+class-design">design</a></code>, which may also include response data.<br />
In any case, the design should be a factorial design;
the functions are not useful for quantitative designs (like e.g. latin hypercube samples).
</p>
</td></tr>
<tr><td><code id="GRind_+3A_arft">arft</code></td>
<td>
<p>logical indicating whether or not the average <code class="reqn">R^2</code> frequency table
(ARFT, see Groemping 2013) is to be returned
</p>
</td></tr>
<tr><td><code id="GRind_+3A_scft">scft</code></td>
<td>
<p>logical indicating whether the squared canonical correlation frequency
table (SCFT, see Groemping 2013) is to be returned
</p>
</td></tr>
<tr><td><code id="GRind_+3A_cancors">cancors</code></td>
<td>
<p>logical indicating whether individual canonical correlations
are to be returned (see Groemping 2013). These will not be needed
for normal use of the package.
</p>
</td></tr>
<tr><td><code id="GRind_+3A_with.blocks">with.blocks</code></td>
<td>
<p>a logical, indicating whether or not an existing block factor
is to be included into word counting. This option is ignored if <code>design</code>
is not of class <code>design</code>.<br />
Per default, an existing block factor is ignored.<br />
For designs without a block factor, the option does not have an effect.<br />
If the design is blocked, and <code>with.blocks</code>
is <code>TRUE</code>, the block factor is treated like any other factor in terms of word counting.</p>
</td></tr>
<tr><td><code id="GRind_+3A_all">all</code></td>
<td>
<p> logical; decides whether or not to consider projections of more than R~factors, where R denotes the design resolution</p>
</td></tr>
<tr><td><code id="GRind_+3A_resk.only">resk.only</code></td>
<td>
<p>logical; if <code>all</code> is <code>TRUE</code>, should only full resolution projections be considered?
Choosing <code>FALSE</code> may cause very long run times.</p>
</td></tr>
<tr><td><code id="GRind_+3A_kmin">kmin</code></td>
<td>
<p>integer; purpose is to continue an earlier run with additional larger projections</p>
</td></tr>
<tr><td><code id="GRind_+3A_kmax">kmax</code></td>
<td>
<p>integer; limit on projection sizes to consider</p>
</td></tr>
<tr><td><code id="GRind_+3A_regcheck">regcheck</code></td>
<td>
<p>logical; is the purpose a regularity check? If <code>TRUE</code>, the function stops after the first projection size
that included squared canonical correlation different from 0 or 1.</p>
</td></tr>
<tr><td><code id="GRind_+3A_x">x</code></td>
<td>
<p>a list of class <code>GRind</code>, as created by function <code>GRind</code></p>
</td></tr>
<tr><td><code id="GRind_+3A_quote">quote</code></td>
<td>
<p>a logical indicating whether character values are quoted</p>
</td></tr>
<tr><td><code id="GRind_+3A_...">...</code></td>
<td>
<p>further arguments to function <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>GR</code>, <code>GRind</code>, and <code>SCFTs</code> work for factors only and are not intended
for quantitative variables. Nevertheless it is possible to apply them to class <code><a href="#topic+design">design</a></code> plans with quantitative
variables in them in some situations.
</p>
<p>Function <code>GR</code> calculates the generalized resolution according to Deng and Tang (1999)
for 2-level designs or a generalization thereof according to Groemping (2011) and
Groemping and Xu (2014) for general
orthogonal arrays. It returns a value between 3 and 5, where the numeric value 5 stands for
&ldquo;at least 5&rdquo;. Roughly, generalized resolution measures the closeness of a design
to the next higher resolution (worst-case based, e.g. one completely aliased triple of
factors implies resolution 3).
</p>
<p>Function <code>GRind</code> (newer than <code>GR</code>, and recommended) calculates the generalized
resolution, together with factor wise generalized resolution values, squared canonical correlations
and average R-squared values, as mentioned in Groemping and Xu (2014) and further developed in
Groemping (2013, 2017).
The print method for class <code>Grind</code> objects prints the individual factor components of GRind.i such that they
do not mislead:
Because of the shortest word approach for GR, SCFT and ARFT, a GRind.i component
can be at most one larger than the resolution. For example, if GR is 3.5 so that the
resolution is 3, the largest possible numeric value of a GRind.i component is 4, but it means &quot;&gt;=4&quot;.
</p>
<p>Function <code>SCFTs</code> does more extensive SCFT and ARFT calculations than function <code>GRind</code>:
in particular, the function allows to do such calculations for more projection sizes,
either restricting attention to full resolution projections or going for ALL projections
with non-zero word lengths.
These capabilities have been introduced in relation to regularity checking based on SCFTs
(see Groemping and Bailey 2016):
Defining a factorial design as regular if all main effects are orthogonal in some sense
to effects including other factors of any order, it is conjectured that a regularity check on full resolution
projections only will suffice for identifying non-regularity (work in progress).
However, this is a conjecture only; as long as it is not proven, a definite check for this type of regularity requires checking ALL projections,
i.e. setting <code>resk.only</code> to <code>FALSE</code>. With this setting, the function may run for a very long time
(depends in particular on the number of factors)!
</p>


<h3>Value</h3>

<p>Function <code>GR</code> returns a list with elements <code>GR</code> (the generalized resolution of the array, a not necessarily integer
number between 3 and 5) and <code>RPFT</code> (the relative projection frequency table).
<code>GR</code> values smaller than 5 are exact, while the number five
stands for &ldquo;at least 5&rdquo;. The resolution itself is the integer portion of <code>GR</code>.
The <code>RPFT</code> element is the relative projection frequency table for 4-factor projections
for <code>GR=5</code>. For unconfounded three- and four-column designs, <code>GR</code> takes the
value <code>Inf</code> (used to be 5 for package versions up to 0.23-4).
</p>
<p>Function <code>GRind</code> works on designs with resolution at least 3 and
returns a list with elements <br />
<code>GRs</code> (the two versions of
generalized resolution described in Groemping and Xu 2014), <br />
the matrix <code>GR.i</code> with rows GRtot.i and GRind.i for the
factor wise generalized resolutions (also in Groemping and Xu 2014), <br />
and optionally <br />
the ARFT (Groemping 2013, 2017), <br />
the SCFT (Groemping 2013, 2017), <br />
and/or the canonical correlations.<br />
The latter are held in an <br />
nfac x choose(nfac-1, R-1) x max(nlev)-1 array <br />
and are supplemented with 0es,
if there are fewer of them than the respective dfi.
</p>
<p>The factor wise generalized resolutions are in the closed interval between
resolution and resolution + 1. In the latter case, their meaning is &quot;at least
resolution + 1&quot;. (The print method ensures that they are printed accordingly,
but the list elements themselves are just the numbers.)
</p>
<p>Function <code>SCFTs</code> returns a list of lists with a component for
each projection size considered. Each such component contains the following entries:
</p>
<table>
<tr><td><code>SCFT</code></td>
<td>
<p>Squared canonical correlation table for the projection size</p>
</td></tr>
<tr><td><code>ARFT</code></td>
<td>
<p>Average <code class="reqn">R^2</code> frequency table for the projection size (if requested)</p>
</td></tr>
<tr><td><code>cancors</code></td>
<td>
<p>canonical correlations (if requested)</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The functions have been checked on the types of designs for which
they are intended (especially orthogonal arrays produced with oa.design) and
on 2-level fractional factorial designs produced with package <span class="pkg">FrF2</span>.
They may produce meaningless results for some other types of designs.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Groemping, U. (2011). Relative projection frequency tables for orthogonal arrays.
Report 1/2011, <em>Reports in Mathematics, Physics and Chemistry</em>
<a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2013). Frequency tables for the coding invariant ranking of
orthogonal arrays. Report 2/2013, <em>Reports in Mathematics, Physics and Chemistry</em>
<a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2017). Frequency tables for the coding invariant quality assessment
of factorial designs. <em>IISE Transactions</em> <b>49</b>, 505-517.
doi: <a href="https://doi.org/10.1080/0740817X.2016.1241458">10.1080/0740817X.2016.1241458</a>.
</p>
<p>Groemping, U. and Bailey, R.A. (2016). Regular fractions of factorial arrays. In:
<em>mODa 11 &ndash; Advances in Model-Oriented Design and Analysis</em>.
New York: Springer.
</p>
<p>Groemping, U. and Xu, H. (2014). Generalized resolution for orthogonal arrays.
<em>The Annals of Statistics</em> <b>42</b>, 918&ndash;939.
<a href="https://projecteuclid.org/euclid.aos/1400592647">https://projecteuclid.org/euclid.aos/1400592647</a>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+GWLP">GWLP</a></code> and <code><a href="#topic+generalized.word.length">generalized.word.length</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   oa24.bad &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(1,2,14,15))
   oa24.good &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(3,10,14,15))
   ## generalized resolution differs (resolution is III in both cases)
   GR(oa24.bad)
   GR(oa24.good)

   ## and analogously also GRind and ARFT and SCFT
   GRind(oa24.bad)
   GRind(oa24.good)

   ## SCFTs
   ## Not run: plan &lt;- L24.2.12.12.1[,c(1:5,13)]
   GRind(plan)  ## looks regular (0/1 SCFT only)
   SCFTs(plan)
   SCFTs(plan, resk.only=FALSE)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='GWLP'> Function for fast calculation of GWLP </h2><span id='topic+GWLP'></span><span id='topic+GWLP.design'></span><span id='topic+GWLP.default'></span>

<h3>Description</h3>

<p>Calculates GWLP using the formulae from Xu and Wu (2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GWLP(design, ...)
## S3 method for class 'design'
GWLP(design, kmax=design.info(design)$nfactors, 
     attrib.out=FALSE, with.blocks = FALSE, digits = NULL, ...)
## Default S3 method:
GWLP(design, kmax=ncol(design), attrib.out=FALSE, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWLP_+3A_design">design</code></td>
<td>
<p> a design, not necessarily of class <code><a href="#topic+design">design</a></code>;
class design properties are exploited by using only factor columns 
(or factor and block columns, if <code>with.blocks</code> is <code>TRUE</code>) </p>
</td></tr>
<tr><td><code id="GWLP_+3A_kmax">kmax</code></td>
<td>
<p> the maximum word length requested </p>
</td></tr>
<tr><td><code id="GWLP_+3A_attrib.out">attrib.out</code></td>
<td>
<p> the detail added to the output (see Value section)</p>
</td></tr>
<tr><td><code id="GWLP_+3A_with.blocks">with.blocks</code></td>
<td>
<p> if <code>TRUE</code>, the block column contributes to 
the GWLP, otherwise it does not </p>
</td></tr>
<tr><td><code id="GWLP_+3A_digits">digits</code></td>
<td>
<p> the number of decimals to round to; <code>NULL</code> prevents rounding </p>
</td></tr>
<tr><td><code id="GWLP_+3A_...">...</code></td>
<td>
<p> further arguments to generic <code>GWLP</code>; not used in the methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>GWLP</code> is much faster but also more inaccurate than the 
function <code><a href="#topic+lengths">lengths</a></code>, which calculates numbers of words 
for lengths 2 to 5 only. Note, however, that function <code><a href="#topic+lengths">lengths</a></code> 
can be faster for designs with very many rows. <br />
If a design factor contains only some of the intended levels, 
<code>design</code> must be a data frame, and the factor must be an R
factor with the complete set of levels specified, 
in order to make function <code>GWLP</code> aware of the missing levels.
</p>


<h3>Value</h3>

<p>The <code>GWLP</code> methods output a named vector with the numbers of generalized 
words of lengths zero to <code>kmax</code>. If <code>attrib.out</code> is <code>TRUE</code>, 
this vector comes with the attributes <code>B</code> and <code>levels.info</code>, 
the latter documenting the level situation of the design, the former 
the distance distribution B (Xu and Wu 2001).
</p>


<h3>Author(s)</h3>

<p> Hongquan Xu, Ulrike Groemping </p>


<h3>References</h3>

 
<p>Xu, H.-Q. and Wu, C.F.J. (2001). Generalized minimum aberration for 
asymmetrical fractional factorial designs. 
<em>Annals of Statistics</em> <b>29</b>, 1066&ndash;1077.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+lengths">lengths</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>GWLP(L18)
GWLP(L18, attrib.out=TRUE)
</code></pre>

<hr>
<h2 id='GWLP_internals'> Internal functions in support of function GWLP </h2><span id='topic+levels.no'></span><span id='topic+ham'></span><span id='topic+Kraw'></span><span id='topic+Choose'></span><span id='topic+distDistmix'></span><span id='topic+levelmix'></span><span id='topic+Bprime'></span><span id='topic+dualDistmix'></span>

<h3>Description</h3>

<p>Internal functions needed for function GWLP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Choose(n, k)
Kraw(k,x,n,q)
ham(c1, c2)
# levels.no(xx)
levelmix(xx)
distDistmix(code, levm)
Bprime(dists, nmax=5)
dualDistmix(Bprime, nmax=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWLP_internals_+3A_n">n</code></td>
<td>
<p>an integer number</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_k">k</code></td>
<td>
<p>an integer number</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_x">x</code></td>
<td>
<p>an integer number</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_q">q</code></td>
<td>
<p>an integer number</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_c1">c1</code></td>
<td>
<p>a design row</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_c2">c2</code></td>
<td>
<p>a design row</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_xx">xx</code></td>
<td>
<p> a design, not necessarily of class <code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_code">code</code></td>
<td>
<p> a design, not necessarily of class <code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_levm">levm</code></td>
<td>
<p> an object returned by function <code>levelmix</code> </p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_dists">dists</code></td>
<td>
<p> the BSep element of an outcome object from <code>distDistmix</code>, 
analogous to the B_j1_j2 of p.1072 of Xu and Wu 2001</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_nmax">nmax</code></td>
<td>
<p>set to <code>kmax</code> in calls by other functions</p>
</td></tr>
<tr><td><code id="GWLP_internals_+3A_bprime">Bprime</code></td>
<td>
<p>an outcome object from <code>Bprime</code>, the MacWilliams transform 
of the distance distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are used in function <code><a href="#topic+GWLP">GWLP</a></code>.
Function <code>ham</code> calculates the Hamming distance, function <code>Kraw</code> 
the Krawtchouk polynomials, function <code>Choose</code> differs from the base 
function <code><a href="base.html#topic+choose">choose</a></code> by treatment of negative values <code>n</code>, 
functions <code>levels.no</code> and <code>levelmix</code> are utilities providing the 
level information on the design <code>xx</code> (<code>levels.no(xx)</code> is commented out 
in the usage section, because it can be seen as an S3 method for the generic 
function <code>levels</code> for objects of a conceivable class <code>no</code>; 
therefore its documentation without <code>#</code> would cause complaints in CRAN checks.) 
The functions <code>distDistmix</code>, <code>Bprime</code> and <code>dualDistmix</code> 
implement formulae from Xu and Wu (2001) for the distance distribution, 
its MacWilliams transform and the calculation of GWLP from the latter.
</p>


<h3>Value</h3>

<p>not documented for these internal functions
</p>


<h3>Author(s)</h3>

<p> Hongquan Xu, Ulrike Groemping </p>


<h3>References</h3>

 
<p>Xu, H.-Q. and Wu, C.F.J. (2001). Generalized minimum aberration for 
asymmetrical fractional factorial designs. 
<em>Annals of Statistics</em> <b>29</b>, 1066&ndash;1077.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+GWLP">GWLP</a></code> </p>

<hr>
<h2 id='halfnormal'>
Creation of half normal effects plots and numeric methods for 
significance assessment
</h2><span id='topic+halfnormal'></span><span id='topic+halfnormal.default'></span><span id='topic+halfnormal.lm'></span><span id='topic+halfnormal.design'></span><span id='topic+null.check'></span><span id='topic+orth.check'></span><span id='topic+ME.Lenth'></span><span id='topic+CME.LW98'></span><span id='topic+CME.EM08'></span>

<h3>Description</h3>

<p>Generic function and methods for creating half normal effects plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfnormal(x, ...)
## Default S3 method:
halfnormal(x, labs=names(x), codes = NULL, pch = 1, cex.text = 1,
   alpha = 0.05, xlab = "absolute effects", large.omit = 0, plot=TRUE, 
   crit=NULL, ...)
## S3 method for class 'lm'
halfnormal(x, labs = NULL, code = FALSE, pch = NULL, cex.text = 1, 
   alpha = 0.05, xlab = "absolute coefficients", large.omit = 0, plot=TRUE, 
   keep.colons = !code, ME.partial = FALSE, 
   external.pe = NULL, external.center = FALSE, contr.center = "contr.poly", 
   pch.set = c(1, 16, 8), scl = NULL, method="Lenth", 
   legend=code, err.points=TRUE, err.line=TRUE, linecol="darkgray", linelwd=2, 
   ...)
## S3 method for class 'design'
halfnormal(x, response = NULL, labs = NULL, code = FALSE, pch = NULL, 
   cex.text = 1, 
   alpha = 0.05, xlab = "absolute coefficients", large.omit = 0, plot=TRUE, 
   keep.colons = !code, ME.partial = FALSE, 
   external.pe = NULL, external.center = FALSE, contr.center = "contr.poly", 
   pch.set = c(1, 16, 8), scl = NULL, method="Lenth", 
   legend=code, err.points=TRUE, err.line=TRUE, linecol="darkgray", linelwd=2, 
   ...)

ME.Lenth(b, simulated=TRUE, alpha=NULL)
CME.LW98(b, sterr, dfe, simulated=TRUE, alpha=NULL)
CME.EM08(b, sterr, dfe, simulated=TRUE, weight0=5, alpha=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halfnormal_+3A_x">x</code></td>
<td>
<p>a numeric vector of effects, a linear model from experimental data, 
or an experimental design of class <code>design</code></p>
</td></tr>
<tr><td><code id="halfnormal_+3A_labs">labs</code></td>
<td>
<p>effect labels;<br /> 
default labels: for the default method, names of the vector x, or <code>b1</code>, <code>b2</code>, ... for 
unnamed vectors; for classes <code>design</code> or <code>lm</code> taken from the linear model</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_codes">codes</code></td>
<td>
<p>a vector with a code for each effect; the default <code>NULL</code> 
uses the <code>labs</code> values</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_code">code</code></td>
<td>
<p>a logical; <code>TRUE</code> implies that factor letters 
are used instead of factor codes, and that the default for default for 
<code>keep.colons</code> is changed to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="halfnormal_+3A_pch">pch</code></td>
<td>
<p>plot symbol; <code>NULL</code>, a number or a vector of plot symbol numbers 
or the same length as the effects in x;<br /> 
in the default method, a single number (default 1) implies that the given 
plotting symbol is used for for all points;<br /> 
for the other methods, the default <code>NULL</code> or a single number 
implies that pch.set is employed for lack of fit or pure error contrast points;<br />
for the non-default methods, a vector-valued <code>pch</code> will only rarely be useful 
(see Details section)</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_cex.text">cex.text</code></td>
<td>
<p>factor to hand to <code>cex</code> argument for point labeling with 
function <code>text</code> and margin annotations with function <code>mtext</code>; 
for <code>mtext</code>, it is multiplied with <code>par("cex")</code>, in order to 
obtain the same size for point labels and the margin annotations.
</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_alpha">alpha</code></td>
<td>
<p>number between 0 and 1: the significance level for labelling effects;<br /> 
for functions <code>ME.Lenth</code>, <code>CME.LW98</code> and <code>CME.EM08</code>, 
<code>alpha</code> can also be <code>NULL</code> or a numeric vector; 
for using the simulated critical bounds, all elements of alpha must be in 
0.01,0.02,...,0.25</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_xlab">xlab</code></td>
<td>
<p>character string: the x axis label</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>FALSE</code>, plotting is suppressed</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_large.omit">large.omit</code></td>
<td>
<p>integer number of largest effects to be omitted from plot 
and calculations in order to concentrate on the smaller effects; 
(note that the significance is also re-assessed; if that is undesirable, 
an explicit <code>crit</code> value can be specified from all coefficients, 
or <code>alpha</code> can be adjusted to reflect the same significant effects 
as with all coefficients)</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_crit">crit</code></td>
<td>
<p>default <code>NULL</code>; not meant for the end user; allows the <code>method</code> 
option for linear models and experimental designs to choose alternatives 
to Lenth's method</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_keep.colons">keep.colons</code></td>
<td>
<p>if <code>TRUE</code>, the automatic effect labels contain colons for interactions</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_me.partial">ME.partial</code></td>
<td>
<p>if <code>TRUE</code>, partial aliasing among main effects is 
permitted and will be orthogonalized away</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_external.pe">external.pe</code></td>
<td>
<p>numeric vector with values from outside the experimental data 
for use in estimating the error variance</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_external.center">external.center</code></td>
<td>
<p>if <code>TRUE</code>, external values from <code>external.pe</code> 
are taken as center point values, and a nonlinearity check contrast is estimated 
from them</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_contr.center">contr.center</code></td>
<td>
<p>contrasts used for external center points; 
<code>contr.poly</code> or <code>contr.XuWu</code></p>
</td></tr>
<tr><td><code id="halfnormal_+3A_pch.set">pch.set</code></td>
<td>
<p>plot symbols used for experimental effects, automatically 
determined lack of fit contrasts or pure error effects</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_scl">scl</code></td>
<td>
<p>squared column length to which the model matrix is normalized; 
default: number of experimental runs</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_method">method</code></td>
<td>
<p>the default <code>"Lenth"</code> applies Lenth's method to 
the combined set of effects including error contrasts (if any); 
the alternatives <code>"LW98"</code> or <code>"EM08"</code> 
apply the methods proposed by Larntz and Whitcomb (1998) or 
Edwards and Mee (2008) with weight0=5; if there is no pure error, 
method <code>"Lenth"</code> is always used, with a warning</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_legend">legend</code></td>
<td>
<p>squared column length to which the model matrix is normalized; 
default: number of experimental runs</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_err.points">err.points</code></td>
<td>
<p>logical, default <code>TRUE</code>; determines, whether pure error 
points are added to the plot (lack-of-fit points are always added)</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_err.line">err.line</code></td>
<td>
<p>logical, default <code>TRUE</code>; determines, whether null line 
is added to the plot in case pure error points are available</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_linecol">linecol</code></td>
<td>
<p>specifies the color for the null line, if applicable</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_linelwd">linelwd</code></td>
<td>
<p>specifies the width of the null line, if applicable</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_response">response</code></td>
<td>
<p>response for which the plot is to be created</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_...">...</code></td>
<td>
<p>further options to be handed to the <code>plot</code> function;<br />
among these, 
if options <code>col</code> and/or <code>cex</code> have an element for each effect, 
these are used in the expected order (first color refers to first element 
of x and so forth); this change was introduced in version 0.26-2 and 
causes an appropriate reordering in the actual plot function.</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_b">b</code></td>
<td>
<p>vector of coefficients</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_simulated">simulated</code></td>
<td>
<p>logical; if <code>FALSE</code>, the original critical values from 
Lenth 1989 are used, otherwise the methods use stored simulated values from a million 
simulation runs for significance levels of 0.01, 0.02, ..., to 0.25</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_sterr">sterr</code></td>
<td>
<p>a standard error for <code>b</code>, obtained from (a few, <code>dfe</code>) 
pure error degrees of freedom; the methods by Larntz and Whitcomb (1998) and 
Edwards and Mee (2008) combine this with Lenth's method</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_dfe">dfe</code></td>
<td>
<p>the number of pure error degrees of freedom on which 
<code>sterr</code> was based</p>
</td></tr>
<tr><td><code id="halfnormal_+3A_weight0">weight0</code></td>
<td>
<p>a tuning parameter for the method by Edwards and Mee 2008; 
Edwards and Mee recommend to set this to 5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>halfnormal</code> creates half normal effects plots with automatic 
effect labelling according to significance. It also prints the significant 
effects and creates an output object that contains only the vector if signifcant 
effects (for the default method) or in addition several further components (see 
section &quot;Value&quot;). Note: The methods for linear models and experimental designs plot 
absolute coefficients from a linear model (i.e. in case of 2-level factors with 
the usual -1/+1 coding, half of the absolute effects).
</p>
<p>The methods for linear models and experimental designs allow to automatically 
create lack of fit and pure error contrasts to also be included in the plot, 
following an orthogonalization strategy similar to Section 5 in Langsrud (2001). 
Furthermore, they handle factors with more than two levels, and they handle partially 
aliased effects by orthogonalizing out previous effects from later effects in 
the model order (similar to what Langsrud 2001 proposed for multiple response 
variables); thus, the plots are order dependent in case of partial aliasing. 
The more severe the partial aliasing, the more drastic the difference between the 
different effect orders. Per default, main effects are required to be 
orthogonal; this can be changed via option <code>ME.partial</code>.
</p>
<p>The functions <code>ME.Lenth</code>, <code>CME.LW98</code> and <code>CME.EM08</code> yield standard 
error estimates and critical values. For alpha in 0.01, 0.02, ..., 0.25, 
function <code>ME.Lenth</code> uses simulated critical values from a large number of 
simulations (1000000), if the number of effects is in 7 to 143. 
Functions <code>CME.LW98</code> and <code>CME.EM08</code> currently simulate critical values 
from 10000 simulation runs on the fly.
If no simulated values are available or simulation has been switched off, 
the half-normal plotting routines will use the conservative t-values proposed by 
Lenth (1989) (<code>ME.Lenth</code>) or Larntz and Whitcomb (<code>CME.LW98</code> and <code>CME.EM08</code>).
</p>
<p>Vector valued entries for <code>pch</code>, <code>col</code> and <code>cex</code> are handled 
very specifically for the class <code>lm</code> and class <code>design</code> methods: 
They make the most sense if the model is already saturated: 
If no pure error effects have been automatically calculated, effects whose <code>pch</code> 
is identical to the third element of <code>pch.set</code> will be treated as pure error effects; 
this allows to manually code these effects.<br />
Generally, vector-valued <code>pch</code> (and <code>col</code> and <code>cex</code>) must have as 
many elements as the final coefficients vector after augmenting the coefficients;
the coefficient vector carries first the experimental coefficients, then the automatically 
calculated lack-of-fit coefficients, then the automatically calculated pure error 
coefficients, then lack-of fit coefficients from external replications, 
and finally the pure error coefficients from external replications. Even for 
<code>err.points=FALSE</code>, entries for all these elements are needed. The value for 
<code>pch</code> determines, which coefficients are considered pure error.
</p>


<h3>Value</h3>

<p>The default method for <code>halfnormal</code> visibly returns a character vector of significant 
effects only. The methods for linear models and experimental designs invisibly return lists 
of nine elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>coef</code> </td><td style="text-align: left;"> contains the estimated coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mm</code>   </td><td style="text-align: left;"> contains the model matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> after adjustment to equally scaled independent effects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mod.effs</code> </td><td style="text-align: left;"> the effects that are part of the model </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>res</code>    </td><td style="text-align: left;"> list that indicates the effects (named vector of position numbers)</td>
</tr>
<tr>
 <td style="text-align: left;"> 
              </td><td style="text-align: left;"> that were projected out from any particular model effect (element name) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>LCs</code>    </td><td style="text-align: left;"> contains the coefficients of the linear combinations</td>
</tr>
<tr>
 <td style="text-align: left;"> 
              </td><td style="text-align: left;"> taken from the residuals after projecting out the effects</td>
</tr>
<tr>
 <td style="text-align: left;"> 
              </td><td style="text-align: left;"> listed in <code>res</code> from the original model matrix columns.</td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> Where <code>LCs</code> elements are <code>NULL</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> the original effect completely disappeared </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td><td style="text-align: left;"> because of complete confounding with previous effects.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alpha</code>  </td><td style="text-align: left;"> contains the significance level</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>method</code> </td><td style="text-align: left;"> contains the method of significance assessment</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>signif</code> </td><td style="text-align: left;"> is a character vector of significant effects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>pchs</code>   </td><td style="text-align: left;"> is a numeric vector of plot character identifiers</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The functions <code>ME.Lenth</code>, <code>CME.LW98</code> and <code>CME.EM08</code> each 
return lists of length 4 with an estimate for s0, PSE, ME and SME for Lenth's 
method or their respective modifications for the other two methods (called 
s0, CPSE, CME and CSME for <code>CME.LW98</code> and Cs0, CPSE, CME and CSME for 
<code>CME.EM08</code>). The length of the (C)ME and (C)SME components depends on 
the length of alpha (default: 25 critical values for alphas from 0.25 to 0.01). 
</p>


<h3>Note</h3>

<p>If someone worked out how to modify symbol colors (option <code>col</code>)
and/or sizes (option <code>cex</code>) for a version before 0.26-2, 
version 0.26-2 will mess up the order of the symbol colors and/or sizes. 
The benefit: colors and symbol sizes can now be specified in the natural 
order, see description of the ... argument.</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping, Berliner Hochschule fuer Technik</p>


<h3>References</h3>

<p>Daniel, C. (1959) 
Use of Half Normal Plots in Interpreting Two Level Experiments.
<em>Technometrics</em> <b>1</b>, 311&ndash;340.
</p>
<p>Daniel, C. (1976) 
<em>Application of Statistics to Industrial Experimentation.</em>
New York: Wiley.
</p>
<p>Edwards, D. and Mee, R. (2008) Empirically Determined p-Values for Lenth t Statistics.
<em>Journal of Quality Technology</em> <b>40</b>, 368&ndash;380.
</p>
<p>Langsrud, O. (2001) Identifying Significant Effects in Fractional Factorial 
Multiresponse Experiments. <em>Technometrics</em> <b>43</b>, 415&ndash;424.
</p>
<p>Larntz, K. and Whitcomb, P. (1998) 
Use of replication in almost unreplicated factorials. 
Manuscript of a presentation given at the 42nd ASQ Fall Technical 
conference in Corning, New York. 
Downloaded 4/26/2013 at <a href="https://cdnm.statease.com/pubs/use-of-rep.pdf">https://cdnm.statease.com/pubs/use-of-rep.pdf</a>.
</p>
<p>Lenth, R.V. (1989) Quick and easy analysis of unreplicated factorials.
<em>Technometrics</em> <b>31</b>, 469&ndash;473.
</p>


<h3>See Also</h3>

<p>See also <code><a href="FrF2.html#topic+DanielPlot">DanielPlot</a></code> for (half) normal plots 
of 2-level fractional factorial designs without partial aliasing 
and ignoring any residual degrees of freedom</p>


<h3>Examples</h3>

<pre><code class='language-R'>### critical values
b &lt;- rnorm(12)
ME.Lenth(b)
ME.Lenth(b)$ME
ME.Lenth(b, alpha=0.22)
ME.Lenth(b, alpha=0.123)
ME.Lenth(b, alpha=0.12)
ME.Lenth(rnorm(144), alpha=0.1)
(mel &lt;- ME.Lenth(b, alpha=0.1))
## assuming an external effect standard error based on 3df
## Not run: CME.EM08(b, 0.1, 3, alpha=0.1)    
         ## does not run for saving CRAN check time 
         ## much smaller than Lenth, if external 
         ## standard error much smaller than s0 (see mel)

### Half normal plots
## the default method
halfnormal(rnorm(15), labs=paste("b",1:15,sep=""))
b &lt;- c(250, 8,7,6, rnorm(11))
halfnormal(b, labs=paste("b",1:15,sep=""))
halfnormal(b, labs=paste("b",1:15,sep=""), large.omit=1)

## the design method, saturated main effects design
plan &lt;- oa.design(L12.2.11)
halfnormal(add.response(plan,rnorm(12)))

## the design method, saturated main effects design, 
## partial aliasing due to a missing value
y &lt;- c(NA, rnorm(11))
## the following line would yield an error, because there is even 
## complete aliasing among main effects: 
## Not run: halfnormal(lm(y~., add.response(plan, y)), ME.partial=TRUE)
## this can only be helped by omitting a main effect from the model;
## afterwards, there is still partial aliasing,
## which must be explicitly permitted by the ME.partial option:
halfnormal(lm(y~.-D, add.response(plan, y)), ME.partial=TRUE)

## the linear model method
yc &lt;- rnorm(12)
## partial aliasing only
halfnormal(lm(yc~A+B+C+D+E+F+G+H+J+A:B, plan))
## both partial (A:B) and complete (E:F) aliasing are present
halfnormal(lm(yc~A+B+C+D+E+F+G+H+J+A:B+E:F, plan))
## complete aliasing only because of the missing value in the response
halfnormal(lm(y~A+B+C+D+E+F+G+H+J+A:B+E:F, plan),ME.partial=TRUE)
## omit a large dominating effect

halfnormal(lm(y~A+B+C+D+E+F+G+H+J+A:B+E:F, plan),ME.partial=TRUE)


## a regular fractional factorial design with center points
y20 &lt;- rnorm(20)
## Not run: halfnormal(lm(y20~.^2, FrF2(16,7,ncenter=4)))
</code></pre>

<hr>
<h2 id='ICFTs'>
Function for calculating interaction contribution frequency tables
</h2><span id='topic+ICFTs'></span><span id='topic+ICFT'></span>

<h3>Description</h3>

<p>Function ICFTs calculates interaction contribution frequency tables, 
function ICFT does the same for an entire (usually small) design with more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICFTs(design, digits = 3, resk.only = TRUE, kmin = NULL, kmax = ncol(design), 
   detail = FALSE, with.blocks = FALSE, conc = TRUE)
ICFT(design, digits = 3, with.blocks = FALSE, conc = TRUE, recode=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICFTs_+3A_design">design</code></td>
<td>
<p>a factorial design. This can either be a matrix or a data frame
in which all columns are experimental factors, or a special data frame
of class <code><a href="#topic+class-design">design</a></code>, which may also include response data.<br />
In any case, the design should be a factorial design;
the functions are not useful for quantitative designs (like e.g. latin hypercube samples).
</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_digits">digits</code></td>
<td>
<p>integer; number of digits to round to</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_resk.only">resk.only</code></td>
<td>
<p>logical; if <code>all</code> is <code>TRUE</code>, should only full resolution projections be considered? 
Choosing <code>FALSE</code> may cause very long run times.</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_kmin">kmin</code></td>
<td>
<p>integer; purpose is to continue an earlier run with additional larger projections</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_kmax">kmax</code></td>
<td>
<p>integer; limit on projection sizes to consider</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_detail">detail</code></td>
<td>
<p>logical indicating whether calculation details 
are to be returned (see Groemping 2016). These will not be needed
for normal use of the outcome, but may be interesting for special situations.
</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_with.blocks">with.blocks</code></td>
<td>
<p>a logical, indicating whether or not an existing block factor
is to be included into word counting. This option is ignored if <code>design</code>
is not of class <code>design</code>.<br />
Per default, an existing block factor is ignored.<br />
For designs without a block factor, the option does not have an effect.<br />
If the design is blocked, and <code>with.blocks</code>
is <code>TRUE</code>, the block factor is treated like any other factor.</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_conc">conc</code></td>
<td>
<p>logical indicating whether ambiguities should be resolved 
concentrating the contribution on as few individual values as possible (default) 
or distributing it as evenly as possible (if <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ICFTs_+3A_recode">recode</code></td>
<td>

<p>logical indicating whether or not to recode each column into normalized orthogonal 
coding with function <code><a href="#topic+contr.XuWu">contr.XuWu</a></code>;<br />
if set to FALSE, it is the users responsibility to provide a design in a 
<em>normalized orthogonal</em> coding of choice
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions work for factors only and are not intended
for quantitative variables. 
</p>
<p>Function <code>ICFTs</code> decomposes the projected $a_k$ values (most often: projected $a_3$ values) 
into single degree of freedom contributions from the respective $k$ factor interaction.   
</p>
<p>Function <code>ICFT</code> decomposes the all-factor interaction of the design given to it; 
it is intended for deep-dive investigations.
</p>
<p>The ICFT itself is independent of the choice of normalized orthogonal coding, as are the 
singular values and the matrix of left singular vectors; in case of several identical 
singular values, the left singular vectors are not uniquely determined but are subject to 
arbitrary rotation. The right singular vectors depend on the choice of normalized orthogonal 
coding. They represent the directions of coefficient vectors for which the interaction contributions 
indicate the bias potential for the intercept (see Groemping 2016 for the maths behind this).
</p>


<h3>Value</h3>

<p>Function <code>ICFTs</code> returns a list of lists with a component for 
each projection size considered. Each such component contains the following entries: 
</p>
<table>
<tr><td><code>ICFT</code></td>
<td>
<p>interaction contribution frequency table for the projection size</p>
</td></tr>
<tr><td><code>ICs</code></td>
<td>
<p>individual interaction contributions (if requested by option <code>detail</code>)</p>
</td></tr>
<tr><td><code>sv2s</code></td>
<td>
<p>squared singular values (if requested by option <code>detail</code>)</p>
</td></tr>
<tr><td><code>mean.u2s</code></td>
<td>
<p>squared column means of left-singular vectors (if requested by option <code>detail</code>)</p>
</td></tr>
</table>
<p>Function <code>ICFT</code> returns a list with the following components: 
</p>
<table>
<tr><td><code>ICFT</code></td>
<td>
<p>interaction contribution frequency table for the projection size</p>
</td></tr>
<tr><td><code>ICs</code></td>
<td>
<p>Average <code class="reqn">R^2</code> frequency table for the projection size</p>
</td></tr>
<tr><td><code>sv2s</code></td>
<td>
<p>squared singular values of the model matrix</p>
</td></tr>
<tr><td><code>mean.u2s</code></td>
<td>
<p>squared column means of left-singular vectors in the rotated version (concentrated or even)</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>model matrix of the interaction</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>(left singular vectors corresponding to the rotated version of ICFT (concentrated or even); 
these do not depend on the coding underlying the model matrix</p>
</td></tr>   
<tr><td><code>v</code></td>
<td>
<p>(right singular vectors corresponding to the rotated version of ICFT (concentrated or even); 
these depend on the coding underlying the model matrix</p>
</td></tr>   
<tr><td><code>c.worst</code></td>
<td>
<p>(<code>v%*%c.worst</code> is the worst case parameter vector for the model matrix <code>mm</code> 
in terms of bias of the average response for estimation of the intercept 
caused by the interaction under consideration</p>
</td></tr>   
</table>


<h3>Warning </h3>

<p>The functions have been checked on the types of designs for which
they are intended (especially orthogonal arrays produced with <code><a href="#topic+oa.design">oa.design</a></code>).
They may produce meaningless results for some other types of designs.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Groemping, U. (2017). An Interaction-Based Decomposition of Generalized Word Counts Suited to Assessing 
Combinatorial Equivalence of Factorial Designs. <em>Reports in Mathematics, Physics and Chemistry</em>, 
Report 1/2017. <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2017-001.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2017-001.pdf</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2018). Coding Invariance in Factorial Linear Models and a New Tool for Assessing 
Combinatorial Equivalence of Factorial Designs. 
<em>Journal of Statistical Planning and Inference</em> <b>193</b>, 1-14. 
doi: <a href="https://doi.org/10.1016/j.jspi.2017.07.004">10.1016/j.jspi.2017.07.004</a>.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+GWLP">GWLP</a></code> and <code><a href="#topic+generalized.word.length">generalized.word.length</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   oa24.bad &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(1,2,14,15))
   oa24.good &lt;- oa.design(L24.2.13.3.1.4.1, columns=c(3,10,14,15))
   ## resolution is III in both cases, but the bad one has more words of length 3
   GWLP(oa24.bad)[4:5]
   ICFTs(oa24.bad)
   ICFTs(oa24.bad, conc=FALSE)
   GWLP(oa24.good)[4:5]
   ICFTs(oa24.good)
   ICFTs(oa24.good, conc=FALSE)
   ICFTs(oa24.good, resk.only=FALSE)
   
   ICFT(L18[,c(1,4,6)])
   ICFT(L18[,c(1,4,6)], conc=FALSE)
</code></pre>

<hr>
<h2 id='iscube'>
Functions to isolate cube points from 2-level fractional factorial design with center and / or star points
</h2><span id='topic+iscube'></span><span id='topic+isstar'></span><span id='topic+pickcube'></span>

<h3>Description</h3>

<p>These functions identify the positions for cube points or star points 
and can reduce a central composite design to its cube portion (with 
center points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iscube(design, ...)
isstar(design, ...)
pickcube(design, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iscube_+3A_design">design</code></td>
<td>

<p>a data frame of class design that contains a 2-level fractional factorial 
(regular or non-regular) or a central composite design.
</p>
</td></tr>
<tr><td><code id="iscube_+3A_...">...</code></td>
<td>

<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>iscube</code> provides a logical vector that is TRUE for cube points 
and FALSE for center points and star points. Its purpose is to enable use of simple functions 
for &ldquo;clean&rdquo; 2-level fractional factorials like <code>MEPlot</code> or <code>DanielPlot</code>. 
</p>
<p>Function <code>isstar</code> provides a logical vector that is TRUE for the star block 
(including center points) of a central composite design.
</p>
<p>Function <code>pickcube</code> reduces a central composite design (type <code>ccd</code>) 
to its cube block, including center points. This function is needed, if a CCD 
has been created in one go, but analyses are already required after conducting 
the cube portion of the design (and these perhaps even prevent the star portion 
from being run at all).
</p>


<h3>Value</h3>

<p><code>iscube</code> and <code>isstar</code> each return a logical vector (cf. Details section).
</p>
<p><code>pickcube</code> returns a data frame of class design with 
<code>type</code> <code>FrF2.center</code> or <code>FrF2</code>.
</p>


<h3>Warning</h3>

<p>For version 0.22-8 of package <span class="pkg">DoE.base</span>, function <code>iscube</code> returned a wrong result 
without warning, when applied to an old version CCD design 
(before DoE.wrapper, version 0.8-6 of Nov 15 2011). <br />
Since version 0.23 of package <span class="pkg">DoE.base</span>, the function works on old designs, 
except for blocked or replicated versions; for these, an error is thrown.)
</p>


<h3>Note</h3>

<p>The functions have not been tested for central composite designs for which 
the cube portion itself is blocked.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Montgomery, D.C. (2001). <em>Design and Analysis of Experiments (5th ed.)</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p>See also as <code><a href="FrF2.html#topic+pb">pb</a></code>, <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="DoE.wrapper.html#topic+ccd.design">ccd.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## purely technical example, not run because FrF2 not loaded
  ## Not run: 
  plan &lt;- FrF2(16,5, factor.names=c("one","two","three","four","five"), ncenter=4)
  iscube(plan)
  plan2 &lt;- ccd.augment(plan)
  iscube(plan2)
  isstar(plan2)
  pickcube(plan2)
  
## End(Not run)
   </code></pre>

<hr>
<h2 id='lm+20and+20aov+20method+20for+20class+20design+20objects'>lm and aov methods for class design objects</h2><span id='topic+lm'></span><span id='topic+lm.default'></span><span id='topic+lm.design'></span><span id='topic+coef.lm.design'></span><span id='topic+aov'></span><span id='topic+aov.default'></span><span id='topic+aov.design'></span><span id='topic+print.summary.lm.design'></span><span id='topic+print.lm.design'></span><span id='topic+summary.lm.design'></span><span id='topic+print.summary.aov.design'></span><span id='topic+print.aov.design'></span><span id='topic+summary.aov.design'></span>

<h3>Description</h3>

<p>Methods for automatic linear models for data frames of class design 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm(formula, ...)
## Default S3 method:
lm(formula, data, subset, weights, na.action, method = "qr", 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...)
## S3 method for class 'design'
lm(formula, ..., response=NULL, degree=NULL, FUN=mean, 
    use.center=NULL, use.star=NULL, use.dummies=FALSE)
aov(formula, ...)
## Default S3 method:
aov(formula, data = NULL, projections = FALSE, qr = TRUE,
    contrasts = NULL, ...)
## S3 method for class 'design'
aov(formula, ..., response=NULL, degree=NULL, FUN=mean, 
    use.center=FALSE)
## S3 method for class 'lm.design'
print(x, ...)
## S3 method for class 'lm.design'
summary(object, ...)
## S3 method for class 'lm.design'
coef(object, ...)
## S3 method for class 'summary.lm.design'
print(x, ...)
## S3 method for class 'aov.design'
print(x, ...)
## S3 method for class 'aov.design'
summary(object, ...)
## S3 method for class 'summary.aov.design'
print(x, ...)
lm.design
summary.lm.design
aov.design
summary.aov.design
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_formula">formula</code></td>
<td>
<p> for the default method, cf. documentation for <code><a href="stats.html#topic+lm">lm</a></code> 
in package <span class="pkg">stats</span>;cr
for the class <code><a href="#topic+design">design</a></code> method, a data frame of S3 class 
<code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_...">...</code></td>
<td>
<p> further arguments to functions <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+lm">print.lm</a></code> or <code><a href="stats.html#topic+summary.lm">print.summary.lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_response">response</code></td>
<td>
<p> character string giving the name of the response variable 
(must be among the responses of <code>x</code>; 
for wide format repeated measurement or parameter designs, 
<code>response</code> can also be among the column names of the <code>responselist</code> 
element of the <code>design.info</code> attribute) <br />
OR<br />
integer number giving the position of the response in element 
<code>response.names</code> of attribute <code>design.info</code>
</p>
<p>For the default <code>NULL</code>, the first available response variable 
is used; for wide format designs, this is an aggregation of the variables 
given in first column from the <code>responselist</code> 
element of the <code>design.info</code> attribute of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_degree">degree</code></td>
<td>
<p> degree for the formula; if <code>NULL</code>, 
the default for the <code>formula</code> method is used </p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_fun">FUN</code></td>
<td>
<p> function for the <code><a href="#topic+aggregate.design">aggregate.design</a></code> method; 
this must be an unquoted function name;<br />
This option is relevant for repeated measurement designs 
and parameter designs in long format only</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_use.center">use.center</code></td>
<td>
 <p><code>NULL</code> or logical indicating whether center points are to be used +
in the analysis; <br />
if <code>NULL</code>, the default is FALSE for <code>pb</code> and <code>FrF2</code> designs with 
center points and TRUE for <code>ccd</code> designs; the option is irrelevant 
for all other design types.<br />
<code>FALSE</code> allows usage of simple analysis functions from package 
<code><a href="FrF2.html#topic+FrF2-package">FrF2-package</a></code> (e.g. function <code><a href="FrF2.html#topic+IAPlot">IAPlot</a></code>)
</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_use.star">use.star</code></td>
<td>
 <p><code>NULL</code> or logical indicating whether the star portion of a CCD design 
is to be used in the analysis (ignored for all other types of designs). <br />
The default TRUE analyses the complete design. Specifying FALSE permits interim analyses of 
the cube portion of a central composite design.
</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_use.dummies">use.dummies</code></td>
<td>
<p> logical indicating whether the error dummies of a Plackett Burman design 
are to be used in the formula (ignored for all other types of designs). 
</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_projections">projections</code></td>
<td>
<p> logical indicating whether the projections should be returned;
for orthogonal arrays, these are helpful, as they provide the estimated 
deviation from the overall average attributed to each particular factor; 
it is not recommended to use them with unbalanced designs </p>
</td></tr> 
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_x">x</code></td>
<td>
<p> object of class <code>lm</code> or <code>summary.lm</code>,<br /> 
for <code>lm.default</code> like in <code><a href="stats.html#topic+lm">lm</a></code>  </p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_object">object</code></td>
<td>
<p> object of class <code>lm.design</code> created by function <code>lm.design</code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_lm.design">lm.design</code></td>
<td>
<p>a class that is identical in content to class <code>lm</code>; 
its purpose is to call a specific print method that provides slightly more 
detail than the standard printout for linear models</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_summary.lm.design">summary.lm.design</code></td>
<td>
<p>a class that is identical in content to class <code>summary.lm</code>; 
its purpose is to call a specific print method that provides slightly more 
detail than the standard summary for linear models</p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_data">data</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_subset">subset</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_weights">weights</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_na.action">na.action</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_method">method</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_model">model</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_y">y</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_qr">qr</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_singular.ok">singular.ok</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_contrasts">contrasts</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="lm+2B20and+2B20aov+2B20method+2B20for+2B20class+2B20design+2B20objects_+3A_offset">offset</code></td>
<td>
<p> like in <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aov</code> and <code>lm</code> methods for class <code><a href="#topic+design">design</a></code> 
conduct a default linear model analysis for data frames of 
class <code><a href="#topic+design">design</a></code> that do contain at least one response.
</p>
<p>The intention for providing default analyses is to support convenient quick inspections. 
In many cases, there will be good reasons to customize the analysis, for example by including 
some but not all effects of a certain degree. Also, it may be statistically more wise 
to work with mixed models for some types of design. <b>The default analyses must not 
be taken as a statistical recommendation!</b>
</p>
<p>The choice of default analyses 
has been governed by simplicity: It uses fixed effects only and does either 
main effects models (<code>degree=1</code>, default for <code>pb</code> and <code>oa</code> designs), 
models with main effects and 2-factor interactions (<code>degree=2</code>, 
default for most designs) or second order models (that contain 
quadratic effects in addition to the 2-factor interactions, unchangeable default 
for designs with quantitative variables). The <code>degree</code> parameter can be used 
to modify the degree of interactions. If blocks are 
present, the block main effect is always entered as a fixed effect without interactions. 
</p>
<p>Designs with center points are per default analysed without the center points; the main 
reason for this is convenient usage of functions <code><a href="FrF2.html#topic+DanielPlot">DanielPlot</a></code>, 
<code><a href="FrF2.html#topic+IAPlot">MEPlot</a></code> and <code><a href="FrF2.html#topic+IAPlot">IAPlot</a></code> from package <span class="pkg">FrF2</span>. 
With the <code>use.center</code> option, this default can be changed; in this case, significance 
of the center point indicator implies that there are one or more quadratic effect(s) 
in the model.
</p>
<p>Designs with repeated measurements (<code>repeat.only=TRUE</code>) and parameter 
designs of long format are treated by <code><a href="#topic+aggregate.design">aggregate.design</a></code> 
with aggregation function <code>FUN</code> (default: means are calculated) 
before applying a linear model.
</p>
<p>For designs with repeated measurements (<code>repeat.only=TRUE</code>) and parameter 
designs of wide format, the default is to use the first aggregated response, 
if the design has been aggregated already. For a so far unaggregated design, 
the default is to treat the design by <code><a href="#topic+aggregate.design">aggregate.design</a></code>, 
using the function <code>FUN</code> (default: mean) and then use the first response. 
The defaults can be overridden by specifying <code>response</code>: Here, 
<code>response</code> can not only be one of the current responses but also a column name 
of the <code>responselist</code> element of the <code>design.info</code> attribute of the 
design (i.e. a response name from the long version of the design).
</p>
<p>The implementation of the formulae is not done in functions <code>lm.design</code> or 
<code>aov.design</code> themselves 
but based on the method for function formula (<code><a href="#topic+formula.design">formula.design</a></code>).
</p>
<p>The <code>print</code> methods prepend the formula and the number of experimental runs 
underlying the analysis to the default printout. 
The purpose of this is meaningful output in case a call from 
inside function <code><a href="#topic+lm.design">lm.design</a></code> or <code><a href="#topic+aov.design">aov.design</a></code> 
(methods for functions <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+aov">aov</a></code> ) 
does not reveal enough information, and another pointer that center points have been 
omitted or repeated measurements aggregated over. The <code>coef</code> method for objects 
of class <code>lm.design</code> suppresses <code>NA</code> coefficients, i.e. 
returns valid coefficients only. For <code>aov</code> objects, this is the default 
anyway.
</p>


<h3>Value</h3>

<p>The value for the <code>lm</code> functions is a linear model object, 
exactly like for function <code><a href="stats.html#topic+lm">lm</a></code>, 
except for the added class <code>lm.design</code> in case of the method for class <code>design</code>, 
and an added list element <code>WholePlotEffects</code> for split plot designs.
</p>
<p>The value for the <code>aov</code> functions is an aov object, 
exactly like for function <code><a href="stats.html#topic+aov">aov</a></code>, 
and an added list element <code>WholePlotEffects</code> for split plot designs.
</p>
<p>The value of the <code>summary</code> functions for class <code>lm.design</code> and 
<code>aov.design</code> respectively
is a linear model or aov summary, exactly like documented in <code><a href="stats.html#topic+summary.lm">summary.lm</a></code> 
or <code><a href="stats.html#topic+summary.aov">summary.aov</a></code>, 
except for the added classes <code>summary.lm.design</code> or <code>summary.aov.design</code>, 
and an added list element <code>WholePlotEffects</code> (for <code>summary.lm.design</code>) 
or attribute (for <code>summary.aov.design</code>) for split plot designs.
</p>
<p>The print functions return <code>NULL</code>; they are used for their side effects only.
</p>


<h3>Warning</h3>

<p> The generics for <code>lm</code> and <code>aov</code> replace the functions 
from package <span class="pkg">stats</span>. For normal use, this is not an issue, because their 
default methods are exactly the functions from package <span class="pkg">stats</span>.<br /> 
However, when programming on the language (or when using a package that relies on 
such constructs), you may see unexpected results. 
For example, <code>match.call(lm)</code> returns a different result, depending on 
whether or not package <span class="pkg">DoE.base</span> is loaded. This can be avoided by 
explicitly requesting e.g. <code>match.call(stats::lm)</code>, which always works 
in the same way.<br />
Please report any additional issues that you may experience.
</p>


<h3>Note</h3>

<p> The package is currently subject to intensive development; most key functionality is now included. 
Some changes to input and output structures may still occur.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also the information on class <code><a href="#topic+design">design</a></code> 
and its formula method <code><a href="#topic+formula.design">formula.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  oa12 &lt;- oa.design(nlevels=c(2,2,6))
  ## add a few variables to oa12
  responses &lt;- cbind(y=rexp(12),z=runif(12))
  oa12 &lt;- add.response(oa12, responses)
  ## want treatment contrasts rather than the default
  ## polynomial contrasts for the factors 
  oa12 &lt;- change.contr(oa12, "contr.treatment")
  linmod.y &lt;- lm(oa12)
  linmod.z &lt;- lm(oa12, response="z")
  linmod.y
  linmod.z
  summary(linmod.y)
  summary(linmod.z)
  
## examples with aggregation
  plan &lt;- oa.design(nlevels=c(2,6,2), replications=2, repeat.only=TRUE)
  y &lt;- rnorm(24)
  z &lt;- rexp(24)
  plan &lt;- add.response(plan, cbind(y=y,z=z))
  lm(plan)
  lm(plan, response="z")
  lm(plan, FUN=sd)
  ## wide format
  plan &lt;- reptowide(plan)
  plan
  design.info(plan)$responselist
  ## default: aggregate variables for first column of responselist
  lm(plan)
  ## request z variables instead (z is the column name of response list)
  lm(plan, response="z") 
  ## force analysis of first z measurement only
  lm(plan, response="z.1")
  ## use almost all options 
  ## (option use.center can only be used with center point designs 
  ##          from package FrF2)
  summary(lm(plan, response="z", degree=2, FUN=sd))

</code></pre>

<hr>
<h2 id='lowerbound_AR'>
Function to Calculate a Lower Bound for A_R and Internal Auxiliary Functions
</h2><span id='topic+lowerbound_AR'></span><span id='topic+lowerbounds'></span><span id='topic+lowerbound_chi2'></span>

<h3>Description</h3>

<p>The functions serve the calculation of lower bounds for the worst case confounding. lowerbound_AR is intended for direct use, lowerbounds and lowerbound_chi2 are internal functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowerbound_AR(nruns, nlevels, R, crit = "total")
lowerbounds(nruns, nlevels, R)
lowerbound_chi2(nruns, nlevels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowerbound_AR_+3A_nruns">nruns</code></td>
<td>

<p>positive integer, the number of runs
</p>
</td></tr>
<tr><td><code id="lowerbound_AR_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of positive integers, the numbers of levels for the factors
</p>
</td></tr>
<tr><td><code id="lowerbound_AR_+3A_r">R</code></td>
<td>

<p>positive integer, the resolution of the design; 
if it is uncertain whether resolution R is feasible, 
this should be checked by function <code><a href="#topic+oa_feasible">oa_feasible</a></code> before applying 
any of the lower bound functions.
</p>
</td></tr>
<tr><td><code id="lowerbound_AR_+3A_crit">crit</code></td>
<td>

<p><code>"total"</code> or <code>"worst"</code>; if <code>"total"</code>,
a bound for the overall A_R (sum of the results from <code>lowerbounds</code>) is calculated;
otherwise, a bound for the largest individual contribution from an R factor set is calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: if the specified resolution R is not feasible (necessary conditions can be 
checked with function <code><a href="#topic+oa_feasible">oa_feasible</a></code>), any bound(s) returned will be 
meaningless.
</p>
<p>Function <code>lowerbounds</code> provides (integral) bounds on <code class="reqn">n^2 A_R</code> 
(with <code class="reqn">n</code>=<code>nruns</code>) according to Groemping and Xu (2014) Theorem 5 for all R factor sets. 
If the number of runs permits a design with resolution larger than R, the value(s) will be 0. 
For resolution at least III, the result of function <code>lowerbound_AR</code> is the sum (<code>crit="total"</code>) 
or maximum (<code>crit="worst"</code>) of these individual bounds, divided by the square of the number of runs.
</p>
<p>For resolution II and <code>crit="total"</code>, function <code>lowerbound_chi2</code> implements 
the lower bound <em>B</em> on <code class="reqn">\chi^2</code> which was provided in Lemma 2 of Liu and Lin (2009). 
For supersaturated resolution II designs, this bound is is usually sharper than the one 
obtained on the basis of Groemping and Xu (2014). Due to the relation between <code class="reqn">A_2</code> 
and <code class="reqn">\chi^2</code> that is stated in Groemping (2017) (summands of <code class="reqn">A_2</code> are an 
<em>n</em>th of a <code class="reqn">\chi^2</code>, with <code class="reqn">n</code>=<code>nruns</code>), this bound can be easily 
transformed into a bound for <code class="reqn">A_2</code>; this relation is also used to slightly sharpen 
the bound <em>B</em> itself: <code class="reqn">n^2 \cdot A_2</code> must be integral, 
which implies that <em>B</em> can be replaced by <code>ceiling(nruns*B)/nruns</code>, 
which is applied in function <code>lowerbound_chi2</code>. Function <code>lowerbound_AR</code> 
increases the lower bound on <code class="reqn">A_2</code> accordingly, if <code>lowerbound_chi2</code> provides 
a sharper bound than the sum of the elements returned by functioni <code>lowerbounds</code>.
</p>


<h3>Value</h3>

<p><code>lowerbound_AR</code> returns a lower bound for the number of words of length <code>R</code> 
(either total or worst case), <br />
<code>lowerbounds</code> returns a vector of lower bounds for individual <code>R</code> factor 
sets on a different scale (division by <code>nruns^2</code> needed for transforming this 
into the contributions to words of length <code>R</code>),<br />
and function <code>lowerbound_chi2</code> returns a lower bound on the <code class="reqn">\chi^2</code> 
value which can be used as a quality criterion for supersaturated designs.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Groemping, U. and Xu, H. (2014). Generalized resolution for orthogonal arrays. <em>The Annals of Statistics</em> <b>42</b>, 918-939.
</p>
<p>Groemping, U. (2017). Frequency tables for the coding-invariant quality assessment of factorial designs. <em>IISE Transactions</em> <b>49</b>, 505-517.
</p>
<p>Liu, M.Q. and Lin, D.K.J. (2009). Construction of Optimal Mixed-Level Supersaturated Designs. <em>Statistica Sinica</em> <b>19</b>, 197-211.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+oa_feasible">oa_feasible</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerbound_AR(24, c(2,3,4,6),2)
</code></pre>

<hr>
<h2 id='Methods+20for+20class+20design+20objects'>Methods for class design objects</h2><span id='topic++5B.design'></span><span id='topic+aggregate.design'></span><span id='topic+print.design'></span><span id='topic+summary.design'></span><span id='topic+class-design-methods'></span>

<h3>Description</h3>

<p>Methods for subsetting, aggregating, printing and summarizing class 
design objects. The formula, lm and plot methods are subject of a separate help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'design'
x[i, j, drop.attr = TRUE, drop = FALSE]
## S3 method for class 'design'
print(x, show.order=NULL, group.print=TRUE, std.order=FALSE, ...)
## S3 method for class 'design'
summary(object, brief = NULL, quote = FALSE, ...)
## S3 method for class 'design'
aggregate(x, ..., 
    by = NULL, response = NULL, FUN = "mean", postfix = NULL, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_x">x</code></td>
<td>
<p> data frame of S3 class <code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_i">i</code></td>
<td>
<p> indices for subsetting rows </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_j">j</code></td>
<td>
<p> indices for subsetting columns </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_drop.attr">drop.attr</code></td>
<td>
<p> logical, controls whether or not attributes are dropped; 
if <code>TRUE</code>, the result is no longer of class <code>design</code>, and all special design attributes are dropped;
otherwise, the design attributes are adjusted to reflect the subsetting result</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_drop">drop</code></td>
<td>
<p> logical that controls dropping of dimensions in the Extract function for 
data.frame objects, which is called by the method for class <code>design</code></p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_show.order">show.order</code></td>
<td>
 <p><code>NULL</code> or logical; if <code>TRUE</code>, the design is printed with run order information; 
default is <code>TRUE</code> for design types for which this information is helpful (see code for detail), <code>FALSE</code> otherwise </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_group.print">group.print</code></td>
<td>
<p> logical, default <code>TRUE</code>; 
if <code>TRUE</code>, structured designs (blocked and split-plot designs) 
are printed with intermediate lines at structure breaks; 
if <code>FALSE</code>, the designs are simply printed as data frames.</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_std.order">std.order</code></td>
<td>
<p> logical, default <code>FALSE</code>; 
if <code>TRUE</code>, the design is printed in standard order rather 
than in the randomized order.</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_...">...</code></td>
<td>
<p> further arguments to functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+aggregate">aggregate</a></code>, 
<code><a href="stats.html#topic+contrasts">contrasts</a></code> </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_object">object</code></td>
<td>
<p> data frame of S3 class <code>design</code>, like argument <code>design</code> </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_brief">brief</code></td>
<td>
 <p><code>NULL</code> or logical; <code>TRUE</code> requests a printout of the 
design at the end of the <code>summary</code> output, <code>FALSE</code> suppresses such a printout. 
If <code>brief = NULL</code> (the default), the <code>summary</code> method prints 
the design <code>object</code> if it has up to 40 rows and up to 20 columns. </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_quote">quote</code></td>
<td>
<p> logical; <code>TRUE</code> requests quoting strings in print parts of the output, 
<code>FALSE</code> suppresses quotes.</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_by">by</code></td>
<td>
<p>by variables for the <code><a href="stats.html#topic+aggregate">data frame method</a></code> 
of function <code>aggregate</code>, 
needed if <code>x</code> is not a wide design for which the special 
method for class <code><a href="#topic+design">design</a></code> is intended</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_response">response</code></td>
<td>
<p>used for wide format designs only; <br />
if <code>NULL</code>, all responses of the design are aggregated; 
specify names of selected responses (column names of the <code>responselist</code> element 
of the <code>design.info</code> attribute) for restricting the responses that are treated</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_fun">FUN</code></td>
<td>
<p>a function to be used for aggregation, the default is <code>"mean"</code>;<br />
can be used like the <code>FUN</code> argument to <code><a href="base.html#topic+apply">apply</a></code> </p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_postfix">postfix</code></td>
<td>
<p><code>NULL</code> implies postfixing the response name with (a character version of) 
<code>FUN</code>; a character string can be given instead for a user-defined postfix</p>
</td></tr>
<tr><td><code id="Methods+2B20for+2B20class+2B20design+2B20objects_+3A_replace">replace</code></td>
<td>
<p>logical that decides whether an existing variable of the given name 
is to be replaced; the default is <code>TRUE</code> for convenience reasons. 
WARNING: If custom variables other than aggregation variables are added to wide format designs, 
it is recommended to use variables names that are not likely to be generated 
by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Items of class <code><a href="#topic+design">design</a></code> are data frames with attributes,
that have been created for conducting experiments. Apart from the methods
documented here, separate files document the methods <code><a href="#topic+formula.design">formula.design</a></code>
and <code><a href="#topic+plot.design">plot.design</a></code>.
</p>
<p>The extractor method subsets the design, taking care of the attributes accordingly (cf. the value section). 
Subsetting can also handle replication in a limited way, although this is not first 
choice. Repeated measurements can be added to a design that has no proper replications, 
and proper replications can be added to a design that has no repeated measurements. 
</p>
<p>The method for <code>print</code> displays the design. Per default, the design is 
printed in the actual run order, and run order information is shown for designs 
with special structure (blocked, replicated). Optionally, the design can be 
printed in standard order, which may be useful for comparing to other designs 
or for getting a clearer idea about the structure of smaller designs. 
</p>
<p>The method for <code>summary</code> provides design-specific information - 
some further development may still be expected. If a standard data frame summary 
is desired, explicitly use function <code>summary.data.frame</code> instead of <code>summary</code>.
</p>
<p>The method for <code>aggregate</code> provides aggregation utilities for wide format designs and 
links back to the method for data frames for designs that are not of wide format. 
If a wide format design is to be treated with the <code>aggregate</code> method for data frames, 
<code><a href="stats.html#topic+aggregate">aggregate.data.frame</a></code> must be used explicitly. 
This method calculates a mean, standard deviation or SN ratio from the individual responses 
(which can be repeated measurements or outer array runs from a Taguchi parameter design).  
</p>


<h3>Value</h3>

<table>
<tr><td><code>extractor</code></td>
<td>
<p>The extractor function returns a class design object with modified attributes 
or a data frame without special attributes, depending on the situation. 
</p>
<p>If <code>j</code> is given, the function always returns a data frame without 
special attributes, even if <code>drop.attr=FALSE</code> or <code>j=1:ncol(design)</code>.<br />
If only <code>i</code> is given, 
the default option <code>drop.attr=TRUE</code> also returns a 
data frame without attributes.<br />
Exception: Even for <code>drop.attr=TRUE</code>, if <code>i</code> is a permutation of 
the row numbers or a logical vector with all elements <code>TRUE</code>, 
the attributes are preserved, and attributes <code>run.order</code> 
and <code>desnum</code> are reordered along with the design, if necessary.<br />
If <code>drop.attr=FALSE</code> and <code>j</code> is empty, 
the function returns an object of class design with rows of attributes <code>run.order</code> 
and <code>desnum</code> selected in line with those of the design itself. 
In this case, the new <code>design.info</code> attribute is a list with entries 
</p>

<dl>
<dt>type</dt><dd><p>resolving to &ldquo;subset of design&rdquo;, </p>
</dd>
<dt>subset.rows</dt><dd><p> a numeric or logical vector with the selected rows, and</p>
</dd>
<dt>orig.design.info</dt><dd><p> which contains the original <code>design.info</code> attribute.</p>
</dd>
</dl>
</td></tr>
</table>
<p>The <code>print</code> and <code>summary</code> methods are called for their side effects and return <code>NULL</code>.
</p>
<p>The method for <code>aggregate</code> returns the input wide format design with one or more 
additional response columns and the <code>response.names</code> element of the 
<code>design.info</code> attribute changed to only include the newly-added responses. 
</p>


<h3>Note</h3>

<p> The package is currently subject to intensive development; most key functionality is now included. 
Some changes to input and output structures may still occur.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also the following functions known to produce objects of class 
<code>design</code>: <code>FrF2</code>, <code>pb</code>, <code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code>.<br />
See also the following further methods for class <code>design</code> objects: 
<code><a href="#topic+formula.design">formula.design</a></code>, <code><a href="#topic+lm.design">lm.design</a></code>, <code><a href="#topic+plot.design">plot.design</a></code>.<br />
Function <code><a href="graphics.html#topic+plot.design">plot.design</a></code> from package graphics works on 
data frames with R factors as explanatory variables, if a numeric response is available; 
this function is invoked by method <code><a href="#topic+plot.design">plot.design</a></code> from this package, 
where appropriate.</p>


<h3>Examples</h3>

<pre><code class='language-R'>oa12 &lt;- oa.design(nlevels=c(2,2,6))
#### Examples for extractor function
  ## subsetting to half the runs drops all attributes per default
  oa12[1:6,]
  ## keep the attributes (usually not reasonable, but ...)
  oa12[1:6, drop.attr=FALSE]
  ## reshuffling a design
  ## (re-)randomize
  oa12[sample(12),]
  ## add repeated measurements
  oa12[rep(1:12,each=3),]
  ## add a proper replication 
  ## (does not work for blocked designs)
  oa12[c(sample(12),sample(12)),]
  ## subsetting and rbinding to loose also contrasts of factors
  str(rbind(oa12[1:2,],oa12[3:12]))
  ## keeping all non-design-related attributes like the contrasts
  str(undesign(oa12))

#### Examples print and summary
  ## rename factors and relabel levels of first two factors
  namen &lt;- c(rep(list(c("current","new")),2),list(""))
  names(namen) &lt;- c("First.Factor", "Second.Factor", "Third.Factor")
  factor.names(oa12) &lt;- namen
  oa12   ### printed with the print method!

  ## add a few variables to oa12
  responses &lt;- cbind(temp=sample(23:34),y1=rexp(12),y2=runif(12))
  oa12 &lt;- add.response(oa12, responses)
  response.names(oa12)
  ## temp (for temperature) is not meant to be a response 
  ## --&gt; drop it from responselist but not from data
  response.names(oa12) &lt;- c("y1","y2")

## print design
  oa12
## look at design-specific summary
  summary(oa12)
## look at data frame style summary instead
  summary.data.frame(oa12)
  
## aggregation examples
  plan &lt;- oa.design(nlevels=c(2,6,2), replications=2, repeat.only=TRUE)
  y &lt;- rnorm(24)
  z &lt;- rexp(24)
  plan &lt;- add.response(plan, cbind(y=y,z=z))
  plan &lt;- reptowide(plan)
  plan.mean &lt;- aggregate(plan)
  plan.mean
  aggregate(plan, response="z")
  aggregate(plan, FUN=sd)
  aggregate(plan, FUN = function(obj) max(obj) - min(obj), postfix="range")
  ## several aggregates: add standard deviations to plan with means
  plan.mean.sd &lt;- aggregate(plan.mean, FUN=sd)
  plan.mean.sd
  response.names(plan.mean.sd)
  ## change response.names element of design.info back to y.mean and z.mean
  ## may be needed for automatic analysis routines that have not been 
  ## created yet
  plan.mean.sd &lt;- aggregate(plan.mean.sd, FUN=mean)
  plan.mean.sd
  response.names(plan.mean.sd)
</code></pre>

<hr>
<h2 id='oa_feasible'>Function to Check Whether an Array of Specified Strength Might Exist
</h2><span id='topic+oa_feasible'></span>

<h3>Description</h3>

<p>The function checks necessary conditions for the existence of an array of specified strength
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oa_feasible(nruns, nlevels, strength = 2, verbose=TRUE, returnbound=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oa_feasible_+3A_nruns">nruns</code></td>
<td>
<p>positive integer, number of rows</p>
</td></tr>
<tr><td><code id="oa_feasible_+3A_nlevels">nlevels</code></td>
<td>
<p>vector of positive integers: its length determines the number of columns, the elements determine the numbers of levels for each column</p>
</td></tr>
<tr><td><code id="oa_feasible_+3A_strength">strength</code></td>
<td>
<p>positive integer (default 2), not larger than the length of <code>nlevels</code> requested strength of array; 1+strength is the resolution</p>
</td></tr>
<tr><td><code id="oa_feasible_+3A_verbose">verbose</code></td>
<td>
<p>logical; if TRUE, reason for outcome is printed</p>
</td></tr>
<tr><td><code id="oa_feasible_+3A_returnbound">returnbound</code></td>
<td>
<p>logical; if TRUE, the function returns a lower bound for the number of runs needed instead of a logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses several known bounds and necessary divisibility requirements on <code>nruns</code> for checking <em>potential</em> feasibility of an array of the requested strength. It is checked that <code>nruns</code> is a multiple of the LCM of the run sizes of unreplicated full factorials of all sets of <code>strength</code> factors and that Rao's bound is fulfilled (the simplest one for strength 2 arrays being that <code>nruns</code> is larger than the sum of the main effect degrees of freedom; formulae available in Hedayat et al. 1999 Theorem 2.1 for pure levels and Diestelkamp 2004 Theorem 3.1 for mixed levels). For pure level designs, the Bush bounds and Bose/Bush bounds are implemented (Hedayat et al., Theorems 2.8, 2.11 and 2.19).
Furthermore, Bierbrauer's bound (Diestelkamp 2004 Theorems 2.1 and 2.2) is implemented for pure and mixed level designs; note that the mixed level formula has been applied for large <code>strength</code> values only, because the proof of Diestelkamp is valid only for these (contrary to what is claimed in the paper). For pure 2-level-designs, the bound from Bierbrauer et al. (1999) is also implemented. All these are necessary but not a sufficient conditions for the existence of an orthogonal array of the requested strength.
</p>
<p>The implemented bounds have been verified against selected scenarii from Tables 12.1 to 12.3 of Hedayat, Sloane and Stufken 1999. These tables detect further infeasibilities, since they incorporate detailed research results for specific scenarii, contrary to this function which only checks straightforward explicit bounds. Another resource for checking feasibility of symmetric OAs (i.e. OAs with the same number of levels for all factors) is the website <a href="http://mint.sbg.ac.at/">http://mint.sbg.ac.at/</a>.
</p>


<h3>Value</h3>

<p>A logical or an integer number.<br /> 
For <code>returnbound=FALSE</code> (default), a logical is returned: if FALSE, an OA is infeasible; if TRUE, an OA <em>might</em> be feasible.<br />
For <code>returnbound=TRUE</code>, an integer is returned: a <em>lower bound</em> for the number of runs needed for an OA with the requested strength.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Bierbrauer, J., Gopalakrishnan, K. and Stinson, D.R. (1999). 
Orthogonal Arrays, Resilient Functions, Error Correcting Codes and Linear Programming Bounds. 
Working paper (expanded and revised version of a published extended abstract of the same authors). 
<a href="https://pages.mtu.edu/~jbierbra/">https://pages.mtu.edu/~jbierbra/</a>.
</p>
<p>Diestelkamp, W. (2004). Parameter inequalities for orthogonal arrays with mixed levels.
<em>Designs, Codes and Cryptography</em> <b>33</b>, 187-197.
</p>
<p>Hedayat, S., Sloane, N.J.A. and Stufken, J. (1999). Orthogonal Arrays. Springer, New York.
</p>


<h3>See Also</h3>

<p>See also function <code><a href="#topic+show.oas">show.oas</a></code> of package <span class="pkg">DoE.base</span> for orthogonal arrays catalogued in that package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## strength 2 equal to resolution 3 is the default
## pure level examples (function checks criteria in the order listed here)
oa_feasible(51, rep(5,7))
   ## nruns not divisible by 5^2
oa_feasible(1024, rep(2,14), strength=7)
   ## violates Bierbrauer et al.s bound for 2-level
oa_feasible(6561, rep(3,11), strength=8)
   ## violates Bierbrauer's bound for pure level
oa_feasible(25, rep(5,7))
   ## violates Rao's bound for pure level
oa_feasible(256,rep(4,7), 4)
   ## violates Bush bound (checked for pure level only)
oa_feasible(54, rep(3,26))
   ## violates Bose/Bush bound (checked for pure level only)
oa_feasible(25, rep(5, 12), strength = 1)
   ## feasible; but do not try to optimize (5^12 integer variables!!!)
oa_feasible(243, rep(3,11), strength = 4)
   ## strength 4 design that strictly attains the Rao bound for pure level

## mixed level examples (function checks criteria in the order listed here)
oa_feasible(25, c(rep(5,6),4))
   ## too few df for main effects (special case of Rao's bound)
oa_feasible(100, c(rep(5,6),4), 5)
   ## violates Diestelkamps mixed level version of Bierbrauer's bound
               ## (also violates Rao's bound, but this is checked earlier)
oa_feasible(100, c(rep(5,7),4), 3)
   ## violates Rao's bound for mixed level, strength 3
oa_feasible(100, c(rep(5,7),4), 4)
   ## violates Rao's bound for mixed level, even strength
oa_feasible(100, c(rep(5,7),4), 5)
   ## violates Rao's bound for mixed level, general odd strength
oa_feasible(50, c(2,rep(5,12)))
   ## does not violate any bound, although the pure level portion
   ## violates the Bose/Bush bound
   ## for almost pure level: also check pure level portions!

oa_feasible(24, c(2,4,3,4))
   ## violates divisibility by the LCM of all products of pairs
oa_feasible(48, c(2,4,3,4,2))
   ## TRUE and indeed feasible
</code></pre>

<hr>
<h2 id='oa.design'> Function for accessing orthogonal arrays </h2><span id='topic+oa.design'></span><span id='topic+origin'></span><span id='topic+oa'></span>

<h3>Description</h3>

<p>Function for accessing orthogonal arrays,
allowing limited optimal allocation of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oa.design(ID=NULL, nruns=NULL, nfactors=NULL, nlevels=NULL,
      factor.names = if (!is.null(nfactors)) {
        if (nfactors &lt;= 50) Letters[1:nfactors]
           else paste("F", 1:nfactors, sep = "")}
        else NULL,
        columns="order",
        replications=1, repeat.only=FALSE,
        randomize=TRUE, seed=NULL, min.residual.df=0, levordold = FALSE)
origin(ID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oa.design_+3A_id">ID</code></td>
<td>
<p> orthogonal array to be used; must be given as the name without quotes
(e.g. <code>L12.2.2.6.1</code>);
available names can be looked at using function <code><a href="#topic+show.oas">show.oas</a></code>; 
furthermore, <code>L18</code>, <code>L36</code>
and <code>L54</code> for the respective Taguchi arrays can be used.<br />
Users can also specify names of their own designs here (cf. details).<br />
<code>ID</code> must be of class <code>oa</code>.
If omitted, <code>ID</code> is automatically determined based on <code>nlevels</code>
or <code>factor.names</code>. </p>
</td></tr>
<tr><td><code id="oa.design_+3A_nruns">nruns</code></td>
<td>
<p> minimum number of runs to be used,
can be omitted if obvious from <code>ID</code> or if
the smallest possible array is to be found </p>
</td></tr>
<tr><td><code id="oa.design_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors;
only needed if <code>nlevels</code> is a single number and
<code>factor.names</code> is omitted;
can otherwise be determined from length of <code>factor.names</code>,
<code>nlevels</code> or <code>column</code> </p>
</td></tr>
<tr><td><code id="oa.design_+3A_nlevels">nlevels</code></td>
<td>
<p> number(s) of levels, vector with <code>nfactors</code> entries or single number;
can be omitted, if obvious from <code>factor.names</code> or from <code>ID</code>,<br />
or if <code>ID</code> and <code>columns</code> are given <br />
or if all columns of <code>ID</code> are to be used 
with default factor names and levels;<br />
can be a single number if <code>nfactors</code> is known directly or as length of
<code>factor.names</code> </p>
</td></tr>
<tr><td><code id="oa.design_+3A_factor.names">factor.names</code></td>
<td>
<p> a character vector of <code>nfactors</code> factor names
or a list with <code>nfactors</code> elements;<br />
if the list is named, list names represent factor names, otherwise default factor names are used;<br />
the elements of the list are <br />
EITHER vectors of appropriate length (corresponding to <code>nlevels</code>)
with factor levels for the respective factor<br />
OR empty strings;<br />
Default factor names are the first elements of the character vector <code><a href="#topic+Letters">Letters</a></code>,
or the factors position numbers preceded by capital F in case of more than 50 factors.
Default factor levels are the numbers from 1 to the number of levels for each factor.</p>
</td></tr>
<tr><td><code id="oa.design_+3A_columns">columns</code></td>
<td>

<p>EITHER<br />
a vector of column numbers referring to columns of design <code>ID</code>,
assigning a specific column of the array to each factor;<br />
this can only be specified, if <code>ID</code> is also given;<br />
OR<br />
a string that defines the degree of optimization requested
in terms of column allocation (cf. section &ldquo;Details&rdquo;):
choices are <code>"order"</code>, <code>"min3"</code>, <code>"min34"</code>,
<code>"min3.rela"</code>, <code>"min34.rela"</code>, <code>"minRPFT"</code>
or <code>"minRelProjAberr"</code>.<br />
For resource reasons, the default is <code>"order"</code>, but smaller designs
can sometimes be substantially improved with other choices.
Cf. the &ldquo;Details&rdquo; section for the
meaning of the character string specifications for <code>columns.</code>
Column optimization can be computationally intensive. If it cannot
be accomplished with the given ressources, a warning is issued, and
an unoptimized design is returned.<br />
Some of the optimization methods have just been proposed, and there is
little experience with them. It is strongly recommended to always check
the properties of the design w.r.t. suitability for the planned experiment
BEFORE starting expensive investments.</p>
</td></tr>
<tr><td><code id="oa.design_+3A_replications">replications</code></td>
<td>
<p> the number of replications of the array,
the setting of <code>repeat.only</code> determines, whether these are real replications
or repeated measurements only. Note that replications are not considered for
accomodation of <code>min.residual.df</code> residual degrees of freedom,
unless a full factorial is used.</p>
</td></tr>
<tr><td><code id="oa.design_+3A_repeat.only">repeat.only</code></td>
<td>
<p> default <code>FALSE</code> implies real replications,
<code>TRUE</code> implies repeated measurements only </p>
</td></tr>
<tr><td><code id="oa.design_+3A_randomize">randomize</code></td>
<td>
<p> logical indicating whether the run order is to be randomized ? </p>
</td></tr>
<tr><td><code id="oa.design_+3A_seed">seed</code></td>
<td>
<p> integer seed for the random number generator <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>oa.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="oa.design_+3A_min.residual.df">min.residual.df</code></td>
<td>
<p> minimum number of residual degrees of freedom;<br />
Note: function <code>oa.design</code> does not count replications specified with option
<code>replications</code> in determining residual degrees of freedom for <code>min.resid.df</code>. </p>
</td></tr>
<tr><td><code id="oa.design_+3A_levordold">levordold</code></td>
<td>
<p> logical indicating whether or not old (=pre version 0.27)
level ordering should be used;<br />
defaults to <code>FALSE</code>, which implies that levels are ordered as indicated
in <code>factor.names</code>;<br /> in the old ordering, levels were automatically reordered
by the <code>as.factor</code> function, which is usually undesirable, but may be desired
for reproducing designs created with earlier versions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">DoE.base</span> is described in Groemping (2018). 
The paper also has detailed material on function <code>oa.design</code>.
</p>
<p>Function <code>oa.design</code> assigns factors to the columns of orthogonal arrays that are
available within package <span class="pkg">DoE.base</span> or are provided by the user.
The available arrays and their properties are listed in the
data frame <code>oacat</code> and can be systematically searched for using function <code><a href="#topic+show.oas">show.oas</a></code>.
The design names also indicate the number of runs and the numbers of factors
for each number of levels, e.g. <code>L18.3.6.6.1</code> is an 18 run design with six factors in 3 levels
(<code>3.6</code>) and one factor in 6 levels (<code>6.1</code>).
</p>
<p><code>oa</code> is the S3 class used for orthogonal arrays. Objects of class <code>oa</code> should at least have
the attribute <code>origin</code>, an attribute <code>comment</code> should be used for additional information.
</p>
<p>Users can define their own orthogonal arrays and hand them to <code>oa.design</code> with parameter <code>ID</code>.<br />
Requirements for the arrays: <br />
</p>

<ul>
<li><p> Factor levels must be coded as numbers from 1 to number of levels.
</p>
</li>
<li><p> The array must be of classes <code>oa</code> and <code>matrix</code><br />
(If your array is a matrix named <code>foo</code>, you can simply assign it class <code>oa</code> by
the command <code>class(foo) &lt;- c("oa","matrix")</code>, see also last example.)
</p>
</li>
<li><p> The array should have an attribute <code>origin</code>.
</p>
</li>
<li><p> The array can have an attribute <code>comment</code>; <br />
this should be used for mentioning specific properties, e.g.
for the <code>L18.2.1.3.7</code> that the interaction of the first two factors
can be estimated.
</p>
</li></ul>

<p>Users are encouraged to send additional arrays to the package maintainer.
The requirements for these are the same as listed above, with attribute <code>origin</code>
being a MUST in this case. (See the last example for how to assign an attribute.)<br />
For relatively small important applications, creation of a tailor-made array of class <code>oa</code> can 
be attempted with package <span class="pkg">DoE.MIParray</span>, which uses mixed integer optimization for creating 
a design from scratch (see Groemping and Fontana 2019 for the algorithm behind that approach).<br /> 
</p>
<p>The data frame <code><a href="#topic+oacat">oacat</a></code> lists the orthogonal arrays from Warren Kuhfelds
collection of &ldquo;parent&rdquo; and &ldquo;child&rdquo; arrays. The parent arrays, 
plus a few additional arrays, are directly exported from the package namespace. 
The child arrays from Kuhfelds collection can be constructed from these, using
the replacement instructions provided in the variable <code>lineage</code> of <code>oacat</code>.    
The last example below indicates how
a child array can be created manually, and compares this to the automatically created array.<br />
(A lot more than just the child arrays could be obtained from these arrays
by implementing a functionality similar to the market research macros available in SAS; presumably,
this topic will not be addressed soon, as it will involve a substantial amount of work.)
</p>
<p>Furthermore, there are stronger arrays 
(at least resolution IV) in the catalogue <code><a href="#topic+oacat3">oacat3</a></code>. Since version 1.1, 
function <code>oa.design</code> uses the stronger arrays, where possible. 
</p>
<p>If no specific orthogonal array is specified and function <code>oa.design</code> does not
find an orthogonal array that meets the specified requirements,
<code>oa.design</code> returns a full factorial, replicated for enough residual degrees of freedom, if necessary.
If <code>oa.design</code> has not found an array smaller than the full factorial, it is
absolutely possibly that a smaller array does exist nevertheless. It may be worth
while checking with oacat whether an appropriate smaller array can be found by
combining some of the parent arrays listed there (looking for a design with a few
factors in 5 runs, you may e.g. call <code>oacat[oacat$n5&gt;0,]$name</code> in order to see the
names of more promising candidate arrays for combination, or you may also want to look
up arrays with <code>n25&gt;0</code> subsequently.
</p>
<p>With version 0.9-18 of the package,
the possibility for an automatic allocation of columns for improved design
performance was implemented. With version 0.23, this approach has been sped
up and extended to properly cover relative projection aberration according to
Groemping (2011) with and without step (b) (see below) (the previous choice
<code>"maxGR.min34"</code> was modified and renamed to <code>"minRelProjAberr"</code>).<br />
Because of performance reasons, and because of a lack of a clear best default,
optimum column allocation is not switched on per default.
However, with the default column order from left to right,
the package always issues a warning to remind users that an automatic unoptimized design
can be quite far from ideal.
If optimization is activated, the first step is selection of an array,
either explicitly by the user (option <code>ID</code>) or automatically (unoptimized)
according to the required combination of factors. Within that array, the following
choices for the <code>column</code> option are on offer:<br />
</p>

<dl>
<dt>&quot;order&quot;</dt><dd><p>the default choice; allocates factors from left to right, which
is what most software does (but what is not necessarily good, see also the example section)</p>
</dd>
<dt><code>"min3"</code></dt><dd><p><b>recommended</b>, if <code>"min34"</code> is not affordable; 
aliasing between main effects and 2-factor
interactions is kept to a minimal degree,
minimizing the number of generalized words of length 3 according to Xu and Wu (2001)</p>
</dd>
<dt>&quot;min3.rela&quot;</dt><dd><p>the same approach is taken, but with
<em>relative</em> number of generalized words according to Groemping (2011)</p>
</dd>
<dt>&quot;min34&quot;</dt><dd><p><b>recommended</b>, if affordable; 
beware the time demand; this requests
that the number of words of generalized length 4 is also minimized.</p>
</dd>
<dt>&quot;min34.rela&quot;</dt><dd><p>again takes the same approach, but with
<em>relative</em> number of generalized words according to Groemping (2011)</p>
</dd>
<dt>&quot;minRPFT&quot;</dt><dd><p>minimizes the relative projection frequency table, applying the
approach according to Groemping (2011) without step (b) (see next entry).</p>
</dd>
<dt>&quot;minRelProjAberr&quot;</dt><dd><p>applies minimum relative projection aberration
according to Groemping (2011)
((a): maximize generalized resolution,
(b): minimize total relative number of shortest words, (c) rank designs
according to relative projection frequency table (obtainable with P3.3 or P4.4, depending on resolution)
and (d) resolve ties by looking at absolute number of length 4 words in case of resolution III).</p>
</dd>
</dl>

<p>WARNING: Usually, it is recommended to investigate the properties of a design automatically
created by function <code>oa.design</code> before starting experimentation.
While all designs can estimate main effects <em>in the absence of interactions</em>,
the presence of interactions may render some designs useless or even dangerous.
Deliberate choice of columns different from the default may improve a design
(see example section)!
</p>
<p>Mathematical comment on the expansion example:
There are 720 different ways to expand the unique <code>L18.3.6.6.1</code>
into an <code>L18.2.1.3.7</code>, depending on which row of the replacement design
<code>nest.des</code> is assigned to which level of the 6 level factor; 
for qualitative factors, 
60 of these are potentially non-isomorphic (divide 720 by the 2 * 3! ways 
of permuting levels within a factor; there are
more possibly different arrays for quantitative 3 level factors, since arbitrary
relabelling of the levels is no longer isomorphic).
According to Eric Schoen (personal communication), for this particular case, 
all the resulting children
are isomorphic to each other and are also isomorphic to the Taguchi L18.
To see isomorphism of two designs is not easy; in the example, <code>nest.des</code>
has been prepared such that it is easy to see isomorphism of the resulting
child to the Taguchi <code>L18</code>: <code>L18</code> is reproduced by
assigning the first row of <code>nest.des</code> to level 1 etc.,
except for a swap of columns <code>G</code> and <code>H</code>.
</p>


<h3>Value</h3>

<p><code>oa.design</code> returns a data frame of S3 class <code><a href="#topic+design">design</a></code>
with attributes attached.
</p>
<p>In the data frame itself, the experimental factors are all stored as R factors. <br />
For factors with 2 levels, <code><a href="#topic+contr.FrF2">contr.FrF2</a></code> contrasts (-1 / +1) are used. <br />
For factors with more than 2 numerical levels, polynomial contrasts are used
(i.e. analyses will per default use orthogonal polynomials). <br />
For factors with more than 2 categorical levels, the default contrasts are used.<br />
Future versions will most likely allow more user control about the type of
contrasts to be used.
</p>
<p>The <code>desnum</code> and <code>run.order</code> attributes of class <code><a href="#topic+design">design</a></code> are
as usual. In the <code>design.info</code> attribute, the following elements are specific for
this type of designs:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>is <code>oa</code> (unless no special orthogonal array is found, in which case
a full factorial is created instead, cf. <code><a href="#topic+fac.design">fac.design</a></code> for its <code>design.info</code> attribute),</p>
</td></tr>
<tr><td><code>nlevels</code></td>
<td>
<p>vector containing the number of levels for each factor</p>
</td></tr>
<tr><td><code>generating.oa</code></td>
<td>
<p>contains information on the generating orthogonal array,</p>
</td></tr>
<tr><td><code>selected.columns</code></td>
<td>
<p>contains information, which column of the orthogonal array underlies which factor,</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>contains the respective attribute of the orthogonal array,</p>
</td></tr>
<tr><td><code>comment</code></td>
<td>
<p>contains the respective attribute of the orthogonal array,</p>
</td></tr>
<tr><td><code>residual.df</code></td>
<td>
<p>contains the requested residual degrees of freedom for a main effects model.</p>
</td></tr>
</table>
<p>Other information is generic, like documented for class <code><a href="#topic+design">design</a></code>.
</p>
<p>Function <code>origin</code> returns the origin attribute of the orthogonal array <code>ID</code>,
functions <code><a href="base.html#topic+comment">comment</a></code> and <code>"comment&lt;-"</code> from package <span class="pkg">base</span>
return and set the comment attribute.
</p>


<h3>Warning</h3>

<p>Since version 1.1 of the package, strength 3 arrays are automatically used, if available. 
This changes the behavior of function <code>oa.design</code> for situations for requests with a 
combination of <code>nruns</code> and <code>nlevels</code> for which a strength 3 array exists in <code>oacat3</code>. 
If the old behavior is required for reproducing a previously-created array, it is 
possible to set <code>oacat3</code> to <code>NULL</code> by the command <code>assignInNamespace("oacat3", NULL, pos="package:DoE.base")</code>; 
this temporary replacement of <code>oacat3</code> with <code>NULL</code> remains in effect 
for the current R session; detaching it (with namespace unloading) and reloading is possible but can also go wrong; 
therefore, it is recommended to only use the above technique if you are prepared to restart the 
R session before using the original version of <code>oacat3</code>.
</p>
<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under development. Suggestions and bug reports are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Groemping, U. (2011). Relative projection frequency tables for orthogonal arrays.
Report 1/2011, <em>Reports in Mathematics, Physics and Chemistry</em> <a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>,
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Groemping, U. (2018). R Package DoE.base for Factorial Designs. <em>Journal of Statistical Software</em> <b>85</b>(5), 1&ndash;41.
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York.
</p>
<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute <a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>
<p>Schoen, E. (2009). All orthogonal arrays with 18 runs. <em>Quality and Reliability Engineering International</em> <b>25</b>, 467&ndash;480.
</p>
<p>Xu, H.-Q. and Wu, C.F.J. (2001). Generalized minimum aberration for asymmetrical
fractional factorial designs. <em>Annals of Statistics</em> <b>29</b>, 1066&ndash;1077.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## smallest available array for 6 factors with 3 levels each
  oa.design(nfactors=6, nlevels=3)
  ## level combination for which only a full factorial is (currently) found
  oa.design(nlevels=c(4,3,3,2))
  ## array requested via factor.names
  oa.design(factor.names=list(one=c("a","b","c"), two=c(125,275),
     three=c("old","new"), four=c(-1,1), five=c("min","medium","max")))
  ## array requested via character factor.names and nlevels
    ## (with a little German lesson for one two three four five)
  oa.design(factor.names=c("eins","zwei","drei","vier","fuenf"), nlevels=c(2,2,2,3,7))
  ## array requested via explicit name, Taguchi L18
  oa.design(ID=L18)
  ## array requested via explicit name, with column selection
  oa.design(ID=L18.3.6.6.1,columns=c(2,3,7))
  ## array requested with nruns, not very reasonable
  oa.design(nruns=12, nfactors=3, nlevels=2)
  ## array requested with min.residual.df
  oa.design(nfactors=3, nlevels=2, min.residual.df=12)

  ## examples showing alias structures and their improvment with option columns
  plan &lt;- oa.design(nfactors=6,nlevels=3)
  plan
     ## generalized word length pattern
     length3(plan)
     ## length3 (first element of GWP) can be slightly improved by columns="min3"
     plan &lt;- oa.design(nfactors=6,nlevels=3,columns="min3")
     summary(plan)  ## the first 3-level column of the array is not used
     length3(plan)
  plan &lt;- oa.design(nlevels=c(2,2,2,6))
     length3(plan)
  plan.opt &lt;- oa.design(nlevels=c(2,2,2,6),columns="min3") ## substantial improvement
     length3(plan.opt)
     length4(plan.opt)
  ## visualize practical relevance of improvement:
     ## for optimal plan, all 3-dimensional projections are full factorials
  plot(plan, select=1:3)
  plot(plan, select=c(1,2,4))
  plot(plan, select=c(1,3,4))
  plot(plan, select=2:4)
  plot(plan.opt, select=1:3)
  plot(plan.opt, select=c(1,2,4))
  plot(plan.opt, select=c(1,3,4))
  plot(plan.opt, select=2:4)


  ## The last example:
  ## generate an orthogonal array equivalent to Taguchi's L18
  ## by combining L18.3.6.6.1 with a full factorial in 2 and 3 levels
  
  show.oas(nruns=18, parents.only=FALSE)
       ## lineage entry leads the way:
           ## start from L18.3.6.6.1
           ## insert L6.2.1.3.1 for the 6 level factor
  ## prepare the parent
   parent.des &lt;- L18.3.6.6.1
   colnames(parent.des) &lt;- c(Letters[3:9])
       ## new columns will become A and B
  ## 6-level design can be created by fac.design or expand.grid or cbind
   nest.des &lt;- as.matrix(expand.grid(1:3,1:2))[c(1:3,5,6,4),c(2,1)]
        ## want first column to change most slowly
        ## want resulting design to be easily transformable into Taguchi L18
        ## see mathematical comments in section Details
   colnames(nest.des) &lt;- c("A","B")
  ## do the expansion (see mathematical comments in section Details)
  ## using function expansive.replace
  L18.2.1.3.7.manual &lt;- expansive.replace(parent.des, nest.des)[,c(7:8,1:6)]
  L18.2.1.3.7.manual &lt;- L18.2.1.3.7.manual[ord(L18.2.1.3.7.manual),]  ## sort array
      rownames(L18.2.1.3.7.manual) &lt;- 1:18
        ## (ordering is not necessary, just **tidy**)
  ## prepare for using it with function oa.design
        ## note: function expansive.replace creates a matrix of class "oa"
        ## rearranging the columns removed that class and makes it necessary 
        ##    to add the class again for using the array in DoE.base 
  attr(L18.2.1.3.7.manual, "origin") &lt;-
      c(show.oas(name="L18.2.1.3.7", parents.only=FALSE,show=0)$lineage,
        "unconventional order")
  class(L18.2.1.3.7.manual) &lt;- c("oa", "matrix")
  comment(L18.2.1.3.7.manual) &lt;- "Interaction of first two factors estimable"
     ## indicates that first two factors are full factorial from 6-level factor
  origin(L18.2.1.3.7.manual)
  comment(L18.2.1.3.7.manual)
  L18  ## Taguchi array
  L18.2.1.3.7.manual  ## manually expanded array
  oa.design(L18.2.1.3.7, randomize=FALSE)
        ## automatically expanded array
  P3.3(L18.2.1.3.7.manual)  ## length 3 pattern of 3 factor projections
                  ## this also identifies the array as isomorphic to L18
                  ## according to Schoen 2009
  ## the array can now be used in oa.design, like the built-in arrays
  oa.design(ID=L18.2.1.3.7.manual,nfactors=7,nlevels=3)
</code></pre>

<hr>
<h2 id='oacat'>
Data Frames That List Available Orthogonal Arrays
</h2><span id='topic+oacat'></span><span id='topic+oacat3'></span>

<h3>Description</h3>

<p>These data frames hold the lists of available orthogonal arrays, 
except for a few structurally equivalent additional arrays known 
as Taguchi arrays (L18, L36, L54). Arrays in  
in oacat are mostly from the Kuhfeld collection, 
those in oacat3 from some other sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oacat
oacat3
</code></pre>


<h3>Details</h3>

<p>The data frames hold a list of orthogonal arrays, as described in Section &ldquo;value&rdquo;. 
Inspection of these arrays can be most easily done with function <code><a href="#topic+show.oas">show.oas</a></code>. 
Some of the listed arrays are directly accessible through their names (&ldquo;parent&rdquo; arrays, 
also listed under <code><a href="#topic+arrays">arrays</a></code>) or 
are full factorials the construction of which is obvious. Others 
can be constructed as &ldquo;child&rdquo; arrays from the parent and full factorial 
arrays, using a so-called <code>lineage</code> which is also included as a column 
in data frame <code>oacat</code>. Most of the listed arrays have been taken 
from Kuhfeld 2009. Exceptions: The three arrays <code>L128.2.15.8.1</code>, 
<code>L256.2.19</code> and <code>L2048.2.63</code>) have been taken from Mee 2009; these 
are irregular resolution IV or V arrays for which all main effects can be 
orthogonally estimated even in the presence of interactions, or even all 2fis 
can be orthogonally estimated, provided there are no higher order effects.
</p>
<p>Note that most of the arrays in <code>oacat</code>, per default, are guaranteed to 
orthogonally estimate 
all main effects, <b>provided all higher order effects are negligible</b> 
(again, the Mee arrays are an exception). This can be 
a very severe limitation, of course, and arbitrary strong biases can distort the 
estimates even of main effects, if this assumption is violated. 
It is therefore strongly recommended to inspect 
the quality of an orthogonal array quite closely before deciding to use it 
for experimentation. Some functions for inspecting arrays are provided in the 
package (cf. <code><a href="#topic+generalized.word.length">generalized.word.length</a></code>).
</p>
<p>The data frame <code>oacat3</code> contains stronger arrays that have at least the main 
effects unconfounded with two-factor interactions. If only these are of interest, 
function <code><a href="#topic+show.oas">show.oas</a></code> can be restricted to strong arrays 
by option <code>Rgt3=TRUE</code>. Function <code><a href="#topic+oa.design">oa.design</a></code> will use a strong 
array, if possible. Since package version 1.2, <code>oacat3</code> contains arrays 
that were obtained via expansive replacement (indicated in the <code>lineage</code> 
column). It is important to note that this automatic replacement is not optimized 
in any way; in some cases it may be worthwhile to check whether a better array
can be produced with different level choices or by expanding not the first but 
a different column of the parent array 
(for an example, see function <code><a href="#topic+expansive.replace">expansive.replace</a></code>); this is not 
automatically checked and can only be done by the user.
</p>


<h3>Value</h3>

<p>The data frames contain the columns <code>name</code>, <code>nruns</code>, <code>lineage</code> 
and further columns <code>n2</code> to <code>n72</code>; furthermore, some columns with 
calculated metrics are included. <code>name</code> holds the name of the 
array, <code>nruns</code> its number of runs, and <code>lineage</code> the way the array can 
be constructed from other arrays, if applicable. The columns <code>n2</code> to <code>n72</code> 
each contain the number of factors with the respective number of levels.
</p>
<p>The logical columns <code>ff</code>, <code>regular.strict</code> and <code>regular</code> indicate a  
full factorial and a regular design in the strict or weak sense, respectively
(strict: all ARFT entries are 0 or 1, defined as &ldquo;<code class="reqn">R^2</code> regular&rdquo; in Groemping and Bailey (2016); 
weak: all SCFT entries are 0 or 1, defined as &ldquo;CC regular&rdquo; in 
Groemping and Bailey (2016)). For <code class="reqn">R^2</code> regularity, it suffices to check all full resolution factor sets, 
i.e., sets of j factors with resolution j; for CC regularity, this is conjectured to be also true.
The entries in column <code>regular</code> are based on that conjecture (and for some larger designs, 
even those checks were not completed);
thus, designs denominated as CC regular might prove otherwise if the conjecture 
proves wrong, and for larger designs also for unchecked full resolution factor sets of higher dimensions).
</p>
<p>Column <code>SCones</code> contains the number of worst case (=1)
squared canonical correlations for the number of R factor subsets, with 
R the resolution; if this number is 0, main effects can be considered 
to have partial confounding only with any interactions of up to R-1 factors. 
<code>GR</code>, <code>GRind</code>, <code>maxAR</code>
and <code>maxSC</code> contain the generalized resolution in two versions, 
the maximum average <code class="reqn">R^2</code> and the maximum squared canonical correlation.
</p>
<p><code>dfe</code> contains the error degrees of freedom of a main effects model, 
if all columns of the array are populated; if this is 0, the design is saturated. 
<code>A3</code> to <code>A8</code> contain the numbers of words of lengths 3 to 8. 
More information on these metrics can be found in 
<code><a href="#topic+generalized.word.length">generalized.word.length</a></code> and the literature therein. 
</p>
<p>The design names also indicate the number of runs and the numbers of factors: 
The first portion of each array name (starting with L) indicates the number of runs, 
each subsequent pair of numbers indicates a number of levels together with the frequency with which it occurs.
For example, <code>L18.2.1.3.7</code> is an 18 run design with one factor with 
2 levels and seven factors with 3 levels each. 
</p>
<p>The columns <code>gmarule</code> and <code>sgmarule</code> refer to the implementation of 
known rules from the literature that certain subsets of array columns have 
generalized minimum aberration (Butler 2005); if such a subset is requested, 
there is no message of caution even if the array columns are used with 
<code>column="order"</code> instead of optimizing the selection. Currently, 
only the rules from Butler (2005) are implemented; hopefully, more rules will be added 
in the future.
</p>
<p>The column <code>lineage</code> deserves particular attention: 
it is an empty string, if the design is directly available and can be accessed via its name, or if the design 
is a full factorial (e.g. L6.2.1.3.1). Otherwise, the lineage entry is structured as follows: 
It starts with the specification of a parent array, given as <code>levels1~no of factors; levels2~no of factors;</code>. 
After a colon, there are one or more replacements, each enclosed in brackets; within each pair of brackets, 
the left-hand side of the exclamation mark shows the to-be-replaced factor, the right-hand side the 
replacement array that has to be used for replacing the levels of such a factor one or more times. For example, 
the lineage for <code>L18.2.1.3.7</code> is <code>3~6;6~1;:(6~1!2~1;3~1;)</code>, which means that the parent array in 
18 runs with six 3 level factors and one 6 level factor has to be used, and the 6 level factor has to be replaced 
with the full factorial with one 2 level factor and one 3 level factor.
</p>


<h3>Warning</h3>

<p>For designs with only 2-level factors, it is usually more wise to 
use package <span class="pkg"><a href="FrF2.html#topic+FrF2-package">FrF2</a></span>. Exceptions: The three arrays by 
Mee (2009; cf. section &ldquo;Details&rdquo; above) are very useful for 2-level factors. 
</p>
<p>Many of the orthogonal arrays from <code>oacat</code>, 
especially when using all columns for experimentation, 
are guaranteed to orthogonally estimate all main effects, 
<b>provided all higher order effects are negligible</b>. 
</p>
<p>Make sure you understand the implications of using an orthogonal main effects design 
for experimentation. In particular, for some designs there is a very severe 
risk of obtaining biased main effect estimates, if there are some interactions between 
experimental factors. The documentation for <code><a href="#topic+generalized.word.length">generalized.word.length</a></code> and 
examples section below that illustrate this remark. 
Cf. also the instructions in section &ldquo;Details&rdquo;).
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping, with contributions by Boyko Amarov 
</p>


<h3>References</h3>

 
<p>Agrawal, V. and Dey, A. (1983). Orthogonal resolution IV designs for some asymmetrical factorials. 
<em>Technometrics</em> <b>25</b>, 197&ndash;199.
</p>
<p>Brouwer, A. Small mixed fractional factorial designs of strength 3. <a href="https://www.win.tue.nl/~aeb/codes/oa/3oa.html#toc1">https://www.win.tue.nl/~aeb/codes/oa/3oa.html#toc1</a> accessed March 1 2016
</p>
<p>Brouwer, A., Cohen, A.M. and Nguyen, M.V.M. (2006). Orthogonal arrays of strength 3 and small run sizes. <em>Journal of Statistical Planning and Inference</em> <b>136</b>, 3268&ndash;3280.
</p>
<p>Butler, N.A. (2005). Generalised minimum aberration construction results for symmetrical orthogonal arrays. <em>Biometrika</em> <b>92</b>, 485 &ndash; 491.
</p>
<p>Eendebak, P. and Schoen, E. Complete Series of Orthogonal Arrays. <a href="http://www.pietereendebak.nl/oapackage/series.html">http://www.pietereendebak.nl/oapackage/series.html</a> accessed March 1 2016
</p>
<p>Groemping, U. and Bailey, R.A. (2016). Regular fractions of factorial arrays. In: 
<em>mODa 11 &ndash; Advances in Model-Oriented Design and Analysis</em>. 
Cham: Springer International Publishing.
</p>
<p>Groemping, U. and Fontana, R. (2019). An Algorithm for Generating Good Mixed 
Level Factorial Designs. <em>Computational Statistics and Data Analysis</em> <b>137</b>, 101&ndash;114.
</p>
<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute 
<a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>
<p>Nguyen, M.V.M. (2005). <em>Journal of Statistical Planning and Inference</em> <b>138</b>,
220&ndash;233.
</p>
<p>Nguyen, M.V.M. (2008). Some new constructions of strength 3 mixed orthogonal arrays. <em>Journal of Statistical Planning and Inference</em> <b>138</b>,
220&ndash;233.
</p>
<p>Sloane, N. Orthogonal Arrays. <a href="http://neilsloane.com/oadir/">http://neilsloane.com/oadir/</a> accessed March 1 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oa.design">oa.design</a></code> for using the designs from <code>oacat</code> in design creation<br />
<code><a href="#topic+show.oas">show.oas</a></code> for inspecting the available arrays from <code>oacat</code><br />
<code><a href="#topic+generalized.word.length">generalized.word.length</a></code> for inspection functions for array properties<br />
<code><a href="#topic+arrays">arrays</a></code> for a list of orthogonal arrays which are directly accessible 
within the package 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   head(oacat)
   
   sapply(oacat3$name[which(oacat3$lineage=="")], 
        function(nn) unlist(attributes(get(nn))[c("origin", "comment")]))
   
</code></pre>

<hr>
<h2 id='param.design'> Function to generate Taguchi style parameter designs </h2><span id='topic+param.design'></span><span id='topic+paramtowide'></span>

<h3>Description</h3>

<p>The functions create parameter designs for robustness experiments 
and signal-to-noise investigations with inner and outer arrays 
and facilitate their formatting and data aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.design(inner, outer, direction="long", responses=NULL, ...)
paramtowide(design, constant=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.design_+3A_inner">inner</code></td>
<td>
<p> an experimental design for the inner array, 
data frame of class <code><a href="#topic+design">design</a></code>; 
as function <code>param.design</code> does not 
randomize, its runs should already be randomized </p>
</td></tr>
<tr><td><code id="param.design_+3A_outer">outer</code></td>
<td>
<p> an experimental design for the outer array, 
data frame of class <code><a href="#topic+design">design</a></code> or vector</p>
</td></tr>
<tr><td><code id="param.design_+3A_direction">direction</code></td>
<td>
<p>character taking the values <code>"wide"</code> or <code>"long"</code>;
if long, the outer array runs for each inner array run are 
listed underneath each other; if wide, they are listed within the 
same row</p>
</td></tr>
<tr><td><code id="param.design_+3A_responses">responses</code></td>
<td>
 <p><code>NULL</code>, or character vector of response names;<br />
for the long format, there are no response columns if <code>responses</code> is <code>NULL</code>, 
while response columns of the specified 
name(s) containing <code>NA</code> values are generated if <code>responses</code> is specified;<br /> 
for the wide format, response columns are always generated 
(one column per run of the outer array for each response): 
if <code>responses</code> is <code>NULL</code>, 
response columns are called <code>"y.1"</code>, <code>"y.2"</code> etc., 
if <code>responses</code> is specified, a set of response columns 
for each specified name is generated 
</p>
</td></tr>
<tr><td><code id="param.design_+3A_design">design</code></td>
<td>
<p> parameter design in long format (created by function <code>param.design</code>) </p>
</td></tr>
<tr><td><code id="param.design_+3A_constant">constant</code></td>
<td>
<p> character vector giving names of variables in addition to the 
experimental factors of the inner array that are constant over 
outer array runs for each inner array run</p>
</td></tr>
<tr><td><code id="param.design_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A parameter design is an experimental plan for setting the so-called &ldquo;control parameters&rdquo; 
such that they achieve the intended function and at the same time minimize the effects 
of the so-called &ldquo;noise parameters&rdquo;. Note that the word parameters is used 
here in an engineering sense rather than in the typical sense it is used in statistics. 
The experiment crosses the control factors in the &ldquo;inner array&rdquo; with the 
noise factors in the &ldquo;outer array&rdquo;. 
</p>
<p>Function <code>param.design</code> uses function <code><a href="#topic+cross.design">cross.design</a></code> for 
creating an inner/outer array crossed design. There will be data aggregation 
functions for such designs in the near future.
</p>
<p>Note that designs created by <code>param.design</code> are not properly randomized, 
as they are conducted in the Taguchi inner / outer array sense with the runs of 
the inner array as whole plots and the factors of the outer array as split-plot 
factors. With analysis methods that work on data aggregated over the outer array 
this is appropriate. If analysis of control and noise factor designs is to be conducted 
in a combined approach, the experiment should be fully randomized. This can be 
done using function <code><a href="#topic+cross.design">cross.design</a></code> directly (cf. example there). 
</p>


<h3>Value</h3>

<p>A data frame of class <code><a href="#topic+design">design</a></code> with type &ldquo;param&rdquo; or 
&ldquo;FrF2.param&rdquo; for long version inner/outer array designs, and 
type of the inner array suffixed with &ldquo;.paramwide&rdquo; for wide version 
inner/outer array designs. The <code>design.info</code> attribute of such designs has 
the following extraordinary elements:<br />
</p>
<p>In long format, there are the same elements as for type <code>crossed</code> from 
function <code><a href="#topic+cross.design">cross.design</a></code>, and the additional elements 
<code>inner</code> and <code>outer</code> that give the names of the inner and outer array 
variables. 
</p>
<p>In wide format, the <code>design.info</code> information refers to the inner array, 
the elements <code>cross... something</code> are no longer available (except for <code>cross.types</code>), 
and the element <code>outer</code> contains the outer array design the rows of which 
correspond to the response columns. The additional element <code>format</code> with value 
&ldquo;innerouterWide&rdquo; indicates the wide format (introduced for analogy to wide 
repeated measures designs), and <code>responselist</code> shows the responses and their 
respective columns in support of subsequent aggregation. Finally, 
if there are variables that are neither experimental factors nor responses and 
change within one run of the inner array, these are listed in <code>restlist</code>. 
</p>


<h3>Note</h3>

<p> This function is still experimental.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>NIST/SEMATECH e-Handbook of Statistical Methods, Section 5.5.6 (What are Taguchi Designs?), 
accessed August 11, 2009. <a href="https://www.itl.nist.gov/div898/handbook/pri/section5/pri56.htm">https://www.itl.nist.gov/div898/handbook/pri/section5/pri56.htm</a>
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+cross.design">cross.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## It is recommended to use param.design particularly with FrF2 designs. 
## For the examples to run without package FrF2 loaded, 
## oa.design designs are used here.

## quick preliminary checks to try out possibilities
control &lt;- oa.design(L18, columns=1:4, factor.names=paste("C",1:4,sep=""))
noise &lt;- oa.design(L4.2.3, columns=1:3, factor.names=paste("N",1:3,sep=""))
## long
long &lt;- param.design(control,noise)
## wide
wide &lt;- param.design(control,noise,direction="wide")
wide
long

## use proper labelled factors
## should of course be as meaningful as possible for your data
fnc &lt;- c(list(c("current","new")),rep(list(c("type1", "type2","type3")),3))
names(fnc) &lt;- paste("C", 1:4, sep="")
control &lt;- oa.design(L18, factor.names=fnc)
fnn &lt;- rep(list(c("low","high")),3)
names(fnn) &lt;- paste("N",1:3,sep="")
noise &lt;- oa.design(L4.2.3, factor.names = fnn)
ex.inner.outer &lt;- param.design(control,noise,direction="wide",responses=c("force","yield"))
ex.inner.outer              
## export e.g. to Excel or other program with which editing is more convenient
## Not run: 
   ### design written to default path as html and rda by export.design
   ### html can be opened with Excel
   ### data can be typed in 
   ### for preparation of loading back into R, 
   ###     remove all legend-like comment that does not belong to the data table itself
   ###     and store as csv
   ### reimport into R using add.response
   ### (InDec and OutDec are for working with German settings csv 
   ###     in an R with standard OutDec, i.e. wrong default option)
   getwd()  ## look at default path, works on most systems
   export.design(ex.inner.outer, OutDec=",")
   add.response("ex.inner.outer", "ex.inner.outer.csv", "ex.inner.outer.rda", InDec=",")

## End(Not run)
</code></pre>

<hr>
<h2 id='planor2design'> Convert matrix, data frame or object of class planordesign 
to object of class design </h2><span id='topic+data2design'></span><span id='topic+planor2design'></span>

<h3>Description</h3>

<p>function to convert matrix, data frame or object of class planordesign to class design 
(allowing use of convenience functions, particularly plotting with mosaic plots)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2design(x, quantitative = rep(FALSE, ncol(x)), ...)
planor2design(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planor2design_+3A_x">x</code></td>
<td>
<p> an object of class <code>data.frame</code>, <code>matrix</code> 
(function <code>data2design</code>) or <code>planordesign</code> </p>
</td></tr>
<tr><td><code id="planor2design_+3A_quantitative">quantitative</code></td>
<td>
<p> a logical vector, indicating which factors are quantitative;<br /> 
defaults to all factors being qualitative</p>
</td></tr>
<tr><td><code id="planor2design_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For matrices and data frames, an unreplicated and unrandomized design is 
assumed (not crucial, but the some entries of the <code>design.info</code> attribute 
and the entire <code>run.order</code> attribute of the result will 
be wrong otherwise). Per default, all factors are treated as qualitative and 
thus made into factors, if they are not factors already.
</p>
<p>Items of the S4 class <code>planordesign</code> are regular factorial designs 
created by package <span class="pkg">planor</span> (the designs itself is in the slot <code>design</code>). 
Function <code>planor2design</code> transforms them into objects of the S3 class 
<code>design</code>; currently, only the most basic information is included
(nunit and the factor information); 
the design is assumed to be unrandomized and unreplicated.   
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+design">design</a></code> with the <code>type</code> and 
<code>creator</code> element of <code>design.info</code> given as <code>external</code> 
or <code>planor</code>. For designs of type <code>planor</code>, the <code>generators</code> 
element of the <code>design.info</code> 
attribute contains the <code>designkey</code> from the original <code>planor</code> design.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See also: the <code>planordesign</code> class of package <span class="pkg">planor</span> (if that package is available), 
<code><a href="#topic+design">design</a></code>, <code><a href="#topic+plot.design">plot.design</a></code>
</p>

<hr>
<h2 id='Plotting+20class+20design+20objects'>Plotting class design objects</h2><span id='topic+plot.design'></span>

<h3>Description</h3>

<p>The plot method for class design objects; other methods are part of a
separate help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'design'
plot(x, y=NULL, select=NULL, selprop=0.25, ask=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_x">x</code></td>
<td>
<p> data frame of S3 class <code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_y">y</code></td>
<td>
<p> a character vector of names of numeric variables in <code>x</code> to be plotted as responses,
or a numeric response vector, or a numeric matrix containing response columns,
or a data frame of numeric response variables (the latter would not work when directly
using function <code><a href="graphics.html#topic+plot.design">plot.design</a></code> from package graphics)</p>
</td></tr>
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_select">select</code></td>
<td>

<p>Specification of selected factors through option <code>select</code>
has been introduced in order to obtain manageable plot sizes. For example,
mosaic plots are most easily readible for up to three or at most four factors.
Main effects plots with too many factors may also be hard to read because of overlapping
labeling. <code>select</code> can also be used for bringing the factors into a desirable order. <br />
<code>select</code> can be<br />
a vector of integers with position numbers of experimental factors,<br />
a character vector of factor letters, <br />
or a character vector of factor names for factors to be selected for plotting; 
in case of ambiguity, factor names take precedence over factor letters.<br />
The following choices are of interest for creating mosaic plots of the design 
factors; any response data will be ignored.<br />
<code>select</code> can be<br />
a list of numeric vectors (all of equal length) specifying the tuples to be plotted 
(a length one list (insted of the numeric vector itself) allows to plot 
the design table as a mosaic plot instead of showing a main effects 
plot, if the design has responses)<br />
one of the special character strings <code>"all2"</code>, <code>"all3"</code> or <code>"all4"</code>
for obtaining mosaic plots of all pairs, triples or quadruples of (a selection of) factors 
(see Details section), <br />
a list with a numeric vector with position numbers of experimental factors as the first
and one of the above special character strings as the second element for requesting all 
tuples of a subset of the factors,<br />
or a list with a single factor position number as the first and one of the above special 
character strings as the second element for requesting all tuples that include 
the specified single factor,<br />
or any of the character strings <code>"complete"</code>, <code>"worst"</code>, <code>"worst.rel"</code>, 
<code>"worst.parft"</code> or <code>"worst.parftdf"</code>  
for automatic selection of the projections with the worst confounding to be plotted 
(see Details section)
</p>
</td></tr>
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_selprop">selprop</code></td>
<td>
<p> a number between 0 and 1 indicating which proportion of 
worst cases to plot in case <code>select=worst</code> or <code>select=worst.rel</code> 
is to be plotted (see Details section). The default is useful for small 
designs only. For large designs, reduce this number !
</p>
</td></tr>  
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_ask">ask</code></td>
<td>
<p> a logical; <br />
default behavior if <code>ask=NULL</code>: 
<code>ask</code> is set to <code>TRUE</code> if multiple plots are requested and 
the current graphics device is interactive 
(or none is open but be the next to be opened device is interactive) and 
<code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="Plotting+2B20class+2B20design+2B20objects_+3A_...">...</code></td>
<td>
<p> further arguments to functions <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="vcd.html#topic+mosaic">mosaic</a></code>, or the function <code><a href="graphics.html#topic+plot.design">plot.design</a></code> from package graphics;<br />
For experts, option <code>sub</code> with the special settings <code>"GR"</code>, <code>"A"</code>,<code>"rA"</code>, 
<code>"sumPARFT"</code> or <code>"sumPARFTdf"</code> 
can be used to create sub titles that display the generalized resolution, 
absolute or relative word lengths (see <code><a href="#topic+generalized.word.length">generalized.word.length</a></code>). 
All other specifications for <code>sub</code> should work as expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Items of class <code><a href="#topic+design">design</a></code> are data frames with attributes,
that have been created for conducting experiments. Apart from the plot method
documented here, separate files document the methods <code><a href="#topic+formula.design">formula.design</a></code>,
<code><a href="#topic+lm.design">lm.design</a></code>, and <code><a href="#topic+class-design-methods">further methods</a></code>.
</p>
<p>The method for <code>plot</code> calls the method available in package graphics
(see <code><a href="graphics.html#topic+plot.design">plot.design</a></code>) wherever this makes sense (<code>x</code> not of class <code>design</code>,
<code>x</code> of class <code>design</code> but not following the class <code><a href="#topic+design">design</a></code> structure
defined in package <span class="pkg">DoE.base</span>,
and <code>x</code> a design with all factors being R-factors and at least one response available).
</p>
<p>Function <code><a href="graphics.html#topic+plot.design">plot.design</a></code> from package <span class="pkg">graphics</span> is not
an adequate choice for designs without responses or designs with experimental factors
that are not R-factors. <br />
For designs with all factors being R-factors and no response defined (e.g. a freshly-created
design from function <code><a href="#topic+oa.design">oa.design</a></code>), function <code>plot.design</code> creates a mosaic plot of
the frequency table of the design, which may be quite useful to understand the structure
for designs with relatively few factors (cf. example below; function <code>plot.design</code> calls
function <code><a href="vcd.html#topic+mosaic">mosaic</a></code> for this purpose). It will generally be necessary to specify the <code>select</code> argument, if the design is not very small. If <code>select</code> is not specified although there are more than four factors, <code>select=1:4</code> is chosen as the default.<br />
For designs with at least one experimental factor that is not an R-factor, function
<code>plot.design</code> calls function <code><a href="graphics.html#topic+plot.dataframe">plot.data.frame</a></code> in order
to create a scatter plot matrix.<br />
Currently, there is no good method for plotting designs with mixed qualitative
and quantitative factors.
</p>
<p>If option <code>select</code> is set to <code>"all2"</code>, <code>"all3"</code> or <code>"all4"</code>,
or a list with a numeric vector as its first element and one of these as the second element, 
or with <code>select</code> as any of <code>"complete"</code>, <code>"worst"</code>, <code>"worst.rel"</code>,
<code>"worst.parft"</code> or <code>"worst.parftdf"</code>,
response variables are ignored, and mosaic plots are created.<br /> 
These requests usually ask for several plots; note that the plots are
created one after the other; with an interactive graphics device, the default is that they overwrite each other
after a user confirmation for the next plot, which allows users to visually inspect them one at a time;
under Windows, the plotting series can be aborted using the <code>Esc</code>-key. 
With non-interactive graphics devices, 
the default is <code>ask=FALSE</code> (e.g. for storing all the plots
in a multi-page file, see examples).
</p>
<p>If option <code>select</code> is any of <code>"all2"</code>, <code>"all3"</code> or <code>"all4"</code>,
mosaic plots of all pairs, triples or quadruples of factors are created as specified. <br />
Note that <code>"all2"</code>
is interesting for non-orthogonal designs only, e.g. ones created by function <code>Dopt.design</code>.<br />
</p>
<p>If option <code>select</code> is set to <code>"complete"</code>, <code>"worst"</code> <code>"worst.rel"</code>,
<code>"worst.parft"</code> or <code>"worst.parftdf"</code>,
the worst case tuples to be displayed are selected by function <code><a href="#topic+tupleSel">tupleSel</a></code>.    
</p>


<h3>Value</h3>

<p>The <code>plot</code> method is called for its side effects and returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p> The package is currently subject to intensive development; most key functionality is now included.
Some changes to input and output structures may still occur.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

<p>Groemping, U (2014) Mosaic plots are useful for visualizing low order projections 
of factorial designs. To appear in <em>The American Statistician</em>
<a href="https://www.tandfonline.com/action/showAxaArticles?journalCode=utas20">https://www.tandfonline.com/action/showAxaArticles?journalCode=utas20</a>.
</p>


<h3>See Also</h3>

<p> See also the following functions known to produce objects of class
<code>design</code>: <code>FrF2</code>, <code>pb</code>, <code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code>,
and function <code><a href="graphics.html#topic+plot.design">plot.design</a></code> from package graphics;
a method for function <code><a href="stats.html#topic+lm">lm</a></code> is described in the separate help file
<code><a href="#topic+lm.design">lm.design</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Examples for plotting designs
oa12 &lt;- oa.design(nlevels=c(2,2,6))
  ## plotting a design without response (uses function mosaic from package vcd)
  plot(oa12)
  ## equivalent to mosaic(~A+B+C, oa12)
  ## alternative order: mosaic(~C+A+B, oa12)
  plot(oa12, select=c(3,1,2))
  ## using the select function: the plots show that the projection for factors
  ## C, D and E (columns 3, 14 and 15 of the array) is a full factorial,
  ## while A, D and E (columns 1, 14, and 15 of the array) do not occur in
  ## all combinations
  plan &lt;- oa.design(L24.2.13.3.1.4.1,nlevels=c(2,2,2,3,4))
  plot(plan, select=c("E","D","A"))
  plot(plan, select=c("E","D","C"))
  ## Not run: 
  plot(plan, select="all3")
  plot(plan, select=list(c(1,3,4,5), "all3"))
  ## use the specialist version of option sub
  plot(plan, select=list(c(1,3,4,5), "all3"), sub="A")
  ## create a file with mosaic plots of all 3-factor projections
  pdf(file="exampleplots.pdf")
  plot(plan, select="all3", main="Design from L24.2.13.3.1.4.1 in default column order)")
  plot(plan, select="worst", selprop=0.3, sub="A")
  dev.off()
  ## the file exampleplots.pdf is now available within the current working
  ## directory
  
## End(Not run)

  ## plotting a design with response
  y=rnorm(12)
  plot(oa12, y)
  ## plot design with a response included
  oa12.r &lt;- add.response(oa12,y)
  plot(oa12.r)
  ## plotting a numeric design (with or without response,
  ##   does not make statistical sense here, for demo only)
  noa12 &lt;- qua.design(oa12, quantitative="all")
  plot(noa12, y, main="Scatter Plot Matrix")
</code></pre>

<hr>
<h2 id='print.oa'>
Function to Print oa Objects with a Lot of Added Info
</h2><span id='topic+print.oa'></span>

<h3>Description</h3>

<p>The function suppresses printing of voluminous info attached as attributes to oa objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.oa_+3A_x">x</code></td>
<td>

<p>the oa object to be printed
</p>
</td></tr>
<tr><td><code id="print.oa_+3A_...">...</code></td>
<td>

<p>further arguments for default print function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently removes all attributes except <code>origin</code>, <code>class</code>, <code>dim</code>, <code>dimnames</code> before printing.<br />
If available, status information from the <code>MIPinfo</code> attribute is printed.<br /> 
Additionally, the names of unusual attributes are printed. 
They can also be printed separately by running <code>names(attributes(x))</code>; to access an attribute, run <code>attr(x, "MIPinfo")</code>, for example.
</p>


<h3>Value</h3>

<p>The function is used for its side effects and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>See Also</h3>

<p>See also <code><a href="base.html#topic+print.default">print.default</a></code> and <code><a href="utils.html#topic+str">str</a></code>
</p>

<hr>
<h2 id='qua.design'> Function to switch between qualitative and quantitative factors and 
different contrast settings</h2><span id='topic+qua.design'></span><span id='topic+change.contr'></span>

<h3>Description</h3>

<p>The function allows to switch between qualitative and quantitative factors and 
different contrast settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qua.design(design, quantitative = NA, contrasts = character(0), ...)
change.contr(design, contrasts=contr.treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qua.design_+3A_design">design</code></td>
<td>
<p> an experimental design, 
data frame of class <code><a href="#topic+design">design</a></code> </p>
</td></tr>
<tr><td><code id="qua.design_+3A_quantitative">quantitative</code></td>
<td>
<p> can be 
</p>
<p>EITHER
</p>
<p>one of the single entries <br />
NA for setting all factors to the default coding for class design (cf. details),<br /> 
&ldquo;all&rdquo; for making all factors quantitative (=numeric),<br />
&ldquo;none&rdquo; for making all factors qualitative (=factor)<br />
</p>
<p>OR
</p>
<p>an unnamed vector of length <code>nfactors</code> 
with an entry <code>TRUE</code>, <code>NA</code> or <code>FALSE</code> for each factor, 
where <code>TRUE</code> makes a factor into a numeric variable, 
and <code>FALSE</code> makes it into a factor with treatment contrasts, and NA 
reinstates the default factor settings;<br /> 
</p>
<p>OR
</p>
<p>a named vector (names from the factor names of the design) with 
an entry <code>TRUE</code>, <code>NA</code> or <code>FALSE</code> for each named factor 
(implying no change for the omitted factors)
</p>
</td></tr>
<tr><td><code id="qua.design_+3A_contrasts">contrasts</code></td>
<td>
<p> only takes effect for factors for which quantitative is <code>FALSE</code>;<br />
the default <code>character(0)</code> does not change any contrasts vs.~the previous 
or default contrasts.<br />
</p>
<p>For customizing, a 
</p>
<p>character string <br />
OR a character vector with a contrast name entry for each factor
OR a named character vector of arbitrary length from 1 to number of factors<br />
</p>
<p>can be given; the names must correspond to names of factors 
to be modified, and entries must be names of contrast functions. 
The contrast functions are then applied to the respective factors 
with the correct number of levels.<br />
Possible contrast function names include (at least) 
<code><a href="#topic+contr.FrF2">contr.FrF2</a></code> (for number of levels a power of 2 only), 
<code><a href="stats.html#topic+contrast">contr.helmert</a></code>, 
<code><a href="stats.html#topic+contrast">contr.treatment</a></code>, 
<code><a href="stats.html#topic+contrast">contr.SAS</a></code>, 
<code><a href="stats.html#topic+contrast">contr.sum</a></code>, 
<code><a href="stats.html#topic+contrast">contr.poly</a></code>.
CAUTION: Function <code>qua.design</code> checks whether the contrast names 
actually define a function, but it is not checked 
whether this function is a valid contrast function.
</p>
</td></tr>
<tr><td><code id="qua.design_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>With function <code>qua.design</code>, option <code>quantitative</code> has the following implications:<br />
An experimental factor for which quantitative is <code>TRUE</code> is recoded into a numeric variable.<br /> 
An experimental factor for which quantitative is <code>NA</code> is recoded into an R-factor 
with the default contrasts given below.<br /> 
An experimental factor for which quantitative is FALSE is recoded into an R-factor 
with treatment contrasts (default) or with custom contrasts as indicated by the 
<code>contrasts</code> parameter. <br />
If the intention is to change contrasts only, function <code>change.contr</code> 
is a convenience interface to function <code>qua.design</code>.
</p>
<p>The default contrasts for factors in class <code><a href="#topic+design">design</a></code> objects 
(exception: purely quantitative design types like lhs or rsm designs) 
depend on the number and content of levels: <br />
2-level experimental factors are coded as R-factors with -1/1 contrasts, <br />
experimental factors with more than two quantitative (=can be coerced to numeric) levels are 
coded as R factors with polynomial contrasts (with scores the numerical levels of the factor), <br />
and qualitatitve experimental factors with more than two levels are coded 
as R factors with treatment contrasts. 
</p>
<p>Note that, for 2-level factors, the default contrasts from function <code>qua.design</code> 
differ from the default contrasts with which the factors were generated in case of 
functions <code><a href="#topic+fac.design">fac.design</a></code> or <code><a href="#topic+oa.design">oa.design</a></code>. Thus, for recreating 
the original state, it may be necessary to explicity specify the desired contrasts.
</p>
<p>Function <code>change.contr</code> makes all factors qualitative. Per default, treatment 
contrasts (cf. <code><a href="stats.html#topic+contrast">contr.treatment</a></code>) 
are assigned to all factors. The default contrasts can of course be modified.
</p>
<p>Warning: It is possible to misuse these functions especially for designs that have been 
combined from several designs. For example, while setting factors in an lhs design 
(cf. <code><a href="DoE.wrapper.html#topic+lhs.design">lhs.design</a></code>) to 
qualitative is prevented, if the lhs design has been crossed with another design of a different 
type, it would be possible to make such a nonsensical modification.
</p>


<h3>Value</h3>

<p>A data frame of class <code><a href="#topic+design">design</a></code>; the element <code>quantitative</code> of attribute <code>design.info</code>, 
the data frame itself and the <code>desnum</code> attribute are modified as appropriate.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>Examples</h3>

<pre><code class='language-R'>## usage with all factors treated alike
y &lt;- rnorm(12)
plan &lt;- oa.design(nlevels=c(2,6,2))
lm(y~.,plan)
lm(y~., change.contr(plan))   ## with treatment contrasts instead
plan &lt;- qua.design(plan, quantitative = "none")
lm(y~.,plan)
plan &lt;- qua.design(plan, quantitative = "none", contrasts=c(B="contr.treatment"))
lm(y~.,plan)
plan &lt;- qua.design(plan, quantitative = "none")
lm(y~.,plan)

plan &lt;- qua.design(plan, quantitative = "all")
lm(y~.,plan)
plan &lt;- qua.design(plan)  ## NA resets to default state
lm(y~.,plan)

## usage with individual factors treated differently
plan &lt;- oa.design(factor.names = list(liquid=c("type1","type2"), 
     dose=c(0,10,50,100,200,500), temperature=c(10,15)))
str(undesign(plan))
## Not run: 
## would cause an error, since liquid is character and cannot be reasonably coerced to numeric
plan &lt;- qua.design(plan, quantitative = "all")

## End(Not run)
plan &lt;- qua.design(plan, quantitative = "none")
str(undesign(plan))

plan &lt;- qua.design(plan, quantitative = c(dose=TRUE,temperature=TRUE))
str(undesign(plan))
## reset all factors to default
plan &lt;- qua.design(plan, quantitative = NA)
str(undesign(plan))
desnum(plan)
## add a response
y &lt;- rnorm(12)
plan &lt;- add.response(plan,y)
## set dose to treatment contrasts
plan &lt;- qua.design(plan, quantitative = c(dose=FALSE), contrasts=c(dose="contr.treatment"))
str(undesign(plan))
desnum(plan)
</code></pre>

<hr>
<h2 id='Reshape+20designs+20with+20repeated+20measurements'> Reshape designs with repeated measurements</h2><span id='topic+reptowide'></span><span id='topic+reptolong'></span>

<h3>Description</h3>

<p>Convenience functions to reshape a design with repeated measurements 
from long to wide or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### generic function
reptowide(design, constant=NULL, ...)
reptolong(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reshape+2B20designs+2B20with+2B20repeated+2B20measurements_+3A_design">design</code></td>
<td>
 
<p>a data frame of S3 class <code>design</code>. <br />
For function <code>reptowide</code>, the design must have repeated measurements 
(<code>repeat.only=TRUE</code> in <code>design.info</code> attribute). <br />
For <code>reptolong</code>, the design must be in the wide form produced 
by function <code>reptowide</code>.</p>
</td></tr> 
<tr><td><code id="Reshape+2B20designs+2B20with+2B20repeated+2B20measurements_+3A_constant">constant</code></td>
<td>
 <p><code>NULL</code> or character vector; 
if <code>design</code> contains variables other than the experimental 
factors and the block column (e.g. covariables) that do not 
change over repeated measurements within the same experimental unit,
<code>constant</code> must be a character vector with the respective variable names</p>
</td></tr>
<tr><td><code id="Reshape+2B20designs+2B20with+2B20repeated+2B20measurements_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions leave the design unchanged (with a warning) 
for all class <code>design</code> objects that are not of the required 
repeated measurements form. 
</p>
<p>If <code>design</code> is not of class <code>design</code>, an error is thrown.
</p>
<p>The <code>reptowide</code> function makes use of the function <code><a href="stats.html#topic+reshape">reshape</a></code> 
in package <span class="pkg">stats</span>, the <code>reptolong</code> function does not. 
</p>


<h3>Value</h3>

<p>A data frame of class <code>design</code> with the required reshaping. 
</p>
<p>The <code>reptowide</code> function returns a design with one row containing 
all the repeated measurements for the same experimental setup (therefore wide),
the <code>reptolong</code> function reshapes a wide design back into the 
long form with all repeated measurements directly underneath each other. 
</p>
<p>The attributes of the design are treated along with the data frame itself: 
The <code>reptowide</code> function resets elements of the <code>design.info</code> 
attribute (<code>response.names</code>, <code>repeat.only</code>) and adds the new elements 
<code>format</code> with value &ldquo;repeatedMeasuresWide&rdquo;, 
<code>responselist</code> and, if there are variables that are neither experimental 
factors nor responses, <code>restlist</code> for those of these that do change 
with repeated measurements. The <code>reptolong</code> function reinstates 
the original long version. 
</p>
<p>Note that the order of variables may change, if there are any variables 
in addition to the factors and responses.
</p>


<h3>Note</h3>

<p> The package is currently subject to intensive development; most key functionality is now included. 
Some changes to input and output structures may still occur.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>See Also</h3>

<p> See Also <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code>, 
<code><a href="#topic+fac.design">fac.design</a></code>, <code><a href="#topic+oa.design">oa.design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    ### design without response data
    ### response variable y is added per default
    plan &lt;- oa.design(nlevels=c(2,6,2), replication=2, repeat.only=TRUE)
    pw &lt;- reptowide(plan)  ## make wide
    pl &lt;- reptolong(pw)  ## make long again
    
    ### design with response and further data
    y &lt;- rexp(24)
    temp &lt;- rep(sample(19:30),each=2)  ## constant covariable
    prot.id &lt;- factor(Letters[1:24]) ## non-constant character covariable
    plan.2 &lt;- add.response(plan, y)
    plan.2$temp &lt;- temp     ## not response
    plan.2$prot.id &lt;- prot.id   ##not response
    plan.2
    reptowide(plan.2, constant="temp")
</code></pre>

<hr>
<h2 id='show.oas'>
Function to display list of available orthogonal arrays
</h2><span id='topic+show.oas'></span>

<h3>Description</h3>

<p>This function allows to inspect the list of available orthogonal arrays, 
optionally specifying selection criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.oas(name = "all", nruns = "all", nlevels = "all", factors = "all", 
    regular = "all", GRgt3 = c("all", "tot", "ind"), Rgt3 = FALSE, show = 10, 
    parents.only = FALSE, showGRs = FALSE, showmetrics = FALSE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.oas_+3A_name">name</code></td>
<td>

<p>character string or vector of character strings giving name(s) of (an) orthogonal 
array(s); results in an error if name does not contain any valid name; 
warns if name contains any invalid name
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_nruns">nruns</code></td>
<td>

<p>the requested number of runs or a 2-element vector 
with a minimum and maximum for the number of runs 
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_nlevels">nlevels</code></td>
<td>

<p>a vector of requested numbers of levels for a set of factors in question, 
must contain integers &gt; 1 only;<br />
nlevels cannot be specified together with factors
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_factors">factors</code></td>
<td>

<p>a list with the two elements <code>nlevels</code> and <code>number</code>, which are both integer 
vectors of equal length;<br /> 
<code>nlevels</code> contains the number of levels and <code>number</code> the number of factors 
for the corresponding number of levels
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_regular">regular</code></td>
<td>

<p>either unrestricted (the default &ldquo;all&rdquo;), a logical which requests 
(<code>TRUE</code>) or rejects (<code>FALSE</code>) regular arrays, or the character string 
&ldquo;strict&rdquo; to request strictly regular arrays, for which all confounded factors 
are <em>completely</em> confounded with a 2-factor interaction of two other factors (the 
latter are fixed level arrays or crossed arrays) 
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_grgt3">GRgt3</code></td>
<td>

<p>either unrestricted (the default &ldquo;all&rdquo;), or a character string which requests 
<code>GR</code> (<code>"tot"</code>) or <code>GRind</code> (<code>"ind"</code>) to be larger than 3<br /> 
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_rgt3">Rgt3</code></td>
<td>

<p>logical requesting inclusion of standard resolution 3 arrays as listed in 
<code><a href="#topic+oacat">oacat</a></code> per default, and restricting the output to arrays of 
resolution at least IV (as listed in <code><a href="#topic+oacat3">oacat3</a></code>), 
if changed to <code>TRUE</code><br /> 
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_show">show</code></td>
<td>

<p>an integer number specifying how many arrays are to be listed (upper bound), 
or the character string <code>"all"</code> for showing all arrays, no matter how many. 
The default is to show 10 arrays. <code>show = 0</code> switches off the display of the result 
and only returns a value. Since August 2018, the number refers to stronger and weaker arrays, separately.
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_parents.only">parents.only</code></td>
<td>

<p>logical specifying whether to show only parent arrays or child arrays as well; 
the default is <code>FALSE</code> for inclusion of child arrays
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_showgrs">showGRs</code></td>
<td>

<p>logical specifying whether to show the generalized resolution quality metrics 
with the resulting arrays; the default is <code>FALSE</code>. If set to <code>TRUE</code>, 
three metrics are displayed (see Details section).
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_showmetrics">showmetrics</code></td>
<td>

<p>logical specifying whether to show all array quality metrics with the resulting 
arrays; the default is <code>FALSE</code>. If set to <code>TRUE</code>, several metrics 
are displayed (see Details section).
</p>
</td></tr>
<tr><td><code id="show.oas_+3A_digits">digits</code></td>
<td>

<p>integer number of significant digits to show for GR and A metrics;
irrelevant, if <code>showmetrics</code> is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function shows the arrays that are listed in the data frames <code><a href="#topic+oacat">oacat</a></code>
or <code><a href="#topic+oacat3">oacat3</a></code>. 
</p>
<p>For child arrays that have to be generated with a lineage rule 
(can be automatically done with function <code><a href="#topic+oa.design">oa.design</a></code>), the lineage is displayed 
together with the array name. The option <code>parent.only = TRUE</code> 
suppresses printing and output of child arrays. The structure of the lineage entry 
is documented under <code><a href="#topic+oacat">oacat</a></code>.
</p>
<p>If display of metrics is requested with <code>showmetrics=TRUE</code>, the printed output shows the metrics
GR*, GRind*, regular (logical, whether regular or not), SCones* (number of squared canonical correlations that are 1), 
and the numbers of words of lengths 3 to 8 (A3 to A8). <code>showGRs=TRUE</code> 
requests the metrics marked with asterisks only (without <code>SCones</code> in case <code>GRgt3="ind"</code>). More information on 
all these metrics can be found <code><a href="#topic+generalized.word.length">here</a></code>
</p>


<h3>Value</h3>

<p>A data frame with the three columns <code>name</code>, <code>nruns</code> and <code>lineage</code>, 
containing the array name, the number of runs and - if applicable - the lineage for generating the array
from other arrays. The lineage entry is empty for parent arrays that are either directly available 
in the package and can be accessed by giving their name (e.g. <code>L18.3.6.6.1</code>) or are full factorials 
(e.g. <code>L28.4.1.7.1</code>). If further information has been requested (e.g. with <code>showmetrics=TRUE</code>), 
the data frame contains additional columns.
</p>
<p>If no array has been found, the returned value is <code>NULL</code>.
</p>


<h3>Note</h3>

<p>Thanks to Peter Theodor Wilrich for proposing such a function.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping 
</p>


<h3>References</h3>

 
<p>Kuhfeld, W. (2009). Orthogonal arrays. Website courtesy of SAS Institute 
<a href="https://support.sas.com/techsup/technote/ts723b.pdf">https://support.sas.com/techsup/technote/ts723b.pdf</a> and references therein.
</p>
<p>Mee, R. (2009). <em>A Comprehensive Guide to Factorial Two-Level Experimentation</em>. 
New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oa.design">oa.design</a></code> for using the arrays from <code><a href="#topic+oacat">oacat</a></code> in design creation<br />
<code><a href="#topic+oacat">oacat</a></code> for the data frames underlying the function<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## the first 10 orthogonal arrays with 24 to 28 runs
   show.oas(nruns = c(24,28))
   ## the first 10 orthogonal arrays with 24 to 28 runs
   ## excluding child arrays
   show.oas(nruns = c(24,28), parents.only=TRUE)
   ## the orthogonal arrays with 4 2-level factors, one 4-level factor and one 5-level factor
   show.oas(factors = list(nlevels=c(2,4,5),number=c(4,1,1)))
   ## show them all with quality metrics
   show.oas(factors = list(nlevels=c(2,4,5),number=c(4,1,1)), show=Inf, showmetrics=TRUE)
   ## pick only those with no complete confounding of any degrees of freedom
   show.oas(factors = list(nlevels=c(2,4,5),number=c(4,1,1)), GRgt3="ind", showmetrics=TRUE)
   ## the orthogonal arrays with 4 2-level factors, one 7-level factor and one 5-level factor
   show.oas(factors = list(nlevels=c(2,7,5),number=c(4,1,1)))
   ## the latter orthogonal arrays with the nlevels notation 
   ## (that can also be used in a call to oa.design subsequently)
   show.oas(nlevels = c(2,7,2,2,5,2))
   ## calling arrays by name 
   show.oas(name=c("L12.2.11", "L18.2.1.3.7"))
</code></pre>

<hr>
<h2 id='SN'> Function for the signal-to-noise ratio 10 * log10(mean^2/var) </h2><span id='topic+SN'></span>

<h3>Description</h3>

<p>Function for the signal-to-noise ratio 10 * log10(mean^2/var)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SN(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SN_+3A_x">x</code></td>
<td>
<p> a data vector to take the S/N ratio over </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taguchi proposes three different versions of S/N-ratio. 
In line with Box, Hunter and Hunter (2005), only the one 
for target-optimization is given here, as it is invariant 
against linear transformation.
</p>


<h3>Value</h3>

<p>a number (10 * log10(mean^2/var))
</p>


<h3>Note</h3>

<p> This package is currently under intensive development. Substantial changes are to be expected in the near future.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box G. E. P, Hunter, W. C. and Hunter, J. S. (2005) 
<em>Statistics for Experimenters, 2nd edition</em>.
New York: Wiley.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+aggregate.design">aggregate.design</a></code>; 
function <code>SN</code> has been developed for use with aggregating parameter designs</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp(10)
SN(x)
10 * log10(mean(x)^2/var(x))
20 * log10(mean(x)/sd(x))
</code></pre>

<hr>
<h2 id='utilities'> Utility functions for DoE packages, not intended for direct use </h2><span id='topic+make.formulas'></span><span id='topic+make.generators'></span><span id='topic+des.recode'></span><span id='topic+Letters'></span><span id='topic+printBy'></span><span id='topic+gen.fun'></span><span id='topic+generators'></span><span id='topic+generators.default'></span><span id='topic+generators.design'></span><span id='topic+generators.catlg'></span><span id='topic+generators.character'></span><span id='topic+PFTs.from.variants'></span><span id='topic+matrix.fromPFTs'></span><span id='topic+rankPFT'></span><span id='topic+bestPFT'></span><span id='topic+rect_simplex'></span><span id='topic+HouseholderRotToOne'></span>

<h3>Description</h3>

<p>Utility functions for DoE packages, not intended for direct use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.generators(name, liste)
make.formulas(orignames, factor.names)
des.recode(var, recodes, as.factor.result, char) 
printBy(data, byvars, ...)
Letters
gen.fun(obj, num = FALSE)
generators(design, ...)
## S3 method for class 'design'
generators(design, ...)
## S3 method for class 'catlg'
generators(design, ...)
## S3 method for class 'character'
generators(design, select.catlg = catlg, ...)
PFTs.from.variants(array, variants, R=3, rela=TRUE)
matrix.fromPFTs(PFTs)
rankPFT(pfts)
bestPFT(pfts)
rect_simplex(r)
HouseholderRotToOne(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities_+3A_name">name</code></td>
<td>
<p> ... </p>
</td></tr>
<tr><td><code id="utilities_+3A_liste">liste</code></td>
<td>
<p> ... </p>
</td></tr>
<tr><td><code id="utilities_+3A_orignames">orignames</code></td>
<td>
<p> ... </p>
</td></tr>
<tr><td><code id="utilities_+3A_factor.names">factor.names</code></td>
<td>
<p> ... </p>
</td></tr>
<tr><td><code id="utilities_+3A_var">var</code></td>
<td>
<p> variable </p>
</td></tr>
<tr><td><code id="utilities_+3A_recodes">recodes</code></td>
<td>
<p> character string specifying recodes, so far only used in the principal form &ldquo;-1=level[1];1=level[2]&rdquo; </p>
</td></tr>
<tr><td><code id="utilities_+3A_as.factor.result">as.factor.result</code></td>
<td>
<p> logical that specifies whether or not results are to be coerced to factor. 
The default is that factors are coerced to factor, while numeric variables with numeric recodes are kept numeric.</p>
</td></tr>
<tr><td><code id="utilities_+3A_char">char</code></td>
<td>
<p> logical: should replacement be treated as character string (TRUE) or evaluated? default is FALSE</p>
</td></tr>
<tr><td><code id="utilities_+3A_data">data</code></td>
<td>
<p> data frame to be printed in groups that are defined by the <code>byvars</code></p>
</td></tr>
<tr><td><code id="utilities_+3A_byvars">byvars</code></td>
<td>
<p> character vector of variable names; 
variables named here determine the groups; only adjacent observations are considered part of a group, i.e. 
if data are not ordered by the <code>byvars</code>, several separate occurrences of the same group may occur</p>
</td></tr>
<tr><td><code id="utilities_+3A_obj">obj</code></td>
<td>
<p> an entry of a class <code>catlg</code> object</p>
</td></tr>
<tr><td><code id="utilities_+3A_num">num</code></td>
<td>
<p> logical; if <code>TRUE</code>, Yates matrix column numbers are output, otherwise human-friendly generators</p>
</td></tr>
<tr><td><code id="utilities_+3A_design">design</code></td>
<td>
<p>FrF2 design given as catalogue entry, design itself or character string; 
function generators provides the generating contrasts for additional factors for these designs.
</p>
</td></tr>
<tr><td><code id="utilities_+3A_select.catlg">select.catlg</code></td>
<td>
<p>the catalogue in which to look for the design (should be of class <code>catlg</code>)
</p>
</td></tr>
<tr><td><code id="utilities_+3A_...">...</code></td>
<td>
<p> further arguments to function <code>print</code> or <code>generators</code> </p>
</td></tr>
<tr><td><code id="utilities_+3A_array">array</code></td>
<td>
<p> orthogonal array (available in the workspace); must be matrix or data frame </p>
</td></tr>
<tr><td><code id="utilities_+3A_variants">variants</code></td>
<td>
<p> matrix the rows of which contain column numbers for <code>array</code> </p>
</td></tr>
<tr><td><code id="utilities_+3A_r">R</code></td>
<td>
<p> resolution of <code>array</code> and also <code>array[variants,,drop=FALSE]</code> </p>
</td></tr>
<tr><td><code id="utilities_+3A_rela">rela</code></td>
<td>
<p> logical; relative PFTs (<code>TRUE</code>) or absolute PFTs (<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="utilities_+3A_pfts">PFTs</code></td>
<td>
<p> list of (absolute or relative) projection frequency tables.<br /> 
The list could have been produced with function <code>PFTs.from.variants</code>. </p>
</td></tr>
<tr><td><code id="utilities_+3A_pfts">pfts</code></td>
<td>
<p> a matrix the columns of which contain the PFT entries for several designs, 
with row names indicating the (relative) number of words of a triple/quadruple.<br />
The matrix could have been obtained from function <code>matrix.fromPFTs</code>. </p>
</td></tr>
<tr><td><code id="utilities_+3A_r">r</code></td>
<td>
<p>integer; dimension of the simplex</p>
</td></tr>
<tr><td><code id="utilities_+3A_from">from</code></td>
<td>
<p>numeric vector to be rotated towards (1,0,...,0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most functions are not intended for direct use. 
</p>
<p>The constant <code>Letters</code> is the vector of all capital and lower case 
letters of the Roman alphabet except <code>I</code> and <code>i</code>. 
It is used for default factor names and has been obtained as <br />
<code>Letters &lt;- c(LETTERS[-9],letters[-9])</code>.
</p>
<p>The generic function <code>generators</code> and its methods determine generating contrasts 
for regular fractional factorial 2-level designs, which can be specified as <br />
the design itself (created with function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>),<br /> 
a list of catalogue entries in package <span class="pkg">FrF2</span> object <code><a href="FrF2.html#topic+catlg">catlg</a></code>,<br /> 
or a character string that names such a catalogue entry. <br />
The method for the design itself cannot be used on designs of type 
<code>FrF2.param...</code> or <code>FrF2.folded</code>. Also, it cannot
be used on designs produced with versions of <span class="pkg">FrF2</span> before <code>1.1</code> in case 
of blocked or splitplot designs. It is generally recommended to update all packages of the 
suite (<span class="pkg">DoE.base</span>, <span class="pkg">FrF2</span>, <span class="pkg">DoE.wrapper</span>, <span class="pkg">RcmdrPlugin.DoE</span>), whenever 
one of them is updated.
</p>
<p>This paragraph describes internal functions: Function <code>PFTs.from.variants</code> 
can be used to determine a list of (relative) 
projection frequency tables (cf. Groemping 2011) for comparing several column 
selections from the same array. Function <code>matrix.fromPFTs</code> brings 
this list into matrix form, functions <code>rankPFT</code> and <code>bestPFT</code> 
allow ranking or picking best selections.
</p>


<h3>Value</h3>

<p>Most functions are not intended for direct use.
</p>
<p>The <code>generators</code> methods output a list of human-readable character string 
vectors with the generators of catalogue entries or a design. 
</p>
<p>The following functions have not yet been adapted to also handle the more 
attractive new metrics calculated with functions <code>P3.3</code>, <code>P4.4</code> and 
<code>GRind</code>.
Function <code>PFTs.from.variants</code> outputs a list of (relative) projection 
frequency tables (each entry is produced with function <code>P3.3</code> or <code>P4.4</code>). 
Function <code>matrix.fromPFTs</code> outputs a matrix (reshaped from such a list, filling 
missing entries with 0 counts for some designs, if required), with columns for 
the different selections and rows for different (relative) numbers of generalized words. 
Function <code>rankPFTs</code> outputs a ranking vector, with 1 for the best design 
(ties are kept in the original order). Function <code>bestPFTs</code> outputs a logical vector, 
with entry <code>TRUE</code> for all best designs (identical best (R)PFTs).
</p>


<h3>Note</h3>

<p> This package is currently under intensive development. Substantial changes are to be expected in the near future.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Groemping, U. (2011). Relative projection frequency tables for orthogonal arrays. 
Report 1/2011, <em>Reports in Mathematics, Physics and Chemistry</em> <a href="http://www1.bht-berlin.de/FB_II/reports/welcome.htm">http://www1.bht-berlin.de/FB_II/reports/welcome.htm</a>, 
Department II, Berliner Hochschule fuer Technik (formerly Beuth University of Applied Sciences), Berlin.
</p>
<p>Hedayat, A.S., Sloane, N.J.A. and Stufken, J. (1999) <em>Orthogonal Arrays: Theory and Applications</em>, Springer, New York. 
</p>


<h3>See Also</h3>

<p> See Also <code><a href="FrF2.html#topic+FrF2-package">FrF2-package</a></code>, <code><a href="DoE.wrapper.html#topic+DoE.wrapper-package">DoE.wrapper-package</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## default factor names for most design generating functions 
## (some quantitative designs have other default factor names)
## for up to 50 factors
Letters
## Not run: 
generators("7-2.2")
generators(catlg[2:8])
generators(FrF2(16,7))
generators(FrF2(16,5,blocks=4,alias.block.2fi=TRUE))
generators(FrF2(16,5,WPs=4,nfac.WP=2))

## End(Not run)
## column selections from L18 with one 2-level and six 3-level factors
v &lt;- rbind(1:7, c(1:6,8), c(1:5,7:8), c(1:4,6:8), c(1:3,5:8), c(1:2,4:8), c(1,3:8))
## RPFTs
RPFTs &lt;- DoE.base:::PFTs.from.variants(L18, v, rela=TRUE)
rpfts &lt;- DoE.base:::matrix.fromPFTs(RPFTs)
rpfts
DoE.base:::rankPFT(rpfts)
DoE.base:::bestPFT(rpfts)
</code></pre>

<hr>
<h2 id='VSGFS'> VSGFS: an experiment using an optimized orthogonal array in 72 runs </h2><span id='topic+VSGFS'></span>

<h3>Description</h3>

<p>VSGFS: an experiment using an optimized orthogonal array in 72 runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSGFS
</code></pre>


<h3>Format</h3>

<p>VSGFS is a data frame of class <code><a href="#topic+design">design</a></code> with seven experimental factors and 
three response variables. The data have been published in Vasilev et al. (2014).
</p>
<p>The experimental factors, all stored as R factors, with their levels are 
</p>

<table>
<tr>
 <td style="text-align: right;">
    [,1]  </td><td style="text-align: left;">   Light       </td><td style="text-align: left;">   Lght-, Lght+</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,2]  </td><td style="text-align: left;">   ShakFreq    </td><td style="text-align: left;">   SF-, SF+</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,3]  </td><td style="text-align: left;">   InocSize    </td><td style="text-align: left;">   IS-, IS+</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,4]  </td><td style="text-align: left;">   FilledVol   </td><td style="text-align: left;">   FV-, FV0, FV+</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,5]  </td><td style="text-align: left;">   CM          </td><td style="text-align: left;">   CM-, CM+</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,6]  </td><td style="text-align: left;">   Carbo       </td><td style="text-align: left;">   Suc, Gluc, Mannit (Sucrose, Glucose, Mannitol)</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,7]  </td><td style="text-align: left;">   Cyclodextrin  </td><td style="text-align: left;"> CD1, CD2, CD3, CD4 (beta, methyl-beta, triacetyl-beta, none)
    </td>
</tr>

</table>

<p>The response variables, all stored as numerical variables, are
</p>

<table>
<tr>
 <td style="text-align: right;">
    [,8]  </td><td style="text-align: left;">   Biomass     </td><td style="text-align: left;">   fresh weight in g</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,9]  </td><td style="text-align: left;">   Content     </td><td style="text-align: left;">   geraniol content in <code class="reqn">\mu</code>g per g fresh weight</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,10] </td><td style="text-align: left;">   Yield       </td><td style="text-align: left;">   geraniol yield in <code class="reqn">\mu</code>g per flask
    </td>
</tr>

</table>



<h3>Details</h3>

<p>The data set comes from an experiment that was created with function 
<code><a href="#topic+oa.design">oa.design</a></code> using the array <code><a href="#topic+L72.2.43.3.8.4.1.6.1">L72.2.43.3.8.4.1.6.1</a></code>. 
Column selection within the array was done with option <code>columns="min34"</code> 
that picks the first set of columns obtained by function <code><a href="#topic+oa.min34">oa.min34</a></code>. 
(Optimization takes quite a while, so that the design was reconstructed later 
by explicitly requesting the optimum set of columns.)
</p>
<p>Design creation and the experiment itself were conducted at the Fraunhofer 
IME in Aachen by Nikolay Vasilev and colleagues. More detail on the experiment 
and the variables can be found in Vasilev et al. (2014).
</p>
<p>The design was created under an R version before 3.6.0. For reproducing its 
creation under R 3.6.0 and later, it is therefore necessary to switch 
to the previous version of random number generation 
(using the <code>RNGkind</code> function, see examples section). Note that the 
previous discrete random uniform random number generator was not perfectly 
uniform, especially for very large samples; for randomizing experiments 
of typical sizes (like this one), this problem can be neglected.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Vasilev, N., Schmidt, C., Groemping, U., Fischer, R. and Schillberg, S. (2014). 
Assessment of Cultivation Factors that Affect Biomass and Geraniol Production 
in Transgenic Tobacco Cell Suspension Cultures. <em>PLoS ONE</em> <b>9</b>(8): 
e104620. <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0104620">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0104620</a>. 
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+oacat">oacat</a></code>, <code><a href="#topic+show.oas">show.oas</a></code>, <code><a href="#topic+oa.min34">oa.min34</a></code>, 
<code><a href="#topic+oa.design">oa.design</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## code used for creating the data frame
## option levordold is needed, because the level ordering 
## changed (improved) with version 0.27 
## and the design was originally created with an earlier version
## Not run: 
  if (getRversion()&gt;='3.6.0') RNGkind(sample.kind="Rounding")
  VSGFS &lt;- oa.design(ID=L72.2.43.3.8.4.1.6.1, 
   nlevels=c(2,2,2,3,2,3,4), 
   columns=c(4,22,37,46,41,48,52), 
   factor.names=list(Light=c("Lght-","Lght+"),
      ShakFreq=c("SF-","SF+"),
      InocSize=c("IS-","IS+"),
      FilledVol=c("FV-","FV0", "FV+"), 
      CM=c("CM-","CM+"),
      Sugar=c("Suc", "Gluc", "Mannit"),
      CDs=c("CD1","CD2","CD3","CD4")),
   seed = 9, randomize=TRUE, levordold=TRUE)
  if (getRversion()&gt;='3.6.0') RNGkind(sample.kind="default")

response &lt;- as.data.frame(scan(what=list(Biomass=0, Content=0, Yield=0), sep=" ")) 
5.80 24.13 139.98
4.97 16.96 84.28
1.28 21.08 26.99
6.83 17.71 120.95
0.86 21.28 18.30
4.09 18.86 77.14
2.39 17.08 40.81
4.05 17.84 72.23
5.84 17.74 103.61
3.38 18.08 61.11
0.40 24.82 9.93
3.86 18.10 69.88
4.58 21.29 97.49
6.29 17.32 108.91
4.85 15.50 75.17
1.25 23.14 28.92
2.09 18.43 38.51
4.26 17.75 75.62
4.78 18.53 88.57
6.63 17.82 118.14
0.77 18.79 14.47
4.89 18.23 89.15
4.53 17.69 80.11
4.27 18.05 77.07
3.90 15.84 61.77
4.15 18.73 77.74
3.95 17.12 67.63
6.92 16.86 116.68
5.00 16.96 84.80
0.37 21.79 8.06
2.36 19.57 46.18
5.11 18.13 92.66
4.69 17.38 81.50
1.20 19.57 23.49
1.76 17.98 31.65
6.21 17.03 105.76
5.63 15.71 88.43
3.98 18.42 73.32
2.31 19.38 44.76
1.86 18.41 34.25
4.22 17.93 75.68
2.77 17.17 47.55
0.40 23.10 9.24
1.42 18.89 26.83
1.54 17.44 26.86
5.03 17.40 87.53
8.70 14.41 125.38
3.21 19.29 61.92
5.36 18.46 98.93
3.87 16.89 65.35
7.70 18.60 143.20
1.71 17.67 30.22
4.38 16.79 73.54
2.24 19.61 43.92
3.79 19.35 73.35
3.09 18.67 57.70
1.57 17.64 27.70
5.43 18.45 100.19
3.86 17.09 65.96
7.44 19.07 141.85
5.87 17.13 100.53
2.65 17.51 46.39
6.14 15.85 97.34
6.32 14.80 93.56
5.19 16.53 85.78
5.09 17.30 88.04
4.40 17.52 77.08
1.68 21.89 36.78
0.93 23.06 21.45
1.79 22.88 40.95
2.64 18.38 48.52
7.78 16.22 126.19


VSGFS &lt;- add.response(VSGFS, response)
VSGFS$Sugar &lt;- relevel(VSGFS$Sugar, "Suc")
VSGFS$FilledVol &lt;- relevel(VSGFS$FilledVol, "FV0")
VSGFS$FilledVol &lt;- relevel(VSGFS$FilledVol, "FV-")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
