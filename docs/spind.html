<!DOCTYPE html><html lang="en"><head><title>Help for package spind</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spind}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acfft'><p>Spatial autocorrelation diagnostics</p></a></li>
<li><a href='#adjusted.actuals'><p>Adjusted actual values</p></a></li>
<li><a href='#aic.calc'><p>Akaike Information Criterion with correction for sample size</p></a></li>
<li><a href='#carlinadata'><p>Carlina data set</p></a></li>
<li><a href='#covar.plot'><p>Plot wavelet variance/covariance</p></a></li>
<li><a href='#GEE'><p>GEE (Generalized Estimating Equations)</p></a></li>
<li><a href='#hook'><p>Hook data set</p></a></li>
<li><a href='#mmiGEE'><p>Multi-model inference for GEE models</p></a></li>
<li><a href='#mmiWMRR'><p>Multi-model inference for wavelet multiresolution regression</p></a></li>
<li><a href='#musdata'><p>Mus musculus data set</p></a></li>
<li><a href='#qic.calc'><p>Quasi-Information Criterion for Generalized Estimating</p>
Equations</a></li>
<li><a href='#rvi.plot'><p>Relative Variable Importance</p></a></li>
<li><a href='#scaleWMRR'><p>Scaling by wavelet multiresolution regression (WMRR)</p></a></li>
<li><a href='#spind'><p>spind: Spatial Methods and Indices</p></a></li>
<li><a href='#step.spind'><p>Stepwise model selection for GEEs and WRMs</p></a></li>
<li><a href='#th.dep'><p>Spatial threshold-dependent accuracy measures</p></a></li>
<li><a href='#th.indep'><p>Spatial threshold-independent accuracy measures</p></a></li>
<li><a href='#upscale'><p>Upscaling of smooth components</p></a></li>
<li><a href='#wavecovar'><p>Wavelet covariance analysis</p></a></li>
<li><a href='#wavevar'><p>Wavelet variance analysis</p></a></li>
<li><a href='#WRM'><p>Wavelet-revised models (WRMs)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatial Methods and Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Gudrun Carl [cre, aut], Ingolf Kuehn [aut], Sam Levin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Levin &lt;levisc8@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/levisc8/spind">https://github.com/levisc8/spind</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/levisc8/spind/issues">https://github.com/levisc8/spind/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for spatial methods based on generalized estimating equations (GEE) and
  wavelet-revised methods (WRM), functions for scaling by wavelet multiresolution regression (WMRR),
  conducting multi-model inference, and stepwise model selection. Further, contains functions 
  for spatially corrected model accuracy measures.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gee (&ge; 4.13.19), geepack (&ge; 1.2.1), MASS (&ge; 7.3.49),
splancs (&ge; 2.1.40), lattice (&ge; 0.20.35), waveslim (&ge; 1.7.5),
rje (&ge; 1.9), stringr (&ge; 1.3.1), ggplot2 (&ge; 3.0.0),
RColorBrewer (&ge; 1.1.2), rlang(&ge; 0.2.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.15.1), rmarkdown (&ge; 1.9), gridExtra (&ge; 2.3),
testthat (&ge; 2.0.0), PresenceAbsence (&ge; 1.1.9), sp (&ge; 1.2.7),
covr (&ge; 3.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-30 14:12:33 UTC; sl13sise</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-30 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acfft'>Spatial autocorrelation diagnostics</h2><span id='topic+acfft'></span>

<h3>Description</h3>

<p>A function for calculating spatial autocorrelation using Moran's I.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfft(coord, f, lim1 = 1, lim2 = 2, dmax = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfft_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="acfft_+3A_f">f</code></td>
<td>
<p>A vector which is the same length as <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="acfft_+3A_lim1">lim1</code></td>
<td>
<p>Lower bound for first bin. Default is 1</p>
</td></tr>
<tr><td><code id="acfft_+3A_lim2">lim2</code></td>
<td>
<p>Upper bound for first bin. Default is 2</p>
</td></tr>
<tr><td><code id="acfft_+3A_dmax">dmax</code></td>
<td>
<p>Number of distance bins to examine. Bins are formed by annuli of gradually
increasing radii. Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Moran's I values for each distance bin.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(musdata)
coords &lt;- musdata[ ,4:5]
mglm &lt;- glm(musculus ~ pollution + exposure, "poisson", musdata)

ac &lt;- acfft(coords, resid(mglm, type = "pearson"), lim1 = 0, lim2 = 1)
ac

</code></pre>

<hr>
<h2 id='adjusted.actuals'>Adjusted actual values</h2><span id='topic+adjusted.actuals'></span>

<h3>Description</h3>

<p>Adjusts actual presence/absence data based on the autocorrelation
in the predictions of a model. The function will optionally plot results of
model predictions, un-modified actual presence/absence, and adjusted  values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjusted.actuals(data, coord, plot.maps = FALSE, color.maps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjusted.actuals_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix containing actual presence/absence (binary,
0 or 1) values in 1st column and predicted values (numeric between 0 and 1)
in 2nd column.</p>
</td></tr>
<tr><td><code id="adjusted.actuals_+3A_coord">coord</code></td>
<td>
<p>a matrix of two columns of the same length providing integer,
consecutively numbered coordinates for each occurrence and prediction in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="adjusted.actuals_+3A_plot.maps">plot.maps</code></td>
<td>
<p>A logical indicating whether maps should be plotted.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="adjusted.actuals_+3A_color.maps">color.maps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, produces colorful maps.
If <code>FALSE</code>, produces grayscale maps. Default is grayscale. NOW DEPRECATED,
color maps will not be produced in future versions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of adjusted actual values.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hook)
data &lt;- hook[ ,1:2]
coord &lt;- hook[ ,3:4]
aa &lt;- adjusted.actuals(data, coord, plot.maps = TRUE)

</code></pre>

<hr>
<h2 id='aic.calc'>Akaike Information Criterion with correction for sample size</h2><span id='topic+aic.calc'></span>

<h3>Description</h3>

<p>Calculates AIC and AICc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic.calc(formula, family, data, mu, n.eff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aic.calc_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="aic.calc_+3A_family">family</code></td>
<td>
<p>Family used to fit the model. <code>gaussian</code>, <code>binomial</code>, or <code>poisson</code> are supported</p>
</td></tr>
<tr><td><code id="aic.calc_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="aic.calc_+3A_mu">mu</code></td>
<td>
<p>Fitted values from a model</p>
</td></tr>
<tr><td><code id="aic.calc_+3A_n.eff">n.eff</code></td>
<td>
<p>Effective number of observations. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>

<dl>
<dt><code>loglik</code></dt><dd><p>Log likelihood of the model</p>
</dd>
<dt><code>df</code></dt><dd><p>Degrees of freedom</p>
</dd>
<dt><code>AIC</code></dt><dd><p>AIC score for the specified model</p>
</dd>
<dt><code>AICc</code></dt><dd><p>AIC score corrected for small sample sizes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gudrun Carl, Sam Levin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(musdata)
coords &lt;- musdata[ ,4:5]
mglm &lt;- glm(musculus ~ pollution + exposure, "poisson", musdata)

aic &lt;- aic.calc(musculus ~ pollution + exposure, "poisson", musdata,
                mglm$fitted)
aic$AIC

</code></pre>

<hr>
<h2 id='carlinadata'>Carlina data set</h2><span id='topic+carlinadata'></span>

<h3>Description</h3>

<p>A data frame containing simulated count data for the thistle, Carlina horrida.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carlinadata
</code></pre>


<h3>Format</h3>

<p>A data frame with 961 rows and 5 columns
</p>

<dl>
<dt>carlina.horrida</dt><dd><p>integer - Simulated count data</p>
</dd>
<dt>aridity</dt><dd><p>numeric - Simulated aridity index values. This variable has high spatial autocorrelation
values.</p>
</dd>
<dt>land.use</dt><dd><p>numeric - Simulated land use intensity. This variable has no spatial autocorrelation.</p>
</dd>
<dt>x</dt><dd><p>integer - x-coordinates for each grid cell</p>
</dd>
<dt>y</dt><dd><p>integer - y-coordinates for each grid cell</p>
</dd>
</dl>


<hr>
<h2 id='covar.plot'>Plot wavelet variance/covariance</h2><span id='topic+covar.plot'></span>

<h3>Description</h3>

<p>Plots the wavelet variance or covariance for the specified formula.
The scale-dependent results are graphically displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar.plot(
  formula,
  data,
  coord,
  wavelet = "haar",
  wtrafo = "dwt",
  plot = "covar",
  customize_plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covar.plot_+3A_formula">formula</code></td>
<td>
<p>With specified notation according to names in data frame.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_coord">coord</code></td>
<td>
<p>A matrix of 2 columns with
corresponding x,y-coordinates which have to be integer.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_wavelet">wavelet</code></td>
<td>
<p>Type of wavelet: <code>haar</code>, <code>d4</code>, or <code>la8</code>.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform: <code>dwt</code> or <code>modwt</code>.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_plot">plot</code></td>
<td>
<p>Either <code>var</code> for wavelet variance analysis
or <code>covar</code> for wavelet covariance analysis.</p>
</td></tr>
<tr><td><code id="covar.plot_+3A_customize_plot">customize_plot</code></td>
<td>
<p>Additional plotting parameters passed to <code>ggplot</code>.
NOW DEPRECATED</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each variable or pair of variables in <code>formula</code> is passed to <code>wavevar</code> or
<code>wavecovar</code> internally, and the result is plotted as a function of <code>level</code>.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<p>1. <code>result</code> =  a vector of results.
</p>
<p>2. <code>plot</code> = a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavevar">wavevar</a></code>, <code><a href="#topic+wavecovar">wavecovar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carlinadata)
coords &lt;- carlinadata[,4:5]

covariance &lt;- covar.plot(carlina.horrida ~ aridity + land.use - 1,
                         data = carlinadata,
                         coord = coords,
                         wavelet = "d4",
                         wtrafo = 'modwt',
                         plot = 'covar')

covariance$plot
covariance$result

variance &lt;- covar.plot(carlina.horrida ~ aridity + land.use - 1,
                       data = carlinadata,
                       coord = coords,
                       wavelet = "d4",
                       wtrafo = 'modwt',
                       plot = 'var')

variance$plot
variance$result

</code></pre>

<hr>
<h2 id='GEE'>GEE (Generalized Estimating Equations)</h2><span id='topic+GEE'></span><span id='topic+plot.GEE'></span><span id='topic+predict.GEE'></span><span id='topic+summary.GEE'></span>

<h3>Description</h3>

<p><code>GEE</code> provides GEE-based methods from the packages <span class="pkg">gee</span> and <span class="pkg">geepack</span>
to account for spatial autocorrelation in multiple linear regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEE(
  formula,
  family,
  data,
  coord,
  corstr = "fixed",
  cluster = 3,
  moran.params = list(),
  plot = FALSE,
  scale.fix = FALSE,
  customize_plot = NULL
)

## S3 method for class 'GEE'
plot(x, ...)

## S3 method for class 'GEE'
predict(object, newdata, ...)

## S3 method for class 'GEE'
summary(object, ..., printAutoCorPars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GEE_+3A_formula">formula</code></td>
<td>
<p>Model formula. Variable names must match variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="GEE_+3A_family">family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, or <code>poisson</code> are supported.
Called using a quoted character string (i.e. <code>family</code> = &quot;gaussian&quot;).</p>
</td></tr>
<tr><td><code id="GEE_+3A_data">data</code></td>
<td>
<p>A data frame with variable names that match the variables
specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="GEE_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="GEE_+3A_corstr">corstr</code></td>
<td>
<p>Expected autocorrelation structure: <code>independence</code>, <code>fixed</code>,
<code>exchangeable</code>, and <code>quadratic</code>  are possible.
</p>

<ul>
<li><p><code>independence</code> - This is the same as a GLM, i.e. correlation matrix = identity matrix.
</p>
</li>
<li><p><code>fixed</code> - Uses an adapted isotropic power function specifying all correlation
coefficients.
</p>
</li>
<li><p><code>exchangeable</code> and <code>quadratic</code> for clustering, i.e.
the correlation matrix has a block diagonal form:
</p>

<ul>
<li><p><code>exchangeable</code> - All intra-block correlation coefficients are equal.
</p>
</li>
<li><p><code>quadratic</code> - Intra-block correlation coefficients for different
distances can be different.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="GEE_+3A_cluster">cluster</code></td>
<td>
<p>Cluster size for cluster models <code>exchangeable</code>
and <code>quadratic</code>. Values of 2, 3, and 4 are allowed.
</p>

<ul>
<li><p> 2 - a 2*2 cluster
</p>
</li>
<li><p> 3 - a 3*3 cluster
</p>
</li>
<li><p> 4 - a 4*4 cluster
</p>
</li></ul>
</td></tr>
<tr><td><code id="GEE_+3A_moran.params">moran.params</code></td>
<td>
<p>A list of parameters for calculating Moran's I.
</p>

<ul>
<li><p><code>lim1</code> Lower limit for first bin. Default is 0.
</p>
</li>
<li><p><code>increment</code> Step size for calculating I. Default is 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="GEE_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether autocorrelation of
residuals should be plotted. NOW DEPRECATED in favor of <code>plot.GEE</code> method.</p>
</td></tr>
<tr><td><code id="GEE_+3A_scale.fix">scale.fix</code></td>
<td>
<p>A logical indicating whether or not the scale parameter should
be fixed. The default is <code>FALSE</code>. Use <code>TRUE</code> when planning to use
stepwise model selection procedures in <code>step.spind</code>.</p>
</td></tr>
<tr><td><code id="GEE_+3A_customize_plot">customize_plot</code></td>
<td>
<p>Additional plotting parameters passed to <code>ggplot</code>.
NOW DEPRECATED in favor <code>plot.GEE</code> method.</p>
</td></tr>
<tr><td><code id="GEE_+3A_x">x</code></td>
<td>
<p>An object of class <code>GEE</code> or <code>WRM</code></p>
</td></tr>
<tr><td><code id="GEE_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="GEE_+3A_object">object</code></td>
<td>
<p>An object of class <code>GEE</code>.</p>
</td></tr>
<tr><td><code id="GEE_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing variables to base the predictions on.</p>
</td></tr>
<tr><td><code id="GEE_+3A_printautocorpars">printAutoCorPars</code></td>
<td>
<p>A logical indicating whether to print the
working autocorrelation parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GEE can be used to fit linear models for response variables with
different distributions: <code>gaussian</code>, <code>binomial</code>, or <code>poisson</code>.
As a spatial model, it is a generalized linear model in which the residuals
may be autocorrelated. It accounts for spatial (2-dimensional)
autocorrelation of the residuals in cases of regular gridded datasets
and returns corrected parameter estimates. The grid cells are assumed to be square.
Furthermore, this function requires that <strong>all predictor variables
be continuous</strong>.
</p>


<h3>Value</h3>

<p>An object of class <code>GEE</code>. This consists of a list with the
following elements:
</p>

<dl>
<dt><code>call</code></dt><dd><p>Call</p>
</dd>
<dt><code>formula</code></dt><dd><p>Model formula</p>
</dd>
<dt><code>family</code></dt><dd><p>Family</p>
</dd>
<dt><code>coord</code></dt><dd><p>Coordinates used for the model</p>
</dd>
<dt><code>corstr</code></dt><dd><p>User-selected correlation structure</p>
</dd>
<dt><code>b</code></dt><dd><p>Estimate of regression parameters</p>
</dd>
<dt><code>s.e.</code></dt><dd><p>Standard errors of the estimates</p>
</dd>
<dt><code>z</code></dt><dd><p>Depending on the <code>family</code>, either a <em>z</em> or <em>t</em> value</p>
</dd>
<dt><code>p</code></dt><dd><p><em>p</em>-values for each parameter estimate</p>
</dd>
<dt><code>scale</code></dt><dd><p>Scale parameter (dispersion parameter) of the distribution's variance</p>
</dd>
<dt><code>scale.fix</code></dt><dd><p>Logical indicating whether <code>scale</code> has fixed value</p>
</dd>
<dt><code>cluster</code></dt><dd><p>User-specified cluster size for clustered models</p>
</dd>
<dt><code>fitted</code></dt><dd><p>Fitted values from the model</p>
</dd>
<dt><code>resid</code></dt><dd><p>Normalized Pearson residuals</p>
</dd>
<dt><code>w.ac</code></dt><dd><p>Working autocorrelation parameters</p>
</dd>
<dt><code>Mat.ac</code></dt><dd><p>Working autocorrelation matrix</p>
</dd>
<dt><code>QIC</code></dt><dd><p>Quasi Information Criterion. See <code><a href="#topic+qic.calc">qic.calc</a></code>
for further details</p>
</dd>
<dt><code>QLik</code></dt><dd><p>Quasi-likelihood. See <code><a href="#topic+qic.calc">qic.calc</a></code>
for further details</p>
</dd>
<dt><code>plot</code></dt><dd><p>Logical value indicating whether autocorrelation should
be plotted</p>
</dd>
<dt><code>moran.params</code></dt><dd><p>Parameters for calculating Moran's I</p>
</dd>
<dt><code>v2</code></dt><dd><p>Parameter variance of the <code>GEE</code> model</p>
</dd>
<dt><code>var.naive</code></dt><dd><p>Parameter variance of the <code>independence</code> model</p>
</dd>
<dt><code>ac.glm</code></dt><dd><p>Autocorrelation of GLM residuals</p>
</dd>
<dt><code>ac.gee</code></dt><dd><p>Autocorrelation of GEE residuals</p>
</dd>
<dt><code>plot</code></dt><dd><p>An object of class <code>ggplot</code> containing information
on the autocorrelation of residuals from the fitted <code>GEE</code> and a
<code>GLM</code></p>
</dd>
</dl>

<p>Elements can be viewed using the <code><a href="#topic+summary.GEE">summary.GEE</a></code> methods included in
the package.
</p>


<h3>Note</h3>

<p>When using <code>corstr = "fixed"</code> on large data sets, the function
may return an error, as the resulting variance-covariance matrix is too
large for R to handle. If this happens, one will have to use one of the
cluster models (i.e <code>quadratic, exchangeable</code>).
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl, Sam Levin
</p>


<h3>References</h3>

<p>Carl G &amp; Kuehn I, 2007. Analyzing Spatial Autocorrelation in Species
Distributions using Gaussian and Logit Models, Ecol. Model. 207, 159 - 170
</p>
<p>Carey, V. J., 2006. Ported to R by Thomas Lumley (versions 3.13,
4.4, version 4.13)., B. R. gee: Generalized Estimation Equation
solver. R package version 4.13-11.
</p>
<p>Yan, J., 2004. geepack: Generalized Estimating Equation Package.
R package version 0.2.10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qic.calc">qic.calc</a></code>, <code><a href="#topic+summary.GEE">summary.GEE</a></code>, <code><a href="gee.html#topic+gee">gee</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(musdata)
coords&lt;- musdata[,4:5]

## Not run: 
mgee &lt;- GEE(musculus ~ pollution + exposure,
            family = "poisson",
            data =  musdata,
            coord = coords,
            corstr = "fixed",
            scale.fix = FALSE)

summary(mgee, printAutoCorPars = TRUE)

pred &lt;- predict(mgee, newdata = musdata)

library(ggplot2)

plot(mgee)

my_gee_plot &lt;- mgee$plot

# move the legend to a new position
print(my_gee_plot + ggplot2::theme(legend.position = 'top'))


## End(Not run)
</code></pre>

<hr>
<h2 id='hook'>Hook data set</h2><span id='topic+hook'></span>

<h3>Description</h3>

<p>A data frame containing actual presence absence data and predicted probability
of occurrence values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 4 columns
</p>

<dl>
<dt>actuals</dt><dd><p>integer - Presence/absence records</p>
</dd>
<dt>predictions</dt><dd><p>numeric - predicted probabilities of occurrence</p>
</dd>
<dt>x</dt><dd><p>integer - x-coordinates for each grid cell</p>
</dd>
<dt>y</dt><dd><p>integer - y-coordinates for each grid cell</p>
</dd>
</dl>


<hr>
<h2 id='mmiGEE'>Multi-model inference for GEE models</h2><span id='topic+mmiGEE'></span>

<h3>Description</h3>

<p>mmiGEE is a multimodel inference approach evaluating the relative
importance of predictors used in <code><a href="#topic+GEE">GEE</a></code>.
</p>
<p>@details It performs automatically
generated model selection and creates a model
selection table according to the approach of multi-model inference
(Burnham &amp; Anderson, 2002). QIC is used to obtain model
selection weights and to rank the models. Moreover, mmiGEE calculates relative
variable importance of a given model.
Finally, this function requires that <strong>all predictor variables
be continuous</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmiGEE(object, data, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmiGEE_+3A_object">object</code></td>
<td>
<p>A model of class <code>GEE</code>.</p>
</td></tr>
<tr><td><code id="mmiGEE_+3A_data">data</code></td>
<td>
<p>A data frame or set of vectors of equal length.</p>
</td></tr>
<tr><td><code id="mmiGEE_+3A_trace">trace</code></td>
<td>
<p>A logical indicating whether or not to print results to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the relative importance of each variable
using multi-model inference methods in a Generalized Estimating Equations
framework implemented in <code>GEE</code>.
</p>


<h3>Value</h3>

<p><code>mmiGEE</code> returns a list containing the following elements
</p>

<dl>
<dt><code>result</code></dt><dd><p>A matrix containing slopes, degrees of freedom, quasilikelihood,
QIC, delta, and weight values for the set of candidate models.
The models are ranked by QIC.</p>
</dd>
<dt><code>rvi</code></dt><dd><p>A vector containing the relative importance of each variable
in the regression.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gudrun Carl, Sam Levin
</p>


<h3>References</h3>

<p>Burnham, K.P. &amp; Anderson, D.R. (2002) Model selection and
multimodel inference. Springer, New York.
</p>
<p>Carl G &amp; Kuehn I, 2007. Analyzing Spatial Autocorrelation in Species
Distributions using Gaussian and Logit Models, Ecol. Model. 207, 159 - 170
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GEE">GEE</a></code>, <code><a href="#topic+qic.calc">qic.calc</a></code>, <span class="pkg">MuMIn</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data (for demonstration only)
library(MASS)
data(birthwt)

# impose an artificial (not fully appropriate) grid structure

x &lt;- rep(1:14, 14)
y &lt;- as.integer(gl(14, 14))
coords &lt;- cbind(x[-(190:196)], y[-(190:196)])

## Not run: 

formula &lt;- formula(low ~ race + smoke +  bwt)

mgee &lt;- GEE(formula,
            family = "gaussian",
            data = birthwt,
            coord = coords,
            corstr = "fixed",
            scale.fix = TRUE)

mmi &lt;- mmiGEE(mgee, birthwt)


## End(Not run)
</code></pre>

<hr>
<h2 id='mmiWMRR'>Multi-model inference for wavelet multiresolution regression</h2><span id='topic+mmiWMRR'></span>

<h3>Description</h3>

<p>mmiWMRR is a multimodel inference approach evaluating the relative
importance of predictors used in <code><a href="#topic+scaleWMRR">scaleWMRR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmiWMRR(object, data, scale, detail = TRUE, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmiWMRR_+3A_object">object</code></td>
<td>
<p>A model of class <code>WRM</code>.</p>
</td></tr>
<tr><td><code id="mmiWMRR_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="mmiWMRR_+3A_scale">scale</code></td>
<td>
<p>0 or higher integers possible (limit depends on sample size).
<code>scale</code>=1 is equivalent to <code>WRM</code> with <code>level</code>=1.</p>
</td></tr>
<tr><td><code id="mmiWMRR_+3A_detail">detail</code></td>
<td>
<p>Remove smooth wavelets? If <code>TRUE</code>, only detail
components are analyzed. If set to <code>FALSE</code>, smooth and detail
components are analyzed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mmiWMRR_+3A_trace">trace</code></td>
<td>
<p>Logical value indicating whether to print results to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs automatically
generated model selection and creates a model
selection table according to the approach of multi-model inference
(Burnham &amp; Anderson, 2002). The analysis is carried out for scale-specific
regressions (i.e. where <code><a href="#topic+scaleWMRR">scaleWMRR</a></code> can be used). AIC is
used to obtain model
selection weights and to rank the models.
Furthermore, this function requires that <strong>all predictor variables
be continuous</strong>.
</p>


<h3>Value</h3>

<p><code>mmiWMRR</code> returns a list containing the following elements
</p>

<dl>
<dt><code>result</code></dt><dd><p>A matrix containing slopes, degrees of freedom, likelihood,
AIC, delta, and weight values for the set of candidate models.
The models are ranked by AIC.</p>
</dd>
<dt><code>level</code></dt><dd><p>An integer corresponding to scale</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>References</h3>

<p>Burnham, K.P. &amp; Anderson, D.R. (2002) Model selection and
multimodel inference. Springer, New York.
</p>
<p>Carl G, Doktor D, Schweiger O, Kuehn I (2016)
Assessing relative variable importance across different spatial
scales: a two-dimensional wavelet analysis.
Journal of Biogeography 43: 2502-2512.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aic.calc">aic.calc</a></code>, <code><a href="#topic+rvi.plot">rvi.plot</a></code>,
<span class="pkg">MuMIn</span>, <code><a href="#topic+WRM">WRM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(carlinadata)
coords &lt;- carlinadata[ ,4:5]

## Not run: 


wrm &lt;- WRM(carlina.horrida ~ aridity + land.use,
           family = "poisson",
           data = carlinadata,
           coord = coords,
           level = 1,
           wavelet = "d4")

mmi &lt;- mmiWMRR(wrm,
               data = carlinadata,
               scale = 3,
               detail = TRUE,
               trace = FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='musdata'>Mus musculus data set</h2><span id='topic+musdata'></span>

<h3>Description</h3>

<p>A data frame containing simulated count data of a house mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>musdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 5 columns
</p>

<dl>
<dt>musculus</dt><dd><p>integer - Simulated count data for Mus musculus</p>
</dd>
<dt>pollution</dt><dd><p>numeric - Simulated variable that describes degree
of pollution in corresponding grid cell</p>
</dd>
<dt>exposure</dt><dd><p>numeric - Simulated variable that describes degree of
exposure for each grid cell</p>
</dd>
<dt>x</dt><dd><p>integer - x-coordinates for each grid cell</p>
</dd>
<dt>y</dt><dd><p>integer - y-coordinates for each grid cell</p>
</dd>
</dl>


<hr>
<h2 id='qic.calc'>Quasi-Information Criterion for Generalized Estimating
Equations</h2><span id='topic+qic.calc'></span>

<h3>Description</h3>

<p>A function for calculating quasi-likelihood and Quasi-Information
Criterion values based on the method of Hardin &amp; Hilbe (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qic.calc(formula, family, data, mu, var.robust, var.indep.naive)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qic.calc_+3A_formula">formula</code></td>
<td>
<p>a model formula</p>
</td></tr>
<tr><td><code id="qic.calc_+3A_family">family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, or <code>poisson</code></p>
</td></tr>
<tr><td><code id="qic.calc_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="qic.calc_+3A_mu">mu</code></td>
<td>
<p>fitted values from a model</p>
</td></tr>
<tr><td><code id="qic.calc_+3A_var.robust">var.robust</code></td>
<td>
<p>variance of model parameters</p>
</td></tr>
<tr><td><code id="qic.calc_+3A_var.indep.naive">var.indep.naive</code></td>
<td>
<p>naive variance of model parameters under the
<code>independence</code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>QIC</code></dt><dd><p>quasi-information criterion</p>
</dd>
<dt><code>loglik</code></dt><dd><p>quasi-likelihood</p>
</dd>
</dl>



<h3>References</h3>

<p>Hardin, J.W. &amp; Hilbe, J.M. (2003) Generalized Estimating Equations. Chapman and Hall, New York.
</p>
<p>Barnett et al. Methods in Ecology &amp; Evolution 2010, 1, 15-24.
</p>

<hr>
<h2 id='rvi.plot'>Relative Variable Importance</h2><span id='topic+rvi.plot'></span>

<h3>Description</h3>

<p>Creates model selection tables, calculates and plots relative
variable importance based on the scale level of a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvi.plot(
  formula,
  family,
  data,
  coord,
  maxlevel,
  detail = TRUE,
  wavelet = "haar",
  wtrafo = "dwt",
  n.eff = NULL,
  trace = FALSE,
  customize_plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvi.plot_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_family">family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, and <code>poisson</code>
are supported.</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_data">data</code></td>
<td>
<p>A data frame or set of vectors of equal length.</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_coord">coord</code></td>
<td>
<p>X,Y coordinates for each observation. Coordinates should be
consecutive integers.</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_maxlevel">maxlevel</code></td>
<td>
<p>An integer for maximum scale level</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_detail">detail</code></td>
<td>
<p>Remove smooth wavelets? If <code>TRUE</code>, only detail components are analyzed.
If set to <code>FALSE</code>, smooth and detail components are analyzed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_wavelet">wavelet</code></td>
<td>
<p>Type of wavelet: <code>haar</code>, <code>d4</code>, or <code>la8</code></p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform: <code>dwt</code> or <code>modwt</code></p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_n.eff">n.eff</code></td>
<td>
<p>A numeric value of effective sample size</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_trace">trace</code></td>
<td>
<p>Should R print progress updates to the console? Default is FALSE</p>
</td></tr>
<tr><td><code id="rvi.plot_+3A_customize_plot">customize_plot</code></td>
<td>
<p>Additional plotting parameters passed to <code>ggplot</code>.
NOW DEPRECATED.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the relative importance of each variable
using multi-model inference methods in a wavelet multi-resolution regression
framework implemented in <code>mmiWMRR</code>. The scale level dependent
results are then graphically displayed.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<p>1. A matrix containing the relative importance of each variable
in the regression at each value of the scale level.
</p>
<p>2. A <code>ggplot</code> object containing a plot of the relative
variable importance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carlinadata)
coords&lt;- carlinadata[,4:5]

## Not run: 

wrm &lt;- WRM(carlina.horrida ~ aridity + land.use,
           family = "poisson",
           data = carlinadata,
           coord = coords,
           level = 1,
           wavelet = "d4")

mmi &lt;- mmiWMRR(wrm, data = carlinadata, scale = 3, detail = TRUE)


# Plot scale-dependent relative variable importance
rvi &lt;- rvi.plot(carlina.horrida ~ aridity + land.use,
                family = "poisson",
                data = carlinadata,
                coord = coords,
                maxlevel = 4,
                detail = TRUE,
                wavelet = "d4")

rvi$plot
rvi$rvi


## End(Not run)
</code></pre>

<hr>
<h2 id='scaleWMRR'>Scaling by wavelet multiresolution regression (WMRR)</h2><span id='topic+scaleWMRR'></span>

<h3>Description</h3>

<p>scaleWMRR performs a scale-specific regression based on a
wavelet multiresolution analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleWMRR(
  formula,
  family,
  data,
  coord,
  scale = 1,
  detail = TRUE,
  wavelet = "haar",
  wtrafo = "dwt",
  b.ini = NULL,
  pad = list(),
  control = list(),
  moran.params = list(),
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleWMRR_+3A_formula">formula</code></td>
<td>
<p>With specified notation according to names in data frame.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_family">family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, or <code>poisson</code>.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_coord">coord</code></td>
<td>
<p>Corresponding coordinates which have to be integer.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_scale">scale</code></td>
<td>
<p>0 (which is equivalent to GLM) or
higher integers possible (limit depends on sample size).</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_detail">detail</code></td>
<td>
<p>Remove smooth wavelets? If <code>TRUE</code>, only detail components are analyzed.
If set to <code>FALSE</code>, smooth and detail components are analyzed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_wavelet">wavelet</code></td>
<td>
<p>Type of wavelet: <code>haar</code> or <code>d4</code> or <code>la8</code></p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform: <code>dwt</code> or <code>modwt</code>.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_b.ini">b.ini</code></td>
<td>
<p>Initial parameter values. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_pad">pad</code></td>
<td>
<p>A list of parameters for padding wavelet coefficients.
</p>

<ul>
<li><p>padform - 0, 1, and 2 are possible.
<code>padform</code> is automatically set to
0 when either <code>level</code>=0 or
the <code>formula</code> includes an intercept and has a non-<code>gaussian</code>
<code>family</code>.
</p>

<ul>
<li><p>0 - Padding with 0s.
</p>
</li>
<li><p>1 - Padding with mean values.
</p>
</li>
<li><p>2 - Padding with mirror values.
</p>
</li></ul>

</li>
<li><p>padzone - Factor for expanding the padding zone
</p>
</li></ul>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.
</p>

<ul>
<li><p><code>eps</code> - Positive convergence tolerance. Smaller values of
<code>eps</code> provide better parameter estimates, but also reduce the probability
of the iterations converging. In case of issues with convergence, test larger
values of <code>eps</code>. Default is 10^-5.
</p>
</li>
<li><p><code>denom.eps</code> - Default is 10^-20.
</p>
</li>
<li><p><code>itmax</code> - Integer giving the maximum number of iterations.
Default is 200.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_moran.params">moran.params</code></td>
<td>
<p>A list of parameters for calculating Moran's I.
</p>

<ul>
<li><p><code>lim1</code> - Lower limit for first bin. Default is 0.
</p>
</li>
<li><p><code>increment</code> - Step size for calculating Moran's I. Default is 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scaleWMRR_+3A_trace">trace</code></td>
<td>
<p>A logical value indicating whether to print parameter estimates
to the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits generalized linear models while taking the
two-dimensional grid structure of
datasets into account. The following error distributions (in
conjunction with appropriate link functions) are allowed: <code>gaussian</code>,
<code>binomial</code>, or <code>poisson</code>. The model provides scale-specific
results for data sampled on a contiguous geographical area. The
dataset is assumed to be regular gridded and the grid cells are
assumed to be square. A function from the package 'waveslim' is used
for the wavelet transformations (Whitcher, 2005).
Furthermore, this function requires that <strong>all predictor variables
be continuous</strong>.
</p>


<h3>Value</h3>

<p>scaleWMRR returns a list containing the following elements
</p>

<dl>
<dt><code>call</code></dt><dd><p>Model call</p>
</dd>
<dt><code>b</code></dt><dd><p>Estimates of regression parameters</p>
</dd>
<dt><code>s.e.</code></dt><dd><p>Standard errors of the parameter estimates</p>
</dd>
<dt><code>z</code></dt><dd><p>Z values (or corresponding values for statistics)</p>
</dd>
<dt><code>p</code></dt><dd><p>p-values for each parameter estimate</p>
</dd>
<dt><code>df</code></dt><dd><p>Degrees of freedom</p>
</dd>
<dt><code>fitted</code></dt><dd><p>Fitted values</p>
</dd>
<dt><code>resid</code></dt><dd><p>Pearson residuals</p>
</dd>
<dt><code>converged</code></dt><dd><p>Logical value whether the procedure converged</p>
</dd>
<dt><code>trace</code></dt><dd><p>Logical. If TRUE:</p>
</dd>
</dl>

<ul>
<li><p><code>ac.glm</code> Autocorrelation of glm.residuals
</p>
</li>
<li><p><code>ac</code> Autocorrelation of wavelet.residuals
</p>
</li></ul>




<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>References</h3>

<p>Carl G, Doktor D, Schweiger O, Kuehn I (2016)
Assessing relative variable importance across different spatial
scales: a two-dimensional wavelet analysis.
Journal of Biogeography 43: 2502-2512.
</p>
<p>Whitcher, B. (2005) Waveslim: basic wavelet routines for one-, two-
and three-dimensional signal processing. R package version 1.5.
</p>


<h3>See Also</h3>

<p><span class="pkg">waveslim</span>,<code><a href="waveslim.html#topic+mra.2d">mra.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(carlinadata)
coords &lt;- carlinadata[ ,4:5]

## Not run: 

# scaleWMRR at scale = 0 is equivalent to GLM

ms0 &lt;- scaleWMRR(carlina.horrida ~ aridity + land.use,
                 family = "poisson",
                 data = carlinadata,
                 coord = coords,
                 scale = 0,
                 trace = TRUE)

# scale-specific regressions for detail components
ms1 &lt;- scaleWMRR(carlina.horrida ~ aridity + land.use,
                 family = "poisson",
                 data = carlinadata,
                 coord = coords,
                 scale = 1,
                 trace = TRUE)

ms2 &lt;- scaleWMRR(carlina.horrida ~ aridity + land.use,
                 family = "poisson",
                 data = carlinadata,
                 coord = coords,
                 scale = 2,
                 trace = TRUE)

ms3&lt;- scaleWMRR(carlina.horrida ~ aridity + land.use,
                 family = "poisson",
                 data = carlinadata,
                 coord = coords,
                 scale = 3,
                 trace = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='spind'>spind: Spatial Methods and Indices</h2><span id='topic+spind'></span>

<h3>Description</h3>

<p>The <code>spind</code> package provides convenient implementation of Generalized
estimating equations (GEEs) and Wavelet-revised models (WRMs)
in the context of spatial models. It also provides tools for
multi-model inference, stepwise model selection, and spatially
corrected model diagnostics. This help section provides brief descriptions
of each function and is organized by the type of model they apply to
or the scenarios in which you might use them. Of course, these are
recommendations - feel free to use them as you see fit. For a more
detailed description of the package and its functions, please see
the vignette <em>Intro to spind</em> (<code>browseVignettes('spind')</code>).
</p>


<h3>GEEs</h3>

<p>The <code>GEE</code> function fits spatial models using a generalized
estimating equation and a set of gridded data. The package
also includes S3 methods for <code>summary</code> and <code>predict</code>
so you can interact with these models in the same way you might
interact with a <code>glm</code> or <code>lm</code>.
</p>


<h3>WRMs</h3>

<p>The <code>WRM</code> function fits spatial models using a wavelet-revised
model and a set of gridded data. The package
also includes S3 methods for <code>summary</code> and <code>predict</code>
so you can interact with these models in the same way you might
interact with a <code>glm</code> or <code>lm</code>. There are also a number
of helper functions that help you fine tune the fitting process
that are specific to WRMs. Please see the documentation for
<code>WRM</code> for more details on those.
</p>
<p><code>WRM</code> also has a few other features specific to it. For example, if
you are interested in viewing the variance or covariance of your variables
as a function of <code>level</code>, <code>covar.plot</code> is useful. <code>upscale</code>
will plot your matrices as a function of <code>level</code> so you can examine the
effect of cluster resolution on your results.
</p>


<h3>Multi-model inference and stepwise model selection</h3>

<p><code>spind</code> includes a couple of functions to help you find the best fit
for your data. The first two are multimodel inference tools specific to GEEs
and WRMs and are called <code>mmiGEE</code> and <code>mmiWMRR</code>. These generate
outputs very similar to those from the <code>MuMIn</code> package. If you would
like to see how variable importance changes as a function of the <code>scale</code> of
the WMRR, you can call <code>rvi.plot</code>. This will generate a model selection
table for each degree of <code>level</code> (from 1 to <code>maxlevel</code>) and then
plot the weight of each variable as a function of <code>level</code>.
</p>
<p><code>spind</code> also includes a function for stepwise model selection that is
loosely based on <code><a href="stats.html#topic+step">step</a></code> and <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>. <code>step.spind</code> differs
from these in that it is specific to classes <code>WRM</code> and <code>GEE</code>. It
performs model selection using AIC or AICc for WRMs and QIC for GEEs.
</p>


<h3>Spatial indices of goodness of fit</h3>

<p>Finally, <code>spind</code> has a number of functions that provide spatially
corrected goodness of fit diagnostics for any type of model (i.e. they
are not specific to classes <code>WRM</code> or <code>GEE</code>). These first appeared
in <code>spind v1.0</code> and have not been updated in this release. The first two are
divided into whether or not they are threshold dependent or not. Threshold
dependent metrics can be calculated using <code>th.dep</code> and threshold
independent metrics can be calculated using <code>th.indep</code>.
</p>
<p><code>acfft</code> calculates spatial autocorrelation of residuals from a model
using <em>Moran's I</em>. You can set the number of distance bins you'd
like to examine using <code>dmax</code> argument and the size of those bins
using <code>lim1</code> and <code>lim2</code>.
</p>


<h3>Conclusion</h3>

<p>The vignette titled <em>Intro to spind</em> provides more information
on these functions and some example workflows that will demonstrate them
in greater depth than this document. Of course, if you have suggestions on
how to improve this document or any of the other ones in here, please don't
hesitate to contact us.
</p>

<hr>
<h2 id='step.spind'>Stepwise model selection for GEEs and WRMs</h2><span id='topic+step.spind'></span>

<h3>Description</h3>

<p>Stepwise model selection by AIC or AICc for WRMS
and QIC for GEEs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.spind(object, data, steps = NULL, trace = TRUE, AICc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step.spind_+3A_object">object</code></td>
<td>
<p>A model of class <code>WRM</code> or <code>GEE</code>.</p>
</td></tr>
<tr><td><code id="step.spind_+3A_data">data</code></td>
<td>
<p>The data used to fit that model.</p>
</td></tr>
<tr><td><code id="step.spind_+3A_steps">steps</code></td>
<td>
<p>Number of iterations the procedure should
go through before concluding. The default is to use the number of
variables as the number of iterations.</p>
</td></tr>
<tr><td><code id="step.spind_+3A_trace">trace</code></td>
<td>
<p>Should R print progress updates and the final, best model found
to the console? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="step.spind_+3A_aicc">AICc</code></td>
<td>
<p>Logical. In the case of model selection with <code>WRM</code>s,
should AICc be used to determine which model is best rather than AIC?
This argument is ignored for <code>GEE</code>s. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs stepwise variable elimination
for model comparison. Each iteration will try to find the best
combination of predictors for a given number of variables based
on AIC, AICc, or QIC, and then use that as the base model
for the next iteration until there are no more variables to eliminate.
Alternatively, it will terminate when reducing the number of variables
while respecting the model hierarchy no longer produces lower
information criterion values.
</p>


<h3>Value</h3>

<p>A list with components <code>model</code> and <code>table</code>.
<code>model</code> is always formula for the best model found by the procedure.
<code>table</code> is always a data frame, but the content varies for each type of
model.
For <code>WRM</code>'s, the columns
returned are
</p>

<ul>
<li><p><code>Deleted.Vars</code> Variables retained from the previous iteration
which were tested in the current iteration.
</p>
</li>
<li><p><code>LogLik</code> Log-likelihood of the model.
</p>
</li>
<li><p><code>AIC</code> AIC score for the model.
</p>
</li>
<li><p><code>AICc</code> AICc score for the model.
</p>
</li></ul>

<p>For <code>GEE</code>s:
</p>

<ul>
<li><p><code>Deleted.Vars</code> Variables retained from the previous iteration
which were tested in the current iteration.
</p>
</li>
<li><p><code>QIC</code> Quasi-information criterion of the model.
</p>
</li>
<li><p><code>Quasi.Lik</code> Quasi-likelihood of the model.
</p>
</li></ul>



<h3>Note</h3>

<p>Currently, the function only supports backwards model selection
(i.e. one must start with a full model and subtract variables).
Forward and both directions options may be added later.
</p>


<h3>Author(s)</h3>

<p>Sam Levin
</p>


<h3>References</h3>

<p>Hardin, J.W. &amp; Hilbe, J.M. (2003) Generalized Estimating Equations. Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qic.calc">qic.calc</a></code>, <code><a href="#topic+aic.calc">aic.calc</a></code>, <code><a href="stats.html#topic+add1">add1</a></code>,
<code><a href="stats.html#topic+step">step</a></code>, <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For demonstration only. We are artificially imposing a grid structure
# on data that is not actually spatial data

library(MASS)
data(birthwt)

x &lt;- rep(1:14, 14)
y &lt;- as.integer(gl(14, 14))
coords &lt;- cbind(x[-(190:196)], y[-(190:196)])

## Not run: 
formula &lt;- formula(low ~ age + lwt + race + smoke + ftv + bwt)

mgee &lt;- GEE(formula,
            family = "gaussian",
            data = birthwt,
            coord = coords,
            corstr = "fixed",
            scale.fix = TRUE)

ss &lt;- step.spind(mgee, birthwt)

best.mgee &lt;- GEE(ss$model,
                 family = "gaussian",
                 data = birthwt,
                 coord = coords,
                 corstr = "fixed",
                 scale.fix = TRUE)

summary(best.mgee, printAutoCorPars = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='th.dep'>Spatial threshold-dependent accuracy measures</h2><span id='topic+th.dep'></span>

<h3>Description</h3>

<p>Calculates spatially corrected, threshold-dependent metrics for
an observational data set and model predictions (Kappa and confusion matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>th.dep(data, coord, thresh = 0.5, spatial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="th.dep_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with two columns. The first column
should contain actual presence/absence data (binary, 0 or 1) and the
second column should contain model predictions of probability of
occurrence (numeric, between 0 and 1).</p>
</td></tr>
<tr><td><code id="th.dep_+3A_coord">coord</code></td>
<td>
<p>A data frame or matrix with two columns containing x,y
coordinates for each actual and predicted value. Coordinates must be
integer and consecutively numbered.</p>
</td></tr>
<tr><td><code id="th.dep_+3A_thresh">thresh</code></td>
<td>
<p>A cutoff value for classifying predictions as modeled
presences or modeled absences. Default is 0.5.</p>
</td></tr>
<tr><td><code id="th.dep_+3A_spatial">spatial</code></td>
<td>
<p>A logical indicating whether spatially corrected indices
(rather than classical indices) should be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>kappa</code></dt><dd><p>Kappa statistic</p>
</dd>
<dt><code>cm</code></dt><dd><p>Confusion matrix</p>
</dd>
<dt><code>sensitivity</code></dt><dd><p>Sensitivity</p>
</dd>
<dt><code>specificity</code></dt><dd><p>Specificity</p>
</dd>
<dt><code>actuals</code></dt><dd><p>Actual occurrence data or adjusted actual occurrence data</p>
</dd>
<dt><code>splitlevel.pred</code></dt><dd><p>Level splitting of predicted values</p>
</dd>
<dt><code>splitlevel.act</code></dt><dd><p>Level splitting of actuals or adjusted actuals</p>
</dd>
<dt><code>splitposition.pred</code></dt><dd><p>Position splitting of predicted values</p>
</dd>
<dt><code>splitposition.act</code></dt><dd><p>Position splitting of actuals or adjusted actuals</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>References</h3>

<p>Carl G, Kuehn I (2017) Spind: a package for computing
spatially corrected accuracy measures.
Ecography 40: 675-682. DOI: 10.1111/ecog.02593
</p>


<h3>See Also</h3>

<p><code><a href="#topic+th.indep">th.indep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hook)
data &lt;- hook[ ,1:2]
coord &lt;- hook[ ,3:4]
si1 &lt;- th.dep(data, coord, spatial = TRUE)
si1$kappa
si1$cm

</code></pre>

<hr>
<h2 id='th.indep'>Spatial threshold-independent accuracy measures</h2><span id='topic+th.indep'></span>

<h3>Description</h3>

<p>Calculates spatially corrected, threshold-independent metrics for
an observational data set and model predictions (AUC, ROC, max-TSS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>th.indep(data, coord, spatial = TRUE, plot.ROC = FALSE, customize_plot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="th.indep_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with two columns. The first column
should contain actual presence/absence data (binary, 0 or 1) and the
second column should contain model predictions of probability of
occurrence (numeric, between 0 and 1).</p>
</td></tr>
<tr><td><code id="th.indep_+3A_coord">coord</code></td>
<td>
<p>A data frame or matrix with two columns containing x,y
coordinates for each actual and predicted value. Coordinates must be
integer and consecutively numbered.</p>
</td></tr>
<tr><td><code id="th.indep_+3A_spatial">spatial</code></td>
<td>
<p>A logical value indicating whether spatial corrected
indices (rather than classical indices) should be computed.</p>
</td></tr>
<tr><td><code id="th.indep_+3A_plot.roc">plot.ROC</code></td>
<td>
<p>A logical indicating whether the ROC should be plotted. NOW DEPRECATED.</p>
</td></tr>
<tr><td><code id="th.indep_+3A_customize_plot">customize_plot</code></td>
<td>
<p>Additional plotting parameters passed to <code>ggplot</code>. NOW DEPRECATED.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>AUC</code></dt><dd><p>Area under curve</p>
</dd>
<dt><code>opt.thresh</code></dt><dd><p>optimal threshold for maximum TSS value</p>
</dd>
<dt><code>TSS</code></dt><dd><p>Maximum TSS value</p>
</dd>
<dt><code>sensitivity</code></dt><dd><p>Sensitivity</p>
</dd>
<dt><code>Specificity</code></dt><dd><p>Specificity</p>
</dd>
<dt><code>AUC.plot</code></dt><dd><p>A <code>ggplot</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>References</h3>

<p>Carl G, Kuehn I (2017) Spind: a package for computing spatially
corrected accuracy measures. Ecography 40: 675-682.
DOI: 10.1111/ecog.02593
</p>


<h3>See Also</h3>

<p><code><a href="#topic+th.dep">th.dep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hook)
data &lt;- hook[ ,1:2]
coord &lt;- hook[ ,3:4]
si2 &lt;- th.indep(data, coord, spatial = TRUE)
si2$AUC
si2$TSS
si2$opt.thresh
si2$plot

</code></pre>

<hr>
<h2 id='upscale'>Upscaling of smooth components</h2><span id='topic+upscale'></span>

<h3>Description</h3>

<p>The analysis is based a wavelet multiresolution analysis
using only smooth wavelet components.
It is a 2D analysis taking the grid structure and provides scale-specific
results for data sampled on a contiguous geographical area. The
dataset is assumed to be regular gridded and the grid cells are
assumed to be square.
The scale-dependent results are graphically displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upscale(
  f,
  coord,
  wavelet = "haar",
  wtrafo = "dwt",
  pad = mean(f),
  color.maps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upscale_+3A_f">f</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="upscale_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="upscale_+3A_wavelet">wavelet</code></td>
<td>
<p>Name of wavelet family. <code>haar</code>, <code>d4</code>, and <code>la8</code>.
are possible. <code>haar</code> is the default.</p>
</td></tr>
<tr><td><code id="upscale_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform. Either <code>dwt</code> or <code>modwt</code>.
<code>dwt</code> is the default.</p>
</td></tr>
<tr><td><code id="upscale_+3A_pad">pad</code></td>
<td>
<p>A numeric value for padding the matrix
into a bigger square. Default is set to mean(f).</p>
</td></tr>
<tr><td><code id="upscale_+3A_color.maps">color.maps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, produces colorful maps.
If <code>FALSE</code>, produces grayscale maps. Default is grayscale. NOW DEPRECATED,
color maps will not be produced in future versions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of plots showing the matrix image at each value for
<code>level</code>.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carlinadata)
coords &lt;- carlinadata[ ,4:5]

# Upscaling of smooth components
upscale(carlinadata$land.use, coord = coords)

</code></pre>

<hr>
<h2 id='wavecovar'>Wavelet covariance analysis</h2><span id='topic+wavecovar'></span>

<h3>Description</h3>

<p>Calculates the wavelet covariance based on a wavelet
multiresolution analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavecovar(f1, f2, coord, wavelet = "haar", wtrafo = "dwt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavecovar_+3A_f1">f1</code></td>
<td>
<p>A vector of length <em>n</em>.</p>
</td></tr>
<tr><td><code id="wavecovar_+3A_f2">f2</code></td>
<td>
<p>A vector of length <em>n</em>.</p>
</td></tr>
<tr><td><code id="wavecovar_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="wavecovar_+3A_wavelet">wavelet</code></td>
<td>
<p>Name of wavelet family. <code>haar</code>, <code>d4</code>, and <code>la8</code>.
are possible. <code>haar</code> is the default.</p>
</td></tr>
<tr><td><code id="wavecovar_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform. Either <code>dwt</code> or <code>modwt</code>.
<code>dwt</code> is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Wavelet covariance for <code>f1</code> and <code>f2</code>.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>See Also</h3>

<p><span class="pkg">waveslim</span>, <code><a href="#topic+WRM">WRM</a></code>, <code><a href="#topic+covar.plot">covar.plot</a></code>,
<code><a href="#topic+scaleWMRR">scaleWMRR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carlinadata)

coords &lt;- carlinadata[ ,4:5]
pc &lt;- covar.plot(carlina.horrida ~ aridity + land.use,
                 data = carlinadata,
                 coord = coords,
                 wavelet = 'd4',
                 wtrafo = 'modwt',
                 plot = 'covar')

pc$plot

</code></pre>

<hr>
<h2 id='wavevar'>Wavelet variance analysis</h2><span id='topic+wavevar'></span>

<h3>Description</h3>

<p>Calculates the wavelet variance based on a wavelet
multiresolution analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavevar(f, coord, wavelet = "haar", wtrafo = "dwt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavevar_+3A_f">f</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="wavevar_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="wavevar_+3A_wavelet">wavelet</code></td>
<td>
<p>Name of wavelet family. <code>haar</code>, <code>d4</code>, and <code>la8</code>.
are possible. <code>haar</code> is the default.</p>
</td></tr>
<tr><td><code id="wavevar_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform. Either <code>dwt</code> or <code>modwt</code>.
<code>dwt</code> is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Wavelet variance for <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl
</p>


<h3>See Also</h3>

<p><span class="pkg">waveslim</span>, <code><a href="#topic+WRM">WRM</a></code>, <code><a href="#topic+covar.plot">covar.plot</a></code>,
<code><a href="#topic+scaleWMRR">scaleWMRR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carlinadata)

coords &lt;- carlinadata[ ,4:5]
pv &lt;- covar.plot(carlina.horrida ~ aridity + land.use,
                 data = carlinadata,
                 coord = coords,
                 wavelet = 'd4',
                 wtrafo = 'modwt',
                 plot = 'var')

pv$plot

</code></pre>

<hr>
<h2 id='WRM'>Wavelet-revised models (WRMs)</h2><span id='topic+WRM'></span><span id='topic+plot.WRM'></span><span id='topic+summary.WRM'></span><span id='topic+predict.WRM'></span>

<h3>Description</h3>

<p>A wavelet-based method to remove spatial autocorrelation
in multiple linear regressions. Wavelet transforms are implemented using
<span class="pkg">waveslim</span> (Whitcher, 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WRM(
  formula,
  family,
  data,
  coord,
  level = 1,
  wavelet = "haar",
  wtrafo = "dwt",
  b.ini = NULL,
  pad = list(),
  control = list(),
  moran.params = list(),
  plot = FALSE,
  customize_plot = NULL
)

## S3 method for class 'WRM'
plot(x, ...)

## S3 method for class 'WRM'
summary(object, ...)

## S3 method for class 'WRM'
predict(object, newdata, sm = FALSE, newcoord = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WRM_+3A_formula">formula</code></td>
<td>
<p>Model formula. Variable names must match variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="WRM_+3A_family">family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, or <code>poisson</code> are supported.</p>
</td></tr>
<tr><td><code id="WRM_+3A_data">data</code></td>
<td>
<p>A data frame with variable names that match the variables specified in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="WRM_+3A_coord">coord</code></td>
<td>
<p>A matrix of two columns with corresponding cartesian
coordinates. Currently only supports integer coordinates.</p>
</td></tr>
<tr><td><code id="WRM_+3A_level">level</code></td>
<td>
<p>An integer specifying the degree of wavelet decomposition
</p>

<ul>
<li><p>0 - Without autocorrelation removal (equivalent to a GLM)
</p>
</li>
<li><p>1 - For best autocorrelation removal
</p>
</li>
<li><p>... - Higher integers possible. The limit depends on sample size
</p>
</li></ul>
</td></tr>
<tr><td><code id="WRM_+3A_wavelet">wavelet</code></td>
<td>
<p>Name of wavelet family. <code>haar</code>, <code>d4</code>, and <code>la8</code>.
are possible. <code>haar</code> is the default.</p>
</td></tr>
<tr><td><code id="WRM_+3A_wtrafo">wtrafo</code></td>
<td>
<p>Type of wavelet transform. Either <code>dwt</code> or <code>modwt</code>.
<code>dwt</code> is the default.</p>
</td></tr>
<tr><td><code id="WRM_+3A_b.ini">b.ini</code></td>
<td>
<p>Initial parameter values. Default is NULL.</p>
</td></tr>
<tr><td><code id="WRM_+3A_pad">pad</code></td>
<td>
<p>A list of parameters for padding wavelet coefficients.
</p>

<ul>
<li><p>padform - 0, 1, and 2 are possible.
<code>padform</code> is automatically set to
0 when either <code>level</code>=0 or
a <code>formula</code> including an intercept and a non-gaussian family
</p>

<ul>
<li><p>0 - Padding with 0s.
</p>
</li>
<li><p>1 - Padding with mean values.
</p>
</li>
<li><p>2 - Padding with mirror values.
</p>
</li></ul>

</li>
<li><p>padzone - Factor for expanding the padding zone
</p>
</li></ul>
</td></tr>
<tr><td><code id="WRM_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.
</p>

<ul>
<li><p><code>eps</code> - Positive convergence tolerance. Smaller values of
<code>eps</code> provide better parameter estimates, but also reduce the probability
of the iterations converging. In case of issues with convergence, test larger
values of <code>eps</code>. Default is 10^-5.
</p>
</li>
<li><p><code>denom.eps</code> - Default is 10^-20.
</p>
</li>
<li><p><code>itmax</code> - Integer giving the maximum number of iterations.
Default is 200.
</p>
</li></ul>
</td></tr>
<tr><td><code id="WRM_+3A_moran.params">moran.params</code></td>
<td>
<p>A list of parameters for calculating Moran's I.
</p>

<ul>
<li><p><code>lim1</code> - Lower limit for first bin. Default is 0.
</p>
</li>
<li><p><code>increment</code> - Step size for calculating Moran's I. Default is 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="WRM_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether to plot autocorrelation of
residuals by distance bin. NOW DEPRECATED in favor of <code>plot.WRM</code> method.</p>
</td></tr>
<tr><td><code id="WRM_+3A_customize_plot">customize_plot</code></td>
<td>
<p>Additional plotting parameters passed to <code>ggplot</code>.
NOW DEPRECATED in favor of <code>plot.WRM</code> method.</p>
</td></tr>
<tr><td><code id="WRM_+3A_x">x</code></td>
<td>
<p>An object of class <code>GEE</code> or <code>WRM</code></p>
</td></tr>
<tr><td><code id="WRM_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="WRM_+3A_object">object</code></td>
<td>
<p>An object of class <code>WRM</code></p>
</td></tr>
<tr><td><code id="WRM_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing variables used to make predictions.</p>
</td></tr>
<tr><td><code id="WRM_+3A_sm">sm</code></td>
<td>
<p>Logical. Should part of smooth components be included?</p>
</td></tr>
<tr><td><code id="WRM_+3A_newcoord">newcoord</code></td>
<td>
<p>New coordinates corresponding to observations in <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WRM can be used to fit linear models for response vectors of different
distributions: <code>gaussian</code>, <code>binomial</code>, or <code>poisson</code>.
As a spatial model, it is a generalized linear model in which the residuals
may be autocorrelated. It corrects for  2-dimensional residual
autocorrelation for regular gridded data sets using the wavelet
decomposition technique. The grid cells are assumed to be square.
Furthermore, this function requires that <strong>all predictor variables
be continuous</strong>.
</p>


<h3>Value</h3>

<p>An object of class <code>WRM</code>. This consists of a list with the
following elements:
</p>

<dl>
<dt><code>call</code></dt><dd><p>Call</p>
</dd>
<dt><code>formula</code></dt><dd><p>Model formula</p>
</dd>
<dt><code>family</code></dt><dd><p>Family</p>
</dd>
<dt><code>coord</code></dt><dd><p>Coordinates used in the model</p>
</dd>
<dt><code>b</code></dt><dd><p>Estimate of regression parameters</p>
</dd>
<dt><code>s.e.</code></dt><dd><p>Standard errors</p>
</dd>
<dt><code>z</code></dt><dd><p>Depending on the <code>family</code>, either a <em>z</em> or <em>t</em> value</p>
</dd>
<dt><code>p</code></dt><dd><p><em>p</em>-values</p>
</dd>
<dt><code>fitted</code></dt><dd><p>Fitted values from the model</p>
</dd>
<dt><code>resid</code></dt><dd><p>Pearson residuals</p>
</dd>
<dt><code>b.sm</code></dt><dd><p>Parameter estimates of neglected smooth part</p>
</dd>
<dt><code>fitted.sm</code></dt><dd><p>Fitted values of neglected smooth part</p>
</dd>
<dt><code>level</code></dt><dd><p>Selected level of wavelet decomposition</p>
</dd>
<dt><code>wavelet</code></dt><dd><p>Selected wavelet</p>
</dd>
<dt><code>wtrafo</code></dt><dd><p>Selected wavelet transformation</p>
</dd>
<dt><code>padzone</code></dt><dd><p>Selected padding zone expansion factor</p>
</dd>
<dt><code>padform</code></dt><dd><p>Selected matrix padding type</p>
</dd>
<dt><code>n.eff</code></dt><dd><p>Effective number of observations</p>
</dd>
<dt><code>AIC</code></dt><dd><p>Akaike information criterion</p>
</dd>
<dt><code>AICc</code></dt><dd><p>AIC score corrected for small sample sizes</p>
</dd>
<dt><code>LogLik</code></dt><dd><p>Log likelihood of the model</p>
</dd>
<dt><code>ac.glm</code></dt><dd><p>Autocorrelation of GLM residuals</p>
</dd>
<dt><code>ac.wrm</code></dt><dd><p>Autocorrelation of WRM residuals</p>
</dd>
<dt><code>b.ini</code></dt><dd><p>Initial parameter values</p>
</dd>
<dt><code>control</code></dt><dd><p>Control parameters for the fitting process</p>
</dd>
<dt><code>moran.params</code></dt><dd><p>Parameters for calculating Moran's I</p>
</dd>
<dt><code>pad</code></dt><dd><p>List of parameters for padding wavelet coefficients</p>
</dd>
<dt><code>plot</code></dt><dd><p>An object of class <code>ggplot</code> containing information
on the autocorrelation of residuals from the fitted <code>WRM</code> and a
<code>GLM</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>For those interested in multimodel inference approaches, <code>WRM</code> with
<code>level = 1</code> is identical to <code>mmiWMRR</code> with <code>scale = 1</code>.
</p>


<h3>Author(s)</h3>

<p>Gudrun Carl, Sam Levin
</p>


<h3>References</h3>

<p>Carl, G., Kuehn, I. (2010): A wavelet-based extension of generalized
linear models to remove the effect of spatial autocorrelation.
Geographical Analysis 42 (3), 323 - 337
</p>
<p>Whitcher, B. (2005) Waveslim: basic wavelet routines for one-, two-
and three-dimensional signal processing. R package version 1.5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmiWMRR">mmiWMRR</a></code>, <code><a href="#topic+predict.WRM">predict.WRM</a></code>, <code><a href="#topic+summary.WRM">summary.WRM</a></code>,
<code><a href="#topic+aic.calc">aic.calc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(musdata)
coords &lt;- musdata[,4:5]

## Not run: 
mwrm &lt;- WRM(musculus ~ pollution + exposure,
            family = "poisson",
            data = musdata,
            coord = coords,
            level = 1)

pred &lt;- predict(mwrm, newdata = musdata)

summary(mwrm)

plot(mwrm)

library(ggplot2)

my_wrm_plot &lt;- mwrm$plot

# increase axis text size
print(my_wrm_plot + ggplot2::theme(axis.text = element_text(size = 15)))


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
