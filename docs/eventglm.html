<!DOCTYPE html><html><head><title>Help for package eventglm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eventglm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_ipcw_pos'><p>Compute inverse probability of censoring weights pseudo observations</p></a></li>
<li><a href='#check_mod_cens'><p>Error check censoring model</p></a></li>
<li><a href='#colon'><p>Chemotherapy for Stage B/C colon cancer</p></a></li>
<li><a href='#confint.pseudoglm'><p>Confidence Intervals for pseudoglm Model Parameters</p></a></li>
<li><a href='#cumincglm'><p>Generalized linear models for cumulative incidence</p></a></li>
<li><a href='#eventglm'><p>Regression Models for Event History Outcomes</p></a></li>
<li><a href='#get_pseudo_cuminc'><p>Utility to get jackknife pseudo observations of cumulative incidence</p></a></li>
<li><a href='#get_pseudo_rmean'><p>Utility to get jackknife pseudo observations of restricted mean</p></a></li>
<li><a href='#jackknife.competing.risks2'><p>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</p></a></li>
<li><a href='#jackknife.survival2'><p>Compute jackknife pseudo-observations of the survival function</p></a></li>
<li><a href='#leaveOneOut.competing.risks'><p>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</p></a></li>
<li><a href='#leaveOneOut.competing.risks2'><p>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</p></a></li>
<li><a href='#leaveOneOut.survival'><p>Compute leave one out jackknife contributions of the survival function</p></a></li>
<li><a href='#leaveOneOut.survival2'><p>Compute leave one out jackknife contributions of the survival function</p></a></li>
<li><a href='#match_cause'><p>Match cause specification against model response</p></a></li>
<li><a href='#mgus2'><p>Monoclonal gammopathy data</p></a></li>
<li><a href='#print.pseudoglm'><p>Print method for pseudoglm</p></a></li>
<li><a href='#pseudo_aareg'><p>Compute censoring weighted pseudo observations</p></a></li>
<li><a href='#pseudo_coxph'><p>Compute censoring weighted pseudo observations</p></a></li>
<li><a href='#pseudo_independent'><p>Compute pseudo observations under independent censoring</p></a></li>
<li><a href='#pseudo_rmst2'><p>Compute pseudo-observations for the restricted mean survival</p></a></li>
<li><a href='#pseudo_stratified'><p>Compute pseudo observations using stratified jackknife</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.pseudoglm'><p>Pseudo-observation scaled residuals</p></a></li>
<li><a href='#rmeanglm'><p>Generalized linear models for the restricted mean survival</p></a></li>
<li><a href='#summary.pseudoglm'><p>Summary method</p></a></li>
<li><a href='#vcov.pseudoglm'><p>Compute covariance matrix of regression coefficient estimates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Models for Event History Outcomes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-26</td>
</tr>
<tr>
<td>Description:</td>
<td>A user friendly, easy to understand way of doing event
    history regression for marginal estimands of interest,
    including the cumulative incidence and the restricted mean
    survival, using the pseudo observation framework for 
    estimation. For a review of the methodology, see Andersen and
    Pohar Perme (2010) &lt;<a href="https://doi.org/10.1177%2F0962280209105020">doi:10.1177/0962280209105020</a>&gt; or Sachs 
    and Gabriel (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v102.i09">doi:10.18637/jss.v102.i09</a>&gt;. The
    interface uses the well known formulation of a generalized
    linear model and allows for features including plotting of 
    residuals, the use of sampling weights, and corrected
    variance estimation. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sachsmc.github.io/eventglm/">https://sachsmc.github.io/eventglm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sachsmc/eventglm/issues/">https://github.com/sachsmc/eventglm/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, prodlim, knitr, rmarkdown, rio, data.table</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, sandwich, stats, geepack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-26 10:35:20 UTC; micsac</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael C Sachs [aut, cre],
  Erin E Gabriel [aut],
  Morten Overgaard [ctb] (Corrected variance calculation),
  Thomas A Gerds [ctb] (Fast computation of leave one out cumulative
    incidence),
  Terry Therneau [ctb] (Restricted mean computation)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael C Sachs &lt;sachsmc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-26 11:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_ipcw_pos'>Compute inverse probability of censoring weights pseudo observations</h2><span id='topic+calc_ipcw_pos'></span>

<h3>Description</h3>

<p>Compute inverse probability of censoring weights pseudo observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ipcw_pos(mr, time, causen, type, ipcw.method, Gi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ipcw_pos_+3A_mr">mr</code></td>
<td>
<p>Model response object returned by <a href="#topic+Surv">Surv</a></p>
</td></tr>
<tr><td><code id="calc_ipcw_pos_+3A_time">time</code></td>
<td>
<p>Max time</p>
</td></tr>
<tr><td><code id="calc_ipcw_pos_+3A_causen">causen</code></td>
<td>
<p>Cause of interest (numeric)</p>
</td></tr>
<tr><td><code id="calc_ipcw_pos_+3A_type">type</code></td>
<td>
<p>Outcome type, &quot;cuminc&quot;, &quot;survival&quot;, or &quot;rmean&quot;</p>
</td></tr>
<tr><td><code id="calc_ipcw_pos_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>&quot;binder&quot; or &quot;hajek&quot;</p>
</td></tr>
<tr><td><code id="calc_ipcw_pos_+3A_gi">Gi</code></td>
<td>
<p>vector of estimated censoring probabilities</p>
</td></tr>
</table>

<hr>
<h2 id='check_mod_cens'>Error check censoring model</h2><span id='topic+check_mod_cens'></span>

<h3>Description</h3>

<p>Censoring model must take the same named arguments as the predefined modules
(though they do not all have to be used), and return a vector of pseudo observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_mod_cens(model.censoring)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_mod_cens_+3A_model.censoring">model.censoring</code></td>
<td>
<p>censoring model specification as character or function</p>
</td></tr>
</table>

<hr>
<h2 id='colon'>Chemotherapy for Stage B/C colon cancer</h2><span id='topic+colon'></span>

<h3>Description</h3>

<p>These are data from one of the first successful trials of adjuvant
chemotherapy for colon cancer. Levamisole is a low-toxicity compound
previously used to treat worm infestations in animals; 5-FU is a moderately
toxic (as these things go) chemotherapy agent. There are only one record per patient for the death outcome (or censoring). This is redistributed from
the survival package, with a small modification to include only the death outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colon
</code></pre>


<h3>Format</h3>

<p>A data frame with 929 rows and 17 variables:
</p>

<dl>
<dt>id</dt><dd><p>id</p>
</dd>
<dt>study</dt><dd><p>1 for all patients</p>
</dd>
<dt>rx</dt><dd><p>Treatment - Obs(ervation), Lev(amisole), Lev(amisole)+5-FU</p>
</dd>
<dt>sex</dt><dd><p>1=male</p>
</dd>
<dt>age</dt><dd><p>in years</p>
</dd>
<dt>obstruct</dt><dd><p>obstruction of colon by tumour</p>
</dd>
<dt>perfor</dt><dd><p>perforation of colon</p>
</dd>
<dt>adhere</dt><dd><p>adherence to nearby organs</p>
</dd>
<dt>nodes</dt><dd><p>number of lymph nodes with detectable cancer</p>
</dd>
<dt>time</dt><dd><p>days until death or censoring</p>
</dd>
<dt>status</dt><dd><p>censoring status</p>
</dd>
<dt>differ</dt><dd><p>differentiation of tumour (1=well, 2=moderate, 3=poor)</p>
</dd>
<dt>extent</dt><dd><p>Extent of local spread (1=submucosa, 2=muscle, 3=serosa, 4=contiguous structures)</p>
</dd>
<dt>surg</dt><dd><p>time from surgery to registration (0=short, 1=long)</p>
</dd>
<dt>node4</dt><dd><p>more than 4 positive lymph nodes</p>
</dd>
<dt>etype</dt><dd><p>event type: 1=recurrence,2=death</p>
</dd>
<dt>event</dt><dd><p>event indicator: censored, death</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="survival.html#topic+colon">colon</a>
</p>

<hr>
<h2 id='confint.pseudoglm'>Confidence Intervals for pseudoglm Model Parameters</h2><span id='topic+confint.pseudoglm'></span>

<h3>Description</h3>

<p>Computes Wald confidence intervals for one or more parameters in a fitted model. Users can specify the type of variance estimate used, with the default being the robust sandwich variance estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudoglm'
confint(object, parm, level = 0.95, type = "robust", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.pseudoglm_+3A_object">object</code></td>
<td>
<p>A fitted model object from <a href="#topic+cumincglm">cumincglm</a> or <a href="#topic+rmeanglm">rmeanglm</a></p>
</td></tr>
<tr><td><code id="confint.pseudoglm_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.pseudoglm_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.pseudoglm_+3A_type">type</code></td>
<td>
<p>The type of variance estimate to use, see <a href="#topic+vcov.pseudoglm">vcov.pseudoglm</a></p>
</td></tr>
<tr><td><code id="confint.pseudoglm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter. These will be labelled as (1-level)/2 and 1 - (1-level)/2 in 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumincipcw &lt;- cumincglm(survival::Surv(etime, event) ~ age + sex,
         time = 200, cause = "pcm", link = "identity",
         model.censoring = "independent", data = mgus2)
confint(cumincipcw)

</code></pre>

<hr>
<h2 id='cumincglm'>Generalized linear models for cumulative incidence</h2><span id='topic+cumincglm'></span>

<h3>Description</h3>

<p>Using pseudo observations for the cumulative incidence, this function then
runs a generalized linear model and estimates the parameters representing
contrasts in the cumulative incidence at a particular set of times (specified
by the <code>time</code> argument) across covariate values. The link function can
be &quot;identity&quot; for estimating differences in the cumulative incidence, &quot;log&quot;
for estimating ratios, and any of the other link functions supported by
<a href="stats.html#topic+quasi">quasi</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumincglm(
  formula,
  time,
  cause = 1,
  link = "identity",
  model.censoring = "independent",
  formula.censoring = NULL,
  ipcw.method = "binder",
  data,
  survival = FALSE,
  weights,
  subset,
  na.action,
  offset,
  control = list(...),
  model = FALSE,
  x = TRUE,
  y = TRUE,
  singular.ok = TRUE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumincglm_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates. If there are multiple time points, the special term &quot;tve(.)&quot;
can be used to specify that the effect of the variable inside the
parentheses will be time varying. In the output this will be represented
as the interaction between the time points and the variable.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_time">time</code></td>
<td>
<p>Numeric vector specifying the times at which the cumulative
incidence or survival probability effect estimates are desired.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_link">link</code></td>
<td>
<p>Link function for the cumulative incidence regression model.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_model.censoring">model.censoring</code></td>
<td>
<p>Type of model for the censoring distribution. Options
are &quot;stratified&quot;, which computes the pseudo-observations stratified on a
set of categorical covariates, &quot;aareg&quot; for Aalen's additive hazards model,
and &quot;coxph&quot; for Cox's proportional hazards model. With those options, we
assume that the time to event and event indicator are conditionally
independent of the censoring time, and that the censoring model is
correctly specified. If &quot;independent&quot;, we assume completely independent
censoring, i.e., that the time to event and covariates are independent of
the censoring time. the censoring time is independent of the covariates in
the model. Can also be a custom function, see Details and the &quot;Extending
eventglm&quot; vignette.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>A one sided formula (e.g., <code>~ x1 + x2</code>)
specifying the model for the censoring distribution. If NULL, uses the same
mean model as for the outcome.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Which method to use for calculation of inverse probability
of censoring weighted pseudo observations. &quot;binder&quot; the default, uses the
number of observations as the denominator, while the &quot;hajek&quot; method uses
the sum of the weights as the denominator.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_survival">survival</code></td>
<td>
<p>Set to TRUE to use survival (one minus the cumulative
incidence) as the outcome. Not available for competing risks models.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be NULL or a numeric vector.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of
<a href="base.html#topic+options">options</a>, and is <a href="stats.html#topic+na.fail">na.fail</a> if that is unset. The
'factory-fresh' default is <a href="stats.html#topic+na.omit">na.omit</a>. Another possible value is
NULL, no action. Value <a href="stats.html#topic+na.exclude">na.exclude</a> can be useful.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be
included in the linear predictor during fitting. This should be NULL or a
numeric vector of length equal to the number of cases. One or more
<a href="stats.html#topic+offset">offset</a> terms can be included in the formula instead or as
well, and if more than one is specified their sum is used. See
<a href="stats.html#topic+model.offset">model.offset</a>. If length(time) &gt; 1, then any offset terms must
appear in the formula.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. This
is passed to <a href="stats.html#topic+glm.control">glm.control</a>.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether model frame should be
included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_x">x</code></td>
<td>
<p>logical value indicating whether the model matrix used in the
fitting process should be returned as components of the returned value.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_y">y</code></td>
<td>
<p>logical value indicating whether the response vector
(pseudo-observations) used in the fitting process should be returned as
components of the returned value.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical; if FALSE a singular fit is an error.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of
<a href="stats.html#topic+model.matrix.default">model.matrix.default</a>.</p>
</td></tr>
<tr><td><code id="cumincglm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="stats.html#topic+glm.fit">glm.fit</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument &quot;model.censoring&quot; determines how the pseudo
observations are calculated. This can be the name of a function or the
function itself, which must have arguments &quot;formula&quot;, &quot;time&quot;, &quot;cause&quot;,
&quot;data&quot;, &quot;type&quot;, &quot;formula.censoring&quot;, and &quot;ipcw.method&quot;. If it is the name
of a function, this code will look for a function with the prefix &quot;pseudo_&quot;
first, to avoid clashes with related methods such as coxph. The function
then must return a vector of pseudo observations, one for each subject in
data which are used in subsequent calculations. For examples of the
implementation, see the &quot;pseudo-modules.R&quot; file, or the vignette &quot;Extending
eventglm&quot;.
</p>


<h3>Value</h3>

<p>A pseudoglm object, with its own methods for print, summary, and
vcov. It inherits from glm, so predict and other glm methods are supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    cumincipcw &lt;- cumincglm(Surv(etime, event) ~ age + sex,
         time = 200, cause = "pcm", link = "identity",
         model.censoring = "independent", data = mgus2)
# stratified on only the categorical covariate
     cumincipcw2 &lt;- cumincglm(Surv(etime, event) ~ age + sex,
                         time = 200, cause = "pcm", link = "identity",
                         model.censoring = "stratified",
                         formula.censoring = ~ sex, data = mgus2)
# multiple time points
cuminct2 &lt;- cumincglm(Surv(etime, event) ~ age + sex,
         time = c(50, 100, 200), cause = "pcm", link = "identity",
         model.censoring = "independent", data = mgus2)
 cuminct3 &lt;- cumincglm(Surv(etime, event) ~ age + tve(sex),
         time = c(50, 100, 200), cause = "pcm", link = "identity",
         model.censoring = "independent", data = mgus2)
</code></pre>

<hr>
<h2 id='eventglm'>Regression Models for Event History Outcomes</h2><span id='topic+eventglm'></span>

<h3>Description</h3>

<p>A user friendly, easy to understand way of doing event history regression
for marginal estimands of interest, including the cumulative incidence and the
restricted mean survival, using the pseudo observation framework for estimation.
The interface uses the well known formulation of a generalized linear model and allows
for features including plotting of residuals, the use of sampling weights, and corrected
variance estimation.
</p>


<h3>References</h3>

<p>Sachs MC, Gabriel EE (2022). &quot;Event History Regression with Pseudo-Observations: Computational Approaches and an Implementation in R.&quot; Journal of Statistical Software, 102(9), 1-34. &lt;doi:10.18637/jss.v102.i09&gt;
</p>

<hr>
<h2 id='get_pseudo_cuminc'>Utility to get jackknife pseudo observations of cumulative incidence</h2><span id='topic+get_pseudo_cuminc'></span>

<h3>Description</h3>

<p>Utility to get jackknife pseudo observations of cumulative incidence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pseudo_cuminc(marginal.estimate, time, cause, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pseudo_cuminc_+3A_marginal.estimate">marginal.estimate</code></td>
<td>
<p>A survfit object with no covariates</p>
</td></tr>
<tr><td><code id="get_pseudo_cuminc_+3A_time">time</code></td>
<td>
<p>Time at which to calculate the obs</p>
</td></tr>
<tr><td><code id="get_pseudo_cuminc_+3A_cause">cause</code></td>
<td>
<p>which cause</p>
</td></tr>
<tr><td><code id="get_pseudo_cuminc_+3A_mr">mr</code></td>
<td>
<p>Model response of the survival object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudo-observations
</p>

<hr>
<h2 id='get_pseudo_rmean'>Utility to get jackknife pseudo observations of restricted mean</h2><span id='topic+get_pseudo_rmean'></span>

<h3>Description</h3>

<p>Utility to get jackknife pseudo observations of restricted mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pseudo_rmean(marginal.estimate, time, cause, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pseudo_rmean_+3A_marginal.estimate">marginal.estimate</code></td>
<td>
<p>A survfit object with no covariates</p>
</td></tr>
<tr><td><code id="get_pseudo_rmean_+3A_time">time</code></td>
<td>
<p>Time at which to calculate the obs</p>
</td></tr>
<tr><td><code id="get_pseudo_rmean_+3A_cause">cause</code></td>
<td>
<p>which cause</p>
</td></tr>
<tr><td><code id="get_pseudo_rmean_+3A_mr">mr</code></td>
<td>
<p>Model response of the survival object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudo-observations
</p>

<hr>
<h2 id='jackknife.competing.risks2'>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</h2><span id='topic+jackknife.competing.risks2'></span>

<h3>Description</h3>

<p>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife.competing.risks2(object, times, cause, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackknife.competing.risks2_+3A_object">object</code></td>
<td>
<p>A survfit object, with competing events</p>
</td></tr>
<tr><td><code id="jackknife.competing.risks2_+3A_times">times</code></td>
<td>
<p>Times at which the cumulative incidence is computed, must be length 1</p>
</td></tr>
<tr><td><code id="jackknife.competing.risks2_+3A_cause">cause</code></td>
<td>
<p>Value indicating for which cause the cumulative incidence is to be computed, it must match one of the values available in object (see example)</p>
</td></tr>
<tr><td><code id="jackknife.competing.risks2_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1, ..., k = event types)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed pseudo-observations of the cause-specific cumulative incidence at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.cuminc &lt;- survival::survfit(survival::Surv(etime, event) ~ 1, data = mgus2)
mrs &lt;- with(mgus2, Surv(etime, event))
pseudo.obs &lt;- jackknife.competing.risks2(sfit.cuminc, times = 200, cause = "pcm", mrs)
mean(pseudo.obs)
# agrees with
summary(sfit.cuminc, times = 200)
</code></pre>

<hr>
<h2 id='jackknife.survival2'>Compute jackknife pseudo-observations of the survival function</h2><span id='topic+jackknife.survival2'></span>

<h3>Description</h3>

<p>Compute jackknife pseudo-observations of the survival function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife.survival2(object, times, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackknife.survival2_+3A_object">object</code></td>
<td>
<p>A survfit object, with a single event (no competing risks)</p>
</td></tr>
<tr><td><code id="jackknife.survival2_+3A_times">times</code></td>
<td>
<p>Times at which the survival is computed, must be length 1</p>
</td></tr>
<tr><td><code id="jackknife.survival2_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1 = event)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed estimates of survival at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.surv &lt;- survival::survfit(survival::Surv(time, status) ~ 1, data = colon)
mrs &lt;- with(colon, Surv(time, status))
pseudo.obs &lt;- jackknife.survival2(sfit.surv, times = 1000, mrs)
mean(pseudo.obs)
# agrees with
summary(sfit.surv, times = 1000)
</code></pre>

<hr>
<h2 id='leaveOneOut.competing.risks'>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</h2><span id='topic+leaveOneOut.competing.risks'></span>

<h3>Description</h3>

<p>This version computes them for all times up to <code>times</code>, for the restricted mean lifetime lost
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut.competing.risks(object, times, cause, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut.competing.risks_+3A_object">object</code></td>
<td>
<p>A survfit object, with competing events</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks_+3A_times">times</code></td>
<td>
<p>Times at which the cumulative incidence is computed, must be length 1</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks_+3A_cause">cause</code></td>
<td>
<p>Value indicating for which cause the cumulative incidence is to be computed, it must match one of the values available in object (see example)</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1, ..., k = event types)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed values of the cause-specific cumulative incidence at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.cuminc &lt;- survival::survfit(survival::Surv(etime, event) ~ 1, data = mgus2)
mrs &lt;- with(mgus2, Surv(etime, event))
jackvals &lt;- leaveOneOut.competing.risks(sfit.cuminc, times = 200, cause = "pcm", mrs)
</code></pre>

<hr>
<h2 id='leaveOneOut.competing.risks2'>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks</h2><span id='topic+leaveOneOut.competing.risks2'></span>

<h3>Description</h3>

<p>Compute jackknife pseudo-observations of the cause-specific cumulative incidence for competing risks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut.competing.risks2(object, times, cause, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut.competing.risks2_+3A_object">object</code></td>
<td>
<p>A survfit object, with competing events</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks2_+3A_times">times</code></td>
<td>
<p>Times at which the cumulative incidence is computed, must be length 1</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks2_+3A_cause">cause</code></td>
<td>
<p>Value indicating for which cause the cumulative incidence is to be computed, it must match one of the values available in object (see example)</p>
</td></tr>
<tr><td><code id="leaveOneOut.competing.risks2_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1, ..., k = event types)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed values of the cause-specific cumulative incidence at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.cuminc &lt;- survival::survfit(survival::Surv(etime, event) ~ 1, data = mgus2)
mrs &lt;- with(mgus2, Surv(etime, event))
jackvals &lt;- leaveOneOut.competing.risks2(sfit.cuminc, times = 200, cause = "pcm", mrs)
</code></pre>

<hr>
<h2 id='leaveOneOut.survival'>Compute leave one out jackknife contributions of the survival function</h2><span id='topic+leaveOneOut.survival'></span>

<h3>Description</h3>

<p>For each subject, the survival function is recomputed leaving that subject out.
This one does the calculation for all observed times, for calculation of the restricted mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut.survival(object, times, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut.survival_+3A_object">object</code></td>
<td>
<p>A survfit object, with a single event (no competing risks)</p>
</td></tr>
<tr><td><code id="leaveOneOut.survival_+3A_times">times</code></td>
<td>
<p>Compute values at observed times up to and including this time</p>
</td></tr>
<tr><td><code id="leaveOneOut.survival_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1 = event)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed values of survival at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.surv &lt;- survival::survfit(survival::Surv(time, status) ~ 1, data = colon)
mrs &lt;- with(colon, Surv(time, status))
jackvals &lt;- leaveOneOut.survival(sfit.surv, 1000, mrs)
</code></pre>

<hr>
<h2 id='leaveOneOut.survival2'>Compute leave one out jackknife contributions of the survival function</h2><span id='topic+leaveOneOut.survival2'></span>

<h3>Description</h3>

<p>For each subject, the survival function is recomputed leaving that subject out.
This is the workhorse for <a href="#topic+jackknife.survival2">jackknife.survival2</a> and will generally not
be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut.survival2(object, times, mr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut.survival2_+3A_object">object</code></td>
<td>
<p>A survfit object, with a single event (no competing risks)</p>
</td></tr>
<tr><td><code id="leaveOneOut.survival2_+3A_times">times</code></td>
<td>
<p>Times at which the survival is computed, must be length 1</p>
</td></tr>
<tr><td><code id="leaveOneOut.survival2_+3A_mr">mr</code></td>
<td>
<p>Model response, the result of a call to Surv, or a matrix with two columns: &quot;time&quot; (observed follow up time) and &quot;status&quot; (0 = censored, 1 = event)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknifed values of survival at time times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfit.surv &lt;- survival::survfit(survival::Surv(time, status) ~ 1, data = colon)
mrs &lt;- with(colon, Surv(time, status))
jackvals &lt;- leaveOneOut.survival2(sfit.surv, times = 1000, mrs)
</code></pre>

<hr>
<h2 id='match_cause'>Match cause specification against model response</h2><span id='topic+match_cause'></span>

<h3>Description</h3>

<p>Match cause specification against model response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_cause(mr, cause)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_cause_+3A_mr">mr</code></td>
<td>
<p>model.response as returned by <a href="#topic+Surv">Surv</a></p>
</td></tr>
<tr><td><code id="match_cause_+3A_cause">cause</code></td>
<td>
<p>Numeric or string indicating the cause of interest</p>
</td></tr>
</table>

<hr>
<h2 id='mgus2'>Monoclonal gammopathy data</h2><span id='topic+mgus2'></span>

<h3>Description</h3>

<p>Natural history of 1341 sequential patients with monoclonal gammopathy of undetermined significance (MGUS). This is a superset of the mgus data, at a later point in the accrual process. This dataset is redistributed from the survival package with an added competing risks event indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgus2
</code></pre>


<h3>Format</h3>

<p>A data frame with 1384 observations on the following 10 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>subject identifier</p>
</dd>
<dt><code>age</code></dt><dd><p>age at diagnosis, in years</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>F</code> <code>M</code></p>
</dd>
<dt><code>dxyr</code></dt><dd><p>year of diagnosis</p>
</dd>
<dt><code>hgb</code></dt><dd><p>hemoglobin</p>
</dd>
<dt><code>creat</code></dt><dd><p>creatinine</p>
</dd>
<dt><code>mspike</code></dt><dd><p>size of the monoclonal serum spike</p>
</dd>
<dt><code>ptime</code></dt><dd><p>time until progression to a plasma cell
malignancy (PCM) or last contact, in months</p>
</dd>
<dt><code>pstat</code></dt><dd><p>occurrence of PCM: 0=no, 1=yes </p>
</dd>
<dt><code>futime</code></dt><dd><p>time until death or last contact, in months</p>
</dd>
<dt><code>death</code></dt><dd><p>occurrence of death: 0=no, 1=yes</p>
</dd>
<dt><code>etime</code></dt><dd><p>time until either death, pcm, or last contact</p>
</dd>
<dt><code>event</code></dt><dd><p>factor indicating which event occurred first</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="survival.html#topic+mgus2">mgus2</a>
</p>

<hr>
<h2 id='print.pseudoglm'>Print method for pseudoglm</h2><span id='topic+print.pseudoglm'></span>

<h3>Description</h3>

<p>Print method for pseudoglm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudoglm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pseudoglm_+3A_x">x</code></td>
<td>
<p>A pseudoglm object, as returned by <a href="#topic+cumincglm">cumincglm</a> or <a href="#topic+rmeanglm">rmeanglm</a></p>
</td></tr>
<tr><td><code id="print.pseudoglm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits</p>
</td></tr>
<tr><td><code id="print.pseudoglm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='pseudo_aareg'>Compute censoring weighted pseudo observations</h2><span id='topic+pseudo_aareg'></span>

<h3>Description</h3>

<p>Assuming that the censoring depends on covariates,
the pseudo observations are calculated with the inverse probability of
censoring weighted approach, where the censoring probabilities are estimated
using Aalen's additive hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_aareg(
  formula,
  time,
  cause = 1,
  data,
  type = c("cuminc", "survival", "rmean"),
  formula.censoring = NULL,
  ipcw.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_aareg_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the outcome model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates.</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_time">time</code></td>
<td>
<p>Numeric constant specifying the time at which the cumulative
incidence or survival probability effect estimates are desired.</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_type">type</code></td>
<td>
<p>One of &quot;survival&quot;, &quot;cuminc&quot;, or &quot;rmean&quot;</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>A right-sided formula specifying which variables to
use in the model for the censoring distribution.</p>
</td></tr>
<tr><td><code id="pseudo_aareg_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Which method to use for calculation of inverse
probability of censoring weighted pseudo observations. &quot;binder&quot; the
default, uses the number of observations as the denominator, while the
&quot;hajek&quot; method uses the sum of the weights as the denominator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudo observations
</p>


<h3>See Also</h3>

<p><a href="survival.html#topic+aareg">aareg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>POi &lt;- pseudo_aareg(Surv(time, status) ~ 1, 1500, cause = 1,
  data = colon, type = "rmean", formula.censoring = ~ sex + age,
  ipcw.method = "binder")

mean(POi)

</code></pre>

<hr>
<h2 id='pseudo_coxph'>Compute censoring weighted pseudo observations</h2><span id='topic+pseudo_coxph'></span>

<h3>Description</h3>

<p>Assuming that the censoring depends on covariates,
the pseudo observations are calculated with the inverse probability of
censoring weighted approach, where the censoring probabilities are estimated
using Cox's proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_coxph(
  formula,
  time,
  cause = 1,
  data,
  type = c("cuminc", "survival", "rmean"),
  formula.censoring = NULL,
  ipcw.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_coxph_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the outcome model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates.</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_time">time</code></td>
<td>
<p>Numeric constant specifying the time at which the cumulative
incidence or survival probability effect estimates are desired.</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_type">type</code></td>
<td>
<p>One of &quot;survival&quot;, &quot;cuminc&quot;, or &quot;rmean&quot;</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>A right-sided formula specifying which variables to
use in the model for the censoring distribution.</p>
</td></tr>
<tr><td><code id="pseudo_coxph_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Which method to use for calculation of inverse
probability of censoring weighted pseudo observations. &quot;binder&quot; the
default, uses the number of observations as the denominator, while the
&quot;hajek&quot; method uses the sum of the weights as the denominator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudo observations
</p>


<h3>See Also</h3>

<p><a href="survival.html#topic+coxph">coxph</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>POi &lt;- pseudo_coxph(Surv(time, status) ~ 1, 1500, cause = 1,
  data = colon, type = "survival", formula.censoring = ~ sex + age,
  ipcw.method = "hajek")

mean(POi)

</code></pre>

<hr>
<h2 id='pseudo_independent'>Compute pseudo observations under independent censoring</h2><span id='topic+pseudo_independent'></span>

<h3>Description</h3>

<p>Assuming completely independent censoring, i.e., censoring does not depend on
the survival time nor any covariates in the model, the pseudo observations
are calculated with the standard jackknife approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_independent(
  formula,
  time,
  cause = 1,
  data,
  type = c("cuminc", "survival", "rmean"),
  formula.censoring = NULL,
  ipcw.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_independent_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates.</p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_time">time</code></td>
<td>
<p>Numeric constant specifying the time at which the cumulative
incidence or survival probability effect estimates are desired.</p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_type">type</code></td>
<td>
<p>One of &quot;survival&quot;, &quot;cuminc&quot;, or &quot;rmean&quot;</p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>Not used with this method, see
<a href="#topic+pseudo_stratified">pseudo_stratified</a>, <a href="#topic+pseudo_aareg">pseudo_aareg</a> or <a href="#topic+pseudo_coxph">pseudo_coxph</a></p>
</td></tr>
<tr><td><code id="pseudo_independent_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Not used with this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknife pseudo observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>POi &lt;- pseudo_independent(Surv(time, status) ~ 1, 1500, cause = 1, data = colon, type = "survival")
mean(POi)

</code></pre>

<hr>
<h2 id='pseudo_rmst2'>Compute pseudo-observations for the restricted mean survival</h2><span id='topic+pseudo_rmst2'></span>

<h3>Description</h3>

<p>Compute pseudo-observations for the restricted mean survival
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_rmst2(sfit, jacks, times, tmax, type = "cuminc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_rmst2_+3A_sfit">sfit</code></td>
<td>
<p>A survfit object</p>
</td></tr>
<tr><td><code id="pseudo_rmst2_+3A_jacks">jacks</code></td>
<td>
<p>A matrix of leave-one-out jackknife values, subjects in the rows, times in the columns</p>
</td></tr>
<tr><td><code id="pseudo_rmst2_+3A_times">times</code></td>
<td>
<p>Times at which the survival is calculated</p>
</td></tr>
<tr><td><code id="pseudo_rmst2_+3A_tmax">tmax</code></td>
<td>
<p>Max time</p>
</td></tr>
<tr><td><code id="pseudo_rmst2_+3A_type">type</code></td>
<td>
<p>&quot;cuminc&quot; or &quot;survival&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of pseudo observations for the restricted mean or lifetime lost
</p>

<hr>
<h2 id='pseudo_stratified'>Compute pseudo observations using stratified jackknife</h2><span id='topic+pseudo_stratified'></span>

<h3>Description</h3>

<p>Assuming that the censoring depends on covariates with a finite set of levels,
the pseudo observations are calculated with the jackknife approach stratified
on those covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_stratified(
  formula,
  time,
  cause = 1,
  data,
  type = c("cuminc", "survival", "rmean"),
  formula.censoring = NULL,
  ipcw.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_stratified_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates.</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_time">time</code></td>
<td>
<p>Numeric constant specifying the time at which the cumulative
incidence or survival probability effect estimates are desired.</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_type">type</code></td>
<td>
<p>One of &quot;survival&quot;, &quot;cuminc&quot;, or &quot;rmean&quot;</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>A right-sided formula specifying which variables to
stratify on. All variables in this formula must be categorical.</p>
</td></tr>
<tr><td><code id="pseudo_stratified_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Not used with this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of jackknife pseudo observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>POi &lt;- pseudo_stratified(Surv(time, status) ~ 1, 1500, cause = 1,
  data = colon, formula.censoring = ~ sex, type = "rmean")
mean(POi)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>survival</dt><dd><p><code><a href="survival.html#topic+Surv">Surv</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.pseudoglm'>Pseudo-observation scaled residuals</h2><span id='topic+residuals.pseudoglm'></span>

<h3>Description</h3>

<p>Computes residuals according to the recommendations of Pohar-Perme and
Andersen (2009) &lt;doi: 10.1002/sim.3401&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudoglm'
residuals(object, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.pseudoglm_+3A_object">object</code></td>
<td>
<p>A pseudoglm object, as returned by <a href="#topic+cumincglm">cumincglm</a> or
<a href="#topic+rmeanglm">rmeanglm</a></p>
</td></tr>
<tr><td><code id="residuals.pseudoglm_+3A_type">type</code></td>
<td>
<p>Either &quot;scaled&quot; (the default for cumulative incidence outcomes)
or one of the types available in <a href="stats.html#topic+residuals.glm">residuals.glm</a> for restricted mean outcomes, with the default being &quot;deviance&quot;.</p>
</td></tr>
<tr><td><code id="residuals.pseudoglm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <a href="stats.html#topic+residuals.glm">residuals.glm</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scaled residuals are computed as </p>
<p style="text-align: center;"><code class="reqn">\hat{\epsilon}_i =
  \frac{\hat{E}(V_i) - \hat{Y}_i}{\sqrt{\hat{Y}_i (1 - \hat{Y}_i)}}</code>
</p>
<p> When the
outcome is the cumulative incidence, the denominator corresponds to an
estimate of the standard error of the conditional estimate of the outcome
in the absence of censoring. For the restricted mean, no such rescaling is
done and the computation is passed off to <a href="stats.html#topic+residuals.glm">residuals.glm</a>.
</p>


<h3>Value</h3>

<p>A numeric vector of residuals
</p>


<h3>References</h3>

<p>Perme MP, Andersen PK. Checking hazard regression models using
pseudo-observations. Stat Med. 2008;27(25):5309-5328.
&lt;doi:10.1002/sim.3401&gt;
</p>

<hr>
<h2 id='rmeanglm'>Generalized linear models for the restricted mean survival</h2><span id='topic+rmeanglm'></span>

<h3>Description</h3>

<p>Using pseudo observations for the restricted mean, or the restricted mean
lifetime lost in the competing risks case, this function then runs a
generalized linear model to estimate associations of the restricted
mean/lifetime lost up to a particular time (specified by the <code>time</code>
argument) with covariates. The link function can be &quot;identity&quot; for estimating
differences in the restricted mean, &quot;log&quot; for estimating ratios, and any of
the other link functions supported by <a href="stats.html#topic+quasi">quasi</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmeanglm(
  formula,
  time,
  cause = 1,
  link = "identity",
  model.censoring = "independent",
  formula.censoring = NULL,
  ipcw.method = "binder",
  data,
  weights,
  subset,
  na.action,
  offset,
  control = list(...),
  model = FALSE,
  x = TRUE,
  y = TRUE,
  singular.ok = TRUE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmeanglm_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model. The left hand side must be a
<a href="survival.html#topic+Surv">Surv</a> object specifying a right censored survival or
competing risks outcome. The status indicator, normally 0=alive, 1=dead.
Other choices are TRUE/FALSE (TRUE = death) or 1/2 (2=death). For competing
risks, the event variable will be a factor, whose first level is treated as
censoring. The right hand side is the usual linear combination of
covariates.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_time">time</code></td>
<td>
<p>Numeric constant specifying the time up to which the restricted
mean effect estimates are desired.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_cause">cause</code></td>
<td>
<p>Numeric or character constant specifying the cause indicator of
interest.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_link">link</code></td>
<td>
<p>Link function for the restricted mean regression model.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_model.censoring">model.censoring</code></td>
<td>
<p>Type of model for the censoring distribution. Options
are &quot;stratified&quot;, which computes the pseudo-observations stratified on a
set of categorical covariates, &quot;aareg&quot; for Aalen's additive hazards model,
and &quot;coxph&quot; for Cox's proportional hazards model. With those options, we
assume that the time to event and event indicator are conditionally
independent of the censoring time, and that the censoring model is
correctly specified. If &quot;independent&quot;, we assume completely independent
censoring, i.e., that the time to event and covariates are independent of
the censoring time. the censoring time is independent of the covariates in
the model. Can also be a custom function, see Details and the
&quot;Extending eventglm&quot; vignette.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_formula.censoring">formula.censoring</code></td>
<td>
<p>A one sided formula (e.g., <code>~ x1 + x2</code>)
specifying the model for the censoring distribution. If NULL, uses the same
mean model as for the outcome.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>Which method to use for calculation of inverse
probability of censoring weighted pseudo observations. &quot;binder&quot; the
default, uses the number of observations as the denominator, while the
&quot;hajek&quot; method uses the sum of the weights as the denominator.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_data">data</code></td>
<td>
<p>Data frame in which all variables of formula can be interpreted.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be NULL or a numeric vector.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of
<a href="base.html#topic+options">options</a>, and is <a href="stats.html#topic+na.fail">na.fail</a> if that is unset. The
'factory-fresh' default is <a href="stats.html#topic+na.omit">na.omit</a>. Another possible value is
NULL, no action. Value <a href="stats.html#topic+na.exclude">na.exclude</a> can be useful.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be
included in the linear predictor during fitting. This should be NULL or a
numeric vector of length equal to the number of cases. One or more
<a href="stats.html#topic+offset">offset</a> terms can be included in the formula instead or as
well, and if more than one is specified their sum is used. See
<a href="stats.html#topic+model.offset">model.offset</a>.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. This
is passed to <a href="stats.html#topic+glm.control">glm.control</a>.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether model frame should be
included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_x">x</code></td>
<td>
<p>logical value indicating whether the model matrix used in the
fitting process should be returned as components of the returned value.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_y">y</code></td>
<td>
<p>logical value indicating whether the response vector
(pseudo-observations) used in the fitting process should be returned as
components of the returned value.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical; if FALSE a singular fit is an error.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of
<a href="stats.html#topic+model.matrix.default">model.matrix.default</a>.</p>
</td></tr>
<tr><td><code id="rmeanglm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="stats.html#topic+glm.fit">glm.fit</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument &quot;model.censoring&quot; determines how the pseudo observations
are calculated. This can be the name of a function or the function itself, which
must have arguments &quot;formula&quot;, &quot;time&quot;, &quot;cause&quot;, &quot;data&quot;, &quot;type&quot;,
&quot;formula.censoring&quot;, and &quot;ipcw.method&quot;. If it is the name of a function, this code
will look for a function with the prefix &quot;pseudo_&quot; first, to avoid clashes with
related methods such as coxph. The function then must return a vector
of pseudo observations, one for each subject in data which are used in subsequent
calculations. For examples of the implementation, see the &quot;pseudo-modules.R&quot;
file, or the vignette &quot;Extending eventglm&quot;.
</p>


<h3>Value</h3>

<p>A pseudoglm object, with its own methods for print, summary, and
vcov. It inherits from glm, so predict and other glm methods are supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    cumincipcw &lt;- rmeanglm(Surv(etime, event) ~ age + sex,
         time = 200, cause = "pcm", link = "identity",
         model.censoring = "independent", data = mgus2)
# stratified on only the categorical covariate
     cumincipcw2 &lt;- rmeanglm(Surv(etime, event) ~ age + sex,
                         time = 200, cause = "pcm", link = "identity",
                         model.censoring = "stratified",
                         formula.censoring = ~ sex, data = mgus2)
</code></pre>

<hr>
<h2 id='summary.pseudoglm'>Summary method</h2><span id='topic+summary.pseudoglm'></span>

<h3>Description</h3>

<p>Summary method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudoglm'
summary(
  object,
  correlation = FALSE,
  symbolic.cor = FALSE,
  type = "robust",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pseudoglm_+3A_object">object</code></td>
<td>
<p>A pseudoglm object, as returned by <a href="#topic+cumincglm">cumincglm</a> or <a href="#topic+rmeanglm">rmeanglm</a></p>
</td></tr>
<tr><td><code id="summary.pseudoglm_+3A_correlation">correlation</code></td>
<td>
<p>logical; if TRUE, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.pseudoglm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; If TRUE, print the correlations in a symbolic form rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.pseudoglm_+3A_type">type</code></td>
<td>
<p>The method to use for variance estimation; one of &quot;corrected&quot;, &quot;robust&quot;, &quot;naive&quot;, or &quot;cluster&quot;</p>
</td></tr>
<tr><td><code id="summary.pseudoglm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="stats.html#topic+summary.glm">summary.glm</a>
</p>

<hr>
<h2 id='vcov.pseudoglm'>Compute covariance matrix of regression coefficient estimates</h2><span id='topic+vcov.pseudoglm'></span>

<h3>Description</h3>

<p>Compute covariance matrix of regression coefficient estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudoglm'
vcov(object, type = "robust", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.pseudoglm_+3A_object">object</code></td>
<td>
<p>A pseudoglm object, as returned by <a href="#topic+cumincglm">cumincglm</a> or
<a href="#topic+rmeanglm">rmeanglm</a>.</p>
</td></tr>
<tr><td><code id="vcov.pseudoglm_+3A_type">type</code></td>
<td>
<p>The method to use for variance estimation; one of &quot;corrected&quot;,
&quot;robust&quot;, &quot;naive&quot;, or &quot;cluster&quot;</p>
</td></tr>
<tr><td><code id="vcov.pseudoglm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;corrected&quot; variance estimate for the cumulative incidence is as
described in Overgaard et al. (2017) &lt;doi:10.1214/16-AOS1516&gt;, with code
adapted from Overgaard's Stata program. This method does not handle ties
and only has marginal benefits in reasonable sample sizes. The default is
&quot;robust&quot; which uses the sandwich estimator vcovHC as implemented in the
sandwich package. &quot;cluster&quot; is another option if you have clustered
observations that uses the vcovCL function in sandwich. Finally &quot;naive&quot;
uses the same method as glm to compute the variance, and is known to be
anti-conservative. The bootstrap is another recommended option that can be
implemented using other tools; there is an example in the vignette.
</p>


<h3>Value</h3>

<p>A numeric matrix containing the variance-covariance estimates
</p>


<h3>References</h3>

<p>Overgaard, Morten; Parner, Erik Thorlund; Pedersen, Jan.
Asymptotic theory of generalized estimating equations based on jack-knife
pseudo-observations. Ann. Statist. 45 (2017), no. 5, 1988&ndash;2015.
&lt;doi:10.1214/16-AOS1516&gt;.
</p>


<h3>See Also</h3>

<p><a href="sandwich.html#topic+vcovHC">vcovHC</a>, <a href="sandwich.html#topic+vcovCL">vcovCL</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
