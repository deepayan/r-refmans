<!DOCTYPE html><html><head><title>Help for package RobExtremes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobExtremes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RobExtremes-package'>
<p>RobExtremes &ndash; Optimally Robust Estimation for Extreme Value Distributions</p></a></li>
<li><a href='#.checkEstClassForParamFamily-methods'><p> Methods for Function .checkEstClassForParamFamily in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#asvarMedkMAD'><p> Function to compute asymptotic variance of MedkMAD estimator</p></a></li>
<li><a href='#asvarPickands'><p> Function to compute asymptotic variance of Pickands estimator</p></a></li>
<li><a href='#asvarQBCC'><p> Function to compute asymptotic variance of QuantileBCC estimator</p></a></li>
<li><a href='#checkmakeIC-methods'><p>Methods for Functions checkIC and makeIC in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#E'><p>Generic Function for the Computation of (Conditional) Expectations</p></a></li>
<li><a href='#getCVaR'><p>Risk Measures for Scale-Shape Families</p></a></li>
<li><a href='#getStartIC-methods'><p>Methods for Function getStartIC in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#GEV'><p>Generating function for GEV-class</p></a></li>
<li><a href='#GEV-class'><p>Generalized EV distribution</p></a></li>
<li><a href='#GEVFamily'><p>Generating function for families of Generalized Extreme Value distributions</p></a></li>
<li><a href='#GEVFamilyMuUnknown'><p>Generating function for families of Generalized Extreme Value distributions</p></a></li>
<li><a href='#GEVParameter-class'><p>Parameter of generalized Pareto distributions</p></a></li>
<li><a href='#GPareto'><p>Generating function for GPareto-class</p></a></li>
<li><a href='#GPareto-class'><p>Generalized Pareto distribution</p></a></li>
<li><a href='#GParetoFamily'><p>Generating function for Generalized Pareto families</p></a></li>
<li><a href='#GParetoParameter-class'><p>Parameter of generalized Pareto distributions</p></a></li>
<li><a href='#Gumbel'><p>Generating function for Gumbel-class</p></a></li>
<li><a href='#Gumbel-class'><p>Gumbel distribution</p></a></li>
<li><a href='#GumbelLocationFamily'><p>Generating function for Gumbel location families</p></a></li>
<li><a href='#GumbelParameter-class'><p>Paramter of Gumbel distributions</p></a></li>
<li><a href='#internal_interpolate_helpers_for_RobExtremes'><p>Internal helper functions for generating interpolation grids for</p>
speed up in package RobExtremes</a></li>
<li><a href='#internal_ldehelpers_for_distrMod'><p>Internal helper functions for treating LDEstimators in package distrMod</p></a></li>
<li><a href='#InternalEstimatorReturnClasses'><p>Internal Estimator Return Classes in 'RobExtremes'</p></a></li>
<li><a href='#InternalProbFamilyClasses-class'><p>Internal Classes for Method Dispatch in 'ProbFamliy' Classes</p></a></li>
<li><a href='#InternalProbFamilyReturnClasses-class'><p>Internal return classes for generating functions</p></a></li>
<li><a href='#interpolateSn'><p> Function to compute LD (location-dispersion) estimates</p></a></li>
<li><a href='#ismevgpdgevdiag-methods'><p> Methods for Diagnostic Functions in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#kMAD'><p>Asymmetric Median of Absolute Deviations for Skewed Distributions</p></a></li>
<li><a href='#LDEstimate-class'><p>LDEstimate-class.</p></a></li>
<li><a href='#LDEstimator'><p> Function to compute LD (location-dispersion) estimates</p></a></li>
<li><a href='#movToRef-methods'><p>Methods for Functions moving from and to reference parameter in Package</p>
&lsquo;RobExtremes&rsquo;</a></li>
<li><a href='#Pareto'><p>Generating function for Pareto-class</p></a></li>
<li><a href='#Pareto-class'><p>Pareto distribution</p></a></li>
<li><a href='#ParetoFamily'><p>Generating function for Generalized Pareto families</p></a></li>
<li><a href='#ParetoParameter-class'><p>Paramter of Pareto distributions</p></a></li>
<li><a href='#PickandsEstimator'><p> Function to compute Pickands estimates for the GPD and GEVD</p></a></li>
<li><a href='#QuantileBCCEstimator'><p> Function to compute QuantileBCC estimates for the Weibull Family</p></a></li>
<li><a href='#rescaleFunction-methods'><p>Methods for Function rescaleFunction in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#RobExtremesConstants'><p>Built-in Constants in package RobExtremes</p></a></li>
<li><a href='#validParameter-methods'><p> Methods for function validParameter in Package &lsquo;RobExtremes&rsquo;</p></a></li>
<li><a href='#var'><p>Generic Functions for the Computation of Functionals</p></a></li>
<li><a href='#WeibullFamily'><p>Generating function for Weibull family</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimally Robust Estimation for Extreme Value Distributions</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimally robust estimation for extreme value distributions using S4 classes and
            methods (based on packages 'distr', 'distrEx', 'distrMod', 'RobAStBase', and
            'ROptEst'); the underlying theoretic results can be found in Ruckdeschel and
            Horbenko, (2013 and 2012), \doi{10.1080/02331888.2011.628022} and
            \doi{10.1007/s00184-011-0366-4}.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, distrMod(&ge; 2.8.0), ROptEst(&ge; 1.2.0),
robustbase, evd</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit(&ge; 0.4.26), ismev(&ge; 1.39)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>fitdistrplus(&ge; 1.0-9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RobAStRDA, distr, distrEx(&ge; 2.8.0), RandVar, RobAStBase(&ge;
1.2.0), startupmsg, actuar</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/robast/">https://r-forge.r-project.org/projects/robast/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-02-07 03:37:36 +0100 (Mi, 07
Feb 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1295 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1290</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 13:22:26 UTC; ruckdesc</td>
</tr>
<tr>
<td>Author:</td>
<td>Nataliya Horbenko [aut, cph],
  Bernhard Spangl [ctb] (contributed smoothed grid values of the Lagrange
    multipliers),
  Sascha Desmettre [ctb] (contributed smoothed grid values of the
    Lagrange multipliers),
  Eugen Massini [ctb] (contributed an interactive smoothing routine for
    smoothing the Lagrange multipliers and smoothed grid values of the
    Lagrange multipliers),
  Daria Pupashenko [ctb] (contributed MDE-estimation for GEV distribution
    in the framework of her PhD thesis 2011--14),
  Gerald Kroisandt [ctb] (contributed testing routines),
  Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Peter Ruckdeschel <a href="https://orcid.org/0000-0001-7815-4809"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Ruckdeschel &lt;peter.ruckdeschel@uni-oldenburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 00:30:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='RobExtremes-package'>
RobExtremes &ndash; Optimally Robust Estimation for Extreme Value Distributions
</h2><span id='topic+RobExtremes-package'></span><span id='topic+RobExtremes'></span>

<h3>Description</h3>

<p><span class="pkg">RobExtremes</span> provides infrastructure for speeded-up optimally robust
estimation (i.e., MBRE, OMSE, RMXE) for extreme value distributions,
extending packages <span class="pkg">distr</span>, <span class="pkg">distrEx</span>, <span class="pkg">distrMod</span>,
<span class="pkg">robustbase</span>, <span class="pkg">RobAStBase</span>, and <span class="pkg">ROptEst</span>.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RobExtremes </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-07 </td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Optimally Robust Estimation for Extreme Value Distributions</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Optimally robust estimation for extreme value distributions
using S4 classes and methods </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> (based on packages distr, distrEx, distrMod, RobAStBase, and ROptEst). </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), methods, distrMod(&gt;= 2.8.0), ROptEst(&gt;= 1.2.0), robustbase, evd </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> RUnit(&gt;= 0.4.26), ismev(&gt;= 1.39) </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> RobAStRDA, distr, distrEx(&gt;= 2.8.0), RandVar, RobAStBase(&gt;= 1.2.0), startupmsg,actuar </td>
</tr>
<tr>
 <td style="text-align: left;">
Authors:
</td><td style="text-align: left;"> Bernhard Spangl [contributed smoothed grid values of the Lagrange multipliers]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Sascha Desmettre [contributed smoothed grid values of the Lagrange multipliers]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Eugen Massini [contributed an interactive smoothing routine for smoothing the</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">       Lagrange multipliers and smoothed grid values of the Lagrange multipliers] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Daria Pupashenko [contributed MDE-estimation for GEV distribution in
the framework of</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">       her PhD thesis 2011--14]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Gerald Kroisandt [contributed testing routines]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Nataliya Horbenko ["aut","cph"] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Matthias Kohl ["aut", "cph"]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Peter Ruckdeschel ["cre", "aut", "cph"],</td>
</tr>
<tr>
 <td style="text-align: left;">
Contact: </td><td style="text-align: left;"> peter.ruckdeschel@uni-oldenburg.de</td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://r-forge.r-project.org/projects/robast/</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8 </td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1290 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Distributions</h3>

<p>Importing from packages <span class="pkg">actuar</span>,
<span class="pkg">evd</span>, it provides S4 classes and methods for the
</p>
<ul>
<li><p> Gumbel distribution
</p>
</li>
<li><p> Generalized Extreme Value distribution (GEVD)
</p>
</li>
<li><p> Generalized Pareto distribution (GPD)
</p>
</li>
<li><p> Pareto distribution</p>
</li></ul>



<h3>Functionals for Distributions</h3>

<p>These distributions come together with particular methods for expectations.
I.e., a functional E() as in package <span class="pkg">distrEx</span>, which as first argument
takes the distribution, and, optionally, can take as second argument
a function which then is used as integrand. These particular methods are
available for the GPD, Pareto, Gamma, Weibull, and GEV disdribution and use
integration on the quantile scale, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\mathop{E}[X]=\int_0^1 q^X(s)\,ds</code>
</p>

<p>where <code class="reqn">q^X</code> is the quantile function of X.
In addition, where they exist, we provide closed from expressions for
variances, median, IQR, skewness, kurtosis. <br />
In addition, extending estimators <code>Sn</code> and <code>Qn</code> from package
<span class="pkg">robustbase</span>, we provide functionals for Sn and Qn. A new
asymmetric version of the <code>mad</code>, <code>kMAD</code> gives yet another robust
scale estimator (and functional). 
</p>


<h3>Models and Estimators</h3>

<p>As to models, we provide the
</p>

<ul>
<li><p> GPD model (with known threshold), together with (speeded-up) optimally
robust estimators, with LDEstimators (in general, and with <code>medkMAD</code>,
<code>medSn</code> and <code>medQn</code> as particular ones) and Pickands' estimator as
starting estimators.
</p>
</li>
<li><p> GEVD model (with known or unknown threshold), together with (speeded-up)
optimally robust estimators, with LDEstimators (see above) and Pickands'
estimator as starting estimators.
</p>
</li>
<li><p> Pareto model
</p>
</li>
<li><p> Weibull model
</p>
</li>
<li><p> Gamma model
</p>
</li></ul>

<p>and for each of these, we provide  speeded-up optimally robust estimation
(i.e., MBRE, OMSE, RMXE).<br />
We robust (high-breakdown) starting estimators for
</p>

<ul>
<li><p> GPD (PickandsEstimator, medkMAD, medSn, medQn)
</p>
</li>
<li><p> GEV (PickandsEstimator)
</p>
</li>
<li><p> Pareto (Cramér-von-Mises-Minimum-Distance-Estimator)
</p>
</li>
<li><p> Weibull (the quantile based estimator of Boudt/Caliskan/Croux)
</p>
</li>
<li><p> Gamma (Cramér-von-Mises-Minimum-Distance-Estimator)
</p>
</li></ul>

<p>For all these families, of course, MLEs and Minimum-Distance-Estimators
are also available through package &quot;distrMod&quot;. 
</p>


<h3>Diagnostics</h3>

<p>We bridge to the diagnostics provided by package &quot;ismev&quot;, i.e. our
return objects can be plugged into the diagnostics of this package.<br />
We have the usual diagnostic plots from package &quot;RobAStBase&quot;,
i.e.
</p>

<ul>
<li><p> Outylingness plots  <code>outlyingPlotIC</code>
</p>
</li>
<li><p> IC plots <code>plot</code>
</p>
</li>
<li><p> Information plots via <code>infoPlot</code>
</p>
</li>
<li><p> IC comparison plots via <code>comparePlot</code>
</p>
</li>
<li><p> Cniperpoint plots (from package &quot;ROptEst&quot;) via <code>CniperPointPlot</code>
</p>
</li></ul>

<p>but also (adopted from package &quot;distrMod&quot;)
</p>

<ul>
<li><p> qqplots (with confidence bands) via <code>qqplot</code>
</p>
</li>
<li><p> returnlevel plots via <code>returnlevelplot</code>
</p>
</li></ul>



<h3>Starting Point</h3>

<p>As a starting point you may look at the included script
&lsquo;<span class="file">&quot;RobFitsAtRealData.R&quot;</span>&rsquo; in the scripts folder of the package,
accessible by
<code>file.path(system.file(package="RobExtremes"),
             "scripts/RobFitsAtRealData.R")</code>.
</p>


<h3>Classes</h3>

<pre>
[*]: there is a generating function with the same name in RobExtremes
[**]:  generating function from distrMod, but with (speeded-up)
       opt.rob-estimators in RobExtremes
##########################
Distribution Classes
##########################
"Distribution" (from distr)
|&gt;"UnivariateDistribution" (from distr)
|&gt;|&gt;"AbscontDistribution" (from distr)
|&gt;|&gt;|&gt;"Gumbel"    [*]
|&gt;|&gt;|&gt;"Pareto"    [*]
|&gt;|&gt;|&gt;"GPareto"   [*]
|&gt;|&gt;|&gt;"GEVD"      [*]
##########################
Parameter Classes
##########################
"OptionalParameter" (from distr)
|&gt;"Parameter" (from distr)
|&gt;|&gt;"GumbelParameter"
|&gt;|&gt;"ParetoParameter"
|&gt;|&gt;"GEVDParameter"
|&gt;|&gt;"GParetoParameter"
##########################
ProbFamily classes
##########################
slots: [&lt;name&gt;(&lt;class&gt;)]
"ProbFamily"                                  (from distrMod)
|&gt;"ParamFamily"                               (from distrMod)
|&gt;|&gt;"L2ParamFamily"                           (from distrMod)
|&gt;|&gt;|&gt;"L2GroupParamFamily"                    (from distrMod)
|&gt;|&gt;|&gt;|&gt;"ParetoFamily"                  [*]
|&gt;|&gt;|&gt;|&gt;"L2ScaleShapeUnion"                   (from distrMod)
|&gt;|&gt;|&gt;|&gt;|&gt;"GammaFamily"                 [**]
|&gt;|&gt;|&gt;|&gt;|&gt;"GParetoFamily"               [*]
|&gt;|&gt;|&gt;|&gt;|&gt;"GEVFamily"                   [*]
|&gt;|&gt;|&gt;|&gt;|&gt;"WeibullFamily"               [**]
|&gt;|&gt;|&gt;|&gt;"L2LocationScaleUnion"  /VIRTUAL/     (from distrMod)
|&gt;|&gt;|&gt;|&gt;|&gt;"L2LocationFamily"                  (from distrMod)
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"GumbelLocationFamily"      [*]
|&gt;|&gt;|&gt;|&gt;"L2LocScaleShapeUnion"  /VIRTUAL/     (from distrMod)
|&gt;|&gt;|&gt;|&gt;|&gt;"GEVFamilyMuUnknown"          [*]
</pre>


<h3>Functions</h3>

<pre>
LDEstimator     Estimators for scale-shape models based on
                location and dispersion
medSn                    loc=median disp=Sn
medQn                    loc=median disp=Qn
medkMAD                  loc=median disp=kMAD
asvarMedkMAD               [asy. variance to MedkMADE]
PickandsEstimator        PickandsEstimator
asvarPickands              [asy. variance to PickandsE]
QuantileBCCEstimator     Quantile based estimator for the Weibull distribution
asvarQBCC                  [asy. variance to QuantileBCCE]
</pre>

<h3>Generating Functions</h3>

<pre>
Distribution Classes
Gumbel                  Generating function for Gumbel-class
GEVD                    Generating function for GEVD-class
GPareto                 Generating function for GPareto-class
Pareto                  Generating function for Pareto-class
L2Param Families
ParetoFamily            Generating function for ParetoFamily-class
GParetoFamily           Generating function for GParetoFamily-class
GEVFamily               Generating function for GEVFamily-class
WeibullFamily           Generating function for WeibullFamily-class
</pre>

<h3>Methods</h3>

<pre>
Functionals:
E                       Generic function for the computation of
                        (conditional) expectations
var                     Generic functions for the computation of functionals
IQR                     Generic functions for the computation of functionals
median                  Generic functions for the computation of functionals
skewness                Generic functions for the computation of functionals
kurtosis                Generic functions for the computation of functionals
Sn                      Generic function for the computation of (conditional)
                        expectations
Qn                      Generic functions for the computation of functionals
</pre>


<h3>Constants</h3>

<pre>
EULERMASCHERONICONSTANT
APERYCONSTANT
</pre>

<h3>Acknowledgement</h3>

<p>This package is joint work by Peter Ruckdeschel, Matthias Kohl, and
Nataliya Horbenko (whose PhD thesis went into this package to a large extent),
with contributions by Dasha Pupashenko, Misha Pupashenko, Gerald Kroisandt,
Eugen Massini, Sascha Desmettre, and Bernhard Spangl, in the framework of
project &quot;Robust Risk Estimation&quot; (2011-2016) funded by Volkswagen foundation
(and gratefully ackknowledged). Thanks also goes to the maintainers of CRAN,
in particully to Uwe Ligges who greatly helped us with finding an appropriate
way to store the database of interpolating functions which allow the speed up
&ndash; this is now package RobAStRDA on CRAN. 
</p>


<h3>Start-up-Banner</h3>

<p>You may suppress the start-up banner/message completely by setting
<code>options("StartupBanner"="off")</code> somewhere before loading this package by
<code>library</code> or <code>require</code> in your R-code / R-session.
If option <code>"StartupBanner"</code> is not defined (default) or setting
<code>options("StartupBanner"=NULL)</code> or
<code>options("StartupBanner"="complete")</code> the complete start-up banner is
displayed.
For any other value of option <code>"StartupBanner"</code> (i.e., not in
<code>c(NULL,"off","complete")</code>) only the version information is displayed.
The same can be achieved by wrapping the <code>library</code> or <code>require</code>  call
into either <code>suppressStartupMessages()</code> or
<code>onlytypeStartupMessages(.,atypes="version")</code>.
As for general <code>packageStartupMessage</code>'s, you may also suppress all
the start-up banner by wrapping the <code>library</code> or <code>require</code>
call into <code>suppressPackageStartupMessages()</code> from
<span class="pkg">startupmsg</span>-version 0.5 on.
</p>


<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
RobAStXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>, <br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>, and <br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a>,<br />
<em>Maintainer:</em>  Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Horbenko, N., Ruckdeschel, P., and Bae, T. (2011): Robust Estimation of Operational Risk.
Journal of Operational Risk <em>6</em>(2), 3-30. <br />
M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.<br />
Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 762&ndash;791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
Ruckdeschel, P., Kohl, M., Stabla, T., and Camphausen, F. (2006):
S4 Classes for Distributions, <em>R News</em>, <em>6</em>(2), 2-6. 
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf</a>.<br />
A vignette for packages <span class="pkg">distr</span>, <span class="pkg">distrSim</span>, <span class="pkg">distrTEst</span>,
and <span class="pkg">RobExtremes</span> is included into the mere documentation package <span class="pkg">distrDoc</span>
and may be called by <code>require("distrDoc");vignette("distr")</code>.
A homepage to this package is available under <a href="http://robast.r-forge.r-project.org/">http://robast.r-forge.r-project.org/</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+0distr-package">distr-package</a></code>,
<code><a href="distrEx.html#topic+0distrEx-package">distrEx-package</a></code>,
<code><a href="distrMod.html#topic+0distrMod-package">distrMod-package</a></code>,
<code><a href="RobAStBase.html#topic+0RobAStBase-package">RobAStBase-package</a></code>,
<code><a href="ROptEst.html#topic+0ROptEst-package">ROptEst-package</a></code>
</p>

<hr>
<h2 id='.checkEstClassForParamFamily-methods'> Methods for Function .checkEstClassForParamFamily in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+.checkEstClassForParamFamily'></span><span id='topic+.checkEstClassForParamFamily-methods'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CLDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CMCEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CkStepEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CORobEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CMLEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CMDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGParetoFamily+2CCvMMDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CMCEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CLDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CkStepEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CORobEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CMLEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CCvMMDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamily+2CMDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CMCEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CLDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CkStepEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CORobEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CMLEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CCvMMDEstimate-method'></span><span id='topic+.checkEstClassForParamFamily+2CGEVFamilyMuUnknown+2CMDEstimate-method'></span>

<h3>Description</h3>

<p>.checkEstClassForParamFamily-methods</p>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkEstClassForParamFamily-methods_+3A_pfam">PFam</code></td>
<td>
<p>a parametric family.</p>
</td></tr>
<tr><td><code id=".checkEstClassForParamFamily-methods_+3A_estimator">estimator</code></td>
<td>
<p>an estimator. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The respective methods can be used to cast an estimator to
a model-specific subclass with particular methods.
</p>


<h3>Value</h3>

<p>The <code>GParetoFamily,Estimate</code>-method returns the estimator cast to
S4 class <code>GPDEstimate</code>,<br />
the <code>GParetoFamily,LDEstimate</code>-method cast to
S4 class  <code>GPDLDEstimate</code>,<br />
the <code>GParetoFamily,MCEstimate</code>-method cast to
S4 class  <code>GPDMCEstimate</code>,<br />
the <code>GParetoFamily,kStepEstimate</code>-method cast to
S4 class  <code>GPDkStepEstimate</code>,<br />
the <code>GParetoFamily,ORobEstimate</code>-method cast to
S4 class  <code>GPDORobEstimate</code>,<br />
the <code>GParetoFamily,MDEstimate</code>-method cast to
S4 class  <code>GPDMDEstimate</code>,<br />
the <code>GParetoFamily,MLEstimate</code>-method cast to
S4 class  <code>GPDML.ALEstimate</code>,<br />
the <code>GParetoFamily,CvMMDEstimate</code>-method cast to
S4 class  <code>GPDCvMMD.ALEstimate</code>,<br />
</p>
<p>The <code>GEVFamily,Estimate</code>-method returns the estimator cast to
S4 class <code>GEVEstimate</code>,<br />
the <code>GEVFamily,LDEstimate</code>-method cast to
S4 class  <code>GEVLDEstimate</code>,<br />
the <code>GEVFamily,MCEstimate</code>-method cast to
S4 class  <code>GEVMCEstimate</code>,<br />
the <code>GEVFamily,kStepEstimate</code>-method cast to
S4 class  <code>GEVkStepEstimate</code>,<br />
the <code>GEVFamily,ORobEstimate</code>-method cast to
S4 class  <code>GEVORobEstimate</code>,<br />
the <code>GEVFamily,MDEstimate</code>-method cast to
S4 class  <code>GEVMDEstimate</code>,<br />
the <code>GEVFamily,MLEstimate</code>-method cast to
S4 class  <code>GEVML.ALEstimate</code>,<br />
the <code>GEVFamily,CvMMDEstimate</code>-method cast to
S4 class  <code>GEVCvMMD.ALEstimate</code>,<br />
</p>
<p>the <code>GEVFamilyMuUnknown,Estimate</code>-method cast to
S4 class  <code>GEVEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,LDEstimate</code>-method cast to
S4 class  <code>GEVLDEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,MCEstimate</code>-method cast to
S4 class  <code>GEVMCEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,kStepEstimate</code>-method cast to
S4 class  <code>GEVkStepstimate</code>.<br />
the <code>GEVFamilyMuUnknown,ORobEstimate</code>-method cast to
S4 class  <code>GEVORobEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,MDEstimate</code>-method cast to
S4 class  <code>GEVMDEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,MLEstimate</code>-method cast to
S4 class  <code>GEVML.ALEstimate</code>,<br />
the <code>GEVFamilyMuUnknown,CvMMDEstimate</code>-method cast to
S4 class  <code>GEVCvMMD.ALEstimate</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>

<hr>
<h2 id='asvarMedkMAD'> Function to compute asymptotic variance of MedkMAD estimator</h2><span id='topic+asvarMedkMAD'></span>

<h3>Description</h3>

<p>Function <code>asvarMedkMAD</code> computes the asymptotic (co)variance of
a MedkMAD estimator at a Scale-Shape model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asvarMedkMAD( model, k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asvarMedkMAD_+3A_model">model</code></td>
<td>
<p>an object of class <code>"ScaleShapeUnion"</code>. </p>
</td></tr>
<tr><td><code id="asvarMedkMAD_+3A_k">k</code></td>
<td>
<p>numeric (&gt;0); additional parameter for <code><a href="#topic+kMAD">kMAD</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Generalized Pareto Family all terms are analytic; in case
of the general scale-shape model, numerical integration is used.
</p>


<h3>Value</h3>

<p>A 2x2 matrix; the covariance. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Horbenko, N. (2011): Optimally-Robust Estimators in Generalized
Pareto Models. ArXiv 1005.1476. To appear at <em>Statistics</em>.
DOI: 10.1080/02331888.2011.628022. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LDEstimator">LDEstimator</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>GP &lt;- GParetoFamily(scale=1,shape=0.7)
asvarMedkMAD(GP,k=1)

## for didactical purposes turn GP into a non-GPD
setClass("noGP",contains="L2ScaleShapeUnion")
GP2 &lt;- GP
class(GP2) &lt;- "noGP"
asvarMedkMAD(GP2,k=1) ### uses numerical integration
</code></pre>

<hr>
<h2 id='asvarPickands'> Function to compute asymptotic variance of Pickands estimator</h2><span id='topic+asvarPickands'></span>

<h3>Description</h3>

<p>Function <code>asvarPickands</code> computes the asymptotic (co)variance of
a Pickands estimator at a GPD or GEVD model &ndash; the latter with location
mu known or unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asvarPickands( model, alpha=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asvarPickands_+3A_model">model</code></td>
<td>
<p>an object of class <code>"ScaleShapeUnion"</code>. </p>
</td></tr>
<tr><td><code id="asvarPickands_+3A_alpha">alpha</code></td>
<td>
<p> numeric &gt; 1; determines the variant of the Pickands-Estimator
based on matching the empirical <code class="reqn">a_1=1-1/\alpha</code> and
<code class="reqn">a_1=1-1/\alpha^2</code> quantiles against the
population counter parts. The &ldquo;classical&rdquo; Pickands Estimator is
obtained for <code>alpha=2</code> (GPD) resp. for <code>alpha=1/log(2)</code> (GEVD). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All terms are analytic.
</p>


<h3>Value</h3>

<p>A 2x2 matrix (resp., for mu unknown in the GEV model a 3x3 matrix); the covariance. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em> 47(4), 762&ndash;791.
DOI: 10.1080/02331888.2011.628022. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PickandsEstimator">PickandsEstimator</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>GP &lt;- GParetoFamily(scale=1,shape=0.7)
asvarPickands(GP)
asvarPickands(GP,alpha=2.3)
GE &lt;- GEVFamily(loc=0,scale=1,shape=0.7)
asvarPickands(GE)
GE0 &lt;- GEVFamilyMuUnknown(loc=0,scale=1,shape=0.7)
asvarPickands(GE0)

</code></pre>

<hr>
<h2 id='asvarQBCC'> Function to compute asymptotic variance of QuantileBCC estimator</h2><span id='topic+asvarQBCC'></span>

<h3>Description</h3>

<p>Function <code>asvarQBCC</code> computes the asymptotic (co)variance of
a QuantileBCC estimator at a Weibull model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asvarQBCC( model, p1 = 1/3, p2 = 2/3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asvarQBCC_+3A_model">model</code></td>
<td>
<p>an object of class <code>"ScaleShapeUnion"</code>. </p>
</td></tr>
<tr><td><code id="asvarQBCC_+3A_p1">p1</code>, <code id="asvarQBCC_+3A_p2">p2</code></td>
<td>
<p>levels of the quantiles; maximal breakdown point is achieved
for <code class="reqn">p1=p2-p1=1-p2=1/3</code> which is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All terms are analytic.
</p>


<h3>Value</h3>

<p>A 2x2 matrix; the covariance. </p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+QuantileBCCEstimator">QuantileBCCEstimator</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>GP &lt;- WeibullFamily(scale=1,shape=0.7)
asvarQBCC(GP)
asvarQBCC(GP, p1=1/4, p2= 5/8)
</code></pre>

<hr>
<h2 id='checkmakeIC-methods'>Methods for Functions checkIC and makeIC in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+checkIC+2CIC+2CParetoFamily-method'></span><span id='topic+checkIC+2CIC+2CGParetoFamily-method'></span><span id='topic+checkIC+2CIC+2CGEVFamily-method'></span><span id='topic+checkIC+2CIC+2CGEVFamilyMuUnknown-method'></span><span id='topic+makeIC+2CIC+2CParetoFamily-method'></span><span id='topic+makeIC+2CIC+2CGParetoFamily-method'></span><span id='topic+makeIC+2CIC+2CGEVFamily-method'></span><span id='topic+makeIC+2CIC+2CGEVFamilyMuUnknown-method'></span>

<h3>Description</h3>

<p><code>checkIC</code> checks accuracy of the centering
and Fisher consistency condition of an IC, <code>makeIC</code>,
by centering and restandardizing warrants these conditions.</p>


<h3>Methods</h3>


<dl>
<dt>checkIC</dt><dd><p><code>signature(IC="IC", L2Fam = "ParetoFamily")</code>:
To enhance accuracy, the method for <code>"ParetoFamily"</code> uses
integration via the quantile transform, i.e., <code class="reqn">E[h(X)]</code>
for a random variable <code class="reqn">X\sim F</code> with quantil function <code class="reqn">q</code>
is computed as <code class="reqn">\int_0^1 h(q(s))\,ds</code>
</p>
</dd>
<dt>checkIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GParetoFamily")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GParetoFamily"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>checkIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GEVFamily")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GEVFamily"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>checkIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GEVFamilyMuUnknown")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GEVFamilyMuUnknown"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC="IC", L2Fam = "ParetoFamily")</code>:
As with <code>"checkIC"</code>, to enhance accuracy,
the method for <code>"makeIC"</code> for <code>"ParetoFamily"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GParetoFamily")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GParetoFamily"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GEVFamily")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GEVFamily"</code> uses
integration via the quantile transform.</p>
</dd>
<dt>makeIC</dt><dd><p><code>signature(IC="IC", L2Fam = "GEVFamilyMuUnknown")</code>:
As for <code>"ParetoFamily"</code>, to enhance accuracy,
the method for <code>"GEVFamilyMuUnknown"</code> uses
integration via the quantile transform.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+checkIC">checkIC</a></code>,<code><a href="RobAStBase.html#topic+makeIC-methods">makeIC</a></code></p>

<hr>
<h2 id='E'>Generic Function for the Computation of (Conditional) Expectations</h2><span id='topic+E'></span><span id='topic+DistributionsIntegratingByQuantiles-class'></span><span id='topic+E-methods'></span><span id='topic+E+2CDistributionsIntegratingByQuantiles+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CGumbel+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CGPareto+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CGPareto+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CGEV+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CGEV+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CPareto+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CPareto+2Cfunction+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of (conditional) expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E(object, fun, cond, ...)

## S4 method for signature 'GEV,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 
## 'DistributionsIntegratingByQuantiles,function,missing'
E(object,
         fun, low = NULL, upp = NULL,
         rel.tol= getdistrExOption("ErelativeTolerance"),
         lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
         upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
         IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Gumbel,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'GPareto,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'GPareto,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Pareto,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code></p>
</td></tr>
<tr><td><code id="E_+3A_fun">fun</code></td>
<td>
<p> if missing the (conditional) expectation is computed
else the (conditional) expection of <code>fun</code> is computed. </p>
</td></tr>
<tr><td><code id="E_+3A_cond">cond</code></td>
<td>
<p> if not missing the conditional expectation 
given <code>cond</code> is computed. </p>
</td></tr>
<tr><td><code id="E_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr>
<tr><td><code id="E_+3A_low">low</code></td>
<td>
<p>lower bound of integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_upp">upp</code></td>
<td>
<p>upper bound of integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_uppertruncquantile">upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td></tr>
<tr><td><code id="E_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>fun</code> </p>
</td></tr>
<tr><td><code id="E_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code><a href="distrEx.html#topic+distrExOptions">distrExOptions</a></code>. 
Also note that arguments <code>low</code> and <code>upp</code> should be given as
named arguments in order to prevent them to be matched by arguments
<code>fun</code> or <code>cond</code>. Also the result, when arguments 
<code>low</code> or <code>upp</code> is given, is the <em>unconditional value</em> of the
expectation; no conditioning with respect to <code>low &lt;= object &lt;= upp</code>
is done. To be able to use integration after transformation via the
respective probability transformation to [0,1], we introduce a class union
<code>"DistributionsIntegratingByQuantiles"</code>, which currently comprises
classes <code>"GPareto"</code>, <code>"Pareto"</code>, <code>"Weibull"</code>, <code>"GEV"</code>.
In addition, the specific method for <code>"GPareto", "function", "missing"</code>
uses integration on [0,1] via the substitution method (y := log(x)).
</p>
<p>Diagnostics on the involved integrations are available
if argument   <code>diagnostic</code> is <code>TRUE</code>. Then there is attribute
<code>diagnostic</code> attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>The expectation is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Gumbel&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;GPareto&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;DistributionsIntegratingByQuantiles&quot;,
fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>use probability transform, i.e., a substitution <code>y = p(object)(x)</code>
for numerical integration.</p>
</dd>
<dt>object = &quot;GPareto&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>use substitution method (y := log(x)) for numerical integration.</p>
</dd>
<dt>object = &quot;Pareto&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrEx.html#topic+distrExIntegrate">distrExIntegrate</a></code>, <code><a href="distrEx.html#topic+m1df">m1df</a></code>, <code><a href="distrEx.html#topic+m2df">m2df</a></code>,
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>GP &lt;- GPareto(shape=0.3)

E(GP)
E(GP, fun = function(x){2*x^2}) ## uses the log trafo

P &lt;- Pareto()
E(P)
E(P,fun = function(x){1/(x^2+1)})

</code></pre>

<hr>
<h2 id='getCVaR'>Risk Measures for Scale-Shape Families</h2><span id='topic+getVaR'></span><span id='topic+getCVaR'></span><span id='topic+getEL'></span><span id='topic+print.riskMeasure'></span>

<h3>Description</h3>

<p>Functions to compute Value-at-Risk (VaR), Conditional Value-at-Risk (CVaR)
and Expected Loss (EL) at data from scale-shape families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVaR(data, model, level, rob=TRUE)
getCVaR(data, model, level, rob=TRUE)
getEL(data, model, N0, rob=TRUE)
## S3 method for class 'riskMeasure'
print(x, level=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCVaR_+3A_data">data</code></td>
<td>
<p>data at which to compute the risk measure. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_model">model</code></td>
<td>
<p>an object of class <code>"L2ScaleShapeFamily"</code>.
The parametric family at which to evaluate the risk measure. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_level">level</code></td>
<td>
<p>real: probability needed for VaR and CVaR. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_n0">N0</code></td>
<td>
<p>real: expected frequency for expected loss. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_rob">rob</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) the RMXE-parametric estimator is
used; otherwise the MLE. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_x">x</code></td>
<td>
<p>an object of (S3-)class <code>"riskmeasure"</code>. </p>
</td></tr>
<tr><td><code id="getCVaR_+3A_...">...</code></td>
<td>
<p>further arguments for <code>print</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The risk measures <code>getVaR</code>, <code>getCVaR</code>, <code>getEL</code> return
an (S3) object of class <code>"riskMeasure"</code>, i.e., a numeric vector
of length 2 with components <code>"Risk"</code> and <code>"varofRisk"</code>
containing the respective risk measure
and a corresponding (asymptotic) standard error for the risk
measure. To the return class <code>"riskMeasure"</code>,
there is a particular <code>print</code>-method; if the corresponding argument
<code>level</code> is <code>NULL</code> (default) the corresponding standard error
is printed together with the risk measure; otherwise a corresponding
CLT-based confidence interval for the risk meausre is produced.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>P. Ruckdeschel, N. Horbenko (2013): Optimally-Robust Estimators in Generalized
Pareto Models. Statistics 47(4), 762&ndash;791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
N. Horbenko, P. Ruckdeschel, T. Bae (2011): Robust Estimation of Operational Risk.
Journal of Operational Risk 6(2), 3&ndash;30.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GParetoFamily">GParetoFamily</a></code>, <code><a href="#topic+GEVFamily">GEVFamily</a></code>, <code><a href="#topic+WeibullFamily">WeibullFamily</a></code>, <code><a href="distrMod.html#topic+GammaFamily">GammaFamily</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   # to reduce checking time
  set.seed(123)
  GPD &lt;- GParetoFamily(loc=20480, scale=7e4, shape=0.3)
  data &lt;- r(GPD)(500)
  getCVaR(data,GPD,0.99)
  getVaR(data,GPD,0.99)
  getEL(data,GPD,5)
  getVaR(data,GPD,0.99, rob=FALSE)
  getEL(data,GPD,5, rob=FALSE)
  getCVaR(data,GPD,0.99, rob=FALSE)
  
</code></pre>

<hr>
<h2 id='getStartIC-methods'>Methods for Function getStartIC in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+getStartIC-methods'></span><span id='topic+getStartIC'></span><span id='topic+getStartIC+2CL2ScaleShapeUnion+2CinterpolRisk-method'></span><span id='topic+getStartIC+2CL2LocScaleShapeUnion+2CinterpolRisk-method'></span><span id='topic+getStartIC+2CParetoFamily+2CinterpolRisk-method'></span>

<h3>Description</h3>

<p><code>getStartIC</code> computes the optimally-robust IC to be used as
argument <code>ICstart</code> in <code>kStepEstimator</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartIC(model, risk, ...)
## S4 method for signature 'L2ScaleShapeUnion,interpolRisk'
getStartIC(model, risk, ...,
   withMakeIC = FALSE, ..debug=FALSE, modifyICwarn = NULL)
## S4 method for signature 'L2LocScaleShapeUnion,interpolRisk'
getStartIC(model, risk, ...,
   withMakeIC = FALSE, ..debug=FALSE, modifyICwarn = NULL)
## S4 method for signature 'ParetoFamily,interpolRisk'
getStartIC(model, risk, ...,
   withMakeIC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStartIC-methods_+3A_model">model</code></td>
<td>
<p>normtype of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_risk">risk</code></td>
<td>
<p>normtype of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to specific methods.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_..debug">..debug</code></td>
<td>
<p>logical; if <code>TRUE</code> information for debugging is issued.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getStartIC</code> is used internally in functions <code>robest</code>
and <code>roptest</code> to compute the optimally robust influence function
according to the arguments given to them.</p>


<h3>Value</h3>

<p>An IC of type <code>HampIC</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2ScaleShapeUnion", risk = "interpolRisk")</code>:
computes the optimally robust influence function by interpolation
on a grid (using internal helper function <code>.getPsi</code>).</p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2LocScaleShapeUnion", risk = "interpolRisk")</code>:
computes the optimally robust influence function by interpolation
on a grid (using internal helper function <code>.getPsi.wL</code>).</p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "ParetoFamily", risk = "interpolRisk")</code>:
computes the optimally robust influence function by interpolation
on a grid (using internal helper function <code>.getPsi.P</code>).</p>
</dd>
</dl>

<p>All of these methods recenter and restandardize the obtained ICs to
warrant centeredness and Fisher consistency.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="ROptEst.html#topic+robest">robest</a></code>,<code><a href="ROptEst.html#topic+optIC">optIC</a></code>, <code><a href="ROptEst.html#topic+radiusMinimaxIC">radiusMinimaxIC</a></code></p>

<hr>
<h2 id='GEV'>Generating function for GEV-class</h2><span id='topic+GEV'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"GEV"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEV(loc = 0, scale = 1, shape = 0, location = loc)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEV_+3A_loc">loc</code></td>
<td>
<p> real number: location parameter of 
the GEV distribution. </p>
</td></tr>
<tr><td><code id="GEV_+3A_scale">scale</code></td>
<td>
<p> positive real number: scale parameter
of the GEV distribution </p>
</td></tr>
<tr><td><code id="GEV_+3A_shape">shape</code></td>
<td>
<p> non-negative real number: shape parameter of 
the GEV distribution. </p>
</td></tr>
<tr><td><code id="GEV_+3A_location">location</code></td>
<td>
<p> real number: location of GEV distribution </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"GEV"</code></p>


<h3>Note</h3>

<p>The class <code>"GEV"</code> is based on the code provided 
by the package <span class="pkg">evd</span> by Alec Stephenson.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+GEV-class">GEV-class</a></code>, <code><a href="evd.html#topic+gpd">dgpd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- GEV(loc = 0, scale = 1, shape = 0))
plot(P1)

E(GEV()) 
E(P1)
E(P1, function(x){x^2})
var(P1)
sd(P1)
median(P1)
IQR(P1)
mad(P1)

</code></pre>

<hr>
<h2 id='GEV-class'>Generalized EV distribution</h2><span id='topic+GEV-class'></span><span id='topic+initialize+2CGEV-method'></span><span id='topic+loc+2CGEV-method'></span><span id='topic+loc+3C-+2CGEV-method'></span><span id='topic+location+2CGEV-method'></span><span id='topic+location+3C-+2CGEV-method'></span><span id='topic+scale+2CGEV-method'></span><span id='topic+scale+3C-+2CGEV-method'></span><span id='topic+shape+2CGEV-method'></span><span id='topic+shape+3C-+2CGEV-method'></span><span id='topic++2B+2CGEV+2Cnumeric-method'></span><span id='topic++2A+2CGEV+2Cnumeric-method'></span><span id='topic+liesInSupport+2CGEV+2Cnumeric-method'></span>

<h3>Description</h3>

<p>[borrowed from <span class="pkg">evd</span>]:
The GEV distribution function with parameters <code>loc</code> <code class="reqn">= a</code>,
<code>scale</code> <code class="reqn">= b</code>, <code>shape</code> <code class="reqn">= s</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(x) = exp[-{1+s(z-a)/b}^(-1/s)]</code>
</p>

<p>for <code class="reqn">1+s(z-a)/b &gt; 0</code>, where <code class="reqn">b &gt; 0</code>. If <code class="reqn">s = 0</code> the distribution is 
defined by continuity and gives the Gumbel distribution. 
If <code class="reqn">1+s(z-a)/b \leq 0</code>, the value <code class="reqn">z</code> is either 
greater than the upper end point (if <code class="reqn">s &lt; 0</code>), or less than the lower end 
point (if <code class="reqn">s &gt; 0</code>).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GEV", loc, scale,shape)</code>.
More frequently they are created via the generating function 
<code>GEV</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"GEVParameter"</code>. </p>
</dd>
<dt><code>r</code></dt><dd><p><code>rgpd</code></p>
</dd>
<dt><code>d</code></dt><dd><p><code>dgpd</code></p>
</dd>
<dt><code>p</code></dt><dd><p><code>pgpd</code>, but vectorized and with special treatment of 
arguments <code>lower.tail</code> and <code>log.p</code></p>
</dd>
<dt><code>q</code></dt><dd><p><code>qgpd</code>, but vectorized and with special treatment of 
arguments <code>lower.tail</code> and <code>log.p</code></p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code></p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "GEV")</code>: initialize method. </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "GEV")</code>: wrapped access method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>loc</dt><dd><p><code>signature(object = "GEV")</code>: wrapped access method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "GEV")</code>: alias to <code>loc</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "GEV")</code>: wrapped access method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GEV")</code>: wrapped replace method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "GEV")</code>: wrapped replace  method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "GEV")</code>: alias to <code>loc&lt;-</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(x = "GEV")</code>: wrapped replace  method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "GEV", e2 = "numeric")</code>: exact method
for this transformation &mdash; stays within this class. </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "GEV", e2 = "numeric")</code>: exact method
for this transformation &mdash; stays within this class if <code>e2&gt;0</code>. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "GEV", fun = "missing", cond = "missing")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>var</dt><dd><p><code>signature(signature(x = "GEV")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>median</dt><dd><p><code>signature(signature(x = "GEV")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>IQR</dt><dd><p><code>signature(signature(x = "GEV")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>skewness</dt><dd><p><code>signature(signature(x = "GEV")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>kurtosis</dt><dd><p><code>signature(signature(x = "GEV")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>liesInSupport</dt><dd><p><code>signature(object = "GEV", x = "numeric")</code>:
checks if <code>x</code> lies in the support of the respective distribution. </p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is based on the code provided by the package <span class="pkg">evd</span>
by  A. G. Stephenson.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Pickands, J. (1975) <em>Statistical inference using extreme order
statistics. _Annals of Statistics_, *3*, 119-131.</em></p>


<h3>See Also</h3>

<p><code><a href="evd.html#topic+gpd">dgpd</a></code>, <code><a href="distr.html#topic+AbscontDistribution-class">AbscontDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- new("GEV", loc = 0, scale = 1,shape = 0))
plot(P1)
shape(P1)
loc(P1)
scale(P1) &lt;- 4
loc(P1) &lt;- 2
shape(P1) &lt;- -1 # may be negative!
plot(P1)
</code></pre>

<hr>
<h2 id='GEVFamily'>Generating function for families of Generalized Extreme Value distributions </h2><span id='topic+GEVFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"GEVFamily"</code> which
represents a Generalized EV family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEVFamily(loc = 0, scale = 1, shape = 0.5, of.interest = c("scale", "shape"),
          p = NULL, N = NULL, trafo = NULL, start0Est = NULL, withPos = TRUE,
          secLevel = 0.7, withCentL2 = FALSE, withL2derivDistr  = FALSE,
          withMDE = FALSE, ..ignoreTrafo = FALSE, ..withWarningGEV = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEVFamily_+3A_loc">loc</code></td>
<td>
<p> real: known/fixed threshold/location parameter </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_scale">scale</code></td>
<td>
<p> positive real: scale parameter </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_of.interest">of.interest</code></td>
<td>
<p> character: which parameters, transformations are of interest.<br />
possibilites are: &quot;scale&quot;, &quot;shape&quot;, &quot;quantile&quot;, &quot;expected loss&quot;,
&quot;expected shortfall&quot;; a maximum number of two of these may be selected </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_p">p</code></td>
<td>
<p>real or NULL: probability needed for quantile and expected shortfall </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_n">N</code></td>
<td>
<p>real or NULL: expected frequency for expected loss </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or NULL: transformation of the parameter </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_start0est">start0Est</code></td>
<td>
<p> startEstimator &mdash; if <code>NULL</code> <code><a href="#topic+PickandsEstimator">PickandsEstimator</a></code> is used </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_withpos">withPos</code></td>
<td>
<p> logical of length 1: Is shape restricted to positive values? </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_seclevel">secLevel</code></td>
<td>
<p> a numeric of length 1:
In the ideal GEV model, for each observastion <code class="reqn">X_i</code>, the expression
<code class="reqn">1+\frac{{\rm shape}(X_i-{\rm loc})}{{\rm scale}}</code>
must be positive, which in principle could be attacked by a single outlier.
Hence for sample size <code class="reqn">n</code> we allow for <code class="reqn">\varepsilon n</code>
violations, interpreting the violations as outliers. Here
<code class="reqn">\varepsilon = {\tt secLevel}/\sqrt{n}</code>. </p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_withcentl2">withCentL2</code></td>
<td>
<p>logical: shall L2 derivative be centered by substracting
the E()? Defaults to <code>FALSE</code>, but higher accuracy can be achieved
when set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>FALSE</code> (to speed up computations).</p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_withmde">withMDE</code></td>
<td>
<p>logical: should Minimum Distance Estimators be used to
find a good starting value for the parameter search?
Defaults to <code>FALSE</code>  (to speed up computations).
We have seen cases though, where the use of the then
employed <code>PickandsEstimator</code> was drastically misleading
and subsequently led to bad estimates where it is used
as starting value; so where feasible it is a good idea
to also try argument <code>withMDE=TRUE</code> for control purposes.</p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_..ignoretrafo">..ignoreTrafo</code></td>
<td>
<p>logical: only used internally in <code>kStepEstimator</code>; do not change this.</p>
</td></tr>
<tr><td><code id="GEVFamily_+3A_..withwarninggev">..withWarningGEV</code></td>
<td>
<p>logical: shall warnings be issued if shape is large?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"GEVFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
<a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
</p>
<p>Kohl, M., Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 
762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+GPareto-class">GPareto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- GEVFamily())
FisherInfo(G1)
checkL2deriv(G1)
</code></pre>

<hr>
<h2 id='GEVFamilyMuUnknown'>Generating function for families of Generalized Extreme Value distributions </h2><span id='topic+GEVFamilyMuUnknown'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"GEVFamilyMuUnknown"</code> which
represents a Generalized EV family with unknown location parameter <code>mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEVFamilyMuUnknown(loc = 0, scale = 1, shape = 0.5, of.interest = c("loc",
              "scale", "shape"), p = NULL, N = NULL, trafo = NULL,
              start0Est = NULL, withPos = TRUE, secLevel = 0.7,
              withCentL2 = FALSE, withL2derivDistr  = FALSE, withMDE = FALSE,
              ..ignoreTrafo = FALSE, ..withWarningGEV = TRUE, ..name = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEVFamilyMuUnknown_+3A_loc">loc</code></td>
<td>
<p> real: known/fixed threshold/location parameter </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_scale">scale</code></td>
<td>
<p> positive real: scale parameter </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_of.interest">of.interest</code></td>
<td>
<p> character: which parameters, transformations are of interest.<br />
possibilites are: &quot;scale&quot;, &quot;shape&quot;, &quot;quantile&quot;, &quot;expected loss&quot;,
&quot;expected shortfall&quot;; a maximum number of two of these may be selected </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_p">p</code></td>
<td>
<p>real or NULL: probability needed for quantile and expected shortfall </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_n">N</code></td>
<td>
<p>real or NULL: expected frequency for expected loss </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_trafo">trafo</code></td>
<td>
<p> matrix or NULL: transformation of the parameter </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_start0est">start0Est</code></td>
<td>
<p> startEstimator &mdash; if <code>NULL</code> <code><a href="#topic+PickandsEstimator">PickandsEstimator</a></code> is used </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_withpos">withPos</code></td>
<td>
<p> logical of length 1: Is shape restricted to positive values? </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_seclevel">secLevel</code></td>
<td>
<p> a numeric of length 1:
In the ideal GEV model, for each observastion <code class="reqn">X_i</code>, the expression
<code class="reqn">1+\frac{{\rm shape}(X_i-{\rm loc})}{{\rm scale}}</code>
must be positive, which in principle could be attacked by a single outlier.
Hence for sample size <code class="reqn">n</code> we allow for <code class="reqn">\varepsilon n</code>
violations, interpreting the violations as outliers. Here
<code class="reqn">\varepsilon = {\tt secLevel}/\sqrt{n}</code>. </p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_withcentl2">withCentL2</code></td>
<td>
<p>logical: shall L2 derivative be centered by substracting
the E()? Defaults to <code>FALSE</code>, but higher accuracy can be achieved
when set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>FALSE</code> (to speed up computations).</p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_withmde">withMDE</code></td>
<td>
<p>logical: should Minimum Distance Estimators be used to
find a good starting value for the parameter search?
Defaults to <code>FALSE</code>  (to speed up computations).
We have seen cases though, where the use of the then
employed <code>PickandsEstimator</code> was drastically misleading
and subsequently led to bad estimates where it is used
as starting value; so where feasible it is a good idea
to also try argument <code>withMDE=TRUE</code> for control purposes.</p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_..ignoretrafo">..ignoreTrafo</code></td>
<td>
<p>logical: only used internally in <code>kStepEstimator</code>; do not change this.</p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_..withwarninggev">..withWarningGEV</code></td>
<td>
<p>logical: shall warnings be issued if shape is large?</p>
</td></tr>
<tr><td><code id="GEVFamilyMuUnknown_+3A_..name">..name</code></td>
<td>
<p>character: optional alternative name for the parametric family;
used in generating interpolating grids. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"GEVFamilyMuUnknown"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
<a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
</p>
<p>Kohl, M., Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 
762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+GPareto-class">GPareto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- GEVFamilyMuUnknown())
FisherInfo(G1)
checkL2deriv(G1)
</code></pre>

<hr>
<h2 id='GEVParameter-class'>Parameter of generalized Pareto distributions</h2><span id='topic+GEVParameter-class'></span><span id='topic+loc+2CGEVParameter-method'></span><span id='topic+loc+3C-+2CGEVParameter-method'></span><span id='topic+location+2CGEVParameter-method'></span><span id='topic+location+3C-+2CGEVParameter-method'></span><span id='topic+scale+2CGEVParameter-method'></span><span id='topic+scale+3C-+2CGEVParameter-method'></span><span id='topic+shape+2CGEVParameter-method'></span><span id='topic+shape+3C-+2CGEVParameter-method'></span>

<h3>Description</h3>

<p>The class of the parameter of generalized Pareto distribution.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GEVParameter", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>loc</code></dt><dd><p> real number: location parameter of 
a GEV distribution. </p>
</dd>
<dt><code>scale</code></dt><dd><p> real number: scale parameter of 
a GEV distribution. </p>
</dd>
<dt><code>shape</code></dt><dd><p> real number: shape parameter of 
a GEV distribution. </p>
</dd>
<dt><code>name</code></dt><dd><p> default name is 
&ldquo;parameter of a GEV distribution&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>loc</dt><dd><p><code>signature(object = "GEVParameter")</code>: access method for
slot <code>loc</code>. </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "GEVParameter")</code>: alias to <code>loc</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "GEVParameter")</code>: access method for
slot <code>scale</code>. </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "GEVParameter")</code>: access method for
slot <code>shape</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "GEVParameter")</code>: replace method for
slot <code>loc</code>. </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "GEVParameter")</code>: alias to <code>loc&lt;-</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GEVParameter")</code>: replace method for
slot <code>shape</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GEVParameter")</code>: replace method for
slot <code>shape</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+GEV-class">GEV-class</a></code>, <code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- new("GEVParameter")
loc(P)
## same as
location(P)
scale(P)
shape(P)

scale(P) &lt;- 2
location(P) &lt;- 4
shape(P) &lt;- -1 # may be negative!
P
</code></pre>

<hr>
<h2 id='GPareto'>Generating function for GPareto-class</h2><span id='topic+GPareto'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"GPareto"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPareto(loc = 0, scale = 1, shape = 0, location = loc)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPareto_+3A_loc">loc</code></td>
<td>
<p> real number: location parameter of 
the GPareto distribution. </p>
</td></tr>
<tr><td><code id="GPareto_+3A_scale">scale</code></td>
<td>
<p> positive real number: scale parameter
of the GPareto distribution </p>
</td></tr>
<tr><td><code id="GPareto_+3A_shape">shape</code></td>
<td>
<p> non-negative real number: shape parameter of 
the GPareto distribution. </p>
</td></tr>
<tr><td><code id="GPareto_+3A_location">location</code></td>
<td>
<p> alternative argument name for argument 'loc' &mdash; to 
support argument names of package <span class="pkg">VGAM</span>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"GPareto"</code></p>


<h3>Note</h3>

<p>The class <code>"GPareto"</code> is based on the code provided 
by the package <span class="pkg">evd</span> by  Alec Stephenson.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+GPareto-class">GPareto-class</a></code>, <code><a href="evd.html#topic+gpd">dgpd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- GPareto(loc = 1, scale = 1, shape = -0.5))
plot(P1)

E(GPareto()) 
E(P1)
E(P1, function(x){x^2})
var(P1)
sd(P1)
median(P1)
IQR(P1)
mad(P1)

</code></pre>

<hr>
<h2 id='GPareto-class'>Generalized Pareto distribution</h2><span id='topic+GPareto-class'></span><span id='topic+initialize+2CGPareto-method'></span><span id='topic+loc+2CGPareto-method'></span><span id='topic+loc+3C-+2CGPareto-method'></span><span id='topic+location+2CGPareto-method'></span><span id='topic+location+3C-+2CGPareto-method'></span><span id='topic+scale+2CGPareto-method'></span><span id='topic+scale+3C-+2CGPareto-method'></span><span id='topic+shape+2CGPareto-method'></span><span id='topic+shape+3C-+2CGPareto-method'></span><span id='topic++2B+2CGPareto+2Cnumeric-method'></span><span id='topic++2A+2CGPareto+2Cnumeric-method'></span><span id='topic+liesInSupport+2CGPareto+2Cnumeric-method'></span>

<h3>Description</h3>

<p>[borrowed from <span class="pkg">evd</span>]:
</p>
<p>The (Three-parameter) generalized Pareto distribution with parameter <code>loc</code><code class="reqn">= a</code>,
<code>scale</code> <code class="reqn">= b</code>, <code>shape</code> <code class="reqn">= c</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{b} (1+c z)^(-1/c - 1), \quad z = \frac{x-a}{c}</code>
</p>

<p>for <code class="reqn">x &gt; a</code> (<code class="reqn"> c \geq 0</code>) and <code class="reqn">a \leq x \leq a - b/c</code>(<code class="reqn">c &lt; 0</code>).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GPareto", loc, scale,shape)</code>.
More frequently they are created via the generating function 
<code>GPareto</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"GParetoParameter"</code>. </p>
</dd>
<dt><code>r</code></dt><dd><p><code>rgpd</code></p>
</dd>
<dt><code>d</code></dt><dd><p><code>dgpd</code></p>
</dd>
<dt><code>p</code></dt><dd><p><code>pgpd</code>, but vectorized and with special treatment of 
arguments <code>lower.tail</code> and <code>log.p</code></p>
</dd>
<dt><code>q</code></dt><dd><p><code>qgpd</code>, but vectorized and with special treatment of 
arguments <code>lower.tail</code> and <code>log.p</code></p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code></p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "GPareto")</code>: initialize method. </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "GPareto")</code>: wrapped access method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>loc</dt><dd><p><code>signature(object = "GPareto")</code>: wrapped access method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "GPareto")</code>: alias to <code>loc</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "GPareto")</code>: wrapped access method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GPareto")</code>: wrapped replace method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "GPareto")</code>: wrapped replace  method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "GPareto")</code>: alias to <code>loc&lt;-</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(x = "GPareto")</code>: wrapped replace  method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "GPareto", e2 = "numeric")</code>: exact method
for this transformation &mdash; stays within this class. </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "GPareto", e2 = "numeric")</code>: exact method
for this transformation &mdash; stays within this class if <code>e2&gt;0</code>. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "GPareto", fun = "missing", cond = "missing")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>var</dt><dd><p><code>signature(signature(x = "GPareto")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>median</dt><dd><p><code>signature(signature(x = "GPareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>IQR</dt><dd><p><code>signature(signature(x = "GPareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>skewness</dt><dd><p><code>signature(signature(x = "GPareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>kurtosis</dt><dd><p><code>signature(signature(x = "GPareto")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>liesInSupport</dt><dd><p><code>signature(object = "GPareto", x = "numeric")</code>:
checks if <code>x</code> lies in the support of the respective distribution. </p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is based on the code provided by the package <span class="pkg">evd</span>
by  A. G. Stephenson.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Pickands, J. (1975) <em>Statistical inference using extreme order
statistics. _Annals of Statistics_, *3*, 119-131.</em></p>


<h3>See Also</h3>

<p><code><a href="evd.html#topic+gpd">dgpd</a></code>, <code><a href="distr.html#topic+AbscontDistribution-class">AbscontDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- new("GPareto", loc = 0, scale = 1,shape = 0))
plot(P1)
shape(P1)
loc(P1)
scale(P1) &lt;- 4
location(P1) &lt;- 2 ## same as loc(P1) &lt;- 2
shape(P1) &lt;- -2 # may be negative
plot(P1)
</code></pre>

<hr>
<h2 id='GParetoFamily'>Generating function for Generalized Pareto families</h2><span id='topic+GParetoFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"GParetoFamily"</code> which
represents a Generalized Pareto family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GParetoFamily(loc = 0, scale = 1, shape = 0.5, of.interest = c("scale", "shape"),
       p = NULL, N = NULL, trafo = NULL, start0Est = NULL, withPos = TRUE,
       secLevel = 0.7,  withCentL2 = FALSE, withL2derivDistr  = FALSE,
       withMDE = FALSE, ..ignoreTrafo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GParetoFamily_+3A_loc">loc</code></td>
<td>
<p> real: known/fixed threshold/location parameter </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_scale">scale</code></td>
<td>
<p> positive real: scale parameter </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_of.interest">of.interest</code></td>
<td>
<p> character: which parameters, transformations are of interest.<br />
possibilites are: &quot;scale&quot;, &quot;shape&quot;, &quot;quantile&quot;, &quot;expected loss&quot;,
&quot;expected shortfall&quot;; a maximum number of two of these may be selected </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_p">p</code></td>
<td>
<p>real or NULL: probability needed for quantile and expected shortfall </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_n">N</code></td>
<td>
<p>real or NULL: expected frequency for expected loss </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or NULL: transformation of the parameter </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_start0est">start0Est</code></td>
<td>
<p> startEstimator &mdash; if <code>NULL</code> <code><a href="#topic+medkMADhybr">medkMADhybr</a></code> is used </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_withpos">withPos</code></td>
<td>
<p> logical of length 1: Is shape restricted to positive values? </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_seclevel">secLevel</code></td>
<td>
<p> a numeric of length 1:
In the ideal GEV model, for each observastion <code class="reqn">X_i</code>, the expression
<code class="reqn">1+\frac{{\rm shape}(X_i-{\rm loc})}{{\rm scale}}</code>
must be positive, which in principle could be attacked by a single outlier.
Hence for sample size <code class="reqn">n</code> we allow for <code class="reqn">\varepsilon n</code>
violations, interpreting the violations as outliers. Here
<code class="reqn">\varepsilon = {\tt secLevel}/\sqrt{n}</code>. </p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_withcentl2">withCentL2</code></td>
<td>
<p>logical: shall L2 derivative be centered by substracting
the E()? Defaults to <code>FALSE</code>, but higher accuracy can be achieved
when set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>FALSE</code> (to speed up computations).</p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_withmde">withMDE</code></td>
<td>
<p>logical: should Minimum Distance Estimators be used to
find a good starting value for the parameter search?
Defaults to <code>FALSE</code>  (to speed up computations).</p>
</td></tr>
<tr><td><code id="GParetoFamily_+3A_..ignoretrafo">..ignoreTrafo</code></td>
<td>
<p>logical: only used internally in <code>kStepEstimator</code>; do not change this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"GParetoFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
<a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
</p>
<p>Kohl, M., Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 
762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+GPareto-class">GPareto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- GParetoFamily())
FisherInfo(G1)
checkL2deriv(G1)
</code></pre>

<hr>
<h2 id='GParetoParameter-class'>Parameter of generalized Pareto distributions</h2><span id='topic+GParetoParameter-class'></span><span id='topic+loc+2CGParetoParameter-method'></span><span id='topic+loc+3C-+2CGParetoParameter-method'></span><span id='topic+location+2CGParetoParameter-method'></span><span id='topic+location+3C-+2CGParetoParameter-method'></span><span id='topic+scale+2CGParetoParameter-method'></span><span id='topic+scale+3C-+2CGParetoParameter-method'></span><span id='topic+shape+2CGParetoParameter-method'></span><span id='topic+shape+3C-+2CGParetoParameter-method'></span>

<h3>Description</h3>

<p>The class of the parameter of generalized Pareto distribution.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GParetoParameter", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>loc</code></dt><dd><p> real number: location parameter of 
a generalized Pareto distribution. </p>
</dd>
<dt><code>scale</code></dt><dd><p> real number: scale parameter of 
a generalized Pareto distribution. </p>
</dd>
<dt><code>shape</code></dt><dd><p> real number: shape parameter of 
a generalized Pareto distribution. </p>
</dd>
<dt><code>name</code></dt><dd><p> default name is 
&ldquo;parameter of a GPareto distribution&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>loc</dt><dd><p><code>signature(object = "GParetoParameter")</code>: access method for
slot <code>loc</code>. </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "GParetoParameter")</code>: alias to <code>loc</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(object = "GParetoParameter")</code>: access method for
slot <code>scale</code>. </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "GParetoParameter")</code>: access method for
slot <code>shape</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "GParetoParameter")</code>: replace method for
slot <code>loc</code>. </p>
</dd>
<dt>location&lt;-</dt><dd><p><code>signature(object = "GParetoParameter")</code>: alias to <code>loc&lt;-</code>,
to support argument naming of package <span class="pkg">VGAM</span>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GParetoParameter")</code>: replace method for
slot <code>shape</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "GParetoParameter")</code>: replace method for
slot <code>shape</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+GPareto-class">GPareto-class</a></code>, <code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- new("GParetoParameter")
loc(P)
## same as
location(P)
scale(P)
shape(P)

scale(P) &lt;- 2
loc(P) &lt;- -5
shape(P) &lt;- -1 # may be negative
P
</code></pre>

<hr>
<h2 id='Gumbel'>Generating function for Gumbel-class</h2><span id='topic+Gumbel'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"Gumbel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gumbel(loc = 0, scale = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_loc">loc</code></td>
<td>
<p> real number: location parameter of 
the Gumbel distribution. </p>
</td></tr>
<tr><td><code id="Gumbel_+3A_scale">scale</code></td>
<td>
<p> positive real number: scale parameter
of the Gumbel distribution </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"Gumbel"</code></p>


<h3>Note</h3>

<p>The class <code>"Gumbel"</code> is based on the code provided 
by the package <span class="pkg">evd</span>.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Gumbel-class">Gumbel-class</a></code>, <code><a href="evd.html#topic+gumbel">rgumbel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- Gumbel(loc = 1, scale = 2))
plot(G1)
loc(G1)
scale(G1)
loc(G1) &lt;- -1
scale(G1) &lt;- 2
plot(G1)

E(Gumbel()) # Euler's constant
E(G1, function(x){x^2})

## The function is currently defined as
function(loc = 0, scale = 1){ 
  new("Gumbel", loc = loc, scale = scale)
}
</code></pre>

<hr>
<h2 id='Gumbel-class'>Gumbel distribution</h2><span id='topic+Gumbel-class'></span><span id='topic+initialize+2CGumbel-method'></span><span id='topic+loc+2CGumbel-method'></span><span id='topic+loc+3C-+2CGumbel-method'></span><span id='topic+scale+2CGumbel-method'></span><span id='topic+scale+3C-+2CGumbel-method'></span><span id='topic++2B+2CGumbel+2Cnumeric-method'></span><span id='topic++2A+2CGumbel+2Cnumeric-method'></span><span id='topic+liesInSupport+2CGumbel+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The Gumbel cumulative distribution function with 
location parameter <code>loc</code> <code class="reqn">= \mu</code> and scale 
parameter <code>scale</code> <code class="reqn">= \sigma</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp(-\exp[-(x-\mu)/\sigma])</code>
</p>

<p>for all real x, where <code class="reqn">\sigma &gt; 0</code>; 
c.f. <code>rgumbel</code>. This distribution is also known as
extreme value distribution of type I; confer Chapter~22 of 
Johnson et al. (1995).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Gumbel", loc, scale)</code>.
More frequently they are created via the generating function 
<code>Gumbel</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"GumbelParameter"</code>. </p>
</dd>
<dt><code>r</code></dt><dd><p><code>rgumbel</code></p>
</dd>
<dt><code>d</code></dt><dd><p><code>dgumbel</code></p>
</dd>
<dt><code>p</code></dt><dd><p><code>pgumbel</code></p>
</dd>
<dt><code>q</code></dt><dd><p><code>qgumbel</code></p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code></p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Gumbel")</code>: initialize method. </p>
</dd>
<dt>loc</dt><dd><p><code>signature(object = "Gumbel")</code>: wrapped access method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "Gumbel")</code>: wrapped access method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "Gumbel")</code>: wrapped replace method for
slot <code>loc</code> of slot <code>param</code>. </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(x = "Gumbel")</code>: wrapped replace method for
slot <code>scale</code> of slot <code>param</code>. </p>
</dd>
<dt><code>+</code></dt><dd><p><code>signature(e1 = "Gumbel", e2 = "numeric")</code>: result again of 
class <code>"Gumbel"</code>; exact. </p>
</dd>
<dt><code>*</code></dt><dd><p><code>signature(e1 = "Gumbel", e2 = "numeric")</code>: result again of 
class <code>"Gumbel"</code>; exact. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "Gumbel", fun = "missing", cond = "missing")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>var</dt><dd><p><code>signature(x = "Gumbel")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>skewness</dt><dd><p><code>signature(x = "Gumbel")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>kurtosis</dt><dd><p><code>signature(x = "Gumbel")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>median</dt><dd><p><code>signature(x = "Gumbel")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>IQR</dt><dd><p><code>signature(x = "Gumbel")</code>: 
exact evaluation of expectation using explicit expressions.</p>
</dd>
<dt>liesInSupport</dt><dd><p><code>signature(object = "Gumbel", x = "numeric")</code>:
checks if <code>x</code> lies in the support of the respective distribution. </p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is based on the code provided by the package <span class="pkg">evd</span>.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Johnson et al. (1995) <em>Continuous Univariate Distributions. Vol. 2. 2nd ed.</em>
New York: Wiley.</p>


<h3>See Also</h3>

<p><code><a href="evd.html#topic+gumbel">rgumbel</a></code>, <code><a href="distr.html#topic+AbscontDistribution-class">AbscontDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- new("Gumbel", loc = 1, scale = 2))
plot(G1)
loc(G1)
scale(G1)
loc(G1) &lt;- -1
scale(G1) &lt;- 2
plot(G1)
</code></pre>

<hr>
<h2 id='GumbelLocationFamily'>Generating function for Gumbel location families</h2><span id='topic+GumbelLocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationFamily"</code> which
represents a Gumbel location family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GumbelLocationFamily(loc = 0, scale = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GumbelLocationFamily_+3A_loc">loc</code></td>
<td>
<p> location parameter </p>
</td></tr>
<tr><td><code id="GumbelLocationFamily_+3A_scale">scale</code></td>
<td>
<p> scale parameter </p>
</td></tr>
<tr><td><code id="GumbelLocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+Gumbel-class">Gumbel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##current implementation is:
theta &lt;- 0
names(theta) &lt;- "loc"
GL &lt;- ParamFamily(name = "Gumbel location family",
          param = ParamFamParameter(name = "location parameter", main = theta),
          startPar = function(x,...) c(min(x),max(x)),
          distribution = Gumbel(loc = 0, scale = 1), ## scale known!
          modifyParam = function(theta){ Gumbel(loc = theta, scale = 1) },
          props = paste(c("The Gumbel location family is invariant under",
                    "the group of transformations 'g(x) = x + loc'",
                    "with location parameter 'loc'"), collapse = " "))
GL

(G1 &lt;- GumbelLocationFamily())
plot(G1)
Map(L2deriv(G1)[[1]])
checkL2deriv(G1)
</code></pre>

<hr>
<h2 id='GumbelParameter-class'>Paramter of Gumbel distributions</h2><span id='topic+GumbelParameter-class'></span><span id='topic+loc'></span><span id='topic+loc+2CGumbelParameter-method'></span><span id='topic+loc+3C-'></span><span id='topic+loc+3C-+2CGumbelParameter-method'></span><span id='topic+scale+2CGumbelParameter-method'></span><span id='topic+scale+3C-+2CGumbelParameter-method'></span>

<h3>Description</h3>

<p>The class of the parameter of Gumbel distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GumbelParameter", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>loc</code></dt><dd><p> real number: location parameter of 
a Gumbel distribution. </p>
</dd>
<dt><code>scale</code></dt><dd><p> positive real number: scale
parameter of a Gumbel distribution. </p>
</dd>
<dt><code>name</code></dt><dd><p> default name is 
&ldquo;parameter of a Gumbel distribution&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>loc</dt><dd><p><code>signature(object = "GumbelParameter")</code>: access method for
slot <code>loc</code>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "GumbelParameter")</code>: access method for
slot <code>scale</code>. </p>
</dd>
<dt>loc&lt;-</dt><dd><p><code>signature(object = "GumbelParameter")</code>: replace method for
slot <code>loc</code>. </p>
</dd>
<dt>scale&lt;-</dt><dd><p><code>signature(x = "GumbelParameter")</code>: replace method for
slot <code>scale</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Gumbel-class">Gumbel-class</a></code>, <code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("GumbelParameter")
</code></pre>

<hr>
<h2 id='internal_interpolate_helpers_for_RobExtremes'>Internal helper functions for generating interpolation grids for
speed up in package RobExtremes</h2><span id='topic+internal_interpolate_helpers_for_RobExtremes'></span><span id='topic+.modify.xi.PFam.call'></span><span id='topic+.RMXE.xi'></span><span id='topic+.OMSE.xi'></span><span id='topic+.MBRE.xi'></span><span id='topic+.getLMGrid'></span><span id='topic+.getPsi'></span><span id='topic+.getPsi.wL'></span><span id='topic+.getPsi.P'></span><span id='topic+.is.na.Psi'></span><span id='topic+.svInt'></span><span id='topic+.generateInterpGridSn'></span>

<h3>Description</h3>

<p>These functions are used internally to generate interpolation grids,
for Lagrange multipliers or LDEstimators in package <span class="pkg">RobExtremes</span>,
to be stored in the respective &lsquo;<span class="file">sysdata.rda</span>&rsquo; file. </p>


<h3>Usage</h3>

<pre><code class='language-R'>.getPsi(param, fct, L2Fam , type)
.getPsi.wL(param, fct, L2Fam , type)
.getPsi.P(xi, L2Fam , type)


.is.na.Psi(param, fct, nam = "shape")

.modify.xi.PFam.call(xi, PFam)

.RMXE.xi(xi, PFam)
.MBRE.xi(xi, PFam)
.OMSE.xi(xi, PFam)

.getLMGrid(xiGrid = getShapeGrid(), PFam = GParetoFamily(scale=1,shape=2),
           optFct = .RMXE.xi, GridFileName="LMGrid.Rdata", withPrint = FALSE,
           len = 13)

.svInt(optF = .RMXE.th, xiGrid = getShapeGrid(700, cutoff.at.0=0.005),
       PFam = GParetoFamily(shape=1,scale=2), radius = 0.5, upper = 1e4,
       lower = 1e-4, OptOrIter = "iterate",  maxiter = 150,
       tol = .Machine$double.eps^0.5, loRad = 0, upRad = Inf, loRad0 = 1e-3,
       loRad.s = 0.2, upRad.s = 1, withStartLM = TRUE, len = 13, namFzus = "")

.generateInterpGridSn(xiGrid = getShapeGrid(500, cutoff.at.0=0.005),
                      PFam = GParetoFamily(), withPrint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_param">param</code></td>
<td>
<p>object of class <code>"ParamFamParameter"</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_fct">fct</code></td>
<td>
<p>list of functions containing the interpolators. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_l2fam">L2Fam</code></td>
<td>
<p>an object of class <code>"L2ParamFamily"</code>, the parametric family
at which to evaluate the Lagrange multipliers or LDEstimators;
in our use case, it is a shape-scale model, hence the respective
(main) parameter must contain <code>"scale"</code> and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_nam">nam</code></td>
<td>
<p>character; name of the shape parameter. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_type">type</code></td>
<td>
<p>type of the optimality: one of &quot;.OMSE&quot; for maxMSE,
&quot;.RMXE&quot; for rmx, and  &quot;.MBRE&quot; for MBRE. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_xi">xi</code></td>
<td>
<p>numeric of length 1; shape value. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_pfam">PFam</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>, the parametric family
at which to evaluate the Lagrange multipliers or LDEstimators;
in our use case, it is a shape-scale model, hence the respective
(main) parameter must contain <code>"scale"</code> and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_xigrid">xiGrid</code></td>
<td>
<p>numeric; grid of shape values. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_optfct">optFct</code>, <code id="internal_interpolate_helpers_for_RobExtremes_+3A_optf">optF</code></td>
<td>
<p>function with arguments <code>xi</code> and <code>PFam</code>;
determines the Lagrange multipliers. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_gridfilename">GridFileName</code></td>
<td>
<p>character; if <code>GridFileName!=""</code>, the pure
y-grid values are saved under this filename. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_withprint">withPrint</code></td>
<td>
<p>logical of length 1: shall current shape value be printed out?</p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_radius">radius</code></td>
<td>
<p> [for OMSE]: positive numeric of length 1: the radius of the
neighborhood for which the LM's are to be computed;
defaults to 0.5. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_lorad">loRad</code></td>
<td>
<p> the lower end point of the interval to be searched
in the inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_uprad">upRad</code></td>
<td>
<p> the upper end point of the interval to be searched in the
inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_lorad.s">loRad.s</code></td>
<td>
<p> the lower end point of the interval
to be searched in the outer optimization
(for the user-guessed radius); if <code>NULL</code>
set to <code>loRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_uprad.s">upRad.s</code></td>
<td>
<p> the upper end point of the interval to be searched in the
outer optimization (for the user-guessed radius); if
<code>NULL</code> set to <code>upRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_lorad0">loRad0</code></td>
<td>
<p> for numerical reasons: the effective lower bound for the zero search;
internally set to <code>max(loRad,loRad0)</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_withstartlm">withStartLM</code></td>
<td>
<p> logical of length 1: shall the LM's of the preceding grid
value serve as starting value for the next grid value? </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_len">len</code></td>
<td>
<p>integer; number of Lagrange multipliers to be calibrated. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_for_RobExtremes_+3A_namfzus">namFzus</code></td>
<td>
<p>character; infix for the name of the &lsquo;<span class="file">.csv</span>&rsquo;-File
to which the results are written; used to split the
work on xi-grids into chunks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.getpsi</code> reads the respective interpolating function
from an object from &lsquo;<span class="file">sysdata.rda</span>&rsquo; and generates a respective
<code>HampelIC</code> object by a call to  <code>generateIC</code>.
<code>.getpsi.wL</code> does the same thing for the 3-dim model
<code>GEVFamilyMuUnknown</code>.
Last, due to scale equivariance, or the <code>ParetoFamliy</code>, <code>.getpsi.P</code>
reads the LM's for the reference parameter and then generates
the  respective <code>HampelIC</code> object by a call to  <code>generateIC</code>.
</p>
<p><code>.is.na.Psi</code> checks whether the shape parameter already lies
beyond the range for which inter-/extrapolation is admitted
(and, correspondingly, returns <code>TRUE</code> if one has to compute the
IC completely anew.).
</p>
<p><code>.MBRE.xi</code> computes the Lagrange multipliers for the MBRE estimator,
<code>.OMSE.xi</code> for the OMSE estimator at radius <code>r=0.5</code>,
and <code>.RMXE.xi</code> the RMXE estimator.
</p>
<p><code>.svInt</code> is a short form for <code>ROptEst:::.generateInterpGrid</code>
for LM interpolation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.getpsi</code></td>
<td>
<p>an IC. </p>
</td></tr>
<tr><td><code>.is.na.Psi</code></td>
<td>
<p>logical of length 1. </p>
</td></tr>
<tr><td><code>.modify.xi.PFam.call</code></td>
<td>
<p>A call to evaluate the parametric
family at the new parameter value. </p>
</td></tr>
<tr><td><code>.MBRE.xi</code></td>
<td>
<p>A list with items <code>b</code> (a number; clipping height),
<code>a</code> (a 2-vector; outer centering),
<code>a.w</code> (a 2-vector; inner centering, in
the weight), <code>A</code> (a 2x2 matrix; outer standardization),
<code>A.w</code> (a 2x2 matrix; inner standardization, in the weight).
</p>
</td></tr>
<tr><td><code>.OMSE.xi</code></td>
<td>
<p>as <code>.MBRE.xi</code>. </p>
</td></tr>
<tr><td><code>.RMXE.xi</code></td>
<td>
<p>as <code>.MBRE.xi</code>. </p>
</td></tr>
<tr><td><code>.getLMGrid</code></td>
<td>
<p>A list with items <code>grid</code>, a matrix with the interpolation
grid and <code>fct</code> a function in <code>x</code> (the shape)
and <code>i</code> deciding on the Lagrange multiplier. </p>
</td></tr>
<tr><td><code>.generateInterpGridSn</code></td>
<td>
  <p><code>invisible(NULL)</code></p>
</td></tr>
<tr><td><code>.svInt</code></td>
<td>
  <p><code>invisible(NULL)</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions are only meant for the developers of package <span class="pkg">RobExtremes</span>
(or respective packages).
They can be used to speed up things by interpolation.
Our use case is a speed up for further scale-shape families (or enhance
existing speed-ups) such that the respective grids are stored in
the &lsquo;<span class="file">sysdata.rda</span>&rsquo; file of this package and can be used in
(exported) new particular methods for functional <code>Sn</code>.
Special attention has to be paid for R-versions pre and post R-2.16.
So if interpolation functions are desired for both alternatives, one
has to run <code>ROptEst:::.recomputeInterpolators</code> once on each
version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpolateSn">interpolateSn</a></code></p>

<hr>
<h2 id='internal_ldehelpers_for_distrMod'>Internal helper functions for treating LDEstimators in package distrMod</h2><span id='topic+internal_ldehelpers_for_distrMod'></span><span id='topic+.prepend'></span><span id='topic+.LDMatch'></span>

<h3>Description</h3>

<p>These functions are used internally by function <code>LDEstimator</code>
in package &ldquo;distrMod&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepend(prep, list0, dots = NULL)
.LDMatch(x.0, loc.est.0, disp.est.0, loc.fctal.0, disp.fctal.0,
         ParamFamily.0, loc.est.ctrl.0 = NULL, loc.fctal.ctrl.0=NULL,
         disp.est.ctrl.0 = NULL, disp.fctal.ctrl.0=NULL,
         q.lo.0 =0, q.up.0=Inf, log.q.0 =TRUE, ..., vdbg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_prep">prep</code></td>
<td>
<p>a vector; to be prepended as first argument in
a function; named <code>x</code> internally. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_list0">list0</code></td>
<td>
<p>a list to be appended to <code>prep</code>; names are taken over. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_dots">dots</code></td>
<td>
<p>an optional list (or <code>NULL</code>) to be appended to <code>prep</code>
and <code>list0</code>; names are taken over. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_x.0">x.0</code></td>
<td>
<p>a vector (numeric) at which to evaluate the LD-match</p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_loc.est.0">loc.est.0</code></td>
<td>
<p>a function expecting <code>x</code> (a numeric vector)
as first argument; location estimator. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_disp.est.0">disp.est.0</code></td>
<td>
<p>a function expecting <code>x</code> (a numeric vector)
as first argument; dispersion estimator; may only take
non-negative values.  </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_loc.fctal.0">loc.fctal.0</code></td>
<td>
<p>a function expecting a distribution object as first
argument; location functional. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_disp.fctal.0">disp.fctal.0</code></td>
<td>
<p>a function expecting a distribution object as first
argument; dispersion functional; may only take
non-negative values. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_loc.est.ctrl.0">loc.est.ctrl.0</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the location estimator. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_disp.est.ctrl.0">disp.est.ctrl.0</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the dispersion estimator.  </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_loc.fctal.ctrl.0">loc.fctal.ctrl.0</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the location functional. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_disp.fctal.ctrl.0">disp.fctal.ctrl.0</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the dispersion functional.  </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_paramfamily">ParamFamily</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>. The parametric
family at which to evaluate the LDEstimator; the respective
(main) parameter must contain <code>"scale"</code>
and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_q.lo.0">q.lo.0</code></td>
<td>
<p>numeric; lower bound for search intervall in shape parameter. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_q.up.0">q.up.0</code></td>
<td>
<p>numeric; upper bound for search intervall in shape parameter.  </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_log.q.0">log.q.0</code></td>
<td>
<p>logical; shall the zero search be done on log-scale? </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to location estimator and functional
and dispersion estimator and functional. </p>
</td></tr>
<tr><td><code id="internal_ldehelpers_for_distrMod_+3A_vdbg">vdbg</code></td>
<td>
<p>logical; if <code>TRUE</code>, debugging information is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.prepend</code> is used to produce the argument list for the calls to
estimators and functionals. This argument list consists of <code>prep</code> (first
argument), named <code>x</code> internally, the items of <code>list0</code> and, if
non-<code>NULL</code>, the items of  <code>...</code>.
</p>
<p><code>.LDMatch</code> performs the matching of location and dispersion functional
against empirical values (without any S4-structure).
</p>


<h3>Value</h3>

<table>
<tr><td><code>.prepend</code></td>
<td>
<p>a named list to be used as arguments in a call. </p>
</td></tr>
<tr><td><code>.LDMatch</code></td>
<td>
<p>a named vector with components <code>"shape"</code> and <code>"scale"</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code>
</p>

<hr>
<h2 id='InternalEstimatorReturnClasses'>Internal Estimator Return Classes in 'RobExtremes'</h2><span id='topic+InternalEstimatorReturnClasses-class'></span><span id='topic+GPDEstimate-class'></span><span id='topic+GEVEstimate-class'></span><span id='topic+GPDMCEstimate-class'></span><span id='topic+GEVMCEstimate-class'></span><span id='topic+GPDMDEstimate-class'></span><span id='topic+GEVMDEstimate-class'></span><span id='topic+GPDLDEstimate-class'></span><span id='topic+GEVLDEstimate-class'></span><span id='topic+GPDkStepEstimate-class'></span><span id='topic+GEVkStepEstimate-class'></span><span id='topic+GPDORobEstimate-class'></span><span id='topic+GEVORobEstimate-class'></span><span id='topic+GPDCvMMD.ALEstimate-class'></span><span id='topic+GEVCvMMD.ALEstimate-class'></span><span id='topic+GPDML.ALEstimate-class'></span><span id='topic+GEVML.ALEstimate-class'></span>

<h3>Description</h3>

<p>S4 classes for return values of estimators
in package <span class="pkg">RobExtremes</span> defined for internal
purposes.</p>


<h3>Described classes</h3>

<p>The S4 classes described here are <code>GPDEstimate</code>, <code>GEVEstimate</code>,
<code>GPDMCEstimate</code>, <code>GEVMCEstimate</code>,
<code>GPDMDEstimate</code>, <code>GEVMDEstimate</code>,
<code>GPDLDEstimate</code>, <code>GEVLDEstimate</code>,
<code>GPDkStepEstimate</code>, <code>GEVkStepEstimate</code>,
<code>GPDORobEstimate</code>, <code>GEVORobEstimate</code>,
<code>GPDML.ALEstimate</code>, <code>GEVML.ALEstimate</code>,
<code>GPDCvMMD.ALEstimate</code>, <code>GEVCvMMD.ALEstimate</code>.</p>


<h3>Objects from the Class</h3>

<p>These classes are used internally
to provide specific S4 methods for different estimators later on;
thus, there are no generating functions.</p>


<h3>Slots</h3>

<p>All slots are inherited from parent classes.
</p>


<h3>Extends</h3>

<p>Classes <code>GPDEstimate</code>, <code>GEVEstimate</code> extend class <code>Estimate</code>,
directly.<br />
Class <code>GPDMCEstimate</code> extends classes <code>GPDEstimate</code>,
<code>MCEstimate</code>, directly.<br />
Class <code>GEVMCEstimate</code> extends classes <code>GEVEstimate</code>,
<code>MCEstimate</code>, directly.<br />
Class <code>GPDMDEstimate</code> extends classes <code>GPDEstimate</code>,
<code>MDEstimate</code>, directly.<br />
Class <code>GEVMDEstimate</code> extends classes <code>GEVEstimate</code>,
<code>MDEstimate</code>, directly.<br />
Class <code>GPDMCALEstimate</code> extends classes <code>GPDEstimate</code>,
<code>MCALEstimate</code>, directly.<br />
Class <code>GEVMCALEstimate</code> extends classes <code>GEVEstimate</code>,
<code>MCALEstimate</code>, directly.<br />
Class <code>GPDLDEstimate</code> extends classes <code>GPDEstimate</code>,
<code>LDEstimate</code>, directly.<br />
Class <code>GEVLDEstimate</code> extends classes <code>GEVEstimate</code>,
<code>LDEstimate</code>, directly.<br />
Class <code>GPDkStepEstimate</code> extends classes <code>GPDEstimate</code>,
<code>kStepEstimate</code>, directly.<br />
Class <code>GEVkStepEstimate</code> extends classes <code>GEVEstimate</code>,
<code>kStepEstimate</code>, directly.<br />
Class <code>GPDORobEstimate</code> extends classes <code>GPDkStepEstimate</code>,
<code>ORobEstimate</code>, directly.<br />
Class <code>GEVORobEstimate</code> extends classes <code>GEVkStepEstimate</code>,
<code>ORobEstimate</code>, directly.<br />
Class <code>GPDML.ALEstimate</code> extends classes <code>GPDEstimate</code>,
<code>ML.ALEstimate</code>, directly.<br />
Class <code>GEVML.ALEstimate</code> extends classes <code>GEVEstimate</code>,
<code>ML.ALEstimate</code>, directly.<br />
Class <code>GPDCvMMD.ALEstimate</code> extends classes <code>GPDEstimate</code>,
<code>CvMMD.ALEstimate</code>, directly.<br />
Class <code>GEVCvMMD.ALEstimate</code> extends classes <code>GEVEstimate</code>,
<code>CvMMD.ALEstimate</code>, directly.<br />
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code>,
<code><a href="distrMod.html#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="RobAStBase.html#topic+kStepEstimate-class">kStepEstimate-class</a></code>,
<code><a href="#topic+LDEstimate-class">LDEstimate-class</a></code></p>

<hr>
<h2 id='InternalProbFamilyClasses-class'>Internal Classes for Method Dispatch in 'ProbFamliy' Classes</h2><span id='topic+InternalProbFamilyClasses-class'></span><span id='topic+L2LocScaleShapeUnion-class'></span><span id='topic+ParamWithLocAndScaleAndShapeFamParameter-class'></span><span id='topic+locscaleshapename'></span><span id='topic+locscaleshapename-methods'></span><span id='topic+locscaleshapename+2CL2LocScaleShapeUnion-method'></span><span id='topic+locscalename+2CL2LocScaleShapeUnion-method'></span><span id='topic+scaleshapename+2CL2LocScaleShapeUnion-method'></span><span id='topic+locationname'></span><span id='topic+locationname-methods'></span><span id='topic+locationname+2CL2LocScaleShapeUnion-method'></span><span id='topic+scalename+2CL2LocScaleShapeUnion-method'></span><span id='topic+shapename'></span><span id='topic+shapename-methods'></span><span id='topic+shapename+2CL2LocScaleShapeUnion-method'></span><span id='topic+locscaleshapename+3C-'></span><span id='topic+locscaleshapename+3C--methods'></span><span id='topic+locscaleshapename+3C-+2CL2LocScaleShapeUnion-method'></span>

<h3>Description</h3>

<p>Internal S4 classes for method dispatch in 'L2ParamFamily' and
'L2LocationFamily' (and friends) and in the respective parameter classes.</p>


<h3>Described classes</h3>

<p>In this file we describe classes <code>L2LocScaleShapeUnion</code> and
<code>ParamWithLocAndScaleAndShapeFamParameter</code>.<br />
Class <code>L2LocScaleShapeUnion</code> is a virtual class,
extending class <code>L2GroupParamFamily</code> with new slot <code>locscaleshapename</code>
(and, in fact, but not by S4 inheritance,
containing classes <code>L2ScaleShapeUnion</code> and <code>L2LocationScaleFamily</code>).
It is the parent class of class <code>GEVFamilyMuUnknown</code>.<br />
Class <code>ParamWithLocAndScaleAndShapeFamParameterUnion</code> is a virtual class
(union) containing classes <code>ParamWithScaleFamParameter</code> and
<code>ParamWithShapeFamParameter</code>.<br />
Class <code>ParamWithLocAndScaleAndShapeFamParameter</code> &ldquo;extends&rdquo; (no new
slots) class <code>ParamWithScaleAndShapeFamParameter</code>. It is the class
of the parameter in the class <code>GEVFamilyMuUnknown</code>.<br />
</p>


<h3>Objects from these classes</h3>

<p>Objects are only generated internally by the mentioned generating functions. 
</p>


<h3>Methods</h3>


<dl>
<dt>locscaleshapename</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the respective slot of the class </p>
</dd>
<dt>locscalename</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the location and scale part of the respective slot of the class </p>
</dd>
<dt>scaleshapename</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the scale and shape part of the respective slot of the class </p>
</dd>
<dt>locationname</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the location part of the respective slot of the class </p>
</dd>
<dt>scalename</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the scale part of the respective slot of the class </p>
</dd>
<dt>shapename</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion")</code>:
accesses the shape part of the respective slot of the class </p>
</dd>
<dt>locscaleshapename&lt;-</dt><dd><p><code>signature(object = "L2LocationScaleShapeUnion", value = "character")</code>:
replaces the respective slot of the class </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>,
<code><a href="distrMod.html#topic+internalClassUnions-class">L2ScaleShapeUnion-class</a></code>,
<code><a href="distrMod.html#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code>,
<code><a href="distrMod.html#topic+ParamFamParameter-class">ParamWithScaleAndShapeFamParameter-class</a></code>,
<code><a href="distrMod.html#topic+ParamFamParameter-class">ParamWithScaleFamParameter-class</a></code>,
<code><a href="distrMod.html#topic+ParamFamParameter-class">ParamWithShapeFamParameter-class</a></code>.
</p>

<hr>
<h2 id='InternalProbFamilyReturnClasses-class'>Internal return classes for generating functions</h2><span id='topic+InternalProbFamilyReturnClasses-class'></span><span id='topic+GumbelLocationFamily-class'></span><span id='topic+ParetoFamily-class'></span><span id='topic+GEVFamily-class'></span><span id='topic+GEVFamilyMuUnknown-class'></span><span id='topic+GParetoFamily-class'></span><span id='topic+WeibullFamily-class'></span>

<h3>Description</h3>

<p>Internal return classes for generating functions 'L2ParamFamily' and
'L2LocationFamily' (and friends); used for particular method dispatch only</p>


<h3>Described classes</h3>

<p>In this file we describe classes <code>GParetoFamily</code>, <code>GEVFamily</code>,
<code>GEVFamilyMuUnknown</code>, <code>WeibullFamily</code> all &ldquo;extending&rdquo;
(no new slots!) class union
<code>"L2LocationScaleShapeUnion"</code> and <code>ParetoFamily</code> &ldquo;extending&rdquo;
(no new slots!) class <code>L2ParamFamily</code>.
</p>


<h3>Objects from these classes</h3>

<p>Objects are only generated internally by the mentioned generating functions. 
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+BasicClasses">numeric-class</a></code>,
<code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>,
<code><a href="distrMod.html#topic+L2ScaleShapeUnion-class">L2ScaleShapeUnion-class</a></code>,
</p>

<hr>
<h2 id='interpolateSn'> Function to compute LD (location-dispersion) estimates </h2><span id='topic+interpolateSn'></span><span id='topic+getShapeGrid'></span><span id='topic+getSnGrid'></span>

<h3>Description</h3>

<p>Function <code>LDEstimator</code> provides a general way to compute
estimates for a given parametric family of probability measures
(with a scale and shape parameter) which
can be obtained by matching location and dispersion functionals
against empirical counterparts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getShapeGrid(gridsize=1000, centralvalue=0.7,
             withPos=TRUE, cutoff.at.0=1e-4, fac = 2)

getSnGrid(xiGrid = getShapeGrid(), PFam=GParetoFamily(), low=0,
                      upp=1.01, accuracy = 10000, GridFileName="SnGrid.Rdata",
                      withPrint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolateSn_+3A_gridsize">gridsize</code></td>
<td>
<p>integer; the size of the grid to be created. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_centralvalue">centralvalue</code></td>
<td>
<p>numeric of length 1: the central value of the grid
(for details see below). </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_withpos">withPos</code></td>
<td>
<p>logical of length 1; are negative values for the shape forbidden? </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_cutoff.at.0">cutoff.at.0</code></td>
<td>
<p>numeric of length 1: How close may we come to 0? </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_fac">fac</code></td>
<td>
<p>a scaling factor used for the respective grid values (see below). </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_xigrid">xiGrid</code></td>
<td>
<p>numeric; grid of shape values. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_pfam">PFam</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>. The parametric
family at which to evaluate the LDEstimator; the respective
(main) parameter must contain <code>"scale"</code>
and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_low">low</code></td>
<td>
<p>numeric; argument for <code><a href="#topic+Sn">Sn</a></code>. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_upp">upp</code></td>
<td>
<p>numeric; argument for <code><a href="#topic+Sn">Sn</a></code>. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_accuracy">accuracy</code></td>
<td>
<p>numeric; argument for <code><a href="#topic+Sn">Sn</a></code>. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_gridfilename">GridFileName</code></td>
<td>
<p>character; if <code>GridFileName!=""</code>, the pure
y-grid values are saved under this filename. </p>
</td></tr>
<tr><td><code id="interpolateSn_+3A_withprint">withPrint</code></td>
<td>
<p>logical of length 1: shall current shape value be printed out?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getShapeGrid</code> is a helper function to produce an unequally spaced
grid of shape values xi, with the rationale that we need values close
to some typical values more often than values at the border. The code
starts with an equally spaced grid of size <code>gridsize</code>
from <code>0.5</code> to <code>1-0.25/gridsize</code>. This is reflected at <code>0.5</code>,
and a grid of respective quantiles of <code>Norm(mean=centralvalue, sd=fac)</code>
is produced&mdash;with the heuristic rational that most estimators will be
asymptotically normal around a typical value. If <code>withPos</code> is TRUE,
negative values are cut off and replaced by respective higher quantiles of the
corresponding normal; similarly, values to close to 0 are replaced by values
between the cutoff value and the next admissible value and again by
respective higher normal quantiles.
</p>
<p><code>getSnGrid</code> is a helper function to produce a grid of <code>Sn</code> values
for a given grid of shape values and scale equal to 1 in a given
shape-scale family.
This result of this function can then be used to speed
up calls to <code>Sn</code> (or to <code>medSn</code>) by providing particular methods
for <code>Sn</code>.
For an example of such a particular method see the body of
<code>getMethod("Sn", "GPareto")</code> where object
<code>sng[["Generalized Pareto Family"]]</code> is just the result of a call
<code>getSnGrid(xiGrid = getShapeGrid(), PFam=GParetoFamily())</code> which
has been stored in the namespace of package <code>distrMod</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>getShapeGrid</code></td>
<td>
<p>a numeric grid of xi-values. </p>
</td></tr>
<tr><td><code>getSnGrid</code></td>
<td>
<p>a grid, i.e.; a matrix with columns
<code>xi</code> and <code>Sn</code>&ndash;the respective interpolation grid). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
getShapeGrid(50)
head(getShapeGrid(withPos=FALSE))

## Not run: 
### code used for the grid stored in the namespace of distrMod:
getSnGrid()

## End(Not run)
</code></pre>

<hr>
<h2 id='ismevgpdgevdiag-methods'> Methods for Diagnostic Functions in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+gpd.diag'></span><span id='topic+gev.diag'></span><span id='topic+gpd.prof'></span><span id='topic+gev.prof'></span><span id='topic+gpd.profxi'></span><span id='topic+gev.profxi'></span><span id='topic+gpd.diag-methods'></span><span id='topic+gev.diag-methods'></span><span id='topic+gpd.profxi-methods'></span><span id='topic+gev.profxi-methods'></span><span id='topic+gpd.diag+2CGPDEstimate-method'></span><span id='topic+gpd.diag+2Cgpd.fit-method'></span><span id='topic+gev.diag+2CGEVEstimate-method'></span><span id='topic+gev.diag+2Cgev.fit-method'></span><span id='topic+gpd.prof+2CGPDEstimate-method'></span><span id='topic+gpd.prof+2Cgpd.fit-method'></span><span id='topic+gev.prof+2CGEVEstimate-method'></span><span id='topic+gev.prof+2Cgev.fit-method'></span><span id='topic+gpd.profxi+2CGPDEstimate-method'></span><span id='topic+gpd.profxi+2Cgpd.fit-method'></span><span id='topic+gev.profxi+2CGEVEstimate-method'></span><span id='topic+gev.profxi+2Cgev.fit-method'></span>

<h3>Description</h3>

<p>We provide wrapper to the diagnostic plots
<code>gpd.diag</code> and <code>gev.diag</code> of package <span class="pkg">ismev</span>,
as well as to profilers <code>gpd.prof</code>, <code>gpd.profxi</code> and <code>gev.prof</code>,
<code>gev.profxi</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.diag(z,...)
## S4 method for signature 'gpd.fit'
gpd.diag(z)
## S4 method for signature 'GPDEstimate'
gpd.diag(z, npy = 365)
gev.diag(z)
## S4 method for signature 'gev.fit'
gev.diag(z)
## S4 method for signature 'GEVEstimate'
gev.diag(z)
gpd.prof(z,...)
## S4 method for signature 'gpd.fit'
gpd.prof(z, m, xlow, xup, npy = 365, conf = 0.95, nint = 100)
## S4 method for signature 'GPDEstimate'
gpd.prof(z, m, xlow, xup, npy = 365, conf = 0.95, nint = 100)
gev.prof(z,...)
## S4 method for signature 'gev.fit'
gev.prof(z, m, xlow, xup, conf = 0.95, nint = 100)
## S4 method for signature 'GEVEstimate'
gev.prof(z, m, xlow, xup, conf = 0.95, nint = 100)
gpd.profxi(z,...)
## S4 method for signature 'gpd.fit'
gpd.profxi(z,  xlow, xup, conf = 0.95, nint = 100)
## S4 method for signature 'GPDEstimate'
gpd.profxi(z,  xlow, xup, npy = 365, conf = 0.95, nint = 100)
gev.profxi(z,...)
## S4 method for signature 'gev.fit'
gev.profxi(z, xlow, xup, conf = 0.95, nint = 100)
## S4 method for signature 'GEVEstimate'
gev.profxi(z, xlow, xup, conf = 0.95, nint = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_z">z</code></td>
<td>
<p>an argument of class <code>gpd.fit</code>, <code>gev.fit</code> (recovering
the original calling convention from package <span class="pkg">ismev</span> or of class
<code>GEVFamily</code> or <code>GParetoFamily</code>.</p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_m">m</code></td>
<td>
<p>The return level (i.e.\ the profile likelihood is for the
value that is exceeded with probability <code>1/m</code>). </p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_...">...</code></td>
<td>
<p>further parameters to be passed on the specific methods. </p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_xlow">xlow</code>, <code id="ismevgpdgevdiag-methods_+3A_xup">xup</code></td>
<td>
<p>The least and greatest value at which to evaluate the
profile likelihood. </p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_npy">npy</code></td>
<td>
<p>The number of observations per year. </p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_conf">conf</code></td>
<td>
<p>The confidence coefficient of the plotted profile confidence
interval. </p>
</td></tr>
<tr><td><code id="ismevgpdgevdiag-methods_+3A_nint">nint</code></td>
<td>
<p>The number of points at which the profile likelihood is
evaluated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide a coercing of our fits of S4-classes <code>"GPDEstimate"</code>
and <code>"GEVEstimate"</code> to the (S3-)classes <code>gpd.fit</code> and <code>gev.fit</code>
of package <span class="pkg">ismev</span> (the latter being cast to an S4 class, internally, in
our package.
</p>


<h3>Value</h3>

<p>For <code>gpd.fit</code>, <code>gev.fit</code>
(quoted from package <span class="pkg">ismev</span>:
For stationary models four plots are produced; a probability plot,
a quantile plot, a return level plot and a histogram of data with
fitted density.
</p>
<p>For non-stationary models two plots are produced; a residual
probability plot and a residual quantile plot.
</p>
<p>For <code>gpd.prof</code>, <code>gev.prof</code>
(quoted from package <span class="pkg">ismev</span>:
</p>
<p>A plot of the profile likelihood is produced, with a horizontal
line representing a profile confidence interval with confidence
coefficient <code>conf</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>ismev: An   Introduction to Statistical Modeling of Extreme Values. R package
version 1.39. https://CRAN.R-project.org/package=ismev; original S functions
written by Janet E. Heffernan with R port and R documentation provided by
Alec G. Stephenson. (2012).
</p>
<p>Coles, S. (2001). <em>An introduction
to statistical modeling of extreme values.</em> London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ismev)){
  ## from ismev
  data(portpirie)
  data(rain)

  detach(package:ismev)
  ppfit &lt;- ismev::gev.fit(portpirie[,2])
  gev.diag(ppfit)
  ##
  (mlE &lt;- MLEstimator(portpirie[,2], GEVFamilyMuUnknown(withPos=FALSE)))
  gev.diag(mlE)


  ## not tested on CRAN because it takes some time...
  gev.prof(mlE, m = 10, 4.1, 5)
  gev.profxi(mlE, -0.3, 0.3)

  rnfit &lt;- ismev::gpd.fit(rain,10)
  gpd.diag(rnfit)
  ##
  mlE2 &lt;- MLEstimator(rain[rain&gt;10], GParetoFamily(loc=10))
  gpd.diag(mlE2)

  gpd.prof(mlE2, m = 10, 55, 77)
  gpd.profxi(mlE2, -0.02, 0.02)

}
</code></pre>

<hr>
<h2 id='kMAD'>Asymmetric Median of Absolute Deviations for Skewed Distributions</h2><span id='topic+kMAD'></span><span id='topic+kMAD-methods'></span><span id='topic+kMAD+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic+kMAD+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Function for the computation of asymmetric median absolute deviation (kMAD)
It coincides with ordinary median absolute deviation (MAD) for <code class="reqn">k=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kMAD(x,k,...)
## S4 method for signature 'numeric,numeric'
kMAD(x, k = 1, na.rm = TRUE, 
                eps = .Machine$double.eps, ... )
## S4 method for signature 'UnivariateDistribution,numeric'
kMAD(x, k = 1, up = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kMAD_+3A_x">x</code></td>
<td>
<p>a numeric vector or a distribution. </p>
</td></tr>
<tr><td><code id="kMAD_+3A_k">k</code></td>
<td>
<p>numeric; tunning parameter for asymmetrical MAD; has to be of length 1 and larger than 1.</p>
</td></tr>
<tr><td><code id="kMAD_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code> then <code>NA</code> values are stripped from <code>x</code> before computation takes place. </p>
</td></tr>
<tr><td><code id="kMAD_+3A_eps">eps</code></td>
<td>
<p>numeric; accuracy up to which to state equality of two numeric values </p>
</td></tr>
<tr><td><code id="kMAD_+3A_up">up</code></td>
<td>
<p>numeric; upper bound for search interval; important in distributions without left/right endpoint.</p>
</td></tr>
<tr><td><code id="kMAD_+3A_...">...</code></td>
<td>
<p>additional arguments for other functions; not used so far;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For kMAD (asymmetrial MAD)  is a root of the equation: 
</p>
<p style="text-align: center;"><code class="reqn">\mathop{\rm kMAD}(F,k) = \inf\{t&gt;0\;\mid \;F(m+kt)-F(m-t)\ge 1/2 \}</code>
</p>
<p>, 
where <code>F</code> is the cumulative distribution function, <code>m</code> is the median of <code>F</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>, 
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Ruckdeschel, P., Horbenko, N. (2010): Robustness Properties for Generalized Pareto Distributions. ITWM Report 182.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mad">mad</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
kMAD(x,k=10)
kMAD(Norm(),k=10)
</code></pre>

<hr>
<h2 id='LDEstimate-class'>LDEstimate-class.</h2><span id='topic+LDEstimate-class'></span><span id='topic+dispersion'></span><span id='topic+dispersion+2CLDEstimate-method'></span><span id='topic+location+2CLDEstimate-method'></span><span id='topic+show+2CLDEstimate-method'></span>

<h3>Description</h3>

<p>Class of Location Dispersion estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LDEstimate", ...)</code>.
More frequently they are created via the generating function
<code>LDEstimator</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate.</p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced.</p>
</dd>
<dt><code>dispersion</code></dt><dd><p>Object of class <code>"numeric"</code>:
the value of the fitted dispersion.</p>
</dd>
<dt><code>location</code></dt><dd><p>Object of class <code>"numeric"</code>:
the value of the fitted location.</p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>asvar</code></dt><dd><p> object of class <code>"OptionalMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. </p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize at which the estimate was evaluated. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part</p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
the fixed and known part of the parameter. </p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>:
a list with components <code>fct</code> and <code>mat</code> (see below). </p>
</dd>
<dt><code>untransformed.estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate.</p>
</dd>
<dt><code>untransformed.asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed 
estimator. </p>
</dd>
<dt><code>completecases</code></dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Estimate"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>dispersion</dt><dd><p><code>signature(object = "LDEstimate")</code>:
accessor function for slot <code>dispersion</code>. </p>
</dd>
<dt>location</dt><dd><p><code>signature(object = "LDEstimate")</code>:
accessor function for slot <code>location</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "LDEstimate")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code>, <code><a href="#topic+LDEstimator">LDEstimator</a></code>,
<code><a href="distrMod.html#topic+MCEstimator">MCEstimator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

(S &lt;- medQn(x, G))
dispersion(S)
location(S)
</code></pre>

<hr>
<h2 id='LDEstimator'> Function to compute LD (location-dispersion) estimates </h2><span id='topic+LDEstimator'></span><span id='topic+medkMAD'></span><span id='topic+medkMADhybr'></span><span id='topic+medSn'></span><span id='topic+medQn'></span>

<h3>Description</h3>

<p>Function <code>LDEstimator</code> provides a general way to compute
estimates for a given parametric family of probability measures
(with a scale and shape parameter) which
can be obtained by matching location and dispersion functionals
against empirical counterparts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDEstimator(x, loc.est, disp.est, loc.fctal, disp.fctal, ParamFamily,
            loc.est.ctrl = NULL, loc.fctal.ctrl=NULL,
            disp.est.ctrl = NULL, disp.fctal.ctrl=NULL,
            q.lo =1e-3, q.up=15, log.q =TRUE,
            name, Infos, asvar = NULL, nuis.idx = NULL,
            trafo = NULL, fixed = NULL, asvar.fct  = NULL, na.rm = TRUE,
            ..., .withEvalAsVar = FALSE, vdbg = FALSE)
medkMAD(x, ParamFamily, k=1, q.lo =1e-3, q.up=15, nuis.idx = NULL,
        trafo = NULL, fixed = NULL, asvar.fct = NULL, na.rm = TRUE,
        ..., .withEvalAsVar = FALSE, vdbg = FALSE)
medkMADhybr(x, ParamFamily, k=1, q.lo =1e-3, q.up=15, KK = 20, nuis.idx = NULL,
        trafo = NULL, fixed = NULL,  asvar.fct = NULL, na.rm = TRUE,
        ..., .withEvalAsVar = FALSE)
medSn(x, ParamFamily, q.lo =1e-3, q.up=10, nuis.idx = NULL,
      trafo = NULL, fixed = NULL, asvar.fct = NULL, na.rm = TRUE,
      accuracy = 100, ..., .withEvalAsVar = FALSE)
medQn(x, ParamFamily, q.lo =1e-3, q.up=15, nuis.idx = NULL,
      trafo = NULL, fixed = NULL, asvar.fct = NULL, na.rm = TRUE,
      ..., .withEvalAsVar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>. The parametric
family at which to evaluate the LDEstimator; the respective
(main) parameter must contain <code>"scale"</code>
and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_loc.est">loc.est</code></td>
<td>
<p>a function expecting <code>x</code> (a numeric vector)
as first argument; location estimator. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_disp.est">disp.est</code></td>
<td>
<p>a function expecting <code>x</code> (a numeric vector)
as first argument; dispersion estimator; may only take
non-negative values.  </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_loc.fctal">loc.fctal</code></td>
<td>
<p>a function expecting a distribution object as first
argument; location functional. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_disp.fctal">disp.fctal</code></td>
<td>
<p>a function expecting a distribution object as first
argument; dispersion functional; may only take
non-negative values. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_loc.est.ctrl">loc.est.ctrl</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the location estimator. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_disp.est.ctrl">disp.est.ctrl</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the dispersion estimator.  </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_loc.fctal.ctrl">loc.fctal.ctrl</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the location functional. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_disp.fctal.ctrl">disp.fctal.ctrl</code></td>
<td>
<p>a list (or <code>NULL</code>); optional additional arguments
for the dispersion functional.  </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_k">k</code></td>
<td>
<p>numeric; additional parameter for <code><a href="#topic+kMAD">kMAD</a></code>; must be positive
and of length 1.</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_kk">KK</code></td>
<td>
<p>numeric; Maximal number of trials with different <code>k</code> in
<code>medkMADhybr</code> . </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_q.lo">q.lo</code></td>
<td>
<p>numeric; lower bound for search intervall in shape parameter. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_q.up">q.up</code></td>
<td>
<p>numeric; upper bound for search intervall in shape parameter.  </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_log.q">log.q</code></td>
<td>
<p>logical; shall the zero search be done on log-scale? </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_name">name</code></td>
<td>
<p> optional name for estimator. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_asvar">asvar</code></td>
<td>
<p> optionally the asymptotic (co)variance of the estimator </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_nuis.idx">nuis.idx</code></td>
<td>
<p> optionally the indices of the estimate belonging
to nuisance parameter</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_fixed">fixed</code></td>
<td>
<p> optionally (numeric) the fixed part of the parameter</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_asvar.fct">asvar.fct</code></td>
<td>
<p>optionally: a function to determine the corresponding
asymptotic variance; if given, <code>asvar.fct</code> takes arguments
<code>L2Fam</code>((the parametric model as object of class <code>L2ParamFamily</code>)) 
and <code>param</code> (the parameter value as object of class 
<code>ParamFamParameter</code>); arguments are called by name; <code>asvar.fct</code>
may also process further arguments passed through the <code>...</code> argument</p>
</td></tr>              
<tr><td><code id="LDEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_accuracy">accuracy</code></td>
<td>
<p>numeric: argument to be passed on to <code><a href="#topic+Sn">Sn</a></code>. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to location estimator and functional
and dispersion estimator and functional. </p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_vdbg">vdbg</code></td>
<td>
<p>logical; if <code>TRUE</code>, debugging information is shown.</p>
</td></tr>
<tr><td><code id="LDEstimator_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>loc.est</code>, <code>disp.est</code> (location and dispersion estimators)
have to be functions with first argument <code>x</code> (a numeric vector with the
empirical data) and additional, optional individual arguments to be passed on
in the respective calls as lists <code>loc.est.ctrl</code>, <code>disp.est.ctrl</code>,
and global additional arguments through the <code>...</code> argument.
Similarly, arguments <code>loc.fctal</code>, <code>disp.fctal</code> (location and
dispersion functionals) have to be functions with first argument an
object of class <code>UnivariateDistribution</code>, and additional, optional
individual arguments to be passed on
in the respective calls as lists <code>loc.fctal.ctrl</code>, <code>disp.fctal.ctrl</code>,
and global additional arguments again through the <code>...</code> argument.
Uses <code><a href="#topic+.LDMatch">.LDMatch</a></code> internally.
</p>


<h3>Value</h3>

<p>An object of S4-class <code>"Estimate"</code>.
</p>


<h3>Note</h3>

<p>The values for <code>q.lo</code> and <code>q.up</code> are a bit delicate and
have to be found, model by model, by try and error.
As a rule, <code>medSn</code> is rather slow, as the evaluation of the <code>Sn</code>
functional is quite expensive. So if <code>medSn</code> is the estimator of choice,
it pays off, for a given shape-scale family, to evaluate <code>medSn</code> on a
grid of shape-values (with scale 1) and then to use an interpolation techniques
in a particular method to replace the default one for this shape-scale family.
As an example, we have done so for the GPD family.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Marazzi, A. and Ruffieux, C. (1999): The truncated mean of asymmetric distribution.
<em>Computational Statistics and Data Analysis</em> <b>32</b>, 79-100.
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025-1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="distrMod.html#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
set.seed(123)
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

medQn(x = x, ParamFamily = G)
medSn(x = x, ParamFamily = G, q.lo = 0.5, q.up = 4)


## not tested on CRAN because it takes time...
## without speedup for Sn:
LDEstimator(x, loc.est = median, disp.est = Sn, loc.fctal = median,
            disp.fctal = getMethod("Sn","UnivariateDistribution"),
            ParamFamily = G, disp.est.ctrl = list(constant=1))

medkMAD(x = x, ParamFamily = G)
medkMADhybr(x = x, ParamFamily = G)

medkMAD(x = x, k=10, ParamFamily = G)

##not at all robust:
LDEstimator(x, loc.est = mean, disp.est = sd,
               loc.fctal = E, disp.fctal = sd,
            ParamFamily = G)
</code></pre>

<hr>
<h2 id='movToRef-methods'>Methods for Functions moving from and to reference parameter in Package
&lsquo;RobExtremes&rsquo; </h2><span id='topic+moveL2Fam2RefParam'></span><span id='topic+moveICBackFromRefParam'></span><span id='topic+moveL2Fam2RefParam-methods'></span><span id='topic+moveICBackFromRefParam-methods'></span><span id='topic+moveL2Fam2RefParam+2CL2ScaleShapeUnion-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2ScaleShapeUnion-method'></span><span id='topic+moveICBackFromRefParam+2CIC+2CL2LocScaleShapeUnion-method'></span>

<h3>Description</h3>

<p>In <code>optIC</code> a gain in accuracy can be obtained when computing
the optimally-robust ICs at a reference parameter of the model (instead of an
arbtirary one). To this end, <code>moveL2Fam2RefParam</code> moved the model to
the reference parameter and <code>moveICBackFromRefParam</code> moves the obtained
optimal IC back to the original parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveL2Fam2RefParam(L2Fam, ...)
       moveICBackFromRefParam(IC, L2Fam,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movToRef-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p>object of class <code>L2ParamFamily</code></p>
</td></tr>
<tr><td><code id="movToRef-methods_+3A_ic">IC</code></td>
<td>
<p>IC of class <code>HampIC</code></p>
</td></tr>
<tr><td><code id="movToRef-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to particular methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moveL2Fam2RefParam</code> and <code>moveICBackFromRefParam</code> are used
internally in functions <code>robest</code> and <code>roptest</code> to compute the
optimally robust influence function according to the arguments given to them.</p>


<h3>Value</h3>

<table>
<tr><td><code>moveL2Fam2RefParam</code></td>
<td>
<p>the L2 Family transformed to reference parameter.</p>
</td></tr>
<tr><td><code>moveICBackFromRefParam</code></td>
<td>
<p>the backtransformed IC.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>moveL2Fam2RefParam</dt><dd><p><code>signature(L2Fam = "L2ScaleShapeUnion")</code>:
moves <code>L2Fam</code> to scale <code>1</code> (and, if existing location to
<code>0</code>). </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2ScaleShapeUnion")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>
(and in addition changes Lagrange multipliers accordingly),
rescaling risk where necessary. </p>
</dd>
<dt>moveICBackFromRefParam</dt><dd><p><code>signature(IC = "IC", L2Fam = "L2LocScaleShapeUnion")</code>:
moves IC in <code>IC</code> back to original location and scale in <code>L2Fam</code>
(and in addition changes Lagrange multipliers accordingly),
rescaling risk where necessary. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="ROptEst.html#topic+robest">robest</a></code>,<code><a href="ROptEst.html#topic+optIC">optIC</a></code>, <code><a href="ROptEst.html#topic+radiusMinimaxIC">radiusMinimaxIC</a></code></p>

<hr>
<h2 id='Pareto'>Generating function for Pareto-class</h2><span id='topic+Pareto'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"Pareto"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pareto(shape = 1, Min = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto_+3A_shape">shape</code></td>
<td>
<p> positive real number: shape parameter of 
the Pareto distribution. </p>
</td></tr>
<tr><td><code id="Pareto_+3A_min">Min</code></td>
<td>
<p> positive real number: Min parameter
of the Pareto distribution </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"Pareto"</code></p>


<h3>Note</h3>

<p>The class <code>"Pareto"</code> is based on the code provided 
by the package <span class="pkg">actuar</span> by  Vincent Goulet and Mathieu Pigeon.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Pareto-class">Pareto-class</a></code>, <code><a href="actuar.html#topic+SingleParameterPareto">dpareto1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- Pareto(shape = 1, Min = 1))
plot(P1)

E(Pareto()) 
E(P1)
E(P1, function(x){x^2})
var(P1)
sd(P1)
median(P1)
IQR(P1)
mad(P1)

</code></pre>

<hr>
<h2 id='Pareto-class'>Pareto distribution</h2><span id='topic+Pareto-class'></span><span id='topic+initialize+2CPareto-method'></span><span id='topic+shape+2CPareto-method'></span><span id='topic+shape+3C-+2CPareto-method'></span><span id='topic+Min+2CPareto-method'></span><span id='topic+Min+3C-+2CPareto-method'></span><span id='topic+scale+2CPareto-method'></span><span id='topic++2A+2CPareto+2Cnumeric-method'></span><span id='topic+liesInSupport+2CPareto+2Cnumeric-method'></span>

<h3>Description</h3>

<p>[borrowed from <span class="pkg">actuar</span>]:
</p>
<p>The (Single-parameter) Pareto distribution with parameter <code>shape</code>
<code class="reqn">= \alpha</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha \theta^\alpha}{x^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; \theta</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta &gt;
    0</code>.
</p>
<p>Although there appears to be two parameters, only <code>shape</code> is a true
parameter. The value of <code>min</code> <code class="reqn">= \theta</code> must be set in
advance.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Pareto", shape, Min)</code>.
More frequently they are created via the generating function 
<code>Pareto</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p>Object of class <code>"Reals"</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"ParetoParameter"</code>. </p>
</dd>
<dt><code>r</code></dt><dd><p><code>rpareto1</code></p>
</dd>
<dt><code>d</code></dt><dd><p><code>dpareto1</code></p>
</dd>
<dt><code>p</code></dt><dd><p><code>ppareto1</code></p>
</dd>
<dt><code>q</code></dt><dd><p><code>qpareto1</code></p>
</dd>
<dt><code>gaps</code></dt><dd><p>(numeric) matrix or <code>NULL</code></p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontDistribution"</code>, directly.<br />
Class <code>"UnivariateDistribution"</code>, by class <code>"AbscontDistribution"</code>.<br />
Class <code>"Distribution"</code>, by class <code>"AbscontDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Pareto")</code>: initialize method. </p>
</dd>
<dt>shape</dt><dd><p><code>signature(object = "Pareto")</code>: wrapped access method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>Min</dt><dd><p><code>signature(x = "Pareto")</code>: wrapped access method for
slot <code>Min</code> of slot <code>param</code>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "Pareto")</code>: wrapped access method for
slot <code>Min</code> of slot <code>param</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "Pareto")</code>: wrapped replace method for
slot <code>shape</code> of slot <code>param</code>. </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(x = "Pareto")</code>: wrapped replace method for
slot <code>Min</code> of slot <code>param</code>. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "Pareto", fun = "missing", cond = "missing")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>var</dt><dd><p><code>signature(signature(x = "Pareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>median</dt><dd><p><code>signature(signature(x = "Pareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>IQR</dt><dd><p><code>signature(signature(x = "Pareto")</code>:
exact evaluation using explicit expressions.</p>
</dd>
<dt>skewness</dt><dd><p><code>signature(signature(x = "Pareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>kurtosis</dt><dd><p><code>signature(signature(x = "Pareto")</code>: 
exact evaluation using explicit expressions.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "Pareto", e2 = "numeric")</code>: exact method
for this transformation &mdash; stays within this class if <code>e2&gt;0</code>. </p>
</dd>
<dt>liesInSupport</dt><dd><p><code>signature(object = "Pareto", x = "numeric")</code>:
checks if <code>x</code> lies in the support of the respective distribution. </p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is based on the code provided by the package <span class="pkg">actuar</span>
by  Vincent Goulet and Mathieu Pigeon.</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Johnson et al. (1995) <em>Continuous Univariate Distributions. Vol. 2. 2nd ed.</em>
New York: Wiley.<br />
Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2004),
<em>Loss Models, From Data to Decisions, Second Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="actuar.html#topic+SingleParameterPareto">dpareto1</a></code>, <code><a href="distr.html#topic+AbscontDistribution-class">AbscontDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- new("Pareto", shape = 1, Min = 2))
plot(P1)
shape(P1)
Min(P1)
shape(P1) &lt;- 4
Min(P1) &lt;- 2
plot(P1)
</code></pre>

<hr>
<h2 id='ParetoFamily'>Generating function for Generalized Pareto families</h2><span id='topic+ParetoFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"ParetoFamily"</code> which
represents a Pareto family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParetoFamily(Min = 1, shape = 0.5, trafo = NULL, start0Est = NULL,
                    withCentL2 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParetoFamily_+3A_min">Min</code></td>
<td>
<p> real: known/fixed threshold/location parameter </p>
</td></tr>
<tr><td><code id="ParetoFamily_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="ParetoFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or NULL: transformation of the parameter </p>
</td></tr>
<tr><td><code id="ParetoFamily_+3A_start0est">start0Est</code></td>
<td>
<p> startEstimator &mdash; if <code>NULL</code>
<code>log(2)/log(median/Min)</code> is used </p>
</td></tr>
<tr><td><code id="ParetoFamily_+3A_withcentl2">withCentL2</code></td>
<td>
<p>logical: shall L2 derivative be centered by substracting
the E()? Defaults to <code>FALSE</code>, but higher accuracy can be achieved
when set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"ParetoFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
<a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
</p>
<p>Kohl, M., Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 
762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+Pareto-class">Pareto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- ParetoFamily())
FisherInfo(P1)
checkL2deriv(P1)
</code></pre>

<hr>
<h2 id='ParetoParameter-class'>Paramter of Pareto distributions</h2><span id='topic+ParetoParameter-class'></span><span id='topic+shape'></span><span id='topic+shape+2CParetoParameter-method'></span><span id='topic+shape+3C-'></span><span id='topic+shape+3C-+2CParetoParameter-method'></span><span id='topic+Min+2CParetoParameter-method'></span><span id='topic+Min+3C-+2CParetoParameter-method'></span><span id='topic+scale+2CParetoParameter-method'></span>

<h3>Description</h3>

<p>The class of the parameter of Pareto distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ParetoParameter", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>shape</code></dt><dd><p> real number: shape parameter of 
a Pareto distribution. </p>
</dd>
<dt><code>Min</code></dt><dd><p> positive real number: Min
parameter of a Pareto distribution. </p>
</dd>
<dt><code>name</code></dt><dd><p> default name is 
&ldquo;parameter of a Pareto distribution&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>shape</dt><dd><p><code>signature(object = "ParetoParameter")</code>: access method for
slot <code>shape</code>. </p>
</dd>
<dt>Min</dt><dd><p><code>signature(x = "ParetoParameter")</code>: access method for
slot <code>Min</code>. </p>
</dd>
<dt>scale</dt><dd><p><code>signature(x = "ParetoParameter")</code>: access method for
slot <code>Min</code>. </p>
</dd>
<dt>shape&lt;-</dt><dd><p><code>signature(object = "ParetoParameter")</code>: replace method for
slot <code>shape</code>. </p>
</dd>
<dt>Min&lt;-</dt><dd><p><code>signature(x = "ParetoParameter")</code>: replace method for
slot <code>Min</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Pareto-class">Pareto-class</a></code>, <code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- new("ParetoParameter"))
Min(P1)
shape(P1)

Min(P1) &lt;- 3
shape(P1) &lt;- 4
P1

</code></pre>

<hr>
<h2 id='PickandsEstimator'> Function to compute Pickands estimates for the GPD and GEVD</h2><span id='topic+PickandsEstimator'></span><span id='topic+.PickandsEstimator'></span>

<h3>Description</h3>

<p>Function <code>PickandsEstimator</code> computes Pickands estimator
(for the GPD and GEVD) at real data and returns an object of class <code>Estimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PickandsEstimator(x, ParamFamily=GParetoFamily(), alpha=2,
            name, Infos, nuis.idx = NULL,
            trafo = NULL, fixed = NULL, na.rm = TRUE,
            ...)
.PickandsEstimator(x, alpha=2, GPD.l = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PickandsEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_alpha">alpha</code></td>
<td>
<p> numeric <code class="reqn">&gt; 1</code>; determines the variant of the Pickands-Estimator
based on matching the empirical quantiles  to levels
<code class="reqn">a_1=1-1/\alpha</code> and
<code class="reqn">a_2=1-1/\alpha^2</code> (in the GPD case) resp.
<code class="reqn">a_1=\exp(-1/\alpha)</code> and
<code class="reqn">a_1=\exp(-1/\alpha^2)</code> (in the GEVD case)
against the population counter parts. The &rdquo;classical&rdquo; Pickands Estimator
building up on the median is obtained for <code>alpha=2</code> for the GPD
and for <code>alpha = 1/log(2)</code> for the GEVD.
If <code>alpha</code> is missing we set it to the optimal value (see note below).</p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p>an object of class <code>"GParetoFamily"</code> or
<code>"GEVFamily"</code>. </p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_name">name</code></td>
<td>
<p> optional name for estimator. </p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_nuis.idx">nuis.idx</code></td>
<td>
<p> optionally the indices of the estimate belonging
to nuisance parameter</p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_fixed">fixed</code></td>
<td>
<p> optionally (numeric) the fixed part of the parameter</p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_...">...</code></td>
<td>
<p>not yet used. </p>
</td></tr>
<tr><td><code id="PickandsEstimator_+3A_gpd.l">GPD.l</code></td>
<td>
<p>logical: if  <code>TRUE</code> the variant for GPD is used, else for
GEVD.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual work is done in <code>.PickandsEstimator</code>.
The wrapper <code>PickandsEstimator</code> pre-treats the data,
and constructs a respective <code>Estimate</code> object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.PickandsEstimator</code></td>
<td>
<p>A numeric vector of length <code>2</code> with components
named <code>scale</code> and <code>shape</code>. </p>
</td></tr>
<tr><td><code>PickandsEstimator</code></td>
<td>
<p>An object of S4-class <code>"Estimate"</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The scale estimate we use, i.e., with scale = <code class="reqn">\beta</code>
and shape = <code class="reqn">\xi</code>, we estimate scale by
<code class="reqn">\beta= \xi a_1/(\alpha^\xi-1)</code>,  differs from
the one given in the original reference, where it was
<code class="reqn">\beta= \xi a_1^2/(a_2-2a_1)</code>.
The one chosen here avoids taking differences <code class="reqn">a_2-2a_1</code>
hence does not require <code class="reqn">a_2 &gt; 2a_1</code>; this leads to
(functional) breakdown point (bdp)
</p>
<p style="text-align: center;"><code class="reqn">\min(a_1,1-a_2,a_2-a_1)</code>
</p>

<p>which is independent <code class="reqn">\xi</code>, whereas the original setting leads to
a bdp  which is depending on <code class="reqn">\xi</code>
</p>
<p style="text-align: center;"><code class="reqn">\min(a_1,1-a_2,a_2-1+(2\alpha^\xi-1)^{-1/\xi})\qquad
\mbox{for GPD}</code>
</p>

<p style="text-align: center;"><code class="reqn">\min(a_1,1-a_2,a_2-\exp(-(2\alpha^\xi-1)^{-1/\xi})) \qquad
\mbox{for GEVD}</code>
</p>
<p>. As a consequence our setting, the bdp-optimal choice of
<code class="reqn">\alpha</code> for GDP is <code class="reqn">2</code> leading to bdp <code class="reqn">1/4</code>, and
<code class="reqn">2.248</code> for GEVD leading to bdp <code class="reqn">0.180</code>. For comparison, with the
original setting, at <code class="reqn">\xi=0.7</code>, this  gives optimal bdp's
<code class="reqn">0.070</code> and <code class="reqn">0.060</code> for GPD and GEVD, respectively.
The standard choice of <code class="reqn">\alpha</code> such that <code class="reqn">a_1</code>
gives the median (<code class="reqn">\alpha=2</code> in the GPD and
<code class="reqn">\alpha=1/\log(2)</code> in the GEVD) in our setting gives
bdp's of <code class="reqn">1/4</code> and <code class="reqn">0.119</code> for GPD and GEVD, respectively, and
in the original setting, at <code class="reqn">\xi=0.7</code>, gives bdp's
<code class="reqn">0.064</code> and <code class="reqn">0.023</code>.
</p>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>
<p>Pickands, J. (1975): Statistical inference using extreme order statistics.
<em>Ann. Stat.</em> <b>3</b>(1), 119&ndash;131.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="distrMod.html#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
set.seed(123)
x &lt;- rgpd(50, scale = 0.5, shape = 3)
y &lt;- rgev(50, scale = 0.5, shape = 3)
## parametric family of probability measures
P &lt;- GParetoFamily(scale = 1, shape = 2)
G &lt;- GEVFamily(scale = 1, shape = 2)
##
PickandsEstimator(x = x, ParamFamily = P)
PickandsEstimator(x = y, ParamFamily = G)
</code></pre>

<hr>
<h2 id='QuantileBCCEstimator'> Function to compute QuantileBCC estimates for the Weibull Family</h2><span id='topic+QuantileBCCEstimator'></span><span id='topic+.QBCC'></span>

<h3>Description</h3>

<p>Function <code>QuantileBCCEstimator</code> computes QuantileBCC estimator
(for the Weibull) at real data and returns an object of class <code>Estimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuantileBCCEstimator(x, p1 = 1/3, p2 = 2/3,
            name, Infos, nuis.idx = NULL,
            trafo = NULL, fixed = NULL, na.rm = TRUE,
            ...)
.QBCC(x, p1 = 1/3, p2 = 2/3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantileBCCEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_p1">p1</code>, <code id="QuantileBCCEstimator_+3A_p2">p2</code></td>
<td>
<p>levels of the quantiles; maximal breakdown point is achieved
for <code class="reqn">p1=p2-p1=1-p2=1/3</code> which is the default.</p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_name">name</code></td>
<td>
<p> optional name for estimator. </p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_nuis.idx">nuis.idx</code></td>
<td>
<p> optionally the indices of the estimate belonging
to nuisance parameter</p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_fixed">fixed</code></td>
<td>
<p> optionally (numeric) the fixed part of the parameter</p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="QuantileBCCEstimator_+3A_...">...</code></td>
<td>
<p>not yet used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual work is done in <code>.QBCC</code>.
The wrapper <code>QuantileBCCEstimator</code> pre-treats the data,
and constructs a respective <code>Estimate</code> object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.QuantileBCCEstimator</code></td>
<td>
<p>A numeric vector of length <code>2</code> with components
named <code>scale</code> and <code>shape</code>. </p>
</td></tr>
<tr><td><code>QuantileBCCEstimator</code></td>
<td>
<p>An object of S4-class <code>"Estimate"</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Boudt, K., Caliskan, D., Croux, C. (2011): Robust explicit estimators of Weibull parameters.
<em>Metrika</em>, <b>73</b> (2), 187&ndash;209.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="distrMod.html#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="distrMod.html#topic+Estimate-class">Estimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
set.seed(123)
distroptions("withgaps"=FALSE)
x &lt;- rweibull(50, scale = 0.5, shape = 3)
##
QuantileBCCEstimator(x = x)
</code></pre>

<hr>
<h2 id='rescaleFunction-methods'>Methods for Function rescaleFunction in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+rescaleFunction+2CGEVFamily-method'></span><span id='topic+rescaleFunction+2CGParetoFamily-method'></span><span id='topic+rescaleFunction+2CGEVFamilyMuUnknown-method'></span><span id='topic+rescaleFunction'></span>

<h3>Description</h3>

<p><code>rescaleFunction</code> provides the default rescaling for
a particular L2-Family for wrapper functions <code>PlotIC</code>, <code>ComparePlotIC</code>,
<code>InfoPlot</code>,  and <code>CniperPointPlot</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleFunction(L2Fam, ...)
## S4 method for signature 'GEVFamily'
rescaleFunction(L2Fam, dataFlag,rescaleFlag)
## S4 method for signature 'GParetoFamily'
rescaleFunction(L2Fam, dataFlag,rescaleFlag)
## S4 method for signature 'GEVFamilyMuUnknown'
rescaleFunction(L2Fam, dataFlag,rescaleFlag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleFunction-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p>an object of class &quot;L2ParamFamily&quot; to be dispatched on. </p>
</td></tr>
<tr><td><code id="rescaleFunction-methods_+3A_dataflag">dataFlag</code></td>
<td>
<p>logical; determines whether data is plotted in or not. </p>
</td></tr>
<tr><td><code id="rescaleFunction-methods_+3A_rescaleflag">rescaleFlag</code></td>
<td>
<p>logical; shall we rescale at all? </p>
</td></tr>
<tr><td><code id="rescaleFunction-methods_+3A_...">...</code></td>
<td>
<p> further arguments for the particular methods not be
dispatched on. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rescaleFunction</code> is realized as an S4 method in order to be
able to provide default rescalings for (new) particular L2 Families ex post
to be used in the wrapper functions </p>


<h3>Value</h3>

<p>a list with arguments needed for the rescaling by internal function
<code>.rescalefct</code>; more specifically it always
contains items <code>scaleX</code> and <code>scaleY</code>, and if <code>dataFlag==TRUE</code>,
also items <code>scaleX.fct</code>, <code>scaleX.inv</code>, <code>scaleY.fct</code>,
<code>scaleY.inv</code>, <code>x.ticks</code>, <code>y.ticks</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Mykhailo Pupashenko <a href="mailto:myhailo.pupashenko@gmail.com">myhailo.pupashenko@gmail.com</a></p>

<hr>
<h2 id='RobExtremesConstants'>Built-in Constants in package RobExtremes</h2><span id='topic+EULERMASCHERONICONSTANT'></span><span id='topic+APERYCONSTANT'></span>

<h3>Description</h3>

<p>Constants built into <span class="pkg">RobExtremes</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EULERMASCHERONICONSTANT
APERYCONSTANT
</code></pre>


<h3>Details</h3>

<p><span class="pkg">RobExtremes</span> has a small number of built-in constants.
</p>
<p>The following constants are available:
</p>

<ul>
<li> <p><code>EULERMASCHERONICONSTANT</code>: the Euler Mascheroni constant 
</p>
<p style="text-align: center;"><code class="reqn">\gamma=-\Gamma'(1)</code>
</p>

<p>given in <a href="http://mathworld.wolfram.com/Euler-MascheroniConstant.html">http://mathworld.wolfram.com/Euler-MascheroniConstant.html</a> (48);
</p>
</li>
<li> <p><code>APERYCONSTANT</code>: the Apéry constant 
</p>
<p style="text-align: center;"><code class="reqn">\zeta(3)= \frac{5}{2} (\sum_{k\ge 1}\frac{(-1)^{k-1}}{k^3 {2k\choose k}})</code>
</p>

<p>as given in <a href="http://mathworld.wolfram.com/AperysConstant.html">http://mathworld.wolfram.com/AperysConstant.html</a>, equation (8);
</p>
</li></ul>

<p>These are implemented as variables in the <span class="pkg">RobExtremes</span> name space taking
appropriate values. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EULERMASCHERONICONSTANT
APERYCONSTANT
</code></pre>

<hr>
<h2 id='validParameter-methods'> Methods for function validParameter in Package &lsquo;RobExtremes&rsquo; </h2><span id='topic+validParameter-methods'></span><span id='topic+validParameter'></span><span id='topic+validParameter+2CGParetoFamily-method'></span><span id='topic+validParameter+2CWeibullFamily-method'></span><span id='topic+validParameter+2CGEVFamily-method'></span><span id='topic+validParameter+2CParetoFamily-method'></span><span id='topic+validParameter+2CGEVFamilyMuUnknown-method'></span>

<h3>Description</h3>

<p>Methods for function <code>validParameter</code> in package <span class="pkg">RobExtremes</span>
to check whether a new parameter (e.g. &quot;proposed&quot; by an optimization)
is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validParameter(object, ...)
## S4 method for signature 'GParetoFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'WeibullFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'GEVFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'ParetoFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'GEVFamilyMuUnknown'
validParameter(object, param,
           tol=.Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validParameter-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>ParamFamily</code></p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_param">param</code></td>
<td>
<p>either a numeric vector or an object of class 
<code>ParamFamParameter</code></p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_tol">tol</code></td>
<td>
<p>accuracy upto which the conditions have to be fulfilled</p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>method for signature
</p>

<dl>
<dt><code>GParetoFamily</code></dt><dd><p>checks if both parameters are finite by <code>is.finite</code>,
if their length is 1 or 2 (e.g. if one features as nuisance parameter), and if
both are strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
<dt><code>WeibullFamily</code></dt><dd><p>checks if both parameters are finite by <code>is.finite</code>,
if their length is 1 or 2 (e.g. if one features as nuisance parameter), and if
both are strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
<dt><code>GEVFamily</code></dt><dd><p>checks if both parameters are finite by <code>is.finite</code>,
if their length is 1 or 2 (e.g. if one features as nuisance parameter), and if
both are strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
<dt><code>GParetoFamily</code></dt><dd><p>checks if both parameters are finite by <code>is.finite</code>,
if their length is 1 or 2 (e.g. if one features as nuisance parameter), and if
both are strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
<dt><code>GEVFamilyMuUnknown</code></dt><dd><p>checks if all parameters are finite by <code>is.finite</code>,
if their length is in 1,2,3 (e.g. if one features as nuisance parameter), and scale
and shape both are strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>logical</code> of length 1 &mdash; valid or not</p>


<h3>Examples</h3>

<pre><code class='language-R'> G &lt;- GParetoFamily()
 validParameter(G, c(scale=0.1, shape=2))
 validParameter(G, c(scale=-0.1, shape=-2))
</code></pre>

<hr>
<h2 id='var'>Generic Functions for the Computation of Functionals</h2><span id='topic+var'></span><span id='topic+var-methods'></span><span id='topic+var+2CGumbel-method'></span><span id='topic+var+2CGPareto-method'></span><span id='topic+var+2CGEV-method'></span><span id='topic+var+2CPareto-method'></span><span id='topic+median'></span><span id='topic+median-methods'></span><span id='topic+median+2CGumbel-method'></span><span id='topic+median+2CGEV-method'></span><span id='topic+median+2CGPareto-method'></span><span id='topic+median+2CPareto-method'></span><span id='topic+IQR'></span><span id='topic+IQR-methods'></span><span id='topic+IQR+2CGumbel-method'></span><span id='topic+IQR+2CGPareto-method'></span><span id='topic+IQR+2CGEV-method'></span><span id='topic+IQR+2CPareto-method'></span><span id='topic+skewness'></span><span id='topic+skewness-methods'></span><span id='topic+skewness+2CGumbel-method'></span><span id='topic+skewness+2CGEV-method'></span><span id='topic+skewness+2CGPareto-method'></span><span id='topic+skewness+2CPareto-method'></span><span id='topic+kurtosis'></span><span id='topic+kurtosis-methods'></span><span id='topic+kurtosis+2CGumbel-method'></span><span id='topic+kurtosis+2CGEV-method'></span><span id='topic+kurtosis+2CGPareto-method'></span><span id='topic+kurtosis+2CPareto-method'></span><span id='topic+Sn'></span><span id='topic+Sn-methods'></span><span id='topic+Sn+2CANY-method'></span><span id='topic+Sn+2CUnivariateDistribution-method'></span><span id='topic+Sn+2CNorm-method'></span><span id='topic+Sn+2CAffLinDistribution-method'></span><span id='topic+Sn+2CGPareto-method'></span><span id='topic+Sn+2CGammad-method'></span><span id='topic+Sn+2CWeibull-method'></span><span id='topic+Sn+2CGEV-method'></span><span id='topic+Sn+2CPareto-method'></span><span id='topic+Sn+2CDiscreteDistribution-method'></span><span id='topic+Qn'></span><span id='topic+Qn-methods'></span><span id='topic+Qn+2CANY-method'></span><span id='topic+Qn+2CUnivariateDistribution-method'></span><span id='topic+Qn+2CNorm-method'></span><span id='topic+Qn+2CDiscreteDistribution-method'></span><span id='topic+Qn+2CAffLinDistribution-method'></span>

<h3>Description</h3>

<p>Generic functions for the computation of functionals on distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IQR(x, ...)

## S4 method for signature 'Gumbel'
IQR(x)
## S4 method for signature 'GEV'
IQR(x)
## S4 method for signature 'GPareto'
IQR(x)
## S4 method for signature 'Pareto'
IQR(x)

median(x, ...)

## S4 method for signature 'Gumbel'
median(x)
## S4 method for signature 'GEV'
median(x)
## S4 method for signature 'GPareto'
median(x)
## S4 method for signature 'Pareto'
median(x)

var(x, ...)

## S4 method for signature 'Gumbel'
var(x, ...)
## S4 method for signature 'GEV'
var(x, ...)
## S4 method for signature 'GPareto'
var(x, ...)
## S4 method for signature 'Pareto'
var(x, ...)

skewness(x, ...)
## S4 method for signature 'Gumbel'
skewness(x, ...)
## S4 method for signature 'GEV'
skewness(x, ...)
## S4 method for signature 'GPareto'
skewness(x, ...)
## S4 method for signature 'Pareto'
skewness(x, ...)

kurtosis(x, ...)
## S4 method for signature 'Gumbel'
kurtosis(x, ...)
## S4 method for signature 'GEV'
kurtosis(x, ...)
## S4 method for signature 'GPareto'
kurtosis(x, ...)
## S4 method for signature 'Pareto'
kurtosis(x, ...)

Sn(x, ...)
## S4 method for signature 'ANY'
Sn(x,  ...)
## S4 method for signature 'UnivariateDistribution'
Sn(x, low = 0, upp = 1.01, accuracy = 1000, ...)
## S4 method for signature 'DiscreteDistribution'
Sn(x,  ...)
## S4 method for signature 'AffLinDistribution'
Sn(x,  ...)
## S4 method for signature 'Norm'
Sn(x,  ...)
## S4 method for signature 'GPareto'
Sn(x,  ...)
## S4 method for signature 'Pareto'
Sn(x,  ...)
## S4 method for signature 'GEV'
Sn(x,  ...)
## S4 method for signature 'Gammad'
Sn(x,  ...)
## S4 method for signature 'Weibull'
Sn(x,  ...)

Qn(x, ...)
## S4 method for signature 'ANY'
Qn(x,  ...)
## S4 method for signature 'UnivariateDistribution'
Qn(x, q00 = NULL, ...)
## S4 method for signature 'AffLinDistribution'
Qn(x, ...)
## S4 method for signature 'DiscreteDistribution'
Qn(x,  ...)
## S4 method for signature 'Norm'
Qn(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p> object of class <code>"UnivariateDistribution"</code></p>
</td></tr>
<tr><td><code id="var_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>fun</code> or <code>E</code></p>
</td></tr>
<tr><td><code id="var_+3A_q00">q00</code></td>
<td>
<p>numeric or NULL: determines search interval (from <code>-q00</code> to <code>q00</code>)
for <code>Qn</code>; if <code>NULL</code> (default) <code>q00</code>
is set to <code>10*q(x)(3/4)</code> internally. </p>
</td></tr>
<tr><td><code id="var_+3A_low">low</code></td>
<td>
<p>numeric; lower bound for search interval for median(abs(x-Y)) where
Y (a real constant) runs over the range of x; defaults to <code>0</code>. </p>
</td></tr>
<tr><td><code id="var_+3A_upp">upp</code></td>
<td>
<p>numeric; upper bound for search interval for median(abs(x-Y)) where
Y (a real constant) runs over the range of x; defaults to <code>1.01</code>.
Is used internally as <code>upp*(mad(x)+abs(median(x)-Y))</code>. </p>
</td></tr>
<tr><td><code id="var_+3A_accuracy">accuracy</code></td>
<td>
<p>numeric; number of grid points for <code>Sn</code>; defaults to <code>1000</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the corresponding functional at the distribution in the argument is computed.
</p>


<h3>Methods</h3>


<dl>
<dt><code>Qn</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">robustbase</span>-function <code>Qn</code> &mdash; see <code><a href="robustbase.html#topic+Qn">Qn</a></code>.</p>
</dd>
<dt><code>Qn</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd>
<p>Qn of univariate distributions.</p>
</dd>
<dt><code>Qn</code>, <code>signature(x = "DiscreteDistribution")</code>:</dt><dd>
<p>Qn of discrete distributions.</p>
</dd>
<dt><code>Qn</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd><p><code>abs(x@a) * Qn(x@X0)</code></p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">robustbase</span>-function <code>Qn</code> &mdash; see <code><a href="robustbase.html#topic+Sn">Sn</a></code>.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd>
<p>Sn of univariate distributions using pseudo-random variables (Thx to N. Horbenko).</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "DiscreteDistribution")</code>:</dt><dd>
<p>Sn of discrete distributions.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd><p><code>abs(x@a) * Sn(x@X0)</code></p>
</dd>
<dt><code>var</code>, <code>signature(x = "Gumbel")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "GPareto")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "GEV")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Gumbel")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "GPareto")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "GEV")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Gumbel")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "GEV")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "GPareto")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Gumbel")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "GEV")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "GPareto")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Gumbel")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "GEV")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "GPareto")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "Norm")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "GPareto")</code>:</dt><dd>
<p>speeded up using interpolation grid.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "GEV")</code>:</dt><dd>
<p>speeded up using interpolation grid.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "Gammad")</code>:</dt><dd>
<p>speeded up using interpolation grid.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "Weibull")</code>:</dt><dd>
<p>speeded up using interpolation grid.</p>
</dd>
<dt><code>Sn</code>, <code>signature(x = "Pareto")</code>:</dt><dd>
<p>speeded up using interpolation grid.</p>
</dd>
<dt><code>Qn</code>, <code>signature(x = "Norm")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>


<h3>Caveat</h3>

<p>If any of the packages <span class="pkg">e1071</span>, <span class="pkg">moments</span>, <span class="pkg">fBasics</span> is to be used together with <span class="pkg">distrEx</span> 
(or <span class="pkg">RobExtremes</span>) the latter must be attached <em>after</em> any of the first mentioned.
Otherwise <code>kurtosis()</code> and <code>skewness()</code>
defined as <em>methods</em> in <span class="pkg">distrEx</span> (or <span class="pkg">RobExtremes</span>) may get masked.<br />
To re-mask, you may use 
<code>kurtosis &lt;- distrEx::kurtosis; skewness &lt;- distrEx::skewness</code>. 
See also <code>distrExMASK()</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrEx.html#topic+Var">Var</a></code>,<br />
<code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+cor">var</a></code>, <code><a href="stats.html#topic+IQR">IQR</a></code>,<br />
<code><a href="stats.html#topic+median">median</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>,  <code><a href="distr.html#topic+sd-methods">sd</a></code>,<br />
<code><a href="robustbase.html#topic+Sn">Sn</a></code>,  <code><a href="robustbase.html#topic+Qn">Qn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Variance of Exp(1) distribution
G &lt;- GPareto()
var(G)

#median(Exp())
IQR(G)

## note the timing
system.time(print(Sn(GPareto(shape=0.5,scale=2))))

system.time(print(Sn(as(GPareto(shape=0.5,scale=2),"AbscontDistribution"))))

</code></pre>

<hr>
<h2 id='WeibullFamily'>Generating function for Weibull family</h2><span id='topic+WeibullFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"WeibullFamily"</code> which
represents a Generalized Pareto family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeibullFamily(scale = 1, shape = 0.5, of.interest = c("scale", "shape"),
       p = NULL, N = NULL, trafo = NULL, start0Est = NULL, withPos = TRUE,
       withCentL2 = FALSE, withL2derivDistr  = FALSE, ..ignoreTrafo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeibullFamily_+3A_scale">scale</code></td>
<td>
<p> positive real: scale parameter </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_of.interest">of.interest</code></td>
<td>
<p> character: which parameters, transformations are of interest.<br />
possibilites are: &quot;scale&quot;, &quot;shape&quot;, &quot;quantile&quot;, &quot;expected loss&quot;,
&quot;expected shortfall&quot;; a maximum number of two of these may be selected </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_p">p</code></td>
<td>
<p>real or NULL: probability needed for quantile and expected shortfall </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_n">N</code></td>
<td>
<p>real or NULL: expected frequency for expected loss </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or NULL: transformation of the parameter </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_start0est">start0Est</code></td>
<td>
<p> startEstimator &mdash; if <code>NULL</code> <code><a href="#topic+medkMADhybr">medkMADhybr</a></code> is used </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_withpos">withPos</code></td>
<td>
<p> logical of length 1: Is shape restricted to positive values? </p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_withcentl2">withCentL2</code></td>
<td>
<p>logical: shall L2 derivative be centered by substracting
the E()? Defaults to <code>FALSE</code>, but higher accuracy can be achieved
when set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>FALSE</code> (to speeds up computations).</p>
</td></tr>
<tr><td><code id="WeibullFamily_+3A_..ignoretrafo">..ignoreTrafo</code></td>
<td>
<p>logical: only used internally in <code>kStepEstimator</code>; do not change this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"WeibullFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a><br />
Nataliya Horbenko <a href="mailto:nhorbenko@gmail.com">nhorbenko@gmail.com</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
<a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.<br />
</p>
<p>Kohl, M., Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2013): Optimally-Robust Estimators in Generalized
Pareto Models. <em>Statistics</em>. <b>47</b>(4), 
762-791.
<a href="https://doi.org/10.1080/02331888.2011.628022">doi:10.1080/02331888.2011.628022</a>.<br />
</p>
<p>Ruckdeschel, P. and Horbenko, N. (2012): Yet another breakdown point notion:
EFSBP &ndash;illustrated at scale-shape models. <em>Metrika</em>, <b>75</b>(8),
1025&ndash;1047. <a href="https://doi.org/10.1007/s00184-011-0366-4">doi:10.1007/s00184-011-0366-4</a>.<br />
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Weibull-class">Weibull-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- WeibullFamily())
FisherInfo(G1)
checkL2deriv(G1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
