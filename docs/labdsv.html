<!DOCTYPE html><html><head><title>Help for package labdsv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {labdsv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abundtrans'><p>Species Abundance Data Transformation</p></a></li>
<li><a href='#abuocc'><p>Abundance/Occurrence Graphical Analysis</p></a></li>
<li><a href='#as.dsvord'><p>Convert existing and external ordinations to dsv format</p></a></li>
<li><a href='#brycesite'><p>Site Data for Bryce Canyon National Park</p></a></li>
<li><a href='#bryceveg'><p>Bryce Canyon Vegetation Data</p></a></li>
<li><a href='#calibrate'><p>Calculate fitted environmental attributes in an ordination</p></a></li>
<li><a href='#ccm'><p>Community Composition Modeling</p></a></li>
<li><a href='#compspec'><p>Compositional Specificity Analysis</p></a></li>
<li><a href='#concov'><p>Constancy-Coverage Table for Ecological Community Data</p></a></li>
<li><a href='#const'><p>Constancy Table</p></a></li>
<li><a href='#convex'><p>Convex Data Transformation</p></a></li>
<li><a href='#defactorize'><p>Change Factors in Data.frames to Character Vectors</p></a></li>
<li><a href='#dematrify'><p>Create Three Column Database Form Data Frame from Sparse Data Frames</p></a></li>
<li><a href='#dga'><p>Direct Gradient Analysis</p></a></li>
<li><a href='#disana'><p>Dissimilarity Analysis</p></a></li>
<li><a href='#dropplt'><p>Dropping Plots with Missing Values From Taxon and Site Data Frames</p></a></li>
<li><a href='#dropspc'><p>Dropping Species with Few Occurrences</p></a></li>
<li><a href='#dsvdis'><p>Dissimilarity Indices and Distance Measures</p></a></li>
<li><a href='#dsvls'><p>LabDSV Object ls() Command</p></a></li>
<li><a href='#envrtest'><p>Environmental Distribution Test</p></a></li>
<li><a href='#euclidify'><p>Nearest Euclidean Space Representation of a Dissimilarity Object</p></a></li>
<li><a href='#factorize'><p>Change Character Vectors in Data.frames to Factors</p></a></li>
<li><a href='#gsr'><p>Global Search and Replace for Data.frames</p></a></li>
<li><a href='#hellinger'><p>Hellinger Data Transformation</p></a></li>
<li><a href='#homoteneity'><p>Homoteneity Analysis of Classified Ecological Communities</p></a></li>
<li><a href='#importance'><p>Importance Table</p></a></li>
<li><a href='#indval'><p>Dufrene-Legendre Indicator Species Analysis</p></a></li>
<li><a href='#isamic'><p>Indicator Species Analysis Minimizing Intermediate Occurrences</p></a></li>
<li><a href='#labdsv.internal'><p>LabDSV Internal Functions</p></a></li>
<li><a href='#matrify'><p>Create Taxon Data.frames From Three Column Database Form</p></a></li>
<li><a href='#metrify'><p>Nearest Metric Space Representation of a Dissimilarity Object</p></a></li>
<li><a href='#neighbors'><p>Neighbors</p></a></li>
<li><a href='#nmds'><p>Nonmetric Multidimensional Scaling</p></a></li>
<li><a href='#ordcomm'><p>Re-Order the Rows and Columns of a Taxon Data Frame</p></a></li>
<li><a href='#ordcomp'><p>Ordination to Dissimilarity Comparison</p></a></li>
<li><a href='#orddist'><p>Ordination Point Pair-Wise Distance Calculation</p></a></li>
<li><a href='#ordneighbors'><p>Nearest Neighbors Plotted in Ordination Space</p></a></li>
<li><a href='#ordpart'><p>Ordination Partitioning</p></a></li>
<li><a href='#ordtest'><p>Ordination Distribution Test</p></a></li>
<li><a href='#pca'><p>Principal Components Analysis</p></a></li>
<li><a href='#pco'><p>Principal Coordinates Analysis</p></a></li>
<li><a href='#plot.dsvord'><p>Plotting Routines For LabDSV Ordinations</p></a></li>
<li><a href='#plot.thull'><p>Plotting a Tensioned Hull</p></a></li>
<li><a href='#predict'><p>Predict species abundances in an ordination</p></a></li>
<li><a href='#raretaxa'><p>Identify Rare Taxa in a Data Set</p></a></li>
<li><a href='#reconcile'><p>Reconcile Community and Site Data.Frames</p></a></li>
<li><a href='#rndcomm'><p>Randomize a Community Data.Frame</p></a></li>
<li><a href='#rnddist'><p>Random Distance</p></a></li>
<li><a href='#samptot'><p>Sample total standardization</p></a></li>
<li><a href='#spcdisc'><p>Species Discrimination Analysis</p></a></li>
<li><a href='#spcmax'><p>Species Maximum Standardization</p></a></li>
<li><a href='#stepdist'><p>Step-Across Distance</p></a></li>
<li><a href='#tsne'><p>t-Distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#vegtab'><p>Vegetation Table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-0</td>
</tr>
<tr>
<td>Title:</td>
<td>Ordination and Multivariate Analysis for Ecology</td>
</tr>
<tr>
<td>Author:</td>
<td>David W. Roberts &lt;droberts@montana.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David W. Roberts &lt;droberts@montana.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), mgcv</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, Rtsne, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optpart</td>
</tr>
<tr>
<td>Enhances:</td>
<td>vegan</td>
</tr>
<tr>
<td>Description:</td>
<td>A variety of ordination and community analyses
   useful in analysis of data sets in community ecology.  
   Includes many of the common ordination methods, with 
   graphical routines to facilitate their interpretation, 
   as well as several novel analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-01 16:58:19 UTC; dvrbts</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-10 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abundtrans'>Species Abundance Data Transformation</h2><span id='topic+abundtrans'></span>

<h3>Description</h3>

<p>Transforms species abundances according to
an arbitrary specified vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundtrans(comm,code,value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abundtrans_+3A_comm">comm</code></td>
<td>
<p>the original community data.frame</p>
</td></tr>
<tr><td><code id="abundtrans_+3A_code">code</code></td>
<td>
<p>a vector containing the set of values appearing in the original data.frame</p>
</td></tr>
<tr><td><code id="abundtrans_+3A_value">value</code></td>
<td>
<p>a vector containing the set of respective values to substitute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a respective substitution to transform specific values
in an initial data.frame to other specified values.</p>


<h3>Value</h3>

<p>a data.frame of transformed abundance data</p>


<h3>Note</h3>

<p>Vegetation data are often collected in arbitrary abundance schemes
(e.g. Braun-Blanquet, Domin, etc.) which have no direct algebraic
transformation (e.g. log).  This function transforms coded abundances to
arbitrary importance values as specified.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+decostand">decostand</a></code>, <code><a href="vegan.html#topic+wisconsin">wisconsin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
old &lt;- c(0.2,0.5,1.0,2.0,3.0,4.0,5.0,6.0)
new &lt;- c(0.2,0.5,3.0,15.0,37.5,62.5,85.0,97.5)
midpoint &lt;- abundtrans(bryceveg,old,new)
</code></pre>

<hr>
<h2 id='abuocc'>Abundance/Occurrence Graphical Analysis</h2><span id='topic+abuocc'></span>

<h3>Description</h3>

<p>Calculates and plots summary statistics about species
occurrences in a data frame</p>


<h3>Usage</h3>

<pre><code class='language-R'>abuocc(comm,minabu=0,panel='all')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abuocc_+3A_comm">comm</code></td>
<td>
<p>a community data.frame with samples as rows 
and species as columns</p>
</td></tr>
<tr><td><code id="abuocc_+3A_minabu">minabu</code></td>
<td>
<p>a minimum abundance threshold species must exceed to be 
included in the calculations (default=0)</p>
</td></tr>
<tr><td><code id="abuocc_+3A_panel">panel</code></td>
<td>
<p>controls which of four graphs is drawn, and can be 'all'
or integers 1-4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions calculates and plots four data summaries about the 
occurrence of species:
</p>
<p>Plots:
</p>
<p>1) the number of samples each species occurs in on a log scale, sorted from maximum to minimum
</p>
<p>2) the number of species in each sample plot (species richness) from highest to lowest
</p>
<p>3) the mean abundance of non-zero values (on a log scale) as a function of the number of plots a species occurs in
</p>
<p>4) the total abundance/sample as a function of the plot-level species richness
</p>
<p>The third plot allows you to identify individual species with the mouse;
the fourth plot allows you to identify individual sample units with the mouse.
</p>


<h3>Value</h3>

<p>Returns an (invisible) list composed of:
</p>
<table>
<tr><td><code>spc.plt</code></td>
<td>
<p>number of species/sample</p>
</td></tr>
<tr><td><code>plt.spc</code></td>
<td>
<p>number of samples each species occurs in</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean abundance of each species when present 
(excluding values smaller than minabu)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It's common in niche theory analyses to calculate the rank abundances 
of taxa in a sample.  This function is similar, but works on multiple samples simultaneously.
The spc.plt vector in the returned list can be used anywhere species richness is desired.  
The plt.spc vector in the returned list can be used to mask out rare species in 
calculations of sample similarity using <code><a href="#topic+dsvdis">dsvdis</a></code> among other purposes.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+fisherfit">fisherfit</a></code>, 
<code><a href="vegan.html#topic+prestonfit">prestonfit</a></code>,
<code><a href="vegan.html#topic+radfit">radfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # produces a data.frame called bryceveg
abuocc(bryceveg)
</code></pre>

<hr>
<h2 id='as.dsvord'>Convert existing and external ordinations to dsv format</h2><span id='topic+as.dsvord'></span>

<h3>Description</h3>

<p>This function updates ordinations from previous versions of labdsv and
converts ordinations of class 
&lsquo;boral&rsquo; from package boral, list output objects 
from package Rtsne, class &lsquo;metaMDS&rsquo; objects from package vegan, or class 
&lsquo;ordiplot&rsquo; objects from package vegan into objects of class &lsquo;dsvord&rsquo;
for plotting and comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dsvord(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dsvord_+3A_obj">obj</code></td>
<td>
<p>an object of class nmds, pco, pca, boral, metaMDS, or ordiplot
or an output list object from Rtsne</p>
</td></tr>
</table>


<h3>Details</h3>

<p>as.dsvord calls internal format-specific conversion functions to produce
an object of class &lsquo;dsvord&rsquo; from the given input.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;dsvord&rsquo;, i.e. a list with items
&lsquo;points&rsquo; and &lsquo;type&rsquo; (optionally more), and attributes
&lsquo;call&rsquo; and &lsquo;timestamp&rsquo; and &lsquo;class&rsquo;.
</p>


<h3>Note</h3>

<p>LabDSV recently converted all ordination objects to a single class
with an ancillary &lsquo;type&rsquo; specification to differentiate ordination
types.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(bryceveg)
dis.bc &lt;- dsvdis(bryceveg,'bray')
library(vegan)
demo.metaMDS &lt;- metaMDS(bryceveg)
metamds.dsv &lt;- as.dsvord(demo.metaMDS)
demo.ordi &lt;- plot(demo.metaMDS)
ordip.dsv &lt;- as.dsvord(demo.ordi)
library(boral)
demo.boral &lt;- boral(bryceveg,row.eff='random')
boral.dsv &lt;- as.dsvord(demo.boral)

## End(Not run)
</code></pre>

<hr>
<h2 id='brycesite'>Site Data for Bryce Canyon National Park</h2><span id='topic+brycesite'></span>

<h3>Description</h3>

<p>Environmental variables recorded at or calculated for each of 160
sample plots in Bryce Canyon National Park, Utah, U.S.A.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(brycesite)</code></pre>


<h3>Format</h3>

<p>a data.frame with sample units as rows and site variables as columns.
Variables are:
</p>

<dl>
<dt>plotcode</dt><dd><p>= original plot codes</p>
</dd>
<dt>annrad</dt><dd><p>= annual direct solar radiation in Langleys</p>
</dd>
<dt>asp</dt><dd><p>= slope aspect in degrees</p>
</dd>
<dt>av</dt><dd><p>= aspect value = (1+cosd(asp-30))/2</p>
</dd>
<dt>depth</dt><dd><p>= soil depth = &quot;deep&quot; or &quot;shallow&quot;</p>
</dd>
<dt>east</dt><dd><p>= UTM easting in meters</p>
</dd>
<dt>elev</dt><dd><p>= elevation in feet</p>
</dd>
<dt>grorad</dt><dd><p>= growing season radiation in Langleys</p>
</dd>
<dt>north</dt><dd><p>= UTM northing in meters</p>
</dd>
<dt>pos</dt><dd><p>= topographic position</p>
</dd>
<dt>quad</dt><dd><p>= USGS 7.5 minute quad sheet</p>
</dd>
<dt>slope</dt><dd><p>= percent slope</p>
</dd>
</dl>


<hr>
<h2 id='bryceveg'>Bryce Canyon Vegetation Data</h2><span id='topic+bryceveg'></span>

<h3>Description</h3>

<p>Estimates of cover class for all non-tree vascular plant 
species in 160 375<code class="reqn">m^2</code>
circular sample plots. Species codes are first three letters of genus + 
first three letters of specific epithet.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bryceveg)</code></pre>


<h3>Format</h3>

<p>a data.frame of 160 sample units (rows) and 169 species (columns).
Cover is estimated in codes as follows:
</p>

<dl>
<dt>0.2</dt><dd><p>present in the stand but not the plot</p>
</dd>
<dt>0.5</dt><dd><p>0-1%</p>
</dd>
<dt>1.0</dt><dd><p>1-5%</p>
</dd>
<dt>2.0</dt><dd><p>5-25%</p>
</dd>
<dt>3.0</dt><dd><p>25-50%</p>
</dd>
<dt>4.0</dt><dd><p>50-75%</p>
</dd>
<dt>5.0</dt><dd><p>75-95%</p>
</dd>
<dt>6.0</dt><dd><p>95-100%</p>
</dd>
</dl>


<hr>
<h2 id='calibrate'>Calculate fitted environmental attributes in an ordination</h2><span id='topic+calibrate'></span><span id='topic+calibrate.dsvord'></span>

<h3>Description</h3>

<p>Fits a Generalized Additive Model (GAM) for 
each environmental variable in a data.frame against an ordination.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsvord'
calibrate(ord,site,dims=1:ncol(ord$points),
           family='gaussian',gamma=1,keep.models=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_ord">ord</code></td>
<td>
<p>an ordination object of class dsvord</p>
</td></tr>
<tr><td><code id="calibrate_+3A_site">site</code></td>
<td>
<p>a matrix or data.frame with sample units as rows
and environmental variables as columns</p>
</td></tr>
<tr><td><code id="calibrate_+3A_dims">dims</code></td>
<td>
<p>the specific dimensions of the ordination to consider</p>
</td></tr>
<tr><td><code id="calibrate_+3A_family">family</code></td>
<td>
<p>the error distribution specifier for the GAM function</p>
</td></tr>
<tr><td><code id="calibrate_+3A_gamma">gamma</code></td>
<td>
<p>the gamma parameter to control fitting GAM models</p>
</td></tr>
<tr><td><code id="calibrate_+3A_keep.models">keep.models</code></td>
<td>
<p>a switch to control saving the individual GAM models</p>
</td></tr>
<tr><td><code id="calibrate_+3A_...">...</code></td>
<td>
<p>arguments to pass</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calibrate function sequentially and independently fits a GAM model
for each environmental variable as a function of ordination coordinates, using the 
family and gamma specifiers supplied in the function call, or their defaults.  The
model fits two or three dimensional models; if the length of dims is greater than three
the dimensions are truncated to the first three chosen.</p>


<h3>Value</h3>

<p>A list object with vector elements aic, dev.expl, adj.rsq, and fitted value matrix.  
Optionally, if keep.models is TRUE, a list with all of the GAM models fitted.
List element aic gives the model AICs for each variable, dev.expl gives the deviance 
explained, adj.rsq gives the adjusted r-Squared, and fitted gives the expected value 
of each variable in each sample unit.</p>


<h3>Author(s)</h3>

<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a> 
</p>


<h3>See Also</h3>

<p><a href="#topic+predict">predict</a> for the complementary function that fits GAM models
for species</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
dis.man &lt;- dist(bryceveg,method="manhattan")
demo.nmds &lt;- nmds(dis.man,k=4)
## Not run: res &lt;- calibrate(demo.nmds,brycesite[,c(2,4,7,12)],minocc=10)
</code></pre>

<hr>
<h2 id='ccm'>Community Composition Modeling</h2><span id='topic+ccm'></span>

<h3>Description</h3>

<p>Compares the composition of modeled communities
to real data using Bray-Curtis similarity</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccm(model,data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccm_+3A_model">model</code></td>
<td>
<p>fitted data from a predictive model</p>
</td></tr>
<tr><td><code id="ccm_+3A_data">data</code></td>
<td>
<p>actual data from the modeled communities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm sweeps through the fitted values and data
one sample unit at time calculating the similarity to the simulated community
to the real community.  The calculation is similarity, not dissimilarity, and
results in a vector of length equal to the number of sample units.
</p>
<p>The diverse matrix has the diversity of the data in the first column, and the
diversity of the simulated or fitted data in the second column.</p>


<h3>Value</h3>

<p>A list object with two components:
</p>
<table>
<tr><td><code>sim</code></td>
<td>
<p>a vector of similarities of modeled communities to 
actual data</p>
</td></tr>
<tr><td><code>diverse</code></td>
<td>
<p>Shannon-Weaver diversity values for modeled and real data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) 
bryceveg &lt;- dropspc(bryceveg,4)
bryce.bc &lt;- dsvdis(bryceveg,'bray')
bryce.nmds &lt;- nmds(bryce.bc)
## Not run: bryce.preds &lt;- predict(bryce.nmds,bryceveg)
## Not run: bryce.ccm &lt;- ccm(bryceveg,bryce.preds$fitted)
## Not run: summary(bryce.ccm$sim)
## Not run: boxplot(bryce.ccm$diverse)
</code></pre>

<hr>
<h2 id='compspec'>Compositional Specificity Analysis</h2><span id='topic+compspec'></span><span id='topic+indspc'></span><span id='topic+plot.compspec'></span>

<h3>Description</h3>

<p>Calculates the mean similarity of all plots in which each species occurs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compspec(comm, dis, numitr=100, drop=FALSE, progress=FALSE)
## S3 method for class 'compspec'
plot(x,spc=NULL,pch=1,type='p',col=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compspec_+3A_comm">comm</code></td>
<td>
<p>a data frame of community samples, samples as rows, species as columns</p>
</td></tr>
<tr><td><code id="compspec_+3A_dis">dis</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from 
<code>dist</code>,
<code><a href="#topic+dsvdis">dsvdis</a></code> or
<code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="compspec_+3A_numitr">numitr</code></td>
<td>
<p>the number of iterations to use to establish the quantiles
of the distribution</p>
</td></tr>
<tr><td><code id="compspec_+3A_drop">drop</code></td>
<td>
<p>a switch to determine whether to drop species out when calculating
their compspec value</p>
</td></tr>
<tr><td><code id="compspec_+3A_progress">progress</code></td>
<td>
<p>a switch to control printing out a progress bar</p>
</td></tr>
<tr><td><code id="compspec_+3A_x">x</code></td>
<td>
<p>an object of class compspec</p>
</td></tr>
<tr><td><code id="compspec_+3A_spc">spc</code></td>
<td>
<p>an integer code to specify exactly which species drop-out to plot</p>
</td></tr>
<tr><td><code id="compspec_+3A_pch">pch</code></td>
<td>
<p>which glyph to plot for species</p>
</td></tr>
<tr><td><code id="compspec_+3A_type">type</code></td>
<td>
<p>which type of plot</p>
</td></tr>
<tr><td><code id="compspec_+3A_col">col</code></td>
<td>
<p>an integer or integer vector) to color the points</p>
</td></tr>
<tr><td><code id="compspec_+3A_...">...</code></td>
<td>
<p>additional arguments to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with several data.frames: &lsquo;vals&rsquo; with species name, mean similarity, 
number of occurrences, and probability of observing as high a mean similarity as observed,
and &lsquo;quantiles&rsquo; with the distribution of the quantiles of mean similarity for 
given numbers of occurrences.
If drop=TRUE, results specific to dropping out each species in turn are added to the list
by species name.</p>


<h3>Note</h3>

<p>One measure of the habitat specificity of a species is the
degree to which a species only occurs in communities that are
similar to each other.  This function calculates the mean similarity of
all samples in which each species occurs, and compares that value to 
the distribution of mean similarities for randomly generated sets of the same size.  
The mean similarity of species which only occur once is set to 0, rather than NA.
</p>
<p>If drop=TRUE each species is deleted in turn and a new dissimilarity matrix minus that
species is calculated for the analysis.  This eliminates the bias that part of the similarity 
of communities being analyzed is due to the known joint occurrence of the species being analyzed.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code>indval</code>,<code>isamic</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
    # returns a Bray/Curtis dissimilarity matrix
compspec(bryceveg,dis.bc)
</code></pre>

<hr>
<h2 id='concov'>Constancy-Coverage Table for Ecological Community Data</h2><span id='topic+concov'></span>

<h3>Description</h3>

<p>Produces a table of combined species constancy and importance</p>


<h3>Usage</h3>

<pre><code class='language-R'>concov(comm,clustering,digits=1,width=5,typical=TRUE,thresh=10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concov_+3A_comm">comm</code></td>
<td>
<p>a community data.frame, samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="concov_+3A_clustering">clustering</code></td>
<td>
<p>(1) an object of class &lsquo;clustering&rsquo;, class &lsquo;partana&rsquo;, 
or class &lsquo;partition&rsquo;, (2) a vector of integer cluster memberships, (3) 
a factor vector, or (4) a character vector</p>
</td></tr>
<tr><td><code id="concov_+3A_digits">digits</code></td>
<td>
<p>the number of digits for the importance value of species</p>
</td></tr>
<tr><td><code id="concov_+3A_width">width</code></td>
<td>
<p>controls the formatting of columns</p>
</td></tr>
<tr><td><code id="concov_+3A_typical">typical</code></td>
<td>
<p>an argument passed to <code><a href="#topic+importance">importance</a></code> to control
how mean abundance is calculated</p>
</td></tr>
<tr><td><code id="concov_+3A_thresh">thresh</code></td>
<td>
<p>a threshold parameter to control the suppression of small
details in the output.  Species must have &gt;= thresh constancy in at least one
type to appear in the output table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>concov calls <code><a href="#topic+const">const</a></code> and
<code><a href="#topic+importance">importance</a></code> and then combines the output in a single table.</p>


<h3>Value</h3>

<p>a data.frame with factors (combined constancy and coverage) as columns</p>


<h3>Note</h3>

<p>Constancy-coverage tables are an informative and concise representation
of species in classified types. The output format [constancy(mean cover)] follows
the convention of the US Forest Service vegetation classifications.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+const">const</a></code>, <code><a href="#topic+importance">importance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)  # returns a vegetation data.frame
data(brycesite) # returns a site data.frame
## Not run: concov(bryceveg,brycesite$quad) # calculates the constancy 
                                         # and coverage by USGS quad
## End(Not run)
</code></pre>

<hr>
<h2 id='const'>Constancy Table</h2><span id='topic+const'></span>

<h3>Description</h3>

<p>For a classified set of vegetation samples,
lists for each species the fraction of samples in each
class the species occurs in.</p>


<h3>Usage</h3>

<pre><code class='language-R'>const(comm, clustering, minval = 0, show = minval, digits = 2, 
             sort = FALSE, spcord = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_+3A_comm">comm</code></td>
<td>
<p>a data.frame of species abundances with samples as rows and
species as columns</p>
</td></tr>
<tr><td><code id="const_+3A_clustering">clustering</code></td>
<td>
<p>(1) an object of class &lsquo;clustering&rsquo;,
class &lsquo;partana&rsquo;, or class &lsquo;partition&rsquo;, (2) a vector of 
numeric cluster memberships, (3) a factor vector, or (4) a character vector.</p>
</td></tr>
<tr><td><code id="const_+3A_minval">minval</code></td>
<td>
<p>the minimum constancy a species must have in at least
one class to be included in the output</p>
</td></tr>
<tr><td><code id="const_+3A_show">show</code></td>
<td>
<p>the minimum constancy a species must have to show a printed value</p>
</td></tr>
<tr><td><code id="const_+3A_digits">digits</code></td>
<td>
<p>the number of digits to report in the table</p>
</td></tr>
<tr><td><code id="const_+3A_sort">sort</code></td>
<td>
<p>a switch to control interactive re-ordering of the output table</p>
</td></tr>
<tr><td><code id="const_+3A_spcord">spcord</code></td>
<td>
<p>a vector of integers to specify the order in which species
should be listed in the table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a table with species as rows, and species constancy in clusters
as columns.
</p>
<p>The &lsquo;clustering&rsquo; vector represents a classification of the samples that
the table summarizes.  It may result from a cluster analysis, partitioning
an ordination, subjective partitioning of a vegetation table, or other source.
</p>
<p>The &lsquo;minval&rsquo; argument is used to emphasize the dominant species and
suppress the rare species.  Vegetation tables are often very sparse, and
this argument simplifies making them more compact.
</p>
<p>The &lsquo;digits&rsquo; argument limits the reported precision of the calculations.
Generally, relatively low precision is adequate and perhaps more realistic.
</p>
<p>The &lsquo;spcord&rsquo; argument specifies the order species are listed in a table.
You can use the reverse of the number of occurrences to get dominant species
at the top to rarer at the bottom, use fidelity values for the ordered clusters,
or possibly the order of species centroids in an ordination.
</p>


<h3>Value</h3>

<p>a data.frame with species as rows, classes as columns, with fraction
of occurrence of species in classes.</p>


<h3>Note</h3>

<p>Constancy tables are often used in vegetation classification to
calculate or present characteristic species for specific classes or types.
&lsquo;const&rsquo; may be combined with &lsquo;importance&rsquo; and &lsquo;vegtab&rsquo; to achieve a
vegetation table-oriented analysis.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+vegtab">vegtab</a></code>,
<code><a href="vegan.html#topic+vegemite">vegemite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called bryceveg
data(brycesite)
class &lt;- cut(brycesite$elev,10,labels=FALSE)
const(bryceveg,class,minval=0.25)
</code></pre>

<hr>
<h2 id='convex'>Convex Data Transformation</h2><span id='topic+convex'></span>

<h3>Description</h3>

<p>Calculates a convex data transformation for a given
number of desired classes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex(n,b=2,stand=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convex_+3A_n">n</code></td>
<td>
<p>the desired number of values</p>
</td></tr>
<tr><td><code id="convex_+3A_b">b</code></td>
<td>
<p>the base of the exponential function</p>
</td></tr>
<tr><td><code id="convex_+3A_stand">stand</code></td>
<td>
<p>a switch to control standardizing values to a maximum of 1.0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a series of values where the difference between adjacent values
is 1/b the previous difference.  With the default b=2 you get an octave scale.</p>


<h3>Value</h3>

<p>a vector of numeric values</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p>spcmax, samptot, abundtrans, hellinger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convex(5,2)
</code></pre>

<hr>
<h2 id='defactorize'>Change Factors in Data.frames to Character Vectors</h2><span id='topic+defactorize'></span>

<h3>Description</h3>

<p>Looks at each column in a data.frame, and converts factors
to character vectors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>defactorize(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defactorize_+3A_df">df</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply scans each column in a data.frame
looking for factor columns.  For each factor column it calls
the &lsquo;as.character()&rsquo; function to convert the column to a character vector.</p>


<h3>Value</h3>

<p>Returns a data.frame where every factor column has been converted
to a character vector.</p>


<h3>Note</h3>

<p>This function simplifies editing data.frames by allowing users to 
edit character columns (which have no levels constraints) and then 
converting the results to factors for modeling.  It is often used in a cycle of
</p>
<p>defactorize(df)
</p>
<p>edit the columns as necessary to correct errors or simplify
</p>
<p>factorize(df)
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+factorize">factorize</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brycesite)
brycesite &lt;- defactorize(brycesite)
brycesite$quad[brycesite$quad=='bp'] &lt;- 'BP'
brycesite &lt;- factorize(brycesite)
</code></pre>

<hr>
<h2 id='dematrify'>Create Three Column Database Form Data Frame from Sparse Data Frames</h2><span id='topic+dematrify'></span>

<h3>Description</h3>

<p>Takes a sparse matrix data frame (typical of ecological
abundance data) and converts it into three column database format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dematrify(comm, filename, sep = ",", thresh = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dematrify_+3A_comm">comm</code></td>
<td>
<p>a sparse data.frame or matrix, with samples as rows and comm 
as columns</p>
</td></tr> 
<tr><td><code id="dematrify_+3A_filename">filename</code></td>
<td>
<p>the name of the filename to produce</p>
</td></tr>
<tr><td><code id="dematrify_+3A_sep">sep</code></td>
<td>
<p>the separator to use in separating columns</p>
</td></tr>
<tr><td><code id="dematrify_+3A_thresh">thresh</code></td>
<td>
<p>the minimum abundance to be included in the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine is pure R code to convert data from sparse
matrix form to three column database form for export or reduced storage</p>


<h3>Value</h3>

<p>a data.frame with the first column the sample ID, the second column
the taxon ID, and the third column the abundance.
</p>


<h3>Note</h3>

<p>Typically, large ecological data sets are characterized by sparse matrices
of taxon abundance in samples with many zeros in the matrix.   Because these datasets
may be many columns wide, they are difficult to work with in text editors or
spreadsheets, and require excessive amount of space for storage.  The reduced three column
form is suitable for input to databases, and more easily edited.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrify">matrify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(labdsv)
data(bryceveg)
x &lt;- dematrify(bryceveg)
</code></pre>

<hr>
<h2 id='dga'>Direct Gradient Analysis</h2><span id='topic+dga'></span>

<h3>Description</h3>

<p>Direct gradient analysis is a graphical representation
of the abundance distribution of (typically) species along opposing environmental
gradients 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dga(z,x,y,step=50,pres="+",abs="-",labcex=1,
    xlab = deparse(substitute(x)), ylab = deparse(substitute(y)),
    pch = 1, title = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dga_+3A_z">z</code></td>
<td>
<p>the variable (typically a species abundance) to be plotted</p>
</td></tr>
<tr><td><code id="dga_+3A_x">x</code></td>
<td>
<p>the variable to use as the x axis</p>
</td></tr>
<tr><td><code id="dga_+3A_y">y</code></td>
<td>
<p>the variable to use as the y axis</p>
</td></tr>
<tr><td><code id="dga_+3A_step">step</code></td>
<td>
<p>controls the grid density fed to the GAM surface fitter</p>
</td></tr>
<tr><td><code id="dga_+3A_pres">pres</code></td>
<td>
<p>the symbol to print when a species is present (presence/absence mode)</p>
</td></tr>
<tr><td><code id="dga_+3A_abs">abs</code></td>
<td>
<p>the symbol to print when a species is absent (presence/absence mode)</p>
</td></tr>
<tr><td><code id="dga_+3A_labcex">labcex</code></td>
<td>
<p>the character size for contour labels</p>
</td></tr>
<tr><td><code id="dga_+3A_xlab">xlab</code></td>
<td>
<p>the x axis legend</p>
</td></tr>
<tr><td><code id="dga_+3A_ylab">ylab</code></td>
<td>
<p>the y axis legend</p>
</td></tr>
<tr><td><code id="dga_+3A_pch">pch</code></td>
<td>
<p>the symbol to print in continuous abundance plots</p>
</td></tr>
<tr><td><code id="dga_+3A_title">title</code></td>
<td>
<p>the title to print</p>
</td></tr> 
<tr><td><code id="dga_+3A_...">...</code></td>
<td>
<p>miscellaneous arguments to pass to par</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;dga&rsquo; interpolates a grid of x,y values from the supplied data
and fits a GAM (from <code><a href="mgcv.html#topic+mgcv">mgcv</a></code>) of the z variable to the grid.  
For presence/absence data (enterd as a logical) it employs a binomial family, for
species abundances a negative binomial is employed.
The GAM surface is then represented by a contour map and abundance 
symbols as described above.</p>


<h3>Value</h3>

<p>a graph of the distribution of the z variable on a grid of
x and y is displayed on the current active device.</p>


<h3>Note</h3>

<p>Direct gradient analysis was promoted by Robert Whittaker and
followers as a preferred method of vegetation analysis.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called bryceveg
x &lt;- c(0.2,0.5,1.0,2.0,3.0,4.0,5.0,6.0)
y &lt;- c(0.2,0.5,3.0,15.0,37.5,62.5,85.0,97.5)
cover &lt;- abundtrans(bryceveg,x,y)
data(brycesite)
dga(round(cover$arcpat),brycesite$elev,brycesite$av)
</code></pre>

<hr>
<h2 id='disana'>Dissimilarity Analysis</h2><span id='topic+disana'></span>

<h3>Description</h3>

<p>Dissimilarity analysis is a graphical analysis of the
distribution of values in a dissimilarity matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>disana(x, panel='all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disana_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; such as returned by
<code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+dsvdis">dsvdis</a></code>.
or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="disana_+3A_panel">panel</code></td>
<td>
<p>a switch to specify which panel of graphics should
be displayed.  Can be either an integer from 1 to 3,
or the word &lsquo;all&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates three vectors: the minimum, mean,
and maximum dissimilarity for each sample in a dissimilarity matrix.
By default it produces three plots: the sorted dissimilarity values,
the sorted min, mean, and maximum dissimilarity for each sample, and
the mean dissimilarity versus the minimum dissimilarity for each sample.
Optionally, you can identify sample plots in the last panel with the mouse.
</p>


<h3>Value</h3>

<p>Plots three graphs to the current graphical device, and returns
an (invisible) list with four components:
</p>
<table>
<tr><td><code>min</code></td>
<td>
<p>the minimum dissimilarity of each sample to all others</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the mean dissimilarity of each sample to all others</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum dissimilarity of each sample to all others</p>
</td></tr>
<tr><td><code>plots</code></td>
<td>
<p>a vector of samples identified in the last panel</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Dissimilarity matrices are often large, and difficult to visualize
directly.  &lsquo;disana&rsquo; is designed to highlight aspects of interest in these
large matrices.  If the first panel shows a long limb of constant maximum
value, you should consider recalculating the dissimilarity with a step-across adjustment.
The third panel is useful for identifying outliers, which are plots more than 0.5 dissimilar
to their nearest neighbor.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called veg
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
disana(dis.bc)
</code></pre>

<hr>
<h2 id='dropplt'>Dropping Plots with Missing Values From Taxon and Site Data Frames</h2><span id='topic+dropplt'></span>

<h3>Description</h3>

<p>Looks for plots which have missing values in site or environment
data, and deletes those plots from both the community and site data frames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropplt(comm,site,which=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropplt_+3A_comm">comm</code></td>
<td>
<p>a community data frame with samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="dropplt_+3A_site">site</code></td>
<td>
<p>a site or environment data frame with samples as rows and 
variables as columns</p>
</td></tr>
<tr><td><code id="dropplt_+3A_which">which</code></td>
<td>
<p>a switch to specify specific plots to drop from both data.frames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First looks to see that the row names of the community data frame and the
site or environment data frame are identical.  If not, it prints an error
message and exits.  If which is NULL, it then looks at the site or environment data frame for
plots or samples that have missing values, and deletes those plots from both the
community and site data frames.  Alternatively, if which is a numeric scalar or vector
it deletes the specified plots from both the community and site data.frames.</p>


<h3>Value</h3>

<p>produces a list with two components:
</p>
<table>
<tr><td><code>site</code></td>
<td>
<p>the new site data frame</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a VERY heavy-handed approach to managing missing values.  Most R
routines (including most of the labdsv package functions) have ways of handling
missing values that are fairly graceful.  This function simply maintains the
correspondence between the community and site data frames while eliminating ALL
missing values, and all plots that have missing values.</p>


<h3>Author(s)</h3>

<p> David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)  # returns a data frame called bryceveg
data(brycesite) # returns a data frame called brycesite
demo &lt;- dropplt(bryceveg,brycesite)
newcomm &lt;- demo$comm
newsite &lt;- demo$site
</code></pre>

<hr>
<h2 id='dropspc'>Dropping Species with Few Occurrences</h2><span id='topic+dropspc'></span>

<h3>Description</h3>

<p>Eliminates species from the community data frame that occur fewer than
or equal to a threshold number of occurrences.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropspc(comm,minocc=0,minabu=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropspc_+3A_comm">comm</code></td>
<td>
<p>a community data frame</p>
</td></tr>
<tr><td><code id="dropspc_+3A_minocc">minocc</code></td>
<td>
<p>the threshold number of occurrences to be dropped</p>
</td></tr>
<tr><td><code id="dropspc_+3A_minabu">minabu</code></td>
<td>
<p>the threshold minimum abundance to be dropped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is useful for eliminating species (columns) from community
data frames which never occur, which often happens if you eliminate plots, and
those plots are the only ones that contain that species.  In addition, many
species are rare in data frames, and some algorithms (especially dissimilarity
functions and table sorting routines) benefit from smaller, simpler data frames.
</p>


<h3>Value</h3>

<p>Produces a new community data frame</p>


<h3>Note</h3>

<p>This is a heavy-handed approach to managing rare species in data.frames.
It is often possible to write a mask (logical vector) that suppresses the
influence of rare species and keeps the original data.frame intact, but this
function simplifies data management for some purposes.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data frame called bryceveg
newveg &lt;- dropspc(bryceveg,5) # deletes species which 
                              # occur 5 or fewer times
</code></pre>

<hr>
<h2 id='dsvdis'>Dissimilarity Indices and Distance Measures</h2><span id='topic+dsvdis'></span>

<h3>Description</h3>

<p>This function provides a set of alternative dissimilarity indices
and distance metrics for classification and ordination, including
weighting by species (columns) and
shortest-path adjustment for dissimilarity indices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsvdis(x,index,weight=rep(1,ncol(x)),step=0.0,
       diag=FALSE, upper=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsvdis_+3A_x">x</code></td>
<td>
<p>a matrix of observations, samples as rows and variables as columns</p>
</td></tr>
<tr><td><code id="dsvdis_+3A_index">index</code></td>
<td>
<p>a specific dissimilarity or distance index (see details below)</p>
</td></tr>
<tr><td><code id="dsvdis_+3A_weight">weight</code></td>
<td>
<p>a vector of weights for species (columns)</p>
</td></tr>
<tr><td><code id="dsvdis_+3A_step">step</code></td>
<td>
<p>a threshold dissimilarity to initiate shortest-path adjustment
(0.0 is a flag for no adjustment)</p>
</td></tr>
<tr><td><code id="dsvdis_+3A_diag">diag</code></td>
<td>
<p>a switch to control returning the diagonal (default=FALSE)</p>
</td></tr>
<tr><td><code id="dsvdis_+3A_upper">upper</code></td>
<td>
<p>a switch to control returning the upper (TRUE) or lower (FALSE)
triangle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates dissimilarity or distance between
rows of a matrix of
observations according to a specific index.  Three indices convert the data to
presence/absence automatically.  In contingency table notation, they are:
</p>

<table>
<tr>
 <td style="text-align: left;">
        steinhaus </td><td style="text-align: left;"> <code class="reqn">1 - a / (a + b + c)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
        sorensen </td><td style="text-align: left;"> <code class="reqn">1 - 2a / (2a + b +c)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
        ochiai </td><td style="text-align: left;"> <code class="reqn">1 - a / \sqrt{(a+b) * (a+c)}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>Others are quantitative.  For variable i in samples x and y:
</p>

<table>
<tr>
 <td style="text-align: left;">
        ruzicka </td><td style="text-align: left;"> <code class="reqn">1 - \sum \min(x_i,y_i) / \sum \max(x_i,y_i)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
        bray/curtis </td><td style="text-align: left;"> <code class="reqn">1 - \sum[2 * \min(x_i,y_i)] / \sum x_i + y_i</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
        roberts </td><td style="text-align: left;"> <code class="reqn">1 - [(x_i+y_i) * \min(x_i,y_i) / \max(x_i,y_i)] / (x_i + y_i)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
        chisq </td><td style="text-align: left;"> <code class="reqn">(exp - obs) / \sqrt{exp}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>The weight argument allows the assignment of weights to individual species in the calculation
of plot-to-plot similarity.  The weights can be assigned by life-form, indicator value,
or for other investigator specific reasons.  For the presence/absence indices the
weights should be integers; for the quantitative indices the weights should be in the interval [0,1].
The default (rep(1,ncol(x)) is to set all species = 1.
</p>
<p>The threshold dissimilarity &lsquo;step&rsquo; sets all values greater than or equal to &quot;step&quot; to 9999.9 and
then solves for the shortest path distance connecting plots to other non-9999.9 values
in the matrix.   Step = 0.0 (the default) is a flag for &quot;no shortest-path correction&quot;.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;dist&quot;, equivalent to that from <code>dist</code>.</p>


<h3>Note</h3>

<p>Ecologists have spent a great deal of time and effort examining the properties
of different dissimilarity indices and distances for ecological data.  Many
of these indices should have more general application however.  Dissimilarity indices
are bounded [0,1], so that samples with no attributes in common cannot be more
dissimilar than 1.0, regardless of their separation along hypothetical or
real gradients.  The shortest-path adjustment provides a partial solution.
Pairs of samples more dissimilar than a specified threshold are set to
9999.9, and the algorithm solves for their actual dissimilarity from the
transitive closure of the triangle inequality.  Essentially, the dissimilarity
is replaced by the shortest connected path between points less than the
threshold apart.  In this way it is possible to obtain dissimilarities
much greater than 1.0.
</p>
<p>The chi-square distance is not usually employed directly in cluster analysis or
ordination, but is provided so that you can calculate correspondence analysis
as a principal coordinates analysis (using <code>cmdscale</code>) from a simple
distance matrix.</p>


<h3>Author(s)</h3>

<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a> 
</p>


<h3>See Also</h3>

<p><code>dist</code>, <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)   # returns a data.frame called "bryceveg"
dis.ochiai &lt;- dsvdis(bryceveg,index="ochiai")
dis.bc &lt;- dsvdis(bryceveg,index="bray/curtis")
</code></pre>

<hr>
<h2 id='dsvls'>LabDSV Object ls() Command</h2><span id='topic+dsvls'></span>

<h3>Description</h3>

<p>The function searches through all the objects in the specified
environment, and determines which ones have specific meaning
in LabDSV.  It then produces an output of a summary of every known
LabDSV object sorted by type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsvls(frame=NULL,opt='full')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsvls_+3A_frame">frame</code></td>
<td>
<p>an environment; if null substitutes parent.frame()</p>
</td></tr>
<tr><td><code id="dsvls_+3A_opt">opt</code></td>
<td>
<p>a switch for &lsquo;full&rsquo; or &lsquo;brief&rsquo; output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints output to the console</p>


<h3>Note</h3>

<p>It's common that after a while the number of objects in your
workspace can get large, and even with disciplined naming of objects
the list can get overwhelming.  dsvls() attempts to organize and 
report on the objects LabDSV understands.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
dis.bc &lt;- dsvdis(bryceveg,'bray')
nmds.bc &lt;- nmds(dis.bc,2)
dsvls()
</code></pre>

<hr>
<h2 id='envrtest'>Environmental Distribution Test</h2><span id='topic+envrtest'></span>

<h3>Description</h3>

<p>Calculates whether the value of a specified environmental variable
has an improbable distribution with respect to a specified vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>envrtest(set,env,numitr=1000,minval=0,replace=FALSE,
     plotit = TRUE, main = paste(deparse(substitute(set)),
     " on ", deparse(substitute(env))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envrtest_+3A_set">set</code></td>
<td>
<p>a vector of logical or quantitative values</p>
</td></tr>
<tr><td><code id="envrtest_+3A_env">env</code></td>
<td>
<p>the quantitative variable whose distribution is to be tested</p>
</td></tr>
<tr><td><code id="envrtest_+3A_numitr">numitr</code></td>
<td>
<p>the number of randomizations to iterate to calculate
probabilities</p>
</td></tr>
<tr><td><code id="envrtest_+3A_minval">minval</code></td>
<td>
<p>the threshold to use to partition the data into a logical
if set is quantitative</p>
</td></tr>
<tr><td><code id="envrtest_+3A_replace">replace</code></td>
<td>
<p>whether to permute (replace=FALSE) or bootstrap
(replace=TRUE) the values in the permutation test</p>
</td></tr>
<tr><td><code id="envrtest_+3A_plotit">plotit</code></td>
<td>
<p>logical; plot results if TRUE</p>
</td></tr>
<tr><td><code id="envrtest_+3A_main">main</code></td>
<td>
<p>title for plot if plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the maximum within-set difference in the values of vector
&lsquo;env&rsquo;, and the distribution of the permuted random within-set differences.  It
then plots the observed difference as a red line, and the sorted permuted
differences as a black line and prints the probability of getting such a limited distribution.
The probability is calculated by permuting numitr-1 times, counting the number
of times the permuted maximum difference is as small or smaller than observed (n),
and calculating (n+1)/numitr.  To get three-digit probabilities, set numitr=1000 (the default)
</p>


<h3>Value</h3>

<p>Produces a plot on the current graphics device, and an invisible list with the
components observed within-set difference and the p-value.
</p>


<h3>Note</h3>

<p>The plot is based on the concept of constraint, or limiting value, and
checks to see whether the distribution of a particular variable within a cluster
is constrained in an improbable way.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
data(brycesite) # returns and environmental data.frame
envrtest(bryceveg$berrep&gt;0,brycesite$elev)
</code></pre>

<hr>
<h2 id='euclidify'>Nearest Euclidean Space Representation of a Dissimilarity Object</h2><span id='topic+euclidify'></span><span id='topic+as.euclidean'></span>

<h3>Description</h3>

<p>Calculates the nearest Euclidean space representation of a 
dissimilarity object by iterating the transitive closure of the
triangle inequality</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidify(dis,upper=FALSE,diag=FALSE)
as.euclidean(dis,upper=FALSE,diag=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidify_+3A_dis">dis</code></td>
<td>
<p>a distance or dissimilarity object returned from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or <code><a href="#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="euclidify_+3A_upper">upper</code></td>
<td>
<p>a logical switch to control whether to return the lower triangle
(upper=FALSE) or upper triangle (upper=TRUE) of the distance matrix</p>
</td></tr>
<tr><td><code id="euclidify_+3A_diag">diag</code></td>
<td>
<p>a logical switch to control whether to return the diagonal of
the distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements a constrained iteration of the transitive closure of
Pythagoras' theorem, such that the squared distance between any two objects is
less than or equal to the sum of the squared distances from the two objects to all possible
third objects.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;dist&rsquo;</p>


<h3>Note</h3>

<p>Many multivariate statistical methods are designed for euclidean spaces,
and yet the direct calculation of euclidean distance is often inappropriate due
to problems with joint absences.  euclidify takes any dissimilarity matrix and
converts it to the closest euclidean representation, generally to avoid negative
eigenvalues in an eigenanalysis of the matrix.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrify">metrify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis') # calculate a Bray/Curtis
                                         # dissimilarity matrix
dis.euc &lt;- euclidify(dis.bc) # calculate the nearest euclidean 
                             # representation 
## Not run: plot(dis.bc,dis.euc)
</code></pre>

<hr>
<h2 id='factorize'>Change Character Vectors in Data.frames to Factors</h2><span id='topic+factorize'></span>

<h3>Description</h3>

<p>Looks at each column in a data.frame, and converts character
vector columns to factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorize(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorize_+3A_df">df</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply scans each column in a data.frame
looking for character vector columns.  For each character column it calls
the &lsquo;factor()&rsquo; function to convert the column to a factor.</p>


<h3>Value</h3>

<p>Returns a data.frame where every character column has been converted
to a factor</p>


<h3>Note</h3>

<p>This function simplifies editing data.frames by allowing users to 
edit character columns (which have no levels constraints) and then 
converting the results to factors for modeling.  It is often used in a cycle of
</p>
<p>defactorize(df)
</p>
<p>edit the columns as necessary to correct errors or simplify
</p>
<p>factorize(df)
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+defactorize">defactorize</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brycesite)
brycesite &lt;- defactorize(brycesite)
brycesite$quad[brycesite$quad=='bp'] &lt;- 'BP'
brycesite &lt;- factorize(brycesite)
</code></pre>

<hr>
<h2 id='gsr'>Global Search and Replace for Data.frames</h2><span id='topic+gsr'></span>

<h3>Description</h3>

<p>Performs in-place editing of data.frames that have
factor columns while correcting for the change to levels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsr(field,old,new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsr_+3A_field">field</code></td>
<td>
<p>a vector or specific column in a data.frame</p>
</td></tr>
<tr><td><code id="gsr_+3A_old">old</code></td>
<td>
<p>a character vector of values to search for</p>
</td></tr>
<tr><td><code id="gsr_+3A_new">new</code></td>
<td>
<p>a character vector of values to replace the 
respective items in old</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function temporarily converts a vector or vector column in a data.frame
to a character vector, and then loops through the &lsquo;old&rsquo; vector
looking for values to replace with the respective value in the &lsquo;new&rsquo;
vector.  The column is then converted back to a factor.</p>


<h3>Value</h3>

<p>a factor vector</p>


<h3>Note</h3>

<p>The function is designed to make simple editing changes to data.frames
or factor vectors, resetting the levels appropriately.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brycesite)
brycesite$quad &lt;- gsr(brycesite$quad,
    old=c('bp','bc','pc','rp','tc','tr'),
    new=c('BP','BC','PC','RP','TC','TR'))
</code></pre>

<hr>
<h2 id='hellinger'>Hellinger Data Transformation</h2><span id='topic+hellinger'></span>

<h3>Description</h3>

<p>Performs the Hellinger data transformation 
(square root of sample total standardized data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellinger(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellinger_+3A_comm">comm</code></td>
<td>
<p>a community data.frame (samples as rows, species as columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a sample total standardization (all values in a 
row are divided by the row sum), and then takes the square root of the 
values.
</p>


<h3>Value</h3>

<p>A community data.frame
</p>


<h3>Note</h3>

<p>Hellinger standardization is a convex standardization that 
simultaneously helps minimize effects of vastly different sample total
abundances.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p>spcmax, samptot, abundtrans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
hellveg &lt;- hellinger(bryceveg)
</code></pre>

<hr>
<h2 id='homoteneity'>Homoteneity Analysis of Classified Ecological Communities</h2><span id='topic+homoteneity'></span>

<h3>Description</h3>

<p>Homoteneity is defined as &lsquo;the mean constancy of the S most constant
species, expressed as a fraction, where S is the mean species richness of a
type.&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homoteneity(comm,clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homoteneity_+3A_comm">comm</code></td>
<td>
<p>a data.frame of species abundances with samples as rows and
species as columns</p>
</td></tr>
<tr><td><code id="homoteneity_+3A_clustering">clustering</code></td>
<td>
<p>a vector of (integer) class memberships, or an object of
class &lsquo;clustering&rsquo;, class &lsquo;partana&rsquo;,
or class <code><a href="cluster.html#topic+partition">partition</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of homoteneity values
</p>


<h3>Note</h3>

<p>This function was adapted from the Virginia Heritage
Program at 
</p>
<p>http://www.dcr.virginia.gov/natural_heritage/ncstatistics.shtml</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+const">const</a></code>, <code><a href="#topic+concov">concov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame of species in sample plots   
data(brycesite) # returns a data.frame of site variables
homoteneity(bryceveg,brycesite$quad) # analysis of species constancy
                                     # by USGS quad location
</code></pre>

<hr>
<h2 id='importance'>Importance Table</h2><span id='topic+importance'></span><span id='topic+importance.default'></span>

<h3>Description</h3>

<p>For a classified set of vegetation samples,
a importance table lists for each species
the average or typical abundance of each species in each class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance(comm,clustering,minval=0,digits=2,show=minval,
       sort=FALSE,typical=TRUE,spcord,dots=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importance_+3A_comm">comm</code></td>
<td>
<p>a data.frame of species abundances with samples as rows and
species as columns</p>
</td></tr>
<tr><td><code id="importance_+3A_clustering">clustering</code></td>
<td>
<p>a vector of (integer) class memberships, or an object of
class &lsquo;clustering&rsquo;, class &lsquo;partana&rsquo;,
of class <code><a href="cluster.html#topic+partition">partition</a></code></p>
</td></tr>
<tr><td><code id="importance_+3A_minval">minval</code></td>
<td>
<p>the minimum importance a species must have in at least one class
to be included in the output</p>
</td></tr>
<tr><td><code id="importance_+3A_digits">digits</code></td>
<td>
<p>the number of digits to report in the table</p>
</td></tr>
<tr><td><code id="importance_+3A_show">show</code></td>
<td>
<p>the minimum value a species must have to print a value</p>
</td></tr>
<tr><td><code id="importance_+3A_sort">sort</code></td>
<td>
<p>a switch to control interactive re-ordering</p>
</td></tr> 
<tr><td><code id="importance_+3A_typical">typical</code></td>
<td>
<p>a switch to control how mean abundance is calculated.
Typical=TRUE divides the sum of species abundance by the number of plots in which
it occurs; typical=FALSE divides by the number of plots in the type</p>
</td></tr>
<tr><td><code id="importance_+3A_spcord">spcord</code></td>
<td>
<p>a vector of integers to specify the order in which species
should be listed in the table</p>
</td></tr>
<tr><td><code id="importance_+3A_dots">dots</code></td>
<td>
<p>a switch to control substituting dots for small values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with species as rows, classes as columns, with
average abundance of species in classes.</p>


<h3>Note</h3>

<p>Importance tables are often used in vegetation classification to
calculate or present characteristic species for specific classes or types.
Importance may be combined with <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+concov">concov</a></code> and <code><a href="#topic+vegtab">vegtab</a></code> to achieve a
vegetation table-oriented analysis.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+const">const</a></code>, <code><a href="#topic+vegtab">vegtab</a></code>,
<code><a href="#topic+concov">concov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called bryceveg
data(brycesite)
class &lt;- cut(brycesite$elev,10,labels=FALSE)
importance(bryceveg,class,minval=0.25)
</code></pre>

<hr>
<h2 id='indval'>Dufrene-Legendre Indicator Species Analysis</h2><span id='topic+indval'></span><span id='topic+duleg'></span><span id='topic+indval.default'></span><span id='topic+indval.stride'></span><span id='topic+summary.indval'></span>

<h3>Description</h3>

<p>Calculates the indicator value (fidelity and relative abundance) of
species in clusters or types.</p>


<h3>Usage</h3>

<pre><code class='language-R'>indval(x, ...)
## Default S3 method:
indval(x,clustering,numitr=1000,...)
## S3 method for class 'stride'
indval(x,comm,numitr=1,...)
## S3 method for class 'indval'
summary(object, p=0.05, type='short', digits=2, show=p,
       sort=FALSE, too.many=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indval_+3A_x">x</code></td>
<td>
<p>a matrix or data.frame of samples with species as columns and
samples as rows, or an object of class &lsquo;stride&rsquo; from function
<code><a href="optpart.html#topic+stride">stride</a></code></p>
</td></tr>
<tr><td><code id="indval_+3A_clustering">clustering</code></td>
<td>
<p>a vector of numeric cluster memberships for samples, or a
classification object returned from <code><a href="cluster.html#topic+pam">pam</a></code>, 
or <code><a href="optpart.html#topic+optpart">optpart</a></code>, <code><a href="optpart.html#topic+slice">slice</a></code>,
or <code><a href="optpart.html#topic+archi">archi</a></code></p>
</td></tr>
<tr><td><code id="indval_+3A_numitr">numitr</code></td>
<td>
<p>the number of randomizations to iterate to calculate
probabilities</p>
</td></tr>
<tr><td><code id="indval_+3A_comm">comm</code></td>
<td>
<p>a data.frame with samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="indval_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;indval&rsquo;</p>
</td></tr>
<tr><td><code id="indval_+3A_p">p</code></td>
<td>
<p>the maximum probability for a species to be listed in the summary</p>
</td></tr>
<tr><td><code id="indval_+3A_type">type</code></td>
<td>
<p>a switch to choose between &lsquo;short&rsquo; and &lsquo;long&rsquo; style summary</p>
</td></tr>
<tr><td><code id="indval_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to show</p>
</td></tr>
<tr><td><code id="indval_+3A_show">show</code></td>
<td>
<p>the threshold to show values as opposed to a dot column place-holder</p>
</td></tr>
<tr><td><code id="indval_+3A_sort">sort</code></td>
<td>
<p>a switch to control user-managed interactive table sorting</p>
</td></tr>
<tr><td><code id="indval_+3A_too.many">too.many</code></td>
<td>
<p>a threshold reduce the listing for large data sets</p>
</td></tr>
<tr><td><code id="indval_+3A_...">...</code></td>
<td>
<p>additional arguments to the summary or generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the indicator value &lsquo;d&rsquo; of species as the product of the 
relative frequency and relative average abundance in clusters.  Specifically,
</p>
<p>where:<br />
<code class="reqn">p_{ij}</code> =  presence/absence (1/0) of species <code class="reqn">i</code> in 
sample <code class="reqn">j</code>; <br />
<code class="reqn">x_{ij}</code> =  abundance of species <code class="reqn">i</code> in sample <code class="reqn">j</code>; <br />
<code class="reqn">n_c</code> = number of samples in cluster <code class="reqn">c</code>;<br />
for cluster <code class="reqn">c \in K</code>; <br /> 
</p>
<p style="text-align: center;"><code class="reqn">f_{ic} = {\sum_{j \in c} p_{ij} \over n_c}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{ic} = {\sum_{j \in c} x_{ij} / n_c \over \sum_{k=1}^K (\sum_{j \in k} x_{ij} / n_k)}</code>
</p>

<p style="text-align: center;"><code class="reqn">d_{ic} = f_{ic} \times a_{ic}</code>
</p>

<p>Calculated on a &lsquo;stride&rsquo; the function calculates the indicator values of
species for each of the separate partitions in the stride.
</p>


<h3>Value</h3>

<p>The default function returns a list of class &lsquo;indval&rsquo; with components:
</p>
<table>
<tr><td><code>relfrq</code></td>
<td>
<p>relative frequency of species in classes</p>
</td></tr>
<tr><td><code>relabu</code></td>
<td>
<p>relative abundance of species in classes</p>
</td></tr>
<tr><td><code>indval</code></td>
<td>
<p>the indicator value for each species</p>
</td></tr>
<tr><td><code>maxcls</code></td>
<td>
<p>the class each species has maximum indicator value for</p>
</td></tr>
<tr><td><code>indcls</code></td>
<td>
<p>the indicator value for each species to its maximum class</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>the probability of obtaining as high an indicator values as
observed over the specified iterations</p>
</td></tr>  
</table>
<p>The stride-based function returns a data.frame with the number of clusters
in the first column and the mean indicator value in the second.
</p>
<p>The &lsquo;summary&rsquo; function has two options.  In &lsquo;short&rsquo; mode it presents
a table of indicator species whose probability is less then &lsquo;p&rsquo;, giving their 
indicator value and the identity of the cluster they indicate, along with the
sum of probabilities for the entire data set.  In &lsquo;long&rsquo; mode, the indicator 
value of each species in each class is shown, with values less than &lsquo;show&rsquo; 
replaced by a place-holder dot to emphasize larger values.
</p>
<p>If &lsquo;sort==TRUE&rsquo;, a prompt is given to re-order the rows of the matrix 
interactively.
</p>


<h3>Note</h3>

<p>Indicator value analysis was proposed by Dufrene and Legendre (1997) as a
possible stopping rule for clustering, but has been used by
ecologists for a variety of analyses.  Dufrene and Legendre's nomenclature in
the paper is somewhat ambiguous, but the equations above are taken from the
worked example in the paper, not the equations on page 350 which
appear to be in error.  Dufrene and Legendre, however, multiply <code class="reqn">d</code>
by 100; this function does not.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Dufrene, M. and Legendre, P.  1997.  Species assemblages and indicator species:
the need for a flexible asymmetrical approach.  Ecol. Monogr. 67(3):345-366.</p>


<h3>See Also</h3>

<p><code><a href="#topic+isamic">isamic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
data(brycesite)
clust &lt;- cut(brycesite$elev,5,labels=FALSE)
summary(indval(bryceveg,clust))
</code></pre>

<hr>
<h2 id='isamic'>Indicator Species Analysis Minimizing Intermediate Occurrences</h2><span id='topic+isamic'></span><span id='topic+duarm'></span>

<h3>Description</h3>

<p>Calculates the degree to which species are either
always present or always absent within clusters or types.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isamic(comm,clustering,sort=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isamic_+3A_comm">comm</code></td>
<td>
<p>a matrix or data.frame of samples, species as columns, samples as
rows</p>
</td></tr>
<tr><td><code id="isamic_+3A_clustering">clustering</code></td>
<td>
<p>a vector of numeric cluster memberships for samples, or a
classification object returned from <code><a href="cluster.html#topic+pam">pam</a></code>, 
<code><a href="optpart.html#topic+partana">partana</a></code>, or <code><a href="optpart.html#topic+slice">slice</a></code></p>
</td></tr>
<tr><td><code id="isamic_+3A_sort">sort</code></td>
<td>
<p>if TRUE, return in order of highest value to lowest rather than
input order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the constancy (fractional occurrence of each species in
every type), and then calculates twice the the sum of the absolute values of the
constancy - 0.5, normalized to the number of clusters (columns).</p>


<h3>Value</h3>

<p>A data.frame of species indicator values</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Aho, K., D.W. Roberts, and T.W. Weaver.  2008. Using geometric and
non-geometric internal evaluators to compare eight vegetation
classification methods.  J. Veg. Sci. 19(4):549-562.</p>


<h3>See Also</h3>

<p><code><a href="#topic+indval">indval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
clust &lt;- cut(brycesite$elev,5,labels=FALSE)
isamic(bryceveg,clust)
</code></pre>

<hr>
<h2 id='labdsv.internal'>LabDSV Internal Functions</h2><span id='topic+plotid'></span><span id='topic+specid'></span><span id='topic+surf'></span><span id='topic+hilight'></span><span id='topic+chullord'></span><span id='topic+shannon'></span><span id='topic+pip'></span><span id='topic+density'></span>

<h3>Description</h3>

<p>These functions establish several generic functions,
and are not intended to be called directly</p>

<hr>
<h2 id='matrify'>Create Taxon Data.frames From Three Column Database Form</h2><span id='topic+matrify'></span>

<h3>Description</h3>

<p>Takes a data.frame in three column form (sample.id, taxon,
abundance) and converts it into full matrix form, and then exports it as a
data.frame with the appropriate row.names and column names.</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrify(data, strata=FALSE, base=100)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrify_+3A_data">data</code></td>
<td>
<p>a data.frame or matrix in three column format (or database
format), where the first column is the sample ID, the second column is the taxon
ID, and the third sample is the abundance of that taxon in that sample.</p>
</td></tr>
<tr><td><code id="matrify_+3A_strata">strata</code></td>
<td>
<p>are the species abundances recorded in multiple strata?</p>
</td></tr>
<tr><td><code id="matrify_+3A_base">base</code></td>
<td>
<p>what is the numeric base relative to 1.0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine is pure R code to convert data from database form to the sparse
matrix form required by multivariate analyses in packages &lsquo;labdsv&rsquo; and
&lsquo;vegan&rsquo;, as well as <code>dist</code> and other routines.  If TRUE, the strata argument
specifies calculating individual species abundances as independent overlap of strata.  
The base function is useful for converting percent to a fraction.
</p>


<h3>Value</h3>

<p>A data.frame with samples as rows, taxa as columns, and abundance values
for taxa in samples.
</p>


<h3>Note</h3>

<p>Typically, the source of the data will be an ASCII file or a dBase
database or a CSV file from an Excel file in three column format.  That file can
be read into a data.frame with <code>read.table</code> or <code>read.csv</code> and then
that data.frame can be matrified by this function.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dematrify">dematrify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(c('a','a','b','b','b','c','c'),
           c('x','y','x','z','w','y','z'),
           c(1,2,1,3,2,2,1))
matrify(x) 
</code></pre>

<hr>
<h2 id='metrify'>Nearest Metric Space Representation of a Dissimilarity Object</h2><span id='topic+metrify'></span><span id='topic+as.metric'></span><span id='topic+is.metric'></span>

<h3>Description</h3>

<p>Calculates the nearest metric space representation of a dissimilarity object by iterating the transitive closure of the triangle inequality rule</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrify(dis,upper=FALSE,diag=FALSE)
as.metric(dis,upper=FALSE,diag=FALSE)
is.metric(dis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrify_+3A_dis">dis</code></td>
<td>
<p>a distance or dissimilarity object returned from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or <code><a href="#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="metrify_+3A_upper">upper</code></td>
<td>
<p>a logical switch to control whether to return the lower triangle
(upper=FALSE) or upper triangle (upper=TRUE) of the distance matrix</p>
</td></tr>
<tr><td><code id="metrify_+3A_diag">diag</code></td>
<td>
<p>a logical switch to control whether to return the diagonal of
the distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements a constrained iteration of the transitive closure of
the triangle inequality, such that the distance between any two objects is
less than or equal to the sum of the distances from the two objects to a
third.
</p>


<h3>Value</h3>

<p>For metrify and as.metric, an object of class &lsquo;dist&rsquo;.  For 
is.metric returns TRUE or FALSE.</p>


<h3>Note</h3>

<p>Many multivariate statistical methods are designed for metric spaces,
and yet the direct calculation of distance is often inappropriate due
to problems with joint absences.  metrify takes any dissimilarity matrix and
converts it to the closest metric space representation, generally to avoid negative
eigenvalues in an eigenanalysis of the matrix.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euclidify">euclidify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis') # calculate a Bray/Curtis
            #  dissimilarity matrix
dis.met &lt;- metrify(dis.bc) # calculate the nearest euclidean
            #  representation
</code></pre>

<hr>
<h2 id='neighbors'>Neighbors</h2><span id='topic+neighbors'></span>

<h3>Description</h3>

<p>Calculates the nearest neighbors in a distance/dissimilarity
matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbors(dis,numnbr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbors_+3A_dis">dis</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; such as returned by
<code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code> or <code><a href="#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="neighbors_+3A_numnbr">numnbr</code></td>
<td>
<p>the number (order) of neighbors to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each sample unit in a dissimilarity matrix finds the 
&lsquo;numnbr&rsquo; nearest neighbors and returns them in order.
</p>


<h3>Value</h3>

<p>Returns a data.frame with sample units as rows and neighbors as columns,
listed in order of proximity to the sample unit.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called veg
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
neighbors(dis.bc,5)
</code></pre>

<hr>
<h2 id='nmds'>Nonmetric Multidimensional Scaling</h2><span id='topic+nmds'></span><span id='topic+bestnmds'></span>

<h3>Description</h3>

<p>This function is simply a wrapper for the isoMDS function in the
MASS package by Venables and Ripley.  The purpose is to convert the output
to class &lsquo;dsvord&rsquo; to simplify plotting and additional graphical analysis as
well as to provide a summary method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmds(dis,k=2,y=cmdscale(d=dis,k=k),maxit=50,trace=FALSE)
bestnmds(dis,k=2,itr=20,maxit=100,trace=FALSE,pbar=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmds_+3A_dis">dis</code></td>
<td>
<p>a dist object returned from <code>dist</code> or a full symmetric
dissimilarity or distance matrix</p>
</td></tr>
<tr><td><code id="nmds_+3A_k">k</code></td>
<td>
<p>the desired number of dimensions for the result</p>
</td></tr>
<tr><td><code id="nmds_+3A_y">y</code></td>
<td>
<p>a matrix of initial locations (objects as rows, coordinates as columns,
as many columns as specified by k).  If none is supplied, <code>cmdscale</code>
is used to generate them</p>
</td></tr>
<tr><td><code id="nmds_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the isoMDS routine</p>
</td></tr>
<tr><td><code id="nmds_+3A_trace">trace</code></td>
<td>
<p>a switch to control printing intermediate results</p>
</td></tr>
<tr><td><code id="nmds_+3A_itr">itr</code></td>
<td>
<p>number of random starts to find best result</p>
</td></tr>
<tr><td><code id="nmds_+3A_pbar">pbar</code></td>
<td>
<p>switch to control printing progress bar in interactive 
sesssions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nmds function simply calls the <code>isoMDS</code> function of the 
MASS library, but converts the result from a list to an object of
class &lsquo;dsvord&rsquo;.  The only purpose for the function is to allow &lsquo;plot&rsquo;,
&lsquo;identify&rsquo;,
&lsquo;surf&rsquo;, and other additional methods to be defined for the 
class, to simplify the analysis of the result.
</p>
<p>The &lsquo;bestnmds&rsquo; function runs one run from a PCO solution and
&lsquo;itr-1&rsquo; number of
random initial locations and returns the best result of the set.</p>


<h3>Value</h3>

<p>An object of class &lsquo;dsvord&rsquo;, with components:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>the coordinates of samples along axes</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>the &quot;goodness-of-fit&quot; computed as stress in percent</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&lsquo;NMDS&rsquo;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nmds is included as part of the LabDSV package to provide a consistent interface and 
utility for vegetation ordination methods.  Other analyses included with the same
interface at present include principal components analysis (pca), principal coordinates
analysis (pco), and t-distributed neighborhood embedding (t-SNE).</p>


<h3>Author(s)</h3>

<p>Venables and Ripley for the original isoMDS function included in the MASS package.
</p>
<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a> 
</p>


<h3>References</h3>

<p>Kruskal, J.B. (1964)  Multidimensional scaling by optimizing goodness of fit
to  nonmetric hypothesis.  Psychometrics 29:1-27.
</p>
<p>Kruskal, J.B. (1964)  Nonmetric multidimensional scaling:  a numerical method.
Psychometrics 29:115-129.
</p>
<p>T.F. Cox and M.A.A. Cox. (1994) <em>Multidimensional Scaling.</em> Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code>isoMDS</code> for the original function
</p>
<p><code><a href="#topic+plot.dsvord">plot.dsvord</a></code> for the &lsquo;plot&rsquo; method, the &lsquo;plotid&rsquo;
method to identify points with a mouse, the &lsquo;points&rsquo; method to 
identify points meeting a logical condition, the &lsquo;hilight&rsquo; method
to color-code points according to a factor, 
the &lsquo;chullord&rsquo; method to add convex hulls for a factor, or the 
the &lsquo;surf&rsquo; method to add surface contours for 
continuous variables.  
</p>
<p><code><a href="vegan.html#topic+initMDS">initMDS</a></code> for an alternative way to automate random starts
</p>
<p><code><a href="vegan.html#topic+postMDS">postMDS</a></code> for a post-solution rescaling
</p>
<p><code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> for a full treatment of variations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
dis.man &lt;- dist(bryceveg,method="manhattan")
demo.nmds &lt;- nmds(dis.man,k=4)
plot(demo.nmds)
points(demo.nmds,brycesite$elev&gt;8000)
plotid(demo.nmds,ids=row.names(brycesite))
</code></pre>

<hr>
<h2 id='ordcomm'>Re-Order the Rows and Columns of a Taxon Data Frame</h2><span id='topic+ordcomm'></span>

<h3>Description</h3>

<p>Allows analysts to interactively re-order a community data frame to
achieve a &lsquo;structured&rsquo; table following phytosociological principles.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordcomm(comm,site)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordcomm_+3A_comm">comm</code></td>
<td>
<p>a community data frame</p>
</td></tr>
<tr><td><code id="ordcomm_+3A_site">site</code></td>
<td>
<p>a site or environment data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a copy of the community data frame, and then prompts for plots to
move in front of another plot.  It then prompts for species to move in front of
a specified species.  Multiple plots or species can be moved in a single move,
with plot or species IDs separated by commas with no blanks.  The program cycles
between prompting for plots to move, and then species to move, until both prompts
are responded to with blank lines.
</p>


<h3>Value</h3>

<p>produces a list with two components:
</p>
<table>
<tr><td><code>comm</code></td>
<td>
<p>the new community data frame</p>
</td></tr>
<tr><td><code>site</code></td>
<td>
<p>the new site data frame</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a a fairly simple means to sort a table.  For large tables, it is
often possible (and preferable) to sort the tables with ordination coordinates
or other indices, but this function allows analysts to order the table
arbitrarily into any form.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code>summary.indval</code>,<code>const</code>,<code>importance</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(bryceveg) # returns a data frame called bryceveg
## Not run: data(brycesite) # returns a data frame called brycesite
## Not run: demo &lt;- ordcomm(bryceveg,brycesite)
## Not run: newveg &lt;- demo$taxon
## Not run: newsite &lt;- demo$site
</code></pre>

<hr>
<h2 id='ordcomp'>Ordination to Dissimilarity Comparison</h2><span id='topic+ordcomp'></span>

<h3>Description</h3>

<p>Plots the distribution of pair-wise distances of all points in an ordination
over the distances in the dissimilarity or distance matrix the ordination was
calculated from.  Prints the correlation between the two on the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordcomp(x,dis,dim,xlab="Computed Distance",
        ylab="Ordination Distance",title="",pch=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordcomp_+3A_x">x</code></td>
<td>
<p>an ordination object of class &lsquo;dsvord&rsquo; 
from <code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+pco">pco</a></code>,
<code><a href="#topic+nmds">nmds</a></code>, <code><a href="fso.html#topic+fso">fso</a></code> or <br />
<code><a href="vegan.html#topic+ordiplot">ordiplot</a></code></p>
</td></tr>
<tr><td><code id="ordcomp_+3A_dis">dis</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+dist">dist</a></code></p>
</td></tr>
<tr><td><code id="ordcomp_+3A_dim">dim</code></td>
<td>
<p>the number of dimensions in the ordination to use (default=all)</p>
</td></tr>
<tr><td><code id="ordcomp_+3A_xlab">xlab</code></td>
<td>
<p>the X axis label for the graph</p>
</td></tr>
<tr><td><code id="ordcomp_+3A_ylab">ylab</code></td>
<td>
<p>the Y axis label for the graph</p>
</td></tr>
<tr><td><code id="ordcomp_+3A_title">title</code></td>
<td>
<p>a title for the  plot</p>
</td></tr>
<tr><td><code id="ordcomp_+3A_pch">pch</code></td>
<td>
<p>the symbol to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is created on the current graphics device.  Returns the (invisible)
correlation.
</p>


<h3>Note</h3>

<p>Ordinations are low dimensional representations of multidimensional spaces.
This function attempts to portray how well the low dimensional solution approximates the
full dimensional space.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # produces a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis') # creates a Bray/Curtis 
                                         # dissimilarity matrix
pco.bc &lt;- pco(dis.bc,2) # produces a two-dimensional Principal 
                        # Coordinates Ordination object
ordcomp(pco.bc,dis.bc)
</code></pre>

<hr>
<h2 id='orddist'>Ordination Point Pair-Wise Distance Calculation</h2><span id='topic+orddist'></span>

<h3>Description</h3>

<p>Calculates the pair-wise distances of all points in an ordination.
The function is simply a
wrapper for the &lsquo;dist&rsquo; function, but simplifies managing ordinations
that store their coordinates under different names, as well as managing
the desired dimensionality of the calculations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>orddist(x,dim)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orddist_+3A_x">x</code></td>
<td>
<p>an ordination object of class &lsquo;dsvord&rsquo; from <code><a href="#topic+pca">pca</a></code>,
<code><a href="#topic+pco">pco</a></code>, <code><a href="#topic+nmds">nmds</a></code>,
<code><a href="fso.html#topic+fso">fso</a></code></p>
</td></tr>
<tr><td><code id="orddist_+3A_dim">dim</code></td>
<td>
<p>the desired dimensionality to be included in the calculations
(must be &lt;= number of dimensions of the ordinations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;dist&rsquo; is produced
</p>


<h3>Note</h3>

<p>Ordinations are low dimensional representations of multidimensional
spaces.  This function produces data on the low-dimensional distances for
other analyses.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # produces a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis') # creates a Bray/Curtis 
                                         #dissimilarity matrix
pco.bc &lt;- pco(dis.bc,2) # produces a two-dimensional Principal 
                        # Coordinates Ordination object
orddist(pco.bc,dim=2)
</code></pre>

<hr>
<h2 id='ordneighbors'>Nearest Neighbors Plotted in Ordination Space</h2><span id='topic+ordneighbors'></span>

<h3>Description</h3>

<p>For each sample unit in an ordination, for each of n nearest neighbors, draws
an arrow from the sample unit to its n neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordneighbors(ord,dis,numnbr=1,ax=1,ay=2,digits=5,length=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordneighbors_+3A_ord">ord</code></td>
<td>
<p>an ordination object of class &lsquo;dsvord&rsquo; 
from <code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+pco">pco</a></code>,
<code><a href="#topic+nmds">nmds</a></code>, <code><a href="fso.html#topic+fso">fso</a></code></p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_dis">dis</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+dist">dist</a></code></p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_numnbr">numnbr</code></td>
<td>
<p>the number (order) of nearest neighbors to plot</p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_ax">ax</code></td>
<td>
<p>the dimension t plot on the X axis</p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_ay">ay</code></td>
<td>
<p>the dimension to plot on the y axis</p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_digits">digits</code></td>
<td>
<p>the number of digits to report</p>
</td></tr>
<tr><td><code id="ordneighbors_+3A_length">length</code></td>
<td>
<p>the length of the arrowhead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Additional information is plotted on an existing ordination and
summary information is printed.  Returns an (invisible) list of summary values.
</p>


<h3>Note</h3>

<p>Ordinations are low dimensional representations of multidimensional spaces.
This function attempts to portray how well the low dimensional solution 
approximates the neighborhood relations of the 
full dimensional space.
</p>
<p>If numnbr = 1 and there are ties the function plots arrows for all tied
values.  If n &gt; 1 the function draws arrows for all values with rank &lt;= n.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # produces a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis') # creates a Bray/Curtis 
                                         # dissimilarity matrix
pco.bc &lt;- pco(dis.bc,2) # produces a two-dimensional Principal 
                        # Coordinates Ordination object
plot(pco.bc)
ordneighbors(pco.bc,dis.bc)
</code></pre>

<hr>
<h2 id='ordpart'>Ordination Partitioning</h2><span id='topic+ordpart'></span><span id='topic+ordpart.pca'></span><span id='topic+ordpart.pco'></span><span id='topic+ordpart.nmds'></span><span id='topic+ordpart.dsvord'></span>

<h3>Description</h3>

<p>This function allows users to partition or classify the points
in an ordination by identifying clusters of points with a mouse</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordpart(ord, ax = 1, ay = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordpart_+3A_ord">ord</code></td>
<td>
<p>an ordination of class &lsquo;dsvord&rsquo; produced by
nmds, pco, pca or other labdsv ordination functions</p>
</td></tr>
<tr><td><code id="ordpart_+3A_ax">ax</code></td>
<td>
<p>the first axis number in the ordination plot</p>
</td></tr>
<tr><td><code id="ordpart_+3A_ay">ay</code></td>
<td>
<p>the second axis number in the ordination plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a plot of an ordination, you assign plots to clusters by drawing
a polygon with the first mouse button to include all points in a given
cluster.  To end that cluster, click the right mouse button to close
the polygon.  Plots included in that cluster will be color-coded to
indicate membership.  Start the
next cluster by drawing another polygon.  To end, click the right
mouse button again after closing the last polygon.  Plots within more than
one polygon are assigned membership in the last polygon which includes them;
plots which are not within any polygon are assigned membership in cluster
zero.
</p>


<h3>Value</h3>

<p>A integer vector of cluster membership values
</p>


<h3>Note</h3>

<p>Although the routine could easily be adapted for any scatter plot,
it is currently only designed for objects of class &lsquo;dsvord&rsquo;.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
nmds.1 &lt;- nmds(dis.bc,5)
plot(nmds.1)
## Not run: clustering &lt;- ordpart(nmds.1)
</code></pre>

<hr>
<h2 id='ordtest'>Ordination Distribution Test</h2><span id='topic+ordtest'></span>

<h3>Description</h3>

<p>Testing the distribution of points in an ordination</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordtest(ord, var, dim=1:ncol(ord$points), index = 'euclidean',
   nitr = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordtest_+3A_ord">ord</code></td>
<td>
<p>an object of class &lsquo;dsvord&rsquo;</p>
</td></tr>
<tr><td><code id="ordtest_+3A_var">var</code></td>
<td>
<p>a logical or factor vector used to organize the calculation
of within-set distances</p>
</td></tr>
<tr><td><code id="ordtest_+3A_dim">dim</code></td>
<td>
<p>the number of dimensions to use in the calculation</p>
</td></tr>
<tr><td><code id="ordtest_+3A_index">index</code></td>
<td>
<p>the distance metric for the calculation of within-set distances.
Currently only euclidean is accepted</p>
</td></tr>
<tr><td><code id="ordtest_+3A_nitr">nitr</code></td>
<td>
<p>the number of iterations to perform to establish p-values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the sum of within-set pair-wise distances and compares to &lsquo;nitr&rsquo;
permutations of the same distribution to calculate the probability of observing
clusters as tight as observed or tighter.  The p-value is calculated by
running nitr-1 permutations and counting the number of cases where the sum of
pair-wise distances is as small as smaller than observed.
That count is increased by one and divided by nitr to estimate p.
</p>


<h3>Value</h3>

<p>Produces a list with components:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>the observed sum of within-set distances</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the probability of obtaining a value that small</p>
</td></tr>
<tr><td><code>reps</code></td>
<td>
<p>the sum of within-set pairwise distances for all permutations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+anosim">anosim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
pco.bc &lt;- pco(dis.bc)
plot(pco.bc)
demo &lt;- ordtest(pco.bc,brycesite$quad)
demo$p
</code></pre>

<hr>
<h2 id='pca'>Principal Components Analysis</h2><span id='topic+pca'></span><span id='topic+loadings'></span><span id='topic+loadings.pca'></span><span id='topic+summary'></span><span id='topic+summary.pca'></span><span id='topic+scores'></span><span id='topic+scores.pca'></span><span id='topic+varplot'></span><span id='topic+varplot.pca'></span>

<h3>Description</h3>

<p>Principal components analysis is a eigenanalysis of a
correlation or covariance matrix used to project a high-dimensional
system to fewer dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(mat, cor = FALSE, dim = min(nrow(mat),ncol(mat)))
## S3 method for class 'pca'
summary(object, dim = length(object$sdev), ...)
## S3 method for class 'pca'
scores(x, labels = NULL, dim = length(x$sdev), ...)
## S3 method for class 'pca'
loadings(x, dim = length(x$sdev), digits = 3, cutoff = 0.1, ...)
## S3 method for class 'pca'
varplot(x, dim=length(x$sdev),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_mat">mat</code></td>
<td>
<p>a matrix or data.frame of interest, samples as rows,
attributes as columns</p>
</td></tr>
<tr><td><code id="pca_+3A_cor">cor</code></td>
<td>
<p>logical: whether to use a correlation matrix (if TRUE),
or covariance matrix (if FALSE)</p>
</td></tr>
<tr><td><code id="pca_+3A_dim">dim</code></td>
<td>
<p>the number of dimensions to return</p>
</td></tr>
<tr><td><code id="pca_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pca&rsquo;</p>
</td></tr>
<tr><td><code id="pca_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;dsvord&rsquo; and type='pca'</p>
</td></tr>
<tr><td><code id="pca_+3A_labels">labels</code></td>
<td>
<p>an (optional) vector of labels to identify points</p>
</td></tr>
<tr><td><code id="pca_+3A_digits">digits</code></td>
<td>
<p>number of digits to report</p>
</td></tr>
<tr><td><code id="pca_+3A_cutoff">cutoff</code></td>
<td>
<p>threshold to suppress printing small values</p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>arguments to pass to function summary or graphics arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCA is a common multivariate technique.  The version here is simply
a wrapper for the <code>prcomp</code> function to make its use and
plotting consistent with the other LabDSV functions.
</p>


<h3>Value</h3>

<p>an object of class &quot;pca&quot;, a list with components:
</p>
<table>
<tr><td><code>scores</code></td>
<td>
<p>a matrix of the coordinates of the samples in the reduced space</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>a matrix of the contributions of the variables to the axes of
the reduced space.</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>a vector of standard deviations for each dimension</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current version of pca is based on the <code>prcomp</code>
function, as opposed to the <code>princomp</code> function.  Nonetheless,
it maintains the more conventional labels &quot;scores&quot; and &quot;loadings&quot;,
rather than x and rotation.  prcomp is based on a
singular value decomposition algorithm, as has worked better in my
experience.  In the rare cases where it fails, you may want to try
<code>princomp</code>.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code>princomp</code>, <code>prcomp</code>,
<code><a href="#topic+pco">pco</a></code>, <code><a href="#topic+nmds">nmds</a></code>,
<code><a href="fso.html#topic+fso">fso</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
data(brycesite)
x &lt;- pca(bryceveg,dim=10)  # returns the first 10 eigenvectors 
                           # and loadings
plot(x)
surf(x,brycesite$elev)
points(x,brycesite$depth=='deep')
</code></pre>

<hr>
<h2 id='pco'>Principal Coordinates Analysis</h2><span id='topic+pco'></span>

<h3>Description</h3>

<p>Principal coordinates analysis is an eigenanalysis of
distance or metric dissimilarity matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pco(dis, k=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pco_+3A_dis">dis</code></td>
<td>
<p>the distance or dissimilarity matrix object of
class &quot;dist&quot; returned from
<code>dist</code>, <code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or
<code><a href="#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="pco_+3A_k">k</code></td>
<td>
<p>the number of dimensions to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>pco is simply a wrapper for the <code>cmdscale</code> function
of Venebles and Ripley to make plotting of the function similar to
other LabDSV functions
</p>


<h3>Value</h3>

<p>An object of class &lsquo;pco&rsquo; with components:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>the coordinates of samples on eigenvectors</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Principal Coordinates Analysis was pioneered by Gower (1966)
as an alternative to PCA better suited to ecological datasets.</p>


<h3>Author(s)</h3>

<p>of the &lsquo;cmdscale&rsquo; function: Venebles and Ripley
</p>
<p>of the wrapper function
David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Gower, J.C. (1966)  Some distance properties of latent root
and vector methods used in multivariate analysis.  Biometrika 53:325-328.</p>


<h3>See Also</h3>

<p><code>cmdscale</code>, <code><a href="#topic+pca">pca</a></code>,
<code><a href="#topic+nmds">nmds</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
                  # returns an object of class dist'
veg.pco &lt;- pco(dis.bc,k=4) # returns first 4 dimensions
plot(veg.pco)
</code></pre>

<hr>
<h2 id='plot.dsvord'>Plotting Routines For LabDSV Ordinations</h2><span id='topic+plot.dsvord'></span><span id='topic+points.dsvord'></span><span id='topic+plotid.dsvord'></span><span id='topic+hilight.dsvord'></span><span id='topic+chullord.dsvord'></span><span id='topic+ellip.dsvord'></span><span id='topic+surf.dsvord'></span><span id='topic+density.dsvord'></span><span id='topic+thull.dsvord'></span><span id='topic+ellip'></span>

<h3>Description</h3>

<p>A set of routines for plotting, highlighting points,
or adding fitted surfaces to ordinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsvord'
plot(x, ax = 1, ay = 2, col = 1, title = "", pch = 1,
                     xlab = paste(x$type, ax), ylab = paste(x$type, ay), ...)
## S3 method for class 'dsvord'
points(x, which, ax = 1, ay = 2, col = 2, pch = 1, cex = 1, 
                      breaks=FALSE, ...)
## S3 method for class 'dsvord'
plotid(ord, ids = seq(1:nrow(ord$points)), ax = 1, ay = 2,
       col = 1, ...)
## S3 method for class 'dsvord'
hilight(ord, overlay, ax = 1, ay = 2, title="", 
        cols=c(2,3,4,5,6,7), glyph=c(1,3,5), ...)
## S3 method for class 'dsvord'
chullord(ord, overlay, ax = 1, ay = 2, cols=c(2,3,4,5,6,7), 
        ltys = c(1,2,3), ...)
## S3 method for class 'dsvord'
ellip(ord, overlay, ax = 1, ay = 2, cols=c(2,3,4,5,6,7),
        ltys = c(1,2,3), ...)
## S3 method for class 'dsvord'
surf(ord, var, ax = 1, ay = 2, thinplate = TRUE, col = 2, 
        labcex = 0.8, lty = 1, family = gaussian, gamma=1, grid=50, ...)
## S3 method for class 'dsvord'
thull(ord,var,grain,ax=1,ay=2,col=2,grid=51,nlevels=5,
        levels=NULL,lty=1,
     numitr=100,...)
## S3 method for class 'dsvord'
density(ord, overlay, ax = 1, ay = 2, cols = c(2, 3, 4, 5,
    6, 7), ltys = c(1, 2, 3), numitr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dsvord_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;dsvord&rsquo;</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ax">ax</code></td>
<td>
<p>the dimension to use for the X axis</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ay">ay</code></td>
<td>
<p>the dimension to use for the Y axis</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_title">title</code></td>
<td>
<p>a title for the plot</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_xlab">xlab</code></td>
<td>
<p>label for X axis</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ylab">ylab</code></td>
<td>
<p>label for Y axis</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_which">which</code></td>
<td>
<p>a logical variable to specify points to be highlighted</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_breaks">breaks</code></td>
<td>
<p>a logical switch to control using variable glyph sizes in &lsquo;points&rsquo;</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ord">ord</code></td>
<td>
<p>an object of class &lsquo;dsvord&rsquo;</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_overlay">overlay</code></td>
<td>
<p>a factor or integer vector to hilight or distinguish</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_cols">cols</code></td>
<td>
<p>the sequence of color indices to be used</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_glyph">glyph</code></td>
<td>
<p>the sequence of glyphs (pch) to be used</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_lty">lty</code></td>
<td>
<p>the line type to be used</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ltys">ltys</code></td>
<td>
<p>the sequence of line types to be used</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_var">var</code></td>
<td>
<p>a variable to be surfaced or tension hulled</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_thinplate">thinplate</code></td>
<td>
<p>a logical variable to control the fitting routine: thinplate=TRUE
(the default) fits a thinplate spline, thinplate=FALSE fits
independent smooth splines.  If you have too few data points you may 
have to specify thinplate=FALSE</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_family">family</code></td>
<td>
<p>controls the link function passed to &lsquo;gam&rsquo;:
one of &lsquo;gaussian&rsquo;, &lsquo;binomial&rsquo;, &lsquo;poisson&rsquo; or &lsquo;nb&rsquo;</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_gamma">gamma</code></td>
<td>
<p>controls the smoothness of the fit from <code><a href="mgcv.html#topic+gam">gam</a></code></p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_grid">grid</code></td>
<td>
<p>the number of X and Y values to use in establishing a grid for
use in surf</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_grain">grain</code></td>
<td>
<p>the size of cell to use in calculating the tensioned hull</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_nlevels">nlevels</code></td>
<td>
<p>the number of contours to draw in representing the tensioned hull</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_ids">ids</code></td>
<td>
<p>identifier labels for samples.  Defaults to 1:n</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_col">col</code></td>
<td>
<p>color index for points or contours</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_labcex">labcex</code></td>
<td>
<p>size of contour interval labels</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_pch">pch</code></td>
<td>
<p>plot character: glyph to plot</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_cex">cex</code></td>
<td>
<p>character expansion factor: size of plotted characters</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_numitr">numitr</code></td>
<td>
<p>the number of iterations to use in estimating the probability of the observed density</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_levels">levels</code></td>
<td>
<p>specific levels for contours in thull</p>
</td></tr>
<tr><td><code id="plot.dsvord_+3A_...">...</code></td>
<td>
<p>arguments to pass to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function &lsquo;plot&rsquo; produces a scatter plot of sample
scores for the specified axes, erasing or over-plotting
on the current graphic device.  Axes dimensions are controlled to produce
a graph with the correct aspect ratio.
Functions &lsquo;points&rsquo;, &lsquo;plotid&rsquo;, and &lsquo;surf&rsquo;
add detail to an existing plot.  The axes specified must
match the underlying plot exactly.
</p>
<p>Function &lsquo;plotid&rsquo; identifies
and labels samples (optionally with values from a third vector)
in the ordination, and requires interaction with the mouse:
left button identifies, right button exits.
</p>
<p>Function &lsquo;points&rsquo; is passed a logical
vector to identify a set of samples by color of glyph.  It can be used
to identify a single set meeting almost any criterion that can be
stated as a logical expression.
</p>
<p>Function &lsquo;hilight&rsquo; is passed a factor vector or integer vector,
and identifies factor values by color and glyph.
</p>
<p>Function &lsquo;chullord&rsquo; is passed a factor vector or integer vector,
and plots a convex hull around all points in each factor class.
By specifying values for arguments &lsquo;cols&rsquo; and &lsquo;ltys&rsquo;
it is possible to control the sequence of colors and linetypes of the convex
hulls.
</p>
<p>Function &lsquo;ellip&rsquo; is passed a factor vector or integer vector,
and plots minimal volume ellipses containingg all points within a class.
By specifying values for arguments &lsquo;cols&rsquo; and &lsquo;ltys&rsquo;
it is possible to control the sequence of colors and linetypes of the ellipses.
</p>
<p>Function &lsquo;density&rsquo; calculates the fraction of points within the convex
hull that belong to the specified type.
</p>
<p>Function &lsquo;surf&rsquo; calculates and plots fitted surfaces for logical or
quantitative variables.  The function employs the <code><a href="mgcv.html#topic+gam">gam</a></code>
function to fit a variable to the ordination coordinates, and to predict the
values at all grid points.  The grid is established with the
&lsquo;expand.grid&rsquo; function, and the grid is then specified in a call to
&lsquo;predict.gam&rsquo;.  The predicted values are trimmed to the the convex hull
of the data, and the contours are fit by &lsquo;contour&rsquo;.  The default link
function for fitting the GAMs is &lsquo;gaussian&rsquo;, suitable for unbounded
continuous variables.  For logical variables you should specify &lsquo;family
= binomial&rsquo; to get a logistic GAM, and for integer counts you should specify
&lsquo;family = poisson&rsquo; to get a Poisson GAM or &lsquo;family='nb'&rsquo; to get a negative binomial fit.
</p>
<p>Function &lsquo;thull&rsquo; calculates a tensioned hull for a specific variable
on the ordination.  A tensioned hull is a minimum volume container.  The grain size
must be specified as a fraction of the units of the NMDS, with larger values
generating smoother representations, and smaller numbers a more resolved 
container.  &lsquo;thull&rsquo; returns an invisible object of class &lsquo;thull&rsquo;
which has an associated plot function.  Plotting the thull object produces a 
colored surface representation of the thull with optional contour lines.
</p>


<h3>Value</h3>

<p>Function &lsquo;plotid&rsquo; returns a vector of row numbers of
identified plots</p>


<h3>Note</h3>

<p>The contouring routine using
<code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> follows <code><a href="vegan.html#topic+ordisurf">ordisurf</a></code> as 
suggested by Jari Oksanen.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
dis.bc &lt;- dsvdis(bryceveg,'bray/curtis')
nmds.1 &lt;- nmds(dis.bc,5)
plot(nmds.1)
points(nmds.1,brycesite$elev&gt;8000)
surf(nmds.1,brycesite$elev)
## Not run: plotid(nmds.1,ids=row.names(bryceveg))
</code></pre>

<hr>
<h2 id='plot.thull'>Plotting a Tensioned Hull</h2><span id='topic+plot.thull'></span><span id='topic+thull'></span>

<h3>Description</h3>

<p>A tensioned hull is a minimum volume container for specified
elements of an ordination.  A &lsquo;thull&rsquo; object is returned as an invisible
object by plotting a thull of an NMDS or PCO (or MFSO).  Subsequently plotting
the returned thull results in an &lsquo;image&rsquo; of the representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'thull'
plot(x,col=rainbow(20),levels=NULL,cont=TRUE,
          xlab=x$xlab,ylab=x$ylab,main=x$main,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.thull_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;thull&rsquo; from function
<a href="#topic+thull">thull</a></p>
</td></tr>
<tr><td><code id="plot.thull_+3A_col">col</code></td>
<td>
<p>the color to use plotting the contours</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_levels">levels</code></td>
<td>
<p>the specific levels desired for the contours</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_cont">cont</code></td>
<td>
<p>a logical variable to control plotting contours on the image
representation of the tensioned hull</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_xlab">xlab</code></td>
<td>
<p>the X axis label</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_ylab">ylab</code></td>
<td>
<p>the Y axis label</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_main">main</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="plot.thull_+3A_...">...</code></td>
<td>
<p>other graphics parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tensioned hull analysis fits a minimum volume envelope to specific
points in an ordination.  A tensioned hull object is returned from function
<code><a href="#topic+thull">thull</a></code> of a ordination of class &lsquo;dsvord&rsquo;.  This function plots the
resulting tensioned hull as an image, with optional overlays of contours. 
</p>


<h3>Value</h3>

<p>Produces a plot on the current graphic device.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a data.frame called bryceveg
dis.bc &lt;- dsvdis(bryceveg,'bray') # calculates a Bray-Curtis 
                                  # dissimilarity matrix
nmds.bc &lt;- nmds(dis.bc) # calculates an NMDS ordination
plot(nmds.bc) # plots the ordination on the current device
demo.thull &lt;- thull(nmds.bc,bryceveg$arcpat,0.25) # calculates 
                        # the tensioned hull representing the 
                        # distributtion of a species
plot(demo.thull) # portrays the image version of the tensioned hull
</code></pre>

<hr>
<h2 id='predict'>Predict species abundances in an ordination</h2><span id='topic+predict'></span><span id='topic+predict.dsvord'></span>

<h3>Description</h3>

<p>This function fits a Generalized Additive Model (GAM) for 
each species in a data.frame against an ordination.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsvord'
predict(object,comm,minocc=5,dims=1:ncol(object$points),
                         family='nb',gamma=1,keep.models=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an object of class dsvord</p>
</td></tr>
<tr><td><code id="predict_+3A_comm">comm</code></td>
<td>
<p>a community matrix or data.frame with samples as rows
and species as columns</p>
</td></tr>
<tr><td><code id="predict_+3A_minocc">minocc</code></td>
<td>
<p>the minimum number of occurrences to model a species</p>
</td></tr>
<tr><td><code id="predict_+3A_dims">dims</code></td>
<td>
<p>which specific dimensions to include</p>
</td></tr>
<tr><td><code id="predict_+3A_family">family</code></td>
<td>
<p>the error distribution specifier for the GAM function;
can be 'nb' for negative binomial, 'poisson' for the 
Poisson distribution, or 'binomial' for presence/absence data</p>
</td></tr>
<tr><td><code id="predict_+3A_gamma">gamma</code></td>
<td>
<p>the gamma parameter to control fitting GAM models</p>
</td></tr>
<tr><td><code id="predict_+3A_keep.models">keep.models</code></td>
<td>
<p>a switch to control saving the individual GAM models</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>ancillary arguments to function predict</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predict function sequentially and independently fits a GAM model
of each species distribution as a function of ordination coordinates, using the 
family and gamma specifiers supplied in the function call, or their defaults.
The function fits two or three dimensional models; if the length of dims is greater than 
three the dimensions are truncated to the first three chosen.</p>


<h3>Value</h3>

<p>A list object with vector elements aic, dev.expl, adj.rsq, and matrix fitted.  
Optionally, if keep.models is TRUE, a list with all of the GAM models fitted.
list element aic gives the model AICs for each species, dev.expl gives the deviance 
explained, adj.rsq gives the adjusted r-Squared, and fitted gives the expected abundance
of each species in each sample unit.</p>


<h3>Author(s)</h3>

<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a> 
</p>


<h3>See Also</h3>

<p><a href="#topic+calibrate">calibrate</a> for the complementary function that fits GAM models
for environment variables</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
dis.man &lt;- dist(bryceveg,method="manhattan")
demo.nmds &lt;- nmds(dis.man,k=4)
## Not run: res &lt;- predict(demo.nmds,bryceveg,minocc=10)
</code></pre>

<hr>
<h2 id='raretaxa'>Identify Rare Taxa in a Data Set</h2><span id='topic+raretaxa'></span>

<h3>Description</h3>

<p>Identifies the distribution of rare taxa in a community data.frame,
using a specified rareness threshold.</p>


<h3>Usage</h3>

<pre><code class='language-R'>raretaxa(comm,min=1,log=FALSE,type='b', panel='all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raretaxa_+3A_comm">comm</code></td>
<td>
<p>a community data.frame with samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="raretaxa_+3A_min">min</code></td>
<td>
<p>the minimum number of occurrences for a species to be considered rare</p>
</td></tr>
<tr><td><code id="raretaxa_+3A_log">log</code></td>
<td>
<p>controls whether or not the Y axis on some graphs should be log
scaled</p>
</td></tr> 
<tr><td><code id="raretaxa_+3A_type">type</code></td>
<td>
<p>the plot type.  &lsquo;b&rsquo; = both points and lines</p>
</td></tr>
<tr><td><code id="raretaxa_+3A_panel">panel</code></td>
<td>
<p>a switch to control which graphic is displayed.  Can be either an integer
from 1 to 3 or the word &lsquo;all&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rare species are an issue in ecological data sets.  This function
produces three graphs identifying (1) the distribution of rare species/plot, (2)
the mean abundance (when present) of rare species, and (3) the total abundance
or rare species/plot.
</p>


<h3>Value</h3>

<p>Produces only graphs and returns no output</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
raretaxa(bryceveg,min=3,log=TRUE)
</code></pre>

<hr>
<h2 id='reconcile'>Reconcile Community and Site Data.Frames</h2><span id='topic+reconcile'></span>

<h3>Description</h3>

<p>reconcile takes two data frames (comm and site) and sorts both
into the same order, and then deletes any rows unique to either of the two
data.frames, achieving perfect correspondence of the two. </p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcile(comm,site,exlist)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconcile_+3A_comm">comm</code></td>
<td>
<p>a community abundance data.frame with samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="reconcile_+3A_site">site</code></td>
<td>
<p>a data.frame of site or environmental variables with samples as rows and variables as columns</p>
</td></tr>
<tr><td><code id="reconcile_+3A_exlist">exlist</code></td>
<td>
<p>a switch to control listing specific plots vs simply the number of plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reconcile sorts each data.frame alphabetically by row.name, and then
compares the list of row.names to identify sample plots common to both
data.frames.  Sample plots which occur in only one of the data.frames are
deleted.
</p>


<h3>Value</h3>

<p>A list object with two elements: comm and site, which are the sorted and
reconciled data.frames.
</p>


<h3>Note</h3>

<p>Package labdsv (and many other packages in ecological data analysis)
require two data.frames to structure the data.  One contains the abundance of
species within samples with samples as rows and species as columns.  This data.frame I
refer to as the sQuotecomm data.frame.  The other data.frame contains all the
environmental or site data collected at the same samples.  This data.frame I
refer to as the &lsquo;site&rsquo; data.frame.  Due to independent subsampling, sorting or
editing of the data (often outside of R) the two data.frames often lose the necessary
requirement of the identical number of rows, with the rows in exactly the same
order.  The reconcile() function is a simple remedy to correct this situation
while maintaining the maximum amount of data.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)   # returns a data.frame of taxon abundance
data(brycesite)  # returns a data.frame of site variables
test &lt;- reconcile(bryceveg,brycesite)
</code></pre>

<hr>
<h2 id='rndcomm'>Randomize a Community Data.Frame</h2><span id='topic+rndcomm'></span><span id='topic+rndtaxa'></span>

<h3>Description</h3>

<p>Permutes a vegetation (or other) data.frame to establish
a basis for null model tests in vegetation ecology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndcomm(comm,replace=FALSE,species=FALSE,plots=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rndcomm_+3A_comm">comm</code></td>
<td>
<p>the vegetation (or other taxon) data.frame, samples as rows, species as columns</p>
</td></tr>
<tr><td><code id="rndcomm_+3A_replace">replace</code></td>
<td>
<p>a switch for permuting (if FALSE) or boostrapping (if TRUE)</p>
</td></tr>
<tr><td><code id="rndcomm_+3A_species">species</code></td>
<td>
<p>a switch to control randomizing by species (if TRUE),
maintaining species occurrence distributions</p>
</td></tr>
<tr><td><code id="rndcomm_+3A_plots">plots</code></td>
<td>
<p>a switch to control randomizing by samples (if TRUE),
maintaining plot-level species richness</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Permutes or bootstraps a vegetation data frame for input to
<code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="vegan.html#topic+vegdist">vegdist</a></code>, <code><a href="#topic+dsvdis">dsvdis</a></code>,
or other routines.  Can randomize by columns (species=TRUE), samples
(plots=TRUE), or fully (neither species nor plots = TRUE).
</p>


<h3>Value</h3>

<p>a data.frame with samples as rows and species as columns of the same
dimensions as entered.</p>


<h3>Note</h3>

<p>Randomizing vegetation often leads to unrealistic data distributions,
but this function attempts to preserve either species occurrence distributions
or plot-level species richness.  It is probably worth examining the output
of this function with <code><a href="#topic+abuocc">abuocc</a></code> to see its characteristics
before engaging in extensive analysis.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg) # returns a vegetation data.frame called bryceveg
test &lt;- rndcomm(bryceveg,species=TRUE) # preserves species abundance
                                       # distribution
test2 &lt;- rndcomm(bryceveg,plots=TRUE) # preserves plot-level 
                                      # species richness</code></pre>

<hr>
<h2 id='rnddist'>Random Distance</h2><span id='topic+rnddist'></span>

<h3>Description</h3>

<p>Calculates a random distance matrix for use in null
model analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnddist(size, method='metric', sat = 1.0, upper=FALSE, 
       diag=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnddist_+3A_size">size</code></td>
<td>
<p>the number of items to calculate the distances for</p>
</td></tr>
<tr><td><code id="rnddist_+3A_method">method</code></td>
<td>
<p>the desired properties of the matrix.  Must be either
&lsquo;metric&rsquo; or &lsquo;euclidean&rsquo;</p>
</td></tr>
<tr><td><code id="rnddist_+3A_sat">sat</code></td>
<td>
<p>a saturation coefficient to set an upper limit less than 1.0
that truncates maximum values to simulate a dissimilarity rather than a distance</p>
</td></tr>
<tr><td><code id="rnddist_+3A_upper">upper</code></td>
<td>
<p>logical: whether to print the upper triangle (default=FALSE)</p>
</td></tr>
<tr><td><code id="rnddist_+3A_diag">diag</code></td>
<td>
<p>logical: whether to print the diagonal (default=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a matrix of <code class="reqn">size^2</code> uniform random numbers
and passes the matrix to <code><a href="#topic+metrify">metrify</a></code> or
<code><a href="#topic+euclidify">euclidify</a></code> to ensure the metric or
euclidean properties of the distances.  Values are normalized
to a maximum of 1.0.
</p>


<h3>Value</h3>

<p>A dissimilarity object of class &lsquo;dist&rsquo;</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrify">metrify</a></code>, <code><a href="#topic+euclidify">euclidify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnddist(100)
pco.x &lt;- pco(x)
plot(pco.x)
</code></pre>

<hr>
<h2 id='samptot'>Sample total standardization</h2><span id='topic+samptot'></span>

<h3>Description</h3>

<p>Standardizes a community data set to a sample total
standardization.</p>


<h3>Usage</h3>

<pre><code class='language-R'>samptot(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samptot_+3A_comm">comm</code></td>
<td>
<p>a community matrix (samples as rows, species as columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply calculates row sums for the 
community matrix and then divides all values in that row by 
the appropriate sum so that all samples total to 1.0.
</p>


<h3>Value</h3>

<p>A data frame of sample total standardized community data.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p>spcmax, abundtrans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(bryceveg)
    stveg &lt;- samptot(bryceveg)
    apply(stveg,1,sum)
</code></pre>

<hr>
<h2 id='spcdisc'>Species Discrimination Analysis</h2><span id='topic+spcdisc'></span>

<h3>Description</h3>

<p>Calculates the degree to which species are restricted
to certain classes of classified vegetation</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcdisc(x,sort=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcdisc_+3A_x">x</code></td>
<td>
<p>a classified vegetation table returned by
&lsquo;const&rsquo;, or &lsquo;importance&rsquo;</p>
</td></tr>
<tr><td><code id="spcdisc_+3A_sort">sort</code></td>
<td>
<p>return in sorted order if TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a Shannon-Weiner information statistic
on the relative abundance of species within classes.
</p>


<h3>Value</h3>

<p>A vector of discrimination values.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+const">const</a></code>, <code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+indval">indval</a></code>, <code><a href="#topic+isamic">isamic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
test &lt;- const(bryceveg,brycesite$quad)
spcdisc(test)
</code></pre>

<hr>
<h2 id='spcmax'>Species Maximum Standardization</h2><span id='topic+spcmax'></span>

<h3>Description</h3>

<p>Standardizes a community data.frame by
dividing the abundance of each species by the maximum 
value obtained for that species.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcmax(comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcmax_+3A_comm">comm</code></td>
<td>
<p>community data.frame (samples as rows, species as columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple standardization to make each species abundance
scaled from 0 to 1, essentially relativizing abundance by species and making
each species equal in the calculation of distance or dissimilarity or 
other analyses.
</p>


<h3>Value</h3>

<p>A data.frame of standardized community data.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p>samptot, abundtrans, hellinger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
smveg &lt;- spcmax(bryceveg)
apply(smveg,2,max)
</code></pre>

<hr>
<h2 id='stepdist'>Step-Across Distance</h2><span id='topic+stepdist'></span>

<h3>Description</h3>

<p>Solves for the shortest-path step-across distance for 
a given distance matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepdist(dis,alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepdist_+3A_dis">dis</code></td>
<td>
<p>a distance or dissimilarity object of class &lsquo;dist&rsquo;</p>
</td></tr>
<tr><td><code id="stepdist_+3A_alpha">alpha</code></td>
<td>
<p>a threshold distance to establish the step-across</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the dist object and converts all values
&gt;= alpha to 9999.9 and then solves for new distances by calculating 
the transitive closure of the triangle inequality.</p>


<h3>Value</h3>

<p>an object of class &lsquo;dist&rsquo;</p>


<h3>Note</h3>

<p>The &lsquo;dsvdis&rsquo; function includes a step-across function in
the initial calculation of a distance or dissimilarity matrix.  This function simply
allows the conversion to take place at a later time, or on distance metrics that
&lsquo;dsvdis&rsquo; doesn't support.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
dis.bc &lt;- dsvdis(bryceveg,'bray')
dis.bcx &lt;- stepdist(dis.bc,1.00)
disana(dis.bcx)
</code></pre>

<hr>
<h2 id='tsne'>t-Distributed Stochastic Neighbor Embedding</h2><span id='topic+tsne'></span><span id='topic+besttsne'></span>

<h3>Description</h3>

<p>This function is a wrapper for the Rtsne function in the
Rtsne package by Krijthe and van der Maaten.  The purpose is to convert the output
to class &lsquo;dsvord&rsquo; to simplify plotting and additional graphical analysis as
well as to provide a summary method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsne(dis,k=2,perplexity=30,theta= 0.0,eta=200)
besttsne(dis,k=2,itr=100,perplexity=30,theta=0.0,eta = 200,pbar=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsne_+3A_dis">dis</code></td>
<td>
<p>a dist object returned from <code>dist</code> or a full symmetric
dissimilarity or distance matrix</p>
</td></tr>
<tr><td><code id="tsne_+3A_k">k</code></td>
<td>
<p>the desired number of dimensions for the result</p>
</td></tr>
<tr><td><code id="tsne_+3A_perplexity">perplexity</code></td>
<td>
<p>neighborhood size parameter (should be less than
(size(dis)-1) /3</p>
</td></tr>
<tr><td><code id="tsne_+3A_theta">theta</code></td>
<td>
<p>Speed/accuracy trade-off; set to 0.0 for exact TSNE, 
(0,0,0.5] for increasing speeed (default: 0.0)</p>
</td></tr>
<tr><td><code id="tsne_+3A_eta">eta</code></td>
<td>
<p>Learning rate</p>
</td></tr>
<tr><td><code id="tsne_+3A_itr">itr</code></td>
<td>
<p>number of random starts to find best result</p>
</td></tr>
<tr><td><code id="tsne_+3A_pbar">pbar</code></td>
<td>
<p>switch to control printing progress bar in interactive sessions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tsne function simply calls the <code>Rtsne</code> function of the 
Rtsne package with a specified distance/dissimilarity matrix rather
than the community matrix.  By convention, t-SNE employs a PCA on the 
input data matrix, and calculates distances among the first 50 eigenvectors
of the PCA.  Rtsne, however, allows the submission of a pre-calculated 
distance/dissimilarity matrix in place of the PCA.  Given the long history of 
research into the use of PCA in ecological community analysis, tsne allows 
the simple use of any of a vast number of distance/dissimilarity matrices
known to work better with ecological data.
</p>
<p>In addition, the tsne function converts the output to an object of class 
&lsquo;dsvord&rsquo; to simplify plotting and analyses using the many functions 
defined for objects of class &lsquo;dsvord&rsquo;.  (see 
<code><a href="#topic+plot.dsvord">plot.dsvord</a></code> for more details.)
</p>
<p>The &lsquo;besttsne&rsquo; function runs one run from a PCO solution as the initial
configuration and 
&lsquo;itr-1&rsquo; number of
random initial locations and returns the best result of the set.</p>


<h3>Value</h3>

<p>an object of class &lsquo;dsvord&rsquo;, with components:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>the coordinates of samples along axes</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&lsquo;t-SNE&rsquo;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>tsne is included as part of the LabDSV package to provide a consistent interface and 
utility for ecological community ordination methods.  Other analyses included with the same
interface at present include nonmetric multidimensional scaling (NMDS),
principal components analysis (pca), and principal coordinates
analysis (pco).</p>


<h3>Author(s)</h3>

<p>Jesse H. Krijthe for the original Rtsne R code, adapted from C++ code from 
Laurens van der Maaten. 
</p>
<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a> 
</p>


<h3>References</h3>

     
<p>van der Maaten, L. 2014. Accelerating t-SNE using Tree-Based
Algorithms. Journal of Machine Learning Research, 15, p.3221-3245.
</p>
<p>van der Maaten, L.J.P. &amp; Hinton, G.E., 2008. Visualizing
High-Dimensional Data Using t-SNE. Journal of Machine Learning
Research, 9, pp.2579-2605.
</p>
<p>Krijthe, J,H,  2015. Rtsne: T-Distributed Stochastic Neighbor
Embedding using a Barnes-Hut Implementation, URL:
https://github.com/jkrijthe/Rtsne
</p>


<h3>See Also</h3>

<p><code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> for the original function
</p>
<p><code><a href="#topic+plot.dsvord">plot.dsvord</a></code> for the &lsquo;plot&rsquo; method, the &lsquo;plotid&rsquo;
method to identify points with a mouse, the &lsquo;points&rsquo; method to 
identify points meeting a logical condition, the &lsquo;hilight&rsquo; method
to color-code points according to a factor, 
the &lsquo;chullord&rsquo; method to add convex hulls for a factor, or the 
the &lsquo;surf&rsquo; method to add surface contours for 
continuous variables.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)
data(brycesite)
dis.man &lt;- dist(bryceveg,method="manhattan")
demo.tsne &lt;- tsne(dis.man,k=2)
plot(demo.tsne)
points(demo.tsne,brycesite$elev&gt;8000)
plotid(demo.tsne,ids=row.names(brycesite))
</code></pre>

<hr>
<h2 id='vegtab'>Vegetation Table</h2><span id='topic+vegtab'></span>

<h3>Description</h3>

<p>Produces an ordered table of abundance of species in samples,
sub-sampled by (an optional) classification of the samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegtab(comm,set,minval=1,pltord,spcord,pltlbl,trans=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegtab_+3A_comm">comm</code></td>
<td>
<p>a vegetation (or other taxon) data.frame </p>
</td></tr>
<tr><td><code id="vegtab_+3A_set">set</code></td>
<td>
<p>a logical variable specifying which samples to include</p>
</td></tr>
<tr><td><code id="vegtab_+3A_minval">minval</code></td>
<td>
<p>a minimum abundance threshold to include in the table</p>
</td></tr>
<tr><td><code id="vegtab_+3A_pltord">pltord</code></td>
<td>
<p>a numeric vector specifying the order of rows in the output</p>
</td></tr>
<tr><td><code id="vegtab_+3A_spcord">spcord</code></td>
<td>
<p>a numeric vector specifying the order of columns in the output</p>
</td></tr>
<tr><td><code id="vegtab_+3A_pltlbl">pltlbl</code></td>
<td>
<p>a vector specifying an alternative row label (must be unique!)</p>
</td></tr>
<tr><td><code id="vegtab_+3A_trans">trans</code></td>
<td>
<p>a logical variable to control transposing the table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsets a vegetation data.frame according to specified plots or
minimum species abundances, optionally ordering in arbitrary order.
</p>


<h3>Value</h3>

<p>a data.frame with specified rows, columns, and row.names</p>


<h3>Note</h3>

<p>Vegetation tables are a common tool in vegetation analysis.  In recent
years analysis has tended to become more quantitative, and less oriented to
sorted tables, but even still presenting the results from these analyses
often involves a sorted vegetation table.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegemite">vegemite</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bryceveg)  # returns a vegetation data frame called bryceveg
data(brycesite) # returns an environmental data frame called 
                # brycesite
vegtab(bryceveg,minval=10,pltord=brycesite$elev)
        # produces a sorted table for species whose abundance sums
        # to 10, with rows in order of elevation.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
