<!DOCTYPE html><html><head><title>Help for package scorecard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scorecard}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#describe'><p>Variable Describe</p></a></li>
<li><a href='#gains_table'><p>Gains Table</p></a></li>
<li><a href='#germancredit'><p>German Credit Data</p></a></li>
<li><a href='#iv'><p>Information Value</p></a></li>
<li><a href='#one_hot'><p>One Hot Encoding</p></a></li>
<li><a href='#perf_cv'><p>Cross Validation</p></a></li>
<li><a href='#perf_eva'><p>Binomial Metrics</p></a></li>
<li><a href='#perf_psi'><p>PSI</p></a></li>
<li><a href='#replace_na'><p>Replace Missing Values</p></a></li>
<li><a href='#report'><p>Scorecard Modeling Report</p></a></li>
<li><a href='#scorecard'><p>Creating a Scorecard</p></a></li>
<li><a href='#scorecard_ply'><p>Score Transformation</p></a></li>
<li><a href='#scorecard_pmml'><p>Scorecard to PMML</p></a></li>
<li><a href='#scorecard2'><p>Creating a Scorecard</p></a></li>
<li><a href='#split_df'><p>Split a Data Frame</p></a></li>
<li><a href='#var_filter'><p>Variable Filter</p></a></li>
<li><a href='#var_scale'><p>Variable Scaling</p></a></li>
<li><a href='#vif'><p>Variance Inflation Factors</p></a></li>
<li><a href='#woebin'><p>WOE Binning</p></a></li>
<li><a href='#woebin_adj'><p>WOE Binning Adjustment</p></a></li>
<li><a href='#woebin_plot'><p>WOE Binning Visualization</p></a></li>
<li><a href='#woebin_ply'><p>WOE/BIN Transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Credit Risk Scorecard</td>
</tr>
<tr>
<td>Description:</td>
<td>
  The 'scorecard' package makes the development of credit risk scorecard 
  easier and efficient by providing functions for some common tasks, 
  such as data partition, variable selection, woe binning, scorecard scaling,
  performance evaluation and report generation. These functions can also used
  in the development of machine learning models.
    The references including: 
  1. Refaat, M. (2011, ISBN: 9781447511199). Credit Risk Scorecard: 
  Development and Implementation Using SAS. 
  2. Siddiqi, N. (2006, ISBN: 9780471754510). Credit risk scorecards. 
  Developing and Implementing Intelligent Credit Scoring.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.0), ggplot2, gridExtra, foreach,
doParallel, parallel, openxlsx, stringi, cli, xml2, xefun (&ge;
0.1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pkgdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ShichenXie/scorecard">https://github.com/ShichenXie/scorecard</a>,
<a href="http://shichen.name/scorecard/">http://shichen.name/scorecard/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ShichenXie/scorecard/issues">https://github.com/ShichenXie/scorecard/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-13 05:41:48 UTC; shichenxie</td>
</tr>
<tr>
<td>Author:</td>
<td>Shichen Xie [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shichen Xie &lt;xie@shichen.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-13 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='describe'>Variable Describe</h2><span id='topic+describe'></span>

<h3>Description</h3>

<p>This function provides descriptive statistic for exploratory data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_+3A_dt">dt</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

data("germancredit")
dat = rbind(
  setDT(germancredit),
  data.table(creditability=sample(c("good","bad"),100,replace=TRUE)),
  fill=TRUE)

eda = describe(dat)
eda

</code></pre>

<hr>
<h2 id='gains_table'>Gains Table</h2><span id='topic+gains_table'></span>

<h3>Description</h3>

<p><code>gains_table</code> creates a data frame including distribution of total, negative, positive, positive rate and rejected rate by score bins. The gains table is used in conjunction with financial and operational considerations to make cutoff decisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gains_table(score, label, bin_num = 10, method = "freq", width_by = NULL,
  breaks_by = NULL, positive = "bad|1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gains_table_+3A_score">score</code></td>
<td>
<p>A list of credit score for actual and expected data samples. For example, score = list(actual = scoreA, expect = scoreE).</p>
</td></tr>
<tr><td><code id="gains_table_+3A_label">label</code></td>
<td>
<p>A list of label value for actual and expected data samples. For example, label = list(actual = labelA, expect = labelE).</p>
</td></tr>
<tr><td><code id="gains_table_+3A_bin_num">bin_num</code></td>
<td>
<p>Integer, the number of score bins. Defaults to 10. If it is 'max', then individual scores are used as bins.</p>
</td></tr>
<tr><td><code id="gains_table_+3A_method">method</code></td>
<td>
<p>The score is binning by equal frequency or equal width. Accepted values are 'freq' and 'width'. Defaults to 'freq'.</p>
</td></tr>
<tr><td><code id="gains_table_+3A_width_by">width_by</code></td>
<td>
<p>Number, increment of the score breaks when method is set as 'width'. If it is provided the above parameter bin_num will not be used. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="gains_table_+3A_breaks_by">breaks_by</code></td>
<td>
<p>The name of data set to create breakpoints. Defaults to the first data set. Or numeric values to set breakpoints manually.</p>
</td></tr>
<tr><td><code id="gains_table_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, Defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="gains_table_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perf_eva">perf_eva</a></code> <code><a href="#topic+perf_psi">perf_psi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")

# breaking dt into train and test
dt_list = split_df(dtvf, "creditability")
label_list = lapply(dt_list, function(x) x$creditability)

# binning
bins = woebin(dt_list$train, "creditability")
# scorecard
card = scorecard2(bins, dt = dt_list$train, y = 'creditability')

# credit score
score_list = lapply(dt_list, function(x) scorecard_ply(x, card))


###### gains_table examples ######
# Example I, input score and label can be a vector or a list
g1 = gains_table(score = unlist(score_list), label = unlist(label_list))
g2 = gains_table(score = score_list, label = label_list)

# Example II, specify the bins number and type
g3 = gains_table(score = unlist(score_list), label = unlist(label_list), bin_num = 20)
g4 = gains_table(score = unlist(score_list), label = unlist(label_list), method = 'width')


</code></pre>

<hr>
<h2 id='germancredit'>German Credit Data</h2><span id='topic+germancredit'></span>

<h3>Description</h3>

<p>Credit data that classifies debtors described by
a set of attributes as good or bad credit risks.
See source link below for detailed information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(germancredit)
</code></pre>


<h3>Format</h3>

<p>A data frame with 21 variables
(numeric and factors) and 1000 observations.
</p>


<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/Statlog+(German+Credit+Data)">http://archive.ics.uci.edu/ml/datasets/Statlog+(German+Credit+Data)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load German credit data
data(germancredit)

# structure of germancredit
str(germancredit)

# summary of germancredit
# lapply(germancredit, summary)

</code></pre>

<hr>
<h2 id='iv'>Information Value</h2><span id='topic+iv'></span>

<h3>Description</h3>

<p>This function calculates information value (IV) for multiple x variables. It treats each unique value in x variables as a group. If there is a zero number of y class, it will be replaced by 0.99 to make sure woe/iv is calculable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv(dt, y, x = NULL, positive = "bad|1", order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iv_+3A_dt">dt</code></td>
<td>
<p>A data frame with both x (predictor/feature) and y (response/label) variables.</p>
</td></tr>
<tr><td><code id="iv_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="iv_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y are counted as x variables.</p>
</td></tr>
<tr><td><code id="iv_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, Defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="iv_+3A_order">order</code></td>
<td>
<p>Logical, Defaults to TRUE. If it is TRUE, the output will descending order via iv.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IV is a very useful concept for variable selection while developing credit scorecards. The formula for information value is shown below: </p>
<p style="text-align: center;"><code class="reqn">IV = \sum(DistributionPositive_{i} - DistributionNegative_{i})*\ln(\frac{DistributionPositive_{i}}{DistributionNegative_{i}}).</code>
</p>
<p> The log component in information value is defined as weight of evidence (WOE), which is shown as </p>
<p style="text-align: center;"><code class="reqn">WeightofEvidence = \ln(\frac{DistributionPositive_{i}}{DistributionNegative_{i}}).</code>
</p>

<p>The relationship between information value and predictive power is as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
Information Value </td><td style="text-align: right;"> Predictive Power </td>
</tr>
<tr>
 <td style="text-align: right;">
----------------- </td><td style="text-align: right;"> ---------------- </td>
</tr>
<tr>
 <td style="text-align: right;">
&lt; 0.02 </td><td style="text-align: right;"> useless for prediction </td>
</tr>
<tr>
 <td style="text-align: right;">
0.02 to 0.1 </td><td style="text-align: right;"> Weak predictor </td>
</tr>
<tr>
 <td style="text-align: right;">
0.1 to 0.3 </td><td style="text-align: right;"> Medium predictor </td>
</tr>
<tr>
 <td style="text-align: right;">
&gt; 0.3 </td><td style="text-align: right;"> Strong predictor
</td>
</tr>

</table>



<h3>Value</h3>

<p>A data frame with columns for variable and info_value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load German credit data
data(germancredit)

# information values
info_value = iv(germancredit, y = "creditability")

str(info_value)

</code></pre>

<hr>
<h2 id='one_hot'>One Hot Encoding</h2><span id='topic+one_hot'></span>

<h3>Description</h3>

<p>One-hot encoding on categorical variables and replace missing values.  It is not needed when creating a standard scorecard model, but required in models that without doing woe transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot(dt, var_skip = NULL, var_encode = NULL, nacol_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_hot_+3A_dt">dt</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="one_hot_+3A_var_skip">var_skip</code></td>
<td>
<p>Name of categorical variables that will skip for one-hot encoding. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="one_hot_+3A_var_encode">var_encode</code></td>
<td>
<p>Name of categorical variables to be one-hot encoded, Defaults to NULL. If it is NULL, then all categorical variables except in var_skip are counted.</p>
</td></tr>
<tr><td><code id="one_hot_+3A_nacol_rm">nacol_rm</code></td>
<td>
<p>Logical. One-hot encoding on categorical variable contains missing values, whether to remove the column generated to indicate the presence of NAs. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="one_hot_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load germancredit data
data(germancredit)

library(data.table)
dat = rbind(
  setDT(germancredit)[, c(sample(20,3),21)],
  data.table(creditability=sample(c("good","bad"),10,replace=TRUE)),
  fill=TRUE)

# one hot encoding
## keep na columns from categorical variable
dat_onehot1 = one_hot(dat, var_skip = 'creditability', nacol_rm = FALSE) # default
str(dat_onehot1)
## remove na columns from categorical variable
dat_onehot2 = one_hot(dat, var_skip = 'creditability', nacol_rm = TRUE)
str(dat_onehot2)


</code></pre>

<hr>
<h2 id='perf_cv'>Cross Validation</h2><span id='topic+perf_cv'></span>

<h3>Description</h3>

<p><code>perf_cv</code> provides cross validation on logistic regression and other binomial classification models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perf_cv(dt, y, x = NULL, no_folds = 5, seeds = NULL,
  binomial_metric = "ks", positive = "bad|1", breaks_list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perf_cv_+3A_dt">dt</code></td>
<td>
<p>A data frame with both x (predictor/feature) and y (response/label) variables.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y are counted as x variables.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_no_folds">no_folds</code></td>
<td>
<p>Number of folds for K-fold cross-validation. Defaults to 5.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_seeds">seeds</code></td>
<td>
<p>The seeds to create multiple random splits of the input dataset into training and validation data by using <code>split_df</code> function. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_binomial_metric">binomial_metric</code></td>
<td>
<p>Defaults to ks.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_breaks_list">breaks_list</code></td>
<td>
<p>List of break points, defaults to NULL. If it is NULL, then using original values of the input data to fitting model, otherwise converting into woe values based on training data.</p>
</td></tr>
<tr><td><code id="perf_cv_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames of binomial metrics for each datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("germancredit")

dt = var_filter(germancredit, y = 'creditability')
bins = woebin(dt, y = 'creditability')
dt_woe = woebin_ply(dt, bins)

perf1 = perf_cv(dt_woe, y = 'creditability', no_folds = 5)

perf2 = perf_cv(dt_woe, y = 'creditability', no_folds = 5,
   seeds = sample(1000, 10))

perf3 = perf_cv(dt_woe, y = 'creditability', no_folds = 5,
   binomial_metric = c('ks', 'auc'))


## End(Not run)

</code></pre>

<hr>
<h2 id='perf_eva'>Binomial Metrics</h2><span id='topic+perf_eva'></span>

<h3>Description</h3>

<p><code>perf_eva</code> calculates metrics to evaluate the performance of binomial classification model. It can also creates confusion matrix and model performance graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perf_eva(pred, label, title = NULL, binomial_metric = c("mse", "rmse",
  "logloss", "r2", "ks", "auc", "gini"), confusion_matrix = FALSE,
  threshold = NULL, show_plot = c("ks", "lift"), pred_desc = TRUE,
  positive = "bad|1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perf_eva_+3A_pred">pred</code></td>
<td>
<p>A list or vector of predicted probability or score.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_label">label</code></td>
<td>
<p>A list or vector of label values.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_title">title</code></td>
<td>
<p>The title of plot. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_binomial_metric">binomial_metric</code></td>
<td>
<p>Defaults to c('mse', 'rmse', 'logloss', 'r2', 'ks', 'auc', 'gini'). If it is NULL, then no metric will calculated.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_confusion_matrix">confusion_matrix</code></td>
<td>
<p>Logical, whether to create a confusion matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_threshold">threshold</code></td>
<td>
<p>Confusion matrix threshold. Defaults to the pred on maximum F1.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_show_plot">show_plot</code></td>
<td>
<p>Defaults to c('ks', 'roc'). Accepted values including c('ks', 'lift', 'gain', 'roc', 'lz', 'pr', 'f1', 'density').</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_pred_desc">pred_desc</code></td>
<td>
<p>whether to sort the argument of pred in descending order. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_positive">positive</code></td>
<td>
<p>Value of positive class. Defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="perf_eva_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accuracy = true positive and true negative/total cases
</p>
<p>Error rate = false positive and false negative/total cases
</p>
<p>TPR, True Positive Rate(Recall or Sensitivity) = true positive/total actual positive
</p>
<p>PPV, Positive Predicted Value(Precision) = true positive/total predicted positive
</p>
<p>TNR, True Negative Rate(Specificity) = true negative/total actual negative = 1-FPR
</p>
<p>NPV, Negative Predicted Value = true negative/total predicted negative
</p>


<h3>Value</h3>

<p>A list of binomial metric, confusion matrix and graphics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perf_psi">perf_psi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")

# breaking dt into train and test
dt_list = split_df(dtvf, "creditability")
label_list = lapply(dt_list, function(x) x$creditability)

# woe binning
bins = woebin(dt_list$train, "creditability")
# scorecard, prob
cardprob = scorecard2(bins, dt = dt_list, y = 'creditability', return_prob = TRUE)

# credit score
score_list = lapply(dt_list, function(x) scorecard_ply(x, cardprob$card))

###### perf_eva examples ######
# Example I, one datset
## predicted p1
perf_eva(pred = cardprob$prob$train, label=label_list$train,
         title = 'train')
## predicted score
# perf_eva(pred = score_list$train, label=label_list$train,
#   title = 'train')

# Example II, multiple datsets
## predicted p1
perf_eva(pred = cardprob$prob, label = label_list,
         show_plot = c('ks', 'lift', 'gain', 'roc', 'lz', 'pr', 'f1', 'density'))
## predicted score
# perf_eva(score_list, label_list)



</code></pre>

<hr>
<h2 id='perf_psi'>PSI</h2><span id='topic+perf_psi'></span>

<h3>Description</h3>

<p><code>perf_psi</code> calculates population stability index (PSI) for total credit score and Characteristic Stability Index (CSI) for variables. It can also creates graphics to display score distribution and positive rate trends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perf_psi(score, label = NULL, title = NULL, show_plot = TRUE,
  positive = "bad|1", threshold_variable = 20, var_skip = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perf_psi_+3A_score">score</code></td>
<td>
<p>A list of credit score for actual and expected data samples. For example, score = list(expect = scoreE, actual = scoreA).</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_label">label</code></td>
<td>
<p>A list of label value for actual and expected data samples. For example, label = list(expect = labelE, actual = labelA). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_title">title</code></td>
<td>
<p>Title of plot, Defaults to NULL.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, Defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_threshold_variable">threshold_variable</code></td>
<td>
<p>Integer. Defaults to 20. If the number of unique values &gt; threshold_variable, the provided score will be counted as total credit score, otherwise, it is variable score.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_var_skip">var_skip</code></td>
<td>
<p>Name of variables that are not score, such as id column. It should be the same with the var_kp in scorecard_ply function. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="perf_psi_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population stability index (PSI) formula is displayed below: </p>
<p style="text-align: center;"><code class="reqn">PSI = \sum((Actual\% - Expected\%)*(\ln(\frac{Actual\%}{Expected\%}))).</code>
</p>
<p> The rule of thumb for the PSI is as follows: Less than 0.1 inference insignificant change, no action required; 0.1 - 0.25 inference some minor change, check other scorecard monitoring metrics; Greater than 0.25 inference major shift in population, need to delve deeper.
</p>
<p>Characteristic Stability Index (CSI) formula is displayed below: </p>
<p style="text-align: center;"><code class="reqn">CSI = \sum((Actual\% - Expected\%)*score).</code>
</p>



<h3>Value</h3>

<p>A data frame of psi and graphics of credit score distribution
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perf_eva">perf_eva</a></code> <code><a href="#topic+gains_table">gains_table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")

# breaking dt into train and test
dt_list = split_df(dtvf, "creditability")
label_list = lapply(dt_list, function(x) x$creditability)

# binning
bins = woebin(dt_list$train, "creditability")
# scorecard
card = scorecard2(bins, dt = dt_list$train, y = 'creditability')

# credit score
score_list = lapply(dt_list, function(x) scorecard_ply(x, card))
# credit score, only_total_score = FALSE
score_list2 = lapply(dt_list, function(x) scorecard_ply(x, card,
  only_total_score=FALSE))


###### perf_psi examples ######
# Example I # only total psi
psi1 = perf_psi(score = score_list, label = label_list)
psi1$psi  # psi data frame
psi1$pic  # pic of score distribution
# modify colors
# perf_psi(score = score_list, label = label_list,
#          line_color='#FC8D59', bar_color=c('#FFFFBF', '#99D594'))

# Example II # both total and variable psi
psi2 = perf_psi(score = score_list2, label = label_list)
# psi2$psi  # psi data frame
# psi2$pic  # pic of score distribution


</code></pre>

<hr>
<h2 id='replace_na'>Replace Missing Values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Replace missing values with a specified value or mean/median value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(dt, repl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_+3A_dt">dt</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_repl">repl</code></td>
<td>
<p>Replace missing values with a specified value such as -1, or the mean/median value for numeric variable and mode value for categorical variable if repl is mean or median.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load germancredit data
data(germancredit)

library(data.table)
dat = rbind(
  setDT(germancredit)[, c(sample(20,3),21)],
  data.table(creditability=sample(c("good","bad"),10,replace=TRUE)),
  fill=TRUE)

## replace with -1
dat_repna1 = replace_na(dat, repl = -1)
## replace with median for numeric, and mode for categorical
dat_repna2 = replace_na(dat, repl = 'median')
## replace with mean for numeric, and mode for categorical
dat_repna3 = replace_na(dat, repl = 'mean')

</code></pre>

<hr>
<h2 id='report'>Scorecard Modeling Report</h2><span id='topic+report'></span>

<h3>Description</h3>

<p><code>report</code> creates a scorecard modeling report and save it as a xlsx file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(dt, y, x, breaks_list, x_name = NULL, special_values = NULL,
  seed = 618, save_report = "report", positive = "bad|1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_dt">dt</code></td>
<td>
<p>A data frame or a list of data frames that have both x (predictor/feature) and y (response/label) variables. If there are multiple data frames are provided, only the first data frame would be used for training, and the others would be used for testing/validation.</p>
</td></tr>
<tr><td><code id="report_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="report_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y are counted as x variables.</p>
</td></tr>
<tr><td><code id="report_+3A_breaks_list">breaks_list</code></td>
<td>
<p>A list of break points. It can be extracted from <code>woebin</code> and <code>woebin_adj</code> via the argument save_breaks_list.</p>
</td></tr>
<tr><td><code id="report_+3A_x_name">x_name</code></td>
<td>
<p>A vector of x variables' name.</p>
</td></tr>
<tr><td><code id="report_+3A_special_values">special_values</code></td>
<td>
<p>The values specified in special_values will be in separate bins. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="report_+3A_seed">seed</code></td>
<td>
<p>A random seed to split input data frame. Defaults to 618. If it is NULL, input dt will not split into two datasets.</p>
</td></tr>
<tr><td><code id="report_+3A_save_report">save_report</code></td>
<td>
<p>The name of xlsx file where the report is to be saved. Defaults to 'report'.</p>
</td></tr>
<tr><td><code id="report_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, default &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="report_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("germancredit")

y = 'creditability'
x = c(
  "status.of.existing.checking.account",
  "duration.in.month",
  "credit.history",
  "purpose",
  "credit.amount",
  "savings.account.and.bonds",
  "present.employment.since",
  "installment.rate.in.percentage.of.disposable.income",
  "personal.status.and.sex",
  "property",
  "age.in.years",
  "other.installment.plans",
  "housing"
)

special_values=NULL
breaks_list=list(
 status.of.existing.checking.account=c("... &lt; 0 DM%,%0 &lt;= ... &lt; 200 DM",
   "... &gt;= 200 DM / salary assignments for at least 1 year", "no checking account"),
 duration.in.month=c(8, 16, 34, 44),
 credit.history=c(
   "no credits taken/ all credits paid back duly%,%all credits at this bank paid back duly",
   "existing credits paid back duly till now", "delay in paying off in the past",
   "critical account/ other credits existing (not at this bank)"),
 purpose=c("retraining%,%car (used)", "radio/television",
   "furniture/equipment%,%domestic appliances%,%business%,%repairs",
   "car (new)%,%others%,%education"),
 credit.amount=c(1400, 1800, 4000, 9200),
 savings.account.and.bonds=c("... &lt; 100 DM", "100 &lt;= ... &lt; 500 DM",
   "500 &lt;= ... &lt; 1000 DM%,%... &gt;= 1000 DM%,%unknown/ no savings account"),
 present.employment.since=c("unemployed%,%... &lt; 1 year", "1 &lt;= ... &lt; 4 years",
   "4 &lt;= ... &lt; 7 years", "... &gt;= 7 years"),
 installment.rate.in.percentage.of.disposable.income=c(2, 3),
 personal.status.and.sex=c("male : divorced/separated", "female : divorced/separated/married",
   "male : single", "male : married/widowed"),
 property=c("real estate", "building society savings agreement/ life insurance",
   "car or other, not in attribute Savings account/bonds", "unknown / no property"),
 age.in.years=c(26, 28, 35, 37),
 other.installment.plans=c("bank%,%stores", "none"),
 housing=c("rent", "own", "for free")
 )

# Example I
# input dt is a data frame
# split input data frame into two
report(germancredit, y, x, breaks_list, special_values, seed=618, save_report='report1',
  show_plot = c('ks', 'lift', 'gain', 'roc', 'lz', 'pr', 'f1', 'density'))

# donot split input data
report(germancredit, y, x, breaks_list, special_values, seed=NULL, save_report='report2')

# Example II
# input dt is a list
# only one dataset
report(list(dt=germancredit), y, x,
  breaks_list, special_values, seed=NULL, save_report='report3')

# multiple datasets
report(list(dt1=germancredit[sample(1000,500)],
            dt2=germancredit[sample(1000,500)]), y, x,
 breaks_list, special_values, seed=NULL, save_report='report4')

# multiple datasets
report(list(dt1=germancredit[sample(1000,500)],
            dt2=germancredit[sample(1000,500)],
            dt3=germancredit[sample(1000,500)]), y, x,
 breaks_list, special_values, seed=NULL, save_report='report5')


## End(Not run)

</code></pre>

<hr>
<h2 id='scorecard'>Creating a Scorecard</h2><span id='topic+scorecard'></span>

<h3>Description</h3>

<p><code>scorecard</code> creates a scorecard based on the results from <code>woebin</code> and <code>glm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorecard(bins, model, points0 = 600, odds0 = 1/19, pdo = 50,
  basepoints_eq0 = FALSE, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorecard_+3A_bins">bins</code></td>
<td>
<p>Binning information generated from <code>woebin</code> function.</p>
</td></tr>
<tr><td><code id="scorecard_+3A_model">model</code></td>
<td>
<p>A glm model object.</p>
</td></tr>
<tr><td><code id="scorecard_+3A_points0">points0</code></td>
<td>
<p>Target points, default 600.</p>
</td></tr>
<tr><td><code id="scorecard_+3A_odds0">odds0</code></td>
<td>
<p>Target odds, default 1/19. Odds = p/(1-p).</p>
</td></tr>
<tr><td><code id="scorecard_+3A_pdo">pdo</code></td>
<td>
<p>Points to Double the Odds, default 50.</p>
</td></tr>
<tr><td><code id="scorecard_+3A_basepoints_eq0">basepoints_eq0</code></td>
<td>
<p>Logical, Defaults to FALSE. If it is TRUE, the basepoints will equally distribute to each variable.</p>
</td></tr>
<tr><td><code id="scorecard_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal point for points calculation. Default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of scorecard data frames
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scorecard2">scorecard2</a></code> <code><a href="#topic+scorecard_ply">scorecard_ply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")
# split into train and test
dtlst = split_df(dtvf, y = 'creditability')
# binning
bins = woebin(dtlst$train, "creditability")

# to woe
dtlst_woe = lapply(dtlst, function(d) woebin_ply(d, bins))
# lr
m = glm(creditability ~ ., family = binomial(), data = dtlst_woe$train)
# scorecard
card = scorecard(bins, m)
prob = predict(m, dtlst_woe$train, type='response')
# problst = lapply(dtlst_woe, function(x) predict(m, x, type='response'))


</code></pre>

<hr>
<h2 id='scorecard_ply'>Score Transformation</h2><span id='topic+scorecard_ply'></span>

<h3>Description</h3>

<p><code>scorecard_ply</code> calculates credit score using the results from <code>scorecard</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorecard_ply(dt, card, only_total_score = TRUE, print_step = 0L,
  replace_blank_na = TRUE, var_kp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorecard_ply_+3A_dt">dt</code></td>
<td>
<p>A data frame, which is the original dataset for training model.</p>
</td></tr>
<tr><td><code id="scorecard_ply_+3A_card">card</code></td>
<td>
<p>A data frame or a list of data frames. It's the scorecard generated from the function <code>scorecard</code>.</p>
</td></tr>
<tr><td><code id="scorecard_ply_+3A_only_total_score">only_total_score</code></td>
<td>
<p>Logical, Defaults to TRUE. If it is TRUE, then the output includes only total credit score; Otherwise, if it is FALSE, the output includes both total and each variable's credit score.</p>
</td></tr>
<tr><td><code id="scorecard_ply_+3A_print_step">print_step</code></td>
<td>
<p>A non-negative integer. Defaults to 1. If print_step&gt;0, print variable names by each print_step-th iteration. If print_step=0, no message is print.</p>
</td></tr>
<tr><td><code id="scorecard_ply_+3A_replace_blank_na">replace_blank_na</code></td>
<td>
<p>Logical. Replace blank values with NA. Defaults to TRUE. This argument should be the same with <code>woebin</code>'s.</p>
</td></tr>
<tr><td><code id="scorecard_ply_+3A_var_kp">var_kp</code></td>
<td>
<p>Name of force kept variables, such as id column. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in score values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scorecard">scorecard</a></code> <code><a href="#topic+scorecard2">scorecard2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")
# split into train and test
dtlst = split_df(dtvf, y = 'creditability')
# binning
bins = woebin(dtlst$train, "creditability")
# scorecard
card = scorecard2(bins=bins, dt=dtlst$train, y='creditability')

# credit score
# Example I # only total score
score1 = scorecard_ply(germancredit, card)

# Example II # credit score for both total and each variable
score2 = scorecard_ply(germancredit, card, only_total_score = FALSE)

</code></pre>

<hr>
<h2 id='scorecard_pmml'>Scorecard to PMML</h2><span id='topic+scorecard_pmml'></span>

<h3>Description</h3>

<p><code>scorecard_pmml</code> converts scorecard into PMML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorecard_pmml(card, save_name = NULL, model_name = "scorecard",
  model_version = NULL, description = "scorecard", copyright = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorecard_pmml_+3A_card">card</code></td>
<td>
<p>A data frame or a list of data frames. It's a scorecard object generated from the function <code>scorecard</code>.</p>
</td></tr>
<tr><td><code id="scorecard_pmml_+3A_save_name">save_name</code></td>
<td>
<p>A string. The file name to save scorecard. Defaults to None.</p>
</td></tr>
<tr><td><code id="scorecard_pmml_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="scorecard_pmml_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="scorecard_pmml_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="scorecard_pmml_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("germancredit")
dtvf = var_filter(germancredit, y='creditability')
bins = woebin(dtvf, y='creditability')
card = scorecard2(bins, dtvf, y='creditability')

# export scorecard into pmml
cardpmml = scorecard_pmml(card)
# save pmml
# cardpmml = scorecard_pmml(card, save_name='scorecard', model_version='1.0')

</code></pre>

<hr>
<h2 id='scorecard2'>Creating a Scorecard</h2><span id='topic+scorecard2'></span>

<h3>Description</h3>

<p><code>scorecard2</code> creates a scorecard based on the results from <code>woebin</code>. It has the same function of <code>scorecard</code>, but without model object input and provided adjustment for oversampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorecard2(bins, dt, y, x = NULL, points0 = 600, odds0 = 1/19,
  pdo = 50, basepoints_eq0 = FALSE, digits = 0, return_prob = FALSE,
  posprob_pop = NULL, posprob_sample = NULL, positive = "bad|1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorecard2_+3A_bins">bins</code></td>
<td>
<p>Binning information generated from <code>woebin</code> function.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_dt">dt</code></td>
<td>
<p>A data frame with both x (predictor/feature) and y (response/label) variables.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_x">x</code></td>
<td>
<p>Name of x variables. If it is NULL, then all variables in bins are used. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_points0">points0</code></td>
<td>
<p>Target points, default 600.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_odds0">odds0</code></td>
<td>
<p>Target odds, default 1/19. Odds = p/(1-p).</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_pdo">pdo</code></td>
<td>
<p>Points to Double the Odds, default 50.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_basepoints_eq0">basepoints_eq0</code></td>
<td>
<p>Logical, defaults to FALSE. If it is TRUE, the basepoints will equally distribute to each variable.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal point for points calculation. Default 0.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_return_prob">return_prob</code></td>
<td>
<p>Logical, defaults to FALSE. If it is TRUE, the predict probability will also return.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_posprob_pop">posprob_pop</code></td>
<td>
<p>Positive probability of population. Accepted range: 0-1,  default to NULL. If it is not NULL, the model will adjust for oversampling.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_posprob_sample">posprob_sample</code></td>
<td>
<p>Positive probability of sample. Accepted range: 0-1,  default to the positive probability of the input dt.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, default &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="scorecard2_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of scorecard data frames
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scorecard">scorecard</a></code> <code><a href="#topic+scorecard_ply">scorecard_ply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load germancredit data
data("germancredit")
# filter variable via missing rate, iv, identical value rate
dtvf = var_filter(germancredit, "creditability")
# split into train and test
dtlst = split_df(dtvf, y = 'creditability')
# binning
bins = woebin(dtlst$train, "creditability")

# train only
## create scorecard
card1 = scorecard2(bins=bins, dt=dtlst$train, y='creditability')
## scorecard and predicted probability
cardprob1 = scorecard2(bins=bins, dt=dtlst$train, y='creditability', return_prob = TRUE)

# both train and test
## create scorecard
card2 = scorecard2(bins=bins, dt=dtlst, y='creditability')
## scorecard and predicted probability
cardprob2 = scorecard2(bins=bins, dt=dtlst, y='creditability', return_prob = TRUE)


</code></pre>

<hr>
<h2 id='split_df'>Split a Data Frame</h2><span id='topic+split_df'></span>

<h3>Description</h3>

<p>Split a data frame into multiple datasets according to the specified ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_df(dt, y = NULL, ratios = c(0.7, 0.3), name_dfs = c("train",
  "test"), oot = list(time_col = NULL, time_start = NULL, ratio = NULL),
  seed = 618, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_df_+3A_dt">dt</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="split_df_+3A_y">y</code></td>
<td>
<p>Name of y variable, Defaults to NULL. The input data will split based on the predictor y, if it is provide.</p>
</td></tr>
<tr><td><code id="split_df_+3A_ratios">ratios</code></td>
<td>
<p>A numeric vector indicating the ratio of total rows contained in each split, defaults to c(0.7, 0.3).</p>
</td></tr>
<tr><td><code id="split_df_+3A_name_dfs">name_dfs</code></td>
<td>
<p>Name of returned data frames. Its length should equals to the ratios'. Defaults to train and test.</p>
</td></tr>
<tr><td><code id="split_df_+3A_oot">oot</code></td>
<td>
<p>The out-of-time validation dataset parameters. The parameters of time_cols and either time_start or ratio need to be supplied.</p>
</td></tr>
<tr><td><code id="split_df_+3A_seed">seed</code></td>
<td>
<p>A random seed, Defaults to 618.</p>
</td></tr>
<tr><td><code id="split_df_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load German credit data
data(germancredit)

# Example I
dt_list = split_df(germancredit, y="creditability")

# dimensions of each split data sets
lapply(dt_list, dim)


# Example II
dt_list2 = split_df(germancredit, y="creditability",
  ratios = c(0.5, 0.3, 0.2),
  name_dfs = c('train', 'test', 'valid'))
lapply(dt_list2, dim)

</code></pre>

<hr>
<h2 id='var_filter'>Variable Filter</h2><span id='topic+var_filter'></span>

<h3>Description</h3>

<p>This function filter variables base on specified conditions, such as missing rate, identical value rate, information value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_filter(dt, y, x = NULL, lims = list(missing_rate = 0.95, identical_rate
  = 0.95, info_value = 0.02), var_rm = NULL, var_kp = NULL,
  var_rm_reason = FALSE, positive = "bad|1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_filter_+3A_dt">dt</code></td>
<td>
<p>A data frame with both x (predictor/feature) and y (response/label) variables.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y are counted as x variables.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_lims">lims</code></td>
<td>
<p>A list of variable filters' thresholds.
</p>

<ul>
<li> <p><code>missing_rate</code> The missing rate of kept variables should &lt;= 0.95 by defaults.
</p>
</li>
<li> <p><code>identical_rate</code> The identical value rate (excluding NAs) of kept variables should &lt;= 0.95 by defaults.
</p>
</li>
<li> <p><code>info_value</code> The information value (iv) of kept variables should &gt;= 0.02 by defaults.
</p>
</li></ul>
</td></tr>
<tr><td><code id="var_filter_+3A_var_rm">var_rm</code></td>
<td>
<p>Name of force removed variables, Defaults to NULL.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_var_kp">var_kp</code></td>
<td>
<p>Name of force kept variables, Defaults to NULL.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_var_rm_reason">var_rm_reason</code></td>
<td>
<p>Logical, Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, Defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="var_filter_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for y and selected x variables, and a data frame with columns for remove reason if var_rm_reason is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load German credit data
data(germancredit)

# variable filter
dt_sel = var_filter(germancredit, y = "creditability")
dim(dt_sel)

# return the reason of varaible removed
dt_sel2 = var_filter(germancredit, y = "creditability", var_rm_reason = TRUE)
lapply(dt_sel2, dim)

str(dt_sel2$dt)
str(dt_sel2$rm)

# keep columns manually, such as rowid
germancredit$rowid = row.names(germancredit)
dt_sel3 = var_filter(germancredit, y = "creditability", var_kp = 'rowid')

# remove columns manually
dt_sel4 = var_filter(germancredit, y = "creditability", var_rm = 'rowid')

</code></pre>

<hr>
<h2 id='var_scale'>Variable Scaling</h2><span id='topic+var_scale'></span>

<h3>Description</h3>

<p>scaling variables using standardization or normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_scale(dt, var_skip = NULL, type = "standard", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_scale_+3A_dt">dt</code></td>
<td>
<p>a data frame or vector</p>
</td></tr>
<tr><td><code id="var_scale_+3A_var_skip">var_skip</code></td>
<td>
<p>Name of variables that will skip for scaling Defaults to NULL.</p>
</td></tr>
<tr><td><code id="var_scale_+3A_type">type</code></td>
<td>
<p>type of scaling method, including standard or minmax.</p>
</td></tr>
<tr><td><code id="var_scale_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("germancredit")

# standardization
dts1 = var_scale(germancredit, type = 'standard')

# normalization/minmax
dts2 = var_scale(germancredit, type = 'minmax')
dts2 = var_scale(germancredit, type = 'minmax', new_range = c(-1, 1))

</code></pre>

<hr>
<h2 id='vif'>Variance Inflation Factors</h2><span id='topic+vif'></span>

<h3>Description</h3>

<p><code>vif</code> calculates variance-inflation and generalized variance-inflation factors for linear, generalized linear to identify collinearity among explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif(model, merge_coef = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_+3A_model">model</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="vif_+3A_merge_coef">merge_coef</code></td>
<td>
<p>Logical, whether to merge with coefficients of model summary matrix. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for variable and gvif, or additional columns for df and gvif^(1/(2*df)) if provided model uses factor variable.
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=car">https://cran.r-project.org/package=car</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(germancredit)

# Example I
fit1 = glm(creditability~ age.in.years + credit.amount +
  present.residence.since, family = binomial(), data = germancredit)
vif(fit1)
vif(fit1, merge_coef=TRUE)

# Example II
fit2 = glm(creditability~ status.of.existing.checking.account +
  credit.history + credit.amount, family = binomial(), data = germancredit)
vif(fit2)
vif(fit2, merge_coef=TRUE)


</code></pre>

<hr>
<h2 id='woebin'>WOE Binning</h2><span id='topic+woebin'></span>

<h3>Description</h3>

<p><code>woebin</code> generates optimal binning for numerical, factor and categorical variables using methods including tree-like segmentation or chi-square merge. <code>woebin</code> can also customizing breakpoints if the <code>breaks_list</code> was provided. The default <code>woe</code> is defined as ln(Pos_i/Neg_i). If you prefer ln(Neg_i/Pos_i), please set the argument <code>positive</code> as negative value, such as '0' or 'good'. If there is a zero frequency class when calculating woe, the zero will replaced by 0.99 to make the woe calculable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woebin(dt, y, x = NULL, var_skip = NULL, breaks_list = NULL,
  special_values = NULL, missing_join = "left", stop_limit = 0.1,
  count_distr_limit = 0.05, bin_num_limit = 8, positive = "bad|1",
  no_cores = 2, print_step = 0L, method = "tree",
  ignore_const_cols = TRUE, ignore_datetime_cols = TRUE,
  check_cate_num = TRUE, replace_blank_inf = TRUE, save_as = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="woebin_+3A_dt">dt</code></td>
<td>
<p>A data frame with both x (predictor/feature) and y (response/label) variables.</p>
</td></tr>
<tr><td><code id="woebin_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="woebin_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y and var_skip are counted as x variables.</p>
</td></tr>
<tr><td><code id="woebin_+3A_var_skip">var_skip</code></td>
<td>
<p>Name of variables that will skip for binning. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="woebin_+3A_breaks_list">breaks_list</code></td>
<td>
<p>List of break points, Defaults to NULL. If it is not NULL, variable binning will based on the provided breaks.</p>
</td></tr>
<tr><td><code id="woebin_+3A_special_values">special_values</code></td>
<td>
<p>the values specified in special_values will be in separate bins. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="woebin_+3A_missing_join">missing_join</code></td>
<td>
<p>missing values join with the left non-missing bin if its share is lower than the threshold. Accepted values include 'left' and 'right'. If it sets to NULL, the missing values will be placed in a separate bin.</p>
</td></tr>
<tr><td><code id="woebin_+3A_stop_limit">stop_limit</code></td>
<td>
<p>Stop binning segmentation when information value gain ratio less than the 'stop_limit' if using tree method; or stop binning merge when the chi-square of each neighbor bins are larger than the threshold under significance level of 'stop_limit' and freedom degree of 1 if using chimerge method. Accepted range: 0-0.5; Defaults to 0.1. If it is 'N', each x value is a bin.</p>
</td></tr>
<tr><td><code id="woebin_+3A_count_distr_limit">count_distr_limit</code></td>
<td>
<p>The minimum count distribution percentage. Accepted range: 0.01-0.2; Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="woebin_+3A_bin_num_limit">bin_num_limit</code></td>
<td>
<p>Integer. The maximum number of binning. Defaults to 8.</p>
</td></tr>
<tr><td><code id="woebin_+3A_positive">positive</code></td>
<td>
<p>Value of positive class, defaults to &quot;bad|1&quot;.</p>
</td></tr>
<tr><td><code id="woebin_+3A_no_cores">no_cores</code></td>
<td>
<p>Number of CPU cores for parallel computation. Defaults to 2, if it sets to NULL then 90 percent of total cpu cores will be used.</p>
</td></tr>
<tr><td><code id="woebin_+3A_print_step">print_step</code></td>
<td>
<p>A non-negative integer. Defaults to 1. If print_step&gt;0, print variable names by each print_step-th iteration. If print_step=0 or no_cores&gt;1, no message is print.</p>
</td></tr>
<tr><td><code id="woebin_+3A_method">method</code></td>
<td>
<p>Four methods are provided, &quot;tree&quot; and &quot;chimerge&quot; for optimal binning that support both numerical and categorical variables, and 'width' and 'freq' for equal binning that support numerical variables only. Defaults to &quot;tree&quot;.</p>
</td></tr>
<tr><td><code id="woebin_+3A_ignore_const_cols">ignore_const_cols</code></td>
<td>
<p>Logical. Ignore constant columns. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="woebin_+3A_ignore_datetime_cols">ignore_datetime_cols</code></td>
<td>
<p>Logical. Ignore datetime columns. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="woebin_+3A_check_cate_num">check_cate_num</code></td>
<td>
<p>Logical. Check whether the number of unique values in categorical columns larger than 50. It might make the binning process slow if there are too many unique categories. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="woebin_+3A_replace_blank_inf">replace_blank_inf</code></td>
<td>
<p>Logical. Replace blank values with NA and infinite with -1. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="woebin_+3A_save_as">save_as</code></td>
<td>
<p>A string. The file name to save breaks_list. Defaults to None.</p>
</td></tr>
<tr><td><code id="woebin_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames include binning information for each x variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+woebin_ply">woebin_ply</a></code>, <code><a href="#topic+woebin_plot">woebin_plot</a></code>, <code><a href="#topic+woebin_adj">woebin_adj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load germancredit data
data(germancredit)

# Example I
# binning of two variables in germancredit dataset
# using tree method
bins2_tree = woebin(germancredit, y="creditability",
   x=c("credit.amount","housing"), method="tree")
bins2_tree

## Not run: 
# using chimerge method
bins2_chi = woebin(germancredit, y="creditability",
   x=c("credit.amount","housing"), method="chimerge")

# binning in equal freq/width # only supports numerical variables
numeric_cols = c("duration.in.month", "credit.amount",
  "installment.rate.in.percentage.of.disposable.income", "present.residence.since",
  "age.in.years", "number.of.existing.credits.at.this.bank",
  "number.of.people.being.liable.to.provide.maintenance.for")
bins_freq  = woebin(germancredit, y="creditability", x=numeric_cols, method="freq")
bins_width = woebin(germancredit, y="creditability", x=numeric_cols, method="width")

# y can be NULL if no label column in dataset
bins_freq_noy  = woebin(germancredit, y=NULL, x=numeric_cols)

# Example II
# setting of stop_limit
# stop_limit = 0.1 (by default)
bins_x1 = woebin(germancredit, y = 'creditability', x = 'foreign.worker', stop_limit = 0.1)
# stop_limit = 'N', each x value is a bin
bins_x1_N = woebin(germancredit, y = 'creditability', x = 'foreign.worker', stop_limit = 'N')

# Example III
# binning of the germancredit dataset
bins_germ = woebin(germancredit, y = "creditability")
# converting bins_germ into a data frame
# bins_germ_df = data.table::rbindlist(bins_germ)

# Example IV
# customizing the breakpoints of binning
library(data.table)
dat = rbind(
  setDT(germancredit),
  data.table(creditability=sample(c("good","bad"),10,replace=TRUE)),
  fill=TRUE)

breaks_list = list(
  age.in.years = c(26, 35, 37, "Inf%,%missing"),
  housing = c("own", "for free%,%rent")
)

special_values = list(
  credit.amount = c(2600, 9960, "6850%,%missing"),
  purpose = c("education", "others%,%missing")
)

bins_cus_brk = woebin(dat, y="creditability",
  x=c("age.in.years","credit.amount","housing","purpose"),
  breaks_list=breaks_list, special_values=special_values)

# Example V
# save breaks_list as a R file
bins2 = woebin(germancredit, y="creditability",
   x=c("credit.amount","housing"), save_as='breaks_list')

# Example VI
# setting bin closed on the right
options(scorecard.bin_close_right = TRUE)
binsRight = woebin(germancredit, y = 'creditability', x = 'age.in.years')
binsRight
# setting bin close on the left, the default setting
options(scorecard.bin_close_right = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='woebin_adj'>WOE Binning Adjustment</h2><span id='topic+woebin_adj'></span>

<h3>Description</h3>

<p><code>woebin_adj</code> interactively adjust the binning breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woebin_adj(dt, y, bins, breaks_list = NULL, adj_all_var = TRUE,
  to = "breaks_list", save_as = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="woebin_adj_+3A_dt">dt</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_y">y</code></td>
<td>
<p>Name of y variable.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_bins">bins</code></td>
<td>
<p>A list of data frames. Binning information generated from <code>woebin</code>.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_breaks_list">breaks_list</code></td>
<td>
<p>List of break points, Defaults to NULL. If it is not NULL, variable binning will based on the provided breaks.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_adj_all_var">adj_all_var</code></td>
<td>
<p>Logical, whether to show variables have monotonic woe trends. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_to">to</code></td>
<td>
<p>Adjusting bins into breaks_list or bins_list. Defaults to breaks_list.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_save_as">save_as</code></td>
<td>
<p>A string. The file name to save breaks_list. Defaults to None.</p>
</td></tr>
<tr><td><code id="woebin_adj_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of modified break points of each x variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+woebin">woebin</a></code>, <code><a href="#topic+woebin_ply">woebin_ply</a></code>, <code><a href="#topic+woebin_plot">woebin_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load German credit data
data(germancredit)

# Example I
dt = germancredit[, c("creditability", "age.in.years", "credit.amount")]
bins = woebin(dt, y="creditability")
breaks_adj = woebin_adj(dt, y="creditability", bins)
bins_final = woebin(dt, y="creditability",
                    breaks_list=breaks_adj)

# Example II adjust two variables' breaks in brklst
binsII = woebin(germancredit, y="creditability", save_as = 'breaks')
brklst = source('breaks.R')$value
# update break list file
brklst_adj = woebin_adj(germancredit, "creditability", binsII[1:2],
                        breaks_list = brklst, save_as = 'breaks')

## End(Not run)

</code></pre>

<hr>
<h2 id='woebin_plot'>WOE Binning Visualization</h2><span id='topic+woebin_plot'></span>

<h3>Description</h3>

<p><code>woebin_plot</code> create plots of count distribution and positive probability for each bin. The binning informations are generates by  <code>woebin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woebin_plot(bins, x = NULL, title = NULL, show_iv = TRUE,
  line_value = "posprob", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="woebin_plot_+3A_bins">bins</code></td>
<td>
<p>A list of data frames. Binning information generated by <code>woebin</code>.</p>
</td></tr>
<tr><td><code id="woebin_plot_+3A_x">x</code></td>
<td>
<p>Name of x variables. Defaults to NULL. If x is NULL, then all columns except y are counted as x variables.</p>
</td></tr>
<tr><td><code id="woebin_plot_+3A_title">title</code></td>
<td>
<p>String added to the plot title. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="woebin_plot_+3A_show_iv">show_iv</code></td>
<td>
<p>Logical. Defaults to TRUE, which means show information value in the plot title.</p>
</td></tr>
<tr><td><code id="woebin_plot_+3A_line_value">line_value</code></td>
<td>
<p>The value displayed as line. Accepted values are 'posprob' and 'woe'. Defaults to positive probability.</p>
</td></tr>
<tr><td><code id="woebin_plot_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of binning graphics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+woebin">woebin</a></code>, <code><a href="#topic+woebin_ply">woebin_ply</a></code>, <code><a href="#topic+woebin_adj">woebin_adj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load German credit data
data(germancredit)

# Example I
bins1 = woebin(germancredit, y="creditability", x="credit.amount")

p1 = woebin_plot(bins1)
print(p1)

# modify line value
p1_w = woebin_plot(bins1, line_value = 'woe')
print(p1_w)

# modify colors
p1_c = woebin_plot(bins1, line_color='#FC8D59', bar_color=c('#FFFFBF', '#99D594'))
print(p1_c)

# show iv, line value, bar value
p1_iv = woebin_plot(bins1, show_iv = FALSE)
print(p1_iv)
p1_lineval = woebin_plot(bins1, show_lineval = FALSE)
print(p1_lineval)
p1_barval  = woebin_plot(bins1, show_barval = FALSE)
print(p1_barval)


# Example II
bins = woebin(germancredit, y="creditability")
plotlist = woebin_plot(bins)
print(plotlist$credit.amount)

# # save binning plot
# for (i in 1:length(plotlist)) {
#   ggplot2::ggsave(
#      paste0(names(plotlist[i]), ".png"), plotlist[[i]],
#      width = 15, height = 9, units="cm" )
#   }


</code></pre>

<hr>
<h2 id='woebin_ply'>WOE/BIN Transformation</h2><span id='topic+woebin_ply'></span>

<h3>Description</h3>

<p><code>woebin_ply</code> converts original values of input data into woe or bin based on the binning information generated from <code>woebin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woebin_ply(dt, bins, to = "woe", no_cores = 2, print_step = 0L,
  replace_blank_inf = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="woebin_ply_+3A_dt">dt</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_bins">bins</code></td>
<td>
<p>Binning information generated from <code>woebin</code>.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_to">to</code></td>
<td>
<p>Converting original values to woe or bin. Defaults to woe.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_no_cores">no_cores</code></td>
<td>
<p>Number of CPU cores for parallel computation. Defaults to 2, if it sets to NULL then 90 percent of total cpu cores will be used.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_print_step">print_step</code></td>
<td>
<p>A non-negative integer. Defaults to 1. If print_step&gt;0, print variable names by each print_step-th iteration. If print_step=0 or no_cores&gt;1, no message is print.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_replace_blank_inf">replace_blank_inf</code></td>
<td>
<p>Logical. Replace blank values with NA and infinite with -1. Defaults to TRUE. This argument should be the same with <code>woebin</code>'s.</p>
</td></tr>
<tr><td><code id="woebin_ply_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for variables converted into woe values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+woebin">woebin</a></code>, <code><a href="#topic+woebin_plot">woebin_plot</a></code>, <code><a href="#topic+woebin_adj">woebin_adj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load germancredit data
data(germancredit)

# Example I
dt = germancredit[, c("creditability", "credit.amount", "purpose")]

# binning for dt
bins = woebin(dt, y = "creditability")

# converting to woe
dt_woe = woebin_ply(dt, bins=bins)
str(dt_woe)

# converting to bin
dt_bin = woebin_ply(dt, bins=bins, to = 'bin')
str(dt_bin)


# Example II
# binning for germancredit dataset
bins_germancredit = woebin(germancredit, y="creditability")

# converting the values in germancredit to woe
# bins is a list which generated from woebin()
germancredit_woe = woebin_ply(germancredit, bins_germancredit)

# bins is a data frame
bins_df = data.table::rbindlist(bins_germancredit)
germancredit_woe = woebin_ply(germancredit, bins_df)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
