<!DOCTYPE html><html><head><title>Help for package uHMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {uHMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#uHMM-package'>
<p>Construct an unsupervised Hidden Markov Model</p></a></li>
<li><a href='#computeGap'><p>Compute gap between eigenvalues of a similarity matrix</p></a></li>
<li><a href='#cutCalculation'><p>cutCalculation function</p></a></li>
<li><a href='#emissionMatrix'><p>Emission matrix estimation</p></a></li>
<li><a href='#FastSpectralNJW'><p>Jordan Fast Spectral Algorithm</p></a></li>
<li><a href='#HMMparams'><p>Hidden Markov Model parameter estimation</p></a></li>
<li><a href='#KmeansAutoElbow'><p>KmeansAutoElbow function</p></a></li>
<li><a href='#KpartitionNJW'><p>KpartitionNJW function</p></a></li>
<li><a href='#MarelCarnot'><p>MarelCarnot dataset</p></a></li>
<li><a href='#selfKNN'><p>Self KNN</p></a></li>
<li><a href='#spectralPamClusteringNg'><p>spectralPamClusteringNg function</p></a></li>
<li><a href='#transitionMatrix'><p>Transition matrix estimation</p></a></li>
<li><a href='#uHMMinterface'><p>Graphical Interface to Build an uHMM</p></a></li>
<li><a href='#ZPGaussianSimilarity'><p>Similarity matrix with local scale parameter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construct an Unsupervised Hidden Markov Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Emilie POISSON-CAILLAULT [aut],
  Paul TERNYNCK [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul TERNYNCK &lt;ternynck@lisic.univ-littoral.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct a Hidden Markov Model with states learnt by unsupervised classification.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats, grDevices</td>
</tr>
<tr>
<td>Imports:</td>
<td>tcltk, tcltk2, tkrplot, HMM, clValid, class, cluster,
FactoMineR, corrplot, chron</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-22 13:03:49 UTC; ternynck</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-22 16:25:47</td>
</tr>
</table>
<hr>
<h2 id='uHMM-package'>
Construct an unsupervised Hidden Markov Model
</h2><span id='topic+uHMM-package'></span>

<h3>Description</h3>

<p>This package proposes an interface to detect usual or extreme events in a dataset and to characterize their dynamic, by building an unsupervised Hidden Markov Model (use <code><a href="#topic+uHMMinterface">uHMMinterface</a></code> to launch the interface).
Functions can also be used out of the interface to build an uHMM.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> uHMM </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-04-13 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;">  R (&gt;= 3.0.0), stats, grDevices </td>
</tr>
<tr>
 <td style="text-align: left;">
Import: </td><td style="text-align: left;">  tcltk, tcltk2, tkrplot, HMM, clValid, class, cluster, FactoMineR, corrplot, chron </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Emilie Poisson-Caillault and Paul Ternynck 
</p>
<p>Maintainer: &lt;emilie.caillault@lisic.univ-littoral.fr&gt;
</p>


<h3>Source</h3>

<p>Rousseeuw, Kevin, et al. &quot;Hybrid hidden Markov model for marine environment monitoring.&quot; Selected Topics in Applied Earth Observations and Remote Sensing, IEEE Journal of 8.1 (2015): 204-213.
</p>

<hr>
<h2 id='computeGap'>Compute gap between eigenvalues of a similarity matrix</h2><span id='topic+computeGap'></span>

<h3>Description</h3>

<p>Find the highest gap between eigenvalues of a similarity matrix.
The 2 first eigenvalues are considered as equal to each other (the gap between the 2 first eigenvalues is set to 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGap(similarity, Gmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGap_+3A_similarity">similarity</code></td>
<td>
<p>a similarity matrix.</p>
</td></tr>
<tr><td><code id="computeGap_+3A_gmax">Gmax</code></td>
<td>
<p>the maximum gap value allowed (only the first Gmax eigenvalues will be taken into account).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing the following components:
</p>
<table>
<tr><td><code>gap</code></td>
<td>
<p>a vector indicating the gap between similarity matrix eigenvalues (the gap between the 2 first eigenvalues is set to 0)</p>
</td></tr>
<tr><td><code>Kmax</code></td>
<td>
<p>an integer indicating the index of the highest gap (the highest gap is between the Kmax-th and the (Kmax+1)-th eigenvalues)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbind(matrix(rnorm(50, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(50, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(50, mean = 4, sd = 0.3), ncol = 2))

similarity&lt;-ZPGaussianSimilarity(x,7)
Gap&lt;-computeGap(similarity,10)
plot(1:length(Gap$gap),Gap$gap,type="h",
main=paste("Gap criteria =",Gap$K),ylab="gap value",xlab="eigenvalues")



x=(runif(1000)*4)-2;y=(runif(1000)*4)-2
keep&lt;-which((x**2+y**2&lt;0.5)|(x**2+y**2&gt;1.5**2 &amp; x**2+y**2&lt;2**2 ))
data&lt;-data.frame(x,y)[keep,]
plot(data)

similarity&lt;-ZPGaussianSimilarity(data,1)
Gap&lt;-computeGap(similarity,10)
plot(1:length(Gap$gap),Gap$gap,type="h",
main=paste("Gap criteria =",Gap$K),ylab="gap value",xlab="eigenvalues")

</code></pre>

<hr>
<h2 id='cutCalculation'>cutCalculation function</h2><span id='topic+cutCalculation'></span>

<h3>Description</h3>

<p>Compute intra and inter-cluster cuts from the similarity matrix of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutCalculation(similarity, label, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutCalculation_+3A_similarity">similarity</code></td>
<td>
<p>a similarity matrix.</p>
</td></tr>
<tr><td><code id="cutCalculation_+3A_label">label</code></td>
<td>
<p>vector of cluster sequencing.</p>
</td></tr>
<tr><td><code id="cutCalculation_+3A_k">K</code></td>
<td>
<p>number of clusters. (= nbCluster CALCULE DANS LA FONCTION ???)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>intra cluster cut :
</p>
<p style="text-align: center;"><code class="reqn">Cut(g_{k},g_{l}) = \sum_{i=1,x(i)\in g_{k}}^{N_{p}}\sum_{j=1,x(j)\in g_{l}}^{N_{p}}w(x(i),x(j)) </code>
</p>



<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>mncut</code></td>
<td>
<p>the inter-cluster cut, i.e. K-sum(ratioCutVol).</p>
</td></tr>
<tr><td><code>ratioCutVol</code></td>
<td>
<p>vector of intra-cluster cuts, one component per cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rbind(matrix(runif(100),ncol=2),matrix(runif(100)+2,ncol=2),matrix(runif(20)*3,ncol=2))
similarity&lt;-ZPGaussianSimilarity(x,7)%*%t(ZPGaussianSimilarity(x,7))
km&lt;-kmeans(similarity,2)
label&lt;-km$cluster
plot(x,col=km$cluster)
cutCalculation(similarity,label,length(unique(label)))
</code></pre>

<hr>
<h2 id='emissionMatrix'>Emission matrix estimation</h2><span id='topic+emissionMatrix'></span>

<h3>Description</h3>

<p>This function estimates the emission matrix of a Hidden Markov Model from vectors of state and symbol sequencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emissionMatrix(states, symbols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emissionMatrix_+3A_states">states</code></td>
<td>
<p>a numeric vector of state sequencing.</p>
</td></tr>
<tr><td><code id="emissionMatrix_+3A_symbols">symbols</code></td>
<td>
<p>a numeric vector of symbol sequencing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated emission matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HMMparams">HMMparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states&lt;-c(1,1,3,2,1,2,1,3)
symbols&lt;-c(4,1,3,1,4,4,4,2)
B&lt;-emissionMatrix(states,symbols)
B
</code></pre>

<hr>
<h2 id='FastSpectralNJW'>Jordan Fast Spectral Algorithm</h2><span id='topic+FastSpectralNJW'></span>

<h3>Description</h3>

<p>Perform the Jordan spectral algorithm for large databases. Data are sampled, using K-means with Elbow criteria, before being classified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastSpectralNJW(data, nK = NULL, Kech = 2000, StopCriteriaElbow = 0.97,
  neighbours = 7, method = "", nb.iter = 10, uHMMinterface = FALSE,
  console = NULL, tm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FastSpectralNJW_+3A_data">data</code></td>
<td>
<p>numeric matrix or dataframe.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_nk">nK</code></td>
<td>
<p>number of clusters desired. If NULL, optimal number of clusters will be computed using gap criteria.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_kech">Kech</code></td>
<td>
<p>maximum number of representative points in sampled data.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_stopcriteriaelbow">StopCriteriaElbow</code></td>
<td>
<p>maximum (minimum ?) de variance expliquees des points representatifs souhaite.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_neighbours">neighbours</code></td>
<td>
<p>number of neighbours considered for the computation of local scale parameters.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_method">method</code></td>
<td>
<p>string specifying the spectral classification method desired, either &quot;PAM&quot; (for spectral kmedoids) or &quot;&quot; (for &quot;spectral kmeans&quot;).</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_nb.iter">nb.iter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_uhmminterface">uHMMinterface</code></td>
<td>
<p>logical indicating whether the function is used via the uHMMinterface.</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_console">console</code></td>
<td>
<p>frame of the uHMM interface in which messages should be displayed (only if uHMMinterface=TRUE).</p>
</td></tr>
<tr><td><code id="FastSpectralNJW_+3A_tm">tm</code></td>
<td>
<p>a one row dataframe containing text to display in the uHMMinterface (only if uHMMinterface=TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithme de Jordan pour un grand jeu de donnees : echantillonage puis spectral
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>sim</code></td>
<td>
<p>similarity matrix of representative points, multiplied by its transpose (<code><a href="#topic+ZPGaussianSimilarity">ZPGaussianSimilarity</a></code>).</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>vector of cluster sequencing.</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code>labelElbow</code></td>
<td>
<p>vector of prototype sequencing.</p>
</td></tr>
<tr><td><code>vpK</code></td>
<td>
<p>matrix containing, in columns, the K first normalised eigen vectors of the data similarity matrix.</p>
</td></tr>
<tr><td><code>valp</code></td>
<td>
<p>vector containing the K first eigen values of the data similarity matrix.</p>
</td></tr>
<tr><td><code>echantillons</code></td>
<td>
<p>matrix of prototypes coordinates.</p>
</td></tr>
<tr><td><code>label.echantillons</code></td>
<td>
<p>vector containing the cluster of each prototype.</p>
</td></tr>
<tr><td><code>numSymbole</code></td>
<td>
<p>vector containing the nearest prototype of each data item.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+KmeansAutoElbow">KmeansAutoElbow</a></code> <code><a href="#topic+ZPGaussianSimilarity">ZPGaussianSimilarity</a></code>  <code><a href="class.html#topic+knn">knn</a></code> 
<code><a href="cluster.html#topic+silhouette">silhouette</a></code> <code><a href="clValid.html#topic+dunn">dunn</a></code> <code><a href="clValid.html#topic+connectivity">connectivity</a></code> <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=(runif(1000)*4)-2;y=(runif(1000)*4)-2
keep&lt;-which((x**2+y**2&lt;0.5)|(x**2+y**2&gt;1.5**2 &amp; x**2+y**2&lt;2**2 ))
data&lt;-data.frame(x,y)[keep,]

cl&lt;-FastSpectralNJW(data,2)
plot(data,col=cl$label)

</code></pre>

<hr>
<h2 id='HMMparams'>Hidden Markov Model parameter estimation</h2><span id='topic+HMMparams'></span>

<h3>Description</h3>

<p>This function is used by the <code><a href="#topic+uHMMinterface">uHMMinterface</a></code> to estimate parameters of a Hidden Markov Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMMparams(stateSeq, symbolSeq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMMparams_+3A_stateseq">stateSeq</code></td>
<td>
<p>a numeric vector of state sequencing.</p>
</td></tr>
<tr><td><code id="HMMparams_+3A_symbolseq">symbolSeq</code></td>
<td>
<p>a numeric vector of symbol sequencing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HMMparams returns a list containing :
</p>
<table>
<tr><td><code>trans</code></td>
<td>
<p>The transition matrix.</p>
</td></tr>
<tr><td><code>emis</code></td>
<td>
<p>The emission matrix.</p>
</td></tr>
<tr><td><code>startProb</code></td>
<td>
<p>The vector of initial probability distribution (initial states are supposed equiprobable).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitionMatrix">transitionMatrix</a></code> <code><a href="#topic+emissionMatrix">emissionMatrix</a></code>
</p>

<hr>
<h2 id='KmeansAutoElbow'>KmeansAutoElbow function</h2><span id='topic+KmeansAutoElbow'></span>

<h3>Description</h3>

<p>KmeansAutoElbow performs k-means clustering on a dataframe with selection of optimal number of clusters using elbow criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansAutoElbow(features, Kmax, StopCriteria = 0.99, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansAutoElbow_+3A_features">features</code></td>
<td>
<p>dataframe or matrix of raw data.</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of clusters allowed.</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_stopcriteria">StopCriteria</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search. (???)</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE figures are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KmeansAutoElbow returns partition and K number of groups according to kmeans clustering and Elbow method
</p>


<h3>Value</h3>

<p>The function returns a list containing the following components:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>number of clusters in data according to explained variance and kmeans algorithm.</p>
</td></tr>
<tr><td><code>res.kmeans</code></td>
<td>
<p>an object of class &quot;kmeans&quot; (see <code><a href="stats.html#topic+kmeans">kmeans</a></code>) containing classification results.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbind(matrix(rnorm(300, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
colnames(x) &lt;- c("x", "y")
km&lt;-KmeansAutoElbow(x,round(dim(x)/25,0)[1],StopCriteria=0.99,graph=TRUE)
plot(x,col=km$res.kmeans$cluster)
points(km$res.kmeans$centers, col = 1:km$K, pch = 16)

</code></pre>

<hr>
<h2 id='KpartitionNJW'>KpartitionNJW function</h2><span id='topic+KpartitionNJW'></span>

<h3>Description</h3>

<p>Perform spectral classification on the similarity matrix of a dataset (Ng et al. (2001) algorithm), using kmeans algorithm on data projected in the space of its K first eigen vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KpartitionNJW(similarity, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KpartitionNJW_+3A_similarity">similarity</code></td>
<td>
<p>matrix of similarity.</p>
</td></tr>
<tr><td><code id="KpartitionNJW_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of cluster sequencing.</p>
</td></tr>
<tr><td><code>centres</code></td>
<td>
<p>matrix of cluster centers in the space of the K first normalised eigen vectors.</p>
</td></tr>
<tr><td><code>vecteursPropresProjK</code></td>
<td>
<p>matrix containing, in columns, the K first normalised eigen vectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>valeursPropresK</code></td>
<td>
<p>vector containing the K first eigen values of the similarity matrix.</p>
</td></tr>
<tr><td><code>vecteursPropres</code></td>
<td>
<p>matrix containing, in columns, eigen vectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>valeursPropres</code></td>
<td>
<p>vector containing eigen values of the similarity matrix.</p>
</td></tr>
<tr><td><code>inertieZ</code></td>
<td>
<p>vector of within-cluster sum of squares, one component per cluster.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ng Andrew, Y., M. I. Jordan, and Y. Weiss. &quot;On spectral clustering: analysis and an algorithm [C].&quot; Advances in Neural Information Processing Systems (2001).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
x &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

similarity&lt;-ZPGaussianSimilarity(x,7)
similarity=similarity%*%t(similarity)
sp&lt;-KpartitionNJW(similarity,3)
plot(x,col=sp$label)

#####    
x &lt;- rbind(data.frame(x=1:100+(runif(100)-0.5)*2,y=runif(100)/5), 
           data.frame(x=1:100+(runif(100)-0.5)*2,y=runif(100)/5+1),
           data.frame(x=1:100+(runif(100)-0.5)*2,y=runif(100)/5+2))

similarity&lt;-ZPGaussianSimilarity(x,7)
similarity=similarity%*%t(similarity)
sp&lt;-KpartitionNJW(similarity,3)
plot(x,col=sp$label)

#####
x=(runif(1000)*4)-2;y=(runif(1000)*4)-2
keep&lt;-which((x**2+y**2&lt;0.5)|(x**2+y**2&gt;1.5**2 &amp; x**2+y**2&lt;2**2 ))
data&lt;-data.frame(x,y)[keep,]

similarity=ZPGaussianSimilarity(data, 7)
similarity=similarity%*%t(similarity)
sp&lt;-KpartitionNJW(similarity,2)

plot(data,col=sp$label)

</code></pre>

<hr>
<h2 id='MarelCarnot'>MarelCarnot dataset</h2><span id='topic+MarelCarnot'></span>

<h3>Description</h3>

<p>The MarelCarnot data set gives the measurements of 14 physico-chemical and biological parameters performed by 
the Marel-Carnot station (Boulogne-sur-Mer, France), at high frequency resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarelCarnot
</code></pre>


<h3>Format</h3>

<p>A data frame with 131487 rows and 16 columns.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Dates </td><td style="text-align: left;"> date of measurement </td><td style="text-align: left;"> (YYYY:MM:DD) </td>
</tr>
<tr>
 <td style="text-align: left;">
Hours </td><td style="text-align: left;"> time of measurement </td><td style="text-align: left;"> (HH:MM:SS) </td>
</tr>
<tr>
 <td style="text-align: left;">
C_NI1 </td><td style="text-align: left;"> nitrate concentration </td><td style="text-align: left;"> (in <code class="reqn">\mu</code>mol/L) </td>
</tr>
<tr>
 <td style="text-align: left;">
C_PO1 </td><td style="text-align: left;"> phosphate concentration </td><td style="text-align: left;"> (in <code class="reqn">\mu</code>mol/L) </td>
</tr>
<tr>
 <td style="text-align: left;">
C_O21 </td><td style="text-align: left;"> corrected dissolved oxygen </td><td style="text-align: left;"> (in mg/L) </td>
</tr>
<tr>
 <td style="text-align: left;">
C_SI1 </td><td style="text-align: left;"> silicate concentration </td><td style="text-align: left;"> (in <code class="reqn">\mu</code>mol/L) </td>
</tr>
<tr>
 <td style="text-align: left;">
CSAL1 </td><td style="text-align: left;"> salinity </td><td style="text-align: left;"> (in PSU) </td>
</tr>
<tr>
 <td style="text-align: left;">
CSAT1 </td><td style="text-align: left;"> oxygen saturation </td><td style="text-align: left;"> (in %)  </td>
</tr>
<tr>
 <td style="text-align: left;">
ETCO1 </td><td style="text-align: left;"> air temperature </td><td style="text-align: left;"> (in degrees Celsius) </td>
</tr>
<tr>
 <td style="text-align: left;">
E_LU1 </td><td style="text-align: left;"> P.A.R </td><td style="text-align: left;"> (in <code class="reqn">\mu</code>mol of photons/s/m2) </td>
</tr>
<tr>
 <td style="text-align: left;">
E_O21 </td><td style="text-align: left;"> uncorrected dissolved oxygen </td><td style="text-align: left;"> (in mg/L) </td>
</tr>
<tr>
 <td style="text-align: left;">
E_PH1 </td><td style="text-align: left;"> pH </td>
</tr>
<tr>
 <td style="text-align: left;">
E_TU1 </td><td style="text-align: left;"> turbidity </td><td style="text-align: left;"> (in NTU) </td>
</tr>
<tr>
 <td style="text-align: left;">
ECHL1 </td><td style="text-align: left;"> fluorescence </td><td style="text-align: left;"> (in FFU) </td>
</tr>
<tr>
 <td style="text-align: left;">
E__TA </td><td style="text-align: left;"> water temperature </td><td style="text-align: left;"> (in degrees Celsius) </td>
</tr>
<tr>
 <td style="text-align: left;">
XMAHH </td><td style="text-align: left;"> water level </td><td style="text-align: left;"> (in m) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Lefebvre Alain (2015). MAREL Carnot data and metadata from Coriolis Data Centre. SEANOE. <a href="http://doi.org/10.17882/39754">http://doi.org/10.17882/39754</a>
</p>

<hr>
<h2 id='selfKNN'>Self KNN</h2><span id='topic+selfKNN'></span>

<h3>Description</h3>

<p>This function performs the k-Nearest Neighbour algorithm without class estimation, but only computation of distances and neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selfKNN(train, K = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selfKNN_+3A_train">train</code></td>
<td>
<p>numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="selfKNN_+3A_k">K</code></td>
<td>
<p>number of neighbours considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>matrix of squared root of the distances between observations and their nearest neighbours.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>Index of K nearest neighbours of each observation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-matrix(runif(10),ncol=2)
plot(x,pch=c("1","2","3","4","5"))
selfKNN(x,K=4)
</code></pre>

<hr>
<h2 id='spectralPamClusteringNg'>spectralPamClusteringNg function</h2><span id='topic+spectralPamClusteringNg'></span>

<h3>Description</h3>

<p>Perform spectral classification on the similarity matrix of a dataset, using pam algorithm (a more robust version of K-means) on projected data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralPamClusteringNg(similarity, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralPamClusteringNg_+3A_similarity">similarity</code></td>
<td>
<p>matrix of similarity</p>
</td></tr>
<tr><td><code id="spectralPamClusteringNg_+3A_k">K</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of cluster sequencing.</p>
</td></tr>
<tr><td><code>centres</code></td>
<td>
<p>matrix of cluster medoids (similar in concept to means, but medoids are members of the dataset) in the space of the K first normalised eigen vectors.</p>
</td></tr>
<tr><td><code>id.med</code></td>
<td>
<p>integer vector of indices giving the medoid observation numbers.</p>
</td></tr> 
<tr><td><code>vecteursPropresProjK</code></td>
<td>
<p>matrix containing, in columns, the K first normalised eigen vectors of the similarity matrix.</p>
</td></tr> 
<tr><td><code>valeursPropresK</code></td>
<td>
<p>vector containing the K first eigen values of the similarity matrix.</p>
</td></tr> 
<tr><td><code>vecteursPropres</code></td>
<td>
<p>matrix containing, in columns, eigen vectors of the similarity matrix.</p>
</td></tr> 
<tr><td><code>valeursPropres</code></td>
<td>
<p>vector containing eigen values of the similarity matrix.</p>
</td></tr> 
<tr><td><code>cluster.info</code></td>
<td>
<p>matrix, each row gives numerical information for one cluster. 
These are the cardinality of the cluster (number of observations), 
the maximal and average dissimilarity between the observations in the cluster and the cluster's medoid, 
the diameter of the cluster (maximal dissimilarity between two observations of the cluster), 
and the separation of the cluster (minimal dissimilarity between an observation of the cluster and an observation of another cluster).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ng Andrew, Y., M. I. Jordan, and Y. Weiss. &quot;On spectral clustering: analysis and an algorithm [C].&quot; Advances in Neural Information Processing Systems (2001).
</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+pam">pam</a></code>
</p>

<hr>
<h2 id='transitionMatrix'>Transition matrix estimation</h2><span id='topic+transitionMatrix'></span>

<h3>Description</h3>

<p>This function estimates the transition matrix of a (Hidden) Markov Model from a vector of state sequencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionMatrix(states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionMatrix_+3A_states">states</code></td>
<td>
<p>a numeric vector of state sequencing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated transition matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HMMparams">HMMparams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states&lt;-c(1,1,3,2,1,2,1,3)
A&lt;-transitionMatrix(states)
A
</code></pre>

<hr>
<h2 id='uHMMinterface'>Graphical Interface to Build an uHMM</h2><span id='topic+uHMMinterface'></span>

<h3>Description</h3>

<p>A user-friendly interface to detect usual or extreme events in a dataset and to characterize their dynamic,
by building an unsupervised Hidden Markov Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uHMMinterface(uHMMenv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uHMMinterface_+3A_uhmmenv">uHMMenv</code></td>
<td>
<p>an environment in which data and results will be stored. If NULL, a local environment will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results are saved in the directory chosen by the user.
</p>


<h3>References</h3>

<p>Rousseeuw, Kevin, et al. &quot;Hybrid hidden Markov model for marine environment monitoring.&quot; Selected Topics in Applied Earth Observations and Remote Sensing, IEEE Journal of 8.1 (2015): 204-213.
</p>

<hr>
<h2 id='ZPGaussianSimilarity'>Similarity matrix with local scale parameter</h2><span id='topic+ZPGaussianSimilarity'></span>

<h3>Description</h3>

<p>Compute and return the similarity matrix of a data frame using gaussian kernel with a local scale parameter for each data point, 
rather than a unique scale parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZPGaussianSimilarity(data, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZPGaussianSimilarity_+3A_data">data</code></td>
<td>
<p>a matrix or numeric data frame.</p>
</td></tr>
<tr><td><code id="ZPGaussianSimilarity_+3A_k">K</code></td>
<td>
<p>number of neighbours considered to compute scale parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of similarity.
</p>


<h3>References</h3>

<p>Zelnik-Manor, Lihi, and Pietro Perona. &quot;Self-tuning spectral clustering.&quot; Advances in neural information processing systems. 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbind(matrix(rnorm(50, mean = 0, sd = 0.3), ncol = 2))
similarity&lt;-ZPGaussianSimilarity(x,7)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
