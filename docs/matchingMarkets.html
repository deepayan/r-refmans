<!DOCTYPE html><html><head><title>Help for package matchingMarkets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matchingMarkets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baac00'><p>Townsend Thai Project BAAC Annual Resurvey, 2000</p></a></li>
<li><a href='#hri'><p>All stable matchings in the hospital/residents problem with incomplete lists</p></a></li>
<li><a href='#hri2'><p>Resident-optimal matching in the hospital/residents problem with couples</p></a></li>
<li><a href='#iaa'><p>Immediate Acceptance Algorithm (a.k.a. Boston mechanism) for two-sided matching markets</p></a></li>
<li><a href='#khb'><p>Karlson-Holm-Breen method for comparing probit coefficients</p></a></li>
<li><a href='#klein15a'><p>MCMC results in Klein (2015a)</p></a></li>
<li><a href='#klein15b'><p>Results of Monte Carlo Simulations in Klein (2015b)</p></a></li>
<li><a href='#matchingMarkets-package'><p>An R package for the analysis of stable matchings.</p></a></li>
<li><a href='#plp'><p>Partitioning Linear Programme for the stable roommates problem</p></a></li>
<li><a href='#predict.stabit2'><p>Predict method for fitted matching models</p></a></li>
<li><a href='#rsd'><p>Random serial dictatorship mechanism</p></a></li>
<li><a href='#sri'><p>All stable matchings in the stable roommates problem with incomplete lists</p></a></li>
<li><a href='#stabchk'><p>Stability-Check</p></a></li>
<li><a href='#stabit'><p>Matching model and selection correction for group formation</p></a></li>
<li><a href='#stabit2'><p>Matching model and selection correction for college admissions</p></a></li>
<li><a href='#stabsim'><p>Simulated data for group formation problem</p></a></li>
<li><a href='#stabsim2'><p>Simulated data for college admissions problem</p></a></li>
<li><a href='#ttc'><p>Top-Trading-Cycles Algorithm with existing tenants</p></a></li>
<li><a href='#ttc2'><p>Top-Trading-Cycles Algorithm for a two sided matching problem</p></a></li>
<li><a href='#ttcc'><p>Top-Trading-Cycles and Chains Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12), RcppProgress (&ge; 0.2), lpSolve, lattice,
parallel, partitions, rJava, stats, utils</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java, C++</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2, grDevices, graphics</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Stable Matchings</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thilo Klein &lt;thilo@klein.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements structural estimators to correct for
    the sample selection bias from observed outcomes in matching
    markets. This includes one-sided matching of agents into groups 
    (Klein, 2015) <a href="https://www.econ.cam.ac.uk/research-files/repec/cam/pdf/cwpe1521.pdf">https://www.econ.cam.ac.uk/research-files/repec/cam/pdf/cwpe1521.pdf</a> 
    as well as two-sided matching of students to schools 
    (Aue et al., 2020) <a href="https://ftp.zew.de/pub/zew-docs/dp/dp20032.pdf">https://ftp.zew.de/pub/zew-docs/dp/dp20032.pdf</a>.
    The package also contains algorithms to find stable matchings
    in the three most common matching problems: the stable roommates
    problem (Irving, 1985) &lt;<a href="https://doi.org/10.1016%2F0196-6774%2885%2990033-1">doi:10.1016/0196-6774(85)90033-1</a>&gt;, 
    the college admissions problem (Gale and Shapley, 1962) &lt;<a href="https://doi.org/10.2307%2F2312726">doi:10.2307/2312726</a>&gt;, 
    and the house allocation problem (Shapley and Scarf, 1974) &lt;<a href="https://doi.org/10.1016%2F0304-4068%2874%2990033-0">doi:10.1016/0304-4068(74)90033-0</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://matchingMarkets.org">https://matchingMarkets.org</a>, <a href="https://klein.uk">https://klein.uk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thiloklein/matchingMarkets/issues">https://github.com/thiloklein/matchingMarkets/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 04:43:54 UTC; TKN</td>
</tr>
<tr>
<td>Author:</td>
<td>Thilo Klein [aut, cre, cph],
  Robert Aue [ctb],
  Fahiem Bacchus [cph],
  Sven Giegerich [ctb],
  Matthias Hericks [ctb],
  Alexander Sauer [ctb],
  Niklas Sorensson [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 10:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='baac00'>Townsend Thai Project BAAC Annual Resurvey, 2000</h2><span id='topic+baac00'></span>

<h3>Description</h3>

<p>The <code>baac00</code> data frame contains data of 292 borrowers from Thailand's largest
agricultural lending program.
These data are collected as part of the Townsend Thai Project Bank for 
Agriculture and Agricultural Cooperatives (BAAC) Annual Resurvey
(Townsend, 2000).
The 292 borrowers are nested within 68 groups and 39 markets. This nestedness
makes the dataset particularly relevant for matching applications.
A more complete discussion of the data is
found in Ahlin (2009), Section 3, and Klein (2015a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(baac00)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>g.id</dt><dd><p>group identifier.</p>
</dd>
<dt>m.id</dt><dd><p>market identifier.</p>
</dd>
<dt>R</dt><dd><p>repayment outcome: BAAC never raised interest rate as a penalty for late repayment.</p>
</dd>
<dt>pi</dt><dd><p>success probability: measure of group members' project success probability.</p>
</dd>
<dt>wst</dt><dd><p>worst year: indicator of economically worst year. 1:last year; 2:year before last year; 101-168:neither.</p>
</dd>
<dt>loan_size</dt><dd><p>loan size: average loan size borrowed by the group.</p>
</dd>
<dt>loan_size2</dt><dd><p>loan size squared.</p>
</dd>
<dt>lngroup_agei</dt><dd><p>log group age: log of number of years group has existed.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Townsend, R. (2000). Townsend Thai Project Bank for Agriculture and
Agricultural Cooperatives (BAAC) Annual Resurvey, 2000. Available at
<a href="http://hdl.handle.net/1902.1/12057">http://hdl.handle.net/1902.1/12057</a>, <em>Murray Research Archive</em>.
</p>


<h3>References</h3>

<p>Ahlin, C. (2009). Matching for credit: Risk and diversification in Thai microcredit groups.
Working Paper 251, <em>Bureau for Research and Economic Analysis of Development</em>.
</p>
<p>Klein, T. (2015a). <a href="https://ideas.repec.org/p/cam/camdae/1521.html">Does Anti-Diversification Pay? A One-Sided Matching Model of Microcredit</a>. <em>Cambridge Working Papers in Economics</em>, #1521.
</p>

<hr>
<h2 id='hri'>All stable matchings in the hospital/residents problem with incomplete lists</h2><span id='topic+hri'></span>

<h3>Description</h3>

<p>Finds <em>all</em> stable matchings in either the 
<a href="https://en.wikipedia.org/wiki/Hospital_resident">hospital/residents</a> problem (a.k.a. college 
admissions problem) or the related 
<a href="https://en.wikipedia.org/wiki/Stable_matching">stable marriage</a> problem. 
Dependent on the problem, the results comprise the student and college-optimal or 
the men and women-optimal matchings. The implementation allows for <em>incomplete preference 
lists</em> (some agents find certain agents unacceptable) and <em>unbalanced instances</em> (unequal 
number of agents on both sides). The function uses the Prosser (2014) constraint encoding based on 
either given or randomly generated preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hri(
  nStudents = ncol(s.prefs),
  nColleges = ncol(c.prefs),
  nSlots = rep(1, nColleges),
  s.prefs = NULL,
  c.prefs = NULL,
  s.range = NULL,
  c.range = NULL,
  randomization = NULL,
  seed = NULL,
  check_consistency = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hri_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students (in the college admissions problem) 
or men (in the stable marriage problem) in the market. Defaults to <code>ncol(s.prefs)</code>.</p>
</td></tr>
<tr><td><code id="hri_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges (in the college admissions problem) 
or women (in the stable marriage problem) in the market. Defaults to <code>ncol(c.prefs)</code>.</p>
</td></tr>
<tr><td><code id="hri_+3A_nslots">nSlots</code></td>
<td>
<p>vector of length <code>nColleges</code> indicating the number of places (i.e. 
quota) of each college. Defaults to <code>rep(1,nColleges)</code> for the marriage problem.</p>
</td></tr>
<tr><td><code id="hri_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nColleges</code> <code>x</code> <code>nStudents</code> with the <code>j</code>th 
column containing student <code>j</code>'s ranking over colleges in decreasing order of 
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="hri_+3A_c.prefs">c.prefs</code></td>
<td>
<p>matrix of dimension <code>nStudents</code> <code>x</code> <code>nColleges</code> with the <code>i</code>th 
column containing college <code>i</code>'s ranking over students in decreasing order of 
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="hri_+3A_s.range">s.range</code></td>
<td>
<p>range of two intergers <code>s.range = c(s.min, s.max)</code>, where <code>s.min &lt; s.max</code>. 
Produces incomplete preference lists with the length of each student's list randomly sampled from 
the range <code>[s.min, s.max]</code>. Note: interval is only correct if either c.range or s.range is used.</p>
</td></tr>
<tr><td><code id="hri_+3A_c.range">c.range</code></td>
<td>
<p>range of two intergers <code>c.range = c(c.min, c.max)</code>, where <code>c.min &lt; c.max</code>. 
Produces incomplete preference lists with the length of each college's list randomly sampled from 
the range <code>[c.min, c.max]</code>. Note: interval is only correct if either c.range or s.range is used.</p>
</td></tr>
<tr><td><code id="hri_+3A_randomization">randomization</code></td>
<td>
<p>determines at which level random lottery numbers for student priorities are drawn. The default is <code>randomization = "multiple"</code>, where a student's priority is determined by a separate lottery at each college (i.e. local tie-breaking). For the second variant, <code>randomization = "single"</code>, a single lottery number determines a student's priority at all colleges (i.e. global tie breaking).</p>
</td></tr>
<tr><td><code id="hri_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation.</p>
</td></tr>
<tr><td><code id="hri_+3A_check_consistency">check_consistency</code></td>
<td>
<p>Performs consicentcy checks (Checks if there are columns in the preference matrices that only contains zeros and drops them and checks the matrixes for consistencies if they are given by characters). Defaults to <code>TRUE</code> but changing it to <code>FALSE</code> might reduce the running-time for large problems.</p>
</td></tr>
<tr><td><code id="hri_+3A_verbose">verbose</code></td>
<td>
<p>logical. When set to <code>TRUE</code>, writes information messages on the console (recommended). Defaults to <code>FALSE</code>, which suppresses such messages.</p>
</td></tr>
<tr><td><code id="hri_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hri</code> returns a list of the following elements.
</p>
<table>
<tr><td><code>s.prefs.smi</code></td>
<td>
<p>student-side preference matrix for the stable marriage problem with incomplete lists (SMI).</p>
</td></tr>
<tr><td><code>c.prefs.smi</code></td>
<td>
<p>college-side preference matrix for the stable marriage problem with incomplete lists (SMI).</p>
</td></tr>
<tr><td><code>s.prefs.hri</code></td>
<td>
<p>student-side preference matrix for the college admissions problem (a.k.a. hospital/residents problem) with incomplete lists (HRI).</p>
</td></tr>
<tr><td><code>c.prefs.hri</code></td>
<td>
<p>college-side preference matrix for the college admissions problem (a.k.a. hospital/residents problem) with incomplete lists (HRI).</p>
</td></tr>
<tr><td><code>matchings</code></td>
<td>
<p>edgelist of matched students and colleges, inculding the number of the match
(<code>matching</code>) and two variables that indicate the student-optimal match (<code>sOptimal</code>) and 
college-optimal match (<code>cOptimal</code>)</p>
</td></tr></table>
<p>.
</p>


<h3>Minimum required arguments</h3>

<p><code>hri</code> requires the following combination of arguments, subject to the matching problem.
</p>

<dl>
<dt><code>nStudents, nColleges</code></dt><dd><p>Marriage problem with random preferences.</p>
</dd>
<dt><code>s.prefs, c.prefs</code></dt><dd><p>Marriage problem with given preferences.</p>
</dd>
<dt><code>nStudents, nSlots</code></dt><dd><p>College admissions problem with random preferences.</p>
</dd>
<dt><code>s.prefs, c.prefs, nSlots</code></dt><dd><p>College admissions problem with given preferences.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Gale, D. and L.S. Shapley (1962). College admissions and the stability 
of marriage. <em>The American Mathematical Monthly</em>, 69(1):9&ndash;15.
</p>
<p>Morizumi, Y., T. Hayashi and Y. Ishida (2011). A network visualization of stable matching in the stable 
marriage problem. <em>Artificial Life Robotics</em>, 16:40&ndash;43.
</p>
<p>Prosser, P. (2014). Stable Roommates and Constraint Programming. <em>Lecture Notes in Computer Science, CPAIOR 2014 Edition</em>. 
Springer International Publishing, 8451: 15&ndash;28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## -----------------------
## --- Marriage problem 

## 7 men, 6 women, random preferences:
 hri(nStudents=7, nColleges=6, seed=4)

## 3 men, 2 women, given preferences:
 s.prefs &lt;- matrix(c(1,2, 1,2, 1,2), 2,3)
 c.prefs &lt;- matrix(c(1,2,3, 1,2,3), 3,2)
 hri(s.prefs=s.prefs, c.prefs=c.prefs)

## 3 men, 2 women, given preferences:
 s.prefs &lt;- matrix(c("x","y", "x","y", "x","y"), 2,3)
 colnames(s.prefs) &lt;- c("A","B","C")
 c.prefs &lt;- matrix(c("A","B","C", "A","B","C"), 3,2)
 colnames(c.prefs) &lt;- c("x","y")
 hri(s.prefs=s.prefs, c.prefs=c.prefs)

## --------------------------------
## --- College admission problem 

## 7 students, 2 colleges with 3 slots each, random preferences:
 hri(nStudents=7, nSlots=c(3,3), seed=21)

## 7 students, 2 colleges with 3 slots each, given preferences:
 s.prefs &lt;- matrix(c(1,2, 1,2, 1,NA, 1,2, 1,2, 1,2, 1,2), 2,7)
 c.prefs &lt;- matrix(c(1,2,3,4,5,6,7, 1,2,3,4,5,NA,NA), 7,2)
 hri(s.prefs=s.prefs, c.prefs=c.prefs, nSlots=c(3,3))
 
## 7 students, 2 colleges with 3 slots each, given preferences:
 s.prefs &lt;- matrix(c("x","y", "x","y", "x",NA, "x","y", 
                     "x","y", "x","y", "x","y"), 2,7)
 colnames(s.prefs) &lt;- c("A","B","C","D","E","F","G")
 c.prefs &lt;- matrix(c("A","B","C","D","E","F","G", 
                     "A","B","C","D","E",NA,NA), 7,2)
 colnames(c.prefs) &lt;- c("x","y")
 hri(s.prefs=s.prefs, c.prefs=c.prefs, nSlots=c(3,3))
 
## 7 students, 3 colleges with 3 slots each, incomplete preferences:
 hri(nStudents=7, nSlots=c(3,3,3), seed=21, s.range=c(1,3))
 
 s.prefs &lt;- matrix(c('S1', 'S2', NA,
                     'S3', 'S1', NA,
                     'S1', NA, NA,
                      NA, NA,NA,
                     'S2', 'S1', 'S5'),
                   nrow = 3, ncol = 5)
 
 # Note that we explicitly allow for the existence of entries refering to colleges
 # that do not exist. A warning is generated and the entry is ignored.
 colnames(s.prefs) &lt;- c('A', 'B', 'C', 'D', 'E')
 c.prefs &lt;- matrix(c('B', 'C','D', 'A',
                     'C', 'D', NA, NA, 
                     'D', 'B', 'A', 'E'),
                   nrow = 4, ncol = 3)
 colnames(c.prefs) &lt;- c('S1', 'S2', 'S3')
 
 hri(s.prefs=s.prefs, c.prefs=c.prefs, nSlots=c(3,3,3), check_consistency = TRUE)
 
 
## --------------------
## --- Summary plots


## 200 students, 200 colleges with 1 slot each
 res &lt;- hri(nStudents=200, nColleges=200, seed=12)
 plot(res)
 plot(res, energy=TRUE)

</code></pre>

<hr>
<h2 id='hri2'>Resident-optimal matching in the hospital/residents problem with couples</h2><span id='topic+hri2'></span>

<h3>Description</h3>

<p>Implements the Roth Peranson matching algorithm for the <a href="https://en.wikipedia.org/wiki/National_Resident_Matching_Program">hospital/residents problem with couples</a> as described in Roth and Peranson (1999). The function is based on an adoption of Bacchus (2018) and the SAT-solver of Sorenssen (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hri2(
  nStudents = ncol(s.prefs),
  nColleges = ncol(c.prefs),
  nSlots = rep(1, nColleges),
  nCouples = ncol(co.prefs),
  s.prefs = NULL,
  c.prefs = NULL,
  co.prefs = NULL,
  randomization = "multiple",
  seed = NULL,
  check_consistency = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hri2_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students (in the college admissions problem) 
or men (in the stable marriage problem) in the market. Defaults to <code>ncol(s.prefs)</code>.</p>
</td></tr>
<tr><td><code id="hri2_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges (in the college admissions problem) 
or women (in the stable marriage problem) in the market. Defaults to <code>ncol(c.prefs)</code>.</p>
</td></tr>
<tr><td><code id="hri2_+3A_nslots">nSlots</code></td>
<td>
<p>vector of length <code>nColleges</code> indicating the number of places (i.e. 
quota) of each college. Defaults to <code>rep(1,nColleges)</code> for the marriage problem.</p>
</td></tr>
<tr><td><code id="hri2_+3A_ncouples">nCouples</code></td>
<td>
<p>integer indicating the number of couples (in the college admissions problem) 
or men (in the stable marriage problem) in the market. Defaults to <code>ncol(co.prefs)</code></p>
</td></tr>
<tr><td><code id="hri2_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nColleges</code> <code>x</code> <code>nStudents</code> with the <code>j</code>th 
column containing student <code>j</code>'s ranking over colleges in decreasing order of 
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="hri2_+3A_c.prefs">c.prefs</code></td>
<td>
<p>matrix of dimension <code>nStudents</code> <code>x</code> <code>nColleges</code> with the <code>i</code>th 
column containing college <code>i</code>'s ranking over students in decreasing order of 
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="hri2_+3A_co.prefs">co.prefs</code></td>
<td>
<p>matrix of dimension <code>4</code> <code>x</code> <code>nCouplesPrefs</code> in long format with the <code>1</code>th and <code>2</code>th
columns containing student couple id's; <code>3</code>th and <code>4</code>th is a 2-tuple ranking over college preference for the couple (coupleStudent1.pref, coupleStudent2.pref) in decreasing order of 
preference by rows (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="hri2_+3A_randomization">randomization</code></td>
<td>
<p>determines at which level and in which order random lottery numbers for student priorities are drawn. The default is <code>randomization = "multiple"</code>, where a student's priority is determined by a separate lottery at each college (i.e. local tie-breaking). For the second variant, <code>randomization = "single"</code>, a single lottery number determines a student's priority at all colleges (i.e. global tie breaking). A third variant is common in the context of course allocation, where a &quot;couple&quot; represents a student who submits a preference ranking over single courses (first course) and combinations of courses (first and second course). Here, the option <code>randomization = "single-course-first"</code> gives applications for a student's single courses strictly higher priority than for course combinations. This ensures the fairness criterion that a student is only assigned a second course after single course applications of all students have been considered.</p>
</td></tr>
<tr><td><code id="hri2_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation.</p>
</td></tr>
<tr><td><code id="hri2_+3A_check_consistency">check_consistency</code></td>
<td>
<p>Performs additional consicentcy checks if the preference matrices are given by characters. Defaults to <code>FALSE</code>. Set to <code>FALSE</code> to reduce run-time.</p>
</td></tr>
<tr><td><code id="hri2_+3A_verbose">verbose</code></td>
<td>
<p>logical. When set to <code>TRUE</code>, writes information messages on the console (recommended). Defaults to <code>FALSE</code>, which suppresses such messages.</p>
</td></tr>
<tr><td><code id="hri2_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hri2</code> returns a list of the following elements:
</p>
<table>
<tr><td><code>matchings</code></td>
<td>
<p>List of matched students and colleges.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Detailed report of the matching result, including futher information on ranks.</p>
</td></tr>
</table>


<h3>Minimum required arguments</h3>

<p><code>hri2</code> requires the following combination of arguments, subject to the matching problem.
</p>

<dl>
<dt><code>nStudents, nColleges</code></dt><dd><p>Residence hospital problem without couples and random preferences</p>
</dd>
<dt><code>nStudents, nColleges, nCouples, nSlots</code></dt><dd><p>Residence hospital problem with couples and random preferences.</p>
</dd>
<dt><code>s.prefs, c.prefs, co.prefs, nSlots</code></dt><dd><p>Residence hospital problem with couples and given preferences.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Fahiem Bacchus, Sven Giegerich, Thilo Klein, Niklas Sorensson
</p>


<h3>References</h3>

<p>Bacchus, F. (2018). Stable matching suite. GitHub repository.
</p>
<p>Gale, D. and L.S. Shapley (1962). College admissions and the stability 
of marriage. <em>The American Mathematical Monthly</em>, 69(1):9&ndash;15.
</p>
<p>Roth, A. E., &amp; Peranson, E. (1999). The redesign of the matching market for American physicians: Some engineering aspects of economic design. <em>American economic review</em>, 89(4), 748-780.
</p>
<p>Kojima, F., Pathak, P. A., &amp; Roth, A. E. (2013). Matching with couples: Stability and incentives in large markets. <em>The Quarterly Journal of Economics</em>, 128(4), 1585-1632.
</p>
<p>Sorenssen, N. (2013). minisat. GitHub repository.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with given preferences
s.prefs &lt;- matrix(c(4,2,3,5, 2,1,3,NA, 1,2,3,4), 4,3)
c.prefs &lt;- matrix(rep(1:5,5), 5,5)
co.prefs &lt;- matrix(c(rep(4,3), rep(5,3), 3,3,NA, 3,NA,3), 3,4)
res &lt;- hri2(s.prefs=s.prefs, c.prefs=c.prefs, co.prefs=co.prefs, nSlots=rep(1,5))
res$matchings
# summary(res)

## Example with random preferences
nStudents &lt;- 50
nColleges &lt;- 30
nCouples &lt;- 4
nSlots &lt;- sample(1:nStudents, nColleges)
res &lt;- hri2(nStudents=nStudents, nColleges=nColleges, nCouples=nCouples, nSlots=nSlots)
res$matchings
# summary(res)

## Example with characters in the preferences matrices
s.prefs &lt;- matrix(c("Micro1", NA, NA,
                    "Micro2", "Micro1", "Macro",
                    "Macro",NA ,NA), 
                    ncol = 3)
colnames(s.prefs) &lt;- c('Lea', 'Mia', 'Kai')
c.prefs &lt;- matrix(c("Niklas", "Kai", "Mia", "Anna",
                    "Lea", "Kai", "Anna",NA,
                    "Kai", "Mia", "Lea",NA), 
                    ncol = 3)
colnames(c.prefs) &lt;- c('Micro1', 'Micro2', 'Macro')
col1 &lt;- c(rep("Niklas",4),rep("Anna",5))
col2 &lt;- c(rep("Jan",4),rep("Lisa",5))
col3 &lt;- c("Micro1","Macro","Micro1",NA,"Macro",
          NA,"Micro2","Micro2","Macro")
col4 &lt;- c("Micro2","Micro1",NA,"Macro","Macro",
          "Micro1","Micro2","Macro",NA)
co.prefs &lt;- matrix(c(col1,col2,col3,col4), ncol = 4)
res &lt;- hri2(s.prefs=s.prefs, c.prefs=c.prefs, co.prefs=co.prefs, 
            nSlots=c(2,1,1))                     
res$matching

## Example if students are allowed to apply and be accepted by two courses   
col12 &lt;- c(rep(c(rep("Niklas",4),rep("Anna",2)),2))
col3 &lt;- c("Micro1","Macro","Micro1","Macro","Macro","Macro")
col4 &lt;- c("Micro2","Micro1",NA,NA,"Micro1","Micro2")
co.prefs &lt;- matrix(c(col12,col3,col4), ncol = 4)
res &lt;- hri2(s.prefs=s.prefs, c.prefs=c.prefs, co.prefs=co.prefs, 
            nSlots=c(2,1,1))                     
res$matching
</code></pre>

<hr>
<h2 id='iaa'>Immediate Acceptance Algorithm (a.k.a. Boston mechanism) for two-sided matching markets</h2><span id='topic+iaa'></span>

<h3>Description</h3>

<p>Finds the optimal assignment of students to colleges in the
<a href="https://en.wikipedia.org/wiki/Hospital_resident">college admissions</a> problem
based on the Boston mechanism. The algorithmen is also applicable to the stable marriage problem. The option <code>acceptance="deferred"</code> instead uses the Gale-Shapley
(1962) Deferred Acceptance Algorithm with student offer. The function works with either
given or randomly generated preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iaa(
  nStudents = ncol(s.prefs),
  nColleges = ncol(c.prefs),
  nSlots = rep(1, nColleges),
  s.prefs = NULL,
  c.prefs = NULL,
  acceptance = "immediate",
  short_match = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iaa_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students (in the college admissions problem)
or men (in the stable marriage problem) in the market. Defaults to <code>ncol(s.prefs)</code>.</p>
</td></tr>
<tr><td><code id="iaa_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges (in the college admissions problem)
or women (in the stable marriage problem) in the market. Defaults to <code>ncol(c.prefs)</code>.</p>
</td></tr>
<tr><td><code id="iaa_+3A_nslots">nSlots</code></td>
<td>
<p>vector of length <code>nColleges</code> indicating the number of places (i.e.
quota) of each college. Defaults to <code>rep(1,nColleges)</code> for the marriage problem.</p>
</td></tr>
<tr><td><code id="iaa_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nColleges</code> <code>x</code> <code>nStudents</code> with the <code>j</code>th
column containing student <code>j</code>'s ranking over colleges in decreasing order of
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="iaa_+3A_c.prefs">c.prefs</code></td>
<td>
<p>matrix of dimension <code>nStudents</code> <code>x</code> <code>nColleges</code> with the <code>i</code>th
column containing college <code>i</code>'s ranking over students in decreasing order of
preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="iaa_+3A_acceptance">acceptance</code></td>
<td>
<p>if <code>acceptance="deferred"</code> returns the solution found by the student-proposing Gale-Shapley deferred acceptance algorithm; if <code>acceptance="immediate"</code> (the default) returns the solution found by the Boston mechanism.</p>
</td></tr>
<tr><td><code id="iaa_+3A_short_match">short_match</code></td>
<td>
<p>(Optional)  If <code>FALSE</code> then in the returned matching, free capacities will be indicated with 0 entries. If <code>TRUE</code>, free capacities will not be reported in the returned matching but an additonal data.frame is returned that contains free capacities. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iaa_+3A_seed">seed</code></td>
<td>
<p>(Optional) integer setting the state for random number generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>iaa</code> returns a list with the following elements.
</p>
<table>
<tr><td><code>s.prefs</code></td>
<td>
<p>student-side preference matrix.</p>
</td></tr>
<tr><td><code>c.prefs</code></td>
<td>
<p>college-side preference matrix.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of interations required to find the stable matching.</p>
</td></tr>
<tr><td><code>matchings</code></td>
<td>
<p>edgelist of matches</p>
</td></tr>
<tr><td><code>singles</code></td>
<td>
<p>identifier of single (or unmatched) students/men.</p>
</td></tr>
</table>


<h3>Minimum required arguments</h3>

<p><code>iaa</code> requires the following combination of arguments, subject to the matching problem.
</p>

<dl>
<dt><code>nStudents, nColleges</code></dt><dd><p>Marriage problem with random preferences.</p>
</dd>
<dt><code>s.prefs, c.prefs</code></dt><dd><p>Marriage problem with given preferences.</p>
</dd>
<dt><code>nStudents, nSlots</code></dt><dd><p>College admissions problem with random preferences.</p>
</dd>
<dt><code>s.prefs, c.prefs, nSlots</code></dt><dd><p>College admissions problem with given preferences.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Gale, D. and Shapley, L.S. (1962). College admissions and the stability
of marriage. <em>The American Mathematical Monthly</em>, 69(1):9&ndash;15.
</p>
<p>Kojima, F. and M.U. Unver (2014). The &quot;Boston&quot; school-choice mechanism. <em>Economic Theory</em>, 55(3): 515&ndash;544.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --------------------------------
## --- College admission problem

s.prefs &lt;- matrix(c(1,2,3,
                    1,2,3,
                    1,2,3,
                    2,1,3,
                    2,1,3),
                  byrow = FALSE, ncol = 5, nrow = 3)
c.prefs &lt;- matrix(c(1,4,2,3,5,
                    5,2,3,4,1,
                    1,2,3,4,5),
                  byrow = FALSE, ncol = 3, nrow = 5)
nSlots &lt;- c(2,2,1)

## Boston mechanism
 iaa(s.prefs = s.prefs, c.prefs = c.prefs, nSlots = nSlots)$matchings

## Gale-Shapley algorithm
 iaa(s.prefs = s.prefs, c.prefs = c.prefs, nSlots = nSlots, acceptance="deferred")$matchings

## Same results for the Gale-Shapley algorithm with hri2() function (but different format)
 set.seed(123)
 iaa(nStudents=7, nSlots=c(3,3), acceptance="deferred")$matchings
 set.seed(123)
 hri2(nStudents=7, nSlots=c(3,3))$matchings
</code></pre>

<hr>
<h2 id='khb'>Karlson-Holm-Breen method for comparing probit coefficients</h2><span id='topic+khb'></span>

<h3>Description</h3>

<p>Significance test for confounding; that is, the difference between regression 
coefficients from same-sample nested logit and probit models. The test procedure follows
Karlson et al (2012), Section 3.4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khb(X, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="khb_+3A_x">X</code></td>
<td>
<p>data frame comprising independent variables including confounding variable.</p>
</td></tr>
<tr><td><code id="khb_+3A_y">y</code></td>
<td>
<p>vector of dependent variable.</p>
</td></tr>
<tr><td><code id="khb_+3A_z">z</code></td>
<td>
<p>character string giving the name of the confounding variable in <code>X</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>khb</code> returns for all model coefficients the p-value for the null hypothesis that the change in coefficients is not attributable to confounding by z.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Karlson, K.B., A. Holm and R. Breen (2012). Comparing regression coefficients between same-sample nested models using logit and probit: A new method. <em>Sociological Methodology</em>, 42(1):286&ndash;313.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1. load results from Klein (2015a)
 data(klein15a)

## 2. apply KHB method
with(klein15a$variables, khb(X=X, y=Y, z="eta"))
</code></pre>

<hr>
<h2 id='klein15a'>MCMC results in Klein (2015a)</h2><span id='topic+klein15a'></span>

<h3>Description</h3>

<p>MCMC results in Klein (2015a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(klein15a)</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>model.list</dt><dd><p>.</p>
</dd>
<dt>coefs</dt><dd><p>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Klein, T. (2015a). <a href="https://ideas.repec.org/p/cam/camdae/1521.html">Does Anti-Diversification Pay? A One-Sided Matching Model of Microcredit</a>. <em>Cambridge Working Papers in Economics</em>, #1521.
</p>

<hr>
<h2 id='klein15b'>Results of Monte Carlo Simulations in Klein (2015b)</h2><span id='topic+klein15b'></span>

<h3>Description</h3>

<p>Results of Monte Carlo Simulations in Klein (2015b) for 40 two-group markets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(klein15b)</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>exp.5.5.ols</dt><dd><p>Benchmark study, OLS: coefficient estimates for 40 markets with groups of 5. Data for all 5 group members is observed.</p>
</dd>
<dt>exp.5.5.ntu</dt><dd><p>Benchmark study, structural model.</p>
</dd>
<dt>exp.6.5.ols</dt><dd><p>Experiment 1, OLS: coefficient estimates for 40 markets with groups of 6. Only Data for 5 group members is observed.</p>
</dd>
<dt>exp.6.5.ntu</dt><dd><p>Experiment 1, structural model.</p>
</dd>
<dt>exp.6.6.ols</dt><dd><p>Experiment 2, OLS: coefficient estimates for 40 markets with groups of 6. Data for all 6 group members is observed but only a random sample of 250 of the 922 counterfactual groups is used in the analysis.</p>
</dd>
<dt>exp.6.6.ntu</dt><dd><p>Experiment 2, structural model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Klein, T. (2015a). <a href="https://ideas.repec.org/p/cam/camdae/1521.html">Does Anti-Diversification Pay? A One-Sided Matching Model of Microcredit</a>. <em>Cambridge Working Papers in Economics</em>, #1521.
</p>
<p>Klein, T. (2015b). <a href="https://cran.r-project.org/package=matchingMarkets">Analysis of stable matchings in R: Package matchingMarkets</a>. <em>Vignette to R package matchingMarkets</em>, The Comprehensive R Archive Network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot of posterior distributions

data(klein15b)

tpe &lt;- c(rep("Benchmark",2), rep("Experiment 1",2), rep("Experiment 2",2))

for(i in seq(1,length(klein15b)-1,2)){
  ntu &lt;- klein15b[[i]]
  ols &lt;- klein15b[[i+1]]

  ntu &lt;- ntu[,colnames(ntu) == "beta.wst.ieq"]
  ols &lt;- ols[,colnames(ols) == "beta.wst.ieq"]
  
  if(i == 1){
    draws &lt;- data.frame(Structural=ntu, OLS=ols, type=tpe[i]) #, stringsAsFactors=FALSE
  } else{
    draws &lt;- rbind(draws, data.frame(Structural=ntu, OLS=ols, type=tpe[i]))
  }
}

library(lattice)
lattice.options(default.theme = standard.theme(color = FALSE))
keys &lt;- list(text=c("Structural model","OLS"), space="top", columns=2, lines=TRUE)
densityplot( ~ Structural + OLS | type, plot.points=FALSE, auto.key=keys,
       data = draws, xlab = "coefficient draws", ylab = "density", type = "l",
       panel = function(x,...) {
         panel.densityplot(x,...)
         panel.abline(v=-1, lty=3)
       })


## Modes of posterior distributions

## load data
data(klein15b)

## define function to obtain the mode
mode &lt;- function(x){
  d &lt;- density(x,bw="SJ")
  formatC(round(d$x[which.max(d$y)], 3), format='f', digits=3)
}

## Benchmark study
apply(klein15b$exp.5.5.ntu, 2, mode)
apply(klein15b$exp.5.5.ols, 2, mode)

## Experiment 1
apply(klein15b$exp.6.5.ntu, 2, mode)
apply(klein15b$exp.6.5.ols, 2, mode)

## Experiment 2
apply(klein15b$exp.6.6.ntu, 2, mode)
apply(klein15b$exp.6.6.ols, 2, mode)

</code></pre>

<hr>
<h2 id='matchingMarkets-package'>An R package for the analysis of stable matchings.</h2><span id='topic+matchingMarkets'></span>

<h3>Description</h3>

<p>The <code>matchingMarkets</code> package contains <span class="rlang"><b>R</b></span>, <code>C++</code> and <code>Java</code> code for stable matching 
algorithms and the estimation of structural models that correct for the sample selection bias of 
observed outcomes in matching markets.
</p>
<p>Matching is concerned with who transacts with whom, and how. For example, who 
works at which job, which students go to which school, who forms a workgroup 
with whom, and so on.
</p>
<p>The empirical analysis of matching markets is naturally subject to sample 
selection problems. If agents match assortatively on characteristics 
unobserved to the analyst but correlated with both the exogenous variable and 
the outcome of interest, regression estimates will generally be biased.
</p>
<p>The <code>matchingMarkets</code> package comprises
</p>

<ol>
<li> <p><em>Bayes estimators</em>. The estimators implemented in function <code><a href="#topic+stabit">stabit</a></code> 
and <code><a href="#topic+stabit2">stabit2</a></code> correct for the selection bias from endogenous matching. 
</p>
<p>The current package version provides solutions for two commonly observed matching 
processes: 
(i) the <em>group formation problem</em> with fixed group sizes and
(ii) the <em>college admissions problem</em>.
These processes determine which matches are observed &ndash; 
and which are not &ndash; and this is a sample selection problem.
</p>
</li>
<li> <p><em>Post-estimation tools</em>. Setting <code>mfx=TRUE</code> in the <code>summary</code> function  
computes marginal effects from coefficients in binary outcome and selection equations 
and <code><a href="#topic+khb">khb</a></code> implements the Karlson-Holm-Breen test for confounding due to sample selection.
</p>
</li>
<li> <p><em>Design matrix generation</em>. The estimators are based on independent variables for all feasible, 
i.e., observed and counterfactual, matches in the market. Generating the characteristics
of all feasible matches from individual-level data is a combinatorial problem. 
The package returns design matrices based on pre-specified transformations to generate counterfactual matches. 
</p>
</li>
<li> <p><em>Algorithms</em>. The package also contains matching 
algorithms that can be used to simulated matching data: <code><a href="#topic+hri">hri</a></code>: A constraint model (Posser, 2014) 
for the <a href="https://en.wikipedia.org/wiki/Stable_marriage_problem">stable marriage</a> and 
<a href="https://en.wikipedia.org/wiki/National_Resident_Matching_Program">college admissions</a> problem, a.k.a. hospital/residents 
problem (see Gale and Shapley, 1962). <code><a href="#topic+sri">sri</a></code>: A constraint model for the 
<a href="https://en.wikipedia.org/wiki/Stable_roommates_problem">stable roommates problem</a> (see Gusfield and
Irving, 1989). <code><a href="#topic+ttc">ttc</a></code>: The top-trading-cycles algorithm for the 
<a href="https://en.wikipedia.org/wiki/Top_trading_cycle">housing market problem</a>. These can be used to obtain
stable matchings from simulated or real preference data (see Shapley and Scarf, 1974). 
</p>
</li>
<li> <p><em>Data</em>. In addition to the <code><a href="#topic+baac00">baac00</a></code> dataset from borrowing groups in Thailands largest agricultural lending program, the package provides functions <code><a href="#topic+stabsim">stabsim</a></code> and <code><a href="#topic+stabsim2">stabsim2</a></code> to simulate one's own data from one-sided and two-sided matching markets. 
</p>
</li></ol>



<h3>Frequently Asked Questions</h3>


<ul>
<li> <p><em>Why can I not use the classic Heckman correction?</em>
</p>
<p>Estimators such as the Heckman (1979) correction (in package <a href="https://cran.r-project.org/package=sampleSelection"><code>sampleSelection</code></a>) or double selection models are 
inappropriate for this class of selection problems. To see this, note that 
a simple first stage discrete choice model assumes that an observed match 
reveals match partners' preferences over each other. In a matching market, 
however, agents can only choose from the set of partners who would be 
willing to form a match with them and we do not observe the players' 
relevant choice sets. 
</p>
</li>
<li> <p><em>Do I need an instrumental variable to estimate the model?</em>
</p>
<p>Short answer: No. Long answer: The characteristics of other agents in the 
market serve as the source of exogenous variation necessary to identify 
the model. The identifying exclusion restriction is that characteristics 
of all agents in the market affect the matching, i.e., who matches with 
whom, but it is only the characteristics of the match partners that affect 
the outcome of a particular match once it is formed. No additional instruments 
are required for identification (Sorensen, 2007). 
</p>
</li>
<li> <p><em>What are the main assumptions underlying the estimator?</em>
</p>
<p>The approach has certain limitations rooted in its restrictive economic assumptions. 
</p>

<ol>
<li><p> The matching models are <em>complete information</em> models. That is, agents are assumed to have a complete knowledge of the qualities of other market participants.
</p>
</li>
<li><p> The models are <em>static equilibrium</em> models. This implies that (i) the observed matching must be an equilibrium, i.e., no two agents would prefer to leave their current partners in order to form a new match (definition of pairwise stability), and (ii) the equilibrium must be unique for the likelihood function of the model to be well defined (Bresnahan and Reiss, 1991).
</p>
</li>
<li><p> Uniqueness results can be obtained in two ways. First, as is common in the industrial organization literature, by imposing suitable <em>preference restrictions</em>. A suitable restriction on agents' preferences that guarantees a unique equilibrium is alignment (Pycia, 2012). In a group formation model, (pairwise) preference alignment states that any two agents who belong to the same groups must prefer the same group over the other. Second, by choosing a <em>market assigment</em> based on matching algorithms that produce a unique stable matching, such as the well-studied Gale and Shapley (1962) deferred acceptance algorithm.
</p>
</li>
<li><p> Finally, the models assume <em>bivariate normality</em> of the errors in selection and outcome equation. If that assumption fails, the estimator is generally inconsistent and can provide misleading inference in small samples.
</p>
</li></ol>

</li></ul>



<h3>How to cite this package</h3>

<p>Whenever using this package, please cite as
</p>
<p>Klein, T. (2023). matchingMarkets: Structural Estimator and Algorithms for the Analysis of Stable Matchings. R package version 1.0-4.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Bresnahan, T. and Reiss, P. (1991). Empirical models of discrete games. <em>Journal of Econometrics</em>, 48(1-2):57&ndash;81.
</p>
<p>Gale, D. and Shapley, L.S. (1962). College admissions and the stability of marriage. <em>The American Mathematical Monthly</em>, 69(1):9&ndash;15.
</p>
<p>Gusfield, D.M. and R.W. Irving (1989). The stable marriage problem: Structure and algorithms, MIT Press.
</p>
<p>Heckman, J. (1979). Sample selection bias as a specification error. <em>Econometrica</em>, 47(1):153&ndash;161.
</p>
<p>Prosser, P. (2014). Stable Roommates and Constraint Programming. <em>Lecture Notes in Computer Science, CPAIOR 2014 Edition</em>. Springer International Publishing, 8451: 15&ndash;28.
</p>
<p>Pycia, M. (2012). Stability and preference alignment in matching and coalition formation. <em>Econometrica</em>, 80(1):323&ndash;362.
</p>
<p>Shapley, L. and H. Scarf (1974). On cores and indivisibility. <em>Journal of Mathematical Economics</em>, 1(1):23&ndash;37.
</p>
<p>Sorensen, M. (2007). How smart is smart money? A two-sided matching model of venture capital. <em>The Journal of Finance</em>, 62(6):2725&ndash;2762.
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=sampleSelection">sampleSelection</a>
</p>

<hr>
<h2 id='plp'>Partitioning Linear Programme for the stable roommates problem</h2><span id='topic+plp'></span>

<h3>Description</h3>

<p>Finds the stable matching in the <a href="https://en.wikipedia.org/wiki/Stable_roommates_problem">stable roommates problem</a> 
with transferable utility. 
Uses the Partitioning Linear Programme formulated in Quint (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plp(V = NULL, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plp_+3A_v">V</code></td>
<td>
<p>valuation matrix of dimension <code>NxN</code> that gives row-players valuation 
over column players (or vice versa).</p>
</td></tr>
<tr><td><code id="plp_+3A_n">N</code></td>
<td>
<p>integer (divisible by 2) that gives the number of players in the market.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plp</code> returns a list with the following items.
</p>
<table>
<tr><td><code>Valuation.matrix</code></td>
<td>
<p>input values of V.</p>
</td></tr>
<tr><td><code>Assignment.matrix</code></td>
<td>
<p>upper triangular matrix of dimension <code>NxN</code> with entries of 1 for equilibrium pairs and 0 otherwise.</p>
</td></tr>
<tr><td><code>Equilibrium.groups</code></td>
<td>
<p>matrix that gives the <code>N/2</code> equilibrium pairs and equilibrium partners' mutual valuations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Quint, T. (1991). Necessary and sufficient conditions for balancedness 
in partitioning games. <em>Mathematical Social Sciences</em>, 22(1):87&ndash;91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Roommate problem with 10 players, transferable utility and random preferences:
plp(N=10)

## Roommate problem with 10 players, transferable utility and given preferences:
V &lt;- matrix(rep(1:10, 10), 10, 10)
plp(V=V)
</code></pre>

<hr>
<h2 id='predict.stabit2'>Predict method for fitted matching models</h2><span id='topic+predict.stabit2'></span>

<h3>Description</h3>

<p>Calculate predicted values for matching models fitted with functions <code>stabit</code> and <code>stabit2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stabit2'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stabit2_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>stabit</code></p>
</td></tr>
<tr><td><code id="predict.stabit2_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to 
predict. If omitted, the fitted linear predictors or the fitted response values are returned.</p>
</td></tr>
<tr><td><code id="predict.stabit2_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.stabit2</code> returns a vector of predicted values for the latent outcome variable of an object of class <code>stabit</code>.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Klein, T. (2015a). <a href="https://ideas.repec.org/p/cam/camdae/1521.html">Does Anti-Diversification Pay? A One-Sided Matching Model of Microcredit</a>.
<em>Cambridge Working Papers in Economics</em>, #1521.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load the results from Klein (2015) paper
 data(klein15a)
 
## predict the latent outcome variable
 predict(klein15a)

</code></pre>

<hr>
<h2 id='rsd'>Random serial dictatorship mechanism</h2><span id='topic+rsd'></span>

<h3>Description</h3>

<p>Implements the <a href="https://en.wikipedia.org/wiki/Random_serial_dictatorship">random serial dictatorship</a> algorithm algorithm for a fair division of indivisible objects among individuals. The mechanism takes individuals' prioirty order as an input or alternatively draws a random permutation of the agents form the uniform distribution. Individuals are then successively assigned an object in that order (so the first agent in the ordering gets the first pick and so on).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsd(
  nIndividuals = ncol(prefs),
  nObjects = nrow(prefs),
  prefs,
  priority,
  seed = NULL,
  nSlots = rep(1, nObjects)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsd_+3A_nindividuals">nIndividuals</code></td>
<td>
<p>integer indicating the number of individuals in the matching problem. Defaults to ncol(prefs).</p>
</td></tr>
<tr><td><code id="rsd_+3A_nobjects">nObjects</code></td>
<td>
<p>integer indication the number of objects in the matching problem. Defaults to nrow(prefs).</p>
</td></tr>
<tr><td><code id="rsd_+3A_prefs">prefs</code></td>
<td>
<p>matrix of dimension <code>nObjects</code> x <code>nIndividuals</code> with the jth column containing students j's ranking over the objects in decreasing order of preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="rsd_+3A_priority">priority</code></td>
<td>
<p>(Optional) vector of length <code>nIndividuals</code> indicating the priority of the individuals in decreasing order (i.e. highest individuals first). If none is given, a random order is chosen.</p>
</td></tr>
<tr><td><code id="rsd_+3A_seed">seed</code></td>
<td>
<p>(Optional) integer setting the state for random number generation. Defaults to seed = 123.</p>
</td></tr>
<tr><td><code id="rsd_+3A_nslots">nSlots</code></td>
<td>
<p>(Optional) vector of length <code>nObjects</code> indicating the owners/slots possible/available for each object. (If nSlots only consists of ones this means that every object can only have one owner, if the numbers are higher interpreting objects for example as schools might be more intuitive). Defaults to a vector of length <code>nObjects</code> filled with ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rsd</code> returns a data frame containing the final matching of individuals (ind) to objects (obj).
</p>


<h3>Author(s)</h3>

<p>Thilo Klein, Alexander Sauer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate preference-matrix
prefs &lt;- matrix(c(1,2,3,
                  3,1,2,
                  1,3,2),
                  byrow = FALSE, ncol = 3)

priority &lt;- c(1,2,3)
nSlots &lt;- c(1,1,1)

rsd(prefs = prefs, priority = priority, nSlots = nSlots)
</code></pre>

<hr>
<h2 id='sri'>All stable matchings in the stable roommates problem with incomplete lists</h2><span id='topic+sri'></span>

<h3>Description</h3>

<p>Finds all stable matchings (if one exists) in the 
<a href="https://en.wikipedia.org/wiki/Stable_roommates_problem">stable roommates problem</a> with incomplete 
lists using the Prosser (2014) constraint encoding based on either given or randomly generated preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sri(prefs = NULL, nAgents = NULL, seed = NULL, p.range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sri_+3A_prefs">prefs</code></td>
<td>
<p>valuation matrix of dimension <code>nAgents x nAgents</code> that gives column-players' 
ranking over other players in decreasing order of preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="sri_+3A_nagents">nAgents</code></td>
<td>
<p>integer that gives the number of players in the market.</p>
</td></tr>
<tr><td><code id="sri_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation.</p>
</td></tr>
<tr><td><code id="sri_+3A_p.range">p.range</code></td>
<td>
<p>range of two intergers <code>p.range = c(p.min, p.max)</code>, where <code>p.min &lt; p.max</code>. 
Produces incomplete preference lists with the length of each player's list randomly sampled from 
the range <code>[p.min, p.max]</code>. Note: interval is always too small because non-permissible matches 
are automatically deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sri</code> returns a list with the following items.
</p>
<table>
<tr><td><code>prefs</code></td>
<td>
<p>agents' preference list.</p>
</td></tr>
<tr><td><code>matching</code></td>
<td>
<p>edgelist of matched pairs, inculding the number of the match (<code>matching</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Gusfield, D.M. and R.W. Irving (1989). The Stable Marriage Problem: 
Structure and Algorithms, MIT Press.
</p>
<p>Prosser, P. (2014). Stable Roommates and Constraint Programming. <em>Lecture Notes in Computer Science, CPAIOR 2014 Edition</em>. 
Springer International Publishing, 8451: 15&ndash;28.
</p>
<p>Irving, R.W. (1985). An efficient algorithm for the &quot;stable roommates&quot; problem. <em>Journal of Algorithms</em>, 6(4): 577&ndash;595.
</p>
<p>Irving, R.W. and S. Scott (2007). The stable fixtures problem: A many-to-many extension of stable roommates. 
<em>Discrete Applied Mathematics</em>, 155: 2118&ndash;2129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Roommate problem with 10 players, given preferences:
 prefs &lt;- matrix(rep(1:10, 10), 10, 10)
 sri(prefs=prefs)

## Roommate problem with 10 players, random preferences:
 sri(nAgents=10, seed=1)

## Roommate problem with no equilibrium matching:
 sri(nAgents=10, seed=2)

## Roommate problem with 3 equilibria:
 sri(nAgents=10, seed=3)

</code></pre>

<hr>
<h2 id='stabchk'>Stability-Check</h2><span id='topic+stabchk'></span>

<h3>Description</h3>

<p>Checks a given two sided matching for blocking pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabchk(
  matching,
  c.prefs,
  s.prefs,
  nColleges = ncol(c.prefs),
  nStudents = ncol(s.prefs)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabchk_+3A_matching">matching</code></td>
<td>
<p>data frame or matrix of dimension (<code>min[nColleges, nStudents]</code>) x 2 containing in column 1 the colleges and in column 2 the students with each row forming a couple.</p>
</td></tr>
<tr><td><code id="stabchk_+3A_c.prefs">c.prefs</code></td>
<td>
<p>matrix of dimension <code>nStudents</code> x <code>nColleges</code> with column j containing college j'th ranking over students in decreasing order of preferences.</p>
</td></tr>
<tr><td><code id="stabchk_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nColleges</code> x <code>nStudents</code> with column j containing student j'th ranking over colleges in decreasing order of preferences.</p>
</td></tr>
<tr><td><code id="stabchk_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges</p>
</td></tr>
<tr><td><code id="stabchk_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stabchk</code> returns a data frame with as many rows as blocking pairs were found. Column 1 indicates the college and column 2 indicate the student of the blocking pairs. Returns <code>NULL</code> if no blocking pair is found.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein, Alexander Sauer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## 1-a. Generate preferences for colleges
c.prefs = matrix(c(1,2,3,
                   3,2,1,
                   3,2,1),
                    byrow = FALSE, ncol = 3)

## 1-b. Generate preferences for students
s.prefs = matrix(c(1,2,3,
                   3,2,1,
                   2,1,3),
                 byrow = FALSE, ncol = 3)

## 1-c. Generate matching
matching = matrix(c(1,2,
                    2,1,
                    3,3),
                  byrow = TRUE, ncol = 2)

## 1-d. Check stability
stabchk(matching = matching, c.prefs = c.prefs, s.prefs = s.prefs)

## 2-a. Generate new matching without blocking pairs as a data frame
matching = data.frame('colleges' = c(1,2,3), 'student' = c(1,3,2))
stabchk(matching = matching, c.prefs = c.prefs, s.prefs = s.prefs)

## 3-a. Example with missing values:
matching  &lt;- matrix(c(1,1,2,2,3,3), byrow = FALSE, ncol = 2)
c.prefs &lt;- matrix(c(1,1,3,rep(NA, 6)), byrow = TRUE, ncol = 3)
s.prefs &lt;- matrix(c(2,2,3,rep(NA, 6)), byrow = TRUE, ncol = 3)
stabchk(matching = matching, c.prefs = c.prefs, s.prefs = s.prefs)
</code></pre>

<hr>
<h2 id='stabit'>Matching model and selection correction for group formation</h2><span id='topic+stabit'></span>

<h3>Description</h3>

<p>The function provides a Gibbs sampler for a structural matching model that 
estimates preferences and corrects for sample selection bias when the selection process 
is a one-sided matching game; that is, group/coalition formation.
</p>
<p>The input is individual-level data of all group members from one-sided matching marktes; that is, 
from group/coalition formation games. 
</p>
<p>In a first step, the function generates a model matrix with characteristics of <em>all feasible</em> 
groups of the same size as the observed groups in the market. 
</p>
<p>For example, in the stable roommates problem with <code class="reqn">n=4</code> students <code class="reqn">\{1,2,3,4\}</code> 
sorting into groups of 2, we have <code class="reqn"> {4 \choose 2}=6 </code> feasible groups: 
(1,2)(3,4) (1,3)(2,4) (1,4)(2,3).
</p>
<p>In the group formation problem with <code class="reqn">n=6</code> students <code class="reqn">\{1,2,3,4,5,6\}</code> 
sorting into groups of 3, we have <code class="reqn"> {6 \choose 3} =20</code> feasible groups. 
For the same students sorting into groups of sizes 2 and 4, we have <code class="reqn"> {6 \choose 2} + 
{6 \choose 4}=30</code> feasible groups.
</p>
<p>The structural model consists of a selection and an outcome equation. The <em>Selection Equation</em> 
determines which matches are observed (<code class="reqn">D=1</code>) and which are not (<code class="reqn">D=0</code>).
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{lcl}
       D &amp;= &amp; 1[V \in \Gamma] \\
       V &amp;= &amp; W\alpha + \eta
       \end{array}
     </code>
</p>

<p>Here, <code class="reqn">V</code> is a vector of latent valuations of <em>all feasible</em> matches, ie observed and 
unobserved, and <code class="reqn">1[.]</code> is the Iverson bracket. 
A match is observed if its match valuation is in the set of valuations <code class="reqn">\Gamma</code>
that satisfy the equilibrium condition (see Klein, 2015a). This condition differs for matching
games with transferable and non-transferable utility and can be specified using the <code>method</code> 
argument. 
The match valuation <code class="reqn">V</code> is a linear function of <code class="reqn">W</code>, a matrix of characteristics for 
<em>all feasible</em> groups, and <code class="reqn">\eta</code>, a vector of random errors. <code class="reqn">\alpha</code> is a paramter 
vector to be estimated.
</p>
<p>The <em>Outcome Equation</em> determines the outcome for <em>observed</em> matches. The dependent
variable can either be continuous or binary, dependent on the value of the <code>binary</code>
argument. In the binary case, the dependent variable <code class="reqn">R</code> is determined by a threshold 
rule for the latent variable <code class="reqn">Y</code>.
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{lcl}
       R &amp;= &amp; 1[Y &gt; c] \\
       Y &amp;= &amp; X\beta + \epsilon
       \end{array}
     </code>
</p>

<p>Here, <code class="reqn">Y</code> is a linear function of <code class="reqn">X</code>, a matrix of characteristics for <em>observed</em> 
matches, and <code class="reqn">\epsilon</code>, a vector of random errors. <code class="reqn">\beta</code> is a paramter vector to 
be estimated.
</p>
<p>The structural model imposes a linear relationship between the error terms of both equations 
as <code class="reqn">\epsilon = \delta\eta + \xi</code>, where <code class="reqn">\xi</code> is a vector of random errors and <code class="reqn">\delta</code>
is the covariance paramter to be estimated. If <code class="reqn">\delta</code> were zero, the marginal distributions
of <code class="reqn">\epsilon</code> and <code class="reqn">\eta</code> would be independent and the selection problem would vanish.
That is, the observed outcomes would be a random sample from the population of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabit(
  x,
  m.id = "m.id",
  g.id = "g.id",
  R = "R",
  selection = NULL,
  outcome = NULL,
  simulation = "none",
  seed = 123,
  max.combs = Inf,
  method = "NTU",
  binary = FALSE,
  offsetOut = 0,
  offsetSel = 0,
  marketFE = FALSE,
  censored = 0,
  gPrior = FALSE,
  dropOnes = FALSE,
  interOut = 0,
  interSel = 0,
  standardize = 0,
  niter = 10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabit_+3A_x">x</code></td>
<td>
<p>data frame with individual-level characteristics of all group members including
market- and group-identifiers.</p>
</td></tr>
<tr><td><code id="stabit_+3A_m.id">m.id</code></td>
<td>
<p>character string giving the name of the market identifier variable. Defaults to <code>"m.id"</code>.</p>
</td></tr>
<tr><td><code id="stabit_+3A_g.id">g.id</code></td>
<td>
<p>character string giving the name of the group identifier variable. Defaults to <code>"g.id"</code>.</p>
</td></tr>
<tr><td><code id="stabit_+3A_r">R</code></td>
<td>
<p>dependent variable in outcome equation. Defaults to <code>"R"</code>.</p>
</td></tr>
<tr><td><code id="stabit_+3A_selection">selection</code></td>
<td>
<p>list containing variables and pertaining operators in the selection equation. The format is 
<code>operation = "variable"</code>. See the Details and Examples sections.</p>
</td></tr>
<tr><td><code id="stabit_+3A_outcome">outcome</code></td>
<td>
<p>list containing variables and pertaining operators in the outcome equation. The format is 
<code>operation = "variable"</code>. See the Details and Examples sections.</p>
</td></tr>
<tr><td><code id="stabit_+3A_simulation">simulation</code></td>
<td>
<p>should the values of dependent variables in selection and outcome equations be simulated? Options are <code>"none"</code> for no simulation, <code>"NTU"</code> for non-transferable utility matching, <code>"TU"</code> for transferable utility or <code>"random"</code> for random matching of individuals to groups. Simulation settings are (i) all model coefficients set to <code>alpha=beta=1</code>; (ii) covariance between error terms <code>delta=0.5</code>; (iii) error terms <code>eta</code> and <code>xi</code> are draws from a standard normal distribution.</p>
</td></tr>
<tr><td><code id="stabit_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation if <code>simulation=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stabit_+3A_max.combs">max.combs</code></td>
<td>
<p>integer (divisible by two) giving the maximum number of feasible groups to be used for generating group-level characteristics.</p>
</td></tr>
<tr><td><code id="stabit_+3A_method">method</code></td>
<td>
<p>estimation method to be used. Either <code>"NTU"</code> or <code>"TU"</code> for selection correction using non-transferable or transferable utility matching as selection rule; <code>"outcome"</code> for estimation of the outcome equation only; or <code>"model.frame"</code> for no estimation.</p>
</td></tr>
<tr><td><code id="stabit_+3A_binary">binary</code></td>
<td>
<p>logical: if <code>TRUE</code> outcome variable is taken to be binary; if <code>FALSE</code> outcome variable is taken to be continuous.</p>
</td></tr>
<tr><td><code id="stabit_+3A_offsetout">offsetOut</code></td>
<td>
<p>vector of integers indicating the indices of columns in <code>X</code> for which coefficients should be forced to 1. Use 0 for none.</p>
</td></tr>
<tr><td><code id="stabit_+3A_offsetsel">offsetSel</code></td>
<td>
<p>vector of integers indicating the indices of columns in <code>W</code> for which coefficients should be forced to 1. Use 0 for none.</p>
</td></tr>
<tr><td><code id="stabit_+3A_marketfe">marketFE</code></td>
<td>
<p>logical: if <code>TRUE</code> market-level fixed effects are used in outcome equation; if <code>FALSE</code> no market fixed effects are used.</p>
</td></tr>
<tr><td><code id="stabit_+3A_censored">censored</code></td>
<td>
<p>draws of the <code>delta</code> parameter that estimates the covariation between the error terms in selection and outcome equation are 0:not censored, 1:censored from below, 2:censored from above.</p>
</td></tr>
<tr><td><code id="stabit_+3A_gprior">gPrior</code></td>
<td>
<p>logical: if <code>TRUE</code> the g-prior (Zellner, 1986) is used for the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="stabit_+3A_dropones">dropOnes</code></td>
<td>
<p>logical: if <code>TRUE</code> one-group-markets are exluded from estimation.</p>
</td></tr>
<tr><td><code id="stabit_+3A_interout">interOut</code></td>
<td>
<p>two-colum matrix indicating the indices of columns in <code>X</code> that should be interacted in estimation. Use 0 for none.</p>
</td></tr>
<tr><td><code id="stabit_+3A_intersel">interSel</code></td>
<td>
<p>two-colum matrix indicating the indices of columns in <code>W</code> that should be interacted in estimation. Use 0 for none.</p>
</td></tr>
<tr><td><code id="stabit_+3A_standardize">standardize</code></td>
<td>
<p>numeric: if <code>standardize&gt;0</code> the independent variables will be standardized by dividing by <code>standardize</code> times their standard deviation. Defaults to no standardization <code>standardize=0</code>.</p>
</td></tr>
<tr><td><code id="stabit_+3A_niter">niter</code></td>
<td>
<p>number of iterations to use for the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="stabit_+3A_verbose">verbose</code></td>
<td>
<p>logical. When set to <code>TRUE</code>, writes information messages on the console (recommended). Defaults to <code>FALSE</code>, which suppresses such messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Operators for variable transformations in <code>selection</code> and <code>outcome</code> arguments.
</p>

<dl>
<dt><code>add</code></dt><dd><p>sum over all group members and divide by group size.</p>
</dd>
<dt><code>int</code></dt><dd><p>sum over all possible two-way interactions <code class="reqn">x*y</code> of group members and divide by the number of those, given by <code>choose(n,2)</code>.</p>
</dd>
<dt><code>ieq</code></dt><dd><p>sum over all possible two-way equality assertions <code class="reqn">1[x=y]</code> and divide by the number of those.</p>
</dd>
<dt><code>ive</code></dt><dd><p>sum over all possible two-way interactions of vectors of variables of group members and divide by number of those.</p>
</dd>
<dt><code>inv</code></dt><dd><p>...</p>
</dd>
<dt><code>dst</code></dt><dd><p>sum over all possible two-way distances between players and divide by number of those, where distance is defined as <code class="reqn">e^{-|x-y|}</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>stabit</code> returns for <code>method = "model.frame"</code>, a list of data from a NTU or TU matching market with the following elements.
</p>
<table>
<tr><td><code>OUT</code></td>
<td>
<p>Model matrix of the outcome data, where <code>m.id</code> and <code>g.id</code> are categorical variables for market and group identifier.</p>
</td></tr>
<tr><td><code>SEL</code></td>
<td>
<p>Model matrix of the selection data, again with categorical variables <code>m.id</code> and <code>g.id</code> for market and group identifier.</p>
</td></tr>
<tr><td><code>combs</code></td>
<td>
<p>List of length of the number of markets with each element containing a matrix of all counterfactual group constellations in a market.</p>
</td></tr>
</table>
<p>For any other setting of <code>method</code>, a list of the estimation results is returned.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Klein, T. (2015a). <a href="https://ideas.repec.org/p/cam/camdae/1521.html">Does Anti-Diversification Pay? A One-Sided Matching Model of Microcredit</a>.
<em>Cambridge Working Papers in Economics</em>, #1521.
</p>
<p>Zellner, A. (1986). <em>On assessing prior distributions and Bayesian regression analysis with g-prior distributions</em>, 
volume 6, pages 233&ndash;243. North-Holland, Amsterdam.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## --- SIMULATED EXAMPLE ---

## 1. Simulate one-sided matching data for 200 markets (m=200) with 2 groups
##    per market (gpm=2) and 5 individuals per group (ind=5). True parameters 
##    in selection equation is wst=1, in outcome equation wst=0. 

## 1-a. Simulate individual-level, independent variables
 idata &lt;- stabsim(m=200, ind=5, seed=123, gpm=2)
 head(idata)
 
## 1-b. Simulate group-level variables 
 mdata &lt;- stabit(x=idata, simulation="NTU", method="model.frame",
 selection = list(add="wst"), outcome = list(add="wst"), verbose=FALSE)
 head(mdata$OUT)
 head(mdata$SEL)


## 2. Bias from sorting

## 2-a. Naive OLS estimation
 lm(R ~ wst.add, data=mdata$OUT)$coefficients

## 2-b. epsilon is correlated with independent variables
 with(mdata$OUT, cor(epsilon, wst.add))
 
## 2-c. but xi is uncorrelated with independent variables
 with(mdata$OUT, cor(xi, wst.add))

## 3. Correction of sorting bias when valuations V are observed

## 3-a. 1st stage: obtain fitted value for eta
lm.sel &lt;- lm(V ~ -1 + wst.add, data=mdata$SEL)
lm.sel$coefficients

eta &lt;- lm.sel$resid[mdata$SEL$D==1]

## 3-b. 2nd stage: control for eta
 lm(R ~ wst.add + eta, data=mdata$OUT)$coefficients


## 4. Run Gibbs sampler
 fit1 &lt;- stabit(x=idata, method="NTU", simulation="NTU", censored=1, 
                selection = list(add="wst"), outcome = list(add="wst"), 
                niter=2000, verbose=FALSE)


## 5. Coefficient table
 summary(fit1)


## 6. Plot MCMC draws for coefficients
 plot(fit1)

## --- REPLICATION, Klein (2015a) ---

## 1. Load data 
 data(baac00)
 
## 2. Run Gibbs sampler
 klein15a &lt;- stabit(x=baac00, selection = list(inv="pi",ieq="wst"), 
        outcome = list(add="pi",inv="pi",ieq="wst",
        add=c("loan_size","loan_size2","lngroup_agei")), offsetOut=1,
        method="NTU", binary=TRUE, gPrior=TRUE, marketFE=TRUE, niter=800000)

## 3. Marginal effects
 summary(klein15a, mfx=TRUE)
 
## 4. Plot MCMC draws for coefficients
 plot(klein15a)

</code></pre>

<hr>
<h2 id='stabit2'>Matching model and selection correction for college admissions</h2><span id='topic+stabit2'></span>

<h3>Description</h3>

<p>The function provides a Gibbs sampler for a structural matching model that 
estimates preferences and corrects for sample selection bias when the selection process 
is a two-sided matching game; i.e., a matching of students to colleges.
</p>
<p>The structural model consists of a selection and an outcome equation. The <em>Selection Equation</em> 
determines which matches are observed (<code class="reqn">D=1</code>) and which are not (<code class="reqn">D=0</code>).
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{lcl}
       D &amp;= &amp; 1[V \in \Gamma] \\
       V &amp;= &amp; W\beta + \eta
       \end{array}
     </code>
</p>

<p>Here, <code class="reqn">V</code> is a vector of latent valuations of <em>all feasible</em> matches, ie observed and 
unobserved, and <code class="reqn">1[.]</code> is the Iverson bracket. 
A match is observed if its match valuation is in the set of valuations <code class="reqn">\Gamma</code>
that satisfy the equilibrium condition (see Sorensen, 2007). 
The match valuation <code class="reqn">V</code> is a linear function of <code class="reqn">W</code>, a matrix of characteristics for 
<em>all feasible</em> matches, and <code class="reqn">\eta</code>, a vector of random errors. <code class="reqn">\beta</code> is a paramter 
vector to be estimated.
</p>
<p>The <em>Outcome Equation</em> determines the outcome for <em>observed</em> matches. The dependent
variable can either be continuous or binary, dependent on the value of the <code>binary</code>
argument. In the binary case, the dependent variable <code class="reqn">R</code> is determined by a threshold 
rule for the latent variable <code class="reqn">Y</code>.
</p>
<p style="text-align: center;"><code class="reqn"> \begin{array}{lcl}
       R &amp;= &amp; 1[Y &gt; c] \\
       Y &amp;= &amp; X\alpha + \epsilon
       \end{array}
     </code>
</p>

<p>Here, <code class="reqn">Y</code> is a linear function of <code class="reqn">X</code>, a matrix of characteristics for <em>observed</em> 
matches, and <code class="reqn">\epsilon</code>, a vector of random errors. <code class="reqn">\alpha</code> is a paramter vector to 
be estimated.
</p>
<p>The structural model imposes a linear relationship between the error terms of both equations 
as <code class="reqn">\epsilon = \kappa\eta + \nu</code>, where <code class="reqn">\nu</code> is a vector of random errors and <code class="reqn">\kappa</code>
is the covariance paramter to be estimated. If <code class="reqn">\kappa</code> were zero, the marginal distributions
of <code class="reqn">\epsilon</code> and <code class="reqn">\eta</code> would be independent and the selection problem would vanish.
That is, the observed outcomes would be a random sample from the population of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabit2(
  OUT = NULL,
  SEL = NULL,
  colleges = NULL,
  students = NULL,
  outcome = NULL,
  selection,
  binary = FALSE,
  niter,
  gPrior = FALSE,
  censored = 1,
  thin = 1,
  nCores = max(1, detectCores() - 1),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabit2_+3A_out">OUT</code></td>
<td>
<p>data frame with characteristics of all observed matches, including
market identifier <code>m.id</code>, college identifier <code>c.id</code> and student identifier <code>s.id</code>.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_sel">SEL</code></td>
<td>
<p>optional: data frame with characteristics of all observed and unobserved matches, including 
market identifier <code>m.id</code>, college identifier <code>c.id</code> and student identifier <code>s.id</code>.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_colleges">colleges</code></td>
<td>
<p>character vector of variable names for college characteristics. These variables carry the same value for any college.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_students">students</code></td>
<td>
<p>character vector of variable names for student characteristics. These variables carry the same value for any student.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_outcome">outcome</code></td>
<td>
<p>formula for match outcomes.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_selection">selection</code></td>
<td>
<p>formula for match valuations.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_binary">binary</code></td>
<td>
<p>logical: if <code>TRUE</code> outcome variable is taken to be binary; if <code>FALSE</code> outcome variable is taken to be continuous.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_niter">niter</code></td>
<td>
<p>number of iterations to use for the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_gprior">gPrior</code></td>
<td>
<p>logical: if <code>TRUE</code> the g-prior (Zellner, 1986) is used for the variance-covariance matrix. (Not yet implemented)</p>
</td></tr>
<tr><td><code id="stabit2_+3A_censored">censored</code></td>
<td>
<p>draws of the <code>kappa</code> parameter that estimates the covariation between the error terms in selection and outcome equation are 0:not censored, 1:censored from below, 2:censored from above.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_thin">thin</code></td>
<td>
<p>integer indicating the level of thinning in the MCMC draws. The default <code>thin=1</code> saves every draw, <code>thin=2</code> every second, etc.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_ncores">nCores</code></td>
<td>
<p>number of cores to be used in parallel Gibbs sampling.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_verbose">verbose</code></td>
<td>
<p>logical. When set to <code>TRUE</code>, writes information messages on the console (recommended). Defaults to <code>FALSE</code>, which suppresses such messages.</p>
</td></tr>
<tr><td><code id="stabit2_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stabit2</code> returns a list of the estimation results with the following elements.
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>numeric scalar: standard deviation fixed to 1.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>numeric vector: residuals of the selection equation.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>List of variance covariance matrices for coefficients alpha and beta of selection and outcome equations.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>numeric vector: coefficients of selection and outcome equations.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>numeric vector: fitted values for outcome data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>numeric vector: residuals of the outcome equation.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>integer: degrees of freedom.</p>
</td></tr>
<tr><td><code>binary</code></td>
<td>
<p>logical: if <code>TRUE</code> outcome variable was taken to be binary; if <code>FALSE</code> outcome variable was taken to be continuous.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>estimated formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>One of &quot;Sorensen&quot;, &quot;Klein&quot; or &quot;Klein-selection&quot;. Method &quot;Sorensen&quot; is used when a single selection equation is passed. It assumes an equal sharing rule for student and college utility. Method &quot;Klein&quot; is used when two selection equations (one for students, one for schools) and one outcome equations are passed. Method &quot;Klein-selection&quot; only models selection and therefore does not require an outcome equations.</p>
</td></tr>
<tr><td><code>draws</code></td>
<td>
<p>List of Gibbs sampling draws for alpha and beta coefficients.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>Posterior means of the Gibbs sampling draws.</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p>List of data used in the estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>References</h3>

<p>Sorensen, M. (2007). How Smart is Smart Money? A Two-Sided Matching Model of Venture Capital.
<em>Journal of Finance</em>, 62 (6): 2725-2762.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## --- SIMULATED EXAMPLE ---

## 1. Simulate two-sided matching data for 20 markets (m=20) with 100 students
##    (nStudents=100) per market and 20 colleges with quotas of 5 students, each
##    (nSlots=rep(5,20)). True parameters in selection and outcome equations are 
##    all equal to 1.

xdata &lt;- stabsim2(m=20, nStudents=100, nSlots=rep(5,20), verbose=FALSE,
  colleges = "c1", students = "s1",
  outcome = ~ c1:s1 + eta + nu,
  selection = ~ -1 + c1:s1 + eta
)
head(xdata$OUT)


## 2. Correction for sorting bias when match valuations V are observed

## 2-a. Bias from sorting
 lm1 &lt;- lm(y ~ c1:s1, data=xdata$OUT)
 summary(lm1)

## 2-b. Cause of the bias
 with(xdata$OUT, cor(c1*s1, eta))

## 2-c. Correction for sorting bias
 lm2a &lt;- lm(V ~ -1 + c1:s1, data=xdata$SEL); summary(lm2a)
 etahat &lt;- lm2a$residuals[xdata$SEL$D==1]
 
 lm2b &lt;- lm(y ~ c1:s1 + etahat, data=xdata$OUT)
 summary(lm2b)


## 3. Correction for sorting bias when match valuations V are unobserved

## 3-a. Run Gibbs sampler (when SEL is given)
 fit2 &lt;- stabit2(OUT = xdata$OUT, 
           SEL = xdata$SEL,
           outcome = y ~ c1:s1, 
           selection = ~ -1 + c1:s1,
           niter=1000
 )

## 3-b. Alternatively: Run Gibbs sampler (when SEL is not given)
 fit2 &lt;- stabit2(OUT = xdata$OUT, 
           colleges = "c1",
           students = "s1",
           outcome = y ~ c1:s1, 
           selection = ~ -1 + c1:s1,
           niter=1000
 )


## 4. Implemented methods

## 4-a. Get coefficients
 fit2
 
## 4-b. Coefficient table
 summary(fit2)
 
## 4-c. Get marginal effects
 summary(fit2, mfx=TRUE)
 
## 4-d. Also try the following functions
 #coef(fit2)
 #fitted(fit2)
 #residuals(fit2)
 #predict(fit2, newdata=NULL)

   
## 5. Plot MCMC draws for coefficients
 plot(fit2)

</code></pre>

<hr>
<h2 id='stabsim'>Simulated data for group formation problem</h2><span id='topic+stabsim'></span>

<h3>Description</h3>

<p>Simulate individual-level data for one-sided matching markets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsim(m, ind, seed = 123, singles = NULL, gpm = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsim_+3A_m">m</code></td>
<td>
<p>integer indicating the number of markets to be simulated.</p>
</td></tr>
<tr><td><code id="stabsim_+3A_ind">ind</code></td>
<td>
<p>integer (or vector) indicating the number of individuals per group.</p>
</td></tr>
<tr><td><code id="stabsim_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation. Defaults to <code>set.seed(123)</code>.</p>
</td></tr>
<tr><td><code id="stabsim_+3A_singles">singles</code></td>
<td>
<p>integer giving the number of one-group markets.</p>
</td></tr>
<tr><td><code id="stabsim_+3A_gpm">gpm</code></td>
<td>
<p>integer giving the number of groups per market.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stabsim</code> returns a data frame with the randomly generated variables 
mimicking those in dataset <code><a href="#topic+baac00">baac00</a></code>.
</p>
<table>
<tr><td><code>m.id</code></td>
<td>
<p>categorical: market identifier.</p>
</td></tr>
<tr><td><code>g.id</code></td>
<td>
<p>categorical: group identifier.</p>
</td></tr>
<tr><td><code>wst</code></td>
<td>
<p>binary: indicator taking the value 1 if last year was worse than the year before; 0 otherwise.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>NA: group outcome is not simulated. It can be obtained using the  <code>simulation</code> argument 
in function <code>stabit</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Coalitions [gpm := 2 !]
## Simulate one-sided matching data for 4 markets (m=4) with 2 groups
## per market (gpm=2) and 2 to 4 individuals per group (ind=2:4)
 idata &lt;- stabsim(m=4, ind=2:4, seed=124, singles=2, gpm=2)  

## Rommmates [ind := 2 !]
## Simulate one-sided matching data for 3 markets (m=3) with 3 groups
## per market (gpm=3) and 2 individuals per group (ind=2)
 idata &lt;- stabsim(m=3, ind=2, seed=124, gpm=3)
</code></pre>

<hr>
<h2 id='stabsim2'>Simulated data for college admissions problem</h2><span id='topic+stabsim2'></span>

<h3>Description</h3>

<p>Simulate data for two-sided matching markets. In the simulation for the 
Sorensen (2007) model with one selection equation, an equal sharing rule of 
<code class="reqn">\lambda = 0.5</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsim2(
  m,
  nStudents,
  nColleges = length(nSlots),
  nSlots,
  colleges,
  students,
  outcome,
  selection,
  binary = FALSE,
  seed = 123,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsim2_+3A_m">m</code></td>
<td>
<p>integer indicating the number of markets to be simulated.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students per market.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges per market.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_nslots">nSlots</code></td>
<td>
<p>vector of length <code>nColleges</code> indicating the number of places at each college, i.e. 
the college's quota.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_colleges">colleges</code></td>
<td>
<p>character vector of variable names for college characteristics. These variables carry the same value for any college.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_students">students</code></td>
<td>
<p>character vector of variable names for student characteristics. These variables carry the same value for any student.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_outcome">outcome</code></td>
<td>
<p>formula for match outcomes.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_selection">selection</code></td>
<td>
<p>formula for match valuations.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_binary">binary</code></td>
<td>
<p>logical: if <code>TRUE</code> outcome variable is binary; if <code>FALSE</code> outcome variable is continuous.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_seed">seed</code></td>
<td>
<p>integer setting the state for random number generation. Defaults to <code>set.seed(123)</code>.</p>
</td></tr>
<tr><td><code id="stabsim2_+3A_verbose">verbose</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stabsim2</code> returns a list with the following items.
</p>
<table>
<tr><td><code>OUT</code></td>
<td>
</td></tr>
<tr><td><code>SEL</code></td>
<td>
</td></tr>
<tr><td><code>SELc</code></td>
<td>
</td></tr>
<tr><td><code>SELs</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thilo Klein
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate two-sided matching data for 2 markets (m=2) with 10 students
## (nStudents=10) per market and 3 colleges (nColleges=3) with quotas of
## 2, 3, and 5 students, respectively.

xdata &lt;- stabsim2(m=2, nStudents=10, nSlots=c(2,3,5), verbose=FALSE,
  colleges = "c1", students = "s1",
  outcome = ~ c1:s1 + eta + nu,
  selection = ~ -1 + c1:s1 + eta
)
head(xdata$OUT)
head(xdata$SEL)

</code></pre>

<hr>
<h2 id='ttc'>Top-Trading-Cycles Algorithm with existing tenants</h2><span id='topic+ttc'></span>

<h3>Description</h3>

<p>Implements an algorithm for the
<a href="https://en.wikipedia.org/wiki/Top_trading_cycle">house allocation problem</a> proposed by Abdulkadiroglu and Sonmez (1999) for a matching problem in which there are both vacant houses and existing tenants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttc(
  nStudents = ncol(s.prefs),
  nHouses = length(houses),
  s.prefs,
  houses,
  priority = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttc_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students. Defaults to <code>ncol(s.prefs)</code>.</p>
</td></tr>
<tr><td><code id="ttc_+3A_nhouses">nHouses</code></td>
<td>
<p>integer indicating the number of houses. Defaults to <code>length(houses)</code>.</p>
</td></tr>
<tr><td><code id="ttc_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nHouses</code> x <code>nStudents</code> with column j containing student jth ranking over houses in decreasing order of preferences (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="ttc_+3A_houses">houses</code></td>
<td>
<p>vector of length <code>nHouses</code> which represents the occupation of the houses. Entry in <code>k</code> contains <code>j</code> if student <code>j</code> is living in house <code>k</code> and <code>NA</code> if house <code>k</code> is vacant.</p>
</td></tr>
<tr><td><code id="ttc_+3A_priority">priority</code></td>
<td>
<p>(Optional) vector of length <code>nStudents</code>. Gives the prioirity ordering of the students in the search for cycles (Do not confuse it with the preferences!), if nothing is specified a random ordering is chosen.</p>
</td></tr>
<tr><td><code id="ttc_+3A_seed">seed</code></td>
<td>
<p>(Optional) integer setting the state for random number generation. Defaults to seed = NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ttc</code> returns a data frame of the matching of students (int) to houses (obj)  for the house allocation problem based on the Top-Trading-Cycles algorithm.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein, Alexander Sauer
</p>


<h3>References</h3>

<p>Abdulkadiroglu, A. and T. Sonmez (1999). House Allocation with Existing Tenants. <em>Journal of Economic Theory</em>,  88 (2): 233-260.
</p>
<p>Shapley, L. and H. Scarf (1974). On Cores and Indivisibility. <em>Journal of Mathematical Economics</em>, 1(1): 23-37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-a. Generate matrix of individuals' preference rankings over objects,
## a.k.a. Rank Order Lists (ROL).
s.prefs &lt;- matrix(c(3,2,4,1,        # ROL of student 1
                   3,5,6, NA,
                   3,1, NA,NA,
                   2,5,6,4,
                   1,3,2,NA,
                   2,4,5,6), nrow = 4, ncol = 6, byrow = FALSE)

## 1-b. Generate vector of house occupation objects ('obj') and their owners ('ind')
houses &lt;- 1:6

## 1-c. Find assignment based on TTC algorithm
ttc(s.prefs = s.prefs, houses = houses, nHouses = 6, priority = 1:6)

## 2-a.Compare the example in the paper Abdulkadiroglu et al. (1999)
## on page 246-248 (section 5.1 An Example):
## generate matrix of students' preference rankings over houses, a.k.a. Rank Order Lists (ROL)
s.prefs &lt;- matrix(c(2,6,5,1,4,3,7,NA,
                 7,1,6,5,4,3,2,NA,
                 2,1,4,7,3,6,5,NA,
                 2,4,3,6,1,7,5,NA,
                 4,3,7,1,2,5,6,NA), byrow = FALSE, ncol= 5)

## 2-b. Generate house occupation, so student 1 lives in house 1, ..., student 4 lives in house 4
## and the other houses are vacant.
houses &lt;- c(1,2,3,4,NA,NA,NA,NA)

## 2-c. Generate priority ordering
priority &lt;- 1:5

## 2-d. Find assigment
ttc(s.prefs = s.prefs, houses = houses, priority = priority)
</code></pre>

<hr>
<h2 id='ttc2'>Top-Trading-Cycles Algorithm for a two sided matching problem</h2><span id='topic+ttc2'></span>

<h3>Description</h3>

<p>Implements the school matching algorithm proposed in Abdulkadiroglu and Sonmez (2003) for a matching problem
in which both sides have preferences. Missing preferences are handled in the following ways: Suppose that a student only ranked colleges that are already matched
to other students. This student is removed from the matching process and a list with all unmatchable students is printed.
If <code>full_return</code> is set to <code>TRUE</code>, a vector with this students is returned as well.
Now suppose during the matching process a student points to a college that still has capacities but does not rank any more students.
We assume now that the college is indifferent over all other students (so we do not allow for free capacieties) and we match the student who wants to go there to the college.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttc2(
  nStudents = ncol(s.prefs),
  nColleges = ncol(c.prefs),
  s.prefs = NULL,
  c.prefs = NULL,
  nSlots = NULL,
  priority = NULL,
  seed = NULL,
  full_return = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttc2_+3A_nstudents">nStudents</code></td>
<td>
<p>integer indicating the number of students in the matching problem. Defaults to <code>ncol(s.prefs)</code>.</p>
</td></tr>
<tr><td><code id="ttc2_+3A_ncolleges">nColleges</code></td>
<td>
<p>integer indicating the number of colleges in the matching problem. Defaults to <code>ncol(c.prefs)</code>.</p>
</td></tr>
<tr><td><code id="ttc2_+3A_s.prefs">s.prefs</code></td>
<td>
<p>matrix of dimension <code>nColleges</code> x <code>nStudents</code> with the jth column containing student j's ranking over colleges in decreasing order of preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="ttc2_+3A_c.prefs">c.prefs</code></td>
<td>
<p>matrix of dimension <code>nStudents</code> x <code>nColleges</code> with the ith column containing college i's ranking over students in decreasing order of preference (i.e. most preferred first).</p>
</td></tr>
<tr><td><code id="ttc2_+3A_nslots">nSlots</code></td>
<td>
<p>vector of length <code>nColleges</code> indicating the number of places (i.e. quota) of each college.</p>
</td></tr>
<tr><td><code id="ttc2_+3A_priority">priority</code></td>
<td>
<p>(Optional) vector of length <code>nStudents</code>. Gives the prioirity ordering of the students in the search for cycles (Do not confuse it with the preferences!), if nothing is specified a random ordering is chosen.</p>
</td></tr>
<tr><td><code id="ttc2_+3A_seed">seed</code></td>
<td>
<p>(Optional) integer setting the state for random number generation. Defaults to seed = NULL</p>
</td></tr>
<tr><td><code id="ttc2_+3A_full_return">full_return</code></td>
<td>
<p>(Optinal) If <code>TRUE</code> the return value is a list with the matching, the remaining seats and the unmatchable students is returned. Defaults to <code>FALSE</code> and only the matching is returned.</p>
</td></tr>
<tr><td><code id="ttc2_+3A_verbose">verbose</code></td>
<td>
<p>logical. When set to <code>TRUE</code>, writes information messages on the console (recommended). Defaults to <code>FALSE</code>, which suppresses such messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ttc2</code> returns a data frame of the matching of students (ind) to colleges (obj) for the school market problem based on the Top-Trading-Cycles algorithm.
</p>


<h3>Author(s)</h3>

<p>Thilo Klein, Alexander Sauer
</p>


<h3>References</h3>

<p>Abdulkadiroglu, A. and T. Sonmez (2003). School Choice: A Mechanism Design Approach. <em>American Economic Review</em>, 93 (3): 729-747.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-a. Compare example from the Abdulkadiroglu et al. (2003) (in the Appendix, page 742-744)
## 1-b. Generate matrix of students' preference rankings over schools, a.k.a. Rank Order Lists (ROL)
s.prefs &lt;- matrix(c(
                  2,1,3,4,
                  1,2,3,4,
                  3,2,1,4,
                  3,4,1,2,
                  1,3,4,2,
                  4,1,2,3,
                  1,2,3,4,
                  1,2,4,3),
                  byrow = FALSE, ncol = 8)

## 1-c. Generate matrix of schools' preference rankings over students, a.k.a. Rank Order Lists (ROL)
c.prefs &lt;- matrix(c(
                  1,2,3,4,5,6,7,8,
                  3,5,4,8,7,2,1,6,
                  5,3,1,7,2,8,6,4,
                  6,8,7,4,2,3,5,1),
                  byrow = FALSE, ncol = 4)

## 1-d. Generate capacities
nSlots &lt;- c(2,2,3,3)

## 1-e. Find assignment based on TTC algorithm
ttc2(s.prefs = s.prefs, c.prefs = c.prefs, nSlots = nSlots)

## 2-a. Generate college preferences with college 1 only ranking student 1
c.prefs &lt;- matrix(c(
                   1,rep(NA,7),
                   3,5,4,8,7,2,1,6,
                   5,3,1,7,2,8,6,4,
                   6,8,7,4,2,3,5,1),
                   byrow = FALSE, ncol = 4)

## 2-b. Find assignment based on TTC algorithm
ttc2(s.prefs = s.prefs, c.prefs = c.prefs, nSlots = nSlots, priority = 1:8)

## If all schools have the same preferences the two sided ttc and the serial dictator yield
## the same outcome if the preferences are taken to be the prioirty order for the serial dictator

# Preferences are the same for all schools:
c.prefs &lt;- matrix(c(
                  5,3,1,7,2,8,6,4,
                  5,3,1,7,2,8,6,4,
                  5,3,1,7,2,8,6,4,
                  5,3,1,7,2,8,6,4),
                  byrow = FALSE, ncol = 4)
priority &lt;- c.prefs[,1]

match_ttc &lt;- ttc2(s.prefs = s.prefs, c.prefs = c.prefs, nSlots = nSlots)
match_sd &lt;- rsd(prefs = s.prefs, priority = priority, nSlots = nSlots)
all(match_ttc == match_sd)
</code></pre>

<hr>
<h2 id='ttcc'>Top-Trading-Cycles and Chains Algorithm</h2><span id='topic+ttcc'></span>

<h3>Description</h3>

<p>Implements the Top Trading Cycle and Chains algorithm proposed by Roth et al. (2004) for the kidney exchange problem.
The algorithm requires a rule to determine which chain will be used if there is more than one possibility. The chosen rule is
to search for the longest chain and remove it from the problem (even the first kidney which was unassigned).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttcc(nPatients = ncol(prefs), prefs, priority = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttcc_+3A_npatients">nPatients</code></td>
<td>
<p>integer indicating the number of patient/donor-pairs in the matching problem. Defaults to  <code>ncol(prefs)</code>.</p>
</td></tr>
<tr><td><code id="ttcc_+3A_prefs">prefs</code></td>
<td>
<p>matrix of dimension (<code>nPatients</code> + 1) x <code>nPatients</code> with column j containg patients jth ranking over kidneys in decreasing order of preferences (i.e. most preferred first). An entry with value (<code>nPatients</code> +1) indicates that the patient prefers the waiting list to all kidney below in his ranking (therefore they do not matter and can be neglected/NA).</p>
</td></tr>
<tr><td><code id="ttcc_+3A_priority">priority</code></td>
<td>
<p>(Optional) vector of length <code>nStudents</code>. Gives the prioirity ordering of the students in the search for cycles (Do not confuse it with the preferences!), if nothing is specified a random ordering is chosen.</p>
</td></tr>
<tr><td><code id="ttcc_+3A_seed">seed</code></td>
<td>
<p>(Optional) integer setting the state for random number generation. Defaults to seed = NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ttcc</code> returns a list with the matching and a vector containing the patients who are assigned to the waiting list. The matching comprises a data frame of the operations to be performed between patient-donor pairs (ind-obj).
</p>


<h3>Author(s)</h3>

<p>Thilo Klein, Alexander Sauer
</p>


<h3>References</h3>

<p>Roth, A.; T. Sonmez; U. Unver (2004). Kidney Exchange. <em>Quarterly Journal of Economics</em>, 119 (2): 457-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare Example 1 from Roth et al. (2004) on page 469 - 475
## generate matrix of patients' preference rankings over kidneys, a.k.a. Rank Order Lists (ROL)

prefs &lt;- matrix(c( 9,10, 1,NA,NA,NA,NA,
                  11, 3, 5, 6, 2,NA,NA,
                   2, 4, 5, 6, 7, 8,13,
                   5, 9, 1, 8,10, 3,13,
                   3, 7,11, 4, 5,NA,NA,
                   3, 5, 8, 6,NA,NA,NA,
                   6, 1, 3, 9,10, 1,13,
                   6, 4,11, 2, 3, 8,NA,
                   3,11,13,NA,NA,NA,NA,
                  11, 1, 4, 5, 6, 7,13,
                   3, 6, 5,11,NA,NA,NA,
                  11, 3, 9, 8,10,12,NA),
              byrow = FALSE, ncol = 12)
priority &lt;- 1:12
ttcc(prefs = prefs, priority = priority)
## The final matching differs slightly because in Round 3 another chain is chosen due to a different
## decision rule (compare Figure 3, p472. Here W1 instead of W2 is chosen)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
