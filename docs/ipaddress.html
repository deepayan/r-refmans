<!DOCTYPE html><html><head><title>Help for package ipaddress</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ipaddress}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#address_in_network'><p>Network membership of addresses</p></a></li>
<li><a href='#collapse_networks'><p>Collapse contiguous and overlapping networks</p></a></li>
<li><a href='#common_network'><p>Find the common network of two addresses</p></a></li>
<li><a href='#country_networks'><p>Country-level IP networks</p></a></li>
<li><a href='#exclude_networks'><p>Remove networks from others</p></a></li>
<li><a href='#iana_ipv4'><p>IPv4 address space allocation</p></a></li>
<li><a href='#iana_ipv6'><p>IPv6 address space allocation</p></a></li>
<li><a href='#ip_address'><p>Vector of IP addresses</p></a></li>
<li><a href='#ip_cast'><p>Cast to IP vector</p></a></li>
<li><a href='#ip_format'><p>Format IP vector</p></a></li>
<li><a href='#ip_interface'><p>Vector of IP interfaces</p></a></li>
<li><a href='#ip_network'><p>Vector of IP networks</p></a></li>
<li><a href='#ip_operators'><p>Operators for IP addresses</p></a></li>
<li><a href='#ip_test'><p>Test for IP vector</p></a></li>
<li><a href='#ip_to_binary'><p>Represent address as binary</p></a></li>
<li><a href='#ip_to_bytes'><p>Represent address as raw bytes</p></a></li>
<li><a href='#ip_to_hex'><p>Represent address as hexadecimal</p></a></li>
<li><a href='#ip_to_hostname'><p>Translate address to/from hostname</p></a></li>
<li><a href='#ip_to_integer'><p>Represent address as integer</p></a></li>
<li><a href='#ipaddress-package'><p>ipaddress: Data Analysis for IP Addresses and Networks</p></a></li>
<li><a href='#ipaddress-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#ipv6-transition'><p>IPv6 transition mechanisms</p></a></li>
<li><a href='#is_ipv6'><p>Version of the address space</p></a></li>
<li><a href='#is_reserved'><p>Reserved addresses</p></a></li>
<li><a href='#max_prefix_length'><p>Size of the address space</p></a></li>
<li><a href='#netmask'><p>Network mask</p></a></li>
<li><a href='#network_in_network'><p>Network membership of other networks</p></a></li>
<li><a href='#network_size'><p>Network size</p></a></li>
<li><a href='#reverse_pointer'><p>Reverse DNS pointer</p></a></li>
<li><a href='#sample'><p>Sample random addresses</p></a></li>
<li><a href='#sequence'><p>List addresses within a network</p></a></li>
<li><a href='#summarize_address_range'><p>List constituent networks of an address range</p></a></li>
<li><a href='#traverse_hierarchy'><p>Traverse the network hierarchy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Data Analysis for IP Addresses and Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and functions for working with IP (Internet Protocol)
    addresses and networks, inspired by the Python 'ipaddress' module.
    Offers full support for both IPv4 and IPv6 (Internet Protocol versions
    4 and 6) address spaces. It is specifically designed to work well with
    the 'tidyverse'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidchall.github.io/ipaddress/">https://davidchall.github.io/ipaddress/</a>,
<a href="https://github.com/davidchall/ipaddress">https://github.com/davidchall/ipaddress</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidchall/ipaddress/issues">https://github.com/davidchall/ipaddress/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), Rcpp, rlang (&ge; 1.0.3), vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bignum, blob, crayon, dplyr, fuzzyjoin, knitr, pillar,
rmarkdown, testthat, tibble, tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>AsioHeaders, Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 16:30:34 UTC; davidhall</td>
</tr>
<tr>
<td>Author:</td>
<td>David Hall <a href="https://orcid.org/0000-0002-2193-0480"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Hall &lt;david.hall.physics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='address_in_network'>Network membership of addresses</h2><span id='topic+address_in_network'></span><span id='topic+is_within'></span><span id='topic+is_within_any'></span>

<h3>Description</h3>

<p>These functions check whether an address falls within a network.
</p>
<p><code>is_within()</code> performs a one-to-one matching between addresses and networks.
</p>
<p><code>is_within_any()</code> checks if each address falls within <em>any</em> of the networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_within(address, network)

is_within_any(address, network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="address_in_network_+3A_address">address</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="address_in_network_+3A_network">network</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+is_subnet">is_subnet()</a></code> to check if an <code><a href="#topic+ip_network">ip_network</a></code> is within another
<code><a href="#topic+ip_network">ip_network</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_within(ip_address("192.168.2.6"), ip_network("192.168.2.0/28"))

is_within(ip_address("192.168.3.6"), ip_network("192.168.2.0/28"))

is_within_any(ip_address("192.168.3.6"), ip_network(c("192.168.2.0/28", "192.168.3.0/28")))
</code></pre>

<hr>
<h2 id='collapse_networks'>Collapse contiguous and overlapping networks</h2><span id='topic+collapse_networks'></span>

<h3>Description</h3>

<p>Given a vector of networks, this returns the minimal set of networks required
to represent the same range of addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_networks(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_networks_+3A_network">network</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector (potentially shorter than the input)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exclude_networks">exclude_networks()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collapse_networks(ip_network(c("192.168.0.0/24", "192.168.1.0/24")))
</code></pre>

<hr>
<h2 id='common_network'>Find the common network of two addresses</h2><span id='topic+common_network'></span>

<h3>Description</h3>

<p>Returns the smallest network that contains both addresses.
</p>
<p>This can construct a network from its first and last addresses. However, if
the address range does not match the network boundaries, then the result
extends beyond the original address range. Use <code><a href="#topic+summarize_address_range">summarize_address_range()</a></code>
to receive a list of networks that exactly match the address range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_network(address1, address2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_network_+3A_address1">address1</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="common_network_+3A_address2">address2</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarize_address_range">summarize_address_range()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># address range matches network boundaries
common_network(ip_address("192.168.0.0"), ip_address("192.168.0.15"))

# address range does not match network boundaries
common_network(ip_address("192.167.255.255"), ip_address("192.168.0.16"))
</code></pre>

<hr>
<h2 id='country_networks'>Country-level IP networks</h2><span id='topic+country_networks'></span>

<h3>Description</h3>

<p>Retrieve lists of IP networks registered to specific countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_networks(country, ..., collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="country_networks_+3A_country">country</code></td>
<td>
<p>Character vector of two-letter country codes (ISO 3166-1 alpha-2)</p>
</td></tr>
<tr><td><code id="country_networks_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="country_networks_+3A_collapse">collapse</code></td>
<td>
<p>If <code>TRUE</code> (the default), contiguous networks are collapsed.
See <code><a href="#topic+collapse_networks">collapse_networks()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires an internet connection to download network lists.
</p>


<h3>Value</h3>

<p>A data frame with 2 variables:
</p>

<ul>
<li> <p><code>country</code>: A character vector
</p>
</li>
<li> <p><code>network</code>: A list of <code><a href="#topic+ip_network">ip_network</a></code> vectors
</p>
</li></ul>

<p>Each row represents a single country associated with a vector of IP networks.
</p>


<h3>Source</h3>

<p><a href="https://www.iwik.org/ipcountry/">https://www.iwik.org/ipcountry/</a> (updated daily)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
country_networks(c("GB", "US"))

country_networks(c("GB", "US"), collapse = FALSE)

# retrieve networks for a single country
country_networks("TO")$networks[[1]]

# expand networks for multiple countries
tidyr::unchop(country_networks(c("GB", "US")), networks)

## End(Not run)
</code></pre>

<hr>
<h2 id='exclude_networks'>Remove networks from others</h2><span id='topic+exclude_networks'></span>

<h3>Description</h3>

<p><code>exclude_networks()</code> takes lists of networks to include and exclude. It then
calculates the address ranges that are included but not excluded (similar to
<code><a href="base.html#topic+setdiff">setdiff()</a></code>), and finally returns the minimal set of networks needed to
describe the remaining address ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude_networks(include, exclude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclude_networks_+3A_include">include</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
<tr><td><code id="exclude_networks_+3A_exclude">exclude</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse_networks">collapse_networks()</a></code>, <code><a href="base.html#topic+setdiff">setdiff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exclude_networks(ip_network("192.0.2.0/28"), ip_network("192.0.2.1/32"))

exclude_networks(ip_network("192.0.2.0/28"), ip_network("192.0.2.15/32"))
</code></pre>

<hr>
<h2 id='iana_ipv4'>IPv4 address space allocation</h2><span id='topic+iana_ipv4'></span>

<h3>Description</h3>

<p>A dataset containing the registry of allocated blocks in IPv4 address space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iana_ipv4
</code></pre>


<h3>Format</h3>

<p>A data frame with 121 rows and 3 variables:
</p>

<dl>
<dt>network</dt><dd><p>Address block (an <code><a href="#topic+ip_network">ip_network</a></code> vector)</p>
</dd>
<dt>allocation</dt><dd><p>There are three types of allocation:
</p>

<ul>
<li><p> reserved
</p>
</li>
<li><p> managed by regional Internet registry (RIR)
</p>
</li>
<li><p> assigned to organization
</p>
</li></ul>

</dd>
<dt>label</dt><dd><p>The RIR, organization or purpose for reservation</p>
</dd>
</dl>



<h3>Note</h3>

<p>Last updated 2022-12-12
</p>


<h3>Source</h3>

<p><a href="https://www.iana.org/assignments/ipv4-address-space">https://www.iana.org/assignments/ipv4-address-space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_reserved">is_reserved()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iana_ipv4
</code></pre>

<hr>
<h2 id='iana_ipv6'>IPv6 address space allocation</h2><span id='topic+iana_ipv6'></span>

<h3>Description</h3>

<p>A dataset containing the registry of allocated blocks in IPv6 address space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iana_ipv6
</code></pre>


<h3>Format</h3>

<p>A data frame with 47 rows and 3 variables:
</p>

<dl>
<dt>network</dt><dd><p>Address block (an <code><a href="#topic+ip_network">ip_network</a></code> vector)</p>
</dd>
<dt>allocation</dt><dd><p>There are two types of allocation:
</p>

<ul>
<li><p> reserved
</p>
</li>
<li><p> managed by regional Internet registry (RIR)
</p>
</li></ul>

</dd>
<dt>label</dt><dd><p>The RIR or purpose for reservation</p>
</dd>
</dl>



<h3>Note</h3>

<p>Last updated 2020-08-18
</p>


<h3>Source</h3>

<p><a href="https://www.iana.org/assignments/ipv6-address-space">https://www.iana.org/assignments/ipv6-address-space</a>
</p>
<p><a href="https://www.iana.org/assignments/ipv6-unicast-address-assignments">https://www.iana.org/assignments/ipv6-unicast-address-assignments</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_reserved">is_reserved()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iana_ipv6
</code></pre>

<hr>
<h2 id='ip_address'>Vector of IP addresses</h2><span id='topic+ip_address'></span>

<h3>Description</h3>

<p>Construct a vector of IP addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_address(x = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_address_+3A_x">x</code></td>
<td>
<p>A character vector of IP addresses, in dot-decimal notation (IPv4)
or hexadecimal notation (IPv6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An address in IPv4 space uses 32-bits. It is usually represented
as 4 groups of 8 bits, each shown as decimal digits (e.g. <code style="white-space: pre;">&#8288;192.168.0.1&#8288;</code>).
This is known as dot-decimal notation.
</p>
<p>An address in IPv6 space uses 128-bits. It is usually represented
as 8 groups of 16 bits, each shown as hexadecimal digits
(e.g. <code style="white-space: pre;">&#8288;2001:0db8:85a3:0000:0000:8a2e:0370:7334&#8288;</code>). This representation can
also be compressed by removing leading zeros and replacing consecutive
groups of zeros with double-colon (e.g. <code style="white-space: pre;">&#8288;2001:db8:85a3::8a2e:370:7334&#8288;</code>).
Finally, there is also the dual representation. This expresses the final
two groups as an IPv4 address (e.g. <code style="white-space: pre;">&#8288;2001:db8:85a3::8a2e:3.112.115.52&#8288;</code>).
</p>
<p>The <code>ip_address()</code> constructor accepts a character vector of IP addresses
in these two formats. It checks whether each string is a valid IPv4 or IPv6
address, and converts it to an <code>ip_address</code> object. If the input is invalid,
a warning is emitted and <code>NA</code> is stored instead.
</p>
<p>When casting an <code>ip_address</code> object back to a character vector using
<code>as.character()</code>, IPv6 addresses are reduced to their compressed representation.
A special case is IPv4-mapped IPv6 addresses (see <code><a href="#topic+is_ipv4_mapped">is_ipv4_mapped()</a></code>), which
are returned in the dual representation (e.g. <code style="white-space: pre;">&#8288;::ffff:192.168.0.1&#8288;</code>).
</p>
<p><code>ip_address</code> vectors support a number of <a href="#topic+ip_operators">operators</a>.
</p>


<h3>Value</h3>

<p>An S3 vector of class <code>ip_address</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ip_operators">ip_operators</a></code>, <code>vignette("ip-data")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># supports IPv4 and IPv6 simultaneously
ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334"))

# validates inputs and replaces with NA
ip_address(c("255.255.255.256", "192.168.0.1/32"))
</code></pre>

<hr>
<h2 id='ip_cast'>Cast to IP vector</h2><span id='topic+ip_cast'></span><span id='topic+as_ip_address'></span><span id='topic+as_ip_interface'></span><span id='topic+as_ip_network'></span>

<h3>Description</h3>

<p>Methods for converting character vectors and <code><a href="#topic+ip_interface">ip_interface</a></code> vectors to
<code><a href="#topic+ip_address">ip_address</a></code> and <code><a href="#topic+ip_network">ip_network</a></code> vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ip_address(x)

as_ip_interface(x)

as_ip_network(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_cast_+3A_x">x</code></td>
<td>
<p>An object to cast</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>as_ip_address()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>as_ip_network()</code>: An <code><a href="#topic+ip_network">ip_network</a></code> vector
</p>
</li>
<li> <p><code>as_ip_interface()</code>: An <code><a href="#topic+ip_interface">ip_interface</a></code> vector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>as_ip_address(ip_interface("192.168.0.1/10"))

as_ip_network(ip_interface("192.168.0.1/10"))
</code></pre>

<hr>
<h2 id='ip_format'>Format IP vector</h2><span id='topic+ip_format'></span><span id='topic+format.ip_address'></span><span id='topic+format.ip_interface'></span><span id='topic+format.ip_network'></span>

<h3>Description</h3>

<p>Format vector of IP data using compressed or exploded representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ip_address'
format(x, ..., exploded = FALSE)

## S3 method for class 'ip_interface'
format(x, ..., exploded = FALSE)

## S3 method for class 'ip_network'
format(x, ..., exploded = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_format_+3A_x">x</code></td>
<td>
<p>An object to format</p>
</td></tr>
<tr><td><code id="ip_format_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="ip_format_+3A_exploded">exploded</code></td>
<td>
<p>Logical scalar. Should IPv6 addresses display leading zeros?
(default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format(ip_address("2001:db8::8a2e:370:7334"))

format(ip_address("2001:db8::8a2e:370:7334"), exploded = TRUE)
</code></pre>

<hr>
<h2 id='ip_interface'>Vector of IP interfaces</h2><span id='topic+ip_interface'></span><span id='topic+ip_interface.default'></span><span id='topic+ip_interface.ip_address'></span>

<h3>Description</h3>

<p>Construct a vector of IP interfaces.
</p>
<p>This hybrid class stores both the host address and the network it is on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_interface(...)

## Default S3 method:
ip_interface(x = character(), ...)

## S3 method for class 'ip_address'
ip_interface(address, prefix_length, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_interface_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ip_interface_+3A_x">x</code></td>
<td>
<p>A character vector of IP interfaces, in CIDR notation (IPv4 or IPv6)</p>
</td></tr>
<tr><td><code id="ip_interface_+3A_address">address</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="ip_interface_+3A_prefix_length">prefix_length</code></td>
<td>
<p>An integer vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructing an <code>ip_interface</code> vector is conceptually like constructing an
<code><a href="#topic+ip_network">ip_network</a></code> vector, except the host bits are retained.
</p>
<p>The <code>ip_interface</code> class inherits from the <code><a href="#topic+ip_address">ip_address</a></code> class.
This means it can generally be used in places where an <code><a href="#topic+ip_address">ip_address</a></code>
vector is expected. A few exceptions to this rule are:
</p>

<ul>
<li><p> It does not support addition and subtraction of integers
</p>
</li>
<li><p> It does not support bitwise operations
</p>
</li>
<li><p> It cannot be compared to <code><a href="#topic+ip_address">ip_address</a></code> vectors
</p>
</li></ul>

<p>The <code>ip_interface</code> class additionally supports a few functions typically
reserved for <code><a href="#topic+ip_network">ip_network</a></code> vectors: <code><a href="#topic+prefix_length">prefix_length()</a></code>, <code><a href="#topic+netmask">netmask()</a></code> and
<code><a href="#topic+hostmask">hostmask()</a></code>.
</p>
<p>For other purposes, you can extract the address and network components using
<code><a href="#topic+as_ip_address">as_ip_address()</a></code> and <code><a href="#topic+as_ip_network">as_ip_network()</a></code>.
</p>
<p>When comparing and sorting <code>ip_interface</code> vectors, the network is compared
before the host address.
</p>


<h3>Value</h3>

<p>An S3 vector of class <code>ip_interface</code>
</p>


<h3>See Also</h3>

<p><code>vignette("ip-data")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct from character vector
ip_interface(c("192.168.0.1/10", "2001:db8:c3::abcd/45"))

# construct from address + prefix length objects
ip_interface(ip_address(c("192.168.0.1", "2001:db8:c3::abcd")), c(10L, 45L))

# extract IP address
x &lt;- ip_interface(c("192.168.0.1/10", "2001:db8:c3::abcd/45"))
as_ip_address(x)

# extract IP network (with host bits masked)
as_ip_network(x)
</code></pre>

<hr>
<h2 id='ip_network'>Vector of IP networks</h2><span id='topic+ip_network'></span><span id='topic+ip_network.default'></span><span id='topic+ip_network.ip_address'></span>

<h3>Description</h3>

<p>Construct a vector of IP networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_network(...)

## Default S3 method:
ip_network(x = character(), ..., strict = TRUE)

## S3 method for class 'ip_address'
ip_network(address, prefix_length, ..., strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_network_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ip_network_+3A_x">x</code></td>
<td>
<p>A character vector of IP networks, in CIDR notation (IPv4 or IPv6)</p>
</td></tr>
<tr><td><code id="ip_network_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code> (the default) and the input has host bits set,
then a warning is emitted and <code>NA</code> is returned. If <code>FALSE</code>, the
host bits are set to zero and a valid IP network is returned. If you need
to retain the host bits, consider using <code><a href="#topic+ip_interface">ip_interface()</a></code> instead.</p>
</td></tr>
<tr><td><code id="ip_network_+3A_address">address</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="ip_network_+3A_prefix_length">prefix_length</code></td>
<td>
<p>An integer vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An IP network corresponds to a contiguous range of IP addresses
(also known as an IP block). CIDR notation represents an
IP network as the routing prefix address (which denotes the start
of the range) and the prefix length (which indicates the size of
the range) separated by a forward slash. For example, <code style="white-space: pre;">&#8288;192.168.0.0/24&#8288;</code>
represents addresses from <code style="white-space: pre;">&#8288;192.168.0.0&#8288;</code> to <code style="white-space: pre;">&#8288;192.168.0.255&#8288;</code>.
</p>
<p>The prefix length indicates the number of bits reserved by the
routing prefix. This means that larger prefix lengths indicate
smaller networks. The maximum prefix length is 32 for IPv4 and
128 for IPv6. These would correspond to an IP network of a single
IP address.
</p>
<p>The <code>ip_network()</code> constructor accepts a character vector of IP networks
in CIDR notation. It checks whether each string is a valid IPv4 or IPv6
network, and converts it to an <code>ip_network</code> object. If the input is invalid,
a warning is emitted and <code>NA</code> is stored instead.
</p>
<p>An alternative constructor accepts an <code><a href="#topic+ip_address">ip_address</a></code> vector and an
integer vector containing the network address and prefix length, respectively.
</p>
<p>When casting an <code>ip_network</code> object back to a character vector using
<code>as.character()</code>, IPv6 addresses are reduced to their compressed representation.
</p>
<p>When comparing and sorting <code>ip_network</code> vectors, the network address is
compared before the prefix length.
</p>


<h3>Value</h3>

<p>An S3 vector of class <code>ip_network</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prefix_length">prefix_length()</a></code>, <code><a href="#topic+network_address">network_address()</a></code>, <code><a href="#topic+netmask">netmask()</a></code>, <code><a href="#topic+hostmask">hostmask()</a></code>
</p>
<p><code>vignette("ip-data")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct from character vector
ip_network(c("192.168.0.0/24", "2001:db8::/48"))

# validates inputs and replaces with NA
ip_network(c("192.168.0.0/33", "192.168.0.0"))

# IP networks should not have any host bits set
ip_network("192.168.0.1/22")

# but we can mask the host bits if desired
ip_network("192.168.0.1/22", strict = FALSE)

# construct from address + prefix length
ip_network(ip_address("192.168.0.0"), 24L)

# construct from address + netmask
ip_network(ip_address("192.168.0.0"), prefix_length(ip_address("255.255.255.0")))

# construct from address + hostmask
ip_network(ip_address("192.168.0.0"), prefix_length(ip_address("0.0.0.255")))
</code></pre>

<hr>
<h2 id='ip_operators'>Operators for IP addresses</h2><span id='topic+ip_operators'></span><span id='topic++25+3C+3C+25'></span><span id='topic++25+3E+3E+25'></span>

<h3>Description</h3>

<p><code><a href="#topic+ip_address">ip_address</a></code> vectors support the following operators:
</p>

<ul>
<li><p> bitwise logic operators: <code>!</code> (NOT), <code>&amp;</code> (AND), <code>|</code> (OR), <code>^</code> (XOR)
</p>
</li>
<li><p> bitwise shift operators: <code style="white-space: pre;">&#8288;%&lt;&lt;%&#8288;</code> (left shift), <code style="white-space: pre;">&#8288;%&gt;&gt;%&#8288;</code> (right shift)
</p>
</li>
<li><p> arithmetic operators: <code>+</code> (addition), <code>-</code> (subtraction)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># use ip_to_binary() to understand these examples better

# bitwise NOT
!ip_address("192.168.0.1")

# bitwise AND
ip_address("192.168.0.1") &amp; ip_address("255.0.0.255")

# bitwise OR
ip_address("192.168.0.0") | ip_address("255.0.0.255")

# bitwise XOR
ip_address("192.168.0.0") ^ ip_address("255.0.0.255")

# bitwise shift left
ip_address("192.168.0.1") %&lt;&lt;% 1

# bitwise shift right
ip_address("192.168.0.1") %&gt;&gt;% 1

# addition of integers
ip_address("192.168.0.1") + 10

# subtraction of integers
ip_address("192.168.0.1") - 10
</code></pre>

<hr>
<h2 id='ip_test'>Test for IP vector</h2><span id='topic+ip_test'></span><span id='topic+is_ip_address'></span><span id='topic+is_ip_interface'></span><span id='topic+is_ip_network'></span>

<h3>Description</h3>

<p>Check if an object is an <code><a href="#topic+ip_address">ip_address</a></code>, <code><a href="#topic+ip_network">ip_network</a></code> or <code><a href="#topic+ip_interface">ip_interface</a></code>
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ip_address(x)

is_ip_interface(x)

is_ip_network(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_test_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_ip_address(ip_address("192.168.0.1"))
is_ip_interface(ip_interface("192.168.0.1/10"))
is_ip_network(ip_network("192.168.0.0/24"))
</code></pre>

<hr>
<h2 id='ip_to_binary'>Represent address as binary</h2><span id='topic+ip_to_binary'></span><span id='topic+binary_to_ip'></span>

<h3>Description</h3>

<p>Encode or decode an <code><a href="#topic+ip_address">ip_address</a></code> as a binary bit string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_to_binary(x)

binary_to_ip(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_to_binary_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>ip_to_binary()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>binary_to_ip()</code>: A character vector containing only <code>0</code> and <code>1</code> characters
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The bits are stored in network order (also known as big-endian order), which
is part of the IP standard.
</p>
<p>IPv4 addresses use 32 bits, IPv6 addresses use 128 bits, and missing values
are encoded as <code>NA</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ip_to_binary()</code>: A character vector
</p>
</li>
<li> <p><code>binary_to_ip()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>See Also</h3>

<p>Other address representations: 
<code><a href="#topic+ip_to_bytes">ip_to_bytes</a>()</code>,
<code><a href="#topic+ip_to_hex">ip_to_hex</a>()</code>,
<code><a href="#topic+ip_to_integer">ip_to_integer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334", NA))
ip_to_binary(x)

binary_to_ip(ip_to_binary(x))
</code></pre>

<hr>
<h2 id='ip_to_bytes'>Represent address as raw bytes</h2><span id='topic+ip_to_bytes'></span><span id='topic+bytes_to_ip'></span>

<h3>Description</h3>

<p>Encode or decode an <code><a href="#topic+ip_address">ip_address</a></code> as a list of raw bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_to_bytes(x)

bytes_to_ip(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_to_bytes_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>ip_to_bytes()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>bytes_to_ip()</code>: A list of raw vectors or a <code><a href="blob.html#topic+blob">blob::blob</a></code> object
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The bytes are stored in network order (also known as
big-endian order), which is part of the IP standard.
</p>
<p>IPv4 addresses use 4 bytes, IPv6 addresses use 16 bytes,
and missing values are encoded as <code>NULL</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ip_to_bytes()</code>: A list of raw vectors
</p>
</li>
<li> <p><code>bytes_to_ip()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>See Also</h3>

<p>Use <code><a href="blob.html#topic+blob">blob::as_blob()</a></code> to cast result to a blob object
</p>
<p>Other address representations: 
<code><a href="#topic+ip_to_binary">ip_to_binary</a>()</code>,
<code><a href="#topic+ip_to_hex">ip_to_hex</a>()</code>,
<code><a href="#topic+ip_to_integer">ip_to_integer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334", NA))
ip_to_bytes(x)

bytes &lt;- list(
  as.raw(c(0xc0, 0xa8, 0x00, 0x01)),
  as.raw(c(
    0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x8a, 0x2e, 0x03, 0x70, 0x73, 0x34
  )),
  NULL
)
bytes_to_ip(bytes)
</code></pre>

<hr>
<h2 id='ip_to_hex'>Represent address as hexadecimal</h2><span id='topic+ip_to_hex'></span><span id='topic+hex_to_ip'></span>

<h3>Description</h3>

<p>Encode or decode an <code><a href="#topic+ip_address">ip_address</a></code> as a hexadecimal string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_to_hex(x)

hex_to_ip(x, is_ipv6 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_to_hex_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>ip_to_hex()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>hex_to_ip()</code>: A character vector containing hexadecimal strings
</p>
</li></ul>
</td></tr>
<tr><td><code id="ip_to_hex_+3A_is_ipv6">is_ipv6</code></td>
<td>
<p>A logical vector indicating whether to construct an IPv4 or
IPv6 address. If <code>NULL</code> (the default), then IPv4 is preferred but an IPv6
address is constructed when <code>x</code> is too large for the IPv4 address space.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ip_to_hex()</code>: A character vector
</p>
</li>
<li> <p><code>hex_to_ip()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>See Also</h3>

<p>Other address representations: 
<code><a href="#topic+ip_to_binary">ip_to_binary</a>()</code>,
<code><a href="#topic+ip_to_bytes">ip_to_bytes</a>()</code>,
<code><a href="#topic+ip_to_integer">ip_to_integer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334", NA))
ip_to_hex(x)

hex_to_ip(ip_to_hex(x))
</code></pre>

<hr>
<h2 id='ip_to_hostname'>Translate address to/from hostname</h2><span id='topic+ip_to_hostname'></span><span id='topic+ip_to_hostname_all'></span><span id='topic+hostname_to_ip'></span><span id='topic+hostname_to_ip_all'></span>

<h3>Description</h3>

<p>Perform reverse and forward DNS resolution.
</p>
<p><strong>Note:</strong> These functions are significantly slower than others in the
ipaddress package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_to_hostname(x)

ip_to_hostname_all(x)

hostname_to_ip(x)

hostname_to_ip_all(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_to_hostname_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>ip_to_hostname()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>hostname_to_ip()</code>: A character vector of hostnames
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions require an internet connection. Before processing the input
vector, we first check that a known hostname can be resolved. If this fails,
an error is raised.
</p>
<p>If DNS lookup cannot resolve an input, then <code>NA</code> is returned for that input.
If an error occurs during DNS lookup, then a warning is emitted and <code>NA</code> is
returned for that input.
</p>
<p>DNS resolution performs a many-to-many mapping between IP addresses and
hostnames. For this reason, there are two versions of each function. The
regular version returns just the first value and the <code style="white-space: pre;">&#8288;_all()&#8288;</code> suffix version
returns all values.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ip_to_hostname()</code>: A character vector
</p>
</li>
<li> <p><code>ip_to_hostname_all()</code>: A list of character vectors
</p>
</li>
<li> <p><code>hostname_to_ip()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>hostname_to_ip_all()</code>: A list of <code><a href="#topic+ip_address">ip_address</a></code> vectors
</p>
</li></ul>



<h3>See Also</h3>

<p>The base function <code>nsl()</code> provides forward DNS resolution to IPv4 addresses,
but only on Unix-like systems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hostname_to_ip("r-project.org")

ip_to_hostname(hostname_to_ip("r-project.org"))

## End(Not run)
</code></pre>

<hr>
<h2 id='ip_to_integer'>Represent address as integer</h2><span id='topic+ip_to_integer'></span><span id='topic+integer_to_ip'></span>

<h3>Description</h3>

<p>Encode or decode an <code><a href="#topic+ip_address">ip_address</a></code> as an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_to_integer(x)

integer_to_ip(x, is_ipv6 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_to_integer_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>ip_to_integer()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>integer_to_ip()</code>: A <code><a href="bignum.html#topic+biginteger">bignum::biginteger</a></code> vector
</p>
</li></ul>
</td></tr>
<tr><td><code id="ip_to_integer_+3A_is_ipv6">is_ipv6</code></td>
<td>
<p>A logical vector indicating whether to construct an IPv4 or
IPv6 address. If <code>NULL</code> (the default), then IPv4 is preferred but an IPv6
address is constructed when <code>x</code> is too large for the IPv4 address space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is common to represent an IP address as an integer, by reinterpreting
the bit sequence as a big-endian unsigned integer. This means IPv4 and IPv6
addresses can be represented by 32-bit and 128-bit unsigned integers.
In this way, the IPv4 addresses <code style="white-space: pre;">&#8288;0.0.0.0&#8288;</code> and <code style="white-space: pre;">&#8288;255.255.255.255&#8288;</code> would be
represented as 0 and 4,294,967,295.
</p>
<p>The numeric data types within base R (<code><a href="base.html#topic+integer">integer</a></code> and <code><a href="base.html#topic+double">double</a></code>) have
insufficient precision to cover the IPv6 address space. Instead we return a
<code><a href="bignum.html#topic+biginteger">bignum::biginteger</a></code> vector, which supports arbitrary precision integers.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ip_to_integer()</code>: A <code><a href="bignum.html#topic+biginteger">bignum::biginteger</a></code> vector
</p>
</li>
<li> <p><code>integer_to_ip()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>See Also</h3>

<p>Other address representations: 
<code><a href="#topic+ip_to_binary">ip_to_binary</a>()</code>,
<code><a href="#topic+ip_to_bytes">ip_to_bytes</a>()</code>,
<code><a href="#topic+ip_to_hex">ip_to_hex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334", NA))
ip_to_integer(x)

integer_to_ip(ip_to_integer(x))

# with IPv4 only, we can use numeric data type
as.numeric(ip_to_integer(ip_address("192.168.0.1")))

integer_to_ip(3232235521)
</code></pre>

<hr>
<h2 id='ipaddress-package'>ipaddress: Data Analysis for IP Addresses and Networks</h2><span id='topic+ipaddress'></span><span id='topic+ipaddress-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Classes and functions for working with IP (Internet Protocol) addresses and networks, inspired by the Python 'ipaddress' module. Offers full support for both IPv4 and IPv6 (Internet Protocol versions 4 and 6) address spaces. It is specifically designed to work well with the 'tidyverse'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Hall <a href="mailto:david.hall.physics@gmail.com">david.hall.physics@gmail.com</a> (<a href="https://orcid.org/0000-0002-2193-0480">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://davidchall.github.io/ipaddress/">https://davidchall.github.io/ipaddress/</a>
</p>
</li>
<li> <p><a href="https://github.com/davidchall/ipaddress">https://github.com/davidchall/ipaddress</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/davidchall/ipaddress/issues">https://github.com/davidchall/ipaddress/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ipaddress-vctrs'>Internal vctrs methods</h2><span id='topic+ipaddress-vctrs'></span><span id='topic+vec_arith.ip_address'></span><span id='topic+vec_arith.ip_interface'></span>

<h3>Description</h3>

<p>Internal vctrs methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ip_address'
vec_arith(op, x, y, ...)

## S3 method for class 'ip_interface'
vec_arith(op, x, y, ...)
</code></pre>

<hr>
<h2 id='ipv6-transition'>IPv6 transition mechanisms</h2><span id='topic+ipv6-transition'></span><span id='topic+is_ipv4_mapped'></span><span id='topic+is_6to4'></span><span id='topic+is_teredo'></span><span id='topic+extract_ipv4_mapped'></span><span id='topic+extract_6to4'></span><span id='topic+extract_teredo_server'></span><span id='topic+extract_teredo_client'></span>

<h3>Description</h3>

<p>There are multiple mechanisms designed to help with the transition
from IPv4 to IPv6. These functions make it possible to extract the
embedded IPv4 address from an IPv6 address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ipv4_mapped(x)

is_6to4(x)

is_teredo(x)

extract_ipv4_mapped(x)

extract_6to4(x)

extract_teredo_server(x)

extract_teredo_client(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipv6-transition_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IPv6 transition mechanisms are described in the IETF memos:
</p>

<ul>
<li><p> IPv4-mapped: <a href="https://www.rfc-editor.org/rfc/rfc4291">RFC 4291</a>
</p>
</li>
<li><p> 6to4: <a href="https://www.rfc-editor.org/rfc/rfc3056">RFC 3056</a>
</p>
</li>
<li><p> Teredo: <a href="https://www.rfc-editor.org/rfc/rfc4380">RFC 4380</a>
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>is_xxx()</code>: A logical vector
</p>
</li>
<li> <p><code>extract_xxx()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># these examples show the reserved networks
is_ipv4_mapped(ip_network("::ffff:0.0.0.0/96"))

is_6to4(ip_network("2002::/16"))

is_teredo(ip_network("2001::/32"))

# these examples show embedded IPv4 addresses
extract_ipv4_mapped(ip_address("::ffff:192.168.0.1"))

extract_6to4(ip_address("2002:c000:0204::"))

extract_teredo_server(ip_address("2001:0000:4136:e378:8000:63bf:3fff:fdd2"))

extract_teredo_client(ip_address("2001:0000:4136:e378:8000:63bf:3fff:fdd2"))
</code></pre>

<hr>
<h2 id='is_ipv6'>Version of the address space</h2><span id='topic+is_ipv6'></span><span id='topic+is_ipv4'></span>

<h3>Description</h3>

<p>Version of the address space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ipv4(x)

is_ipv6(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_ipv6_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> or <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+max_prefix_length">max_prefix_length()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ip &lt;- ip_address(c("192.168.0.1", "2001:db8::7334"))

is_ipv4(ip)

is_ipv6(ip)
</code></pre>

<hr>
<h2 id='is_reserved'>Reserved addresses</h2><span id='topic+is_reserved'></span><span id='topic+is_private'></span><span id='topic+is_global'></span><span id='topic+is_multicast'></span><span id='topic+is_unspecified'></span><span id='topic+is_loopback'></span><span id='topic+is_link_local'></span><span id='topic+is_site_local'></span>

<h3>Description</h3>

<p>Most of these functions check if an address or network is reserved for
special use. The exception is <code>is_global()</code>, which checks if it is <em>not</em>
reserved.
</p>
<p>A network is considered reserved if both the <code>network_address()</code>
and <code>broadcast_address()</code> are reserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_private(x)

is_global(x)

is_multicast(x)

is_unspecified(x)

is_reserved(x)

is_loopback(x)

is_link_local(x)

is_site_local(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_reserved_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> or <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here are hyperlinks to the IANA registries of allocated address space:
</p>

<ul>
<li> <p><strong>IPv4:</strong>
<a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml">allocations</a>,
<a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">special purpose</a>
</p>
</li>
<li> <p><strong>IPv6:</strong>
<a href="https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml">allocations</a>,
<a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">special purpose</a>
</p>
</li></ul>



<h3>Value</h3>

<p>A logical vector
</p>


<h3>See Also</h3>

<p>Addresses reserved by IPv6 transition mechanisms can be identified
by functions described in <a href="#topic+ipv6-transition">ipv6-transition</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_private(ip_network(c("192.168.0.0/16", "2001:db8::/32")))

is_global(ip_network(c("1.0.0.0/8", "2002::/32")))

is_multicast(ip_network(c("224.0.0.0/4", "ff00::/8")))

is_unspecified(ip_network(c("0.0.0.0/32", "::/128")))

is_reserved(ip_network(c("240.0.0.0/4", "f000::/5")))

is_loopback(ip_network(c("127.0.0.0/8", "::1/128")))

is_link_local(ip_network(c("169.254.0.0/16", "fe80::/10")))

is_site_local(ip_network("fec0::/10"))
</code></pre>

<hr>
<h2 id='max_prefix_length'>Size of the address space</h2><span id='topic+max_prefix_length'></span>

<h3>Description</h3>

<p>The total number of bits available in the address space. IPv4 uses
32-bit addresses and IPv6 uses 128-bit addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_prefix_length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_prefix_length_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> or <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_ipv4">is_ipv4()</a></code>, <code><a href="#topic+is_ipv6">is_ipv6()</a></code>, <code><a href="#topic+prefix_length">prefix_length()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_address(c("192.168.0.1", "2001:db8::7334"))

max_prefix_length(x)
</code></pre>

<hr>
<h2 id='netmask'>Network mask</h2><span id='topic+netmask'></span><span id='topic+prefix_length'></span><span id='topic+netmask.numeric'></span><span id='topic+hostmask'></span><span id='topic+hostmask.numeric'></span>

<h3>Description</h3>

<p><code>prefix_length()</code>, <code>netmask()</code> and <code>hostmask()</code> extract different (but
equivalent) representations of the network mask. They accept an
<code><a href="#topic+ip_network">ip_network</a></code> or <code><a href="#topic+ip_interface">ip_interface</a></code> vector.
</p>
<p>The functions can also convert between these alternative representations.
For example, <code>prefix_length()</code> can infer the prefix length from an
<code><a href="#topic+ip_address">ip_address</a></code> vector of netmasks and/or hostmasks, while <code>netmask()</code> and
<code>hostmask()</code> can accept a vector of prefix lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefix_length(x)

netmask(x, ...)

## S3 method for class 'numeric'
netmask(x, is_ipv6 = NULL, ...)

hostmask(x, ...)

## S3 method for class 'numeric'
hostmask(x, is_ipv6 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netmask_+3A_x">x</code></td>
<td>

<ul>
<li><p> An <code><a href="#topic+ip_network">ip_network</a></code> vector.
</p>
</li>
<li><p> An <code><a href="#topic+ip_interface">ip_interface</a></code> vector.
</p>
</li>
<li> <p><code>prefix_length()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector of netmasks and/or hostmasks. Ambiguous cases
(all zeros, all ones) are treated as netmasks.
</p>
</li>
<li> <p><code>netmask()</code> and <code>hostmask()</code>: An integer vector of prefix lengths.
</p>
</li></ul>
</td></tr>
<tr><td><code id="netmask_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="netmask_+3A_is_ipv6">is_ipv6</code></td>
<td>
<p>A logical vector indicating whether to construct an IPv4 or
IPv6 address. If <code>NULL</code> (the default), then IPv4 is preferred but an IPv6
address is constructed when <code>x</code> is too large for the IPv4 address space.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>prefix_length()</code>: An integer vector
</p>
</li>
<li> <p><code>netmask()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>hostmask()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+max_prefix_length">max_prefix_length()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_network(c("192.168.0.0/22", "2001:db00::0/26"))

prefix_length(x)

netmask(x)

hostmask(x)

# construct netmask/hostmask from prefix length
netmask(c(22L, 26L), c(FALSE, TRUE))

hostmask(c(22L, 26L), c(FALSE, TRUE))

# extract prefix length from netmask/hostmask
prefix_length(ip_address(c("255.255.255.0", "0.255.255.255")))

# invalid netmask/hostmask raise a warning and return NA
prefix_length(ip_address("255.255.255.1"))
</code></pre>

<hr>
<h2 id='network_in_network'>Network membership of other networks</h2><span id='topic+network_in_network'></span><span id='topic+is_supernet'></span><span id='topic+is_subnet'></span><span id='topic+overlaps'></span>

<h3>Description</h3>

<p><code>is_supernet()</code> and <code>is_subnet()</code> check if one network is a true supernet or
subnet of another network; <code>overlaps()</code> checks for any overlap between two
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_supernet(network, other)

is_subnet(network, other)

overlaps(network, other)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_in_network_+3A_network">network</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
<tr><td><code id="network_in_network_+3A_other">other</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+is_within">is_within()</a></code> to check if an <code><a href="#topic+ip_address">ip_address</a></code> is within an <code><a href="#topic+ip_network">ip_network</a></code>.
</p>
<p>Use <code><a href="#topic+supernet">supernet()</a></code> and <code><a href="#topic+subnets">subnets()</a></code> to traverse the network hierarchy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net1 &lt;- ip_network("192.168.1.128/30")
net2 &lt;- ip_network("192.168.1.0/24")

is_supernet(net1, net2)

is_subnet(net1, net2)

overlaps(net1, net2)
</code></pre>

<hr>
<h2 id='network_size'>Network size</h2><span id='topic+network_size'></span><span id='topic+network_address'></span><span id='topic+broadcast_address'></span><span id='topic+num_addresses'></span>

<h3>Description</h3>

<p><code>network_address()</code> and <code>broadcast_address()</code> yield the first and last
addresses of the network; <code>num_addresses()</code> gives the total number of
addresses in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_address(x)

broadcast_address(x)

num_addresses(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_size_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The broadcast address is a special address at which any host connected
to the network can receive messages. That is, packets sent to this address
are received by all hosts on the network.
In IPv4, the last address of a network is the broadcast address.
Although IPv6 does not follow this approach to broadcast addresses, the
<code>broadcast_address()</code> function still returns the last address of the network.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>network_address()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>broadcast_address()</code>: An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>
</li>
<li> <p><code>num_addresses()</code>: A numeric vector
</p>
</li></ul>



<h3>See Also</h3>

<p>Use <code><a href="#topic+seq.ip_network">seq.ip_network()</a></code> to generate all addresses in a network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ip_network(c("192.168.0.0/22", "2001:db8::/33"))

network_address(x)

broadcast_address(x)

num_addresses(x)
</code></pre>

<hr>
<h2 id='reverse_pointer'>Reverse DNS pointer</h2><span id='topic+reverse_pointer'></span>

<h3>Description</h3>

<p>Returns the PTR record used by reverse DNS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_pointer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_pointer_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These documents describe reverse DNS lookup in more detail:
</p>

<ul>
<li> <p><strong>IPv4:</strong> <a href="https://www.rfc-editor.org/rfc/rfc1035">RFC-1035 Section 3.5</a>
</p>
</li>
<li> <p><strong>IPv6:</strong> <a href="https://www.rfc-editor.org/rfc/rfc3596">RFC-3596 Section 2.5</a>
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverse_pointer(ip_address("127.0.0.1"))

reverse_pointer(ip_address("2001:db8::1"))
</code></pre>

<hr>
<h2 id='sample'>Sample random addresses</h2><span id='topic+sample'></span><span id='topic+sample_ipv4'></span><span id='topic+sample_ipv6'></span><span id='topic+sample_network'></span>

<h3>Description</h3>

<p><code>sample_ipv4()</code> and <code>sample_ipv6()</code> sample from the entire address space;
<code>sample_network()</code> samples from a specific network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_ipv4(size, ..., replace = FALSE)

sample_ipv6(size, ..., replace = FALSE)

sample_network(x, size, ..., replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_+3A_size">size</code></td>
<td>
<p>Integer specifying the number of addresses to return</p>
</td></tr>
<tr><td><code id="sample_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="sample_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sample_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+seq.ip_network">seq.ip_network()</a></code> to generate <em>all</em> addresses in a network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_ipv4(5)

sample_ipv6(5)

sample_network(ip_network("192.168.0.0/16"), 5)

sample_network(ip_network("2001:db8::/48"), 5)
</code></pre>

<hr>
<h2 id='sequence'>List addresses within a network</h2><span id='topic+sequence'></span><span id='topic+seq.ip_network'></span><span id='topic+hosts'></span>

<h3>Description</h3>

<p><code>seq()</code> returns <em>all</em> hosts
</p>
<p><code>hosts()</code> returns only <em>usable</em> hosts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ip_network'
seq(x, ...)

hosts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequence_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> scalar</p>
</td></tr>
<tr><td><code id="sequence_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In IPv4, the unusable hosts are the network address and the broadcast
address (i.e. the first and last addresses in the network).
In IPv6, the only unusable host is the subnet router anycast address
(i.e. the first address in the network).
</p>
<p>For networks with a prefix length of 31 (for IPv4) or 127 (for IPv6),
the unusable hosts are included in the results of <code>hosts()</code>.
</p>
<p>The ipaddress package does not support <a href="base.html#topic+LongVectors">long vectors</a>
(i.e. vectors with more than 2^31 - 1 elements). As a result, these two
functions do not support networks larger than this size. This corresponds
to prefix lengths less than 2 (for IPv4) or 98 (for IPv6). However, you
might find that machine memory imposes stricter limitations.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+network_address">network_address()</a></code> and <code><a href="#topic+broadcast_address">broadcast_address()</a></code> to get the first and last
address of a network.
</p>
<p>Use <code><a href="#topic+sample_network">sample_network()</a></code> to randomly sample addresses from a network.
</p>
<p>Use <code><a href="#topic+subnets">subnets()</a></code> to list the subnetworks within a network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq(ip_network("192.168.0.0/30"))

seq(ip_network("2001:db8::/126"))

hosts(ip_network("192.168.0.0/30"))

hosts(ip_network("2001:db8::/126"))
</code></pre>

<hr>
<h2 id='summarize_address_range'>List constituent networks of an address range</h2><span id='topic+summarize_address_range'></span>

<h3>Description</h3>

<p>Given an address range, this returns the list of constituent networks.
</p>
<p>If you know the address range matches the boundaries of a single network, it
might be preferable to use <code><a href="#topic+common_network">common_network()</a></code>. This returns an <code><a href="#topic+ip_network">ip_network</a></code>
vector instead of a list of <code><a href="#topic+ip_network">ip_network</a></code> vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_address_range(address1, address2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_address_range_+3A_address1">address1</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="summarize_address_range_+3A_address2">address2</code></td>
<td>
<p>An <code><a href="#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+ip_network">ip_network</a></code> vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+common_network">common_network()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># address range matches network boundaries
summarize_address_range(ip_address("192.168.0.0"), ip_address("192.168.0.15"))

# address range does not match network boundaries
summarize_address_range(ip_address("192.167.255.255"), ip_address("192.168.0.16"))
</code></pre>

<hr>
<h2 id='traverse_hierarchy'>Traverse the network hierarchy</h2><span id='topic+traverse_hierarchy'></span><span id='topic+supernet'></span><span id='topic+subnets'></span>

<h3>Description</h3>

<p>These functions step up and down the network hierarchy. <code>supernet()</code> returns
the supernetwork containing the given network. <code>subnets()</code> returns the list
of subnetworks which join to make the given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supernet(x, new_prefix = prefix_length(x) - 1L)

subnets(x, new_prefix = prefix_length(x) + 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traverse_hierarchy_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
<tr><td><code id="traverse_hierarchy_+3A_new_prefix">new_prefix</code></td>
<td>
<p>An integer vector indicating the desired prefix length.
By default, this steps a single level through the hierarchy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ipaddress package does not support <a href="base.html#topic+LongVectors">long vectors</a>
(i.e. vectors with more than 2^31 - 1 elements). The limits the number of
subnetworks that <code>subnets()</code> can return. However, you might find that machine
memory imposes stricter limitations.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>supernet()</code>: An <code><a href="#topic+ip_network">ip_network</a></code> vector
</p>
</li>
<li> <p><code>subnets()</code>: A list of <code><a href="#topic+ip_network">ip_network</a></code> vectors
</p>
</li></ul>



<h3>See Also</h3>

<p>Use <code><a href="#topic+seq.ip_network">seq.ip_network()</a></code> to list the addresses within a network.
</p>
<p>Use <code><a href="#topic+is_supernet">is_supernet()</a></code> and <code><a href="#topic+is_subnet">is_subnet()</a></code> to check if one network is contained
within another.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supernet(ip_network("192.168.0.0/24"))

supernet(ip_network("192.168.0.0/24"), new_prefix = 10L)

subnets(ip_network("192.168.0.0/24"))

subnets(ip_network("192.168.0.0/24"), new_prefix = 27L)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
