<!DOCTYPE html><html lang="en"><head><title>Help for package ssMRCD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ssMRCD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align_PC'><p>Align Loadings of Principal Components</p></a></li>
<li><a href='#biplot.PCAloc'><p>Biplot for PCAloc</p></a></li>
<li><a href='#contamination_random'><p>Contamination Through Swapping</p></a></li>
<li><a href='#eval_objective'><p>Objective function value for local sparse PCA</p></a></li>
<li><a href='#explained_var'><p>Explained Variance summarized over Groups</p></a></li>
<li><a href='#geo_weights'><p>Inverse Geographic Weight Matrix</p></a></li>
<li><a href='#groups_gridbased'><p>Creates Grid-Based Neighborhood Structure</p></a></li>
<li><a href='#local_outliers_ssMRCD'><p>Local Outlier Detection Technique based on ssMRCD</p></a></li>
<li><a href='#objective_matrix'><p>Calculation of Objective Function</p></a></li>
<li><a href='#parameter_tuning'><p>Optimal Smoothing Parameter for ssMRCD based on Local Outliers</p></a></li>
<li><a href='#plot_loadings'><p>Plots of loadings of PCAloc object</p></a></li>
<li><a href='#plot_score_distances'><p>Distance-distance plot of scores of PCA</p></a></li>
<li><a href='#plot_scores'><p>Plots of score distribution</p></a></li>
<li><a href='#plot.locOuts'><p>Diagnostic Plots for Local Outlier Detection</p></a></li>
<li><a href='#plot.PCAloc'><p>Plotting method PCAloc object</p></a></li>
<li><a href='#plot.ssMRCD'><p>Plot Method for ssMRCD Object</p></a></li>
<li><a href='#rescale_weights'><p>Rescale Weight Matrix</p></a></li>
<li><a href='#residuals.ssMRCD'><p>Extracting Residuals from Local Fit</p></a></li>
<li><a href='#restructure_as_list'><p>Restructure Data Matrix as List</p></a></li>
<li><a href='#scale_ssMRCD'><p>Scale Data Locally</p></a></li>
<li><a href='#scores'><p>Calculate Scores for local sparse PCA</p></a></li>
<li><a href='#scores.OD'><p>Orthogonal Distances for PCAloc</p></a></li>
<li><a href='#scores.SD'><p>Score Distances for PCAloc</p></a></li>
<li><a href='#screeplot.PCAloc'><p>Screeplot for PCAloc</p></a></li>
<li><a href='#select_smoothing'><p>Optimal Smoothing Parameter for ssMRCD based on Residuals</p></a></li>
<li><a href='#select_sparsity'><p>Optimal Sparsity Parameter Selection for PCA</p></a></li>
<li><a href='#sparsePCAloc'><p>Calculate Sparse Principle Components</p></a></li>
<li><a href='#sparsity_entries'><p>Entry-wise Sparsity in the Loadings</p></a></li>
<li><a href='#sparsity_group'><p>Group-wise Sparsity in the Loadings</p></a></li>
<li><a href='#sparsity_mixed'><p>Mixed Sparsity of the Loadings</p></a></li>
<li><a href='#sparsity_summary'><p>Entry-wise Sparsity in the Loadings per Group</p></a></li>
<li><a href='#ssMRCD'><p>Spatially Smoothed MRCD Estimator</p></a></li>
<li><a href='#summary.locOuts'><p>Summary of Local Outlier Detection</p></a></li>
<li><a href='#summary.PCAloc'><p>Summary method for PCAloc</p></a></li>
<li><a href='#summary.ssMRCD'><p>Summary Method for ssMRCD Object</p></a></li>
<li><a href='#time_weights'><p>Band weight matrix for time series groupings</p></a></li>
<li><a href='#weatherAUT2021'><p>Austrian Weather Data 2021</p></a></li>
<li><a href='#weatherHoheWarte'><p>Vienna Weather Time Series (1960-2023)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially Smoothed MRCD Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patricia Puchhammer &lt;patricia.puchhammer@tuwien.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of the Spatially Smoothed Minimum Regularized Determinant (ssMRCD) estimator and its usage in an ssMRCD-based outlier detection method as described in Puchhammer and Filzmoser (2023) &lt;<a href="https://doi.org/10.1080%2F10618600.2023.2277875">doi:10.1080/10618600.2023.2277875</a>&gt; and for sparse robust PCA for multi-source data described in Puchhammer, Wilms and Filzmoser (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2407.16299">doi:10.48550/arXiv.2407.16299</a>&gt;. Included are also complementary visualization and parameter tuning tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics, robustbase, scales, car, dbscan,
plot3D, dplyr, ggplot2, expm, foreach, doParallel, rrcov,
DescTools, rootSolve, parallel, Matrix, reshape2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-23 09:56:19 UTC; puchhammer</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricia Puchhammer [aut, cre, cph],
  Peter Filzmoser [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-23 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align_PC'>Align Loadings of Principal Components</h2><span id='topic+align_PC'></span>

<h3>Description</h3>

<p>Aligns loadings per neighborhood for better visualization and comparison. Different options are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_PC(PC, N, p, type = "largest", vec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_PC_+3A_pc">PC</code></td>
<td>
<p>matrix of loadings of size Np x k</p>
</td></tr>
<tr><td><code id="align_PC_+3A_n">N</code></td>
<td>
<p>integer, number of groups/neighborhoods</p>
</td></tr>
<tr><td><code id="align_PC_+3A_p">p</code></td>
<td>
<p>integer, number of variables</p>
</td></tr>
<tr><td><code id="align_PC_+3A_type">type</code></td>
<td>
<p>character indicating how loadings are aligned (see details),
options are <code>"largest", "maxvar","nonzero","mean", "scalar", "none"</code>.</p>
</td></tr>
<tr><td><code id="align_PC_+3A_vec">vec</code></td>
<td>
<p><code>NULL</code> or vector containing vectors for type <code>"scalar"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For input <code>type</code> possible values are <code>"largest", "maxvar","nonzero","mean","scalar"</code>.
For option <code>"maxvar"</code> the variable with the highest absolute value in the loading
is scaled to be positive (per neighborhood, per loading).
For option <code>"nonzero"</code> the variable with largest distance to zero in the entries is
scaled to be positive (per neighborhood, per loading).
For option <code>"scalar"</code> the variable is scaled in a way, that the scalar product
between the loading and the respective part of <code>vec</code> is positive (per neighborhood, per loading).
If <code>vec</code> is of size <code>p</code> times <code>k</code>, the same vector is used for all neighborhoods.
Option <code>"mean"</code> is option <code>"scalar"</code> with <code>vec</code> being the mean of the loadings per variable across neighborhoods.
Option <code>"largest"</code> scales the largest absolute value to be positive per neighborhood and per PC.
Option <code>"none"</code> does nothing and returns <code>PC</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of loadings of size <code>Np</code> times <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = matrix(c(1, 0, 0, 0, sqrt(0.5), -sqrt(0.5), 0, 0,
             0, sqrt(1/3), -sqrt(1/3), sqrt(1/3), sqrt(0.5), sqrt(0.5), 0, 0),
           ncol = 2)
align_PC(PC = x, N = 2, p = 4, type = "largest")
align_PC(PC = x, N = 2, p = 4, type = "mean")
</code></pre>

<hr>
<h2 id='biplot.PCAloc'>Biplot for PCAloc</h2><span id='topic+biplot.PCAloc'></span>

<h3>Description</h3>

<p>Biplot for PCAloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCAloc'
biplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplot.PCAloc_+3A_x">x</code></td>
<td>
<p>object of class PCAloc.</p>
</td></tr>
<tr><td><code id="biplot.PCAloc_+3A_...">...</code></td>
<td>
<p>other input arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters that can be given to the function are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>shape</code> </td><td style="text-align: left;"> point shape  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>size</code> </td><td style="text-align: left;"> point size </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>alpha</code> </td><td style="text-align: left;"> transparency  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>color</code> </td><td style="text-align: left;"> either <code>"variable"</code> or <code>"groups"</code>
   indication how points should be coloured.   </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns version of biplot for PCAloc object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(236)

# make data
data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariance matrices
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# plot biplot
biplot(pca, alpha = 0.4, shape = 16, size = 2, color = "variable")
</code></pre>

<hr>
<h2 id='contamination_random'>Contamination Through Swapping</h2><span id='topic+contamination_random'></span>

<h3>Description</h3>

<p>This function swaps observations completely random in order to introduce contamination
in the data. Used in <code><a href="#topic+parameter_tuning">parameter_tuning</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contamination_random(cont, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contamination_random_+3A_cont">cont</code></td>
<td>
<p>numeric, amount of contamination in data.</p>
</td></tr>
<tr><td><code id="contamination_random_+3A_data">data</code></td>
<td>
<p>data whose observations should be switched.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with switched observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(1)

# get data
data(weatherAUT2021)

# switch 5% of observations
contamination_random(cont = 0.05, data = weatherAUT2021[,1:6])
</code></pre>

<hr>
<h2 id='eval_objective'>Objective function value for local sparse PCA</h2><span id='topic+eval_objective'></span>

<h3>Description</h3>

<p>Objective function value for local sparse PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_objective(PC, eta, gamma, COVS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_objective_+3A_pc">PC</code></td>
<td>
<p>vectorised component to evaluate.</p>
</td></tr>
<tr><td><code id="eval_objective_+3A_eta">eta</code></td>
<td>
<p>degree of sparsity.</p>
</td></tr>
<tr><td><code id="eval_objective_+3A_gamma">gamma</code></td>
<td>
<p>distribution of sparsity between groupwise (<code class="reqn">\gamma = 1</code>) and entrywise (<code class="reqn">\gamma = 0</code>) sparsity.</p>
</td></tr>
<tr><td><code id="eval_objective_+3A_covs">COVS</code></td>
<td>
<p>list of covariance matrices used for PCA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns value of the objective function for given <code>v</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S1 = matrix(c(1, 0.9, 0.8, 0.5,
              0.9, 1.1, 0.7, 0.4,
              0.8, 0.7, 1.5, 0.2,
              0.5, 0.4, 0.2, 1), ncol = 4)
S2 = t(S1)%*% S1
S2 = S2/2

eval_objective(PC = c(1,0,0,0,sqrt(2),0,0,-sqrt(2)),
               eta = 1, gamma = 0.5,
               COVS = list(S1, S2))
</code></pre>

<hr>
<h2 id='explained_var'>Explained Variance summarized over Groups</h2><span id='topic+explained_var'></span>

<h3>Description</h3>

<p>Explained Variance summarized over Groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explained_var(COVS, PC, k, type = "scaled", cor = FALSE, gamma = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explained_var_+3A_covs">COVS</code></td>
<td>
<p>list of covariance matrices</p>
</td></tr>
<tr><td><code id="explained_var_+3A_pc">PC</code></td>
<td>
<p>matrix-like object holding the loadings of length np</p>
</td></tr>
<tr><td><code id="explained_var_+3A_k">k</code></td>
<td>
<p>which component should be evaluated</p>
</td></tr>
<tr><td><code id="explained_var_+3A_type">type</code></td>
<td>
<p>character, either <code>"scaled"</code> for scaling using the extremes solutions or <code>"percent"</code> as percentage of overall variance.</p>
</td></tr>
<tr><td><code id="explained_var_+3A_cor">cor</code></td>
<td>
<p>logical, if <code>COVS</code> is a correlation matrix or not</p>
</td></tr>
<tr><td><code id="explained_var_+3A_gamma">gamma</code></td>
<td>
<p>scalar between 0 and 1 indicatig distribution of sparsity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S1 = matrix(c(1, 0.9, 0.8, 0.5,
              0.9, 1.1, 0.7, 0.4,
              0.8, 0.7, 1.5, 0.2,
              0.5, 0.4, 0.2, 1), ncol = 4)
S2 = t(S1)%*% S1
S2 = S2/2

explained_var(COVS = list(S1, S2),
              PC = c(1,0,0,0,sqrt(2),0,0,-sqrt(2)),
              k = 1,
              cor = FALSE,
              gamma = 0.5)

explained_var(COVS = list(cov2cor(S1), cov2cor(S2)),
              PC = c(1,0,0,0,sqrt(2),0,0,-sqrt(2)),
              k = 1,
              cor = TRUE,
              gamma = 0.5)
</code></pre>

<hr>
<h2 id='geo_weights'>Inverse Geographic Weight Matrix</h2><span id='topic+geo_weights'></span>

<h3>Description</h3>

<p>Calculates a inverse-distance based weight matrix for the function <code><a href="#topic+ssMRCD">ssMRCD</a></code> (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_weights(coordinates, groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_weights_+3A_coordinates">coordinates</code></td>
<td>
<p>matrix of coordinates of observations.</p>
</td></tr>
<tr><td><code id="geo_weights_+3A_groups">groups</code></td>
<td>
<p>vector of neighborhood groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the centers (means of the coordinates given) <code class="reqn">c_i</code> of each neighborhood is calculated.
Then, the Euclidean distance between the centers is calculated and the weight is based on
the inverse distance between two neighborhoods, </p>
<p style="text-align: center;"><code class="reqn">w_{ij} = \frac{1}{dist(c_i, c_j)}. </code>
</p>

<p>It is scaled according to a weight matrix.
</p>


<h3>Value</h3>

<p>Returns a weighting matrix <code>W</code> and the coordinates of the centers per neighborhood <code>centersN</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescale_weights">rescale_weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordinates = matrix(rnorm(1000), ncol = 2, nrow = 500)
groups = sample(1:5, 500, replace = TRUE)

geo_weights(coordinates, groups)

</code></pre>

<hr>
<h2 id='groups_gridbased'>Creates Grid-Based Neighborhood Structure</h2><span id='topic+groups_gridbased'></span>

<h3>Description</h3>

<p>This function creates a grid-based neighborhood structure for the <code><a href="#topic+ssMRCD">ssMRCD</a></code> function using cut-off values for two coordinate axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_gridbased(x, y, cutx, cuty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groups_gridbased_+3A_x">x</code></td>
<td>
<p>vector of first coordinate of data set.</p>
</td></tr>
<tr><td><code id="groups_gridbased_+3A_y">y</code></td>
<td>
<p>vector of second coordinate of data set.</p>
</td></tr>
<tr><td><code id="groups_gridbased_+3A_cutx">cutx</code></td>
<td>
<p>cut-offs for first coordinate.</p>
</td></tr>
<tr><td><code id="groups_gridbased_+3A_cuty">cuty</code></td>
<td>
<p>cut-offs for second coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a neighborhood assignment vector for the coordinates <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data
data(weatherAUT2021)

# set cut-off values
cut_lon = c(9:16, 18)
cut_lat = c(46, 47, 47.5, 48, 49)

# create neighborhood assignments
groups_gridbased(weatherAUT2021$lon,
                      weatherAUT2021$lat,
                      cut_lon,
                      cut_lat)
</code></pre>

<hr>
<h2 id='local_outliers_ssMRCD'>Local Outlier Detection Technique based on ssMRCD</h2><span id='topic+local_outliers_ssMRCD'></span>

<h3>Description</h3>

<p>This function applies the local outlier detection method based on the spatially
smoothed MRCD estimator developed in Puchhammer and Filzmoser (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_outliers_ssMRCD(
  data,
  coords,
  groups,
  lambda,
  weights = NULL,
  k = NULL,
  dist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_outliers_ssMRCD_+3A_data">data</code></td>
<td>
<p>data matrix with measured values.</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of observations.</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_groups">groups</code></td>
<td>
<p>vector of neighborhood assignments.</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_lambda">lambda</code></td>
<td>
<p>scalar used for spatial smoothing (see also <code><a href="#topic+ssMRCD">ssMRCD</a></code>).</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_weights">weights</code></td>
<td>
<p>weight matrix used in <code><a href="#topic+ssMRCD">ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_k">k</code></td>
<td>
<p>integer, if given the <code>k</code> nearest neighbors per observations are used to calculate next distances. Default value is <code>k = NULL</code>.</p>
</td></tr>
<tr><td><code id="local_outliers_ssMRCD_+3A_dist">dist</code></td>
<td>
<p>scalar, if given the neighbors closer than given distance are used for next distances. If <code>dist</code> is given, <code>dist</code> is used, otherwise <code>k</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"locOuts"</code> with following components:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>outliers</code> </td><td style="text-align: left;"> indices of found outliers. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>next_distance</code> </td><td style="text-align: left;"> vector of next distances for all observations. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>cutoff</code> </td><td style="text-align: left;"> upper fence of adjusted boxplot (see <code><a href="robustbase.html#topic+adjbox">adjbox</a></code>) used as cutoff value for next distances. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>coords</code> </td><td style="text-align: left;"> matrix of observation coordinates.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>data</code> </td><td style="text-align: left;"> matrix of observation values. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>groups</code> </td><td style="text-align: left;"> vector of neighborhood assignments. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>k, dist</code> </td><td style="text-align: left;"> specifications regarding neighbor comparisons. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>centersN</code> </td><td style="text-align: left;"> coordinates of centers of neighborhoods. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>matneighbor</code> </td><td style="text-align: left;"> matrix storing information which observations where used to calculate next distance for each observation (per row). 1 indicates it is used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ssMRCD</code> </td><td style="text-align: left;"> object of class <code>"ssMRCD"</code> and output of <code><a href="#topic+ssMRCD">ssMRCD</a></code> covariance estimation. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Puchhammer P. and Filzmoser P. (2023): Spatially smoothed robust covariance estimation for local outlier detection. <a href="https://doi.org/10.48550/arXiv.2305.05371">doi:10.48550/arXiv.2305.05371</a>
</p>


<h3>See Also</h3>

<p>See also functions <code><a href="#topic+ssMRCD">ssMRCD</a>, <a href="#topic+plot.locOuts">plot.locOuts</a>, <a href="#topic+summary.locOuts">summary.locOuts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data construction
data = matrix(rnorm(2000), ncol = 4)
coords = matrix(rnorm(1000), ncol = 2)
groups = sample(1:10, 500, replace = TRUE)
lambda = 0.3

# apply function
outs = local_outliers_ssMRCD(data = data,
                             coords = coords,
                             groups = groups,
                             lambda = lambda,
                             k = 10)
outs
</code></pre>

<hr>
<h2 id='objective_matrix'>Calculation of Objective Function</h2><span id='topic+objective_matrix'></span>

<h3>Description</h3>

<p>Calculation of the value of the objective function for the <code><a href="#topic+ssMRCD">ssMRCD</a></code> for a given list of matrices,
lambda and a weighting matrix according to formula (3) in Puchhammer and Filzmoser (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective_matrix(matrix_list, lambda, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objective_matrix_+3A_matrix_list">matrix_list</code></td>
<td>
<p>a list of matrices <code class="reqn">K_i</code></p>
</td></tr>
<tr><td><code id="objective_matrix_+3A_lambda">lambda</code></td>
<td>
<p>scalar smoothing parameter</p>
</td></tr>
<tr><td><code id="objective_matrix_+3A_weights">weights</code></td>
<td>
<p>matrix of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the objective function using matrices <code class="reqn">K_i</code>.
</p>


<h3>References</h3>

<p>Puchhammer P. and Filzmoser P. (2023): Spatially smoothed robust covariance estimation for local outlier detection. <a href="https://doi.org/10.48550/arXiv.2305.05371">doi:10.48550/arXiv.2305.05371</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct matrices
k1 = matrix(c(1,2,3,4), nrow = 2)
k2 = matrix(c(1,3,5,7), nrow = 2)

# construct weighting matrix
W = matrix(c(0, 1, 1, 0), nrow = 2)

objective_matrix(list(k1, k2), 0.5, W)
</code></pre>

<hr>
<h2 id='parameter_tuning'>Optimal Smoothing Parameter for ssMRCD based on Local Outliers</h2><span id='topic+parameter_tuning'></span>

<h3>Description</h3>

<p>This function provides insight into the effects of different parameter settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_tuning(
  data,
  coords,
  groups,
  lambda = c(0, 0.25, 0.5, 0.75, 0.9),
  weights = NULL,
  k = NULL,
  dist = NULL,
  cont = 0.05,
  repetitions = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_tuning_+3A_data">data</code></td>
<td>
<p>matrix with observations.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of these observations.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_groups">groups</code></td>
<td>
<p>numeric vector, the neighborhood structure that should be used for <code><a href="#topic+ssMRCD">ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_lambda">lambda</code></td>
<td>
<p>scalar, the smoothing parameter.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_weights">weights</code></td>
<td>
<p>weighting matrix used in <code><a href="#topic+ssMRCD">ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_k">k</code></td>
<td>
<p>vector of possible k-values to evaluate.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_dist">dist</code></td>
<td>
<p>vector of possible dist-values to evaluate.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_cont">cont</code></td>
<td>
<p>level of contamination, between 0 and 1.</p>
</td></tr>
<tr><td><code id="parameter_tuning_+3A_repetitions">repetitions</code></td>
<td>
<p>number of repetitions wanted to have a good picture of the best parameter combination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of average false-negative rate (FNR) values and the total number of outliers found by the method as aproxy for the false-positive rate.
Be aware that the FNR does not take into account that there are also natural outliers included in the data set that might or might not be found.
Also a plot is returned representing these average.
The best parameter selection depends on the goal of the analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get data set
data("weatherAUT2021")

# make neighborhood assignments
cut_lon = c(9:16, 18)
cut_lat = c(46, 47, 47.5, 48, 49)
N = ssMRCD::groups_gridbased(weatherAUT2021$lon, weatherAUT2021$lat, cut_lon, cut_lat)
table(N)
N[N == 2] = 1
N[N == 3] = 4
N[N == 5] = 4
N[N == 6] = 7
N[N == 11] = 15
N = as.numeric(as.factor(N))

# tune parameters
set.seed(123)
parameter_tuning(data = weatherAUT2021[, 1:6 ],
                 coords = weatherAUT2021[, c("lon", "lat")],
                 groups = N,
                 lambda = c(0.5, 0.75),
                 k = c(10),
                 repetitions = 1)

</code></pre>

<hr>
<h2 id='plot_loadings'>Plots of loadings of PCAloc object</h2><span id='topic+plot_loadings'></span>

<h3>Description</h3>

<p>Plots of loadings of PCAloc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_loadings(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_loadings_+3A_object">object</code></td>
<td>
<p>object of class PCAloc</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_...">...</code></td>
<td>
<p>other input arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters that can be given to the function are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>text</code> </td><td style="text-align: left;"> logical if values should be added as text.  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>size</code> </td><td style="text-align: left;"> point size.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>tolerance</code> </td><td style="text-align: left;"> tolerance for rounding to zero.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>k</code> </td><td style="text-align: left;"> integer, which component scores should be plotted. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>groupnames</code> </td><td style="text-align: left;"> names of groups. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>varnames</code> </td><td style="text-align: left;"> names of variables. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>textrotate</code> </td><td style="text-align: left;"> angle of text rotation, if included.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns loading heatmap for component <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(236)

data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariance matrices
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# plot score distances
plot_loadings(object = pca,
            k = 1,
            size = 2)
</code></pre>

<hr>
<h2 id='plot_score_distances'>Distance-distance plot of scores of PCA</h2><span id='topic+plot_score_distances'></span>

<h3>Description</h3>

<p>Distance-distance plot of scores of PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_score_distances(X, PC, groups, ssMRCD, k, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_score_distances_+3A_x">X</code></td>
<td>
<p>data matrix.</p>
</td></tr>
<tr><td><code id="plot_score_distances_+3A_pc">PC</code></td>
<td>
<p>loadings from PCA.</p>
</td></tr>
<tr><td><code id="plot_score_distances_+3A_groups">groups</code></td>
<td>
<p>vector containing group assignments.</p>
</td></tr>
<tr><td><code id="plot_score_distances_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p>ssMRCD object.</p>
</td></tr>
<tr><td><code id="plot_score_distances_+3A_k">k</code></td>
<td>
<p>integer of how many components should be used.</p>
</td></tr>
<tr><td><code id="plot_score_distances_+3A_...">...</code></td>
<td>
<p>other input arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters that can be given to the function are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>shape</code> </td><td style="text-align: left;"> point shape  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>size</code> </td><td style="text-align: left;"> point size </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>alpha</code> </td><td style="text-align: left;"> transparency  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns distance-distance plot of orthogonal and score distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(236)

data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariance matrices
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# plot score distances
plot_score_distances(PC = pca$PC,
                     groups = groups,
                     X = data,
                     ssMRCD = covs,
                     k = 2,
                     alpha = 0.4,
                     shape = 16,
                     size = 2)
</code></pre>

<hr>
<h2 id='plot_scores'>Plots of score distribution</h2><span id='topic+plot_scores'></span>

<h3>Description</h3>

<p>Plots of score distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scores(X, PC, groups, ssMRCD, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scores_+3A_x">X</code></td>
<td>
<p>data matrix.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_pc">PC</code></td>
<td>
<p>loadings from PCA.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_groups">groups</code></td>
<td>
<p>vector containing group assignments.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p>ssMRCD object.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_...">...</code></td>
<td>
<p>other input arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters that can be given to the function are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>shape</code> </td><td style="text-align: left;"> point shape  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>size</code> </td><td style="text-align: left;"> point size </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>alpha</code> </td><td style="text-align: left;"> transparency  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>k</code> </td><td style="text-align: left;"> integer, which component scores should be plotted </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns histograms of scores for component <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(236)

data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariance matrices
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# plot score distances
plot_scores(PC = pca$PC,
            groups = groups,
            X = data,
            ssMRCD = covs,
            k = 1,
            alpha = 0.4,
            shape = 16,
            size = 2)
</code></pre>

<hr>
<h2 id='plot.locOuts'>Diagnostic Plots for Local Outlier Detection</h2><span id='topic+plot.locOuts'></span>

<h3>Description</h3>

<p>This function plots different diagnostic plots for local outlier detection.
It can be applied to an object of class <code>"locOuts"</code> which is the output of the function <code><a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locOuts'
plot(
  x,
  type = c("hist", "spatial", "lines", "3D"),
  colour = "all",
  focus = NULL,
  pos = NULL,
  alpha = 0.3,
  data = NULL,
  add_map = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.locOuts_+3A_x">x</code></td>
<td>
<p>a locOuts object obtained by the function <code><a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_type">type</code></td>
<td>
<p>vector containing the types of plots that should be plotted, possible values <code>c("hist", "spatial", "lines", "3D")</code>.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_colour">colour</code></td>
<td>
<p>character specifying the color scheme (see details). Possible values <code>"all", "onlyOuts", "outScore"</code>.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_focus">focus</code></td>
<td>
<p>an integer being the index of the observation whose neighborhood should be analysed more closely.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_pos">pos</code></td>
<td>
<p>integer specifying the position of the text &quot;cut-off&quot; in the histogram (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_alpha">alpha</code></td>
<td>
<p>scalar specifying the transparency level of the points plotted for plot type <code>"spatial", "3D"</code> and <code>"lines"</code>.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_data">data</code></td>
<td>
<p>optional data frame or matrix used for plot of type <code>"line"</code>. Will be used to plot lines based scaled <code>data</code> instead of the data used for local outlier detection.</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_add_map">add_map</code></td>
<td>
<p>TRUE if a map should be plotted along the line plot (<code>type = "lines"</code>).</p>
</td></tr>
<tr><td><code id="plot.locOuts_+3A_...">...</code></td>
<td>
<p>further parameters passed on to base-R plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regarding the parameter <code>type</code> the value <code>"hist"</code> corresponds to a plot of the
histogram of the next distances together with the used cutoff-value.
When using <code>"spatial"</code> the coordinates of each observation are plotted and colorized according to the color setting.
The <code>"lines"</code> plot is used with the index <code>focus</code> of one observation whose out/inlyingness to its neighborhood
should by plotted. The whole data set is scaled to the range [0,1] and the scaled value of the selected observation and
its neighbors are plotted. Outliers are plotted in orange.
The <code>"3D"</code> setting leads to a 3D-plot using the colour setting as height.
The view can be adapted using the parameters <code>theta</code> and <code>phi</code>. <br /> <br />
For the <code>colour</code> setting possible values are <code>"all"</code> (all next distances are
used and colored in an orange palette), <code>"onlyOuts"</code> (only outliers are
plotted in orange, inliers are plotted in grey) and <code>"outScore"</code> (the next
distance divided by the cutoff value is used to colourize the points; inliers are colorized in blue, outliers in orange).
</p>


<h3>Value</h3>

<p>Returns plots regarding next distances and spatial context.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(1)

# make locOuts object
data = matrix(rnorm(2000), ncol = 4)
coords = matrix(rnorm(1000), ncol = 2)
groups = sample(1:10, 500, replace = TRUE)
lambda = 0.3

# local outlier detection
outs = local_outliers_ssMRCD(data = data,
                             coords = coords,
                             groups = groups,
                             lambda = lambda,
                             k = 10)

# plot results
plot(outs, type = "hist")
plot(outs, type = "spatial", colour = "outScore")
plot(outs, type = "3D", colour = "outScore", theta = 0)
plot(outs, type ="lines", focus = outs$outliers[1])
</code></pre>

<hr>
<h2 id='plot.PCAloc'>Plotting method PCAloc object</h2><span id='topic+plot.PCAloc'></span>

<h3>Description</h3>

<p>Plotting method PCAloc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCAloc'
plot(
  x,
  type = c("loadings", "screeplot", "scores", "score_distances", "biplot"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PCAloc_+3A_x">x</code></td>
<td>
<p>object of class PCAloc</p>
</td></tr>
<tr><td><code id="plot.PCAloc_+3A_type">type</code></td>
<td>
<p>character indicating the type of plot, see details.</p>
</td></tr>
<tr><td><code id="plot.PCAloc_+3A_...">...</code></td>
<td>
<p>further arguments passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns plots in ggplot2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set seed
set.seed(236)

# create data and setup
data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariances
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# calculate sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# align loadings
pca$PC = align_PC(PC = pca$PC, N = pca$N, p = pca$p, type = "mean")

# plot different PCA plots
plot(x = pca, type = "score_distances", groups = groups, X = data, ssMRCD = covs, k = 2)
plot(x = pca, type = "biplot", color = "variable")
plot(x = pca, type = "scores", groups = groups, X = data, ssMRCD = covs, k = 1)
plot(x = pca, type = "screeplot")
plot(x = pca, type = "loadings", k = 1)

</code></pre>

<hr>
<h2 id='plot.ssMRCD'>Plot Method for ssMRCD Object</h2><span id='topic+plot.ssMRCD'></span>

<h3>Description</h3>

<p>Plots diagnostics for function output of <code><a href="#topic+ssMRCD">ssMRCD</a></code> regarding convergence behavior
and the resulting covariances matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssMRCD'
plot(
  x,
  type = c("convergence", "ellipses"),
  centersN = NULL,
  colour_scheme = "none",
  xlim_upper = 9,
  manual_rescale = 1,
  legend = TRUE,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ssMRCD_+3A_x">x</code></td>
<td>
<p>object of class <code>"ssMRCD"</code>.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_type">type</code></td>
<td>
<p>type of plot, possible values are <code>"convergence"</code> and <code>"ellipses"</code>. See details.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_centersn">centersN</code></td>
<td>
<p>for plot type <code>"ellipses"</code> a matrix specifying the positions of
the centers of the covariance estimation centers, see also <code><a href="#topic+geo_weights">geo_weights</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_colour_scheme">colour_scheme</code></td>
<td>
<p>coloring scheme used for plot type <code>"ellipses"</code>, either <code>"trace"</code> or <code>"regularity"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_xlim_upper">xlim_upper</code></td>
<td>
<p>numeric giving the upper x limit for plot type <code>"convergence"</code>.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_manual_rescale">manual_rescale</code></td>
<td>
<p>for plot type <code>"ellipses"</code> numeric used to re-scale ellipse sizes.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_legend">legend</code></td>
<td>
<p>logical, if color legend should be included.</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_xlim">xlim</code></td>
<td>
<p>vector of xlim (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_ylim">ylim</code></td>
<td>
<p>vector of ylim (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ssMRCD_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type = "convergence"</code> a plot is produced displaying the convergence behaviour.
Each line represents a different initial value used for the c-step iteration. On the x-axis the
iteration step is plotted with the corresponding value of the objective function. Not monotonically
lines are plotted in red. <br />
</p>
<p>For <code>type = "ellipses"</code> and more than a 2-dimensional data setting plotting the exact tolerance ellipse is
not possible anymore. Instead the two eigenvectors with highest eigenvalue from the
MCD used on the full data set without neighborhood assignments are taken and used as axis for
the tolerance ellipses of the ssMRCD covariance estimators. The tolerance ellipse for the global MCD
covariance is plotted in grey in the upper left corner. It is possible to set the colour scheme
to <code>"trace"</code> to see the overall amount of variabilty and compare the plotted covariance and
the real trace to see how much variance is not plotted. For <code>"regularity"</code> the regularization of each
covariance is shown.
</p>


<h3>Value</h3>

<p>Returns plots of the ssMRCD methodology and results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssMRCD">ssMRCD</a>, <a href="#topic+summary.ssMRCD">summary.ssMRCD</a>,
<a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a>, <a href="#topic+plot.locOuts">plot.locOuts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(1)

# create data set
data = matrix(rnorm(2000), ncol = 4)
coords = matrix(rnorm(1000), ncol = 2)
groups = sample(1:10, 500, replace = TRUE)
lambda = 0.3

# calculate ssMRCD by using the local outlier detection method
outs = local_outliers_ssMRCD(data = data,
                             coords = coords,
                             groups = groups,
                             lambda = lambda,
                             k = 10)

# plot ssMRCD object included in outs
plot(x = outs$ssMRCD,
     centersN = outs$centersN,
     colour_scheme = "trace",
     legend = FALSE)

</code></pre>

<hr>
<h2 id='rescale_weights'>Rescale Weight Matrix</h2><span id='topic+rescale_weights'></span>

<h3>Description</h3>

<p>Given a matrix with values for neighborhood influences the function rescales
the matrix in order to get an appropriate weight matrix used for the function <code><a href="#topic+ssMRCD">ssMRCD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_weights(W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_weights_+3A_w">W</code></td>
<td>
<p>weight matrix with diagonals equal to zero and at least one positive entry per row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An appropriately scaled weight matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssMRCD">ssMRCD</a>, <a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a>, <a href="#topic+geo_weights">geo_weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
W = matrix(c(0, 1, 2,
             1, 0, 1,
             2, 1, 0), nrow = 3)
rescale_weights(W)

</code></pre>

<hr>
<h2 id='residuals.ssMRCD'>Extracting Residuals from Local Fit</h2><span id='topic+residuals.ssMRCD'></span>

<h3>Description</h3>

<p>Extracting Residuals from Local Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssMRCD'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.ssMRCD_+3A_object">object</code></td>
<td>
<p><code>ssMRCD</code> object, see <code><a href="#topic+ssMRCD">ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.ssMRCD_+3A_...">...</code></td>
<td>
<p>see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other input variables are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>remove_outliers</code> </td><td style="text-align: left;"> logical (default <code>FALSE</code>). If TRUE, only residuals
   from not outlying observations are calculated. If FALSE, trimmed residuals are used (see <code>alpha</code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>X</code> </td><td style="text-align: left;"> matrix of new data, if data from the <code>ssMRCD</code> object is used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>groups</code> </td><td style="text-align: left;"> vector of groups for new data, if <code>NULL</code> data from the <code>ssMRCD</code> object is used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mean</code> </td><td style="text-align: left;"> logical (default <code>FALSE</code>), specifying if mean of trimmed
   observations is returned or all residuals. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If <code>X</code> and <code>groups</code> are provided, <code>alpha</code> is set to one and all residuals are used.
If <code>remove_outliers</code> is TRUE, <code>alpha</code> is set to 1 automatically.
</p>


<h3>Value</h3>

<p>Returns either all residuals or the mean of the residual norms lower than the <code>alpha</code>- Quantile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
localCovs = ssMRCD(x, weights = W, lambda = 0.5)

# residuals of model
residuals(localCovs, remove_outliers = TRUE, mean = FALSE)

# residuals of new data
residuals(localCovs,
      X = matrix(rnorm(20), ncol = 2, nrow = 10),
      groups = rep(2, 10),
      mean =TRUE)

</code></pre>

<hr>
<h2 id='restructure_as_list'>Restructure Data Matrix as List</h2><span id='topic+restructure_as_list'></span>

<h3>Description</h3>

<p>This function restructures neighborhood information given by a data matrix
containing all information and one neighborhood assignment vector. It returns a list
of data matrices used in <code><a href="#topic+ssMRCD">ssMRCD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restructure_as_list(data, groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restructure_as_list_+3A_data">data</code></td>
<td>
<p>data matrix with all observations.</p>
</td></tr>
<tr><td><code id="restructure_as_list_+3A_groups">groups</code></td>
<td>
<p>numeric neighborhood assignment vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the observations per neighborhood assignment.
The list is sorted according to the order of the first appearance in the groups vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data matrix
data = matrix(rnorm(n = 3000), ncol = 3)
N_assign = sample(x = 1:10, size = 1000, replace = TRUE)

restructure_as_list(data, N_assign)

</code></pre>

<hr>
<h2 id='scale_ssMRCD'>Scale Data Locally</h2><span id='topic+scale_ssMRCD'></span>

<h3>Description</h3>

<p>Scale Data Locally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_ssMRCD(
  ssMRCD,
  X = NULL,
  groups = NULL,
  multivariate = FALSE,
  center_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_ssMRCD_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p><code>ssMRCD</code> object, see <code><a href="#topic+ssMRCD">ssMRCD</a></code></p>
</td></tr>
<tr><td><code id="scale_ssMRCD_+3A_x">X</code></td>
<td>
<p>matrix, new data to scale with ssMRCD estimation.</p>
</td></tr>
<tr><td><code id="scale_ssMRCD_+3A_groups">groups</code></td>
<td>
<p>vector, group assignments of new data <code>X</code>.</p>
</td></tr>
<tr><td><code id="scale_ssMRCD_+3A_multivariate">multivariate</code></td>
<td>
<p>logical, <code>TRUE</code> if multivariate structure should be used.
Otherwise, univariate variances from the ssMRCD estimator is used.</p>
</td></tr>
<tr><td><code id="scale_ssMRCD_+3A_center_only">center_only</code></td>
<td>
<p>logical, if <code>TRUE</code> observations are only centered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix of observations. If <code>X = NULL</code> X from the ssMRCD object is
used and sorted according to group numbering.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssMRCD">ssMRCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
localCovs = ssMRCD(x, weights = W, lambda = 0.5)

# scale used data
scale_ssMRCD(localCovs,
      multivariate = TRUE)

# scale new data
scale_ssMRCD(localCovs,
      X = matrix(rnorm(20), ncol = 2, nrow = 10),
      groups = rep(2, 10),
      multivariate =TRUE)
</code></pre>

<hr>
<h2 id='scores'>Calculate Scores for local sparse PCA</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>Calculate Scores for local sparse PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(X, PC, groups, ssMRCD = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scores_+3A_x">X</code></td>
<td>
<p>data set as matrix.</p>
</td></tr>
<tr><td><code id="scores_+3A_pc">PC</code></td>
<td>
<p>loading matrix.</p>
</td></tr>
<tr><td><code id="scores_+3A_groups">groups</code></td>
<td>
<p>vector of grouping structure (numeric).</p>
</td></tr>
<tr><td><code id="scores_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p>ssMRCD object used for scaling <code>X</code>. If <code>NULL</code> no scaling and centering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with scores and univariately and locally centered and scaled observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssMRCD">ssMRCD</a></code>, <code><a href="#topic+scale_ssMRCD">scale_ssMRCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
loccovs = ssMRCD(x, weights = W, lambda = 0.5)

# calculate PCA
pca = sparsePCAloc(eta = 1, gamma = 0.5, cor = FALSE,
                   COVS = loccovs$MRCDcov,
                   increase_rho = list(FALSE, 20, 1))

# calculate scores
scores(X = rbind(x1, x2), PC = pca$PC,
       groups = rep(c(1,2), each = 100), ssMRCD = loccovs)
</code></pre>

<hr>
<h2 id='scores.OD'>Orthogonal Distances for PCAloc</h2><span id='topic+scores.OD'></span>

<h3>Description</h3>

<p>Orthogonal Distances for PCAloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores.OD(X, PC, groups, ssMRCD)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scores.OD_+3A_x">X</code></td>
<td>
<p>data matrix of observations.</p>
</td></tr>
<tr><td><code id="scores.OD_+3A_pc">PC</code></td>
<td>
<p>loadings of sparse local PCA.</p>
</td></tr>
<tr><td><code id="scores.OD_+3A_groups">groups</code></td>
<td>
<p>grouping vector for locality.</p>
</td></tr>
<tr><td><code id="scores.OD_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p>ssMRCD object used for PCA calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of orthogonal distances of observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scores">scores</a></code>, <code><a href="#topic+scores.SD">scores.SD</a></code>, <code><a href="#topic+sparsePCAloc">sparsePCAloc</a></code>, <code><a href="#topic+scale_ssMRCD">scale_ssMRCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
loccovs = ssMRCD(x, weights = W, lambda = 0.5)

# calculate PCA
pca = sparsePCAloc(eta = 1, gamma = 0.5, cor = FALSE,
                   COVS = loccovs$MRCDcov,
                   increase_rho = list(FALSE, 20, 1))

# calculate scores
scores.OD(X = rbind(x1, x2), PC = pca$PC,
          groups = rep(c(1,2), each = 100), ssMRCD = loccovs)

</code></pre>

<hr>
<h2 id='scores.SD'>Score Distances for PCAloc</h2><span id='topic+scores.SD'></span>

<h3>Description</h3>

<p>Score Distances for PCAloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores.SD(X, PC, groups, ssMRCD)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scores.SD_+3A_x">X</code></td>
<td>
<p>data matrix of observations.</p>
</td></tr>
<tr><td><code id="scores.SD_+3A_pc">PC</code></td>
<td>
<p>loadings of sparse local PCA.</p>
</td></tr>
<tr><td><code id="scores.SD_+3A_groups">groups</code></td>
<td>
<p>grouping vector for locality.</p>
</td></tr>
<tr><td><code id="scores.SD_+3A_ssmrcd">ssMRCD</code></td>
<td>
<p>ssMRCD object used for PCA calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of score distances of observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scores">scores</a></code>, <code><a href="#topic+scores.OD">scores.OD</a></code>, <code><a href="#topic+sparsePCAloc">sparsePCAloc</a></code>, <code><a href="#topic+scale_ssMRCD">scale_ssMRCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
loccovs = ssMRCD(x, weights = W, lambda = 0.5)

# calculate PCA
pca = sparsePCAloc(eta = 1, gamma = 0.5, cor = FALSE,
                   COVS = loccovs$MRCDcov,
                   increase_rho = list(FALSE, 20, 1))

# calculate scores
scores.SD(X = rbind(x1, x2), PC = pca$PC,
          groups = rep(c(1,2), each = 100), ssMRCD = loccovs)

</code></pre>

<hr>
<h2 id='screeplot.PCAloc'>Screeplot for PCAloc</h2><span id='topic+screeplot.PCAloc'></span>

<h3>Description</h3>

<p>Screeplot for PCAloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCAloc'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.PCAloc_+3A_x">x</code></td>
<td>
<p>object of class PCAloc.</p>
</td></tr>
<tr><td><code id="screeplot.PCAloc_+3A_...">...</code></td>
<td>
<p>other input arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters that can be given to the function are: </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>text</code> </td><td style="text-align: left;"> logical if text should be plotted  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>size</code> </td><td style="text-align: left;"> text size </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>cutoff</code> </td><td style="text-align: left;"> cutoff line for scree plot  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>groupnames</code> </td><td style="text-align: left;"> name of groups   </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>textrotate</code> </td><td style="text-align: left;"> angle of text, if text is plotted.   </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns version of scree plot and cumulative explained variance per group for PCAloc object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(236)
data = matrix(rnorm(2000), ncol = 4)
groups = sample(1:10, 500, replace = TRUE)
W = time_weights(N = 10, c(3,2,1))

# calculate covariance matrices
covs = ssMRCD(data, groups = groups, weights = W, lambda = 0.3)

# sparse PCA
pca = sparsePCAloc(eta = 0.3, gamma = 0.7, cor = FALSE, COVS = covs$MRCDcov,
             n_max = 1000, increase_rho = list(TRUE, 50, 1), trace = FALSE)

# plot biplot
screeplot(pca, text = TRUE, cutoff = 0.8, size = 2)
</code></pre>

<hr>
<h2 id='select_smoothing'>Optimal Smoothing Parameter for ssMRCD based on Residuals</h2><span id='topic+select_smoothing'></span>

<h3>Description</h3>

<p>The optimal smoothing value for the ssMRCD estimator is based on the residuals and the
trimmed mean of the norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_smoothing(
  X,
  groups,
  weights,
  lambda = seq(0, 1, 0.1),
  TM = NULL,
  alpha = 0.75,
  seed = 123436,
  return_all = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_smoothing_+3A_x">X</code></td>
<td>
<p>data matrix containing observations.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_groups">groups</code></td>
<td>
<p>grouping vector corresponding to <code>X</code>.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_weights">weights</code></td>
<td>
<p>weight matrix for groups, see <code><a href="#topic+rescale_weights">rescale_weights</a></code>, and <code><a href="#topic+geo_weights">geo_weights</a></code>.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_lambda">lambda</code></td>
<td>
<p>vector of parameter values for smoothing, between 0 and 1.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_tm">TM</code></td>
<td>
<p>target matrix, if not given MCD (or MRCD if non regular) is used with default values and <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_alpha">alpha</code></td>
<td>
<p>percentage of outliers to be expected.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_seed">seed</code></td>
<td>
<p>seed for ssMRCD calculations.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_return_all">return_all</code></td>
<td>
<p>logical, if FALSE the function returns only the optimal lambda.</p>
</td></tr>
<tr><td><code id="select_smoothing_+3A_cores">cores</code></td>
<td>
<p>integer, number of cores used for parallel computing.</p>
</td></tr>
</table>


<h3>Value</h3>


<table>
<tr>
 <td style="text-align: left;">
   <code>lambda_opt</code> </td><td style="text-align: left;"> optimal lambda for smoothing. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>COVS</code> </td><td style="text-align: left;"> <code>ssMRCD</code> object with optimal parameter setting. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>plot</code> </td><td style="text-align: left;"> plot for optimal parameter setting. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>residuals</code> </td><td style="text-align: left;"> mean of norm of residuals for varying lambda. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

select_smoothing (X = rbind(x1, x2),
                 groups = rep(c(1,2), each = 100),
                 weights = W,
                 lambda = seq(0, 1, 0.1),
                 return_all = TRUE,
                 cores = 1)
</code></pre>

<hr>
<h2 id='select_sparsity'>Optimal Sparsity Parameter Selection for PCA</h2><span id='topic+select_sparsity'></span>

<h3>Description</h3>

<p>Optimal Sparsity Parameter Selection for PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_sparsity(
  COVS,
  k = 1,
  rho = NULL,
  cor = FALSE,
  eta = seq(0, 5, by = 0.2),
  gamma = seq(0, 1, 0.05),
  eps_threshold = 0.001,
  eps_root = 0.1,
  eps_ADMM = 1e-04,
  n_max = 300,
  adjust_eta = FALSE,
  cores = 1,
  increase_rho = list(TRUE, 100, 1),
  convergence_plot = FALSE,
  trace = FALSE,
  stop.sparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_sparsity_+3A_covs">COVS</code></td>
<td>
<p>list of covariance or correlation matrices.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_k">k</code></td>
<td>
<p>number of components to be returned.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_rho">rho</code></td>
<td>
<p>penalty parameter for ADMM.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_cor">cor</code></td>
<td>
<p>logical, if starting values for covariances or correlation matrices should be used.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_eta">eta</code></td>
<td>
<p>vector of possible values for degree of sparsity.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_gamma">gamma</code></td>
<td>
<p>vector of possible values for distribution of sparsity. If only one value is provided, the optimal eta is calculated.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_eps_threshold">eps_threshold</code></td>
<td>
<p>tolerance for thresholding.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_eps_root">eps_root</code></td>
<td>
<p>tolerance for root finder.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_eps_admm">eps_ADMM</code></td>
<td>
<p>tolerance for ADMM iterations.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_n_max">n_max</code></td>
<td>
<p>maximal number of ADMM iterations.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_adjust_eta">adjust_eta</code></td>
<td>
<p>if eta should be adjusted for further components.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallel computing.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_increase_rho">increase_rho</code></td>
<td>
<p>list of settings for improved automated calculation and convergence. See Details.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_convergence_plot">convergence_plot</code></td>
<td>
<p>logical, if convergence plot should be plotted. Not applicable for <code>cores &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_trace">trace</code></td>
<td>
<p>logical, if messages should be displayed. Not applicable for <code>cores &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="select_sparsity_+3A_stop.sparse">stop.sparse</code></td>
<td>
<p>calculate if AUC should be calculated for PCAs until full sparsity is reached (<code>TRUE</code>)
or over the whole eta range (<code>FALSE</code>). Set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>increase_rho</code> consists of a logical indicating if rho should be adjusted
if algorithm did not converged within the given maximal number of iterations. Two integers specify the
maximal <code>rho</code> that is allowed and the step size.
</p>


<h3>Value</h3>

<p>Returns list with </p>

<table>
<tr>
 <td style="text-align: left;">
   <code>PCA</code> </td><td style="text-align: left;"> object of type PCAloc.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>PC</code> </td><td style="text-align: left;"> local loadings of PCA</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>gamma</code> </td><td style="text-align: left;"> optimal value for gamma. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>eta</code> </td><td style="text-align: left;"> optimal value for eta. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>eta_tpo</code> </td><td style="text-align: left;"> values of Trade-Off-Product for eta from optimization process. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>auc</code> </td><td style="text-align: left;"> area under the curve for varying gamma values. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>pars</code> </td><td style="text-align: left;"> parameters and respective sparsity entrywise and mixed and explained variance. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>plot</code> </td><td style="text-align: left;"> ggplot object for optimal parameter selection. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>plot_info</code> </td><td style="text-align: left;"> additional data for plotting functions. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>
C1 = matrix(c(1,0,0,0.9), ncol = 2)
C2 = matrix(c(1.1, 0.1, 0.1, 1), ncol = 2)
C3 = matrix(c(1.2, 0.2, 0.2, 1), ncol = 2)

select_sparsity(COVS = list(C1, C2, C3),
                k = 1,
                rho = 5,
                eta = c(0, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5 ,0.75,  1),
                gamma =c(0, 0.25, 0.5, 0.75, 1),
                eps_threshold = 0.005,
                increase_rho = list(FALSE, 20, 5))

</code></pre>

<hr>
<h2 id='sparsePCAloc'>Calculate Sparse Principle Components</h2><span id='topic+sparsePCAloc'></span>

<h3>Description</h3>

<p>Calculate Sparse Principle Components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsePCAloc(
  eta,
  gamma,
  COVS,
  cor = FALSE,
  rho = NULL,
  k = NULL,
  eps_threshold = NULL,
  eps_ADMM = 1e-04,
  n_max = 200,
  eps_root = 0.1,
  maxiter_root = 50,
  increase_rho = list(TRUE, 100, 1),
  convergence_plot = TRUE,
  starting_value = NULL,
  adjust_eta = TRUE,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsePCAloc_+3A_eta">eta</code></td>
<td>
<p>numeric, degree of sparsity.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_gamma">gamma</code></td>
<td>
<p>numeric, distribution of sparsity.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_covs">COVS</code></td>
<td>
<p>list of covariance or correlation matrices.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_cor">cor</code></td>
<td>
<p>logical, if starting value for correlation or covariance matrices should be used.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_rho">rho</code></td>
<td>
<p>numeric bigger than zero, penalty for ADMM.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_k">k</code></td>
<td>
<p>number of components to calculate.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_eps_threshold">eps_threshold</code></td>
<td>
<p>tolerance for thresholding.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_eps_admm">eps_ADMM</code></td>
<td>
<p>tolerance for ADMM convergence.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_n_max">n_max</code></td>
<td>
<p>number of maximal iterations.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_eps_root">eps_root</code></td>
<td>
<p>tolerance for root finder.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_maxiter_root">maxiter_root</code></td>
<td>
<p>maximal number of iterations for root finder.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_increase_rho">increase_rho</code></td>
<td>
<p>list with entries for stable convergence. See Details.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_convergence_plot">convergence_plot</code></td>
<td>
<p>logical, if convergence plot should be displayed.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_starting_value">starting_value</code></td>
<td>
<p>optional given starting value.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_adjust_eta">adjust_eta</code></td>
<td>
<p>logical, if eta should be adjusted by the variance.</p>
</td></tr>
<tr><td><code id="sparsePCAloc_+3A_trace">trace</code></td>
<td>
<p>logical, if messages should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>increase_rho</code> consists of a logical indicating if rho should be adjusted
if algorithm did not converged within the given maximal number of iterations. Two integers specify the
maximal <code>rho</code> that is allowed and the step size.
</p>


<h3>Value</h3>

<p>An object of class <code>"PCAloc"</code> containing the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>PC</code> </td><td style="text-align: left;"> Matrix of dimension Np x k of stacked loading vectors.  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>p</code> </td><td style="text-align: left;"> Number of variables. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>N</code> </td><td style="text-align: left;"> Number of neighborhoods. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>k</code> </td><td style="text-align: left;"> Number of components. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>COVS</code> </td><td style="text-align: left;"> List of covariance matrices sorted by neighborhood. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>gamma</code> </td><td style="text-align: left;"> Sparsity distribution. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>eta</code> </td><td style="text-align: left;"> Amount of sparsity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>converged</code> </td><td style="text-align: left;"> Logical, if ADMM converged with given specifications. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>n_steps</code> </td><td style="text-align: left;"> Number of steps used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>summary</code> </td><td style="text-align: left;"> Description of result per component. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>residuals</code> </td><td style="text-align: left;"> Primary and secondary residuals. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>C1 = diag(c(1.1, 0.9, 0.6))
C2 = matrix(c(1.1, 0.1, -0.1,
              0.1, 1.0, -0.2,
             -0.1, -0.2, 0.7), ncol = 3)
C3 = (C1 + C2)/2

sparsePCAloc(eta = 1, gamma = 0.5, cor = FALSE, COVS = list(C1, C2, C3),
             n_max = 100, increase_rho = list(FALSE, 100, 1))

</code></pre>

<hr>
<h2 id='sparsity_entries'>Entry-wise Sparsity in the Loadings</h2><span id='topic+sparsity_entries'></span>

<h3>Description</h3>

<p>Entry-wise Sparsity in the Loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity_entries(PC, N, p, tolerance = 0, k = 1, scaled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsity_entries_+3A_pc">PC</code></td>
<td>
<p>matrix-like object of PCs.</p>
</td></tr>
<tr><td><code id="sparsity_entries_+3A_n">N</code></td>
<td>
<p>integer, number of groups.</p>
</td></tr>
<tr><td><code id="sparsity_entries_+3A_p">p</code></td>
<td>
<p>integer, number of variables.</p>
</td></tr>
<tr><td><code id="sparsity_entries_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for sparsity.</p>
</td></tr>
<tr><td><code id="sparsity_entries_+3A_k">k</code></td>
<td>
<p>integer or integer vector of which component should be used.</p>
</td></tr>
<tr><td><code id="sparsity_entries_+3A_scaled">scaled</code></td>
<td>
<p>logical, if total number or percentage of possible sparse entries should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a percentage (<code>scaled = TRUE</code>) or the amount of zero-values entries (<code>scaled = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PC = matrix(c(1,0,2,3,0,7,0,1,0,1,0.001,0), ncol = 2)
sparsity_entries(PC, N = 2, p = 3, tolerance = 0, k = 1, scaled = FALSE)
sparsity_entries(PC, N = 2, p = 3, tolerance = 0.001, k = 2, scaled = TRUE)

</code></pre>

<hr>
<h2 id='sparsity_group'>Group-wise Sparsity in the Loadings</h2><span id='topic+sparsity_group'></span>

<h3>Description</h3>

<p>Group-wise Sparsity in the Loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity_group(PC, N, p, tolerance = 0, k = 1, scaled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsity_group_+3A_pc">PC</code></td>
<td>
<p>matrix-like object of PCs.</p>
</td></tr>
<tr><td><code id="sparsity_group_+3A_n">N</code></td>
<td>
<p>integer, number of groups.</p>
</td></tr>
<tr><td><code id="sparsity_group_+3A_p">p</code></td>
<td>
<p>integer, number of variables.</p>
</td></tr>
<tr><td><code id="sparsity_group_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for sparsity.</p>
</td></tr>
<tr><td><code id="sparsity_group_+3A_k">k</code></td>
<td>
<p>integer, which components should be used. Does not work for multiple PCs simultaneously.</p>
</td></tr>
<tr><td><code id="sparsity_group_+3A_scaled">scaled</code></td>
<td>
<p>logical, if total number or percentage of possible sparse entries should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a matrix of percentages (<code>scaled = TRUE</code>) or the amounts
of zero-values entries (<code>scaled = FALSE</code>) for each group/neighborhood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PC = matrix(c(1,0,2,3,0,7,0,1,0,1,0.001,0), ncol = 2)
sparsity_group(PC, N = 2, p = 3, tolerance = 0, k = 1, scaled = FALSE)
sparsity_group(PC, N = 2, p = 3, tolerance = 0.001, k = 2, scaled = TRUE)
</code></pre>

<hr>
<h2 id='sparsity_mixed'>Mixed Sparsity of the Loadings</h2><span id='topic+sparsity_mixed'></span>

<h3>Description</h3>

<p>Mixed Sparsity of the Loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity_mixed(PC, p, N, k = 1, tolerance = 0.001, mean = "arithmetic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsity_mixed_+3A_pc">PC</code></td>
<td>
<p>matrix-like object of PCs.</p>
</td></tr>
<tr><td><code id="sparsity_mixed_+3A_p">p</code></td>
<td>
<p>integer, number of variables.</p>
</td></tr>
<tr><td><code id="sparsity_mixed_+3A_n">N</code></td>
<td>
<p>integer, number of groups.</p>
</td></tr>
<tr><td><code id="sparsity_mixed_+3A_k">k</code></td>
<td>
<p>integer, which components should be used. Does not work for multiple PCs simultaneously.</p>
</td></tr>
<tr><td><code id="sparsity_mixed_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for sparsity.</p>
</td></tr>
<tr><td><code id="sparsity_mixed_+3A_mean">mean</code></td>
<td>
<p>if <code>"arithmetic"</code> or <code>"geometric"</code> mean should be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the geometric mean of the percentage of entry-wise and group-wise sparsity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PC = matrix(c(1,0,2,3,0,7,0,1,0,1,0.001,0), ncol = 2)
sparsity_mixed(PC, N = 2, p = 3, tolerance = 0, k = 1)
sparsity_mixed(PC, N = 2, p = 3, tolerance = 0.001, k = 2, mean = "geometric")
</code></pre>

<hr>
<h2 id='sparsity_summary'>Entry-wise Sparsity in the Loadings per Group</h2><span id='topic+sparsity_summary'></span>

<h3>Description</h3>

<p>Entry-wise Sparsity in the Loadings per Group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsity_summary(PC, N, p, tolerance = 0, k = 1, scaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsity_summary_+3A_pc">PC</code></td>
<td>
<p>matrix-like object of PCs.</p>
</td></tr>
<tr><td><code id="sparsity_summary_+3A_n">N</code></td>
<td>
<p>integer, number of groups.</p>
</td></tr>
<tr><td><code id="sparsity_summary_+3A_p">p</code></td>
<td>
<p>integer, number of variables.</p>
</td></tr>
<tr><td><code id="sparsity_summary_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for sparsity.</p>
</td></tr>
<tr><td><code id="sparsity_summary_+3A_k">k</code></td>
<td>
<p>integer or integer vector of which component should be used.</p>
</td></tr>
<tr><td><code id="sparsity_summary_+3A_scaled">scaled</code></td>
<td>
<p>logical, if total number or percentage of possible sparse entries should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a matrix of percentages (<code>scaled = TRUE</code>) or the amounts
of zero-values entries (<code>scaled = FALSE</code>) for each group/neighborhood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PC = matrix(c(1,0,2,3,0,7,0,1,0,1,0.001,0), ncol = 2)
sparsity_summary(PC, N = 2, p = 3, tolerance = 0, k = 1, scaled = FALSE)
sparsity_summary(PC, N = 2, p = 3, tolerance = 0.001, k = 2, scaled = TRUE)
</code></pre>

<hr>
<h2 id='ssMRCD'>Spatially Smoothed MRCD Estimator</h2><span id='topic+ssMRCD'></span>

<h3>Description</h3>

<p>The ssMRCD function calculates the spatially smoothed MRCD estimator from Puchhammer and Filzmoser (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssMRCD(
  x,
  groups = NULL,
  weights,
  lambda,
  TM = NULL,
  alpha = 0.75,
  maxcond = 50,
  maxcsteps = 200,
  n_initialhsets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssMRCD_+3A_x">x</code></td>
<td>
<p>a list of matrices containing the observations per neighborhood sorted which can be obtained by the function <code><a href="#topic+restructure_as_list">restructure_as_list</a></code>, or matrix or data frame containing data.
If matrix or data.frame, group vector has to be given.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_groups">groups</code></td>
<td>
<p>vector of neighborhood assignments</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_weights">weights</code></td>
<td>
<p>weighting matrix, symmetrical, rows sum up to one and diagonals need to be zero (see also <code><a href="#topic+geo_weights">geo_weights</a></code> or <code><a href="#topic+rescale_weights">rescale_weights</a></code> .</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_lambda">lambda</code></td>
<td>
<p>numeric between 0 and 1.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_tm">TM</code></td>
<td>
<p>target matrix (optional), default value is the covMcd from robustbase.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_alpha">alpha</code></td>
<td>
<p>numeric, proportion of values included, between 0.5 and 1.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_maxcond">maxcond</code></td>
<td>
<p>optional, maximal condition number used for rho-estimation.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of c-steps before algorithm stops.</p>
</td></tr>
<tr><td><code id="ssMRCD_+3A_n_initialhsets">n_initialhsets</code></td>
<td>
<p>number of initial h-sets, default is 6 times number of neighborhoods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ssMRCD"</code> containing the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>MRCDcov</code> </td><td style="text-align: left;"> List of ssMRCD-covariance matrices sorted by neighborhood. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MRCDicov</code> </td><td style="text-align: left;"> List of inverse ssMRCD-covariance matrices sorted by neighborhood. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MRCDmu</code> </td><td style="text-align: left;"> List of ssMRCD-mean vectors sorted by neighborhood. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mX</code> </td><td style="text-align: left;"> List of data matrices sorted by neighborhood.</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>N</code> </td><td style="text-align: left;"> Number of neighborhoods. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mT</code> </td><td style="text-align: left;"> Target matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rho</code> </td><td style="text-align: left;"> Vector of regularization values sorted by neighborhood. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>alpha</code> </td><td style="text-align: left;"> Scalar what percentage of observations should be used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>h</code> </td><td style="text-align: left;"> Vector of how many observations are used per neighborhood, sorted. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numiter</code> </td><td style="text-align: left;"> The number of iterations for the best initial h-set combination. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>c_alpha</code> </td><td style="text-align: left;"> Consistency factor for normality. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>weights</code> </td><td style="text-align: left;"> The weighting matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lambda</code> </td><td style="text-align: left;"> Smoothing factor. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>obj_fun_values</code> </td><td style="text-align: left;"> A matrix with objective function values for all
initial h-set combinations (rows) and iterations (columns). </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>best6pack</code> </td><td style="text-align: left;"> initial h-set combinations with best objective function value
after c-step iterations. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Kcov</code> </td><td style="text-align: left;"> returns MRCD-estimates without smoothing. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Puchhammer P. and Filzmoser P. (2023): Spatially smoothed robust covariance estimation for local outlier detection. <a href="https://doi.org/10.48550/arXiv.2305.05371">doi:10.48550/arXiv.2305.05371</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ssMRCD">plot.ssMRCD</a>, <a href="#topic+summary.ssMRCD">summary.ssMRCD</a>, <a href="#topic+restructure_as_list">restructure_as_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data set
x1 = matrix(runif(200), ncol = 2)
x2 = matrix(rnorm(200), ncol = 2)
x = list(x1, x2)

# create weighting matrix
W = matrix(c(0, 1, 1, 0), ncol = 2)

# calculate ssMRCD
ssMRCD(x, weights = W, lambda = 0.5)
</code></pre>

<hr>
<h2 id='summary.locOuts'>Summary of Local Outlier Detection</h2><span id='topic+summary.locOuts'></span>

<h3>Description</h3>

<p>Prints a summary of the locOuts object obtained by the function <code><a href="#topic+local_outliers_ssMRCD">local_outliers_ssMRCD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locOuts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.locOuts_+3A_object">object</code></td>
<td>
<p>a locOuts object.</p>
</td></tr>
<tr><td><code id="summary.locOuts_+3A_...">...</code></td>
<td>
<p>further parameters passed on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the <code>locOuts</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.locOuts">plot.locOuts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed
set.seed(1)

# make locOuts object
data = matrix(rnorm(2000), ncol = 4)
coords = matrix(rnorm(1000), ncol = 2)
groups = sample(1:10, 500, replace = TRUE)
lambda = 0.3

# local outlier detection
outs = local_outliers_ssMRCD(data = data,
                             coords = coords,
                             groups = groups,
                             lambda = lambda,
                             k = 10)

# summary method
summary(outs)
</code></pre>

<hr>
<h2 id='summary.PCAloc'>Summary method for PCAloc</h2><span id='topic+summary.PCAloc'></span>

<h3>Description</h3>

<p>Summary method for PCAloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCAloc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PCAloc_+3A_object">object</code></td>
<td>
<p>object of class PCAloc</p>
</td></tr>
<tr><td><code id="summary.PCAloc_+3A_...">...</code></td>
<td>
<p>other input variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for PCAloc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparsePCAloc">sparsePCAloc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'
C1 = diag(c(1.1, 0.9, 0.6))
C2 = matrix(c(1.1, 0.1, -0.1,
              0.1, 1.0, -0.2,
             -0.1, -0.2, 0.7), ncol = 3)
C3 = (C1 + C2)/2

pca = sparsePCAloc(eta = 1, gamma = 0.5, cor = FALSE, COVS = list(C1, C2, C3),
             n_max = 100, increase_rho = list(FALSE, 100, 1), trace = FALSE)

summary(pca)
</code></pre>

<hr>
<h2 id='summary.ssMRCD'>Summary Method for ssMRCD Object</h2><span id='topic+summary.ssMRCD'></span>

<h3>Description</h3>

<p>Summarises most important information of output <code><a href="#topic+ssMRCD">ssMRCD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssMRCD'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ssMRCD_+3A_object">object</code></td>
<td>
<p>object of class <code>"ssMRCD"</code>, output of <code><a href="#topic+ssMRCD">ssMRCD</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ssMRCD_+3A_...">...</code></td>
<td>
<p>further parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the <code>ssMRCD</code> object.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ssMRCD">ssMRCD</a></code>, <code><a href="#topic+plot.ssMRCD">plot.ssMRCD</a></code>.
</p>

<hr>
<h2 id='time_weights'>Band weight matrix for time series groupings</h2><span id='topic+time_weights'></span>

<h3>Description</h3>

<p>Band weight matrix for time series groupings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_weights(N, off_diag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_weights_+3A_n">N</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="time_weights_+3A_off_diag">off_diag</code></td>
<td>
<p>vector for off-diagonal values unequal to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns weight matrix for time series groups appropriate for <code><a href="#topic+ssMRCD">ssMRCD</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geo_weights">geo_weights</a></code>, <code><a href="#topic+rescale_weights">rescale_weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time_weights(N = 10, off_diag = c(2,1))

</code></pre>

<hr>
<h2 id='weatherAUT2021'>Austrian Weather Data 2021</h2><span id='topic+weatherAUT2021'></span>

<h3>Description</h3>

<p>This data is a subset of the GeoSphere Austria monthly weather data of 2021
averaged using the median. Stations with missing values are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weatherAUT2021
</code></pre>


<h3>Format</h3>

<p>A data frame with 183 rows and 10 columns:
</p>

<dl>
<dt>name</dt><dd><p>Unique name of the weather station in German.</p>
</dd>
<dt>lon, lat</dt><dd><p>Longitude and latitude of the weather station.</p>
</dd>
<dt>alt</dt><dd><p>Altitude of the weather station (meter).</p>
</dd>
<dt>p</dt><dd><p>Average air pressure (hPa).</p>
</dd>
<dt>s</dt><dd><p>Monthly sum of sunshine duration (hours).</p>
</dd>
<dt>vv</dt><dd><p>Wind velocity (meter/second).</p>
</dd>
<dt>t</dt><dd><p>Air temperature in 2 meters above the ground in (C).</p>
</dd>
<dt>rsum</dt><dd><p>Average daily sum of precipitation (mm).</p>
</dd>
<dt>rel</dt><dd><p>Relative air humidity (percent).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The original data was downloaded here (December 2022): <a href="https://data.hub.geosphere.at/dataset/klima-v1-1m">https://data.hub.geosphere.at/dataset/klima-v1-1m</a>.
</p>


<h3>References</h3>

<p>Data Source: GeoSphere Austria - <a href="https://data.hub.geosphere.at">https://data.hub.geosphere.at</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weatherAUT2021)
summary(weatherAUT2021)
</code></pre>

<hr>
<h2 id='weatherHoheWarte'>Vienna Weather Time Series (1960-2023)</h2><span id='topic+weatherHoheWarte'></span>

<h3>Description</h3>

<p>This data is a subset of the GeoSphere Austria daily weather data of the time 1960-2023
for the weather station Hohe Warte in Vienna.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weatherHoheWarte
</code></pre>


<h3>Format</h3>

<p>A data frame with 23372 rows and 18 columns including 13 weather measurements:
</p>

<dl>
<dt>time</dt><dd><p>Time of measurement in date format.</p>
</dd>
<dt>cloud_cover</dt><dd><p>Daily mean of cloud coverage, values between 1 and 100.</p>
</dd>
<dt>global_radiation</dt><dd><p>Daily sum of global radiation (J/cm^2).</p>
</dd>
<dt>vapor_pressure</dt><dd><p>Daily mean of vapour pressuer (hPa).</p>
</dd>
<dt>max_wind_speed</dt><dd><p>Maximal wind speed (m/s).</p>
</dd>
<dt>air_pressure</dt><dd><p>Daily mean of air pressure (hPa).</p>
</dd>
<dt>relative_humidity</dt><dd><p>Daily mean of relative humidity (percent).</p>
</dd>
<dt>precipitation</dt><dd><p>Daily sum of precepitation (mm).</p>
</dd>
<dt>sight</dt><dd><p>Sight distance at 1pm (m).</p>
</dd>
<dt>sunshine_duration</dt><dd><p>Daily sum of sunshine duration (h).</p>
</dd>
<dt>temperature_max</dt><dd><p>Daily maximum of temperature at 2m air height (C).</p>
</dd>
<dt>temperature_min</dt><dd><p>Daily minimum of temperature at 2m air height (C).</p>
</dd>
<dt>temperature_mean</dt><dd><p>Daily mean of temperature at 2m air height (C).</p>
</dd>
<dt>wind_velocity</dt><dd><p>Daily mean of wind speed (m/s).</p>
</dd>
<dt>year</dt><dd><p>Year of measurement.</p>
</dd>
<dt>month</dt><dd><p>Month of measurement.</p>
</dd>
<dt>day</dt><dd><p>Day of the year of measurement.</p>
</dd>
<dt>season</dt><dd><p>Season of measuremen (1 = winter, 2 = spring, 3 = summer, 4 = fall).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The original data was downloaded here (April 2024): <a href="https://data.hub.geosphere.at/dataset/klima-v2-1d">https://data.hub.geosphere.at/dataset/klima-v2-1d</a>.
</p>


<h3>References</h3>

<p>Data Source: GeoSphere Austria - <a href="https://data.hub.geosphere.at">https://data.hub.geosphere.at</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weatherHoheWarte)
summary(weatherHoheWarte)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
