<!DOCTYPE html><html><head><title>Help for package crossmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crossmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autonames'><p>Automatically generate names for vectors</p></a></li>
<li><a href='#cross_fit'><p>Cross map a model across multiple formulas, subsets, and weights</p></a></li>
<li><a href='#cross_fit_glm'><p>Cross fit generalized linear models</p></a></li>
<li><a href='#cross_fit_robust'><p>Cross fit robust linear models</p></a></li>
<li><a href='#cross_join'><p>Crossing join</p></a></li>
<li><a href='#cross_list'><p>List all combinations of values</p></a></li>
<li><a href='#crossmap-package'><p>crossmap: Apply Functions to All Combinations of List Elements</p></a></li>
<li><a href='#future_map_vec'><p>Parallelized mapping functions that automatically determine type</p></a></li>
<li><a href='#future_xmap'><p>Map over each combination of list elements simultaneously via futures</p></a></li>
<li><a href='#future_xmap_mat'><p>Parallelized cross map returning a matrix or array</p></a></li>
<li><a href='#map_vec'><p>Mapping functions that automatically determine type</p></a></li>
<li><a href='#tidy_glance'><p>Turn an object into a tidy tibble with glance information</p></a></li>
<li><a href='#xmap'><p>Map over each combination of list elements</p></a></li>
<li><a href='#xmap_mat'><p>Return a table applying a function to all combinations of list elements</p></a></li>
<li><a href='#xpluck'><p>Get one or more elements deep within a nested data structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Apply Functions to All Combinations of List Elements</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an extension to the 'purrr' family of mapping
    functions to apply a function to each combination of elements in a
    list of inputs.  Also includes functions for automatically detecting
    output type in mapping functions, finding every combination of
    elements of lists or rows of data frames, and applying multiple models
    to multiple subsets of a dataset.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://crossmap.rossellhayes.com">https://crossmap.rossellhayes.com</a>,
<a href="https://github.com/rossellhayes/crossmap">https://github.com/rossellhayes/crossmap</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rossellhayes/crossmap/issues">https://github.com/rossellhayes/crossmap/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, cli, dplyr (&ge; 1.0.0), generics, lifecycle, purrr,
rlang, stats, utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, covr, crayon, estimatr, furrr, future, testthat,
tibble, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-12 20:40:53 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Rossell Hayes
    <a href="https://orcid.org/0000-0001-9412-0457"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Rossell Hayes &lt;alexander@rossellhayes.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-12 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autonames'>Automatically generate names for vectors</h2><span id='topic+autonames'></span>

<h3>Description</h3>

<p>Automatically generate names for vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autonames(x, ..., trimws = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autonames_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="autonames_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+format">format()</a></code></p>
</td></tr>
<tr><td><code id="autonames_+3A_trimws">trimws</code></td>
<td>
<p>Whether to trim whitespace surrounding automatically formatted
names.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the names of a named vector and the elements of an unnamed
vector formatted as characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>autonames(c(a = "apple", b = "banana", c = "cantaloupe"))
autonames(c("apple", "banana", "cantaloupe"))

autonames(10^(1:4))
autonames(10^(1:4), big.mark = ",")
autonames(10^(1:4), scientific = TRUE)
</code></pre>

<hr>
<h2 id='cross_fit'>Cross map a model across multiple formulas, subsets, and weights</h2><span id='topic+cross_fit'></span>

<h3>Description</h3>

<p>Applies a modeling function to every combination of a set of formulas and a
set of data subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_fit(
  data,
  formulas,
  cols = NULL,
  weights = NULL,
  clusters = NULL,
  families = NULL,
  fn = lm,
  fn_args = list(),
  tidy = tidy_glance,
  tidy_args = list(),
  errors = c("stop", "warn")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_fit_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_formulas">formulas</code></td>
<td>
<p>A list of formulas to apply to each subset of the data.
If named, these names will be used in the <code>model</code> column of the output.
Otherwise, the formulas will be converted to strings in the <code>model</code> column.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_cols">cols</code></td>
<td>
<p>Columns to subset the data.
Can be any expression supported by
&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;.
If <code><a href="base.html#topic+NULL">NULL</a></code>, the data is not subset into columns.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_weights">weights</code></td>
<td>
<p>A list of columns passed to <code>weights</code> in <code>fn</code>.
If one of the elements is <code><a href="base.html#topic+NULL">NULL</a></code> or <code><a href="base.html#topic+NA">NA</a></code>, that model will not
be weighted.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_clusters">clusters</code></td>
<td>
<p>A list of columns passed to <code>clusters</code> if supported by <code>fn</code>.
If one of the elements is <code><a href="base.html#topic+NULL">NULL</a></code> or <code><a href="base.html#topic+NA">NA</a></code>, that model will not
be clustered.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_families">families</code></td>
<td>
<p>A list of <a href="stats.html#topic+glm">glm</a> model families passed to <code>family</code> if
supported by <code>fn</code>.
Defaults to <code><a href="stats.html#topic+gaussian">gaussian(&quot;identity&quot;)</a></code>, the equivalent of <code><a href="stats.html#topic+lm">lm()</a></code>.
See <a href="stats.html#topic+family">family</a> for examples.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_fn">fn</code></td>
<td>
<p>The modeling function.
Either an unquoted function name or a <a href="purrr.html#topic+map">purrr</a>-style lambda
function with two arguments.
To use multiple modeling functions, see <code><a href="#topic+cross_fit_glm">cross_fit_glm()</a></code>.
Defaults to <a href="stats.html#topic+lm">lm</a>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_fn_args">fn_args</code></td>
<td>
<p>A list of additional arguments to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_tidy">tidy</code></td>
<td>
<p>A logical or function to use to tidy model output into
data.frame columns.
If <code>TRUE</code>, uses the default tidying function: <code><a href="#topic+tidy_glance">tidy_glance()</a></code>.
If <code>FALSE</code>, <code>NA</code>, or <code>NULL</code>, the untidied model output will be returned in
a list column named <code>fit</code>.
An alternative function can be specified with an unquoted function name or
a <a href="purrr.html#topic+map">purrr</a>-style lambda function with one argument (see usage
with <a href="broom.html#topic+tidy.lm">broom::tidy(conf.int = TRUE)</a> in examples).
Defaults to <a href="#topic+tidy_glance">tidy_glance</a>.</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_tidy_args">tidy_args</code></td>
<td>
<p>A list of additional arguments to the <code>tidy</code> function</p>
</td></tr>
<tr><td><code id="cross_fit_+3A_errors">errors</code></td>
<td>
<p>If <code>"stop"</code>, the default, the function will stop and return an
error if any subset produces an error.
If <code>"warn"</code>, the function will produce a warning for subsets that produce
an error and return results for all subsets that do not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a column for the model formula,
columns for subsets,
columns for the model family and type (if applicable),
columns for the weights and clusters (if applicable),
and columns of tidy model output or a list column of models
(if <code>tidy = FALSE</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross_fit_glm">cross_fit_glm()</a></code> to map a model across multiple model types.
</p>
<p><code><a href="#topic+cross_fit_robust">cross_fit_robust()</a></code> to map robust linear models.
</p>
<p><code><a href="#topic+xmap">xmap()</a></code> to apply any function to combinations of inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_fit(mtcars, mpg ~ wt, cyl)
cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl)
cross_fit(mtcars, list(wt = mpg ~ wt, hp = mpg ~ hp), cyl)

cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), c(cyl, vs))
cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), dplyr::starts_with("c"))

cross_fit(mtcars, list(hp = mpg ~ hp), cyl, weights = wt)
cross_fit(mtcars, list(hp = mpg ~ hp), cyl, weights = c(wt, NA))

cross_fit(
  mtcars, list(vs ~ cyl, vs ~ hp), am,
  fn = glm, fn_args = list(family = binomial(link = logit))
)
cross_fit(
  mtcars, list(vs ~ cyl, vs ~ hp), am,
  fn = ~ glm(.x, .y, family = binomial(link = logit))
)

cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy = FALSE)
cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy_args = c(conf.int = TRUE))

cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy = broom::tidy)
cross_fit(
  mtcars, list(mpg ~ wt, mpg ~ hp), cyl,
  tidy = ~ broom::tidy(., conf.int = TRUE)
)
</code></pre>

<hr>
<h2 id='cross_fit_glm'>Cross fit generalized linear models</h2><span id='topic+cross_fit_glm'></span>

<h3>Description</h3>

<p>Cross fit generalized linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_fit_glm(
  data,
  formulas,
  cols = NULL,
  weights = NULL,
  families = gaussian(link = identity),
  fn_args = list(),
  tidy = tidy_glance,
  tidy_args = list(),
  errors = c("stop", "warn")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_fit_glm_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_formulas">formulas</code></td>
<td>
<p>A list of formulas to apply to each subset of the data.
If named, these names will be used in the <code>model</code> column of the output.
Otherwise, the formulas will be converted to strings in the <code>model</code> column.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_cols">cols</code></td>
<td>
<p>Columns to subset the data.
Can be any expression supported by
&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;.
If <code><a href="base.html#topic+NULL">NULL</a></code>, the data is not subset into columns.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_weights">weights</code></td>
<td>
<p>A list of columns passed to <code>weights</code> in <code>fn</code>.
If one of the elements is <code><a href="base.html#topic+NULL">NULL</a></code> or <code><a href="base.html#topic+NA">NA</a></code>, that model will not
be weighted.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_families">families</code></td>
<td>
<p>A list of <a href="stats.html#topic+glm">glm</a> model families.
Defaults to <code><a href="stats.html#topic+gaussian">gaussian(&quot;identity&quot;)</a></code>, the equivalent of <code><a href="stats.html#topic+lm">lm()</a></code>.
See <a href="stats.html#topic+family">family</a> for examples.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_fn_args">fn_args</code></td>
<td>
<p>A list of additional arguments to <code><a href="stats.html#topic+glm">glm()</a></code>.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_tidy">tidy</code></td>
<td>
<p>A logical or function to use to tidy model output into
data.frame columns.
If <code>TRUE</code>, uses the default tidying function: <code><a href="#topic+tidy_glance">tidy_glance()</a></code>.
If <code>FALSE</code>, <code>NA</code>, or <code>NULL</code>, the untidied model output will be returned in
a list column named <code>fit</code>.
An alternative function can be specified with an unquoted function name or
a <a href="purrr.html#topic+map">purrr</a>-style lambda function with one argument (see usage
with <a href="broom.html#topic+tidy.lm">broom::tidy(conf.int = TRUE)</a> in examples).
Defaults to <a href="#topic+tidy_glance">tidy_glance</a>.</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_tidy_args">tidy_args</code></td>
<td>
<p>A list of additional arguments to the <code>tidy</code> function</p>
</td></tr>
<tr><td><code id="cross_fit_glm_+3A_errors">errors</code></td>
<td>
<p>If <code>"stop"</code>, the default, the function will stop and return an
error if any subset produces an error.
If <code>"warn"</code>, the function will produce a warning for subsets that produce
an error and return results for all subsets that do not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a column for the model formula,
columns for subsets,
columns for the model family and type,
columns for the weights (if applicable),
and columns of tidy model output or a list column of models
(if <code>tidy = FALSE</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross_fit">cross_fit()</a></code> to use any modeling function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_fit_glm(
  data     = mtcars,
  formulas = list(am ~ gear, am ~ cyl),
  cols     = vs,
  families = list(gaussian("identity"), binomial("logit"))
)
</code></pre>

<hr>
<h2 id='cross_fit_robust'>Cross fit robust linear models</h2><span id='topic+cross_fit_robust'></span>

<h3>Description</h3>

<p>Cross fit robust linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_fit_robust(
  data,
  formulas,
  cols = NULL,
  weights = NULL,
  clusters = NULL,
  fn_args = list(),
  tidy = tidy_glance,
  tidy_args = list(),
  errors = c("stop", "warn")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_fit_robust_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_formulas">formulas</code></td>
<td>
<p>A list of formulas to apply to each subset of the data.
If named, these names will be used in the <code>model</code> column of the output.
Otherwise, the formulas will be converted to strings in the <code>model</code> column.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_cols">cols</code></td>
<td>
<p>Columns to subset the data.
Can be any expression supported by
&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;.
If <code><a href="base.html#topic+NULL">NULL</a></code>, the data is not subset into columns.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_weights">weights</code></td>
<td>
<p>A list of columns passed to <code>weights</code> in <code>fn</code>.
If one of the elements is <code><a href="base.html#topic+NULL">NULL</a></code> or <code><a href="base.html#topic+NA">NA</a></code>, that model will not
be weighted.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_clusters">clusters</code></td>
<td>
<p>A list of columns passed to <code>clusters</code>.
If one of the elements is <code><a href="base.html#topic+NULL">NULL</a></code> or <code><a href="base.html#topic+NA">NA</a></code>, that model will not
be clustered.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_fn_args">fn_args</code></td>
<td>
<p>A list of additional arguments to <code><a href="estimatr.html#topic+lm_robust">estimatr::lm_robust()</a></code>.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_tidy">tidy</code></td>
<td>
<p>A logical or function to use to tidy model output into
data.frame columns.
If <code>TRUE</code>, uses the default tidying function: <code><a href="#topic+tidy_glance">tidy_glance()</a></code>.
If <code>FALSE</code>, <code>NA</code>, or <code>NULL</code>, the untidied model output will be returned in
a list column named <code>fit</code>.
An alternative function can be specified with an unquoted function name or
a <a href="purrr.html#topic+map">purrr</a>-style lambda function with one argument (see usage
with <a href="broom.html#topic+tidy.lm">broom::tidy(conf.int = TRUE)</a> in examples).
Defaults to <a href="#topic+tidy_glance">tidy_glance</a>.</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_tidy_args">tidy_args</code></td>
<td>
<p>A list of additional arguments to the <code>tidy</code> function</p>
</td></tr>
<tr><td><code id="cross_fit_robust_+3A_errors">errors</code></td>
<td>
<p>If <code>"stop"</code>, the default, the function will stop and return an
error if any subset produces an error.
If <code>"warn"</code>, the function will produce a warning for subsets that produce
an error and return results for all subsets that do not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a column for the model formula,
columns for subsets,
columns for the weights and clusters (if applicable),
and columns of tidy model output or a list column of models
(if <code>tidy = FALSE</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross_fit">cross_fit()</a></code> to use any modeling function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cross_fit_robust(mtcars, mpg ~ wt, cyl, clusters = list(NULL, am))

</code></pre>

<hr>
<h2 id='cross_join'>Crossing join</h2><span id='topic+cross_join'></span>

<h3>Description</h3>

<p>Adds columns from a set of data frames, creating all combinations of
their rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_join(..., copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_join_+3A_...">...</code></td>
<td>
<p><a href="base.html#topic+data.frame">Data frames</a> or a <a href="base.html#topic+list">list</a> of data frames &ndash; including
data frame extensions (e.g. <a href="tibble.html#topic+tibble">tibbles</a>) and lazy data
frames (e.g. from dbplyr or dtplyr).
<code><a href="base.html#topic+NULL">NULL</a></code> inputs are silently ignored.</p>
</td></tr>
<tr><td><code id="cross_join_+3A_copy">copy</code></td>
<td>
<p>If inputs are not from the same data source, and copy is
<code>TRUE</code>, then they will be copied into the same src as the first input.
This allows you to join tables across srcs, but it is a potentially
expensive operation so you must opt into it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as the first input.
The order of the rows and columns of the first input is preserved as much
as possible. The output has the following properties:
</p>

<ul>
<li><p> Rows from each input will be duplicated.
</p>
</li>
<li><p> Output columns include all columns from each input.
If columns have the same name, suffixes are added to disambiguate.
</p>
</li>
<li><p> Groups are taken from the first input.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cross_list">cross_list()</a></code> to find combinations of elements of vectors
and lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits &lt;- dplyr::tibble(
  fruit = c("apple", "banana", "cantaloupe"),
  color = c("red", "yellow", "orange")
)

desserts &lt;- dplyr::tibble(
  dessert = c("cupcake", "muffin", "streudel"),
  makes   = c(8, 6, 1)
)

cross_join(fruits, desserts)
cross_join(list(fruits, desserts))
cross_join(rep(list(fruits), 3))
</code></pre>

<hr>
<h2 id='cross_list'>List all combinations of values</h2><span id='topic+cross_list'></span><span id='topic+cross_tbl'></span>

<h3>Description</h3>

<p>List all combinations of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_list(...)

cross_tbl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_list_+3A_...">...</code></td>
<td>
<p>Inputs or a <a href="base.html#topic+list">list</a> of inputs.
<code><a href="base.html#topic+NULL">NULL</a></code> inputs are silently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> for <code>cross_list()</code> or <a href="tibble.html#topic+tibble">tibble</a> for
<code>cross_tbl()</code>.
Names will match the names of the inputs.
Unnamed inputs will be left unnamed for <code>cross_list()</code> and automatically
named for <code>cross_tbl()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross_join">cross_join()</a></code> to find combinations of data frame rows.
</p>
<p><code><a href="purrr.html#topic+cross">purrr::cross()</a></code> for an implementation that results in a differently
formatted list.
</p>
<p><code><a href="base.html#topic+expand.grid">expand.grid()</a></code> for an implementation that results in a <a href="base.html#topic+data.frame">data.frame</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits   &lt;- c("apple", "banana", "cantaloupe")
desserts &lt;- c("cupcake", "muffin", "streudel")

cross_list(list(fruits, desserts))
cross_list(fruits, desserts)
cross_tbl(fruits, desserts)

cross_list(list(fruit = fruits, dessert = desserts))
cross_list(fruit = fruits, dessert = desserts)
cross_tbl(fruit = fruits, dessert = desserts)
</code></pre>

<hr>
<h2 id='crossmap-package'>crossmap: Apply Functions to All Combinations of List Elements</h2><span id='topic+crossmap'></span><span id='topic+crossmap-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides an extension to the 'purrr' family of mapping functions to apply a function to each combination of elements in a list of inputs. Also includes functions for automatically detecting output type in mapping functions, finding every combination of elements of lists or rows of data frames, and applying multiple models to multiple subsets of a dataset.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander Rossell Hayes <a href="mailto:alexander@rossellhayes.com">alexander@rossellhayes.com</a> (<a href="https://orcid.org/0000-0001-9412-0457">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://crossmap.rossellhayes.com">https://crossmap.rossellhayes.com</a>
</p>
</li>
<li> <p><a href="https://github.com/rossellhayes/crossmap">https://github.com/rossellhayes/crossmap</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rossellhayes/crossmap/issues">https://github.com/rossellhayes/crossmap/issues</a>
</p>
</li></ul>


<hr>
<h2 id='future_map_vec'>Parallelized mapping functions that automatically determine type</h2><span id='topic+future_map_vec'></span><span id='topic+future_map2_vec'></span><span id='topic+future_pmap_vec'></span><span id='topic+future_imap_vec'></span><span id='topic+future_xmap_vec'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="#topic+map_vec">map_vec()</a></code>, <code><a href="#topic+map2_vec">map2_vec()</a></code>,
<code><a href="#topic+pmap_vec">pmap_vec()</a></code>, <code><a href="#topic+imap_vec">imap_vec()</a></code> and <code><a href="#topic+xmap_vec">xmap_vec()</a></code>,
but allow you to map in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_map_vec(
  .x,
  .f,
  ...,
  .class = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_map2_vec(
  .x,
  .y,
  .f,
  ...,
  .class = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_pmap_vec(
  .l,
  .f,
  ...,
  .class = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_imap_vec(
  .x,
  .f,
  ...,
  .class = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_vec(
  .l,
  .f,
  ...,
  .class = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_map_vec_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.class">.class</code></td>
<td>
<p>If <code>.class</code> is specified, all</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="furrr.html#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.y">.y</code></td>
<td>
<p>A vector the same length as <code>.x</code>.
Vectors of length 1 will be recycled.</p>
</td></tr>
<tr><td><code id="future_map_vec_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to <code><a href="#topic+map_vec">map_vec()</a></code>, <code><a href="#topic+map2_vec">map2_vec()</a></code>, <code><a href="#topic+pmap_vec">pmap_vec()</a></code>,
<code><a href="#topic+imap_vec">imap_vec()</a></code> and <code><a href="#topic+xmap_vec">xmap_vec()</a></code>
</p>


<h3>See Also</h3>

<p>The original functions: <code><a href="furrr.html#topic+future_map">furrr::future_map()</a></code>,
<code><a href="furrr.html#topic+future_map2">furrr::future_map2()</a></code>, <code><a href="furrr.html#topic+future_map2">furrr::future_pmap()</a></code>, <code><a href="furrr.html#topic+future_imap">furrr::future_imap()</a></code>
and <code><a href="#topic+future_xmap">future_xmap()</a></code>
</p>
<p>Non-parallelized equivalents: <code><a href="#topic+map_vec">map_vec()</a></code>, <code><a href="#topic+map2_vec">map2_vec()</a></code>,
<code><a href="#topic+pmap_vec">pmap_vec()</a></code>, <code><a href="#topic+imap_vec">imap_vec()</a></code> and <code><a href="#topic+xmap_vec">xmap_vec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits   &lt;- c("apple", "banana", "carrot", "durian", "eggplant")
desserts &lt;- c("bread", "cake", "cupcake", "streudel", "muffin")
x        &lt;- sample(5)
y        &lt;- sample(5)
z        &lt;- sample(5)
names(z) &lt;- fruits

future_map_vec(x, ~ . ^ 2)
future_map_vec(fruits, paste0, "s")

future_map2_vec(x, y, ~ .x + .y)
future_map2_vec(fruits, desserts, paste)

future_pmap_vec(list(x, y, z), sum)
future_pmap_vec(list(x, fruits, desserts), paste)

future_imap_vec(x, ~ .x + .y)
future_imap_vec(x, ~ paste0(.y, ": ", .x))
future_imap_vec(z, paste)

future_xmap_vec(list(x, y), ~ .x * .y)
future_xmap_vec(list(fruits, desserts), paste)
</code></pre>

<hr>
<h2 id='future_xmap'>Map over each combination of list elements simultaneously via futures</h2><span id='topic+future_xmap'></span><span id='topic+future_xmap_chr'></span><span id='topic+future_xmap_dbl'></span><span id='topic+future_xmap_dfc'></span><span id='topic+future_xmap_dfr'></span><span id='topic+future_xmap_int'></span><span id='topic+future_xmap_lgl'></span><span id='topic+future_xmap_raw'></span><span id='topic+future_xwalk'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="#topic+xmap">xmap()</a></code> functions,
but allow you to run the map in parallel using <code><a href="future.html#topic+future">future::future()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_xmap(.l, .f, ..., .progress = FALSE, .options = furrr::furrr_options())

future_xmap_chr(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_dbl(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_dfc(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_dfr(
  .l,
  .f,
  ...,
  .id = NULL,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_int(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_lgl(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_raw(
  .l,
  .f,
  ...,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xwalk(.l, .f, ..., .progress = FALSE, .options = furrr::furrr_options())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_xmap_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
<tr><td><code id="future_xmap_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_xmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="future_xmap_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_xmap_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="furrr.html#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_xmap_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>.
If a string, the output will contain a variable with that name, storing
either the name (if <code>.x</code> is named) or the index (if <code>.x</code> is unnamed) of
the input.
If <code>NULL</code>, the default, no variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An atomic vector, list, or data frame, depending on the suffix.
Atomic vectors and lists will be named if the first element of .l is named.
</p>
<p>If all input is length 0, the output will be length 0.
If any input is length 1, it will be recycled to the length of the longest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmap">xmap()</a></code> to run functions without parallel processing.
</p>
<p><code><a href="#topic+future_xmap_vec">future_xmap_vec()</a></code> to automatically determine output type.
</p>
<p><code><a href="#topic+future_xmap_mat">future_xmap_mat()</a></code> and <code><a href="#topic+future_xmap_arr">future_xmap_arr()</a></code> to return results in a matrix
or array.
</p>
<p><code><a href="furrr.html#topic+future_map">furrr::future_map()</a></code>, <code><a href="furrr.html#topic+future_map2">furrr::future_map2()</a></code>, and <code><a href="furrr.html#topic+future_map2">furrr::future_pmap()</a></code>
for other parallelized mapping functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>future_xmap(list(1:5, 1:5), ~ .y * .x)
future_xmap_dbl(list(1:5, 1:5), ~ .y * .x)
future_xmap_chr(list(1:5, 1:5), ~ paste(.y, "*", .x, "=", .y * .x))

apples_and_bananas &lt;- list(
  x = c("apples", "bananas"),
  pattern = "a",
  replacement = c("oo", "ee")
)

future_xmap_chr(apples_and_bananas, gsub)

formulas &lt;- list(mpg ~ wt, mpg ~ hp)
subsets  &lt;- split(mtcars, mtcars$cyl)

future_xmap(list(subsets, formulas), ~ lm(.y, data = .x))
</code></pre>

<hr>
<h2 id='future_xmap_mat'>Parallelized cross map returning a matrix or array</h2><span id='topic+future_xmap_mat'></span><span id='topic+future_xmap_arr'></span>

<h3>Description</h3>

<p>Parallelized cross map returning a matrix or array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_xmap_mat(
  .l,
  .f,
  ...,
  .names = TRUE,
  .progress = FALSE,
  .options = furrr::furrr_options()
)

future_xmap_arr(
  .l,
  .f,
  ...,
  .names = TRUE,
  .progress = FALSE,
  .options = furrr::furrr_options()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_xmap_mat_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
<tr><td><code id="future_xmap_mat_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_xmap_mat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="future_xmap_mat_+3A_.names">.names</code></td>
<td>
<p>A logical indicating whether to give names to the dimensions of
the matrix or array.
If inputs are named, the names are used.
If inputs are unnamed, the elements of the input are used as names.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="future_xmap_mat_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_xmap_mat_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="furrr.html#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (for <code>future_xmap_mat()</code>) or array (for <code>future_xmap_arr()</code>)
with dimensions matching the lengths of each input in <code>.l</code>.
</p>


<h3>See Also</h3>

<p>Unparallelized versions: <code><a href="#topic+xmap_mat">xmap_mat()</a></code> and <code><a href="#topic+xmap_arr">xmap_arr()</a></code>
</p>
<p><code><a href="#topic+future_xmap_vec">future_xmap_vec()</a></code> to return a vector.
</p>
<p><code><a href="#topic+future_xmap">future_xmap()</a></code> for the underlying functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>future_xmap_mat(list(1:3, 1:3),  ~ ..1 * ..2)

fruits &lt;- c(a = "apple", b = "banana", c = "cantaloupe")
future_xmap_mat(list(1:3, fruits), paste)
future_xmap_mat(list(1:3, fruits), paste, .names = FALSE)

future_xmap_arr(list(1:3, 1:3, 1:3),  ~ ..1 * ..2 * ..3)
</code></pre>

<hr>
<h2 id='map_vec'>Mapping functions that automatically determine type</h2><span id='topic+map_vec'></span><span id='topic+map2_vec'></span><span id='topic+pmap_vec'></span><span id='topic+imap_vec'></span><span id='topic+xmap_vec'></span>

<h3>Description</h3>

<p>These functions work exactly the same as typed variants of <code><a href="purrr.html#topic+map">purrr::map()</a></code>,
<code><a href="purrr.html#topic+map2">purrr::map2()</a></code>, <code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code>, <code><a href="purrr.html#topic+imap">purrr::imap()</a></code> and <code><a href="#topic+xmap">xmap()</a></code>
(e.g. <code><a href="purrr.html#topic+map">purrr::map_chr()</a></code>), but automatically determine the type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_vec(.x, .f, ..., .class = NULL)

map2_vec(.x, .y, .f, ..., .class = NULL)

pmap_vec(.l, .f, ..., .class = NULL)

imap_vec(.x, .f, ..., .class = NULL)

xmap_vec(.l, .f, ..., .class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_vec_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="map_vec_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="map_vec_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="map_vec_+3A_.class">.class</code></td>
<td>
<p>If <code>.class</code> is specified, all</p>
</td></tr>
<tr><td><code id="map_vec_+3A_.y">.y</code></td>
<td>
<p>A vector the same length as <code>.x</code>.
Vectors of length 1 will be recycled.</p>
</td></tr>
<tr><td><code id="map_vec_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to the typed variants of <code><a href="purrr.html#topic+map">purrr::map()</a></code>, <code><a href="purrr.html#topic+map2">purrr::map2()</a></code>,
<code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code>, <code><a href="purrr.html#topic+imap">purrr::imap()</a></code> and <code><a href="#topic+xmap">xmap()</a></code> with the type automatically
determined.
</p>
<p>If the output contains multiple types, the type is determined from
the highest type of the components in the hierarchy <a href="base.html#topic+raw">raw</a> &lt; <a href="base.html#topic+logical">logical</a> &lt;
<a href="base.html#topic+integer">integer</a> &lt; <a href="base.html#topic+double">double</a> &lt; <a href="base.html#topic+complex">complex</a> &lt; <a href="base.html#topic+character">character</a> &lt; <a href="base.html#topic+list">list</a> (as in <code><a href="base.html#topic+c">c()</a></code>).
</p>
<p>If the output contains elements that cannot be coerced to vectors
(e.g. lists), the output will be a list.
</p>


<h3>See Also</h3>

<p>The original functions: <code><a href="purrr.html#topic+map">purrr::map()</a></code>, <code><a href="purrr.html#topic+map2">purrr::map2()</a></code>,
<code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code>, <code><a href="purrr.html#topic+imap">purrr::imap()</a></code> and <code><a href="#topic+xmap">xmap()</a></code>
</p>
<p>Parallelized equivalents: <code><a href="#topic+future_map_vec">future_map_vec()</a></code>, <code><a href="#topic+future_map2_vec">future_map2_vec()</a></code>,
<code><a href="#topic+future_pmap_vec">future_pmap_vec()</a></code>, <code><a href="#topic+future_imap_vec">future_imap_vec()</a></code> and <code><a href="#topic+future_xmap_vec">future_xmap_vec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits   &lt;- c("apple", "banana", "cantaloupe", "durian", "eggplant")
desserts &lt;- c("bread", "cake", "cupcake", "muffin", "streudel")
x        &lt;- sample(5)
y        &lt;- sample(5)
z        &lt;- sample(5)
names(z) &lt;- fruits

map_vec(x, ~ . ^ 2)
map_vec(fruits, paste0, "s")

map2_vec(x, y, ~ .x + .y)
map2_vec(fruits, desserts, paste)

pmap_vec(list(x, y, z), sum)
pmap_vec(list(x, fruits, desserts), paste)

imap_vec(x, ~ .x + .y)
imap_vec(x, ~ paste0(.y, ": ", .x))
imap_vec(z, paste)

xmap_vec(list(x, y), ~ .x * .y)
xmap_vec(list(fruits, desserts), paste)
</code></pre>

<hr>
<h2 id='tidy_glance'>Turn an object into a tidy tibble with glance information</h2><span id='topic+tidy_glance'></span>

<h3>Description</h3>

<p>Apply both <code><a href="generics.html#topic+tidy">generics::tidy()</a></code> and <code><a href="generics.html#topic+glance">generics::glance()</a></code> to an object and
return a single <a href="tibble.html#topic+tibble">tibble</a> with both sets of information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_glance(x, ..., tidy_args = list(), glance_args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_glance_+3A_x">x</code></td>
<td>
<p>An object to be converted into a tidy <a href="tibble.html#topic+tibble">tibble</a>.</p>
</td></tr>
<tr><td><code id="tidy_glance_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="generics.html#topic+tidy">generics::tidy()</a></code>
and <code><a href="generics.html#topic+glance">generics::glance()</a></code>.
</p>
<p>Arguments are passed to both methods, but should be ignored by the
inapplicable method. For example, if called on an <a href="stats.html#topic+lm">lm</a> object,
<code>conf.int</code> will affect <code><a href="generics.html#topic+tidy">generics::tidy()</a></code> but not <code><a href="generics.html#topic+glance">generics::glance()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_glance_+3A_tidy_args">tidy_args</code></td>
<td>
<p>A list of additional arguments passed only
to <code><a href="generics.html#topic+tidy">generics::tidy()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_glance_+3A_glance_args">glance_args</code></td>
<td>
<p>A list of additional arguments passed only
to <code><a href="generics.html#topic+glance">generics::glance()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with columns and rows from
<code><a href="generics.html#topic+tidy">generics::tidy()</a></code> and columns of repeated rows
from <code><a href="generics.html#topic+glance">generics::glance()</a></code>.
</p>
<p>Column names that appear in both the <code>tidy</code> data and <code>glance</code> data will be
disambiguated by appending &quot;<code>model.</code>&quot; to the <code>glance</code> column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)
tidy_glance(mod)
tidy_glance(mod, conf.int = TRUE)
tidy_glance(mod, tidy_args = list(conf.int = TRUE))
</code></pre>

<hr>
<h2 id='xmap'>Map over each combination of list elements</h2><span id='topic+xmap'></span><span id='topic+xmap_chr'></span><span id='topic+xmap_dbl'></span><span id='topic+xmap_dfc'></span><span id='topic+xmap_dfr'></span><span id='topic+xmap_int'></span><span id='topic+xmap_lgl'></span><span id='topic+xmap_raw'></span><span id='topic+xwalk'></span>

<h3>Description</h3>

<p>These functions are variants of <code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code> that iterate over each
combination of elements in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmap(.l, .f, ...)

xmap_chr(.l, .f, ...)

xmap_dbl(.l, .f, ...)

xmap_dfc(.l, .f, ...)

xmap_dfr(.l, .f, ..., .id = NULL)

xmap_int(.l, .f, ...)

xmap_lgl(.l, .f, ...)

xmap_raw(.l, .f, ...)

xwalk(.l, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmap_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
<tr><td><code id="xmap_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="xmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="xmap_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>.
If a string, the output will contain a variable with that name, storing
either the name (if <code>.x</code> is named) or the index (if <code>.x</code> is unnamed) of
the input.
If <code>NULL</code>, the default, no variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typed variants return a vector of the specified type.
To automatically determine type, try <code><a href="#topic+xmap_vec">xmap_vec()</a></code>.
</p>
<p>To return results as a matrix or array, try <code><a href="#topic+xmap_mat">xmap_mat()</a></code> and <code><a href="#topic+xmap_arr">xmap_arr()</a></code>.
</p>
<p>Note that a data frame is a very important special case, in which case
<code>xmap()</code> and <code>xwalk()</code> apply the function <code>.f</code> to each row.
<code>xmap_dfr()</code> and <code>xmap_dfc()</code> return data frames created by row-binding and
column-binding respectively.
</p>


<h3>Value</h3>

<p>An atomic vector, list, or data frame, depending on the suffix.
Atomic vectors and lists will be named if the first element of .l is named.
</p>
<p>If all input is length 0, the output will be length 0.
If any input is length 1, it will be recycled to the length of the longest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmap_vec">xmap_vec()</a></code> to automatically determine output type.
</p>
<p><code><a href="#topic+xmap_mat">xmap_mat()</a></code> and <code><a href="#topic+xmap_arr">xmap_arr()</a></code> to return results in a matrix or array.
</p>
<p><code><a href="#topic+future_xmap">future_xmap()</a></code> to run <code>xmap</code> functions with parallel processing.
</p>
<p><code><a href="#topic+cross_fit">cross_fit()</a></code> to apply multiple models to multiple subsets of data.
</p>
<p><code><a href="#topic+cross_list">cross_list()</a></code> to find combinations of list elements.
</p>
<p><code><a href="purrr.html#topic+map">purrr::map()</a></code>, <code><a href="purrr.html#topic+map2">purrr::map2()</a></code>, and <code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code> for other mapping
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmap(list(1:5, 1:5), ~ .y * .x)
xmap_dbl(list(1:5, 1:5), ~ .y * .x)
xmap_chr(list(1:5, 1:5), ~ paste(.y, "*", .x, "=", .y * .x))

apples_and_bananas &lt;- list(
  x = c("apples", "bananas"),
  pattern = "a",
  replacement = c("oo", "ee")
)

xmap_chr(apples_and_bananas, gsub)

formulas &lt;- list(mpg ~ wt, mpg ~ hp)
subsets  &lt;- split(mtcars, mtcars$cyl)

xmap(list(subsets, formulas), ~ lm(.y, data = .x))
xmap(list(data = subsets, formula = formulas), lm)
</code></pre>

<hr>
<h2 id='xmap_mat'>Return a table applying a function to all combinations of list elements</h2><span id='topic+xmap_mat'></span><span id='topic+xmap_arr'></span>

<h3>Description</h3>

<p>Return a table applying a function to all combinations of list elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmap_mat(.l, .f, ..., .names = TRUE)

xmap_arr(.l, .f, ..., .names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmap_mat_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame.
The length of .l determines the number of arguments that .f will be called
with.
List names will be used if present.</p>
</td></tr>
<tr><td><code id="xmap_mat_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="xmap_mat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="xmap_mat_+3A_.names">.names</code></td>
<td>
<p>A logical indicating whether to give names to the dimensions of
the matrix or array.
If inputs are named, the names are used.
If inputs are unnamed, the elements of the input are used as names.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (for <code>xmap_mat()</code>) or array (for <code>xmap_arr()</code>) with
dimensions equal to the lengths of each input in <code>.l</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+future_xmap_mat">future_xmap_mat()</a></code> and <code><a href="#topic+future_xmap_arr">future_xmap_arr()</a></code> to run functions in
parallel.
</p>
<p><code><a href="#topic+xmap_vec">xmap_vec()</a></code> to return a vector.
</p>
<p><code><a href="#topic+xmap">xmap()</a></code> for the underlying functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmap_mat(list(1:3, 1:3),  ~ ..1 * ..2)

fruits &lt;- c(a = "apple", b = "banana", c = "cantaloupe")
xmap_mat(list(1:3, fruits), paste)
xmap_mat(list(1:3, fruits), paste, .names = FALSE)

xmap_arr(list(1:3, 1:3, 1:3),  ~ ..1 * ..2 * ..3)
</code></pre>

<hr>
<h2 id='xpluck'>Get one or more elements deep within a nested data structure</h2><span id='topic+xpluck'></span>

<h3>Description</h3>

<p><code>xpluck()</code> provides an alternative to <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code>.
Unlike <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code>, <code>xpluck()</code> allows you to extract multiple indices at
each nesting level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpluck(.x, ..., .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpluck_+3A_.x">.x</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> or <a href="base.html#topic+vector">vector</a></p>
</td></tr>
<tr><td><code id="xpluck_+3A_...">...</code></td>
<td>
<p>A list of accessors for indexing into the object.
Can be positive integers,
negative integers (to index from the right),
strings (to index into names) or
missing (to keep all elements at a given level).
</p>
<p>Unlike <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code>,
each accessor may be a vector to extract multiple elements.</p>
</td></tr>
<tr><td><code id="xpluck_+3A_.default">.default</code></td>
<td>
<p>Value to use if target is <code><a href="base.html#topic+NULL">NULL</a></code> or absent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> or <a href="base.html#topic+vector">vector</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj1 &lt;- list("a", list(1, elt = "foo"))
obj2 &lt;- list("b", list(2, elt = "bar"))
x &lt;- list(obj1, obj2)

xpluck(x, 1:2, 2)
xpluck(x, , 2)

xpluck(x, , 2, 1)
xpluck(x, , 2, 2)
xpluck(x, , 2, 1:2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
