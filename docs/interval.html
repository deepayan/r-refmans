<!DOCTYPE html><html><head><title>Help for package interval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {interval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#interval-package'>
<p>Tests and NPMLE for interval censored data</p></a></li>
<li><a href='#Aintmap'><p>Create A matrix and intmap</p></a></li>
<li><a href='#bcos'><p>Breast Cosmesis Data</p></a></li>
<li><a href='#getsurv'><p>get survival values from  icfit object</p></a></li>
<li><a href='#icfit'><p>calculate non-parametric MLE for interval censored survival function</p></a></li>
<li><a href='#icfitControl'><p>Auxiliary for controling icfit</p></a></li>
<li><a href='#ictest'><p>do logrank or Wilcoxon type tests on interval censored data</p></a></li>
<li><a href='#initcomputeMLE'><p>functions to calculate initial NPMLE of the distribution</p></a></li>
<li><a href='#interval-internal'>
<p>Internal functions</p></a></li>
<li><a href='#mControl'><p>Auxiliary for feeding parameters to different methods</p></a></li>
<li><a href='#methodRuleIC1'><p>Rule for determining method for ictest</p></a></li>
<li><a href='#plot.icfit'><p>Plot icfit object</p></a></li>
<li><a href='#summary.icfit'><p>Methods for icfit objects</p></a></li>
<li><a href='#SurvLR'><p>Transform Surv object to data frame with L and R values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Logrank Tests and NPMLE for Interval Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael P. Fay</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael P. Fay &lt;mfay@niaid.nih.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.1), stats, survival, perm (&ge; 1.0), Icens, MLEcens</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coin</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to fit nonparametric survival curves, plot them, and perform logrank or Wilcoxon type tests [see Fay and Shaw &lt;<a href="https://doi.org/10.18637%2Fjss.v036.i02">doi:10.18637/jss.v036.i02</a>&gt;].</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 20:14:24 UTC; faym</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='interval-package'>
Tests and NPMLE for interval censored data
</h2><span id='topic+interval'></span><span id='topic+interval-package'></span>

<h3>Description</h3>

<p>The main functions are <code><a href="#topic+icfit">icfit</a></code> to fit nonparametric survival curves together 
with <code><a href="#topic+plot.icfit">plot.icfit</a></code> to 
plot them, and <code><a href="#topic+ictest">ictest</a></code> to perform logrank or Wilcoxon type tests.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> interval</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-0.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-10-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL 2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Michael Fay
</p>
<p>Maintainer: M.P. Fay &lt;mfay@niaid.nih.gov&gt;
</p>


<h3>References</h3>

<p>Fay, MP and Shaw, PA (2010). Exact and Asymptotic Weighted Logrank Tests for Interval Censored Data: The interval R package.
Journal of Statistical Software. <a href="https://doi.org/10.18637/jss.v036.i02">doi:10.18637/jss.v036.i02</a>. 36 (2):1-34.
</p>

<hr>
<h2 id='Aintmap'>Create A matrix and intmap</h2><span id='topic+Aintmap'></span>

<h3>Description</h3>

<p>The A matrix is an n by k matrix of zeros and ones, where each row represents one of n failure times, 
and each column represents 
a possible interval for the nonparametric maximum likelihood estimate (NPMLE). 
The function <code>Aintmap</code> creates an A matrix and associated intmap 
from left and right intervals (L and R) which may not may not include the boundary 
of the interval (using Lin or Rin).
The matrix intmap  denotes the intervals of the potential jumps in the distribution of the 
NPMLE, 
and its attribute LRin denotes whether to include each of the intervals 
or not. Called  by <code><a href="#topic+icfit">icfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aintmap(L,R,Lin=NULL,Rin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aintmap_+3A_l">L</code></td>
<td>
<p>numeric vector of left endpoints of censoring interval</p>
</td></tr>
<tr><td><code id="Aintmap_+3A_r">R</code></td>
<td>
<p>numeric vector of right endpoints of censoring interval</p>
</td></tr>
<tr><td><code id="Aintmap_+3A_lin">Lin</code></td>
<td>
<p>logical vector, should L be included in the interval? (see details)</p>
</td></tr>
<tr><td><code id="Aintmap_+3A_rin">Rin</code></td>
<td>
<p>logical vector, should R be included in the interval? (see details)</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>Lin</code> and <code>Rin</code> specify whether or not to include the ends of the intervals.
They may be length 1 (and apply to all n values) or length n. The function automatically 
only returns the innermost intervals (also called the Turnbull intervals [see Turnbull, 1976], or the regions of the maximal cliques
[see Gentleman and Vandal, 2002]).
The innermost intervals give the &quot;primary reduction&quot; of Aragon and Eberly (1992). 
</p>


<h3>Value</h3>

<p>A list with two objects:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>an n by k matrix of 0 and 1s</p>
</td></tr>
<tr><td><code>intmap</code></td>
<td>
<p>the associated intmap</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Aragon, J and Eberly, D (1992). On convergence of convex 
minorant algorithms for distribution estimation with 
interval-censored data.  J. of Computational and Graphical 
Statistics. 1: 129-140.
</p>
<p>Gentleman R, and Vandal, A (2002). Nonparametric estimation of the bivariate CDF for arbitrarily censored dtaa. Canadian J of Stat 30: 557-571.
</p>
<p>Turnbull, B (1976). The empirical distribution function with arbitrarily grouped, censored and truncated data.
JRSS-B, 38: 290-295.
</p>


<h3>See Also</h3>

<p> Called from <code><a href="#topic+icfit">icfit</a></code> and <code><a href="#topic+ictest">ictest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Aintmap(c(2,3,3,7),c(3,5,5,8),Lin=c(FALSE,TRUE,FALSE,FALSE),Rin=c(TRUE,FALSE,TRUE,FALSE))
</code></pre>

<hr>
<h2 id='bcos'>Breast Cosmesis Data</h2><span id='topic+bcos'></span>

<h3>Description</h3>

<p>The often used data set for interval censored data, described and given in full in Finkelstein and Wolfe (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bcos)</code></pre>


<h3>Format</h3>

<p>A data frame with 94 observations on the following 3 variables.
</p>

<dl>
<dt><code>left</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>right</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>treatment</code></dt><dd><p>a factor with levels <code>Rad</code> and <code>RadChem</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Finkelstein, D.M., and Wolfe, R.A. (1985). A semiparametric model for regression analysis of interval-censored 
failure time data. Biometrics 41: 731-740.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcos)
</code></pre>

<hr>
<h2 id='getsurv'>get survival values from  icfit object</h2><span id='topic+getsurv'></span>

<h3>Description</h3>

<p>For a vector of times, <code>getsurv</code> gets the associated survival values. 
The MLE is not uniquely defined for times inbetween the first and second row on the 
same column of the intmap. 
If there is not 
a unique MLE for a specific time, then either use, 
interpolation: (default), which basically finds the point on the line connecting 
the two points bounding the non-unique MLE interval, or,
left: take the left side of the non-unique MLE interval (smallest value) or,
right: take the right side  of the non-unique MLE interval. The LRin attribute is ignored (see warning).
</p>
<p>If <code>icfit</code> has more than one strata, then performs the operations on each 
stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsurv(times, icfit, nonUMLE.method = "interpolation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsurv_+3A_times">times</code></td>
<td>
<p>numeric vector of times </p>
</td></tr>
<tr><td><code id="getsurv_+3A_icfit">icfit</code></td>
<td>
<p> icfit object used to define the survival function</p>
</td></tr>
<tr><td><code id="getsurv_+3A_nonumle.method">nonUMLE.method</code></td>
<td>
<p>character vector, either &quot;interpolation&quot;, &quot;left&quot; or &quot;right&quot;.
Method for finding survival when times element is not 
at a unique MLE time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if there is only one stratum, then creates a LIST,with elements
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>vector of survival function values at each element of times</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>vector of times for which need survival function</p>
</td></tr>
<tr><td><code>unique.mle</code></td>
<td>
<p>logical denoting whether associated survival value is a unique MLE</p>
</td></tr>
<tr><td><code>nonUMLE.method</code></td>
<td>
<p>character vector describing non-unique MLE method</p>
</td></tr>
</table>
<p>if there are k&gt;1 strata, then creates a list with k+1 elements, the elements 1:k are 
lists of results for each strata, and element k+1 is called strataNames and is a character 
vector of strata names.  
</p>


<h3>Warning</h3>

<p>The <code>getsurv</code> function does not use LRin attributes, so values exactly on the 
intmap values may only represent the limit approaching that value, not the survival at that value.</p>

<hr>
<h2 id='icfit'>calculate non-parametric MLE for interval censored survival function </h2><span id='topic+icfit'></span><span id='topic+icfit.default'></span><span id='topic+icfit.formula'></span>

<h3>Description</h3>

<p>This function calculates the the non-parametric maximum likelihood estimate for the distribution from interval 
censored data using the self-consistent estimator, so the associated survival distribution generalizes 
the Kaplan-Meier estimate to interval censored data. Formulas using <code>Surv</code> are allowed similar to <code>survfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'formula'
icfit(formula, data, ...)

## Default S3 method:
icfit(L, R,initfit =NULL, control=icfitControl(), Lin=NULL, Rin=NULL, conf.int=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icfit_+3A_l">L</code></td>
<td>
<p>numeric vector of left endpoints of censoring interval (equivalent to first element of <code>Surv</code> when type='interval2', see details)</p>
</td></tr>
<tr><td><code id="icfit_+3A_r">R</code></td>
<td>
<p>numeric vector of right endpoints of censoring interval (equivalent to second element of <code>Surv</code> function when type='interval2', see details)</p>
</td></tr>
<tr><td><code id="icfit_+3A_initfit">initfit</code></td>
<td>
<p>an initial estimate as an object of class <code>icfit</code> or <code>icsurv</code>, or a character vector of the name of the function used to calculate the initial estimate (see details)</p>
</td></tr>
<tr><td><code id="icfit_+3A_control">control</code></td>
<td>
<p>list of arguments for controling algorithm (see <code><a href="#topic+icfitControl">icfitControl</a></code>)</p>
</td></tr>
<tr><td><code id="icfit_+3A_lin">Lin</code></td>
<td>
<p>logical vector, should L be included in the interval? (see details)</p>
</td></tr>
<tr><td><code id="icfit_+3A_rin">Rin</code></td>
<td>
<p>logical vector, should R be included in the interval? (see details)</p>
</td></tr> 
<tr><td><code id="icfit_+3A_formula">formula</code></td>
<td>
<p>a formula with response a numeric vector (which assumes no censoring) or <code>Surv</code> object
the right side of the formula may be 1 or a factor (which produces separate fits for each level). </p>
</td></tr>
<tr><td><code id="icfit_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame containing the variables in the formula. By default the variables are taken from environment(formula).
</p>
</td></tr>
<tr><td><code id="icfit_+3A_conf.int">conf.int</code></td>
<td>
<p>logical, estimate confidence interval? For setting conf.level, etc see <code><a href="#topic+icfitControl">icfitControl</a></code>. (May take very long, see Warning)</p>
</td></tr>
<tr><td><code id="icfit_+3A_...">...</code></td>
<td>
<p>values passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>icfit</code> function fits the nonparametric maximum likelihood estimate (NPMLE) of the 
distribution function for interval censored data. In the default case (when Lin=Rin=NULL) 
we assume there are n (n=length(L)) failure times, and the ith one is in the interval
between L[i] and  R[i]. The default is not to include L[i] in the interval unless L[i]=R[i],
and to include R[i] in the interval unless R[i]=Inf. When Lin and Rin are not NULL they describe 
whether to include L and R in the associated interval. If either Lin or Rin is length 1 then it is 
repeated n times, otherwise they should be logicals of length n. 
</p>
<p>The algorithm is basically an EM-algorithm applied to 
interval censored data (see Turnbull, 1976); however 
first we can define a set of intervals (called the Turnbull intervals)
which are the only intervals where the NPMLE may change. The Turnbull intervals are also called the 
innermost intervals, and are the result of the primary reduction (see Aragon and 
Eberly, 1992). The starting distribution for the E-M algorithm is given by <code>initfit</code>, which may be either 
(1) NULL, in which case a very simple and quick starting distribution is used (see code), (2) a character vector 
describing a function with inputs, L,R, Lin, Rin, and A, see for example <code><a href="#topic+initcomputeMLE">initcomputeMLE</a></code>, (3)
a list giving <code>pf</code> and <code>intmap</code> values, e.g., an <code>icfit</code> object. If option (2) is tried and results in an error then 
the starting distribution reverts to the one used with option (1).
Convergence is defined when the maximum 
reduced gradient is less than epsilon (see <code><a href="#topic+icfitControl">icfitControl</a></code>), and the 
Kuhn-Tucker conditions are approximately met, 
otherwise a warning will result.  (see Gentleman and 
Geyer, 1994). There are other faster algorithms (for example see 
<code><a href="Icens.html#topic+EMICM">EMICM</a></code> in the package 
<code>Icens</code>.
</p>
<p>The output is of class <code>icfit</code> which is identical to the <code>icsurv</code> class of the 
<code>Icens</code> package when there is only one group for which a distribution is needed. 
Following that class, there is an <code>intmap</code> element which gives the bounds 
about which each drop in the NPMLE survival function can occur.  
</p>
<p>Since the classes <code>icfit</code> and <code>icsurv</code> are so closely related, one can directly 
use of initial (and faster) fits from the <code>Icens</code> package as input in 
<code>initfit</code>. Note that when using a non-null <code>initfit</code>, the <code>Lin</code> and <code>Rin</code> values of the 
initial fit are ignored. Alternatively, one may give the name of the function used to calculate the initial fit. 
The function is assumed to input the transpose of the A matrix (called A in the Icens package). Options can be passed 
to initfit function as a list using the initfitOpts variable in <code><a href="#topic+icfitControl">icfitControl</a></code>.
</p>
<p>The advantage of the <code>icfit</code> function over those in <code>Icens</code> package is that it allows a call similar 
to that used in <code>survfit</code> of the <code>survival</code> package so that different groups may be 
plotted at the same time with similar calls.  
</p>
<p>An <code>icfit</code> object prints as a list (see value below). A <code>print</code> function prints output as a list 
except suppresses printing of A matrix. A <code>summary</code> function prints the 
distribution (i.e., probabilities and the intervals where those 
probability masses are known to reside) for each group in the icfit object. There is also 
a plot method, see <code><a href="#topic+plot.icfit">plot.icfit</a></code>.
</p>
<p>For additional references and background see Fay and Shaw (2010).
</p>
<p>The confidence interval method is a modified bootstrap. This can be very time consuming, see warning. The method uses a percentile bootstrap confidence interval with default B=200
replicates (see  <code><a href="#topic+icfitControl">icfitControl</a></code>), with modifications that prevent lower intervals of 1 and upper intervals of 0. Specifically, if there are 
n observations total, then at any time the largest value of the lower interval for survival is binom.test(n,n,conf.level=control()$conf.level)$conf.int[1] and analogously 
the upper interval bounds using binom.test(0,n). The output (CI element of returned list) gives confidence intervals just before and just after each 
assessment time (as defined by icfitControl$timeEpsilon).
</p>


<h3>Value</h3>

<p>An object of class <code>icfit</code> (same as icsurv class, see details). 
</p>
<p>There are 4 methods for this class: <code><a href="#topic+plot.icfit">plot.icfit</a></code>, <code><a href="#topic+print.icfit">print.icfit</a></code>, <code><a href="#topic+summary.icfit">summary.icfit</a></code>, and <code><a href="#topic++5B.icfit">[.icfit</a></code>. The last method 
pulls out individual fits when the right side of the formula of the <code>icfit</code> call was a factor.  
</p>
<p>A list with elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p> this is the n by k matrix of indicator functions, NULL if more than one strata, not printed by default</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>a named numeric vector of length of pf vector (jumps in NPMLEs) for each strata, if one strata observation named NPMLE</p>
</td></tr> 
<tr><td><code>error</code></td>
<td>
<p>this is max(d + u - n), see Gentleman and Geyer, 1994</p>
</td></tr>
<tr><td><code>numit</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code>pf</code></td>
<td>
<p>vector of estimated probabilities of the distribution. if more than one strata, vectors are concatenated</p>
</td></tr>
<tr><td><code>intmap</code></td>
<td>
<p>2 by k matrix, where the ith column defines an interval corresponding to the probability, pf[i]</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>a logical, TRUE if normal convergence</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>character text message on about convergence</p>
</td></tr>
<tr><td><code>anypzero</code></td>
<td>
<p>logical denoting whether any of the Turnbull intervals were set to zero</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>if conf.int=TRUE included as a list of lists for each stratum, each one having elements time, lower, upper, confMethod, conf.level</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The confidence interval method can be very time consuming because it uses a modified bootstrap and the NPMLE is recalculated for each replication.
That is why the default only uses 200 bootstrap replications.
A message gives a crude estimate of how long the confidence interval calculation will take (it calculates a per replication value by averaging the time of the first 10 replications), 
but that estimate can be off by 100 percent or more because the time to calculate each bootstrap replication is quite variable. </p>


<h3>Author(s)</h3>

<p> Michael P. Fay</p>


<h3>References</h3>

<p>    Aragon, J and Eberly, D (1992). On convergence of convex 
minorant algorithms for distribution estimation with 
interval-censored data.  J. of Computational and Graphical 
Statistics. 1: 129-140.
</p>
<p>Fay, MP and Shaw, PA (2010). Exact and Asymptotic Weighted Logrank Tests for Interval Censored Data: The interval R package.
Journal of Statistical Software. <a href="https://doi.org/10.18637/jss.v036.i02">doi:10.18637/jss.v036.i02</a>. 36 (2):1-34.
</p>
<p>Gentleman, R. and Geyer, C.J. (1994). Maximum likelihood 
for interval censored data:consistency and computation. 
Biometrika, 81, 618-623.
</p>
<p>Turnbull, B.W. (1976) The empirical distribution function 
with arbitrarily grouped, censored and truncated data. 
J. R. Statist.  Soc. B 38, 290-295.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ictest">ictest</a></code>,  <code><a href="Icens.html#topic+EMICM">EMICM</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcos)
icout&lt;-icfit(Surv(left,right,type="interval2")~treatment, data=bcos)
plot(icout)
## can pick out just one group
plot(icout[1])
</code></pre>

<hr>
<h2 id='icfitControl'>Auxiliary for controling icfit </h2><span id='topic+icfitControl'></span>

<h3>Description</h3>

<p>A function to create a list of arguments for <code><a href="#topic+icfit">icfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icfitControl(epsilon = 1e-06, maxit = 10000, initfitOpts=NULL, conf.level=.95, B=200, 
    confMethod="modboot",seed=19439101, timeEpsilon=1e-06, timeMessage=TRUE) 
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="icfitControl_+3A_epsilon">epsilon</code></td>
<td>
<p>The minimum error for convergence purposes. The 
EM algorithm stops when error <code class="reqn">&lt;</code> epsilon, where 
error is the maximum of the reduced gradients 
(see Gentleman and Geyer, 1994)</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations of the EM algorithm</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_initfitopts">initfitOpts</code></td>
<td>
<p>named list of options for initfit function if initfit is function name</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_conf.level">conf.level</code></td>
<td>
<p>level for confidence interval, used if conf.int=TRUE</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications for conf.int=TRUE, must be at least 11</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_confmethod">confMethod</code></td>
<td>
<p>method for confidence intervals, must be &quot;modboot&quot;</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_seed">seed</code></td>
<td>
<p>random seed for bootstrap, if NULL no call to set.seed</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_timeepsilon">timeEpsilon</code></td>
<td>
<p>small number for adding or subtracting from time for drawing confidence interval lines</p>
</td></tr>
<tr><td><code id="icfitControl_+3A_timemessage">timeMessage</code></td>
<td>
<p>logical, print estimate of how long modified bootstrap confidence intervals will take to calculate?</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>There is only one option for the confMethod now. The confMethod argument is only needed for future versions if there is another confidence interval method option.
For a description of the modified bootstrap method see <code><a href="#topic+icfit">icfit</a></code>. 
</p>


<h3>Value</h3>

<p>An list with the arguments as components.
</p>


<h3>References</h3>

  
<p>Gentleman, R. and Geyer, C.J. (1994). Maximum likelihood 
for interval censored data:consistency and computation. 
Biometrika, 81, 618-623.
</p>

<hr>
<h2 id='ictest'>do logrank or Wilcoxon type tests on interval censored data</h2><span id='topic+ictest'></span><span id='topic+wlr_trafo'></span><span id='topic+ictest.default'></span><span id='topic+ictest.formula'></span><span id='topic+wlr_trafo.default'></span><span id='topic+wlr_trafo.Surv'></span><span id='topic+wlr_trafo.data.frame'></span>

<h3>Description</h3>

<p>The <code>ictest</code> function performs several different tests for 
interval censored data, and the <code>wlr_trafo</code> function takes interval censored data and returns one of several rank-based 
scores as determined by the <code>scores</code> option. The default for <code>ictest</code> is to perform a permutation test,  either asymptotic or exact
depending on the size of the data. Other types of tests (the scores test form or multiple imputation form) are supported. 
The 5 different score options allow different tests including  
generalizations to interval censored data of either the 
Wilcoxon-Mann-Whitney test
(scores=&quot;wmw&quot;) or  the logrank test (scores=&quot;logrank1&quot; or 
scores=&quot;logrank2&quot;) (see details). 
</p>
<p>The function calls the <code><a href="#topic+icfit">icfit</a></code> function, if an icfit object is not provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## Default S3 method:
ictest(L, R, group,  
    scores = c("logrank1","logrank2","wmw","normal","general"),
    rho=NULL,
    alternative= c("two.sided", "less", "greater"),   
    icFIT=NULL,
    initfit=NULL, 
    icontrol=icfitControl(),
    exact=NULL,
    method=NULL,
    methodRule=methodRuleIC1,
    mcontrol=mControl(),
    Lin=NULL,
    Rin=NULL, 
    dqfunc=NULL, ...)

## S3 method for class 'formula'
ictest(formula, data, subset, na.action, ...)




## Default S3 method:
wlr_trafo(x, R=NULL, 
    scores = c("logrank1", "logrank2", "wmw","normal","general"), 
    icFIT = NULL, initfit =NULL, control=icfitControl(),
    Lin=NULL,Rin=NULL,dqfunc=NULL,...)

## S3 method for class 'Surv'
wlr_trafo(x,...)
 
## S3 method for class 'data.frame'
wlr_trafo(x,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ictest_+3A_l">L</code></td>
<td>
<p>numeric vector of left endpoints of censoring interval (equivalent to first element of Surv when type='interval2'), 
if R is NULL then represents exact failure time</p>
</td></tr>
<tr><td><code id="ictest_+3A_r">R</code></td>
<td>
<p>numeric vector of right endpoints of censoring interval (equivalent to second element of Surv when type='interval2', see details)</p>
</td></tr>
<tr><td><code id="ictest_+3A_x">x</code></td>
<td>
<p>response, either a Surv object or a numeric vector representing the left endpoint. If the latter and R is NULL then x is treated as exact</p>
</td></tr> 
<tr><td><code id="ictest_+3A_group">group</code></td>
<td>
<p> 	a vector denoting the group for which the test 
is desired. If group is a factor or character 
then a k-sample test is performed, where k is 
the number of unique values of group. If group
is numeric then a &quot;correlation&quot; type test is 
performed. If there are only two groups, both 
methods give the same results.  </p>
</td></tr>
<tr><td><code id="ictest_+3A_scores">scores</code></td>
<td>
<p>character vector defining the scores: &quot;logrank1&quot; (default), &quot;logrank2&quot;, &quot;wmw&quot; or others (see details)</p>
</td></tr>
<tr><td><code id="ictest_+3A_rho">rho</code></td>
<td>
<p>either 0 (gives scores=&quot;logrank1&quot;), or 1 (gives scores=&quot;wmw&quot;), ignored if NULL (see Note)</p>
</td></tr>
<tr><td><code id="ictest_+3A_alternative">alternative</code></td>
<td>
<p>character giving alternative for two-sample and trend tests, K-sample should be two.sided (see details)</p>
</td></tr> 
<tr><td><code id="ictest_+3A_icfit">icFIT</code></td>
<td>
<p>a precalculated icfit object for increased computation speed. This should be the icfit from 
the pooled data. Normally initfit should be used instead (see Warning)</p>
</td></tr>
<tr><td><code id="ictest_+3A_initfit">initfit</code></td>
<td>
<p>an object of class icfit or icsurv or a character vector giving a function name, used for the initial estimate (see Warning). 
Ignored if <code>icFIT</code> is not null</p>
</td></tr>
<tr><td><code id="ictest_+3A_icontrol">icontrol</code></td>
<td>
<p>list of arguments for controling NPMLE algorithm in call to icfit (default <code><a href="#topic+icfitControl">icfitControl</a></code>)</p>
</td></tr>
<tr><td><code id="ictest_+3A_formula">formula</code></td>
<td>
<p>a formula with response a numeric vector (which assumes no censoring) or Surv object,
the right side of the formula is the group variable. No strata() is allowed</p>
</td></tr>
<tr><td><code id="ictest_+3A_data">data</code></td>
<td>
<p>data frame for variables in formula</p>
</td></tr>
<tr><td><code id="ictest_+3A_subset">subset</code></td>
<td>
<p>  an optional vector specifying a subset of observations to be used </p>
</td></tr>
<tr><td><code id="ictest_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data contain NAs. Defaults to getOption(&quot;na.action&quot;)</p>
</td></tr>
<tr><td><code id="ictest_+3A_surv">Surv</code></td>
<td>
<p> a Surv object, see <code><a href="survival.html#topic+Surv">Surv</a></code> </p>
</td></tr>
<tr><td><code id="ictest_+3A_exact">exact</code></td>
<td>
<p>a logical value, TRUE denotes exact test, ignored if method is not NULL</p>
</td></tr>
<tr><td><code id="ictest_+3A_method">method</code></td>
<td>
<p>a character value, one of 'pclt','exact.network','exact.ce','exact.mc', 'scoretest', 'wsr.HLY', 'wsr.pclt', 'wsr.mc'. 
If NULL method is chosen by methodRule which may use the value of exact.</p>
</td></tr>
<tr><td><code id="ictest_+3A_methodrule">methodRule</code></td>
<td>
<p>a function used to choose the method, default <code><a href="#topic+methodRuleIC1">methodRuleIC1</a></code>. (see details in <code><a href="perm.html#topic+permTS">perm</a></code>)</p>
</td></tr>
<tr><td><code id="ictest_+3A_mcontrol">mcontrol</code></td>
<td>
<p>list of arguments for controling algorithms of different methods (see <code><a href="#topic+mControl">mControl</a></code>)</p>
</td></tr>
<tr><td><code id="ictest_+3A_lin">Lin</code></td>
<td>
<p>logical vector, should L be included in the interval? (see details)</p>
</td></tr>
<tr><td><code id="ictest_+3A_rin">Rin</code></td>
<td>
<p>logical vector, should R be included in the interval? (see details)</p>
</td></tr> 
<tr><td><code id="ictest_+3A_dqfunc">dqfunc</code></td>
<td>
<p>function used with general scores (see details)</p>
</td></tr>
<tr><td><code id="ictest_+3A_control">control</code></td>
<td>
<p>list of arguments for controling NPMLE algorithm in call to icfit (default <code><a href="#topic+icfitControl">icfitControl</a></code>)</p>
</td></tr>
<tr><td><code id="ictest_+3A_...">...</code></td>
<td>
<p>values passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The censoring in the default case (when Lin=Rin=NULL) 
assumes there are n (n=length(L)) failure times, and the ith one is in the interval
between L[i] and  R[i]. The default is not to include L[i] in the interval unless L[i]=R[i],
and to include R[i] in the interval unless R[i]=Inf. When Lin and Rin are not NULL they describe 
whether to include L and R in the associated interval. If either Lin or Rin is length 1 then it is 
repeated n times, otherwise they should be logicals of length n. 
</p>
<p>Three different types of scores are compared in depth in Fay (1999): When 
scores='logrank1' this gives the most commonly used logrank scores for right censored data,
and reduces to the scores of Sun (1996) for interval censored data.  When 
scores='logrank2' this gives the scores associated with the grouped 
proportional hazards  model of Finkelstein (1986). When scores='wmw' this 
gives the generalized Wilcoxon-Mann-Whitney scores. 
</p>
<p>The other options for scores only allow the permutation methods and 
follow cases where the error under the grouped continuous model is either normally distributed ( scores='normal') or 
distributed by some other distribution (scores='general') (see Fay, 1996). For scores='general' the 
user must supply the function (dqfunc) which represents the density function of the inverse distribution function 
of the error. For example, scores='general' with dqfunc equal to <code>function(x){ dnorm(qnorm(x))}</code> gives 
the same results as scores='normal' or with dqfunc equal to <code>function(x){ dlogis(qlogis(x))}</code> gives 
the same results (theoretically, but perhaps not exactly when calculated) as scores='wmw'. 
</p>
<p>For censored data two common likelihoods are the 
marginal likelihood of the ranks and the 
likelihood with nuisance parameters for the 
baseline survival. Here we use the latter 
likelihood (as in Finkelstein, 1986, Fay, 1996,
and Sun, 1996). 
</p>
<p>Because of theoretical difficulties (discussed below), the default method (method=NULL with methodRule=<code><a href="#topic+methodRuleIC1">methodRuleIC1</a></code>) is to
perform a permutation test on the scores. There are several ways to perform the permutation 
test, and the function <code><a href="#topic+methodRuleIC1">methodRuleIC1</a></code> chooses which of these ways will be used. The choice
is basically between using a permutational central limit theorem (method=&quot;pclt&quot;) or using an exact method. 
There are several algorithms for the exact method (see <code><a href="perm.html#topic+permTS">perm</a></code> ). Note that there are two 
exact two-sided methods and the default is to essentially double the smaller of the one-sided p-values (tsmethod='central'), while the 
default in the <code>coin</code> package is different (see <code><a href="#topic+mControl">mControl</a></code> and the tsmethod option).  
</p>
<p>Another method is to perform a standard score test (method=&quot;scoretest&quot;).
It is difficult to prove the asymptotic validity of the standard
score tests for this likelihood because the 
number of nuisance parameters typically grows with
the sample size and often many of 
the parameters are equal at the nonparametric 
MLE, i.e., they are on the boundary of the 
parameter space (Fay, 1996). Specifically, when the score test is performed then 
an adjustment is made so that the nuisance parameters are defined based on the data and do not approach 
the boundary of the parameter space (see Fay, 1996).  Theoretically, the score test should perform well when there are 
many individuals but few observation times, and its advantage in this situation is that it retains validity even when 
the censoring mechanism
may depend on the treatment.   
</p>
<p>Another method is to use multiple imputation, or within subject resampling (method=&quot;wsr.HLY&quot;) (Huang, Lee, and Yu, 2008). 
This method samples interval censored observations from the nonparametric distribution, then performs the usual 
martingale-based variance. A different possibility is to use a permutational central limit theorem variance for each
wsr (method=&quot;wsr.pclt&quot;) or use Monte Carlo replications to get an possibly exact method from each
within subject resampling (method=&quot;wsr.mc&quot;).  
</p>
<p>Note that when icfit and ictest are used on right 
censored data, because of the method of estimating
variance is different, even Sun's method does not
produce exactly the standard logrank test results. 
</p>
<p>Fay and Shaw (2010) gives the mathematical expressions for the different tests.
</p>
<p>Note that the default method performs reasonably well even when the assessment times depend on the treatment (see Fay and Shih, 2012, Fay and Hunsberger, 2013).
If your primary concern is with retaining type I error and you do not mind conservativeness, then the wsr.pclt or wsr.mc methods can be used.
</p>


<h3>Value</h3>

<p>The function <code>wlr_trafo</code> returns only the numeric vector of scores, while 
<code>ictest</code> returns an object of class &lsquo;ictest&rsquo;, which is a list with the following values. 
</p>
<table>
<tr><td><code>scores</code></td>
<td>

<p>This is a vector the same length as L and R, containing the rank scores (i.e., the ci values 
in Fay, 1999 equation 2). These scores are calculated by <code>wlr_trafo</code>. </p>
</td></tr>
<tr><td><code>U</code></td>
<td>

<p>The efficient score vector. When group is a factor 
or character vector then each element of U has the 
interpretation as the weighted sum of &quot;observed&quot; minus
&quot;expected&quot; deaths for the group element defined by the 
label of U. Thus negative values indicate better than average
survival (see Fay, 1999). </p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p> number of observations in each group </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> full description of the test </p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p> description of data variables</p>
</td></tr> 
<tr><td><code>algorithm</code></td>
<td>
<p> character vector giving algorithm used in calculation, 
value of <code>method</code> or 
of  result of <code>methodRule</code>. One of  
&lsquo;pclt&rsquo;, 'exact.network', etc.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p> either the chi-square or Z statistic, or NULL for exact methods</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom for chi-square statistic</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis</p>
</td></tr>
<tr><td><code>alt.phrase</code></td>
<td>
<p> phrase used to describe the alternative hypothesis </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p value associated with alternative</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p> vector of p-values under different alternatives</p>
</td></tr> 
<tr><td><code>p.conf.int</code></td>
<td>
<p> confidence interval on p.value, for method='exact.mc' only </p>
</td></tr>
<tr><td><code>nmc</code></td>
<td>
<p>number of Monte Carlo replications, for method='exact.mc' only </p>
</td></tr>
<tr><td><code>nwsr</code></td>
<td>
<p>number of within subject resamplings, for WSR methods only</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>covariance matrix for U, output for method='scoretest' only</p>
</td></tr>
<tr><td><code>d2L.dB2</code></td>
<td>
<p>second derivative of log likelihood with respect to beta,output for method='scoretest' only </p>
</td></tr>
<tr><td><code>d2L.dgam2</code></td>
<td>
<p>second derivative of log likelihood with respect to gamma, output for method='scoretest' only</p>
</td></tr>
<tr><td><code>d2L.dBdgam</code></td>
<td>
<p>derivative of log likelihood with respect to beta and  gamma, output for method='scoretest' only</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>output of test statistic from permutation method, difference in means in scores, output only for permutation methods</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>0, null value of test statistics from permutation method, output only with permutation methods</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>number of permutation replications within each WSR, for method='wsr.mc' only</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object of class 'icfit' giving results of NPMLE of all responses combined (ignoring group variable)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Because the input of <code>icFIT</code> is only for saving computational time, 
no checks are made to determine if the <code>icFIT</code> is in fact the correct one. Thus you may get 
wrong answers with no warnings if you input the wrong <code>icFIT</code> object. The safer way to save 
computational time is to input into <code>initfit</code> either a precalculated <code>icfit</code> object  or 
an icsurv object from a function in the <code>Icens</code> package such as <code><a href="Icens.html#topic+EMICM">EMICM</a></code>. 
When this is done, you will get either the correct answer or a warning even when you input a bad guess for the 
<code>initfit</code>. Additionally, you may specify a function name for <code>initfit</code>. The default is NULL which 
uses a simple initial fit function (it is a weighted average of the A matrix, see <code>icfit.default</code> code). 
A fast but somewhat unstable function uses <code><a href="#topic+initcomputeMLE">initcomputeMLE</a></code> 
which uses the <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> function from the 'MLEcens' 
package.
See help for <code><a href="#topic+icfit">icfit</a></code> for details on the <code>initfit</code> option.</p>


<h3>Note</h3>

<p>The 
<code>rho</code> argument 
gives the scores which match the scores from the 
<code><a href="survival.html#topic+survdiff">survdiff</a></code> function, so that when rho=0 then scores=&quot;logrank1&quot;,
and when rho=1 then scores=&quot;wmw&quot;. 
These scores will exactly match those used in survdiff,
but the function <code>survdiff</code> uses an asymptotic method 
based on the score test to calculate p-values, while <code>ictest</code> uses 
permutation methods to calculate 
the p-values, so that the p-values will not match exactly.
The <code>rho</code> argument overides the <code>scores</code> argument,
so that  if <code>rho</code> is not NULL then <code>scores</code> is ignored.
</p>


<h3>Author(s)</h3>

<p> Michael P. Fay </p>


<h3>References</h3>

<p>    Fay, MP (1996). &quot;Rank invariant tests for interval 
censored data under the grouped continuous model&quot;.
Biometrics, 52: 811-822.
</p>
<p>Fay, MP (1999). &quot;Comparing Several Score Tests for 
Interval Censored Data.&quot; Statistics in Medicine,
18: 273-285 (Correction: 1999, 18: 2681).
</p>
<p>Fay, MP and Shaw, PA (2010). Exact and Asymptotic Weighted Logrank Tests for Interval Censored Data: The interval R package.
Journal of Statistical Software. <a href="https://doi.org/10.18637/jss.v036.i02">doi:10.18637/jss.v036.i02</a>. 36 (2):1-34.
</p>
<p>Fay, MP and Shih JH. (2012). Weighted Logrank Tests for Interval Censored Data when Assessment Times Depend on Treatment. Statistics in Medicine 31, 3760-3772.
</p>
<p>Fay, MP and Hunsberger, SA. (2013). Practical Issues on Using Weighted Logrank Tests with Interval Censored Events in Clinical Trials. Chapter 13 in Interval-Censored Time-to-Event Data: Methods and Applications, Chen, D-G, Sun, J, and Peace, KE (editors) Chapman and Hall/CRC. 
</p>
<p>Finkelstein, DM (1986). &quot;A proportional hazards 
model for interval censored failure time data&quot;
Biometrics, 42: 845-854.
</p>
<p>Huang, J, Lee, C, Yu, Q (2008). &quot;A generalized log-rank test for interval-censored failure time 
data via multiple imputation&quot; Statistics in Medicine, 27: 3217-3226.
</p>
<p>Sun, J (1996). &quot;A non-parametric test for interval
censored failure time data with applications to 
AIDS studies&quot;. Statistics in Medicine, 15: 1387-1395. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+icfit">icfit</a></code>, <code><a href="Icens.html#topic+EMICM">EMICM</a></code>, <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## perform a logrank-type test using the permutation form of the test
data(bcos)
testresult&lt;-ictest(Surv(left,right,type="interval2")~treatment, scores="logrank1",data=bcos)
testresult
## perform a Wilcoxon rank sum-type test
## using asymptotic permutation variance
left&lt;-bcos$left
right&lt;-bcos$right
trt&lt;-bcos$treatment
## save time by using previous fit
ictest(left,right,trt, initfit=testresult$fit, method="pclt",scores="wmw")
</code></pre>

<hr>
<h2 id='initcomputeMLE'>functions to calculate initial NPMLE of the distribution</h2><span id='topic+initcomputeMLE'></span><span id='topic+initEMICM'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+icfit">icfit</a></code> calculates the NPMLE of a distribution for interval censored data using an E-M algorithm 
with polishing and checking the Kuhn-Tucker conditions (see <code><a href="#topic+icfit">icfit</a></code> help details). 
It allows functions for the initfit option in order to calculate the starting value of the distribution in the E-M algorithm. 
Because <code><a href="#topic+icfit">icfit</a></code> checks the Kuhn-Tucker conditions, we can try functions without doing extensive quality control,
since if the starting distribution is not close to the true NPMLE the only downside is a slower convergence. But if the 
initfit function is the true NPMLE then convergence happens on the first iteration. Functions must input 5 objects, L,R, Lin, Rin, 
and A, but need not use all of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initcomputeMLE(L,R,Lin,Rin,A=NULL,max.inner=10,max.outer=1000,tol=1e-9)
initEMICM(L=NULL,R=NULL,Lin=NULL,Rin=NULL,A=NULL,maxiter=1000,tol=1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initcomputeMLE_+3A_l">L</code></td>
<td>
<p>numeric vector of left endpoints of censoring interval (equivalent to first element of Surv when type='interval2', see <code><a href="#topic+icfit">icfit</a></code> details)</p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_r">R</code></td>
<td>
<p>numeric vector of right endpoints of censoring interval (equivalent to second element of Surv function when type='interval2', see <code><a href="#topic+icfit">icfit</a></code> details)</p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_lin">Lin</code></td>
<td>
<p>logical vector, should L be included in the interval? (see <code><a href="#topic+icfit">icfit</a></code> details)</p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_rin">Rin</code></td>
<td>
<p>logical vector, should R be included in the interval? (see <code><a href="#topic+icfit">icfit</a></code> details)</p>
</td></tr> 
<tr><td><code id="initcomputeMLE_+3A_a">A</code></td>
<td>
<p>clique matrix</p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_max.inner">max.inner</code></td>
<td>
<p>see <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> </p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_max.outer">max.outer</code></td>
<td>
<p>see <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> </p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_tol">tol</code></td>
<td>
<p>see either <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> or  <code><a href="Icens.html#topic+EMICM">EMICM</a></code> </p>
</td></tr>
<tr><td><code id="initcomputeMLE_+3A_maxiter">maxiter</code></td>
<td>
<p>see <code><a href="Icens.html#topic+EMICM">EMICM</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to work correctly within <code><a href="#topic+icfit">icfit</a></code> the function should output a list with at least a 'pf' element 
giving the estimated mass of the distribution for a series of intervals. 
Further, if an 'intmap' element is included (describing the series of intervals) it will be used by <code><a href="#topic+icfit">icfit</a></code>.
</p>


<h3>Value</h3>

<p>The function <code>initcomputeMLE</code> outputs an icfit object with 'pf' and 'intmap' values and some other values
defined in  the help for <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code>.
</p>
<p>The function <code>initEMICM</code> outputs an icsurv object with a 'pf' element but no 'intmap' element, in addition to 
some other values defined in the help for <code><a href="Icens.html#topic+EMICM">EMICM</a></code>. 
</p>
<p>Here we define pf and intmap:
</p>
<table>
<tr><td><code>pf</code></td>
<td>
<p>vector of estimated probabilities of the distribution</p>
</td></tr>
<tr><td><code>intmap</code></td>
<td>
<p>2 by k matrix, where the ith column defines an interval 
corresponding to the probability, pf[i]</p>
</td></tr> 
</table>


<h3>Warning</h3>

<p>In rare cases the  <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> function (and hence the  <code>initcomputeMLE</code> function) can cause R to crash 
(at least for version 0.1-3 of the <code>MLEcens</code> package).
</p>


<h3>Author(s)</h3>

<p>The wrappers for the functions were written by M. Fay, but the real work are the calculation engines:
</p>
<p>The calculation engine for <code>initcomputeMLE</code> is <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code> and was written by Marloes Maathuis, with  
part of the code for the optimization step is adapted from code that was written by Piet Groeneboom.
</p>
<p>The calculation engine for <code>initEMICM</code> is <code><a href="Icens.html#topic+EMICM">EMICM</a></code> and was written by Alain Vandal and Robert Gentleman 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+icfit">icfit</a></code>,   <code><a href="MLEcens.html#topic+computeMLE">computeMLE</a></code>,  <code><a href="Icens.html#topic+EMICM">EMICM</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## If you want speed and trust the MLEcens package, then there is no need to use icfit at all
## (but the convergence checks in icfit do not take much additional time)
data(bcos)
fit&lt;-initcomputeMLE(bcos$left,bcos$right)
summary(fit)
plot(fit)
</code></pre>

<hr>
<h2 id='interval-internal'>
Internal functions
</h2><span id='topic+icScoreTest'></span><span id='topic+icWSR'></span><span id='topic+scoresFromFit'></span><span id='topic+wsrHLYpclt'></span><span id='topic+wsrMC'></span><span id='topic+icfitBootCI'></span>

<h3>Description</h3>

<p>Functions mostly called by <code><a href="#topic+ictest">ictest</a></code>. Not to be directly called by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icScoreTest(icFIT, group, scores, alternative = "two.sided", tol.svd = 10^-8)
icWSR(fit, group, scores, alternative, type, control)
wsrHLYpclt(A, p, x, group, alternative, nwsr, type, RHO)
wsrMC(A, p, x, group, alternative, nwsr, np, digits = 12)
scoresFromFit(icFIT, scores, dqfunc=NULL)
icfitBootCI(L,R,conf.level=.95,B=100,timeEpsilon=10^-8,seed=19439101,messages=TRUE,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval-internal_+3A_icfit">icFIT</code></td>
<td>
<p>icfit object from all the data</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_group">group</code></td>
<td>
<p>group vector, either numeric or character</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_scores">scores</code></td>
<td>
<p>either 'logrank1', 'logrank2', or 'wmw'</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_alternative">alternative</code></td>
<td>
<p>either 'less','greater','two.sided', or 'two.sidedAbs'</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_tol.svd">tol.svd</code></td>
<td>
<p>small number, values less than that set to zero in svd</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_fit">fit</code></td>
<td>
<p>icfit object from all the data</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_type">type</code></td>
<td>
<p>either 'wsr.pclt','wsr.HLY', or 'wsr.mc'</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_control">control</code></td>
<td>
<p>list passing options to function, see <code><a href="#topic+mControl">mControl</a></code> </p>
</td></tr>
<tr><td><code id="interval-internal_+3A_nwsr">nwsr</code></td>
<td>
<p>number of within subject resamples</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_np">np</code></td>
<td>
<p>number of permutation replications within each wsr</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_digits">digits</code></td>
<td>
<p>for ties, treat values as tied when matched to this number of digits</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_a">A</code></td>
<td>
<p>A matrix from icfit object on all data</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_p">p</code></td>
<td>
<p>pf vector from icfit object on all data</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_x">x</code></td>
<td>
<p>vector of scores associated with each value of p</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_dqfunc">dqfunc</code></td>
<td>
<p>function, density of the results of the quantile function, e.g., function(x)dnorm(qnorm(x)) (used for 'general' scores, 
see <code><a href="#topic+ictest">ictest</a></code>)</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_l">L</code></td>
<td>
<p>left endpoints</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_r">R</code></td>
<td>
<p>right endpoints</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for two-sided confidence interval</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_timeepsilon">timeEpsilon</code></td>
<td>
<p>small amount of time added or subtracted from times, for plotting confidence intervals</p>
</td></tr>
<tr><td><code id="interval-internal_+3A_seed">seed</code></td>
<td>
<p>numeric, if non-NULL then calls set.seed for bootstrap so it will be repeatable.</p>
</td></tr>
</table>

<hr>
<h2 id='mControl'>Auxiliary for feeding parameters to different methods</h2><span id='topic+mControl'></span>

<h3>Description</h3>

<p>A function to create a list of arguments for <code><a href="#topic+ictest">ictest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mControl(cm=NULL,nmc=10^3-1,seed=1234321,digits=12,p.conf.level=.99,
    setSEED=TRUE,tol.svd=10^-8,nwsr=10^3-1,np=10^3-1,tsmethod="central")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mControl_+3A_cm">cm</code></td>
<td>
<p>a choose(n,m) by n matrix, used if method='exact.ce', ignored otherwise</p>
</td></tr>
<tr><td><code id="mControl_+3A_nmc">nmc</code></td>
<td>
<p>number of Monte Carlo replications, used if method='exact.mc', ignored otherwise</p>
</td></tr>
<tr><td><code id="mControl_+3A_seed">seed</code></td>
<td>
<p>value used in <code>set.seed</code> if method='exact.mc', or any of three wsr methods, ignored otherwise</p>
</td></tr> 
<tr><td><code id="mControl_+3A_setseed">setSEED</code></td>
<td>
<p>logical, set to FALSE when performing simulations</p>
</td></tr>
<tr><td><code id="mControl_+3A_p.conf.level">p.conf.level</code></td>
<td>
<p>confidence level for p value estimate, used if method='exact.mc', ignored otherwise </p>
</td></tr>
<tr><td><code id="mControl_+3A_digits">digits</code></td>
<td>
<p>number of digits to use in <code><a href="base.html#topic+signif">signif</a></code> for precision of test statistics</p>
</td></tr>
<tr><td><code id="mControl_+3A_tol.svd">tol.svd</code></td>
<td>
<p>tolerance for use in calculating g-inverse, values less than tol.svd are set to zero, used when method='scoretest'</p>
</td></tr>
<tr><td><code id="mControl_+3A_nwsr">nwsr</code></td>
<td>
<p>number of within subject resamples, used when method='wsr.mc', 'wsr.HLY', or 'wsr.pclt'</p>
</td></tr>
<tr><td><code id="mControl_+3A_np">np</code></td>
<td>
<p>number of permutation replications within each wsr, used when method='wsr.mc'</p>
</td></tr>
<tr><td><code id="mControl_+3A_tsmethod">tsmethod</code></td>
<td>
<p>two-sided method for exact permutation tests, either 'central' or 'abs' (see <code><a href="perm.html#topic+permControl">permControl</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>cm</code>=NULL the resulting matrix is created by <code><a href="perm.html#topic+chooseMatrix">chooseMatrix</a></code>, it may be optionally provided here 
only so that <code>chooseMatrix</code> does not need to be repeatedly called in simulations.  
Also when doing simulations (with
method='exact.mc' or any of the wsr methods), use setSEED=FALSE so that the seed 
is not reset to the same value each time you call the function.
</p>
<p>See <code><a href="perm.html#topic+calcPvalsMC">calcPvalsMC</a></code> for description of how p.conf.level is used. 
</p>


<h3>Value</h3>

<p>An list with the arguments as components.
</p>

<hr>
<h2 id='methodRuleIC1'>Rule for determining method for ictest</h2><span id='topic+methodRuleIC1'></span>

<h3>Description</h3>

<p>This is the default function which determines which permutation method (e.g., &lsquo;pclt&rsquo; or &lsquo;exact.network&rsquo;) to use in <code><a href="#topic+ictest">ictest</a></code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methodRuleIC1(x, group, exact, Nbound = c(20))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methodRuleIC1_+3A_x">x</code></td>
<td>
<p>vector of response scores  </p>
</td></tr>
<tr><td><code id="methodRuleIC1_+3A_group">group</code></td>
<td>
<p>group membership vector</p>
</td></tr>
<tr><td><code id="methodRuleIC1_+3A_exact">exact</code></td>
<td>
<p>logical, TRUE=exact method chosen, FALSE=pclt</p>
</td></tr>
<tr><td><code id="methodRuleIC1_+3A_nbound">Nbound</code></td>
<td>
<p>bound, if n&gt;Nbound then method='pclt' otherwise either 'exact.mc' (for k-sample or trend) 
or 'exact.network' (for two-sample)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines which of several methods will be used in 
<code><a href="#topic+ictest">ictest</a></code>, see <code><a href="perm.html#topic+permTS">permTS</a></code> for description of methods. 
</p>
<p>When exact=FALSE then returns 'pclt'. When exact=TRUE then returns either 'exact.network' if the 
length(cc)&lt;=Nbound and it is a two-sample test or 'exact.mc' otherwise. When exact=NULL and the 
length(cc)&lt;=Nbound, then returns either 'exact.network' (for two-sample) or 'exact.mc' (for k-sample 
and trend). When exact=NULL and length(cc)&gt;Nbound returns 'pclt'.
</p>


<h3>Value</h3>

<p>a character vector with one of the following values: &quot;pclt&quot;,&quot;exact.network&quot;,&quot;exact.mc&quot;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ictest">ictest</a></code></p>

<hr>
<h2 id='plot.icfit'>Plot icfit object </h2><span id='topic+plot.icfit'></span>

<h3>Description</h3>

<p>Plots either the survival distributions, the cumulative distributions, or a transformation of the cumulative distributions,
from an <code>icfit</code> object. If there is more than one strata,
all strata will be plotted. Note that for interval censored data, the changes in the 
NPMLE of the survival function usually do not occur at unique points but occur within some interval
where any of an infinite number of curves will maximize the likelihood. We show those intervals 
were the NPMLE is indeterminate as a gray rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icfit'
plot(x,XLAB="time",YLAB=NULL,COL=gray((8:1)*.1),LTY=1:9,LEGEND=NULL,
    XLEG=NULL,YLEG=NULL,shade=TRUE,dtype="survival",
    dlink=function(x){log(-log(1-x))}, xscale=1, yscale=1, conf.int=NULL,
    estpar=list( lty=NULL, lwd=1, col=gray(0)),
    cipar=list( lty=1:9, lwd=1, col=gray(0.8)),
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.icfit_+3A_x">x</code></td>
<td>
<p>an icfit object, see <code><a href="#topic+icfit">icfit</a></code></p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_xlab">XLAB</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_ylab">YLAB</code></td>
<td>
<p>y label, if NULL label matches dtype</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_col">COL</code></td>
<td>
<p>a vector representing color of rectangles of indeterminate NPMLE, COL[i] used for ith strata</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_lty">LTY</code></td>
<td>
<p>a vector for lty values for lines, LTY[i] used for ith strata</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_legend">LEGEND</code></td>
<td>
<p>logical value, include legend or not, if NULL set to TRUE only if number of strata&gt;1</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_xleg">XLEG</code></td>
<td>
<p>x location for legend, if NULL then gives maximum of 0 and minimum time from intmap</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_yleg">YLEG</code></td>
<td>
<p>y location for legend</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_shade">shade</code></td>
<td>
<p>logical, should the rectangles of indeterminate NPMLE be colored?</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_dtype">dtype</code></td>
<td>
<p>type of distribution plotted, one of 'survival', 'cdf' or 'link' (see details)</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_dlink">dlink</code></td>
<td>
<p>link function when dtype='link' (see details)</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_xscale">xscale</code></td>
<td>
<p>a numeric value used to multiply the labels on the x axis. So if the data are in days, then a value of 1/365.25 would give labels in years.</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_yscale">yscale</code></td>
<td>
<p>a numeric value used to multiply the labels on the y axis. A value of 100, for instance, would be used to give a percent scale. As in the survival package, only the labels are changed, 
not the actual plot coordinates</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_conf.int">conf.int</code></td>
<td>
<p>logical, should confidence intervals be plotted? NULL plots them if they are present in x object and gives no errors if they are not.</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_estpar">estpar</code></td>
<td>
<p>list of par arguments for the estimated distribution lines. If lty=NULL uses LTY argument, otherwise ignores LTY (for backward compatability)</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_cipar">cipar</code></td>
<td>
<p>list of par arguments for the confidence interval lines</p>
</td></tr>
<tr><td><code id="plot.icfit_+3A_...">...</code></td>
<td>
<p>other arguments passed to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Turnbull (1976) noted that the NPMLE was not unique within a certain set of intervals. We represent that non-uniqueness 
using colored rectangles when <code>shade=TRUE</code>. The option <code>shade=TRUE</code> is not supported when dtype=&quot;link&quot;.
</p>
<p>The option <code>dtype="cdf"</code> plots the cumulative distribution function.
</p>
<p>When there are several strata, different types of weighted logrank-type tests (see <code><a href="#topic+ictest">ictest</a></code>) may be derived from score statistics under the 
grouped continuous model with error distribution known. To test which test is appropriate, one may plot the cumulative distribution for 
each stratum transformed by the inverse of the proposed error distribution  (see Fay, 1996).  These are plotted with dtype=&quot;link&quot; where dlink is the link function which 
transforms the cdf. The &quot;wmw&quot; scores correspond to <code>dlink=qlogis</code>, the &quot;logrank2&quot; scores correspond to the default complementary log-log  dlink, 
and the &quot;normal&quot; scores correspond to <code>dlink=qnorm</code>.
</p>


<h3>Value</h3>

<p>Returns a list of arguments for the legend. Values are x,y, legend, fill, lty. See <code><a href="graphics.html#topic+legend">legend</a></code> help.
</p>


<h3>Note</h3>

<p>An object of class 'icsurv' from the <code>Icens</code> package can use this plot function by redefining its class to 'icfit' and 'plot.icfit' will work on it.</p>


<h3>References</h3>

 
<p>Fay, MP (1996). Rank invariant tests for interval censored data 
under the grouped continuous model. Biometrics. 52: 811-822.
</p>
<p>Turnbull, B.W. (1976) The empirical distribution function 
with arbitrarily grouped, censored and truncated data. 
J. R. Statist.  Soc. B 38, 290-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icfit">icfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcos)
fit1&lt;-icfit(Surv(left,right,type="interval2")~treatment,data=bcos)
summary(fit1)
plot(fit1)
 </code></pre>

<hr>
<h2 id='summary.icfit'>Methods for icfit objects</h2><span id='topic+summary.icfit'></span><span id='topic+print.icfit'></span><span id='topic++5B.icfit'></span>

<h3>Description</h3>

<p>The print method prints as a list, except the A (clique) matrix. The summary method prints the masses an associated maps for the fit. The 
[ method allows picking out of specific fits for individual elements of the factor when the right hand side of the formula in <code>icfit</code> 
was a factor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'icfit'
summary(object, digits=4,  ...)

## S3 method for class 'icfit'
print(x, ...)

## S3 method for class 'icfit'
x[i]

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.icfit_+3A_object">object</code></td>
<td>
<p>an icfit object</p>
</td></tr>
<tr><td><code id="summary.icfit_+3A_x">x</code></td>
<td>
<p>an icfit object</p>
</td></tr>
<tr><td><code id="summary.icfit_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding results</p>
</td></tr>
<tr><td><code id="summary.icfit_+3A_i">i</code></td>
<td>
<p>scalar integer to pick ith strata</p>
</td></tr>
<tr><td><code id="summary.icfit_+3A_...">...</code></td>
<td>
<p>arguments to be passed</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+ictest">ictest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcos)
icout&lt;-icfit(Surv(left,right,type="interval2")~treatment, data=bcos)
print(icout)
summary(icout)
icout[1]
</code></pre>

<hr>
<h2 id='SurvLR'>Transform Surv object to data frame with L and R values</h2><span id='topic+SurvLR'></span>

<h3>Description</h3>

<p>Takes a <code><a href="survival.html#topic+Surv">Surv</a></code> object and transforms it into a data frame with
two variables, L and R, representing the left and right interval of interval censored 
data. The failure time is known to be in the interval (L,R]. Right censored data 
are handled by setting L=R for observed and R=Inf for right censored.  These are interpreted correctly 
by <code><a href="#topic+icfit">icfit</a></code> and <code><a href="#topic+ictest">ictest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvLR(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurvLR_+3A_x">x</code></td>
<td>
<p>a <code><a href="survival.html#topic+Surv">Surv</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently type='counting' not supported.</p>


<h3>Value</h3>

<p>A data frame with two variables:
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>left end of interval</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>right end of interval</p>
</td></tr>
</table>


<h3>See Also</h3>

<p> Called from <code><a href="#topic+icfit">icfit</a></code> and <code><a href="#topic+ictest">ictest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>time&lt;-c(1,5,3,7)
status&lt;-c(1,1,0,1)
y&lt;-Surv(time,status)
SurvLR(y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
